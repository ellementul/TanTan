(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
(function (process){
// .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,
// backported and transplited with Babel, with backwards-compat fixes

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function (path) {
  if (typeof path !== 'string') path = path + '';
  if (path.length === 0) return '.';
  var code = path.charCodeAt(0);
  var hasRoot = code === 47 /*/*/;
  var end = -1;
  var matchedSlash = true;
  for (var i = path.length - 1; i >= 1; --i) {
    code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        if (!matchedSlash) {
          end = i;
          break;
        }
      } else {
      // We saw the first non-path separator
      matchedSlash = false;
    }
  }

  if (end === -1) return hasRoot ? '/' : '.';
  if (hasRoot && end === 1) {
    // return '//';
    // Backwards-compat fix:
    return '/';
  }
  return path.slice(0, end);
};

function basename(path) {
  if (typeof path !== 'string') path = path + '';

  var start = 0;
  var end = -1;
  var matchedSlash = true;
  var i;

  for (i = path.length - 1; i >= 0; --i) {
    if (path.charCodeAt(i) === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // path component
      matchedSlash = false;
      end = i + 1;
    }
  }

  if (end === -1) return '';
  return path.slice(start, end);
}

// Uses a mixed approach for backwards-compatibility, as ext behavior changed
// in new Node.js versions, so only basename() above is backported here
exports.basename = function (path, ext) {
  var f = basename(path);
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};

exports.extname = function (path) {
  if (typeof path !== 'string') path = path + '';
  var startDot = -1;
  var startPart = 0;
  var end = -1;
  var matchedSlash = true;
  // Track the state of characters (if any) we see before our first dot and
  // after any path separator we find
  var preDotState = 0;
  for (var i = path.length - 1; i >= 0; --i) {
    var code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
    if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // extension
      matchedSlash = false;
      end = i + 1;
    }
    if (code === 46 /*.*/) {
        // If this is our first dot, mark it as the start of our extension
        if (startDot === -1)
          startDot = i;
        else if (preDotState !== 1)
          preDotState = 1;
    } else if (startDot !== -1) {
      // We saw a non-dot and non-path separator before our dot, so we should
      // have a good chance at having a non-empty extension
      preDotState = -1;
    }
  }

  if (startDot === -1 || end === -1 ||
      // We saw a non-dot character immediately before the dot
      preDotState === 0 ||
      // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return '';
  }
  return path.slice(startDot, end);
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require('_process'))

},{"_process":2}],2:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],3:[function(require,module,exports){
(function (global){
/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.4.1',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) {
			// in Node.js, io.js, or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else {
			// in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else {
		// in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],4:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

},{}],5:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

},{}],6:[function(require,module,exports){
'use strict';

exports.decode = exports.parse = require('./decode');
exports.encode = exports.stringify = require('./encode');

},{"./decode":4,"./encode":5}],7:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var punycode = require('punycode');
var util = require('./util');

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter =
          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      util.isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};

},{"./util":8,"punycode":3,"querystring":6}],8:[function(require,module,exports){
'use strict';

module.exports = {
  isString: function(arg) {
    return typeof(arg) === 'string';
  },
  isObject: function(arg) {
    return typeof(arg) === 'object' && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};

},{}],9:[function(require,module,exports){
require("../lib/mof.js");

const Base64 = require("js-base64").Base64;

const PIXI = require("pixi.js");

const CrInterfice = require("AsynCommun").CrCommunicator;
const CrInterWs = require("../lib/ws_client.js");

const CrSession = require("../src/session.js");
const CrKeyboard = require("./keyboard.js");
const CrDisplay = require("./display.js");

const Map_data = require("../src/map.json");

var onlyClient = false;

var url = 'ws://192.168.1.77:8081';


CrGame(onlyClient, url, Map_data);


function CrGame(onlyClient, game_url, Map_data){

	/*if(onlyClient)
		
		var Session = new CrSession(Map_data);
		
		var InterDisp = new CrInterfice();
		
		CrKeyboard(InterDisp.connect(CrDisplay()), [65, 68, 83, 87, 32]);
		InterDisp.login = "Gamer1";
		
		Session.Connect(InterDisp);
		

		InterDisp = new CrInterfice();
		
		CrKeyboard(InterDisp.connect(function(){}), [37, 38, 39, 40, 45]);
		InterDisp.login = "Gamer2";
		
		Session.Connect(InterDisp);
		
	*/
	var InterWs = CrInterWs(game_url);
	var Display =  CrDisplay();
	var Output = InterWs.connect(Display.input);
	Display.output = Output;
	CrKeyboard(Output, [65, 68, 83, 87, 37, 38, 39, 40, 32, 45]);

	
}

function Crlog(head){
	return function(str, val){
		if(val.action != "Stat") console.log(head, str, val);
	}
}

},{"../lib/mof.js":13,"../lib/ws_client.js":14,"../src/map.json":230,"../src/session.js":231,"./display.js":10,"./keyboard.js":12,"AsynCommun":20,"js-base64":26,"pixi.js":162}],10:[function(require,module,exports){
const CrGui = require("./gui.js");

function CrDisplay(){
	var Input = CrHoarder();
	
	var Stat = {data: {}};
	var World = null;
	var List = {};
	
	let app = new PIXI.Application(window.innerHeight, window.innerHeight, {backgroundColor : 0x000000});
	const gui = CrGui(app.view);

//===============PreLoadTiles========================

	var Tiles = [];

	function drawSvg(svg_str){
		var img = document.createElement('img');
		img.src = "data:image/svg+xml;base64,"+ Base64.encode(svg_str);
		return PIXI.Sprite.from(img);
	}

	function AddTile(tile){
		tile.images = tile.images.map(drawSvg);
		Tiles[tile.id] = tile;
	}
	
	function LoadTiles(mess){
		mess.tiles.forEach(AddTile);
		ReadyTiles();
	}
	

//==================INPUT===============	
	
	this.input =  function(val){
		InputMess(val);
	}

	return this;

	function InputMess(mess){
		switch(mess.type){
			case "Actor": InputActors(mess); break;
			case "GUI": gui.update(mess); break;
			case "Tiles":  InputTiles(mess); break;
			case "Map":  InputMap(mess); break;
			default: console.error("Mess of Unknowed type", mess); 
		}
	}

	function InputTiles(mess){
		switch(mess.action){
			case "Create":  LoadTiles(mess); break;
			case "Add": AddTile(mess.tile); break;
			default: console.error("Mess of Unknowed action", mess);
		}
	}

	function InputMap(mess){
		switch(mess.action){
			case "Create":  CrMap(mess); break;
			default: console.error("Mess of Unknowed action", mess);
		}
	}

	function InputActors(mess){
		switch(mess.action){
			case "Create": CrObj(mess); break;
			case "Update": UpObj(mess); break;
			case "Dell": DellObj(mess); break;
			default: console.error("Mess of Unknowed action", mess);
		}
	}

	function ReadyTiles(){
		this.output({
			action: "ReadyLoad",
			type: "Tiles"
		});
	}

	function ReadyMap(){
		this.output({
			action: "ReadyLoad",
			type: "Map"
		});
	}

//===============Objects==================
	
	function CrObj(mess){
		switch(mess.type){
			case "Tiles": LoadTiles(mess); break;
			case "Map": CrMap(mess); break;
			default : CrElem(mess); break;
		}
	}
	
	function UpObj(mess){
		switch(mess.type){
			case "Map": ; break;
			default : UpdateElem(mess); break;
		}
	}
	
	function DellObj(mess){
		switch(mess.type){
			case "Map": World.dell(); break;
			default : DellElem(mess); break;
		}
	}
	
	function CrElem(mess){
		size_cof = World.size_cof;
		
		var elem = new PIXI.Sprite(Tiles[mess.sprite].images[0].texture);
		elem.anchor.set(0.5);
		
		elem.x = mess.pos.x * size_cof;
		elem.y = mess.pos.y * size_cof;
		
		elem.width = size_cof * mess.box.w * 2;
		elem.height = size_cof * mess.box.h * 2;
		
		if(mess.dir !== undefined) elem.rotation = mess.dir * Math.PI;
		
		World.add(elem);
		
		if(!List[mess.actor_type]) List[mess.actor_type] = [];
		List[mess.actor_type][mess.id] = elem;
	}
	
	function DellElem(mess){
		List[mess.actor_type][mess.id].destroy();
		List[mess.actor_type][mess.id] = undefined;
	}
	
	function UpdateElem(mess){
		var elem = List[mess.actor_type][mess.id];
		
		if(mess.pos){
			elem.x = mess.pos.x * World.size_cof;
			elem.y = mess.pos.y * World.size_cof;
		}
		if(mess.dir !== undefined) elem.rotation = mess.dir * Math.PI;
	}

//============MAP===============

	function CrMap(mess){
		var world = new PIXI.Container();
		world.x = (window.innerWidth - window.innerHeight) / 2 ;
		app.stage.addChild(world);
		
		World = {};
		World.size_cof = window.innerHeight / mess.size; //Кофф. для перевода коорд. из серверных в дисплейные.
		World.add = function(obj){
			world.addChild(obj);
		}
		World.dell = function(){
			world.destroy();
			World = null;
		}
		
		ReadyMap();
	}
	
	
	
}

function CrHoarder(){
	var hoarder = [];
	
	var push = function(val){
		hoarder.push(val);
	};
	
	push.take = function(func){
		if(typeof func != "function") return hoarder;
		
		hoarder.forEach(function(val){
				func(val);
		});
	}
	
	return push;
}

module.exports = CrDisplay;

},{"./gui.js":11}],11:[function(require,module,exports){
module.exports = function CrGui(view){

	document.body.appendChild(view);

	return {
		update,
	}

	function update(msg){
		
		if(msg.setBackground)
			document.body.style.background = "url("+ msg.setBackground.join("/") +")";
	}
};
},{}],12:[function(require,module,exports){
function CrKeyboard(sendFunc, keys_codes){
	
	var keys_is_down = new Array(128);
	var key_timer_ids = new Array(128);
	
	document.addEventListener("keydown", eventKeyDouwn);
	document.addEventListener("keyup" , eventKeyUp);
	
	var timer = setInterval(UpdateKeys, 60)
	
	function UpdateKeys(){
		keys_is_down.forEach(function(is, i){
			if(is){
				sendKey(i);
			}
		});
	}
	
	function eventKeyDouwn(event){
		if(keys_codes.indexOf(event.keyCode) != -1){
			var key_code = event.keyCode;
			keys_is_down[key_code] = true;
		}
	}

	function eventKeyUp(event){
		if(keys_codes.indexOf(event.keyCode) == -1) return;
		
		keys_is_down[event.keyCode] = false;
	}

	function sendKey(key_code){
		var mess = {action: "Move"};
		switch(key_code){
			case 39:
			case 68: mess.dir = 0; break;
			case 40:
			case 83: mess.dir = 0.5; break;
			case 37: 
			case 65: mess.dir = 1; break;
			case 38:
			case 87: mess.dir = -0.5; break;
			case 32:
			case 45: mess.action = "Fire"; break;
		}
		sendFunc(mess);
	}
	
	function sendPing(){
		sendFunc({action: "Ping"});
	}
};

module.exports = CrKeyboard;

},{}],13:[function(require,module,exports){
"use strict";
//Version  1.1
//Craft object.protype
(function(){
	if( typeof(Object.crProp) == "function"){
		return;
	}
	
	
	function constProp(name_prop, value, vis, rewrite){
		
		if(value === undefined) value = true;
		if(vis === undefined) vis = true;

		if(typeof value === "object") Object.freeze(value);
		Object.defineProperty(this, name_prop, {
				value: value,
				enumerable: vis,
				configurable: rewrite,
				writable: rewrite,
			});
	}
	function getSet(name, getter, setter){
		if(typeof setter == "function"){
			Object.defineProperty(this, name, {
				get: getter,
				set: setter,
				enumerable: true,
				configurable: true
			});
		}else{
			Object.defineProperty(this, name, {
				get: getter,
				enumerable: true,
				configurable: true
			});
		}
	}
	
	constProp.call(Object.prototype, 'crProp', constProp, false);
	Object.prototype.crProp('addGetSet', getSet, false);
	
	
	function randIndex(){
		var rand = Math.round((this.length - 1) * Math.random());
		return this[rand];
	}
	
	function AddItem(val){
		if(!this._nulls) this._nulls = [];
		
		if(this._nulls.length){
			var ind = this._nulls.pop();
			this[ind] = val;
			return ind;
		}else{
			return this.push(val) - 1;
		}
	}
	
	function DellItem(ind){
		if(ind > this.length -1) return false;
		
		if(ind == this.length -1){
			this.pop();
		}else{
			if(!this._nulls) this._nulls = [];
			
			this[ind] = undefined;
			this._nulls.push(ind);
		}
		
		return true;	
	}
	
	function createArr(val, length, is_call){
		var arr = [];
		
		if(!length) length = 1;
		if(is_call === undefined) is_call = true;
		
		if(typeof val == 'function' && is_call){
			for(var i = 0; i < length; i++){
				arr.push(val(i, arr));
			}
		}else if(val !== undefined){
			
			for(var i = 0; i < length; i++){
				arr.push(val);
			}
		}

		arr.crProp('rand_i', randIndex);
		arr.crProp('add', AddItem);
		arr.crProp('dell', DellItem);
		
		return arr;
	}
	
	
	
	Array.crProp('create', createArr);
	
	
	if(RegExp.prototype.toJSON !== "function"){
		RegExp.prototype.toJSON = function(){ return this.source; };
	}

})();





},{}],14:[function(require,module,exports){
const CrInterfice = require("AsynCommun").CrCommunicator;

function CrInterWs(url, oneValidFunc, twoValidFunc){

	var socket = new WebSocket(url);
	var InterWs = new CrInterfice(oneValidFunc, twoValidFunc);

	socket.addEventListener('open', function (event) {
		var InFunc = InterWs.connect(function(mess){
			socket.send(JSON.stringify(mess));
		});
		
		socket.addEventListener('message', function (event) {
			InFunc(JSON.parse(event.data));
		});
	});
	
	return InterWs;
}

module.exports = CrInterWs;

},{"AsynCommun":20}],15:[function(require,module,exports){
const CrHoarder = require("./Hoarder.js");

module.exports = function CrInterfice(first_transform_func, second_transform_func){
	
	var InputOne = null;
	var OutputOne = null;
	
	this.connect = function(outputFunc){
		if(OutputOne){
			if(second_transform_func){
				var begFunc = outputFunc;
				outputFunc = function(val){
					begFunc(second_transform_func(val));
				}
			}
			return TwoConnect(outputFunc);
		}
		else{
			if(first_transform_func){
				var begFunc = outputFunc;
				outputFunc = function(val){
					begFunc(first_transform_func(val));
				}
			}
			return OneConnect(outputFunc);
		}
	};
	
	function OneConnect(outputFunc){
		OutputOne = outputFunc;
		InputOne = CrHoarder();
		
		return function(val){
			InputOne(val);
		}
	}
	
	function TwoConnect(outputFunc){
		if(InputOne.take) setTimeout(InputOne.take.bind(null, outputFunc), 0);
		InputOne = outputFunc;
		
		return OutputOne;
	}
}



},{"./Hoarder.js":17}],16:[function(require,module,exports){
const CrHoarder = require("./Hoarder.js");

module.exports = function CrConnector(comm, commTwo){
	let Hoar = CrHoarder();
	let input = msg => Hoar(msg);

	input = commTwo.connect( comm.connect(msg => input(msg)) );
	Hoar.take(input);
}
},{"./Hoarder.js":17}],17:[function(require,module,exports){
module.exports = function CrHoarder(){
	var hoarder = [];
	
	var push = function(val){
		hoarder.push(val);
	};
	
	push.take = function(func){
		setTimeout(function(){
			while(hoarder.length)
				func(hoarder.shift());
		}, 0);
	}
	
	return push;
}
},{}],18:[function(require,module,exports){
module.exports = function CrInterfice(comm){
	let pull = [];

	let staticInput = comm.connect(dynamicInput);
	
	this.connect = function(outputFunc){
		
		pull.push(outputFunc);

		return staticInput;
	};
	
	function dynamicInput(value){
		pull.forEach(func => func(value));
	}
}



},{}],19:[function(require,module,exports){
function CrRoutingInters(log){
	let adr_arr = [];

	
	let connect = function(Inter, adress){

		adr_arr[adress] = Inter.connect(Input);
		setTimeout(() => adr_arr[adress]({action: "Connected", adress: adress}), 0);
	};


	connect.log = log;
	function Input(mess){
		if(typeof(connect.log) == "function") 
			connect.log(mess);

		let adr = mess.adr;
		delete mess.adr;

		if(connect.is_freeze) 
			Object.freeze(mess);

		if(adr_arr[adr]) 
			adr_arr[adr](mess); 
		else 
			throw new Error("Func on adress(" + adr +  ") is not find!");
	}

	return connect;
}

module.exports = CrRoutingInters;

},{}],20:[function(require,module,exports){
module.exports = {
	CrHoarder: require("./Hoarder.js"),
	CrCommunicator: require("./Commun.js"),
	CrConnector: require("./Connector.js"),
	CrMultiComm: require("./MultiCommun.js"),
	CrRouter: require("./Router.js"),
};

},{"./Commun.js":15,"./Connector.js":16,"./Hoarder.js":17,"./MultiCommun.js":18,"./Router.js":19}],21:[function(require,module,exports){
const UUID = require("uuid/v5");
let namespace = require("uuid/v1")();

function CrCatalog(commun){
	let types = new Map();
	let resources = new Map();

	let send = commun.connect(input);


	function input(mess){
		
		switch(mess.action){
			case "AddType": send(addType(mess)); break;
			case "AddRes": send(addResorce(mess)); break;
			case "AddResArr": send(addResArr(mess)); break;
			case "FindRes": send(findResorce(mess)); break;
			case "FindTypeAllRes": send(findResFromType(mess)); break;
			case "RemoveRes": send(removeResorce(mess)); break;
			default: console.log(mess);
		}
	}

	function addType(mess){
		types.set(mess.type, mess.path);

		return {
			action: "AddedType",
			success: true,
			type: mess.type,
			adr: mess.source
		}
	}

	function addResorce(mess){
		
		
		let is_type = mess.resource && types.has(mess.resource.type);

		if(!is_type)
			return {
				action: "AddedRes",
				success: false,
				oldId: mess.resource ? mess.resource.id : "None",
				newId: "None",
				adr: mess.source
			}

		let uid = UUID(mess.resource.type + mess.resource.id, namespace);
		
		let resource = {
			id: uid,
			type: mess.resource.type,
			path: mess.resource.path
		};

		resources.set(uid, resource);

		return {
			action: "AddedRes",
			success: true,
			oldId: mess.resource.id,
			newId: uid,
			adr: mess.source
		}
		
	}

	function addResArr(mess){
		
		var is_type = types.has(mess.type);

		if(!is_type)
			return {
				action: "AddedRes",
				success: false,
				addedIds: [],
				adr: mess.source,
			}

		let addedIds = [];
		
		mess.resources.forEach(function(resource, i){

			let uid = UUID(resource.type + resource.id, namespace);
			
			addedIds.push({
				oldId: resource.id,
				newId: uid,
			});

			resources.set(uid, {
				id: uid,
				type: resource.type,
				path: resource.path,
			});

		});
		return {
			action: "AddedResArr",
			success: !!addedIds.length,
			addedIds,
			adr: mess.source
		}
		
	}

	function findResorce(mess){

		var is_uid = resources.has(mess.id);

		if(!is_uid)
			return {
				action: "FoundRes",
				success: false,
				id: mess.id,
				resource: null,
				fullPath: null,
				adr: mess.source
			}

		let resource = resources.get(mess.id);
		let fullPath = types.get(resource.type).concat(resource.path);

		return {
			action: "FoundRes",
			success: true,
			id: mess.id,
			resource,
			fullPath,
			adr: mess.source,
		}

	}

	function findResFromType(mess){

		let is_type = types.has(mess.type);

		if(!is_type)
			return {
				action: "FoundResArr",
				success: false,
				resources: [],
				adr: mess.source
			}

		let typePath = types.get(mess.type);
		let foundResources = [];

		resources.forEach(({id, type, path}) => {
			if(type == mess.type)
				foundResources.push({
					id,
					fullPath: typePath.concat(path),
				});
		});

		return {
			action: "FoundResArr",
			success: !!foundResources.length,
			resources: foundResources,
			adr: mess.source,
		}

	}

	function removeResorce(mess){
		return {
			action: "RemovedRes",
			success: resources.delete(mess.id),
			id: mess.id,
			adr: mess.source
		}
	}
}

module.exports = CrCatalog;
},{"uuid/v1":221,"uuid/v5":222}],22:[function(require,module,exports){
/**
 * Bit twiddling hacks for JavaScript.
 *
 * Author: Mikola Lysenko
 *
 * Ported from Stanford bit twiddling hack library:
 *    http://graphics.stanford.edu/~seander/bithacks.html
 */

"use strict"; "use restrict";

//Number of bits in an integer
var INT_BITS = 32;

//Constants
exports.INT_BITS  = INT_BITS;
exports.INT_MAX   =  0x7fffffff;
exports.INT_MIN   = -1<<(INT_BITS-1);

//Returns -1, 0, +1 depending on sign of x
exports.sign = function(v) {
  return (v > 0) - (v < 0);
}

//Computes absolute value of integer
exports.abs = function(v) {
  var mask = v >> (INT_BITS-1);
  return (v ^ mask) - mask;
}

//Computes minimum of integers x and y
exports.min = function(x, y) {
  return y ^ ((x ^ y) & -(x < y));
}

//Computes maximum of integers x and y
exports.max = function(x, y) {
  return x ^ ((x ^ y) & -(x < y));
}

//Checks if a number is a power of two
exports.isPow2 = function(v) {
  return !(v & (v-1)) && (!!v);
}

//Computes log base 2 of v
exports.log2 = function(v) {
  var r, shift;
  r =     (v > 0xFFFF) << 4; v >>>= r;
  shift = (v > 0xFF  ) << 3; v >>>= shift; r |= shift;
  shift = (v > 0xF   ) << 2; v >>>= shift; r |= shift;
  shift = (v > 0x3   ) << 1; v >>>= shift; r |= shift;
  return r | (v >> 1);
}

//Computes log base 10 of v
exports.log10 = function(v) {
  return  (v >= 1000000000) ? 9 : (v >= 100000000) ? 8 : (v >= 10000000) ? 7 :
          (v >= 1000000) ? 6 : (v >= 100000) ? 5 : (v >= 10000) ? 4 :
          (v >= 1000) ? 3 : (v >= 100) ? 2 : (v >= 10) ? 1 : 0;
}

//Counts number of bits
exports.popCount = function(v) {
  v = v - ((v >>> 1) & 0x55555555);
  v = (v & 0x33333333) + ((v >>> 2) & 0x33333333);
  return ((v + (v >>> 4) & 0xF0F0F0F) * 0x1010101) >>> 24;
}

//Counts number of trailing zeros
function countTrailingZeros(v) {
  var c = 32;
  v &= -v;
  if (v) c--;
  if (v & 0x0000FFFF) c -= 16;
  if (v & 0x00FF00FF) c -= 8;
  if (v & 0x0F0F0F0F) c -= 4;
  if (v & 0x33333333) c -= 2;
  if (v & 0x55555555) c -= 1;
  return c;
}
exports.countTrailingZeros = countTrailingZeros;

//Rounds to next power of 2
exports.nextPow2 = function(v) {
  v += v === 0;
  --v;
  v |= v >>> 1;
  v |= v >>> 2;
  v |= v >>> 4;
  v |= v >>> 8;
  v |= v >>> 16;
  return v + 1;
}

//Rounds down to previous power of 2
exports.prevPow2 = function(v) {
  v |= v >>> 1;
  v |= v >>> 2;
  v |= v >>> 4;
  v |= v >>> 8;
  v |= v >>> 16;
  return v - (v>>>1);
}

//Computes parity of word
exports.parity = function(v) {
  v ^= v >>> 16;
  v ^= v >>> 8;
  v ^= v >>> 4;
  v &= 0xf;
  return (0x6996 >>> v) & 1;
}

var REVERSE_TABLE = new Array(256);

(function(tab) {
  for(var i=0; i<256; ++i) {
    var v = i, r = i, s = 7;
    for (v >>>= 1; v; v >>>= 1) {
      r <<= 1;
      r |= v & 1;
      --s;
    }
    tab[i] = (r << s) & 0xff;
  }
})(REVERSE_TABLE);

//Reverse bits in a 32 bit word
exports.reverse = function(v) {
  return  (REVERSE_TABLE[ v         & 0xff] << 24) |
          (REVERSE_TABLE[(v >>> 8)  & 0xff] << 16) |
          (REVERSE_TABLE[(v >>> 16) & 0xff] << 8)  |
           REVERSE_TABLE[(v >>> 24) & 0xff];
}

//Interleave bits of 2 coordinates with 16 bits.  Useful for fast quadtree codes
exports.interleave2 = function(x, y) {
  x &= 0xFFFF;
  x = (x | (x << 8)) & 0x00FF00FF;
  x = (x | (x << 4)) & 0x0F0F0F0F;
  x = (x | (x << 2)) & 0x33333333;
  x = (x | (x << 1)) & 0x55555555;

  y &= 0xFFFF;
  y = (y | (y << 8)) & 0x00FF00FF;
  y = (y | (y << 4)) & 0x0F0F0F0F;
  y = (y | (y << 2)) & 0x33333333;
  y = (y | (y << 1)) & 0x55555555;

  return x | (y << 1);
}

//Extracts the nth interleaved component
exports.deinterleave2 = function(v, n) {
  v = (v >>> n) & 0x55555555;
  v = (v | (v >>> 1))  & 0x33333333;
  v = (v | (v >>> 2))  & 0x0F0F0F0F;
  v = (v | (v >>> 4))  & 0x00FF00FF;
  v = (v | (v >>> 16)) & 0x000FFFF;
  return (v << 16) >> 16;
}


//Interleave bits of 3 coordinates, each with 10 bits.  Useful for fast octree codes
exports.interleave3 = function(x, y, z) {
  x &= 0x3FF;
  x  = (x | (x<<16)) & 4278190335;
  x  = (x | (x<<8))  & 251719695;
  x  = (x | (x<<4))  & 3272356035;
  x  = (x | (x<<2))  & 1227133513;

  y &= 0x3FF;
  y  = (y | (y<<16)) & 4278190335;
  y  = (y | (y<<8))  & 251719695;
  y  = (y | (y<<4))  & 3272356035;
  y  = (y | (y<<2))  & 1227133513;
  x |= (y << 1);
  
  z &= 0x3FF;
  z  = (z | (z<<16)) & 4278190335;
  z  = (z | (z<<8))  & 251719695;
  z  = (z | (z<<4))  & 3272356035;
  z  = (z | (z<<2))  & 1227133513;
  
  return x | (z << 2);
}

//Extracts nth interleaved component of a 3-tuple
exports.deinterleave3 = function(v, n) {
  v = (v >>> n)       & 1227133513;
  v = (v | (v>>>2))   & 3272356035;
  v = (v | (v>>>4))   & 251719695;
  v = (v | (v>>>8))   & 4278190335;
  v = (v | (v>>>16))  & 0x3FF;
  return (v<<22)>>22;
}

//Computes next combination in colexicographic order (this is mistakenly called nextPermutation on the bit twiddling hacks page)
exports.nextCombination = function(v) {
  var t = v | (v - 1);
  return (t + 1) | (((~t & -~t) - 1) >>> (countTrailingZeros(v) + 1));
}


},{}],23:[function(require,module,exports){
'use strict';

module.exports = earcut;
module.exports.default = earcut;

function earcut(data, holeIndices, dim) {

    dim = dim || 2;

    var hasHoles = holeIndices && holeIndices.length,
        outerLen = hasHoles ? holeIndices[0] * dim : data.length,
        outerNode = linkedList(data, 0, outerLen, dim, true),
        triangles = [];

    if (!outerNode || outerNode.next === outerNode.prev) return triangles;

    var minX, minY, maxX, maxY, x, y, invSize;

    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);

    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
    if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];

        for (var i = dim; i < outerLen; i += dim) {
            x = data[i];
            y = data[i + 1];
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
        }

        // minX, minY and invSize are later used to transform coords into integers for z-order calculation
        invSize = Math.max(maxX - minX, maxY - minY);
        invSize = invSize !== 0 ? 1 / invSize : 0;
    }

    earcutLinked(outerNode, triangles, dim, minX, minY, invSize);

    return triangles;
}

// create a circular doubly linked list from polygon points in the specified winding order
function linkedList(data, start, end, dim, clockwise) {
    var i, last;

    if (clockwise === (signedArea(data, start, end, dim) > 0)) {
        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
    } else {
        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
    }

    if (last && equals(last, last.next)) {
        removeNode(last);
        last = last.next;
    }

    return last;
}

// eliminate colinear or duplicate points
function filterPoints(start, end) {
    if (!start) return start;
    if (!end) end = start;

    var p = start,
        again;
    do {
        again = false;

        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
            removeNode(p);
            p = end = p.prev;
            if (p === p.next) break;
            again = true;

        } else {
            p = p.next;
        }
    } while (again || p !== end);

    return end;
}

// main ear slicing loop which triangulates a polygon (given as a linked list)
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
    if (!ear) return;

    // interlink polygon nodes in z-order
    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);

    var stop = ear,
        prev, next;

    // iterate through ears, slicing them one by one
    while (ear.prev !== ear.next) {
        prev = ear.prev;
        next = ear.next;

        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
            // cut off the triangle
            triangles.push(prev.i / dim);
            triangles.push(ear.i / dim);
            triangles.push(next.i / dim);

            removeNode(ear);

            // skipping the next vertex leads to less sliver triangles
            ear = next.next;
            stop = next.next;

            continue;
        }

        ear = next;

        // if we looped through the whole remaining polygon and can't find any more ears
        if (ear === stop) {
            // try filtering points and slicing again
            if (!pass) {
                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);

            // if this didn't work, try curing all small self-intersections locally
            } else if (pass === 1) {
                ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);

            // as a last resort, try splitting the remaining polygon into two
            } else if (pass === 2) {
                splitEarcut(ear, triangles, dim, minX, minY, invSize);
            }

            break;
        }
    }
}

// check whether a polygon node forms a valid ear with adjacent nodes
function isEar(ear) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    // now make sure we don't have other points inside the potential ear
    var p = ear.next.next;

    while (p !== ear.prev) {
        if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.next;
    }

    return true;
}

function isEarHashed(ear, minX, minY, invSize) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    // triangle bbox; min & max are calculated like this for speed
    var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x),
        minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y),
        maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x),
        maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);

    // z-order range for the current triangle bbox;
    var minZ = zOrder(minTX, minTY, minX, minY, invSize),
        maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);

    var p = ear.prevZ,
        n = ear.nextZ;

    // look for points inside the triangle in both directions
    while (p && p.z >= minZ && n && n.z <= maxZ) {
        if (p !== ear.prev && p !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;

        if (n !== ear.prev && n !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&
            area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }

    // look for remaining points in decreasing z-order
    while (p && p.z >= minZ) {
        if (p !== ear.prev && p !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
    }

    // look for remaining points in increasing z-order
    while (n && n.z <= maxZ) {
        if (n !== ear.prev && n !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&
            area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }

    return true;
}

// go through all polygon nodes and cure small local self-intersections
function cureLocalIntersections(start, triangles, dim) {
    var p = start;
    do {
        var a = p.prev,
            b = p.next.next;

        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {

            triangles.push(a.i / dim);
            triangles.push(p.i / dim);
            triangles.push(b.i / dim);

            // remove two nodes involved
            removeNode(p);
            removeNode(p.next);

            p = start = b;
        }
        p = p.next;
    } while (p !== start);

    return filterPoints(p);
}

// try splitting polygon into two and triangulate them independently
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
    // look for a valid diagonal that divides the polygon into two
    var a = start;
    do {
        var b = a.next.next;
        while (b !== a.prev) {
            if (a.i !== b.i && isValidDiagonal(a, b)) {
                // split the polygon in two by the diagonal
                var c = splitPolygon(a, b);

                // filter colinear points around the cuts
                a = filterPoints(a, a.next);
                c = filterPoints(c, c.next);

                // run earcut on each half
                earcutLinked(a, triangles, dim, minX, minY, invSize);
                earcutLinked(c, triangles, dim, minX, minY, invSize);
                return;
            }
            b = b.next;
        }
        a = a.next;
    } while (a !== start);
}

// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles(data, holeIndices, outerNode, dim) {
    var queue = [],
        i, len, start, end, list;

    for (i = 0, len = holeIndices.length; i < len; i++) {
        start = holeIndices[i] * dim;
        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        if (list === list.next) list.steiner = true;
        queue.push(getLeftmost(list));
    }

    queue.sort(compareX);

    // process holes from left to right
    for (i = 0; i < queue.length; i++) {
        eliminateHole(queue[i], outerNode);
        outerNode = filterPoints(outerNode, outerNode.next);
    }

    return outerNode;
}

function compareX(a, b) {
    return a.x - b.x;
}

// find a bridge between vertices that connects hole with an outer ring and and link it
function eliminateHole(hole, outerNode) {
    outerNode = findHoleBridge(hole, outerNode);
    if (outerNode) {
        var b = splitPolygon(outerNode, hole);
        filterPoints(b, b.next);
    }
}

// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge(hole, outerNode) {
    var p = outerNode,
        hx = hole.x,
        hy = hole.y,
        qx = -Infinity,
        m;

    // find a segment intersected by a ray from the hole's leftmost point to the left;
    // segment's endpoint with lesser x will be potential connection point
    do {
        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
            if (x <= hx && x > qx) {
                qx = x;
                if (x === hx) {
                    if (hy === p.y) return p;
                    if (hy === p.next.y) return p.next;
                }
                m = p.x < p.next.x ? p : p.next;
            }
        }
        p = p.next;
    } while (p !== outerNode);

    if (!m) return null;

    if (hx === qx) return m; // hole touches outer segment; pick leftmost endpoint

    // look for points inside the triangle of hole point, segment intersection and endpoint;
    // if there are no points found, we have a valid connection;
    // otherwise choose the point of the minimum angle with the ray as connection point

    var stop = m,
        mx = m.x,
        my = m.y,
        tanMin = Infinity,
        tan;

    p = m;

    do {
        if (hx >= p.x && p.x >= mx && hx !== p.x &&
                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {

            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

            if (locallyInside(p, hole) &&
                (tan < tanMin || (tan === tanMin && (p.x > m.x || (p.x === m.x && sectorContainsSector(m, p)))))) {
                m = p;
                tanMin = tan;
            }
        }

        p = p.next;
    } while (p !== stop);

    return m;
}

// whether sector in vertex m contains sector in vertex p in the same coordinates
function sectorContainsSector(m, p) {
    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
}

// interlink polygon nodes in z-order
function indexCurve(start, minX, minY, invSize) {
    var p = start;
    do {
        if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
    } while (p !== start);

    p.prevZ.nextZ = null;
    p.prevZ = null;

    sortLinked(p);
}

// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked(list) {
    var i, p, q, e, tail, numMerges, pSize, qSize,
        inSize = 1;

    do {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;

        while (p) {
            numMerges++;
            q = p;
            pSize = 0;
            for (i = 0; i < inSize; i++) {
                pSize++;
                q = q.nextZ;
                if (!q) break;
            }
            qSize = inSize;

            while (pSize > 0 || (qSize > 0 && q)) {

                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                } else {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                }

                if (tail) tail.nextZ = e;
                else list = e;

                e.prevZ = tail;
                tail = e;
            }

            p = q;
        }

        tail.nextZ = null;
        inSize *= 2;

    } while (numMerges > 1);

    return list;
}

// z-order of a point given coords and inverse of the longer side of data bbox
function zOrder(x, y, minX, minY, invSize) {
    // coords are transformed into non-negative 15-bit integer range
    x = 32767 * (x - minX) * invSize;
    y = 32767 * (y - minY) * invSize;

    x = (x | (x << 8)) & 0x00FF00FF;
    x = (x | (x << 4)) & 0x0F0F0F0F;
    x = (x | (x << 2)) & 0x33333333;
    x = (x | (x << 1)) & 0x55555555;

    y = (y | (y << 8)) & 0x00FF00FF;
    y = (y | (y << 4)) & 0x0F0F0F0F;
    y = (y | (y << 2)) & 0x33333333;
    y = (y | (y << 1)) & 0x55555555;

    return x | (y << 1);
}

// find the leftmost node of a polygon ring
function getLeftmost(start) {
    var p = start,
        leftmost = start;
    do {
        if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;
        p = p.next;
    } while (p !== start);

    return leftmost;
}

// check if a point lies within a convex triangle
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&
           (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&
           (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
}

// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal(a, b) {
    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges
           (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible
            (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors
            equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case
}

// signed area of a triangle
function area(p, q, r) {
    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}

// check if two points are equal
function equals(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
}

// check if two segments intersect
function intersects(p1, q1, p2, q2) {
    var o1 = sign(area(p1, q1, p2));
    var o2 = sign(area(p1, q1, q2));
    var o3 = sign(area(p2, q2, p1));
    var o4 = sign(area(p2, q2, q1));

    if (o1 !== o2 && o3 !== o4) return true; // general case

    if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1
    if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1
    if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2
    if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2

    return false;
}

// for collinear points p, q, r, check if point q lies on segment pr
function onSegment(p, q, r) {
    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
}

function sign(num) {
    return num > 0 ? 1 : num < 0 ? -1 : 0;
}

// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon(a, b) {
    var p = a;
    do {
        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
                intersects(p, p.next, a, b)) return true;
        p = p.next;
    } while (p !== a);

    return false;
}

// check if a polygon diagonal is locally inside the polygon
function locallyInside(a, b) {
    return area(a.prev, a, a.next) < 0 ?
        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :
        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}

// check if the middle point of a polygon diagonal is inside the polygon
function middleInside(a, b) {
    var p = a,
        inside = false,
        px = (a.x + b.x) / 2,
        py = (a.y + b.y) / 2;
    do {
        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&
                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
            inside = !inside;
        p = p.next;
    } while (p !== a);

    return inside;
}

// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon(a, b) {
    var a2 = new Node(a.i, a.x, a.y),
        b2 = new Node(b.i, b.x, b.y),
        an = a.next,
        bp = b.prev;

    a.next = b;
    b.prev = a;

    a2.next = an;
    an.prev = a2;

    b2.next = a2;
    a2.prev = b2;

    bp.next = b2;
    b2.prev = bp;

    return b2;
}

// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode(i, x, y, last) {
    var p = new Node(i, x, y);

    if (!last) {
        p.prev = p;
        p.next = p;

    } else {
        p.next = last.next;
        p.prev = last;
        last.next.prev = p;
        last.next = p;
    }
    return p;
}

function removeNode(p) {
    p.next.prev = p.prev;
    p.prev.next = p.next;

    if (p.prevZ) p.prevZ.nextZ = p.nextZ;
    if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}

function Node(i, x, y) {
    // vertex index in coordinates array
    this.i = i;

    // vertex coordinates
    this.x = x;
    this.y = y;

    // previous and next vertex nodes in a polygon ring
    this.prev = null;
    this.next = null;

    // z-order curve value
    this.z = null;

    // previous and next nodes in z-order
    this.prevZ = null;
    this.nextZ = null;

    // indicates whether this is a steiner point
    this.steiner = false;
}

// return a percentage difference between the polygon area and its triangulation area;
// used to verify correctness of triangulation
earcut.deviation = function (data, holeIndices, dim, triangles) {
    var hasHoles = holeIndices && holeIndices.length;
    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;

    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
    if (hasHoles) {
        for (var i = 0, len = holeIndices.length; i < len; i++) {
            var start = holeIndices[i] * dim;
            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
            polygonArea -= Math.abs(signedArea(data, start, end, dim));
        }
    }

    var trianglesArea = 0;
    for (i = 0; i < triangles.length; i += 3) {
        var a = triangles[i] * dim;
        var b = triangles[i + 1] * dim;
        var c = triangles[i + 2] * dim;
        trianglesArea += Math.abs(
            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -
            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
    }

    return polygonArea === 0 && trianglesArea === 0 ? 0 :
        Math.abs((trianglesArea - polygonArea) / polygonArea);
};

function signedArea(data, start, end, dim) {
    var sum = 0;
    for (var i = start, j = end - dim; i < end; i += dim) {
        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
        j = i;
    }
    return sum;
}

// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts
earcut.flatten = function (data) {
    var dim = data[0][0].length,
        result = {vertices: [], holes: [], dimensions: dim},
        holeIndex = 0;

    for (var i = 0; i < data.length; i++) {
        for (var j = 0; j < data[i].length; j++) {
            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);
        }
        if (i > 0) {
            holeIndex += data[i - 1].length;
            result.holes.push(holeIndex);
        }
    }
    return result;
};

},{}],24:[function(require,module,exports){
'use strict';

var has = Object.prototype.hasOwnProperty
  , prefix = '~';

/**
 * Constructor to create a storage for our `EE` objects.
 * An `Events` instance is a plain object whose properties are event names.
 *
 * @constructor
 * @api private
 */
function Events() {}

//
// We try to not inherit from `Object.prototype`. In some engines creating an
// instance in this way is faster than calling `Object.create(null)` directly.
// If `Object.create(null)` is not supported we prefix the event names with a
// character to make sure that the built-in object properties are not
// overridden or used as an attack vector.
//
if (Object.create) {
  Events.prototype = Object.create(null);

  //
  // This hack is needed because the `__proto__` property is still inherited in
  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
  //
  if (!new Events().__proto__) prefix = false;
}

/**
 * Representation of a single event listener.
 *
 * @param {Function} fn The listener function.
 * @param {Mixed} context The context to invoke the listener with.
 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
 * @constructor
 * @api private
 */
function EE(fn, context, once) {
  this.fn = fn;
  this.context = context;
  this.once = once || false;
}

/**
 * Minimal `EventEmitter` interface that is molded against the Node.js
 * `EventEmitter` interface.
 *
 * @constructor
 * @api public
 */
function EventEmitter() {
  this._events = new Events();
  this._eventsCount = 0;
}

/**
 * Return an array listing the events for which the emitter has registered
 * listeners.
 *
 * @returns {Array}
 * @api public
 */
EventEmitter.prototype.eventNames = function eventNames() {
  var names = []
    , events
    , name;

  if (this._eventsCount === 0) return names;

  for (name in (events = this._events)) {
    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
  }

  if (Object.getOwnPropertySymbols) {
    return names.concat(Object.getOwnPropertySymbols(events));
  }

  return names;
};

/**
 * Return the listeners registered for a given event.
 *
 * @param {String|Symbol} event The event name.
 * @param {Boolean} exists Only check if there are listeners.
 * @returns {Array|Boolean}
 * @api public
 */
EventEmitter.prototype.listeners = function listeners(event, exists) {
  var evt = prefix ? prefix + event : event
    , available = this._events[evt];

  if (exists) return !!available;
  if (!available) return [];
  if (available.fn) return [available.fn];

  for (var i = 0, l = available.length, ee = new Array(l); i < l; i++) {
    ee[i] = available[i].fn;
  }

  return ee;
};

/**
 * Calls each of the listeners registered for a given event.
 *
 * @param {String|Symbol} event The event name.
 * @returns {Boolean} `true` if the event had listeners, else `false`.
 * @api public
 */
EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return false;

  var listeners = this._events[evt]
    , len = arguments.length
    , args
    , i;

  if (listeners.fn) {
    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

    switch (len) {
      case 1: return listeners.fn.call(listeners.context), true;
      case 2: return listeners.fn.call(listeners.context, a1), true;
      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
    }

    for (i = 1, args = new Array(len -1); i < len; i++) {
      args[i - 1] = arguments[i];
    }

    listeners.fn.apply(listeners.context, args);
  } else {
    var length = listeners.length
      , j;

    for (i = 0; i < length; i++) {
      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

      switch (len) {
        case 1: listeners[i].fn.call(listeners[i].context); break;
        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;
        default:
          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
            args[j - 1] = arguments[j];
          }

          listeners[i].fn.apply(listeners[i].context, args);
      }
    }
  }

  return true;
};

/**
 * Add a listener for a given event.
 *
 * @param {String|Symbol} event The event name.
 * @param {Function} fn The listener function.
 * @param {Mixed} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @api public
 */
EventEmitter.prototype.on = function on(event, fn, context) {
  var listener = new EE(fn, context || this)
    , evt = prefix ? prefix + event : event;

  if (!this._events[evt]) this._events[evt] = listener, this._eventsCount++;
  else if (!this._events[evt].fn) this._events[evt].push(listener);
  else this._events[evt] = [this._events[evt], listener];

  return this;
};

/**
 * Add a one-time listener for a given event.
 *
 * @param {String|Symbol} event The event name.
 * @param {Function} fn The listener function.
 * @param {Mixed} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @api public
 */
EventEmitter.prototype.once = function once(event, fn, context) {
  var listener = new EE(fn, context || this, true)
    , evt = prefix ? prefix + event : event;

  if (!this._events[evt]) this._events[evt] = listener, this._eventsCount++;
  else if (!this._events[evt].fn) this._events[evt].push(listener);
  else this._events[evt] = [this._events[evt], listener];

  return this;
};

/**
 * Remove the listeners of a given event.
 *
 * @param {String|Symbol} event The event name.
 * @param {Function} fn Only remove the listeners that match this function.
 * @param {Mixed} context Only remove the listeners that have this context.
 * @param {Boolean} once Only remove one-time listeners.
 * @returns {EventEmitter} `this`.
 * @api public
 */
EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return this;
  if (!fn) {
    if (--this._eventsCount === 0) this._events = new Events();
    else delete this._events[evt];
    return this;
  }

  var listeners = this._events[evt];

  if (listeners.fn) {
    if (
         listeners.fn === fn
      && (!once || listeners.once)
      && (!context || listeners.context === context)
    ) {
      if (--this._eventsCount === 0) this._events = new Events();
      else delete this._events[evt];
    }
  } else {
    for (var i = 0, events = [], length = listeners.length; i < length; i++) {
      if (
           listeners[i].fn !== fn
        || (once && !listeners[i].once)
        || (context && listeners[i].context !== context)
      ) {
        events.push(listeners[i]);
      }
    }

    //
    // Reset the array, or remove it completely if we have no more listeners.
    //
    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
    else if (--this._eventsCount === 0) this._events = new Events();
    else delete this._events[evt];
  }

  return this;
};

/**
 * Remove all listeners, or those of the specified event.
 *
 * @param {String|Symbol} [event] The event name.
 * @returns {EventEmitter} `this`.
 * @api public
 */
EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
  var evt;

  if (event) {
    evt = prefix ? prefix + event : event;
    if (this._events[evt]) {
      if (--this._eventsCount === 0) this._events = new Events();
      else delete this._events[evt];
    }
  } else {
    this._events = new Events();
    this._eventsCount = 0;
  }

  return this;
};

//
// Alias methods names because people roll like that.
//
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.addListener = EventEmitter.prototype.on;

//
// This function doesn't apply anymore.
//
EventEmitter.prototype.setMaxListeners = function setMaxListeners() {
  return this;
};

//
// Expose the prefix.
//
EventEmitter.prefixed = prefix;

//
// Allow `EventEmitter` to be imported as module namespace.
//
EventEmitter.EventEmitter = EventEmitter;

//
// Expose the module.
//
if ('undefined' !== typeof module) {
  module.exports = EventEmitter;
}

},{}],25:[function(require,module,exports){
!function(e){var n=/iPhone/i,t=/iPod/i,r=/iPad/i,a=/\bAndroid(?:.+)Mobile\b/i,p=/Android/i,b=/\bAndroid(?:.+)SD4930UR\b/i,l=/\bAndroid(?:.+)(?:KF[A-Z]{2,4})\b/i,f=/Windows Phone/i,s=/\bWindows(?:.+)ARM\b/i,u=/BlackBerry/i,c=/BB10/i,h=/Opera Mini/i,v=/\b(CriOS|Chrome)(?:.+)Mobile/i,w=/Mobile(?:.+)Firefox\b/i;function m(e,i){return e.test(i)}function i(e){var i=e||("undefined"!=typeof navigator?navigator.userAgent:""),o=i.split("[FBAN");void 0!==o[1]&&(i=o[0]),void 0!==(o=i.split("Twitter"))[1]&&(i=o[0]);var d={apple:{phone:m(n,i)&&!m(f,i),ipod:m(t,i),tablet:!m(n,i)&&m(r,i)&&!m(f,i),device:(m(n,i)||m(t,i)||m(r,i))&&!m(f,i)},amazon:{phone:m(b,i),tablet:!m(b,i)&&m(l,i),device:m(b,i)||m(l,i)},android:{phone:!m(f,i)&&m(b,i)||!m(f,i)&&m(a,i),tablet:!m(f,i)&&!m(b,i)&&!m(a,i)&&(m(l,i)||m(p,i)),device:!m(f,i)&&(m(b,i)||m(l,i)||m(a,i)||m(p,i))||m(/\bokhttp\b/i,i)},windows:{phone:m(f,i),tablet:m(s,i),device:m(f,i)||m(s,i)},other:{blackberry:m(u,i),blackberry10:m(c,i),opera:m(h,i),firefox:m(w,i),chrome:m(v,i),device:m(u,i)||m(c,i)||m(h,i)||m(w,i)||m(v,i)}};return d.any=d.apple.device||d.android.device||d.windows.device||d.other.device,d.phone=d.apple.phone||d.android.phone||d.windows.phone,d.tablet=d.apple.tablet||d.android.tablet||d.windows.tablet,d}"undefined"!=typeof module&&module.exports&&"undefined"==typeof window?module.exports=i:"undefined"!=typeof module&&module.exports&&"undefined"!=typeof window?(module.exports=i(),module.exports.isMobile=i):"function"==typeof define&&define.amd?define([],e.isMobile=i()):e.isMobile=i()}(this);
},{}],26:[function(require,module,exports){
(function (global){
/*
 *  base64.js
 *
 *  Licensed under the BSD 3-Clause License.
 *    http://opensource.org/licenses/BSD-3-Clause
 *
 *  References:
 *    http://en.wikipedia.org/wiki/Base64
 */
;(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined'
        ? module.exports = factory(global)
        : typeof define === 'function' && define.amd
        ? define(factory) : factory(global)
}((
    typeof self !== 'undefined' ? self
        : typeof window !== 'undefined' ? window
        : typeof global !== 'undefined' ? global
: this
), function(global) {
    'use strict';
    // existing version for noConflict()
    global = global || {};
    var _Base64 = global.Base64;
    var version = "2.5.1";
    // if node.js and NOT React Native, we use Buffer
    var buffer;
    if (typeof module !== 'undefined' && module.exports) {
        try {
            buffer = eval("require('buffer').Buffer");
        } catch (err) {
            buffer = undefined;
        }
    }
    // constants
    var b64chars
        = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    var b64tab = function(bin) {
        var t = {};
        for (var i = 0, l = bin.length; i < l; i++) t[bin.charAt(i)] = i;
        return t;
    }(b64chars);
    var fromCharCode = String.fromCharCode;
    // encoder stuff
    var cb_utob = function(c) {
        if (c.length < 2) {
            var cc = c.charCodeAt(0);
            return cc < 0x80 ? c
                : cc < 0x800 ? (fromCharCode(0xc0 | (cc >>> 6))
                                + fromCharCode(0x80 | (cc & 0x3f)))
                : (fromCharCode(0xe0 | ((cc >>> 12) & 0x0f))
                   + fromCharCode(0x80 | ((cc >>>  6) & 0x3f))
                   + fromCharCode(0x80 | ( cc         & 0x3f)));
        } else {
            var cc = 0x10000
                + (c.charCodeAt(0) - 0xD800) * 0x400
                + (c.charCodeAt(1) - 0xDC00);
            return (fromCharCode(0xf0 | ((cc >>> 18) & 0x07))
                    + fromCharCode(0x80 | ((cc >>> 12) & 0x3f))
                    + fromCharCode(0x80 | ((cc >>>  6) & 0x3f))
                    + fromCharCode(0x80 | ( cc         & 0x3f)));
        }
    };
    var re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
    var utob = function(u) {
        return u.replace(re_utob, cb_utob);
    };
    var cb_encode = function(ccc) {
        var padlen = [0, 2, 1][ccc.length % 3],
        ord = ccc.charCodeAt(0) << 16
            | ((ccc.length > 1 ? ccc.charCodeAt(1) : 0) << 8)
            | ((ccc.length > 2 ? ccc.charCodeAt(2) : 0)),
        chars = [
            b64chars.charAt( ord >>> 18),
            b64chars.charAt((ord >>> 12) & 63),
            padlen >= 2 ? '=' : b64chars.charAt((ord >>> 6) & 63),
            padlen >= 1 ? '=' : b64chars.charAt(ord & 63)
        ];
        return chars.join('');
    };
    var btoa = global.btoa ? function(b) {
        return global.btoa(b);
    } : function(b) {
        return b.replace(/[\s\S]{1,3}/g, cb_encode);
    };
    var _encode = buffer ?
        buffer.from && Uint8Array && buffer.from !== Uint8Array.from
        ? function (u) {
            return (u.constructor === buffer.constructor ? u : buffer.from(u))
                .toString('base64')
        }
        :  function (u) {
            return (u.constructor === buffer.constructor ? u : new  buffer(u))
                .toString('base64')
        }
        : function (u) { return btoa(utob(u)) }
    ;
    var encode = function(u, urisafe) {
        return !urisafe
            ? _encode(String(u))
            : _encode(String(u)).replace(/[+\/]/g, function(m0) {
                return m0 == '+' ? '-' : '_';
            }).replace(/=/g, '');
    };
    var encodeURI = function(u) { return encode(u, true) };
    // decoder stuff
    var re_btou = new RegExp([
        '[\xC0-\xDF][\x80-\xBF]',
        '[\xE0-\xEF][\x80-\xBF]{2}',
        '[\xF0-\xF7][\x80-\xBF]{3}'
    ].join('|'), 'g');
    var cb_btou = function(cccc) {
        switch(cccc.length) {
        case 4:
            var cp = ((0x07 & cccc.charCodeAt(0)) << 18)
                |    ((0x3f & cccc.charCodeAt(1)) << 12)
                |    ((0x3f & cccc.charCodeAt(2)) <<  6)
                |     (0x3f & cccc.charCodeAt(3)),
            offset = cp - 0x10000;
            return (fromCharCode((offset  >>> 10) + 0xD800)
                    + fromCharCode((offset & 0x3FF) + 0xDC00));
        case 3:
            return fromCharCode(
                ((0x0f & cccc.charCodeAt(0)) << 12)
                    | ((0x3f & cccc.charCodeAt(1)) << 6)
                    |  (0x3f & cccc.charCodeAt(2))
            );
        default:
            return  fromCharCode(
                ((0x1f & cccc.charCodeAt(0)) << 6)
                    |  (0x3f & cccc.charCodeAt(1))
            );
        }
    };
    var btou = function(b) {
        return b.replace(re_btou, cb_btou);
    };
    var cb_decode = function(cccc) {
        var len = cccc.length,
        padlen = len % 4,
        n = (len > 0 ? b64tab[cccc.charAt(0)] << 18 : 0)
            | (len > 1 ? b64tab[cccc.charAt(1)] << 12 : 0)
            | (len > 2 ? b64tab[cccc.charAt(2)] <<  6 : 0)
            | (len > 3 ? b64tab[cccc.charAt(3)]       : 0),
        chars = [
            fromCharCode( n >>> 16),
            fromCharCode((n >>>  8) & 0xff),
            fromCharCode( n         & 0xff)
        ];
        chars.length -= [0, 0, 2, 1][padlen];
        return chars.join('');
    };
    var _atob = global.atob ? function(a) {
        return global.atob(a);
    } : function(a){
        return a.replace(/\S{1,4}/g, cb_decode);
    };
    var atob = function(a) {
        return _atob(String(a).replace(/[^A-Za-z0-9\+\/]/g, ''));
    };
    var _decode = buffer ?
        buffer.from && Uint8Array && buffer.from !== Uint8Array.from
        ? function(a) {
            return (a.constructor === buffer.constructor
                    ? a : buffer.from(a, 'base64')).toString();
        }
        : function(a) {
            return (a.constructor === buffer.constructor
                    ? a : new buffer(a, 'base64')).toString();
        }
        : function(a) { return btou(_atob(a)) };
    var decode = function(a){
        return _decode(
            String(a).replace(/[-_]/g, function(m0) { return m0 == '-' ? '+' : '/' })
                .replace(/[^A-Za-z0-9\+\/]/g, '')
        );
    };
    var noConflict = function() {
        var Base64 = global.Base64;
        global.Base64 = _Base64;
        return Base64;
    };
    // export Base64
    global.Base64 = {
        VERSION: version,
        atob: atob,
        btoa: btoa,
        fromBase64: decode,
        toBase64: encode,
        utob: utob,
        encode: encode,
        encodeURI: encodeURI,
        btou: btou,
        decode: decode,
        noConflict: noConflict,
        __buffer__: buffer
    };
    // if ES5 is available, make Base64.extendString() available
    if (typeof Object.defineProperty === 'function') {
        var noEnum = function(v){
            return {value:v,enumerable:false,writable:true,configurable:true};
        };
        global.Base64.extendString = function () {
            Object.defineProperty(
                String.prototype, 'fromBase64', noEnum(function () {
                    return decode(this)
                }));
            Object.defineProperty(
                String.prototype, 'toBase64', noEnum(function (urisafe) {
                    return encode(this, urisafe)
                }));
            Object.defineProperty(
                String.prototype, 'toBase64URI', noEnum(function () {
                    return encode(this, true)
                }));
        };
    }
    //
    // export Base64 to the namespace
    //
    if (global['Meteor']) { // Meteor.js
        Base64 = global.Base64;
    }
    // module.exports and AMD are mutually exclusive.
    // module.exports has precedence.
    if (typeof module !== 'undefined' && module.exports) {
        module.exports.Base64 = global.Base64;
    }
    else if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define([], function(){ return global.Base64 });
    }
    // that's it!
    return {Base64: global.Base64}
}));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],27:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var MiniSignalBinding = (function () {
  function MiniSignalBinding(fn, once, thisArg) {
    if (once === undefined) once = false;

    _classCallCheck(this, MiniSignalBinding);

    this._fn = fn;
    this._once = once;
    this._thisArg = thisArg;
    this._next = this._prev = this._owner = null;
  }

  _createClass(MiniSignalBinding, [{
    key: 'detach',
    value: function detach() {
      if (this._owner === null) return false;
      this._owner.detach(this);
      return true;
    }
  }]);

  return MiniSignalBinding;
})();

function _addMiniSignalBinding(self, node) {
  if (!self._head) {
    self._head = node;
    self._tail = node;
  } else {
    self._tail._next = node;
    node._prev = self._tail;
    self._tail = node;
  }

  node._owner = self;

  return node;
}

var MiniSignal = (function () {
  function MiniSignal() {
    _classCallCheck(this, MiniSignal);

    this._head = this._tail = undefined;
  }

  _createClass(MiniSignal, [{
    key: 'handlers',
    value: function handlers() {
      var exists = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];

      var node = this._head;

      if (exists) return !!node;

      var ee = [];

      while (node) {
        ee.push(node);
        node = node._next;
      }

      return ee;
    }
  }, {
    key: 'has',
    value: function has(node) {
      if (!(node instanceof MiniSignalBinding)) {
        throw new Error('MiniSignal#has(): First arg must be a MiniSignalBinding object.');
      }

      return node._owner === this;
    }
  }, {
    key: 'dispatch',
    value: function dispatch() {
      var node = this._head;

      if (!node) return false;

      while (node) {
        if (node._once) this.detach(node);
        node._fn.apply(node._thisArg, arguments);
        node = node._next;
      }

      return true;
    }
  }, {
    key: 'add',
    value: function add(fn) {
      var thisArg = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

      if (typeof fn !== 'function') {
        throw new Error('MiniSignal#add(): First arg must be a Function.');
      }
      return _addMiniSignalBinding(this, new MiniSignalBinding(fn, false, thisArg));
    }
  }, {
    key: 'once',
    value: function once(fn) {
      var thisArg = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

      if (typeof fn !== 'function') {
        throw new Error('MiniSignal#once(): First arg must be a Function.');
      }
      return _addMiniSignalBinding(this, new MiniSignalBinding(fn, true, thisArg));
    }
  }, {
    key: 'detach',
    value: function detach(node) {
      if (!(node instanceof MiniSignalBinding)) {
        throw new Error('MiniSignal#detach(): First arg must be a MiniSignalBinding object.');
      }
      if (node._owner !== this) return this;

      if (node._prev) node._prev._next = node._next;
      if (node._next) node._next._prev = node._prev;

      if (node === this._head) {
        this._head = node._next;
        if (node._next === null) {
          this._tail = null;
        }
      } else if (node === this._tail) {
        this._tail = node._prev;
        this._tail._next = null;
      }

      node._owner = null;
      return this;
    }
  }, {
    key: 'detachAll',
    value: function detachAll() {
      var node = this._head;
      if (!node) return this;

      this._head = this._tail = null;

      while (node) {
        node._owner = null;
        node = node._next;
      }
      return this;
    }
  }]);

  return MiniSignal;
})();

MiniSignal.MiniSignalBinding = MiniSignalBinding;

exports['default'] = MiniSignal;
module.exports = exports['default'];

},{}],28:[function(require,module,exports){
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/

'use strict';
/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};

},{}],29:[function(require,module,exports){
'use strict'

module.exports = function parseURI (str, opts) {
  opts = opts || {}

  var o = {
    key: ['source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'],
    q: {
      name: 'queryKey',
      parser: /(?:^|&)([^&=]*)=?([^&]*)/g
    },
    parser: {
      strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
      loose: /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
    }
  }

  var m = o.parser[opts.strictMode ? 'strict' : 'loose'].exec(str)
  var uri = {}
  var i = 14

  while (i--) uri[o.key[i]] = m[i] || ''

  uri[o.q.name] = {}
  uri[o.key[12]].replace(o.q.parser, function ($0, $1, $2) {
    if ($1) uri[o.q.name][$1] = $2
  })

  return uri
}

},{}],30:[function(require,module,exports){
var EMPTY_ARRAY_BUFFER = new ArrayBuffer(0);

/**
 * Helper class to create a webGL buffer
 *
 * @class
 * @memberof PIXI.glCore
 * @param gl {WebGLRenderingContext} The current WebGL rendering context
 * @param type {gl.ARRAY_BUFFER | gl.ELEMENT_ARRAY_BUFFER} @mat
 * @param data {ArrayBuffer| SharedArrayBuffer|ArrayBufferView} an array of data
 * @param drawType {gl.STATIC_DRAW|gl.DYNAMIC_DRAW|gl.STREAM_DRAW}
 */
var Buffer = function(gl, type, data, drawType)
{

	/**
     * The current WebGL rendering context
     *
     * @member {WebGLRenderingContext}
     */
	this.gl = gl;

	/**
     * The WebGL buffer, created upon instantiation
     *
     * @member {WebGLBuffer}
     */
	this.buffer = gl.createBuffer();

	/**
     * The type of the buffer
     *
     * @member {gl.ARRAY_BUFFER|gl.ELEMENT_ARRAY_BUFFER}
     */
	this.type = type || gl.ARRAY_BUFFER;

	/**
     * The draw type of the buffer
     *
     * @member {gl.STATIC_DRAW|gl.DYNAMIC_DRAW|gl.STREAM_DRAW}
     */
	this.drawType = drawType || gl.STATIC_DRAW;

	/**
     * The data in the buffer, as a typed array
     *
     * @member {ArrayBuffer| SharedArrayBuffer|ArrayBufferView}
     */
	this.data = EMPTY_ARRAY_BUFFER;

	if(data)
	{
		this.upload(data);
	}

	this._updateID = 0;
};

/**
 * Uploads the buffer to the GPU
 * @param data {ArrayBuffer| SharedArrayBuffer|ArrayBufferView} an array of data to upload
 * @param offset {Number} if only a subset of the data should be uploaded, this is the amount of data to subtract
 * @param dontBind {Boolean} whether to bind the buffer before uploading it
 */
Buffer.prototype.upload = function(data, offset, dontBind)
{
	// todo - needed?
	if(!dontBind) this.bind();

	var gl = this.gl;

	data = data || this.data;
	offset = offset || 0;

	if(this.data.byteLength >= data.byteLength)
	{
		gl.bufferSubData(this.type, offset, data);
	}
	else
	{
		gl.bufferData(this.type, data, this.drawType);
	}

	this.data = data;
};
/**
 * Binds the buffer
 *
 */
Buffer.prototype.bind = function()
{
	var gl = this.gl;
	gl.bindBuffer(this.type, this.buffer);
};

Buffer.createVertexBuffer = function(gl, data, drawType)
{
	return new Buffer(gl, gl.ARRAY_BUFFER, data, drawType);
};

Buffer.createIndexBuffer = function(gl, data, drawType)
{
	return new Buffer(gl, gl.ELEMENT_ARRAY_BUFFER, data, drawType);
};

Buffer.create = function(gl, type, data, drawType)
{
	return new Buffer(gl, type, data, drawType);
};

/**
 * Destroys the buffer
 *
 */
Buffer.prototype.destroy = function(){
	this.gl.deleteBuffer(this.buffer);
};

module.exports = Buffer;

},{}],31:[function(require,module,exports){

var Texture = require('./GLTexture');

/**
 * Helper class to create a webGL Framebuffer
 *
 * @class
 * @memberof PIXI.glCore
 * @param gl {WebGLRenderingContext} The current WebGL rendering context
 * @param width {Number} the width of the drawing area of the frame buffer
 * @param height {Number} the height of the drawing area of the frame buffer
 */
var Framebuffer = function(gl, width, height)
{
    /**
     * The current WebGL rendering context
     *
     * @member {WebGLRenderingContext}
     */
    this.gl = gl;

    /**
     * The frame buffer
     *
     * @member {WebGLFramebuffer}
     */
    this.framebuffer = gl.createFramebuffer();

    /**
     * The stencil buffer
     *
     * @member {WebGLRenderbuffer}
     */
    this.stencil = null;

    /**
     * The stencil buffer
     *
     * @member {PIXI.glCore.GLTexture}
     */
    this.texture = null;

    /**
     * The width of the drawing area of the buffer
     *
     * @member {Number}
     */
    this.width = width || 100;
    /**
     * The height of the drawing area of the buffer
     *
     * @member {Number}
     */
    this.height = height || 100;
};

/**
 * Adds a texture to the frame buffer
 * @param texture {PIXI.glCore.GLTexture}
 */
Framebuffer.prototype.enableTexture = function(texture)
{
    var gl = this.gl;

    this.texture = texture || new Texture(gl);

    this.texture.bind();

    //gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA,  this.width, this.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);

    this.bind();

    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture.texture, 0);
};

/**
 * Initialises the stencil buffer
 */
Framebuffer.prototype.enableStencil = function()
{
    if(this.stencil)return;

    var gl = this.gl;

    this.stencil = gl.createRenderbuffer();

    gl.bindRenderbuffer(gl.RENDERBUFFER, this.stencil);

    // TODO.. this is depth AND stencil?
    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, this.stencil);
    gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL,  this.width  , this.height );


};

/**
 * Erases the drawing area and fills it with a colour
 * @param  r {Number} the red value of the clearing colour
 * @param  g {Number} the green value of the clearing colour
 * @param  b {Number} the blue value of the clearing colour
 * @param  a {Number} the alpha value of the clearing colour
 */
Framebuffer.prototype.clear = function( r, g, b, a )
{
    this.bind();

    var gl = this.gl;

    gl.clearColor(r, g, b, a);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
};

/**
 * Binds the frame buffer to the WebGL context
 */
Framebuffer.prototype.bind = function()
{
    var gl = this.gl;
    gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer );
};

/**
 * Unbinds the frame buffer to the WebGL context
 */
Framebuffer.prototype.unbind = function()
{
    var gl = this.gl;
    gl.bindFramebuffer(gl.FRAMEBUFFER, null );
};
/**
 * Resizes the drawing area of the buffer to the given width and height
 * @param  width  {Number} the new width
 * @param  height {Number} the new height
 */
Framebuffer.prototype.resize = function(width, height)
{
    var gl = this.gl;

    this.width = width;
    this.height = height;

    if ( this.texture )
    {
        this.texture.uploadData(null, width, height);
    }

    if ( this.stencil )
    {
        // update the stencil buffer width and height
        gl.bindRenderbuffer(gl.RENDERBUFFER, this.stencil);
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, width, height);
    }
};

/**
 * Destroys this buffer
 */
Framebuffer.prototype.destroy = function()
{
    var gl = this.gl;

    //TODO
    if(this.texture)
    {
        this.texture.destroy();
    }

    gl.deleteFramebuffer(this.framebuffer);

    this.gl = null;

    this.stencil = null;
    this.texture = null;
};

/**
 * Creates a frame buffer with a texture containing the given data
 * @static
 * @param gl {WebGLRenderingContext} The current WebGL rendering context
 * @param width {Number} the width of the drawing area of the frame buffer
 * @param height {Number} the height of the drawing area of the frame buffer
 * @param data {ArrayBuffer| SharedArrayBuffer|ArrayBufferView} an array of data
 */
Framebuffer.createRGBA = function(gl, width, height, data)
{
    var texture = Texture.fromData(gl, null, width, height);
    texture.enableNearestScaling();
    texture.enableWrapClamp();

    //now create the framebuffer object and attach the texture to it.
    var fbo = new Framebuffer(gl, width, height);
    fbo.enableTexture(texture);
    //fbo.enableStencil(); // get this back on soon!

    //fbo.enableStencil(); // get this back on soon!

    fbo.unbind();

    return fbo;
};

/**
 * Creates a frame buffer with a texture containing the given data
 * @static
 * @param gl {WebGLRenderingContext} The current WebGL rendering context
 * @param width {Number} the width of the drawing area of the frame buffer
 * @param height {Number} the height of the drawing area of the frame buffer
 * @param data {ArrayBuffer| SharedArrayBuffer|ArrayBufferView} an array of data
 */
Framebuffer.createFloat32 = function(gl, width, height, data)
{
    // create a new texture..
    var texture = new Texture.fromData(gl, data, width, height);
    texture.enableNearestScaling();
    texture.enableWrapClamp();

    //now create the framebuffer object and attach the texture to it.
    var fbo = new Framebuffer(gl, width, height);
    fbo.enableTexture(texture);

    fbo.unbind();

    return fbo;
};

module.exports = Framebuffer;

},{"./GLTexture":33}],32:[function(require,module,exports){

var compileProgram = require('./shader/compileProgram'),
	extractAttributes = require('./shader/extractAttributes'),
	extractUniforms = require('./shader/extractUniforms'),
	setPrecision = require('./shader/setPrecision'),
	generateUniformAccessObject = require('./shader/generateUniformAccessObject');

/**
 * Helper class to create a webGL Shader
 *
 * @class
 * @memberof PIXI.glCore
 * @param gl {WebGLRenderingContext}
 * @param vertexSrc {string|string[]} The vertex shader source as an array of strings.
 * @param fragmentSrc {string|string[]} The fragment shader source as an array of strings.
 * @param precision {string} The float precision of the shader. Options are 'lowp', 'mediump' or 'highp'.
 * @param attributeLocations {object} A key value pair showing which location eact attribute should sit eg {position:0, uvs:1}
 */
var Shader = function(gl, vertexSrc, fragmentSrc, precision, attributeLocations)
{
	/**
	 * The current WebGL rendering context
	 *
	 * @member {WebGLRenderingContext}
	 */
	this.gl = gl;

	if(precision)
	{
		vertexSrc = setPrecision(vertexSrc, precision);
		fragmentSrc = setPrecision(fragmentSrc, precision);
	}

	/**
	 * The shader program
	 *
	 * @member {WebGLProgram}
	 */
	// First compile the program..
	this.program = compileProgram(gl, vertexSrc, fragmentSrc, attributeLocations);

	/**
	 * The attributes of the shader as an object containing the following properties
	 * {
	 * 	type,
	 * 	size,
	 * 	location,
	 * 	pointer
	 * }
	 * @member {Object}
	 */
	// next extract the attributes
	this.attributes = extractAttributes(gl, this.program);

    this.uniformData = extractUniforms(gl, this.program);

	/**
	 * The uniforms of the shader as an object containing the following properties
	 * {
	 * 	gl,
	 * 	data
	 * }
	 * @member {Object}
	 */
	this.uniforms = generateUniformAccessObject( gl, this.uniformData );

};
/**
 * Uses this shader
 * 
 * @return {PIXI.glCore.GLShader} Returns itself.
 */
Shader.prototype.bind = function()
{
	this.gl.useProgram(this.program);
	return this;
};

/**
 * Destroys this shader
 * TODO
 */
Shader.prototype.destroy = function()
{
	this.attributes = null;
	this.uniformData = null;
	this.uniforms = null;

	var gl = this.gl;
	gl.deleteProgram(this.program);
};


module.exports = Shader;

},{"./shader/compileProgram":38,"./shader/extractAttributes":40,"./shader/extractUniforms":41,"./shader/generateUniformAccessObject":42,"./shader/setPrecision":46}],33:[function(require,module,exports){

/**
 * Helper class to create a WebGL Texture
 *
 * @class
 * @memberof PIXI.glCore
 * @param gl {WebGLRenderingContext} The current WebGL context
 * @param width {number} the width of the texture
 * @param height {number} the height of the texture
 * @param format {number} the pixel format of the texture. defaults to gl.RGBA
 * @param type {number} the gl type of the texture. defaults to gl.UNSIGNED_BYTE
 */
var Texture = function(gl, width, height, format, type)
{
	/**
	 * The current WebGL rendering context
	 *
	 * @member {WebGLRenderingContext}
	 */
	this.gl = gl;


	/**
	 * The WebGL texture
	 *
	 * @member {WebGLTexture}
	 */
	this.texture = gl.createTexture();

	/**
	 * If mipmapping was used for this texture, enable and disable with enableMipmap()
	 *
	 * @member {Boolean}
	 */
	// some settings..
	this.mipmap = false;


	/**
	 * Set to true to enable pre-multiplied alpha
	 *
	 * @member {Boolean}
	 */
	this.premultiplyAlpha = false;

	/**
	 * The width of texture
	 *
	 * @member {Number}
	 */
	this.width = width || -1;
	/**
	 * The height of texture
	 *
	 * @member {Number}
	 */
	this.height = height || -1;

	/**
	 * The pixel format of the texture. defaults to gl.RGBA
	 *
	 * @member {Number}
	 */
	this.format = format || gl.RGBA;

	/**
	 * The gl type of the texture. defaults to gl.UNSIGNED_BYTE
	 *
	 * @member {Number}
	 */
	this.type = type || gl.UNSIGNED_BYTE;


};

/**
 * Uploads this texture to the GPU
 * @param source {HTMLImageElement|ImageData|HTMLVideoElement} the source image of the texture
 */
Texture.prototype.upload = function(source)
{
	this.bind();

	var gl = this.gl;


	gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this.premultiplyAlpha);

	var newWidth = source.videoWidth || source.width;
	var newHeight = source.videoHeight || source.height;

	if(newHeight !== this.height || newWidth !== this.width)
	{
		gl.texImage2D(gl.TEXTURE_2D, 0, this.format, this.format, this.type, source);
	}
	else
	{
    	gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, this.format, this.type, source);
	}

	// if the source is a video, we need to use the videoWidth / videoHeight properties as width / height will be incorrect.
	this.width = newWidth;
	this.height = newHeight;

};

var FLOATING_POINT_AVAILABLE = false;

/**
 * Use a data source and uploads this texture to the GPU
 * @param data {TypedArray} the data to upload to the texture
 * @param width {number} the new width of the texture
 * @param height {number} the new height of the texture
 */
Texture.prototype.uploadData = function(data, width, height)
{
	this.bind();

	var gl = this.gl;


	if(data instanceof Float32Array)
	{
		if(!FLOATING_POINT_AVAILABLE)
		{
			var ext = gl.getExtension("OES_texture_float");

			if(ext)
			{
				FLOATING_POINT_AVAILABLE = true;
			}
			else
			{
				throw new Error('floating point textures not available');
			}
		}

		this.type = gl.FLOAT;
	}
	else
	{
		// TODO support for other types
		this.type = this.type || gl.UNSIGNED_BYTE;
	}

	// what type of data?
	gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this.premultiplyAlpha);


	if(width !== this.width || height !== this.height)
	{
		gl.texImage2D(gl.TEXTURE_2D, 0, this.format,  width, height, 0, this.format, this.type, data || null);
	}
	else
	{
		gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, width, height, this.format, this.type, data || null);
	}

	this.width = width;
	this.height = height;


//	texSubImage2D
};

/**
 * Binds the texture
 * @param  location
 */
Texture.prototype.bind = function(location)
{
	var gl = this.gl;

	if(location !== undefined)
	{
		gl.activeTexture(gl.TEXTURE0 + location);
	}

	gl.bindTexture(gl.TEXTURE_2D, this.texture);
};

/**
 * Unbinds the texture
 */
Texture.prototype.unbind = function()
{
	var gl = this.gl;
	gl.bindTexture(gl.TEXTURE_2D, null);
};

/**
 * @param linear {Boolean} if we want to use linear filtering or nearest neighbour interpolation
 */
Texture.prototype.minFilter = function( linear )
{
	var gl = this.gl;

	this.bind();

	if(this.mipmap)
	{
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, linear ? gl.LINEAR_MIPMAP_LINEAR : gl.NEAREST_MIPMAP_NEAREST);
	}
	else
	{
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, linear ? gl.LINEAR : gl.NEAREST);
	}
};

/**
 * @param linear {Boolean} if we want to use linear filtering or nearest neighbour interpolation
 */
Texture.prototype.magFilter = function( linear )
{
	var gl = this.gl;

	this.bind();

	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, linear ? gl.LINEAR : gl.NEAREST);
};

/**
 * Enables mipmapping
 */
Texture.prototype.enableMipmap = function()
{
	var gl = this.gl;

	this.bind();

	this.mipmap = true;

	gl.generateMipmap(gl.TEXTURE_2D);
};

/**
 * Enables linear filtering
 */
Texture.prototype.enableLinearScaling = function()
{
	this.minFilter(true);
	this.magFilter(true);
};

/**
 * Enables nearest neighbour interpolation
 */
Texture.prototype.enableNearestScaling = function()
{
	this.minFilter(false);
	this.magFilter(false);
};

/**
 * Enables clamping on the texture so WebGL will not repeat it
 */
Texture.prototype.enableWrapClamp = function()
{
	var gl = this.gl;

	this.bind();

	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
};

/**
 * Enable tiling on the texture
 */
Texture.prototype.enableWrapRepeat = function()
{
	var gl = this.gl;

	this.bind();

	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
};

Texture.prototype.enableWrapMirrorRepeat = function()
{
	var gl = this.gl;

	this.bind();

	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.MIRRORED_REPEAT);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.MIRRORED_REPEAT);
};


/**
 * Destroys this texture
 */
Texture.prototype.destroy = function()
{
	var gl = this.gl;
	//TODO
	gl.deleteTexture(this.texture);
};

/**
 * @static
 * @param gl {WebGLRenderingContext} The current WebGL context
 * @param source {HTMLImageElement|ImageData} the source image of the texture
 * @param premultiplyAlpha {Boolean} If we want to use pre-multiplied alpha
 */
Texture.fromSource = function(gl, source, premultiplyAlpha)
{
	var texture = new Texture(gl);
	texture.premultiplyAlpha = premultiplyAlpha || false;
	texture.upload(source);

	return texture;
};

/**
 * @static
 * @param gl {WebGLRenderingContext} The current WebGL context
 * @param data {TypedArray} the data to upload to the texture
 * @param width {number} the new width of the texture
 * @param height {number} the new height of the texture
 */
Texture.fromData = function(gl, data, width, height)
{
	//console.log(data, width, height);
	var texture = new Texture(gl);
	texture.uploadData(data, width, height);

	return texture;
};


module.exports = Texture;

},{}],34:[function(require,module,exports){

// state object//
var setVertexAttribArrays = require( './setVertexAttribArrays' );

/**
 * Helper class to work with WebGL VertexArrayObjects (vaos)
 * Only works if WebGL extensions are enabled (they usually are)
 *
 * @class
 * @memberof PIXI.glCore
 * @param gl {WebGLRenderingContext} The current WebGL rendering context
 */
function VertexArrayObject(gl, state)
{
    this.nativeVaoExtension = null;

    if(!VertexArrayObject.FORCE_NATIVE)
    {
        this.nativeVaoExtension = gl.getExtension('OES_vertex_array_object') ||
                                  gl.getExtension('MOZ_OES_vertex_array_object') ||
                                  gl.getExtension('WEBKIT_OES_vertex_array_object');
    }

    this.nativeState = state;

    if(this.nativeVaoExtension)
    {
        this.nativeVao = this.nativeVaoExtension.createVertexArrayOES();

        var maxAttribs = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);

        // VAO - overwrite the state..
        this.nativeState = {
            tempAttribState: new Array(maxAttribs),
            attribState: new Array(maxAttribs)
        };
    }

    /**
     * The current WebGL rendering context
     *
     * @member {WebGLRenderingContext}
     */
    this.gl = gl;

    /**
     * An array of attributes
     *
     * @member {Array}
     */
    this.attributes = [];

    /**
     * @member {PIXI.glCore.GLBuffer}
     */
    this.indexBuffer = null;

    /**
     * A boolean flag
     *
     * @member {Boolean}
     */
    this.dirty = false;
}

VertexArrayObject.prototype.constructor = VertexArrayObject;
module.exports = VertexArrayObject;

/**
* Some devices behave a bit funny when using the newer extensions (im looking at you ipad 2!)
* If you find on older devices that things have gone a bit weird then set this to true.
*/
/**
 * Lets the VAO know if you should use the WebGL extension or the native methods.
 * Some devices behave a bit funny when using the newer extensions (im looking at you ipad 2!)
 * If you find on older devices that things have gone a bit weird then set this to true.
 * @static
 * @property {Boolean} FORCE_NATIVE
 */
VertexArrayObject.FORCE_NATIVE = false;

/**
 * Binds the buffer
 */
VertexArrayObject.prototype.bind = function()
{
    if(this.nativeVao)
    {
        this.nativeVaoExtension.bindVertexArrayOES(this.nativeVao);

        if(this.dirty)
        {
            this.dirty = false;
            this.activate();
            return this;
        }
        if (this.indexBuffer)
        {
            this.indexBuffer.bind();
        }
    }
    else
    {
        this.activate();
    }

    return this;
};

/**
 * Unbinds the buffer
 */
VertexArrayObject.prototype.unbind = function()
{
    if(this.nativeVao)
    {
        this.nativeVaoExtension.bindVertexArrayOES(null);
    }

    return this;
};

/**
 * Uses this vao
 */
VertexArrayObject.prototype.activate = function()
{

    var gl = this.gl;
    var lastBuffer = null;

    for (var i = 0; i < this.attributes.length; i++)
    {
        var attrib = this.attributes[i];

        if(lastBuffer !== attrib.buffer)
        {
            attrib.buffer.bind();
            lastBuffer = attrib.buffer;
        }

        gl.vertexAttribPointer(attrib.attribute.location,
                               attrib.attribute.size,
                               attrib.type || gl.FLOAT,
                               attrib.normalized || false,
                               attrib.stride || 0,
                               attrib.start || 0);
    }

    setVertexAttribArrays(gl, this.attributes, this.nativeState);

    if(this.indexBuffer)
    {
        this.indexBuffer.bind();
    }

    return this;
};

/**
 *
 * @param buffer     {PIXI.gl.GLBuffer}
 * @param attribute  {*}
 * @param type       {String}
 * @param normalized {Boolean}
 * @param stride     {Number}
 * @param start      {Number}
 */
VertexArrayObject.prototype.addAttribute = function(buffer, attribute, type, normalized, stride, start)
{
    this.attributes.push({
        buffer:     buffer,
        attribute:  attribute,

        location:   attribute.location,
        type:       type || this.gl.FLOAT,
        normalized: normalized || false,
        stride:     stride || 0,
        start:      start || 0
    });

    this.dirty = true;

    return this;
};

/**
 *
 * @param buffer   {PIXI.gl.GLBuffer}
 */
VertexArrayObject.prototype.addIndex = function(buffer/*, options*/)
{
    this.indexBuffer = buffer;

    this.dirty = true;

    return this;
};

/**
 * Unbinds this vao and disables it
 */
VertexArrayObject.prototype.clear = function()
{
    // var gl = this.gl;

    // TODO - should this function unbind after clear?
    // for now, no but lets see what happens in the real world!
    if(this.nativeVao)
    {
        this.nativeVaoExtension.bindVertexArrayOES(this.nativeVao);
    }

    this.attributes.length = 0;
    this.indexBuffer = null;

    return this;
};

/**
 * @param type  {Number}
 * @param size  {Number}
 * @param start {Number}
 */
VertexArrayObject.prototype.draw = function(type, size, start)
{
    var gl = this.gl;

    if(this.indexBuffer)
    {
        gl.drawElements(type, size || this.indexBuffer.data.length, gl.UNSIGNED_SHORT, (start || 0) * 2 );
    }
    else
    {
        // TODO need a better way to calculate size..
        gl.drawArrays(type, start, size || this.getSize());
    }

    return this;
};

/**
 * Destroy this vao
 */
VertexArrayObject.prototype.destroy = function()
{
    // lose references
    this.gl = null;
    this.indexBuffer = null;
    this.attributes = null;
    this.nativeState = null;

    if(this.nativeVao)
    {
        this.nativeVaoExtension.deleteVertexArrayOES(this.nativeVao);
    }

    this.nativeVaoExtension = null;
    this.nativeVao = null;
};

VertexArrayObject.prototype.getSize = function()
{
    var attrib = this.attributes[0];
    return attrib.buffer.data.length / (( attrib.stride/4 ) || attrib.attribute.size);
};

},{"./setVertexAttribArrays":37}],35:[function(require,module,exports){

/**
 * Helper class to create a webGL Context
 *
 * @class
 * @memberof PIXI.glCore
 * @param canvas {HTMLCanvasElement} the canvas element that we will get the context from
 * @param options {Object} An options object that gets passed in to the canvas element containing the context attributes,
 *                         see https://developer.mozilla.org/en/docs/Web/API/HTMLCanvasElement/getContext for the options available
 * @return {WebGLRenderingContext} the WebGL context
 */
var createContext = function(canvas, options)
{
    var gl = canvas.getContext('webgl', options) || 
         canvas.getContext('experimental-webgl', options);

    if (!gl)
    {
        // fail, not able to get a context
        throw new Error('This browser does not support webGL. Try using the canvas renderer');
    }

    return gl;
};

module.exports = createContext;

},{}],36:[function(require,module,exports){
var gl = {
    createContext:          require('./createContext'),
    setVertexAttribArrays:  require('./setVertexAttribArrays'),
    GLBuffer:               require('./GLBuffer'),
    GLFramebuffer:          require('./GLFramebuffer'),
    GLShader:               require('./GLShader'),
    GLTexture:              require('./GLTexture'),
    VertexArrayObject:      require('./VertexArrayObject'),
    shader:                 require('./shader')
};

// Export for Node-compatible environments
if (typeof module !== 'undefined' && module.exports)
{
    // Export the module
    module.exports = gl;
}

// Add to the browser window pixi.gl
if (typeof window !== 'undefined')
{
    // add the window object
    window.PIXI = window.PIXI || {};
    window.PIXI.glCore = gl;
}

},{"./GLBuffer":30,"./GLFramebuffer":31,"./GLShader":32,"./GLTexture":33,"./VertexArrayObject":34,"./createContext":35,"./setVertexAttribArrays":37,"./shader":43}],37:[function(require,module,exports){
// var GL_MAP = {};

/**
 * @param gl {WebGLRenderingContext} The current WebGL context
 * @param attribs {*}
 * @param state {*}
 */
var setVertexAttribArrays = function (gl, attribs, state)
{
    var i;
    if(state)
    {
        var tempAttribState = state.tempAttribState,
            attribState = state.attribState;

        for (i = 0; i < tempAttribState.length; i++)
        {
            tempAttribState[i] = false;
        }

        // set the new attribs
        for (i = 0; i < attribs.length; i++)
        {
            tempAttribState[attribs[i].attribute.location] = true;
        }

        for (i = 0; i < attribState.length; i++)
        {
            if (attribState[i] !== tempAttribState[i])
            {
                attribState[i] = tempAttribState[i];

                if (state.attribState[i])
                {
                    gl.enableVertexAttribArray(i);
                }
                else
                {
                    gl.disableVertexAttribArray(i);
                }
            }
        }

    }
    else
    {
        for (i = 0; i < attribs.length; i++)
        {
            var attrib = attribs[i];
            gl.enableVertexAttribArray(attrib.attribute.location);
        }
    }
};

module.exports = setVertexAttribArrays;

},{}],38:[function(require,module,exports){

/**
 * @class
 * @memberof PIXI.glCore.shader
 * @param gl {WebGLRenderingContext} The current WebGL context {WebGLProgram}
 * @param vertexSrc {string|string[]} The vertex shader source as an array of strings.
 * @param fragmentSrc {string|string[]} The fragment shader source as an array of strings.
 * @param attributeLocations {Object} An attribute location map that lets you manually set the attribute locations
 * @return {WebGLProgram} the shader program
 */
var compileProgram = function(gl, vertexSrc, fragmentSrc, attributeLocations)
{
    var glVertShader = compileShader(gl, gl.VERTEX_SHADER, vertexSrc);
    var glFragShader = compileShader(gl, gl.FRAGMENT_SHADER, fragmentSrc);

    var program = gl.createProgram();

    gl.attachShader(program, glVertShader);
    gl.attachShader(program, glFragShader);

    // optionally, set the attributes manually for the program rather than letting WebGL decide..
    if(attributeLocations)
    {
        for(var i in attributeLocations)
        {
            gl.bindAttribLocation(program, attributeLocations[i], i);
        }
    }


    gl.linkProgram(program);

    // if linking fails, then log and cleanup
    if (!gl.getProgramParameter(program, gl.LINK_STATUS))
    {
        console.error('Pixi.js Error: Could not initialize shader.');
        console.error('gl.VALIDATE_STATUS', gl.getProgramParameter(program, gl.VALIDATE_STATUS));
        console.error('gl.getError()', gl.getError());

        // if there is a program info log, log it
        if (gl.getProgramInfoLog(program) !== '')
        {
            console.warn('Pixi.js Warning: gl.getProgramInfoLog()', gl.getProgramInfoLog(program));
        }

        gl.deleteProgram(program);
        program = null;
    }

    // clean up some shaders
    gl.deleteShader(glVertShader);
    gl.deleteShader(glFragShader);

    return program;
};

/**
 * @private
 * @param gl {WebGLRenderingContext} The current WebGL context {WebGLProgram}
 * @param type {Number} the type, can be either VERTEX_SHADER or FRAGMENT_SHADER
 * @param vertexSrc {string|string[]} The vertex shader source as an array of strings.
 * @return {WebGLShader} the shader
 */
var compileShader = function (gl, type, src)
{
    var shader = gl.createShader(type);

    gl.shaderSource(shader, src);
    gl.compileShader(shader);

    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS))
    {
        console.log(gl.getShaderInfoLog(shader));
        return null;
    }

    return shader;
};

module.exports = compileProgram;

},{}],39:[function(require,module,exports){
/**
 * @class
 * @memberof PIXI.glCore.shader
 * @param type {String} Type of value
 * @param size {Number}
 */
var defaultValue = function(type, size) 
{
    switch (type)
    {
        case 'float':
            return 0;

        case 'vec2': 
            return new Float32Array(2 * size);

        case 'vec3':
            return new Float32Array(3 * size);

        case 'vec4':     
            return new Float32Array(4 * size);
            
        case 'int':
        case 'sampler2D':
            return 0;

        case 'ivec2':   
            return new Int32Array(2 * size);

        case 'ivec3':
            return new Int32Array(3 * size);

        case 'ivec4': 
            return new Int32Array(4 * size);

        case 'bool':     
            return false;

        case 'bvec2':

            return booleanArray( 2 * size);

        case 'bvec3':
            return booleanArray(3 * size);

        case 'bvec4':
            return booleanArray(4 * size);

        case 'mat2':
            return new Float32Array([1, 0,
                                     0, 1]);

        case 'mat3': 
            return new Float32Array([1, 0, 0,
                                     0, 1, 0,
                                     0, 0, 1]);

        case 'mat4':
            return new Float32Array([1, 0, 0, 0,
                                     0, 1, 0, 0,
                                     0, 0, 1, 0,
                                     0, 0, 0, 1]);
    }
};

var booleanArray = function(size)
{
    var array = new Array(size);

    for (var i = 0; i < array.length; i++) 
    {
        array[i] = false;
    }

    return array;
};

module.exports = defaultValue;

},{}],40:[function(require,module,exports){

var mapType = require('./mapType');
var mapSize = require('./mapSize');

/**
 * Extracts the attributes
 * @class
 * @memberof PIXI.glCore.shader
 * @param gl {WebGLRenderingContext} The current WebGL rendering context
 * @param program {WebGLProgram} The shader program to get the attributes from
 * @return attributes {Object}
 */
var extractAttributes = function(gl, program)
{
    var attributes = {};

    var totalAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);

    for (var i = 0; i < totalAttributes; i++)
    {
        var attribData = gl.getActiveAttrib(program, i);
        var type = mapType(gl, attribData.type);

        attributes[attribData.name] = {
            type:type,
            size:mapSize(type),
            location:gl.getAttribLocation(program, attribData.name),
            //TODO - make an attribute object
            pointer: pointer
        };
    }

    return attributes;
};

var pointer = function(type, normalized, stride, start){
    // console.log(this.location)
    gl.vertexAttribPointer(this.location,this.size, type || gl.FLOAT, normalized || false, stride || 0, start || 0);
};

module.exports = extractAttributes;

},{"./mapSize":44,"./mapType":45}],41:[function(require,module,exports){
var mapType = require('./mapType');
var defaultValue = require('./defaultValue');

/**
 * Extracts the uniforms
 * @class
 * @memberof PIXI.glCore.shader
 * @param gl {WebGLRenderingContext} The current WebGL rendering context
 * @param program {WebGLProgram} The shader program to get the uniforms from
 * @return uniforms {Object}
 */
var extractUniforms = function(gl, program)
{
	var uniforms = {};

    var totalUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);

    for (var i = 0; i < totalUniforms; i++)
    {
    	var uniformData = gl.getActiveUniform(program, i);
    	var name = uniformData.name.replace(/\[.*?\]/, "");
        var type = mapType(gl, uniformData.type );

    	uniforms[name] = {
    		type:type,
    		size:uniformData.size,
    		location:gl.getUniformLocation(program, name),
    		value:defaultValue(type, uniformData.size)
    	};
    }

	return uniforms;
};

module.exports = extractUniforms;

},{"./defaultValue":39,"./mapType":45}],42:[function(require,module,exports){
/**
 * Extracts the attributes
 * @class
 * @memberof PIXI.glCore.shader
 * @param gl {WebGLRenderingContext} The current WebGL rendering context
 * @param uniforms {Array} @mat ?
 * @return attributes {Object}
 */
var generateUniformAccessObject = function(gl, uniformData)
{
    // this is the object we will be sending back.
    // an object hierachy will be created for structs
    var uniforms = {data:{}};

    uniforms.gl = gl;

    var uniformKeys= Object.keys(uniformData);

    for (var i = 0; i < uniformKeys.length; i++)
    {
        var fullName = uniformKeys[i];

        var nameTokens = fullName.split('.');
        var name = nameTokens[nameTokens.length - 1];


        var uniformGroup = getUniformGroup(nameTokens, uniforms);

        var uniform =  uniformData[fullName];
        uniformGroup.data[name] = uniform;

        uniformGroup.gl = gl;

        Object.defineProperty(uniformGroup, name, {
            get: generateGetter(name),
            set: generateSetter(name, uniform)
        });
    }

    return uniforms;
};

var generateGetter = function(name)
{
    return function() {
        return this.data[name].value;
    };
};

var GLSL_SINGLE_SETTERS = {
    float: function setSingleFloat(gl, location, value) { gl.uniform1f(location, value); },
    vec2: function setSingleVec2(gl, location, value) { gl.uniform2f(location, value[0], value[1]); },
    vec3: function setSingleVec3(gl, location, value) { gl.uniform3f(location, value[0], value[1], value[2]); },
    vec4: function setSingleVec4(gl, location, value) { gl.uniform4f(location, value[0], value[1], value[2], value[3]); },

    int: function setSingleInt(gl, location, value) { gl.uniform1i(location, value); },
    ivec2: function setSingleIvec2(gl, location, value) { gl.uniform2i(location, value[0], value[1]); },
    ivec3: function setSingleIvec3(gl, location, value) { gl.uniform3i(location, value[0], value[1], value[2]); },
    ivec4: function setSingleIvec4(gl, location, value) { gl.uniform4i(location, value[0], value[1], value[2], value[3]); },

    bool: function setSingleBool(gl, location, value) { gl.uniform1i(location, value); },
    bvec2: function setSingleBvec2(gl, location, value) { gl.uniform2i(location, value[0], value[1]); },
    bvec3: function setSingleBvec3(gl, location, value) { gl.uniform3i(location, value[0], value[1], value[2]); },
    bvec4: function setSingleBvec4(gl, location, value) { gl.uniform4i(location, value[0], value[1], value[2], value[3]); },

    mat2: function setSingleMat2(gl, location, value) { gl.uniformMatrix2fv(location, false, value); },
    mat3: function setSingleMat3(gl, location, value) { gl.uniformMatrix3fv(location, false, value); },
    mat4: function setSingleMat4(gl, location, value) { gl.uniformMatrix4fv(location, false, value); },

    sampler2D: function setSingleSampler2D(gl, location, value) { gl.uniform1i(location, value); },
};

var GLSL_ARRAY_SETTERS = {
    float: function setFloatArray(gl, location, value) { gl.uniform1fv(location, value); },
    vec2: function setVec2Array(gl, location, value) { gl.uniform2fv(location, value); },
    vec3: function setVec3Array(gl, location, value) { gl.uniform3fv(location, value); },
    vec4: function setVec4Array(gl, location, value) { gl.uniform4fv(location, value); },
    int: function setIntArray(gl, location, value) { gl.uniform1iv(location, value); },
    ivec2: function setIvec2Array(gl, location, value) { gl.uniform2iv(location, value); },
    ivec3: function setIvec3Array(gl, location, value) { gl.uniform3iv(location, value); },
    ivec4: function setIvec4Array(gl, location, value) { gl.uniform4iv(location, value); },
    bool: function setBoolArray(gl, location, value) { gl.uniform1iv(location, value); },
    bvec2: function setBvec2Array(gl, location, value) { gl.uniform2iv(location, value); },
    bvec3: function setBvec3Array(gl, location, value) { gl.uniform3iv(location, value); },
    bvec4: function setBvec4Array(gl, location, value) { gl.uniform4iv(location, value); },
    sampler2D: function setSampler2DArray(gl, location, value) { gl.uniform1iv(location, value); },
};

function generateSetter(name, uniform)
{
    return function(value) {
        this.data[name].value = value;
        var location = this.data[name].location;
        if (uniform.size === 1)
        {
            GLSL_SINGLE_SETTERS[uniform.type](this.gl, location, value);
        }
        else
        {
            // glslSetArray(gl, location, type, value) {
            GLSL_ARRAY_SETTERS[uniform.type](this.gl, location, value);
        }
    };
}

function getUniformGroup(nameTokens, uniform)
{
    var cur = uniform;

    for (var i = 0; i < nameTokens.length - 1; i++)
    {
        var o = cur[nameTokens[i]] || {data:{}};
        cur[nameTokens[i]] = o;
        cur = o;
    }

    return cur;
}


module.exports = generateUniformAccessObject;

},{}],43:[function(require,module,exports){
module.exports = {
    compileProgram: require('./compileProgram'),
    defaultValue: require('./defaultValue'),
    extractAttributes: require('./extractAttributes'),
    extractUniforms: require('./extractUniforms'),
    generateUniformAccessObject: require('./generateUniformAccessObject'),
    setPrecision: require('./setPrecision'),
    mapSize: require('./mapSize'),
    mapType: require('./mapType')
};
},{"./compileProgram":38,"./defaultValue":39,"./extractAttributes":40,"./extractUniforms":41,"./generateUniformAccessObject":42,"./mapSize":44,"./mapType":45,"./setPrecision":46}],44:[function(require,module,exports){
/**
 * @class
 * @memberof PIXI.glCore.shader
 * @param type {String}
 * @return {Number}
 */
var mapSize = function(type) 
{ 
    return GLSL_TO_SIZE[type];
};


var GLSL_TO_SIZE = {
    'float':    1,
    'vec2':     2,
    'vec3':     3,
    'vec4':     4,

    'int':      1,
    'ivec2':    2,
    'ivec3':    3,
    'ivec4':    4,

    'bool':     1,
    'bvec2':    2,
    'bvec3':    3,
    'bvec4':    4,

    'mat2':     4,
    'mat3':     9,
    'mat4':     16,

    'sampler2D':  1
};

module.exports = mapSize;

},{}],45:[function(require,module,exports){


var mapType = function(gl, type) 
{
    if(!GL_TABLE) 
    {
        var typeNames = Object.keys(GL_TO_GLSL_TYPES);

        GL_TABLE = {};

        for(var i = 0; i < typeNames.length; ++i) 
        {
            var tn = typeNames[i];
            GL_TABLE[ gl[tn] ] = GL_TO_GLSL_TYPES[tn];
        }
    }

  return GL_TABLE[type];
};

var GL_TABLE = null;

var GL_TO_GLSL_TYPES = {
  'FLOAT':       'float',
  'FLOAT_VEC2':  'vec2',
  'FLOAT_VEC3':  'vec3',
  'FLOAT_VEC4':  'vec4',

  'INT':         'int',
  'INT_VEC2':    'ivec2',
  'INT_VEC3':    'ivec3',
  'INT_VEC4':    'ivec4',
  
  'BOOL':        'bool',
  'BOOL_VEC2':   'bvec2',
  'BOOL_VEC3':   'bvec3',
  'BOOL_VEC4':   'bvec4',
  
  'FLOAT_MAT2':  'mat2',
  'FLOAT_MAT3':  'mat3',
  'FLOAT_MAT4':  'mat4',
  
  'SAMPLER_2D':  'sampler2D'  
};

module.exports = mapType;

},{}],46:[function(require,module,exports){
/**
 * Sets the float precision on the shader. If the precision is already present this function will do nothing
 * @param {string} src       the shader source
 * @param {string} precision The float precision of the shader. Options are 'lowp', 'mediump' or 'highp'.
 *
 * @return {string} modified shader source
 */
var setPrecision = function(src, precision)
{
    if(src.substring(0, 9) !== 'precision')
    {
        return 'precision ' + precision + ' float;\n' + src;
    }

    return src;
};

module.exports = setPrecision;

},{}],47:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _core = require('../core');

var core = _interopRequireWildcard(_core);

var _ismobilejs = require('ismobilejs');

var _ismobilejs2 = _interopRequireDefault(_ismobilejs);

var _accessibleTarget = require('./accessibleTarget');

var _accessibleTarget2 = _interopRequireDefault(_accessibleTarget);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// add some extra variables to the container..
core.utils.mixins.delayMixin(core.DisplayObject.prototype, _accessibleTarget2.default);

var KEY_CODE_TAB = 9;

var DIV_TOUCH_SIZE = 100;
var DIV_TOUCH_POS_X = 0;
var DIV_TOUCH_POS_Y = 0;
var DIV_TOUCH_ZINDEX = 2;

var DIV_HOOK_SIZE = 1;
var DIV_HOOK_POS_X = -1000;
var DIV_HOOK_POS_Y = -1000;
var DIV_HOOK_ZINDEX = 2;

/**
 * The Accessibility manager recreates the ability to tab and have content read by screen
 * readers. This is very important as it can possibly help people with disabilities access pixi
 * content.
 *
 * Much like interaction any DisplayObject can be made accessible. This manager will map the
 * events as if the mouse was being used, minimizing the effort required to implement.
 *
 * An instance of this class is automatically created by default, and can be found at renderer.plugins.accessibility
 *
 * @class
 * @memberof PIXI.accessibility
 */

var AccessibilityManager = function () {
    /**
     * @param {PIXI.CanvasRenderer|PIXI.WebGLRenderer} renderer - A reference to the current renderer
     */
    function AccessibilityManager(renderer) {
        _classCallCheck(this, AccessibilityManager);

        if ((_ismobilejs2.default.tablet || _ismobilejs2.default.phone) && !navigator.isCocoonJS) {
            this.createTouchHook();
        }

        // first we create a div that will sit over the PixiJS element. This is where the div overlays will go.
        var div = document.createElement('div');

        div.style.width = DIV_TOUCH_SIZE + 'px';
        div.style.height = DIV_TOUCH_SIZE + 'px';
        div.style.position = 'absolute';
        div.style.top = DIV_TOUCH_POS_X + 'px';
        div.style.left = DIV_TOUCH_POS_Y + 'px';
        div.style.zIndex = DIV_TOUCH_ZINDEX;

        /**
         * This is the dom element that will sit over the PixiJS element. This is where the div overlays will go.
         *
         * @type {HTMLElement}
         * @private
         */
        this.div = div;

        /**
         * A simple pool for storing divs.
         *
         * @type {*}
         * @private
         */
        this.pool = [];

        /**
         * This is a tick used to check if an object is no longer being rendered.
         *
         * @type {Number}
         * @private
         */
        this.renderId = 0;

        /**
         * Setting this to true will visually show the divs.
         *
         * @type {boolean}
         */
        this.debug = false;

        /**
         * The renderer this accessibility manager works for.
         *
         * @member {PIXI.SystemRenderer}
         */
        this.renderer = renderer;

        /**
         * The array of currently active accessible items.
         *
         * @member {Array<*>}
         * @private
         */
        this.children = [];

        /**
         * pre-bind the functions
         *
         * @private
         */
        this._onKeyDown = this._onKeyDown.bind(this);
        this._onMouseMove = this._onMouseMove.bind(this);

        /**
         * stores the state of the manager. If there are no accessible objects or the mouse is moving, this will be false.
         *
         * @member {Array<*>}
         * @private
         */
        this.isActive = false;
        this.isMobileAccessabillity = false;

        // let listen for tab.. once pressed we can fire up and show the accessibility layer
        window.addEventListener('keydown', this._onKeyDown, false);
    }

    /**
     * Creates the touch hooks.
     *
     */


    AccessibilityManager.prototype.createTouchHook = function createTouchHook() {
        var _this = this;

        var hookDiv = document.createElement('button');

        hookDiv.style.width = DIV_HOOK_SIZE + 'px';
        hookDiv.style.height = DIV_HOOK_SIZE + 'px';
        hookDiv.style.position = 'absolute';
        hookDiv.style.top = DIV_HOOK_POS_X + 'px';
        hookDiv.style.left = DIV_HOOK_POS_Y + 'px';
        hookDiv.style.zIndex = DIV_HOOK_ZINDEX;
        hookDiv.style.backgroundColor = '#FF0000';
        hookDiv.title = 'HOOK DIV';

        hookDiv.addEventListener('focus', function () {
            _this.isMobileAccessabillity = true;
            _this.activate();
            document.body.removeChild(hookDiv);
        });

        document.body.appendChild(hookDiv);
    };

    /**
     * Activating will cause the Accessibility layer to be shown. This is called when a user
     * preses the tab key.
     *
     * @private
     */


    AccessibilityManager.prototype.activate = function activate() {
        if (this.isActive) {
            return;
        }

        this.isActive = true;

        window.document.addEventListener('mousemove', this._onMouseMove, true);
        window.removeEventListener('keydown', this._onKeyDown, false);

        this.renderer.on('postrender', this.update, this);

        if (this.renderer.view.parentNode) {
            this.renderer.view.parentNode.appendChild(this.div);
        }
    };

    /**
     * Deactivating will cause the Accessibility layer to be hidden. This is called when a user moves
     * the mouse.
     *
     * @private
     */


    AccessibilityManager.prototype.deactivate = function deactivate() {
        if (!this.isActive || this.isMobileAccessabillity) {
            return;
        }

        this.isActive = false;

        window.document.removeEventListener('mousemove', this._onMouseMove, true);
        window.addEventListener('keydown', this._onKeyDown, false);

        this.renderer.off('postrender', this.update);

        if (this.div.parentNode) {
            this.div.parentNode.removeChild(this.div);
        }
    };

    /**
     * This recursive function will run through the scene graph and add any new accessible objects to the DOM layer.
     *
     * @private
     * @param {PIXI.Container} displayObject - The DisplayObject to check.
     */


    AccessibilityManager.prototype.updateAccessibleObjects = function updateAccessibleObjects(displayObject) {
        if (!displayObject.visible) {
            return;
        }

        if (displayObject.accessible && displayObject.interactive) {
            if (!displayObject._accessibleActive) {
                this.addChild(displayObject);
            }

            displayObject.renderId = this.renderId;
        }

        var children = displayObject.children;

        for (var i = 0; i < children.length; i++) {
            this.updateAccessibleObjects(children[i]);
        }
    };

    /**
     * Before each render this function will ensure that all divs are mapped correctly to their DisplayObjects.
     *
     * @private
     */


    AccessibilityManager.prototype.update = function update() {
        if (!this.renderer.renderingToScreen) {
            return;
        }

        // update children...
        this.updateAccessibleObjects(this.renderer._lastObjectRendered);

        var rect = this.renderer.view.getBoundingClientRect();
        var sx = rect.width / this.renderer.width;
        var sy = rect.height / this.renderer.height;

        var div = this.div;

        div.style.left = rect.left + 'px';
        div.style.top = rect.top + 'px';
        div.style.width = this.renderer.width + 'px';
        div.style.height = this.renderer.height + 'px';

        for (var i = 0; i < this.children.length; i++) {
            var child = this.children[i];

            if (child.renderId !== this.renderId) {
                child._accessibleActive = false;

                core.utils.removeItems(this.children, i, 1);
                this.div.removeChild(child._accessibleDiv);
                this.pool.push(child._accessibleDiv);
                child._accessibleDiv = null;

                i--;

                if (this.children.length === 0) {
                    this.deactivate();
                }
            } else {
                // map div to display..
                div = child._accessibleDiv;
                var hitArea = child.hitArea;
                var wt = child.worldTransform;

                if (child.hitArea) {
                    div.style.left = (wt.tx + hitArea.x * wt.a) * sx + 'px';
                    div.style.top = (wt.ty + hitArea.y * wt.d) * sy + 'px';

                    div.style.width = hitArea.width * wt.a * sx + 'px';
                    div.style.height = hitArea.height * wt.d * sy + 'px';
                } else {
                    hitArea = child.getBounds();

                    this.capHitArea(hitArea);

                    div.style.left = hitArea.x * sx + 'px';
                    div.style.top = hitArea.y * sy + 'px';

                    div.style.width = hitArea.width * sx + 'px';
                    div.style.height = hitArea.height * sy + 'px';

                    // update button titles and hints if they exist and they've changed
                    if (div.title !== child.accessibleTitle && child.accessibleTitle !== null) {
                        div.title = child.accessibleTitle;
                    }
                    if (div.getAttribute('aria-label') !== child.accessibleHint && child.accessibleHint !== null) {
                        div.setAttribute('aria-label', child.accessibleHint);
                    }
                }
            }
        }

        // increment the render id..
        this.renderId++;
    };

    /**
     * TODO: docs.
     *
     * @param {Rectangle} hitArea - TODO docs
     */


    AccessibilityManager.prototype.capHitArea = function capHitArea(hitArea) {
        if (hitArea.x < 0) {
            hitArea.width += hitArea.x;
            hitArea.x = 0;
        }

        if (hitArea.y < 0) {
            hitArea.height += hitArea.y;
            hitArea.y = 0;
        }

        if (hitArea.x + hitArea.width > this.renderer.width) {
            hitArea.width = this.renderer.width - hitArea.x;
        }

        if (hitArea.y + hitArea.height > this.renderer.height) {
            hitArea.height = this.renderer.height - hitArea.y;
        }
    };

    /**
     * Adds a DisplayObject to the accessibility manager
     *
     * @private
     * @param {DisplayObject} displayObject - The child to make accessible.
     */


    AccessibilityManager.prototype.addChild = function addChild(displayObject) {
        //    this.activate();

        var div = this.pool.pop();

        if (!div) {
            div = document.createElement('button');

            div.style.width = DIV_TOUCH_SIZE + 'px';
            div.style.height = DIV_TOUCH_SIZE + 'px';
            div.style.backgroundColor = this.debug ? 'rgba(255,0,0,0.5)' : 'transparent';
            div.style.position = 'absolute';
            div.style.zIndex = DIV_TOUCH_ZINDEX;
            div.style.borderStyle = 'none';

            // ARIA attributes ensure that button title and hint updates are announced properly
            if (navigator.userAgent.toLowerCase().indexOf('chrome') > -1) {
                // Chrome doesn't need aria-live to work as intended; in fact it just gets more confused.
                div.setAttribute('aria-live', 'off');
            } else {
                div.setAttribute('aria-live', 'polite');
            }

            if (navigator.userAgent.match(/rv:.*Gecko\//)) {
                // FireFox needs this to announce only the new button name
                div.setAttribute('aria-relevant', 'additions');
            } else {
                // required by IE, other browsers don't much care
                div.setAttribute('aria-relevant', 'text');
            }

            div.addEventListener('click', this._onClick.bind(this));
            div.addEventListener('focus', this._onFocus.bind(this));
            div.addEventListener('focusout', this._onFocusOut.bind(this));
        }

        if (displayObject.accessibleTitle && displayObject.accessibleTitle !== null) {
            div.title = displayObject.accessibleTitle;
        } else if (!displayObject.accessibleHint || displayObject.accessibleHint === null) {
            div.title = 'displayObject ' + displayObject.tabIndex;
        }

        if (displayObject.accessibleHint && displayObject.accessibleHint !== null) {
            div.setAttribute('aria-label', displayObject.accessibleHint);
        }

        //

        displayObject._accessibleActive = true;
        displayObject._accessibleDiv = div;
        div.displayObject = displayObject;

        this.children.push(displayObject);
        this.div.appendChild(displayObject._accessibleDiv);
        displayObject._accessibleDiv.tabIndex = displayObject.tabIndex;
    };

    /**
     * Maps the div button press to pixi's InteractionManager (click)
     *
     * @private
     * @param {MouseEvent} e - The click event.
     */


    AccessibilityManager.prototype._onClick = function _onClick(e) {
        var interactionManager = this.renderer.plugins.interaction;

        interactionManager.dispatchEvent(e.target.displayObject, 'click', interactionManager.eventData);
    };

    /**
     * Maps the div focus events to pixi's InteractionManager (mouseover)
     *
     * @private
     * @param {FocusEvent} e - The focus event.
     */


    AccessibilityManager.prototype._onFocus = function _onFocus(e) {
        if (!e.target.getAttribute('aria-live', 'off')) {
            e.target.setAttribute('aria-live', 'assertive');
        }
        var interactionManager = this.renderer.plugins.interaction;

        interactionManager.dispatchEvent(e.target.displayObject, 'mouseover', interactionManager.eventData);
    };

    /**
     * Maps the div focus events to pixi's InteractionManager (mouseout)
     *
     * @private
     * @param {FocusEvent} e - The focusout event.
     */


    AccessibilityManager.prototype._onFocusOut = function _onFocusOut(e) {
        if (!e.target.getAttribute('aria-live', 'off')) {
            e.target.setAttribute('aria-live', 'polite');
        }
        var interactionManager = this.renderer.plugins.interaction;

        interactionManager.dispatchEvent(e.target.displayObject, 'mouseout', interactionManager.eventData);
    };

    /**
     * Is called when a key is pressed
     *
     * @private
     * @param {KeyboardEvent} e - The keydown event.
     */


    AccessibilityManager.prototype._onKeyDown = function _onKeyDown(e) {
        if (e.keyCode !== KEY_CODE_TAB) {
            return;
        }

        this.activate();
    };

    /**
     * Is called when the mouse moves across the renderer element
     *
     * @private
     * @param {MouseEvent} e - The mouse event.
     */


    AccessibilityManager.prototype._onMouseMove = function _onMouseMove(e) {
        if (e.movementX === 0 && e.movementY === 0) {
            return;
        }

        this.deactivate();
    };

    /**
     * Destroys the accessibility manager
     *
     */


    AccessibilityManager.prototype.destroy = function destroy() {
        this.div = null;

        for (var i = 0; i < this.children.length; i++) {
            this.children[i].div = null;
        }

        window.document.removeEventListener('mousemove', this._onMouseMove, true);
        window.removeEventListener('keydown', this._onKeyDown);

        this.pool = null;
        this.children = null;
        this.renderer = null;
    };

    return AccessibilityManager;
}();

exports.default = AccessibilityManager;


core.WebGLRenderer.registerPlugin('accessibility', AccessibilityManager);
core.CanvasRenderer.registerPlugin('accessibility', AccessibilityManager);

},{"../core":72,"./accessibleTarget":48,"ismobilejs":25}],48:[function(require,module,exports){
"use strict";

exports.__esModule = true;
/**
 * Default property values of accessible objects
 * used by {@link PIXI.accessibility.AccessibilityManager}.
 *
 * @function accessibleTarget
 * @memberof PIXI.accessibility
 * @example
 *      function MyObject() {}
 *
 *      Object.assign(
 *          MyObject.prototype,
 *          PIXI.accessibility.accessibleTarget
 *      );
 */
exports.default = {
  /**
   *  Flag for if the object is accessible. If true AccessibilityManager will overlay a
   *   shadow div with attributes set
   *
   * @member {boolean}
   */
  accessible: false,

  /**
   * Sets the title attribute of the shadow div
   * If accessibleTitle AND accessibleHint has not been this will default to 'displayObject [tabIndex]'
   *
   * @member {string}
   */
  accessibleTitle: null,

  /**
   * Sets the aria-label attribute of the shadow div
   *
   * @member {string}
   */
  accessibleHint: null,

  /**
   * @todo Needs docs.
   */
  tabIndex: 0,

  /**
   * @todo Needs docs.
   */
  _accessibleActive: false,

  /**
   * @todo Needs docs.
   */
  _accessibleDiv: false
};

},{}],49:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _accessibleTarget = require('./accessibleTarget');

Object.defineProperty(exports, 'accessibleTarget', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_accessibleTarget).default;
  }
});

var _AccessibilityManager = require('./AccessibilityManager');

Object.defineProperty(exports, 'AccessibilityManager', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_AccessibilityManager).default;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

},{"./AccessibilityManager":47,"./accessibleTarget":48}],50:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _autoDetectRenderer = require('./autoDetectRenderer');

var _Container = require('./display/Container');

var _Container2 = _interopRequireDefault(_Container);

var _ticker = require('./ticker');

var _settings = require('./settings');

var _settings2 = _interopRequireDefault(_settings);

var _const = require('./const');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Convenience class to create a new PIXI application.
 * This class automatically creates the renderer, ticker
 * and root container.
 *
 * @example
 * // Create the application
 * const app = new PIXI.Application();
 *
 * // Add the view to the DOM
 * document.body.appendChild(app.view);
 *
 * // ex, add display objects
 * app.stage.addChild(PIXI.Sprite.fromImage('something.png'));
 *
 * @class
 * @memberof PIXI
 */
var Application = function () {
    // eslint-disable-next-line valid-jsdoc
    /**
     * @param {object} [options] - The optional renderer parameters
     * @param {boolean} [options.autoStart=true] - automatically starts the rendering after the construction.
     *     Note that setting this parameter to false does NOT stop the shared ticker even if you set
     *     options.sharedTicker to true in case that it is already started. Stop it by your own.
     * @param {number} [options.width=800] - the width of the renderers view
     * @param {number} [options.height=600] - the height of the renderers view
     * @param {HTMLCanvasElement} [options.view] - the canvas to use as a view, optional
     * @param {boolean} [options.transparent=false] - If the render view is transparent, default false
     * @param {boolean} [options.antialias=false] - sets antialias (only applicable in chrome at the moment)
     * @param {boolean} [options.preserveDrawingBuffer=false] - enables drawing buffer preservation, enable this if you
     *  need to call toDataUrl on the webgl context
     * @param {number} [options.resolution=1] - The resolution / device pixel ratio of the renderer, retina would be 2
     * @param {boolean} [options.forceCanvas=false] - prevents selection of WebGL renderer, even if such is present
     * @param {number} [options.backgroundColor=0x000000] - The background color of the rendered area
     *  (shown if not transparent).
     * @param {boolean} [options.clearBeforeRender=true] - This sets if the renderer will clear the canvas or
     *   not before the new render pass.
     * @param {boolean} [options.roundPixels=false] - If true PixiJS will Math.floor() x/y values when rendering,
     *  stopping pixel interpolation.
     * @param {boolean} [options.forceFXAA=false] - forces FXAA antialiasing to be used over native.
     *  FXAA is faster, but may not always look as great **webgl only**
     * @param {boolean} [options.legacy=false] - `true` to ensure compatibility with older / less advanced devices.
     *  If you experience unexplained flickering try setting this to true. **webgl only**
     * @param {string} [options.powerPreference] - Parameter passed to webgl context, set to "high-performance"
     *  for devices with dual graphics card **webgl only**
     * @param {boolean} [options.sharedTicker=false] - `true` to use PIXI.ticker.shared, `false` to create new ticker.
     * @param {boolean} [options.sharedLoader=false] - `true` to use PIXI.loaders.shared, `false` to create new Loader.
     */
    function Application(options, arg2, arg3, arg4, arg5) {
        _classCallCheck(this, Application);

        // Support for constructor(width, height, options, noWebGL, useSharedTicker)
        if (typeof options === 'number') {
            options = Object.assign({
                width: options,
                height: arg2 || _settings2.default.RENDER_OPTIONS.height,
                forceCanvas: !!arg4,
                sharedTicker: !!arg5
            }, arg3);
        }

        /**
         * The default options, so we mixin functionality later.
         * @member {object}
         * @protected
         */
        this._options = options = Object.assign({
            autoStart: true,
            sharedTicker: false,
            forceCanvas: false,
            sharedLoader: false
        }, options);

        /**
         * WebGL renderer if available, otherwise CanvasRenderer
         * @member {PIXI.WebGLRenderer|PIXI.CanvasRenderer}
         */
        this.renderer = (0, _autoDetectRenderer.autoDetectRenderer)(options);

        /**
         * The root display container that's rendered.
         * @member {PIXI.Container}
         */
        this.stage = new _Container2.default();

        /**
         * Internal reference to the ticker
         * @member {PIXI.ticker.Ticker}
         * @private
         */
        this._ticker = null;

        /**
         * Ticker for doing render updates.
         * @member {PIXI.ticker.Ticker}
         * @default PIXI.ticker.shared
         */
        this.ticker = options.sharedTicker ? _ticker.shared : new _ticker.Ticker();

        // Start the rendering
        if (options.autoStart) {
            this.start();
        }
    }

    /**
     * Render the current stage.
     */
    Application.prototype.render = function render() {
        this.renderer.render(this.stage);
    };

    /**
     * Convenience method for stopping the render.
     */


    Application.prototype.stop = function stop() {
        this._ticker.stop();
    };

    /**
     * Convenience method for starting the render.
     */


    Application.prototype.start = function start() {
        this._ticker.start();
    };

    /**
     * Reference to the renderer's canvas element.
     * @member {HTMLCanvasElement}
     * @readonly
     */


    /**
     * Destroy and don't use after this.
     * @param {Boolean} [removeView=false] Automatically remove canvas from DOM.
     * @param {object|boolean} [stageOptions] - Options parameter. A boolean will act as if all options
     *  have been set to that value
     * @param {boolean} [stageOptions.children=false] - if set to true, all the children will have their destroy
     *  method called as well. 'stageOptions' will be passed on to those calls.
     * @param {boolean} [stageOptions.texture=false] - Only used for child Sprites if stageOptions.children is set
     *  to true. Should it destroy the texture of the child sprite
     * @param {boolean} [stageOptions.baseTexture=false] - Only used for child Sprites if stageOptions.children is set
     *  to true. Should it destroy the base texture of the child sprite
     */
    Application.prototype.destroy = function destroy(removeView, stageOptions) {
        if (this._ticker) {
            var oldTicker = this._ticker;

            this.ticker = null;
            oldTicker.destroy();
        }

        this.stage.destroy(stageOptions);
        this.stage = null;

        this.renderer.destroy(removeView);
        this.renderer = null;

        this._options = null;
    };

    _createClass(Application, [{
        key: 'ticker',
        set: function set(ticker) // eslint-disable-line require-jsdoc
        {
            if (this._ticker) {
                this._ticker.remove(this.render, this);
            }
            this._ticker = ticker;
            if (ticker) {
                ticker.add(this.render, this, _const.UPDATE_PRIORITY.LOW);
            }
        },
        get: function get() // eslint-disable-line require-jsdoc
        {
            return this._ticker;
        }
    }, {
        key: 'view',
        get: function get() {
            return this.renderer.view;
        }

        /**
         * Reference to the renderer's screen rectangle. Its safe to use as filterArea or hitArea for whole screen
         * @member {PIXI.Rectangle}
         * @readonly
         */

    }, {
        key: 'screen',
        get: function get() {
            return this.renderer.screen;
        }
    }]);

    return Application;
}();

exports.default = Application;

},{"./autoDetectRenderer":52,"./const":53,"./display/Container":55,"./settings":108,"./ticker":128}],51:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _pixiGlCore = require('pixi-gl-core');

var _settings = require('./settings');

var _settings2 = _interopRequireDefault(_settings);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function checkPrecision(src, def) {
    if (src instanceof Array) {
        if (src[0].substring(0, 9) !== 'precision') {
            var copy = src.slice(0);

            copy.unshift('precision ' + def + ' float;');

            return copy;
        }
    } else if (src.trim().substring(0, 9) !== 'precision') {
        return 'precision ' + def + ' float;\n' + src;
    }

    return src;
}

/**
 * Wrapper class, webGL Shader for Pixi.
 * Adds precision string if vertexSrc or fragmentSrc have no mention of it.
 *
 * @class
 * @extends GLShader
 * @memberof PIXI
 */

var Shader = function (_GLShader) {
    _inherits(Shader, _GLShader);

    /**
     *
     * @param {WebGLRenderingContext} gl - The current WebGL rendering context
     * @param {string|string[]} vertexSrc - The vertex shader source as an array of strings.
     * @param {string|string[]} fragmentSrc - The fragment shader source as an array of strings.
     * @param {object} [attributeLocations] - A key value pair showing which location eact attribute should sit.
                       e.g. {position:0, uvs:1}.
     * @param {string} [precision] - The float precision of the shader. Options are 'lowp', 'mediump' or 'highp'.
     */
    function Shader(gl, vertexSrc, fragmentSrc, attributeLocations, precision) {
        _classCallCheck(this, Shader);

        return _possibleConstructorReturn(this, _GLShader.call(this, gl, checkPrecision(vertexSrc, precision || _settings2.default.PRECISION_VERTEX), checkPrecision(fragmentSrc, precision || _settings2.default.PRECISION_FRAGMENT), undefined, attributeLocations));
    }

    return Shader;
}(_pixiGlCore.GLShader);

exports.default = Shader;

},{"./settings":108,"pixi-gl-core":36}],52:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.autoDetectRenderer = autoDetectRenderer;

var _utils = require('./utils');

var utils = _interopRequireWildcard(_utils);

var _CanvasRenderer = require('./renderers/canvas/CanvasRenderer');

var _CanvasRenderer2 = _interopRequireDefault(_CanvasRenderer);

var _WebGLRenderer = require('./renderers/webgl/WebGLRenderer');

var _WebGLRenderer2 = _interopRequireDefault(_WebGLRenderer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

// eslint-disable-next-line valid-jsdoc
/**
 * This helper function will automatically detect which renderer you should be using.
 * WebGL is the preferred renderer as it is a lot faster. If webGL is not supported by
 * the browser then this function will return a canvas renderer
 *
 * @memberof PIXI
 * @function autoDetectRenderer
 * @param {object} [options] - The optional renderer parameters
 * @param {number} [options.width=800] - the width of the renderers view
 * @param {number} [options.height=600] - the height of the renderers view
 * @param {HTMLCanvasElement} [options.view] - the canvas to use as a view, optional
 * @param {boolean} [options.transparent=false] - If the render view is transparent, default false
 * @param {boolean} [options.antialias=false] - sets antialias (only applicable in chrome at the moment)
 * @param {boolean} [options.preserveDrawingBuffer=false] - enables drawing buffer preservation, enable this if you
 *  need to call toDataUrl on the webgl context
 * @param {number} [options.backgroundColor=0x000000] - The background color of the rendered area
 *  (shown if not transparent).
 * @param {boolean} [options.clearBeforeRender=true] - This sets if the renderer will clear the canvas or
 *   not before the new render pass.
 * @param {number} [options.resolution=1] - The resolution / device pixel ratio of the renderer, retina would be 2
 * @param {boolean} [options.forceCanvas=false] - prevents selection of WebGL renderer, even if such is present
 * @param {boolean} [options.roundPixels=false] - If true PixiJS will Math.floor() x/y values when rendering,
 *  stopping pixel interpolation.
 * @param {boolean} [options.forceFXAA=false] - forces FXAA antialiasing to be used over native.
 *  FXAA is faster, but may not always look as great **webgl only**
 * @param {boolean} [options.legacy=false] - `true` to ensure compatibility with older / less advanced devices.
 *  If you experience unexplained flickering try setting this to true. **webgl only**
 * @param {string} [options.powerPreference] - Parameter passed to webgl context, set to "high-performance"
 *  for devices with dual graphics card **webgl only**
 * @return {PIXI.WebGLRenderer|PIXI.CanvasRenderer} Returns WebGL renderer if available, otherwise CanvasRenderer
 */
function autoDetectRenderer(options, arg1, arg2, arg3) {
    // Backward-compatible support for noWebGL option
    var forceCanvas = options && options.forceCanvas;

    if (arg3 !== undefined) {
        forceCanvas = arg3;
    }

    if (!forceCanvas && utils.isWebGLSupported()) {
        return new _WebGLRenderer2.default(options, arg1, arg2);
    }

    return new _CanvasRenderer2.default(options, arg1, arg2);
}

},{"./renderers/canvas/CanvasRenderer":84,"./renderers/webgl/WebGLRenderer":91,"./utils":132}],53:[function(require,module,exports){
'use strict';

exports.__esModule = true;
/**
 * String of the current PIXI version.
 *
 * @static
 * @constant
 * @memberof PIXI
 * @name VERSION
 * @type {string}
 */
var VERSION = exports.VERSION = '4.8.8';

/**
 * Two Pi.
 *
 * @static
 * @constant
 * @memberof PIXI
 * @type {number}
 */
var PI_2 = exports.PI_2 = Math.PI * 2;

/**
 * Conversion factor for converting radians to degrees.
 *
 * @static
 * @constant
 * @memberof PIXI
 * @type {number}
 */
var RAD_TO_DEG = exports.RAD_TO_DEG = 180 / Math.PI;

/**
 * Conversion factor for converting degrees to radians.
 *
 * @static
 * @constant
 * @memberof PIXI
 * @type {number}
 */
var DEG_TO_RAD = exports.DEG_TO_RAD = Math.PI / 180;

/**
 * Constant to identify the Renderer Type.
 *
 * @static
 * @constant
 * @memberof PIXI
 * @name RENDERER_TYPE
 * @type {object}
 * @property {number} UNKNOWN - Unknown render type.
 * @property {number} WEBGL - WebGL render type.
 * @property {number} CANVAS - Canvas render type.
 */
var RENDERER_TYPE = exports.RENDERER_TYPE = {
  UNKNOWN: 0,
  WEBGL: 1,
  CANVAS: 2
};

/**
 * Various blend modes supported by PIXI.
 *
 * IMPORTANT - The WebGL renderer only supports the NORMAL, ADD, MULTIPLY and SCREEN blend modes.
 * Anything else will silently act like NORMAL.
 *
 * @static
 * @constant
 * @memberof PIXI
 * @name BLEND_MODES
 * @type {object}
 * @property {number} NORMAL
 * @property {number} ADD
 * @property {number} MULTIPLY
 * @property {number} SCREEN
 * @property {number} OVERLAY
 * @property {number} DARKEN
 * @property {number} LIGHTEN
 * @property {number} COLOR_DODGE
 * @property {number} COLOR_BURN
 * @property {number} HARD_LIGHT
 * @property {number} SOFT_LIGHT
 * @property {number} DIFFERENCE
 * @property {number} EXCLUSION
 * @property {number} HUE
 * @property {number} SATURATION
 * @property {number} COLOR
 * @property {number} LUMINOSITY
 */
var BLEND_MODES = exports.BLEND_MODES = {
  NORMAL: 0,
  ADD: 1,
  MULTIPLY: 2,
  SCREEN: 3,
  OVERLAY: 4,
  DARKEN: 5,
  LIGHTEN: 6,
  COLOR_DODGE: 7,
  COLOR_BURN: 8,
  HARD_LIGHT: 9,
  SOFT_LIGHT: 10,
  DIFFERENCE: 11,
  EXCLUSION: 12,
  HUE: 13,
  SATURATION: 14,
  COLOR: 15,
  LUMINOSITY: 16,
  NORMAL_NPM: 17,
  ADD_NPM: 18,
  SCREEN_NPM: 19
};

/**
 * Various webgl draw modes. These can be used to specify which GL drawMode to use
 * under certain situations and renderers.
 *
 * @static
 * @constant
 * @memberof PIXI
 * @name DRAW_MODES
 * @type {object}
 * @property {number} POINTS
 * @property {number} LINES
 * @property {number} LINE_LOOP
 * @property {number} LINE_STRIP
 * @property {number} TRIANGLES
 * @property {number} TRIANGLE_STRIP
 * @property {number} TRIANGLE_FAN
 */
var DRAW_MODES = exports.DRAW_MODES = {
  POINTS: 0,
  LINES: 1,
  LINE_LOOP: 2,
  LINE_STRIP: 3,
  TRIANGLES: 4,
  TRIANGLE_STRIP: 5,
  TRIANGLE_FAN: 6
};

/**
 * The scale modes that are supported by pixi.
 *
 * The {@link PIXI.settings.SCALE_MODE} scale mode affects the default scaling mode of future operations.
 * It can be re-assigned to either LINEAR or NEAREST, depending upon suitability.
 *
 * @static
 * @constant
 * @memberof PIXI
 * @name SCALE_MODES
 * @type {object}
 * @property {number} LINEAR Smooth scaling
 * @property {number} NEAREST Pixelating scaling
 */
var SCALE_MODES = exports.SCALE_MODES = {
  LINEAR: 0,
  NEAREST: 1
};

/**
 * The wrap modes that are supported by pixi.
 *
 * The {@link PIXI.settings.WRAP_MODE} wrap mode affects the default wrapping mode of future operations.
 * It can be re-assigned to either CLAMP or REPEAT, depending upon suitability.
 * If the texture is non power of two then clamp will be used regardless as webGL can
 * only use REPEAT if the texture is po2.
 *
 * This property only affects WebGL.
 *
 * @static
 * @constant
 * @name WRAP_MODES
 * @memberof PIXI
 * @type {object}
 * @property {number} CLAMP - The textures uvs are clamped
 * @property {number} REPEAT - The texture uvs tile and repeat
 * @property {number} MIRRORED_REPEAT - The texture uvs tile and repeat with mirroring
 */
var WRAP_MODES = exports.WRAP_MODES = {
  CLAMP: 0,
  REPEAT: 1,
  MIRRORED_REPEAT: 2
};

/**
 * The gc modes that are supported by pixi.
 *
 * The {@link PIXI.settings.GC_MODE} Garbage Collection mode for PixiJS textures is AUTO
 * If set to GC_MODE, the renderer will occasionally check textures usage. If they are not
 * used for a specified period of time they will be removed from the GPU. They will of course
 * be uploaded again when they are required. This is a silent behind the scenes process that
 * should ensure that the GPU does not  get filled up.
 *
 * Handy for mobile devices!
 * This property only affects WebGL.
 *
 * @static
 * @constant
 * @name GC_MODES
 * @memberof PIXI
 * @type {object}
 * @property {number} AUTO - Garbage collection will happen periodically automatically
 * @property {number} MANUAL - Garbage collection will need to be called manually
 */
var GC_MODES = exports.GC_MODES = {
  AUTO: 0,
  MANUAL: 1
};

/**
 * Regexp for image type by extension.
 *
 * @static
 * @constant
 * @memberof PIXI
 * @type {RegExp|string}
 * @example `image.png`
 */
var URL_FILE_EXTENSION = exports.URL_FILE_EXTENSION = /\.(\w{3,4})(?:$|\?|#)/i;

/**
 * Regexp for data URI.
 * Based on: {@link https://github.com/ragingwind/data-uri-regex}
 *
 * @static
 * @constant
 * @name DATA_URI
 * @memberof PIXI
 * @type {RegExp|string}
 * @example data:image/png;base64
 */
var DATA_URI = exports.DATA_URI = /^\s*data:(?:([\w-]+)\/([\w+.-]+))?(?:;charset=([\w-]+))?(?:;(base64))?,(.*)/i;

/**
 * Regexp for SVG size.
 *
 * @static
 * @constant
 * @name SVG_SIZE
 * @memberof PIXI
 * @type {RegExp|string}
 * @example &lt;svg width="100" height="100"&gt;&lt;/svg&gt;
 */
var SVG_SIZE = exports.SVG_SIZE = /<svg[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*>/i; // eslint-disable-line max-len

/**
 * Constants that identify shapes, mainly to prevent `instanceof` calls.
 *
 * @static
 * @constant
 * @name SHAPES
 * @memberof PIXI
 * @type {object}
 * @property {number} POLY Polygon
 * @property {number} RECT Rectangle
 * @property {number} CIRC Circle
 * @property {number} ELIP Ellipse
 * @property {number} RREC Rounded Rectangle
 */
var SHAPES = exports.SHAPES = {
  POLY: 0,
  RECT: 1,
  CIRC: 2,
  ELIP: 3,
  RREC: 4
};

/**
 * Constants that specify float precision in shaders.
 *
 * @static
 * @constant
 * @name PRECISION
 * @memberof PIXI
 * @type {object}
 * @property {string} LOW='lowp'
 * @property {string} MEDIUM='mediump'
 * @property {string} HIGH='highp'
 */
var PRECISION = exports.PRECISION = {
  LOW: 'lowp',
  MEDIUM: 'mediump',
  HIGH: 'highp'
};

/**
 * Constants that specify the transform type.
 *
 * @static
 * @constant
 * @name TRANSFORM_MODE
 * @memberof PIXI
 * @type {object}
 * @property {number} STATIC
 * @property {number} DYNAMIC
 */
var TRANSFORM_MODE = exports.TRANSFORM_MODE = {
  STATIC: 0,
  DYNAMIC: 1
};

/**
 * Constants that define the type of gradient on text.
 *
 * @static
 * @constant
 * @name TEXT_GRADIENT
 * @memberof PIXI
 * @type {object}
 * @property {number} LINEAR_VERTICAL Vertical gradient
 * @property {number} LINEAR_HORIZONTAL Linear gradient
 */
var TEXT_GRADIENT = exports.TEXT_GRADIENT = {
  LINEAR_VERTICAL: 0,
  LINEAR_HORIZONTAL: 1
};

/**
 * Represents the update priorities used by internal PIXI classes when registered with
 * the {@link PIXI.ticker.Ticker} object. Higher priority items are updated first and lower
 * priority items, such as render, should go later.
 *
 * @static
 * @constant
 * @name UPDATE_PRIORITY
 * @memberof PIXI
 * @type {object}
 * @property {number} INTERACTION=50 Highest priority, used for {@link PIXI.interaction.InteractionManager}
 * @property {number} HIGH=25 High priority updating, {@link PIXI.VideoBaseTexture} and {@link PIXI.extras.AnimatedSprite}
 * @property {number} NORMAL=0 Default priority for ticker events, see {@link PIXI.ticker.Ticker#add}.
 * @property {number} LOW=-25 Low priority used for {@link PIXI.Application} rendering.
 * @property {number} UTILITY=-50 Lowest priority used for {@link PIXI.prepare.BasePrepare} utility.
 */
var UPDATE_PRIORITY = exports.UPDATE_PRIORITY = {
  INTERACTION: 50,
  HIGH: 25,
  NORMAL: 0,
  LOW: -25,
  UTILITY: -50
};

},{}],54:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _math = require('../math');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * 'Builder' pattern for bounds rectangles
 * Axis-Aligned Bounding Box
 * It is not a shape! Its mutable thing, no 'EMPTY' or that kind of problems
 *
 * @class
 * @memberof PIXI
 */
var Bounds = function () {
    /**
     *
     */
    function Bounds() {
        _classCallCheck(this, Bounds);

        /**
         * @member {number}
         * @default 0
         */
        this.minX = Infinity;

        /**
         * @member {number}
         * @default 0
         */
        this.minY = Infinity;

        /**
         * @member {number}
         * @default 0
         */
        this.maxX = -Infinity;

        /**
         * @member {number}
         * @default 0
         */
        this.maxY = -Infinity;

        this.rect = null;
    }

    /**
     * Checks if bounds are empty.
     *
     * @return {boolean} True if empty.
     */


    Bounds.prototype.isEmpty = function isEmpty() {
        return this.minX > this.maxX || this.minY > this.maxY;
    };

    /**
     * Clears the bounds and resets.
     *
     */


    Bounds.prototype.clear = function clear() {
        this.updateID++;

        this.minX = Infinity;
        this.minY = Infinity;
        this.maxX = -Infinity;
        this.maxY = -Infinity;
    };

    /**
     * Can return Rectangle.EMPTY constant, either construct new rectangle, either use your rectangle
     * It is not guaranteed that it will return tempRect
     *
     * @param {PIXI.Rectangle} rect - temporary object will be used if AABB is not empty
     * @returns {PIXI.Rectangle} A rectangle of the bounds
     */


    Bounds.prototype.getRectangle = function getRectangle(rect) {
        if (this.minX > this.maxX || this.minY > this.maxY) {
            return _math.Rectangle.EMPTY;
        }

        rect = rect || new _math.Rectangle(0, 0, 1, 1);

        rect.x = this.minX;
        rect.y = this.minY;
        rect.width = this.maxX - this.minX;
        rect.height = this.maxY - this.minY;

        return rect;
    };

    /**
     * This function should be inlined when its possible.
     *
     * @param {PIXI.Point} point - The point to add.
     */


    Bounds.prototype.addPoint = function addPoint(point) {
        this.minX = Math.min(this.minX, point.x);
        this.maxX = Math.max(this.maxX, point.x);
        this.minY = Math.min(this.minY, point.y);
        this.maxY = Math.max(this.maxY, point.y);
    };

    /**
     * Adds a quad, not transformed
     *
     * @param {Float32Array} vertices - The verts to add.
     */


    Bounds.prototype.addQuad = function addQuad(vertices) {
        var minX = this.minX;
        var minY = this.minY;
        var maxX = this.maxX;
        var maxY = this.maxY;

        var x = vertices[0];
        var y = vertices[1];

        minX = x < minX ? x : minX;
        minY = y < minY ? y : minY;
        maxX = x > maxX ? x : maxX;
        maxY = y > maxY ? y : maxY;

        x = vertices[2];
        y = vertices[3];
        minX = x < minX ? x : minX;
        minY = y < minY ? y : minY;
        maxX = x > maxX ? x : maxX;
        maxY = y > maxY ? y : maxY;

        x = vertices[4];
        y = vertices[5];
        minX = x < minX ? x : minX;
        minY = y < minY ? y : minY;
        maxX = x > maxX ? x : maxX;
        maxY = y > maxY ? y : maxY;

        x = vertices[6];
        y = vertices[7];
        minX = x < minX ? x : minX;
        minY = y < minY ? y : minY;
        maxX = x > maxX ? x : maxX;
        maxY = y > maxY ? y : maxY;

        this.minX = minX;
        this.minY = minY;
        this.maxX = maxX;
        this.maxY = maxY;
    };

    /**
     * Adds sprite frame, transformed.
     *
     * @param {PIXI.TransformBase} transform - TODO
     * @param {number} x0 - TODO
     * @param {number} y0 - TODO
     * @param {number} x1 - TODO
     * @param {number} y1 - TODO
     */


    Bounds.prototype.addFrame = function addFrame(transform, x0, y0, x1, y1) {
        var matrix = transform.worldTransform;
        var a = matrix.a;
        var b = matrix.b;
        var c = matrix.c;
        var d = matrix.d;
        var tx = matrix.tx;
        var ty = matrix.ty;

        var minX = this.minX;
        var minY = this.minY;
        var maxX = this.maxX;
        var maxY = this.maxY;

        var x = a * x0 + c * y0 + tx;
        var y = b * x0 + d * y0 + ty;

        minX = x < minX ? x : minX;
        minY = y < minY ? y : minY;
        maxX = x > maxX ? x : maxX;
        maxY = y > maxY ? y : maxY;

        x = a * x1 + c * y0 + tx;
        y = b * x1 + d * y0 + ty;
        minX = x < minX ? x : minX;
        minY = y < minY ? y : minY;
        maxX = x > maxX ? x : maxX;
        maxY = y > maxY ? y : maxY;

        x = a * x0 + c * y1 + tx;
        y = b * x0 + d * y1 + ty;
        minX = x < minX ? x : minX;
        minY = y < minY ? y : minY;
        maxX = x > maxX ? x : maxX;
        maxY = y > maxY ? y : maxY;

        x = a * x1 + c * y1 + tx;
        y = b * x1 + d * y1 + ty;
        minX = x < minX ? x : minX;
        minY = y < minY ? y : minY;
        maxX = x > maxX ? x : maxX;
        maxY = y > maxY ? y : maxY;

        this.minX = minX;
        this.minY = minY;
        this.maxX = maxX;
        this.maxY = maxY;
    };

    /**
     * Add an array of vertices
     *
     * @param {PIXI.TransformBase} transform - TODO
     * @param {Float32Array} vertices - TODO
     * @param {number} beginOffset - TODO
     * @param {number} endOffset - TODO
     */


    Bounds.prototype.addVertices = function addVertices(transform, vertices, beginOffset, endOffset) {
        var matrix = transform.worldTransform;
        var a = matrix.a;
        var b = matrix.b;
        var c = matrix.c;
        var d = matrix.d;
        var tx = matrix.tx;
        var ty = matrix.ty;

        var minX = this.minX;
        var minY = this.minY;
        var maxX = this.maxX;
        var maxY = this.maxY;

        for (var i = beginOffset; i < endOffset; i += 2) {
            var rawX = vertices[i];
            var rawY = vertices[i + 1];
            var x = a * rawX + c * rawY + tx;
            var y = d * rawY + b * rawX + ty;

            minX = x < minX ? x : minX;
            minY = y < minY ? y : minY;
            maxX = x > maxX ? x : maxX;
            maxY = y > maxY ? y : maxY;
        }

        this.minX = minX;
        this.minY = minY;
        this.maxX = maxX;
        this.maxY = maxY;
    };

    /**
     * Adds other Bounds
     *
     * @param {PIXI.Bounds} bounds - TODO
     */


    Bounds.prototype.addBounds = function addBounds(bounds) {
        var minX = this.minX;
        var minY = this.minY;
        var maxX = this.maxX;
        var maxY = this.maxY;

        this.minX = bounds.minX < minX ? bounds.minX : minX;
        this.minY = bounds.minY < minY ? bounds.minY : minY;
        this.maxX = bounds.maxX > maxX ? bounds.maxX : maxX;
        this.maxY = bounds.maxY > maxY ? bounds.maxY : maxY;
    };

    /**
     * Adds other Bounds, masked with Bounds
     *
     * @param {PIXI.Bounds} bounds - TODO
     * @param {PIXI.Bounds} mask - TODO
     */


    Bounds.prototype.addBoundsMask = function addBoundsMask(bounds, mask) {
        var _minX = bounds.minX > mask.minX ? bounds.minX : mask.minX;
        var _minY = bounds.minY > mask.minY ? bounds.minY : mask.minY;
        var _maxX = bounds.maxX < mask.maxX ? bounds.maxX : mask.maxX;
        var _maxY = bounds.maxY < mask.maxY ? bounds.maxY : mask.maxY;

        if (_minX <= _maxX && _minY <= _maxY) {
            var minX = this.minX;
            var minY = this.minY;
            var maxX = this.maxX;
            var maxY = this.maxY;

            this.minX = _minX < minX ? _minX : minX;
            this.minY = _minY < minY ? _minY : minY;
            this.maxX = _maxX > maxX ? _maxX : maxX;
            this.maxY = _maxY > maxY ? _maxY : maxY;
        }
    };

    /**
     * Adds other Bounds, masked with Rectangle
     *
     * @param {PIXI.Bounds} bounds - TODO
     * @param {PIXI.Rectangle} area - TODO
     */


    Bounds.prototype.addBoundsArea = function addBoundsArea(bounds, area) {
        var _minX = bounds.minX > area.x ? bounds.minX : area.x;
        var _minY = bounds.minY > area.y ? bounds.minY : area.y;
        var _maxX = bounds.maxX < area.x + area.width ? bounds.maxX : area.x + area.width;
        var _maxY = bounds.maxY < area.y + area.height ? bounds.maxY : area.y + area.height;

        if (_minX <= _maxX && _minY <= _maxY) {
            var minX = this.minX;
            var minY = this.minY;
            var maxX = this.maxX;
            var maxY = this.maxY;

            this.minX = _minX < minX ? _minX : minX;
            this.minY = _minY < minY ? _minY : minY;
            this.maxX = _maxX > maxX ? _maxX : maxX;
            this.maxY = _maxY > maxY ? _maxY : maxY;
        }
    };

    return Bounds;
}();

exports.default = Bounds;

},{"../math":77}],55:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _utils = require('../utils');

var _DisplayObject2 = require('./DisplayObject');

var _DisplayObject3 = _interopRequireDefault(_DisplayObject2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * A Container represents a collection of display objects.
 * It is the base class of all display objects that act as a container for other objects.
 *
 *```js
 * let container = new PIXI.Container();
 * container.addChild(sprite);
 * ```
 *
 * @class
 * @extends PIXI.DisplayObject
 * @memberof PIXI
 */
var Container = function (_DisplayObject) {
    _inherits(Container, _DisplayObject);

    /**
     *
     */
    function Container() {
        _classCallCheck(this, Container);

        /**
         * The array of children of this container.
         *
         * @member {PIXI.DisplayObject[]}
         * @readonly
         */
        var _this = _possibleConstructorReturn(this, _DisplayObject.call(this));

        _this.children = [];
        return _this;
    }

    /**
     * Overridable method that can be used by Container subclasses whenever the children array is modified
     *
     * @private
     */


    Container.prototype.onChildrenChange = function onChildrenChange() {}
    /* empty */


    /**
     * Adds one or more children to the container.
     *
     * Multiple items can be added like so: `myContainer.addChild(thingOne, thingTwo, thingThree)`
     *
     * @param {...PIXI.DisplayObject} child - The DisplayObject(s) to add to the container
     * @return {PIXI.DisplayObject} The first child that was added.
     */
    ;

    Container.prototype.addChild = function addChild(child) {
        var argumentsLength = arguments.length;

        // if there is only one argument we can bypass looping through the them
        if (argumentsLength > 1) {
            // loop through the arguments property and add all children
            // use it the right way (.length and [i]) so that this function can still be optimised by JS runtimes
            for (var i = 0; i < argumentsLength; i++) {
                this.addChild(arguments[i]);
            }
        } else {
            // if the child has a parent then lets remove it as PixiJS objects can only exist in one place
            if (child.parent) {
                child.parent.removeChild(child);
            }

            child.parent = this;
            // ensure child transform will be recalculated
            child.transform._parentID = -1;

            this.children.push(child);

            // ensure bounds will be recalculated
            this._boundsID++;

            // TODO - lets either do all callbacks or all events.. not both!
            this.onChildrenChange(this.children.length - 1);
            child.emit('added', this);
        }

        return child;
    };

    /**
     * Adds a child to the container at a specified index. If the index is out of bounds an error will be thrown
     *
     * @param {PIXI.DisplayObject} child - The child to add
     * @param {number} index - The index to place the child in
     * @return {PIXI.DisplayObject} The child that was added.
     */


    Container.prototype.addChildAt = function addChildAt(child, index) {
        if (index < 0 || index > this.children.length) {
            throw new Error(child + 'addChildAt: The index ' + index + ' supplied is out of bounds ' + this.children.length);
        }

        if (child.parent) {
            child.parent.removeChild(child);
        }

        child.parent = this;
        // ensure child transform will be recalculated
        child.transform._parentID = -1;

        this.children.splice(index, 0, child);

        // ensure bounds will be recalculated
        this._boundsID++;

        // TODO - lets either do all callbacks or all events.. not both!
        this.onChildrenChange(index);
        child.emit('added', this);

        return child;
    };

    /**
     * Swaps the position of 2 Display Objects within this container.
     *
     * @param {PIXI.DisplayObject} child - First display object to swap
     * @param {PIXI.DisplayObject} child2 - Second display object to swap
     */


    Container.prototype.swapChildren = function swapChildren(child, child2) {
        if (child === child2) {
            return;
        }

        var index1 = this.getChildIndex(child);
        var index2 = this.getChildIndex(child2);

        this.children[index1] = child2;
        this.children[index2] = child;
        this.onChildrenChange(index1 < index2 ? index1 : index2);
    };

    /**
     * Returns the index position of a child DisplayObject instance
     *
     * @param {PIXI.DisplayObject} child - The DisplayObject instance to identify
     * @return {number} The index position of the child display object to identify
     */


    Container.prototype.getChildIndex = function getChildIndex(child) {
        var index = this.children.indexOf(child);

        if (index === -1) {
            throw new Error('The supplied DisplayObject must be a child of the caller');
        }

        return index;
    };

    /**
     * Changes the position of an existing child in the display object container
     *
     * @param {PIXI.DisplayObject} child - The child DisplayObject instance for which you want to change the index number
     * @param {number} index - The resulting index number for the child display object
     */


    Container.prototype.setChildIndex = function setChildIndex(child, index) {
        if (index < 0 || index >= this.children.length) {
            throw new Error('The index ' + index + ' supplied is out of bounds ' + this.children.length);
        }

        var currentIndex = this.getChildIndex(child);

        (0, _utils.removeItems)(this.children, currentIndex, 1); // remove from old position
        this.children.splice(index, 0, child); // add at new position

        this.onChildrenChange(index);
    };

    /**
     * Returns the child at the specified index
     *
     * @param {number} index - The index to get the child at
     * @return {PIXI.DisplayObject} The child at the given index, if any.
     */


    Container.prototype.getChildAt = function getChildAt(index) {
        if (index < 0 || index >= this.children.length) {
            throw new Error('getChildAt: Index (' + index + ') does not exist.');
        }

        return this.children[index];
    };

    /**
     * Removes one or more children from the container.
     *
     * @param {...PIXI.DisplayObject} child - The DisplayObject(s) to remove
     * @return {PIXI.DisplayObject} The first child that was removed.
     */


    Container.prototype.removeChild = function removeChild(child) {
        var argumentsLength = arguments.length;

        // if there is only one argument we can bypass looping through the them
        if (argumentsLength > 1) {
            // loop through the arguments property and add all children
            // use it the right way (.length and [i]) so that this function can still be optimised by JS runtimes
            for (var i = 0; i < argumentsLength; i++) {
                this.removeChild(arguments[i]);
            }
        } else {
            var index = this.children.indexOf(child);

            if (index === -1) return null;

            child.parent = null;
            // ensure child transform will be recalculated
            child.transform._parentID = -1;
            (0, _utils.removeItems)(this.children, index, 1);

            // ensure bounds will be recalculated
            this._boundsID++;

            // TODO - lets either do all callbacks or all events.. not both!
            this.onChildrenChange(index);
            child.emit('removed', this);
        }

        return child;
    };

    /**
     * Removes a child from the specified index position.
     *
     * @param {number} index - The index to get the child from
     * @return {PIXI.DisplayObject} The child that was removed.
     */


    Container.prototype.removeChildAt = function removeChildAt(index) {
        var child = this.getChildAt(index);

        // ensure child transform will be recalculated..
        child.parent = null;
        child.transform._parentID = -1;
        (0, _utils.removeItems)(this.children, index, 1);

        // ensure bounds will be recalculated
        this._boundsID++;

        // TODO - lets either do all callbacks or all events.. not both!
        this.onChildrenChange(index);
        child.emit('removed', this);

        return child;
    };

    /**
     * Removes all children from this container that are within the begin and end indexes.
     *
     * @param {number} [beginIndex=0] - The beginning position.
     * @param {number} [endIndex=this.children.length] - The ending position. Default value is size of the container.
     * @returns {DisplayObject[]} List of removed children
     */


    Container.prototype.removeChildren = function removeChildren() {
        var beginIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var endIndex = arguments[1];

        var begin = beginIndex;
        var end = typeof endIndex === 'number' ? endIndex : this.children.length;
        var range = end - begin;
        var removed = void 0;

        if (range > 0 && range <= end) {
            removed = this.children.splice(begin, range);

            for (var i = 0; i < removed.length; ++i) {
                removed[i].parent = null;
                if (removed[i].transform) {
                    removed[i].transform._parentID = -1;
                }
            }

            this._boundsID++;

            this.onChildrenChange(beginIndex);

            for (var _i = 0; _i < removed.length; ++_i) {
                removed[_i].emit('removed', this);
            }

            return removed;
        } else if (range === 0 && this.children.length === 0) {
            return [];
        }

        throw new RangeError('removeChildren: numeric values are outside the acceptable range.');
    };

    /**
     * Updates the transform on all children of this container for rendering
     */


    Container.prototype.updateTransform = function updateTransform() {
        this._boundsID++;

        this.transform.updateTransform(this.parent.transform);

        // TODO: check render flags, how to process stuff here
        this.worldAlpha = this.alpha * this.parent.worldAlpha;

        for (var i = 0, j = this.children.length; i < j; ++i) {
            var child = this.children[i];

            if (child.visible) {
                child.updateTransform();
            }
        }
    };

    /**
     * Recalculates the bounds of the container.
     *
     */


    Container.prototype.calculateBounds = function calculateBounds() {
        this._bounds.clear();

        this._calculateBounds();

        for (var i = 0; i < this.children.length; i++) {
            var child = this.children[i];

            if (!child.visible || !child.renderable) {
                continue;
            }

            child.calculateBounds();

            // TODO: filter+mask, need to mask both somehow
            if (child._mask) {
                child._mask.calculateBounds();
                this._bounds.addBoundsMask(child._bounds, child._mask._bounds);
            } else if (child.filterArea) {
                this._bounds.addBoundsArea(child._bounds, child.filterArea);
            } else {
                this._bounds.addBounds(child._bounds);
            }
        }

        this._lastBoundsID = this._boundsID;
    };

    /**
     * Recalculates the bounds of the object. Override this to
     * calculate the bounds of the specific object (not including children).
     *
     */


    Container.prototype._calculateBounds = function _calculateBounds() {}
    // FILL IN//


    /**
     * Renders the object using the WebGL renderer
     *
     * @param {PIXI.WebGLRenderer} renderer - The renderer
     */
    ;

    Container.prototype.renderWebGL = function renderWebGL(renderer) {
        // if the object is not visible or the alpha is 0 then no need to render this element
        if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
            return;
        }

        // do a quick check to see if this element has a mask or a filter.
        if (this._mask || this._filters) {
            this.renderAdvancedWebGL(renderer);
        } else {
            this._renderWebGL(renderer);

            // simple render children!
            for (var i = 0, j = this.children.length; i < j; ++i) {
                this.children[i].renderWebGL(renderer);
            }
        }
    };

    /**
     * Render the object using the WebGL renderer and advanced features.
     *
     * @private
     * @param {PIXI.WebGLRenderer} renderer - The renderer
     */


    Container.prototype.renderAdvancedWebGL = function renderAdvancedWebGL(renderer) {
        renderer.flush();

        var filters = this._filters;
        var mask = this._mask;

        // push filter first as we need to ensure the stencil buffer is correct for any masking
        if (filters) {
            if (!this._enabledFilters) {
                this._enabledFilters = [];
            }

            this._enabledFilters.length = 0;

            for (var i = 0; i < filters.length; i++) {
                if (filters[i].enabled) {
                    this._enabledFilters.push(filters[i]);
                }
            }

            if (this._enabledFilters.length) {
                renderer.filterManager.pushFilter(this, this._enabledFilters);
            }
        }

        if (mask) {
            renderer.maskManager.pushMask(this, this._mask);
        }

        // add this object to the batch, only rendered if it has a texture.
        this._renderWebGL(renderer);

        // now loop through the children and make sure they get rendered
        for (var _i2 = 0, j = this.children.length; _i2 < j; _i2++) {
            this.children[_i2].renderWebGL(renderer);
        }

        renderer.flush();

        if (mask) {
            renderer.maskManager.popMask(this, this._mask);
        }

        if (filters && this._enabledFilters && this._enabledFilters.length) {
            renderer.filterManager.popFilter();
        }
    };

    /**
     * To be overridden by the subclasses.
     *
     * @private
     * @param {PIXI.WebGLRenderer} renderer - The renderer
     */


    Container.prototype._renderWebGL = function _renderWebGL(renderer) // eslint-disable-line no-unused-vars
    {}
    // this is where content itself gets rendered...


    /**
     * To be overridden by the subclass
     *
     * @private
     * @param {PIXI.CanvasRenderer} renderer - The renderer
     */
    ;

    Container.prototype._renderCanvas = function _renderCanvas(renderer) // eslint-disable-line no-unused-vars
    {}
    // this is where content itself gets rendered...


    /**
     * Renders the object using the Canvas renderer
     *
     * @param {PIXI.CanvasRenderer} renderer - The renderer
     */
    ;

    Container.prototype.renderCanvas = function renderCanvas(renderer) {
        // if not visible or the alpha is 0 then no need to render this
        if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
            return;
        }

        if (this._mask) {
            renderer.maskManager.pushMask(this._mask);
        }

        this._renderCanvas(renderer);
        for (var i = 0, j = this.children.length; i < j; ++i) {
            this.children[i].renderCanvas(renderer);
        }

        if (this._mask) {
            renderer.maskManager.popMask(renderer);
        }
    };

    /**
     * Removes all internal references and listeners as well as removes children from the display list.
     * Do not use a Container after calling `destroy`.
     *
     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options
     *  have been set to that value
     * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy
     *  method called as well. 'options' will be passed on to those calls.
     * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true
     *  Should it destroy the texture of the child sprite
     * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true
     *  Should it destroy the base texture of the child sprite
     */


    Container.prototype.destroy = function destroy(options) {
        _DisplayObject.prototype.destroy.call(this);

        var destroyChildren = typeof options === 'boolean' ? options : options && options.children;

        var oldChildren = this.removeChildren(0, this.children.length);

        if (destroyChildren) {
            for (var i = 0; i < oldChildren.length; ++i) {
                oldChildren[i].destroy(options);
            }
        }
    };

    /**
     * The width of the Container, setting this will actually modify the scale to achieve the value set
     *
     * @member {number}
     */


    _createClass(Container, [{
        key: 'width',
        get: function get() {
            return this.scale.x * this.getLocalBounds().width;
        },
        set: function set(value) // eslint-disable-line require-jsdoc
        {
            var width = this.getLocalBounds().width;

            if (width !== 0) {
                this.scale.x = value / width;
            } else {
                this.scale.x = 1;
            }

            this._width = value;
        }

        /**
         * The height of the Container, setting this will actually modify the scale to achieve the value set
         *
         * @member {number}
         */

    }, {
        key: 'height',
        get: function get() {
            return this.scale.y * this.getLocalBounds().height;
        },
        set: function set(value) // eslint-disable-line require-jsdoc
        {
            var height = this.getLocalBounds().height;

            if (height !== 0) {
                this.scale.y = value / height;
            } else {
                this.scale.y = 1;
            }

            this._height = value;
        }
    }]);

    return Container;
}(_DisplayObject3.default);

// performance increase to avoid using call.. (10x faster)


exports.default = Container;
Container.prototype.containerUpdateTransform = Container.prototype.updateTransform;

},{"../utils":132,"./DisplayObject":56}],56:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _eventemitter = require('eventemitter3');

var _eventemitter2 = _interopRequireDefault(_eventemitter);

var _const = require('../const');

var _settings = require('../settings');

var _settings2 = _interopRequireDefault(_settings);

var _TransformStatic = require('./TransformStatic');

var _TransformStatic2 = _interopRequireDefault(_TransformStatic);

var _Transform = require('./Transform');

var _Transform2 = _interopRequireDefault(_Transform);

var _Bounds = require('./Bounds');

var _Bounds2 = _interopRequireDefault(_Bounds);

var _math = require('../math');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// _tempDisplayObjectParent = new DisplayObject();

/**
 * The base class for all objects that are rendered on the screen.
 * This is an abstract class and should not be used on its own rather it should be extended.
 *
 * @class
 * @extends EventEmitter
 * @memberof PIXI
 */
var DisplayObject = function (_EventEmitter) {
    _inherits(DisplayObject, _EventEmitter);

    /**
     *
     */
    function DisplayObject() {
        _classCallCheck(this, DisplayObject);

        var _this = _possibleConstructorReturn(this, _EventEmitter.call(this));

        var TransformClass = _settings2.default.TRANSFORM_MODE === _const.TRANSFORM_MODE.STATIC ? _TransformStatic2.default : _Transform2.default;

        _this.tempDisplayObjectParent = null;

        // TODO: need to create Transform from factory
        /**
         * World transform and local transform of this object.
         * This will become read-only later, please do not assign anything there unless you know what are you doing
         *
         * @member {PIXI.TransformBase}
         */
        _this.transform = new TransformClass();

        /**
         * The opacity of the object.
         *
         * @member {number}
         */
        _this.alpha = 1;

        /**
         * The visibility of the object. If false the object will not be drawn, and
         * the updateTransform function will not be called.
         *
         * Only affects recursive calls from parent. You can ask for bounds or call updateTransform manually
         *
         * @member {boolean}
         */
        _this.visible = true;

        /**
         * Can this object be rendered, if false the object will not be drawn but the updateTransform
         * methods will still be called.
         *
         * Only affects recursive calls from parent. You can ask for bounds manually
         *
         * @member {boolean}
         */
        _this.renderable = true;

        /**
         * The display object container that contains this display object.
         *
         * @member {PIXI.Container}
         * @readonly
         */
        _this.parent = null;

        /**
         * The multiplied alpha of the displayObject
         *
         * @member {number}
         * @readonly
         */
        _this.worldAlpha = 1;

        /**
         * The area the filter is applied to. This is used as more of an optimisation
         * rather than figuring out the dimensions of the displayObject each frame you can set this rectangle
         *
         * Also works as an interaction mask
         *
         * @member {PIXI.Rectangle}
         */
        _this.filterArea = null;

        _this._filters = null;
        _this._enabledFilters = null;

        /**
         * The bounds object, this is used to calculate and store the bounds of the displayObject
         *
         * @member {PIXI.Rectangle}
         * @private
         */
        _this._bounds = new _Bounds2.default();
        _this._boundsID = 0;
        _this._lastBoundsID = -1;
        _this._boundsRect = null;
        _this._localBoundsRect = null;

        /**
         * The original, cached mask of the object
         *
         * @member {PIXI.Graphics|PIXI.Sprite}
         * @private
         */
        _this._mask = null;

        /**
         * If the object has been destroyed via destroy(). If true, it should not be used.
         *
         * @member {boolean}
         * @private
         * @readonly
         */
        _this._destroyed = false;

        /**
         * Fired when this DisplayObject is added to a Container.
         *
         * @event PIXI.DisplayObject#added
         * @param {PIXI.Container} container - The container added to.
         */

        /**
         * Fired when this DisplayObject is removed from a Container.
         *
         * @event PIXI.DisplayObject#removed
         * @param {PIXI.Container} container - The container removed from.
         */
        return _this;
    }

    /**
     * @private
     * @member {PIXI.DisplayObject}
     */


    /**
     * Updates the object transform for rendering
     *
     * TODO - Optimization pass!
     */
    DisplayObject.prototype.updateTransform = function updateTransform() {
        this.transform.updateTransform(this.parent.transform);
        // multiply the alphas..
        this.worldAlpha = this.alpha * this.parent.worldAlpha;

        this._bounds.updateID++;
    };

    /**
     * recursively updates transform of all objects from the root to this one
     * internal function for toLocal()
     */


    DisplayObject.prototype._recursivePostUpdateTransform = function _recursivePostUpdateTransform() {
        if (this.parent) {
            this.parent._recursivePostUpdateTransform();
            this.transform.updateTransform(this.parent.transform);
        } else {
            this.transform.updateTransform(this._tempDisplayObjectParent.transform);
        }
    };

    /**
     * Retrieves the bounds of the displayObject as a rectangle object.
     *
     * @param {boolean} skipUpdate - setting to true will stop the transforms of the scene graph from
     *  being updated. This means the calculation returned MAY be out of date BUT will give you a
     *  nice performance boost
     * @param {PIXI.Rectangle} rect - Optional rectangle to store the result of the bounds calculation
     * @return {PIXI.Rectangle} the rectangular bounding area
     */


    DisplayObject.prototype.getBounds = function getBounds(skipUpdate, rect) {
        if (!skipUpdate) {
            if (!this.parent) {
                this.parent = this._tempDisplayObjectParent;
                this.updateTransform();
                this.parent = null;
            } else {
                this._recursivePostUpdateTransform();
                this.updateTransform();
            }
        }

        if (this._boundsID !== this._lastBoundsID) {
            this.calculateBounds();
        }

        if (!rect) {
            if (!this._boundsRect) {
                this._boundsRect = new _math.Rectangle();
            }

            rect = this._boundsRect;
        }

        return this._bounds.getRectangle(rect);
    };

    /**
     * Retrieves the local bounds of the displayObject as a rectangle object
     *
     * @param {PIXI.Rectangle} [rect] - Optional rectangle to store the result of the bounds calculation
     * @return {PIXI.Rectangle} the rectangular bounding area
     */


    DisplayObject.prototype.getLocalBounds = function getLocalBounds(rect) {
        var transformRef = this.transform;
        var parentRef = this.parent;

        this.parent = null;
        this.transform = this._tempDisplayObjectParent.transform;

        if (!rect) {
            if (!this._localBoundsRect) {
                this._localBoundsRect = new _math.Rectangle();
            }

            rect = this._localBoundsRect;
        }

        var bounds = this.getBounds(false, rect);

        this.parent = parentRef;
        this.transform = transformRef;

        return bounds;
    };

    /**
     * Calculates the global position of the display object
     *
     * @param {PIXI.Point} position - The world origin to calculate from
     * @param {PIXI.Point} [point] - A Point object in which to store the value, optional
     *  (otherwise will create a new Point)
     * @param {boolean} [skipUpdate=false] - Should we skip the update transform.
     * @return {PIXI.Point} A point object representing the position of this object
     */


    DisplayObject.prototype.toGlobal = function toGlobal(position, point) {
        var skipUpdate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

        if (!skipUpdate) {
            this._recursivePostUpdateTransform();

            // this parent check is for just in case the item is a root object.
            // If it is we need to give it a temporary parent so that displayObjectUpdateTransform works correctly
            // this is mainly to avoid a parent check in the main loop. Every little helps for performance :)
            if (!this.parent) {
                this.parent = this._tempDisplayObjectParent;
                this.displayObjectUpdateTransform();
                this.parent = null;
            } else {
                this.displayObjectUpdateTransform();
            }
        }

        // don't need to update the lot
        return this.worldTransform.apply(position, point);
    };

    /**
     * Calculates the local position of the display object relative to another point
     *
     * @param {PIXI.Point} position - The world origin to calculate from
     * @param {PIXI.DisplayObject} [from] - The DisplayObject to calculate the global position from
     * @param {PIXI.Point} [point] - A Point object in which to store the value, optional
     *  (otherwise will create a new Point)
     * @param {boolean} [skipUpdate=false] - Should we skip the update transform
     * @return {PIXI.Point} A point object representing the position of this object
     */


    DisplayObject.prototype.toLocal = function toLocal(position, from, point, skipUpdate) {
        if (from) {
            position = from.toGlobal(position, point, skipUpdate);
        }

        if (!skipUpdate) {
            this._recursivePostUpdateTransform();

            // this parent check is for just in case the item is a root object.
            // If it is we need to give it a temporary parent so that displayObjectUpdateTransform works correctly
            // this is mainly to avoid a parent check in the main loop. Every little helps for performance :)
            if (!this.parent) {
                this.parent = this._tempDisplayObjectParent;
                this.displayObjectUpdateTransform();
                this.parent = null;
            } else {
                this.displayObjectUpdateTransform();
            }
        }

        // simply apply the matrix..
        return this.worldTransform.applyInverse(position, point);
    };

    /**
     * Renders the object using the WebGL renderer
     *
     * @param {PIXI.WebGLRenderer} renderer - The renderer
     */


    DisplayObject.prototype.renderWebGL = function renderWebGL(renderer) // eslint-disable-line no-unused-vars
    {}
    // OVERWRITE;


    /**
     * Renders the object using the Canvas renderer
     *
     * @param {PIXI.CanvasRenderer} renderer - The renderer
     */
    ;

    DisplayObject.prototype.renderCanvas = function renderCanvas(renderer) // eslint-disable-line no-unused-vars
    {}
    // OVERWRITE;


    /**
     * Set the parent Container of this DisplayObject
     *
     * @param {PIXI.Container} container - The Container to add this DisplayObject to
     * @return {PIXI.Container} The Container that this DisplayObject was added to
     */
    ;

    DisplayObject.prototype.setParent = function setParent(container) {
        if (!container || !container.addChild) {
            throw new Error('setParent: Argument must be a Container');
        }

        container.addChild(this);

        return container;
    };

    /**
     * Convenience function to set the position, scale, skew and pivot at once.
     *
     * @param {number} [x=0] - The X position
     * @param {number} [y=0] - The Y position
     * @param {number} [scaleX=1] - The X scale value
     * @param {number} [scaleY=1] - The Y scale value
     * @param {number} [rotation=0] - The rotation
     * @param {number} [skewX=0] - The X skew value
     * @param {number} [skewY=0] - The Y skew value
     * @param {number} [pivotX=0] - The X pivot value
     * @param {number} [pivotY=0] - The Y pivot value
     * @return {PIXI.DisplayObject} The DisplayObject instance
     */


    DisplayObject.prototype.setTransform = function setTransform() {
        var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var scaleX = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
        var scaleY = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
        var rotation = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
        var skewX = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
        var skewY = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;
        var pivotX = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;
        var pivotY = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 0;

        this.position.x = x;
        this.position.y = y;
        this.scale.x = !scaleX ? 1 : scaleX;
        this.scale.y = !scaleY ? 1 : scaleY;
        this.rotation = rotation;
        this.skew.x = skewX;
        this.skew.y = skewY;
        this.pivot.x = pivotX;
        this.pivot.y = pivotY;

        return this;
    };

    /**
     * Base destroy method for generic display objects. This will automatically
     * remove the display object from its parent Container as well as remove
     * all current event listeners and internal references. Do not use a DisplayObject
     * after calling `destroy`.
     *
     */


    DisplayObject.prototype.destroy = function destroy() {
        this.removeAllListeners();
        if (this.parent) {
            this.parent.removeChild(this);
        }
        this.transform = null;

        this.parent = null;

        this._bounds = null;
        this._currentBounds = null;
        this._mask = null;

        this.filterArea = null;

        this.interactive = false;
        this.interactiveChildren = false;

        this._destroyed = true;
    };

    /**
     * The position of the displayObject on the x axis relative to the local coordinates of the parent.
     * An alias to position.x
     *
     * @member {number}
     */


    _createClass(DisplayObject, [{
        key: '_tempDisplayObjectParent',
        get: function get() {
            if (this.tempDisplayObjectParent === null) {
                this.tempDisplayObjectParent = new DisplayObject();
            }

            return this.tempDisplayObjectParent;
        }
    }, {
        key: 'x',
        get: function get() {
            return this.position.x;
        },
        set: function set(value) // eslint-disable-line require-jsdoc
        {
            this.transform.position.x = value;
        }

        /**
         * The position of the displayObject on the y axis relative to the local coordinates of the parent.
         * An alias to position.y
         *
         * @member {number}
         */

    }, {
        key: 'y',
        get: function get() {
            return this.position.y;
        },
        set: function set(value) // eslint-disable-line require-jsdoc
        {
            this.transform.position.y = value;
        }

        /**
         * Current transform of the object based on world (parent) factors
         *
         * @member {PIXI.Matrix}
         * @readonly
         */

    }, {
        key: 'worldTransform',
        get: function get() {
            return this.transform.worldTransform;
        }

        /**
         * Current transform of the object based on local factors: position, scale, other stuff
         *
         * @member {PIXI.Matrix}
         * @readonly
         */

    }, {
        key: 'localTransform',
        get: function get() {
            return this.transform.localTransform;
        }

        /**
         * The coordinate of the object relative to the local coordinates of the parent.
         * Assignment by value since pixi-v4.
         *
         * @member {PIXI.Point|PIXI.ObservablePoint}
         */

    }, {
        key: 'position',
        get: function get() {
            return this.transform.position;
        },
        set: function set(value) // eslint-disable-line require-jsdoc
        {
            this.transform.position.copy(value);
        }

        /**
         * The scale factor of the object.
         * Assignment by value since pixi-v4.
         *
         * @member {PIXI.Point|PIXI.ObservablePoint}
         */

    }, {
        key: 'scale',
        get: function get() {
            return this.transform.scale;
        },
        set: function set(value) // eslint-disable-line require-jsdoc
        {
            this.transform.scale.copy(value);
        }

        /**
         * The pivot point of the displayObject that it rotates around.
         * Assignment by value since pixi-v4.
         *
         * @member {PIXI.Point|PIXI.ObservablePoint}
         */

    }, {
        key: 'pivot',
        get: function get() {
            return this.transform.pivot;
        },
        set: function set(value) // eslint-disable-line require-jsdoc
        {
            this.transform.pivot.copy(value);
        }

        /**
         * The skew factor for the object in radians.
         * Assignment by value since pixi-v4.
         *
         * @member {PIXI.ObservablePoint}
         */

    }, {
        key: 'skew',
        get: function get() {
            return this.transform.skew;
        },
        set: function set(value) // eslint-disable-line require-jsdoc
        {
            this.transform.skew.copy(value);
        }

        /**
         * The rotation of the object in radians.
         *
         * @member {number}
         */

    }, {
        key: 'rotation',
        get: function get() {
            return this.transform.rotation;
        },
        set: function set(value) // eslint-disable-line require-jsdoc
        {
            this.transform.rotation = value;
        }

        /**
         * Indicates if the object is globally visible.
         *
         * @member {boolean}
         * @readonly
         */

    }, {
        key: 'worldVisible',
        get: function get() {
            var item = this;

            do {
                if (!item.visible) {
                    return false;
                }

                item = item.parent;
            } while (item);

            return true;
        }

        /**
         * Sets a mask for the displayObject. A mask is an object that limits the visibility of an
         * object to the shape of the mask applied to it. In PIXI a regular mask must be a
         * PIXI.Graphics or a PIXI.Sprite object. This allows for much faster masking in canvas as it
         * utilises shape clipping. To remove a mask, set this property to null.
         *
         * @todo For the moment, PIXI.CanvasRenderer doesn't support PIXI.Sprite as mask.
         *
         * @member {PIXI.Graphics|PIXI.Sprite}
         */

    }, {
        key: 'mask',
        get: function get() {
            return this._mask;
        },
        set: function set(value) // eslint-disable-line require-jsdoc
        {
            if (this._mask) {
                this._mask.renderable = true;
                this._mask.isMask = false;
            }

            this._mask = value;

            if (this._mask) {
                this._mask.renderable = false;
                this._mask.isMask = true;
            }
        }

        /**
         * Sets the filters for the displayObject.
         * * IMPORTANT: This is a webGL only feature and will be ignored by the canvas renderer.
         * To remove filters simply set this property to 'null'
         *
         * @member {PIXI.Filter[]}
         */

    }, {
        key: 'filters',
        get: function get() {
            return this._filters && this._filters.slice();
        },
        set: function set(value) // eslint-disable-line require-jsdoc
        {
            this._filters = value && value.slice();
        }
    }]);

    return DisplayObject;
}(_eventemitter2.default);

// performance increase to avoid using call.. (10x faster)


exports.default = DisplayObject;
DisplayObject.prototype.displayObjectUpdateTransform = DisplayObject.prototype.updateTransform;

},{"../const":53,"../math":77,"../settings":108,"./Bounds":54,"./Transform":57,"./TransformStatic":59,"eventemitter3":24}],57:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = require('../math');

var _TransformBase2 = require('./TransformBase');

var _TransformBase3 = _interopRequireDefault(_TransformBase2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Generic class to deal with traditional 2D matrix transforms
 * local transformation is calculated from position,scale,skew and rotation
 *
 * @class
 * @extends PIXI.TransformBase
 * @memberof PIXI
 */
var Transform = function (_TransformBase) {
  _inherits(Transform, _TransformBase);

  /**
   *
   */
  function Transform() {
    _classCallCheck(this, Transform);

    /**
    * The coordinate of the object relative to the local coordinates of the parent.
    *
    * @member {PIXI.Point}
    */
    var _this = _possibleConstructorReturn(this, _TransformBase.call(this));

    _this.position = new _math.Point(0, 0);

    /**
     * The scale factor of the object.
     *
     * @member {PIXI.Point}
     */
    _this.scale = new _math.Point(1, 1);

    /**
     * The skew amount, on the x and y axis.
     *
     * @member {PIXI.ObservablePoint}
     */
    _this.skew = new _math.ObservablePoint(_this.updateSkew, _this, 0, 0);

    /**
     * The pivot point of the displayObject that it rotates around.
     *
     * @member {PIXI.Point}
     */
    _this.pivot = new _math.Point(0, 0);

    /**
     * The rotation value of the object, in radians
     *
     * @member {Number}
     * @private
     */
    _this._rotation = 0;

    _this._cx = 1; // cos rotation + skewY;
    _this._sx = 0; // sin rotation + skewY;
    _this._cy = 0; // cos rotation + Math.PI/2 - skewX;
    _this._sy = 1; // sin rotation + Math.PI/2 - skewX;
    return _this;
  }

  /**
   * Updates the skew values when the skew or rotation changes.
   *
   * @private
   */


  Transform.prototype.updateSkew = function updateSkew() {
    this._cx = Math.cos(this._rotation + this.skew._y);
    this._sx = Math.sin(this._rotation + this.skew._y);
    this._cy = -Math.sin(this._rotation - this.skew._x); // cos, added PI/2
    this._sy = Math.cos(this._rotation - this.skew._x); // sin, added PI/2
  };

  /**
   * Updates only local matrix
   */


  Transform.prototype.updateLocalTransform = function updateLocalTransform() {
    var lt = this.localTransform;

    lt.a = this._cx * this.scale.x;
    lt.b = this._sx * this.scale.x;
    lt.c = this._cy * this.scale.y;
    lt.d = this._sy * this.scale.y;

    lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c);
    lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d);
  };

  /**
   * Updates the values of the object and applies the parent's transform.
   *
   * @param {PIXI.Transform} parentTransform - The transform of the parent of this object
   */


  Transform.prototype.updateTransform = function updateTransform(parentTransform) {
    var lt = this.localTransform;

    lt.a = this._cx * this.scale.x;
    lt.b = this._sx * this.scale.x;
    lt.c = this._cy * this.scale.y;
    lt.d = this._sy * this.scale.y;

    lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c);
    lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d);

    // concat the parent matrix with the objects transform.
    var pt = parentTransform.worldTransform;
    var wt = this.worldTransform;

    wt.a = lt.a * pt.a + lt.b * pt.c;
    wt.b = lt.a * pt.b + lt.b * pt.d;
    wt.c = lt.c * pt.a + lt.d * pt.c;
    wt.d = lt.c * pt.b + lt.d * pt.d;
    wt.tx = lt.tx * pt.a + lt.ty * pt.c + pt.tx;
    wt.ty = lt.tx * pt.b + lt.ty * pt.d + pt.ty;

    this._worldID++;
  };

  /**
   * Decomposes a matrix and sets the transforms properties based on it.
   *
   * @param {PIXI.Matrix} matrix - The matrix to decompose
   */


  Transform.prototype.setFromMatrix = function setFromMatrix(matrix) {
    matrix.decompose(this);
  };

  /**
   * The rotation of the object in radians.
   *
   * @member {number}
   */


  _createClass(Transform, [{
    key: 'rotation',
    get: function get() {
      return this._rotation;
    },
    set: function set(value) // eslint-disable-line require-jsdoc
    {
      this._rotation = value;
      this.updateSkew();
    }
  }]);

  return Transform;
}(_TransformBase3.default);

exports.default = Transform;

},{"../math":77,"./TransformBase":58}],58:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _math = require('../math');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Generic class to deal with traditional 2D matrix transforms
 *
 * @class
 * @memberof PIXI
 */
var TransformBase = function () {
  /**
   *
   */
  function TransformBase() {
    _classCallCheck(this, TransformBase);

    /**
     * The global matrix transform. It can be swapped temporarily by some functions like getLocalBounds()
     *
     * @member {PIXI.Matrix}
     */
    this.worldTransform = new _math.Matrix();

    /**
     * The local matrix transform
     *
     * @member {PIXI.Matrix}
     */
    this.localTransform = new _math.Matrix();

    this._worldID = 0;
    this._parentID = 0;
  }

  /**
   * TransformBase does not have decomposition, so this function wont do anything
   */


  TransformBase.prototype.updateLocalTransform = function updateLocalTransform() {}
  // empty


  /**
   * Updates the values of the object and applies the parent's transform.
   *
   * @param {PIXI.TransformBase} parentTransform - The transform of the parent of this object
   */
  ;

  TransformBase.prototype.updateTransform = function updateTransform(parentTransform) {
    var pt = parentTransform.worldTransform;
    var wt = this.worldTransform;
    var lt = this.localTransform;

    // concat the parent matrix with the objects transform.
    wt.a = lt.a * pt.a + lt.b * pt.c;
    wt.b = lt.a * pt.b + lt.b * pt.d;
    wt.c = lt.c * pt.a + lt.d * pt.c;
    wt.d = lt.c * pt.b + lt.d * pt.d;
    wt.tx = lt.tx * pt.a + lt.ty * pt.c + pt.tx;
    wt.ty = lt.tx * pt.b + lt.ty * pt.d + pt.ty;

    this._worldID++;
  };

  return TransformBase;
}();

/**
 * Updates the values of the object and applies the parent's transform.
 * @param  parentTransform {PIXI.Transform} The transform of the parent of this object
 *
 */


exports.default = TransformBase;
TransformBase.prototype.updateWorldTransform = TransformBase.prototype.updateTransform;

TransformBase.IDENTITY = new TransformBase();

},{"../math":77}],59:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = require('../math');

var _TransformBase2 = require('./TransformBase');

var _TransformBase3 = _interopRequireDefault(_TransformBase2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Transform that takes care about its versions
 *
 * @class
 * @extends PIXI.TransformBase
 * @memberof PIXI
 */
var TransformStatic = function (_TransformBase) {
    _inherits(TransformStatic, _TransformBase);

    /**
     *
     */
    function TransformStatic() {
        _classCallCheck(this, TransformStatic);

        /**
        * The coordinate of the object relative to the local coordinates of the parent.
        *
        * @member {PIXI.ObservablePoint}
        */
        var _this = _possibleConstructorReturn(this, _TransformBase.call(this));

        _this.position = new _math.ObservablePoint(_this.onChange, _this, 0, 0);

        /**
         * The scale factor of the object.
         *
         * @member {PIXI.ObservablePoint}
         */
        _this.scale = new _math.ObservablePoint(_this.onChange, _this, 1, 1);

        /**
         * The pivot point of the displayObject that it rotates around.
         *
         * @member {PIXI.ObservablePoint}
         */
        _this.pivot = new _math.ObservablePoint(_this.onChange, _this, 0, 0);

        /**
         * The skew amount, on the x and y axis.
         *
         * @member {PIXI.ObservablePoint}
         */
        _this.skew = new _math.ObservablePoint(_this.updateSkew, _this, 0, 0);

        _this._rotation = 0;

        _this._cx = 1; // cos rotation + skewY;
        _this._sx = 0; // sin rotation + skewY;
        _this._cy = 0; // cos rotation + Math.PI/2 - skewX;
        _this._sy = 1; // sin rotation + Math.PI/2 - skewX;

        _this._localID = 0;
        _this._currentLocalID = 0;
        return _this;
    }

    /**
     * Called when a value changes.
     *
     * @private
     */


    TransformStatic.prototype.onChange = function onChange() {
        this._localID++;
    };

    /**
     * Called when skew or rotation changes
     *
     * @private
     */


    TransformStatic.prototype.updateSkew = function updateSkew() {
        this._cx = Math.cos(this._rotation + this.skew._y);
        this._sx = Math.sin(this._rotation + this.skew._y);
        this._cy = -Math.sin(this._rotation - this.skew._x); // cos, added PI/2
        this._sy = Math.cos(this._rotation - this.skew._x); // sin, added PI/2

        this._localID++;
    };

    /**
     * Updates only local matrix
     */


    TransformStatic.prototype.updateLocalTransform = function updateLocalTransform() {
        var lt = this.localTransform;

        if (this._localID !== this._currentLocalID) {
            // get the matrix values of the displayobject based on its transform properties..
            lt.a = this._cx * this.scale._x;
            lt.b = this._sx * this.scale._x;
            lt.c = this._cy * this.scale._y;
            lt.d = this._sy * this.scale._y;

            lt.tx = this.position._x - (this.pivot._x * lt.a + this.pivot._y * lt.c);
            lt.ty = this.position._y - (this.pivot._x * lt.b + this.pivot._y * lt.d);
            this._currentLocalID = this._localID;

            // force an update..
            this._parentID = -1;
        }
    };

    /**
     * Updates the values of the object and applies the parent's transform.
     *
     * @param {PIXI.Transform} parentTransform - The transform of the parent of this object
     */


    TransformStatic.prototype.updateTransform = function updateTransform(parentTransform) {
        var lt = this.localTransform;

        if (this._localID !== this._currentLocalID) {
            // get the matrix values of the displayobject based on its transform properties..
            lt.a = this._cx * this.scale._x;
            lt.b = this._sx * this.scale._x;
            lt.c = this._cy * this.scale._y;
            lt.d = this._sy * this.scale._y;

            lt.tx = this.position._x - (this.pivot._x * lt.a + this.pivot._y * lt.c);
            lt.ty = this.position._y - (this.pivot._x * lt.b + this.pivot._y * lt.d);
            this._currentLocalID = this._localID;

            // force an update..
            this._parentID = -1;
        }

        if (this._parentID !== parentTransform._worldID) {
            // concat the parent matrix with the objects transform.
            var pt = parentTransform.worldTransform;
            var wt = this.worldTransform;

            wt.a = lt.a * pt.a + lt.b * pt.c;
            wt.b = lt.a * pt.b + lt.b * pt.d;
            wt.c = lt.c * pt.a + lt.d * pt.c;
            wt.d = lt.c * pt.b + lt.d * pt.d;
            wt.tx = lt.tx * pt.a + lt.ty * pt.c + pt.tx;
            wt.ty = lt.tx * pt.b + lt.ty * pt.d + pt.ty;

            this._parentID = parentTransform._worldID;

            // update the id of the transform..
            this._worldID++;
        }
    };

    /**
     * Decomposes a matrix and sets the transforms properties based on it.
     *
     * @param {PIXI.Matrix} matrix - The matrix to decompose
     */


    TransformStatic.prototype.setFromMatrix = function setFromMatrix(matrix) {
        matrix.decompose(this);
        this._localID++;
    };

    /**
     * The rotation of the object in radians.
     *
     * @member {number}
     */


    _createClass(TransformStatic, [{
        key: 'rotation',
        get: function get() {
            return this._rotation;
        },
        set: function set(value) // eslint-disable-line require-jsdoc
        {
            if (this._rotation !== value) {
                this._rotation = value;
                this.updateSkew();
            }
        }
    }]);

    return TransformStatic;
}(_TransformBase3.default);

exports.default = TransformStatic;

},{"../math":77,"./TransformBase":58}],60:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _Container2 = require('../display/Container');

var _Container3 = _interopRequireDefault(_Container2);

var _RenderTexture = require('../textures/RenderTexture');

var _RenderTexture2 = _interopRequireDefault(_RenderTexture);

var _Texture = require('../textures/Texture');

var _Texture2 = _interopRequireDefault(_Texture);

var _GraphicsData = require('./GraphicsData');

var _GraphicsData2 = _interopRequireDefault(_GraphicsData);

var _Sprite = require('../sprites/Sprite');

var _Sprite2 = _interopRequireDefault(_Sprite);

var _math = require('../math');

var _utils = require('../utils');

var _const = require('../const');

var _Bounds = require('../display/Bounds');

var _Bounds2 = _interopRequireDefault(_Bounds);

var _bezierCurveTo2 = require('./utils/bezierCurveTo');

var _bezierCurveTo3 = _interopRequireDefault(_bezierCurveTo2);

var _CanvasRenderer = require('../renderers/canvas/CanvasRenderer');

var _CanvasRenderer2 = _interopRequireDefault(_CanvasRenderer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var canvasRenderer = void 0;
var tempMatrix = new _math.Matrix();
var tempPoint = new _math.Point();
var tempColor1 = new Float32Array(4);
var tempColor2 = new Float32Array(4);

/**
 * The Graphics class contains methods used to draw primitive shapes such as lines, circles and
 * rectangles to the display, and to color and fill them.
 *
 * @class
 * @extends PIXI.Container
 * @memberof PIXI
 */

var Graphics = function (_Container) {
    _inherits(Graphics, _Container);

    /**
     *
     * @param {boolean} [nativeLines=false] - If true the lines will be draw using LINES instead of TRIANGLE_STRIP
     */
    function Graphics() {
        var nativeLines = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

        _classCallCheck(this, Graphics);

        /**
         * The alpha value used when filling the Graphics object.
         *
         * @member {number}
         * @default 1
         */
        var _this = _possibleConstructorReturn(this, _Container.call(this));

        _this.fillAlpha = 1;

        /**
         * The width (thickness) of any lines drawn.
         *
         * @member {number}
         * @default 0
         */
        _this.lineWidth = 0;

        /**
         * If true the lines will be draw using LINES instead of TRIANGLE_STRIP
         *
         * @member {boolean}
         */
        _this.nativeLines = nativeLines;

        /**
         * The color of any lines drawn.
         *
         * @member {string}
         * @default 0
         */
        _this.lineColor = 0;

        /**
         * The alignment of any lines drawn (0.5 = middle, 1 = outter, 0 = inner).
         *
         * @member {number}
         * @default 0.5
         */
        _this.lineAlignment = 0.5;

        /**
         * Graphics data
         *
         * @member {PIXI.GraphicsData[]}
         * @private
         */
        _this.graphicsData = [];

        /**
         * The tint applied to the graphic shape. This is a hex value. Apply a value of 0xFFFFFF to
         * reset the tint.
         *
         * @member {number}
         * @default 0xFFFFFF
         */
        _this.tint = 0xFFFFFF;

        /**
         * The previous tint applied to the graphic shape. Used to compare to the current tint and
         * check if theres change.
         *
         * @member {number}
         * @private
         * @default 0xFFFFFF
         */
        _this._prevTint = 0xFFFFFF;

        /**
         * The blend mode to be applied to the graphic shape. Apply a value of
         * `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.
         *
         * @member {number}
         * @default PIXI.BLEND_MODES.NORMAL;
         * @see PIXI.BLEND_MODES
         */
        _this.blendMode = _const.BLEND_MODES.NORMAL;

        /**
         * Current path
         *
         * @member {PIXI.GraphicsData}
         * @private
         */
        _this.currentPath = null;

        /**
         * Array containing some WebGL-related properties used by the WebGL renderer.
         *
         * @member {object<number, object>}
         * @private
         */
        // TODO - _webgl should use a prototype object, not a random undocumented object...
        _this._webGL = {};

        /**
         * Whether this shape is being used as a mask.
         *
         * @member {boolean}
         */
        _this.isMask = false;

        /**
         * The bounds' padding used for bounds calculation.
         *
         * @member {number}
         */
        _this.boundsPadding = 0;

        /**
         * A cache of the local bounds to prevent recalculation.
         *
         * @member {PIXI.Rectangle}
         * @private
         */
        _this._localBounds = new _Bounds2.default();

        /**
         * Used to detect if the graphics object has changed. If this is set to true then the graphics
         * object will be recalculated.
         *
         * @member {boolean}
         * @private
         */
        _this.dirty = 0;

        /**
         * Used to detect if we need to do a fast rect check using the id compare method
         * @type {Number}
         */
        _this.fastRectDirty = -1;

        /**
         * Used to detect if we clear the graphics webGL data
         * @type {Number}
         */
        _this.clearDirty = 0;

        /**
         * Used to detect if we we need to recalculate local bounds
         * @type {Number}
         */
        _this.boundsDirty = -1;

        /**
         * Used to detect if the cached sprite object needs to be updated.
         *
         * @member {boolean}
         * @private
         */
        _this.cachedSpriteDirty = false;

        _this._spriteRect = null;
        _this._fastRect = false;

        _this._prevRectTint = null;
        _this._prevRectFillColor = null;

        /**
         * When cacheAsBitmap is set to true the graphics object will be rendered as if it was a sprite.
         * This is useful if your graphics element does not change often, as it will speed up the rendering
         * of the object in exchange for taking up texture memory. It is also useful if you need the graphics
         * object to be anti-aliased, because it will be rendered using canvas. This is not recommended if
         * you are constantly redrawing the graphics element.
         *
         * @name cacheAsBitmap
         * @member {boolean}
         * @memberof PIXI.Graphics#
         * @default false
         */
        return _this;
    }

    /**
     * Creates a new Graphics object with the same values as this one.
     * Note that the only the properties of the object are cloned, not its transform (position,scale,etc)
     *
     * @return {PIXI.Graphics} A clone of the graphics object
     */


    Graphics.prototype.clone = function clone() {
        var clone = new Graphics();

        clone.renderable = this.renderable;
        clone.fillAlpha = this.fillAlpha;
        clone.lineWidth = this.lineWidth;
        clone.lineColor = this.lineColor;
        clone.lineAlignment = this.lineAlignment;
        clone.tint = this.tint;
        clone.blendMode = this.blendMode;
        clone.isMask = this.isMask;
        clone.boundsPadding = this.boundsPadding;
        clone.dirty = 0;
        clone.cachedSpriteDirty = this.cachedSpriteDirty;

        // copy graphics data
        for (var i = 0; i < this.graphicsData.length; ++i) {
            clone.graphicsData.push(this.graphicsData[i].clone());
        }

        clone.currentPath = clone.graphicsData[clone.graphicsData.length - 1];

        clone.updateLocalBounds();

        return clone;
    };

    /**
     * Calculate length of quadratic curve
     * @see {@link http://www.malczak.linuxpl.com/blog/quadratic-bezier-curve-length/}
     * for the detailed explanation of math behind this.
     *
     * @private
     * @param {number} fromX - x-coordinate of curve start point
     * @param {number} fromY - y-coordinate of curve start point
     * @param {number} cpX - x-coordinate of curve control point
     * @param {number} cpY - y-coordinate of curve control point
     * @param {number} toX - x-coordinate of curve end point
     * @param {number} toY - y-coordinate of curve end point
     * @return {number} Length of quadratic curve
     */


    Graphics.prototype._quadraticCurveLength = function _quadraticCurveLength(fromX, fromY, cpX, cpY, toX, toY) {
        var ax = fromX - 2.0 * cpX + toX;
        var ay = fromY - 2.0 * cpY + toY;
        var bx = 2.0 * cpX - 2.0 * fromX;
        var by = 2.0 * cpY - 2.0 * fromY;
        var a = 4.0 * (ax * ax + ay * ay);
        var b = 4.0 * (ax * bx + ay * by);
        var c = bx * bx + by * by;

        var s = 2.0 * Math.sqrt(a + b + c);
        var a2 = Math.sqrt(a);
        var a32 = 2.0 * a * a2;
        var c2 = 2.0 * Math.sqrt(c);
        var ba = b / a2;

        return (a32 * s + a2 * b * (s - c2) + (4.0 * c * a - b * b) * Math.log((2.0 * a2 + ba + s) / (ba + c2))) / (4.0 * a32);
    };

    /**
     * Calculate length of bezier curve.
     * Analytical solution is impossible, since it involves an integral that does not integrate in general.
     * Therefore numerical solution is used.
     *
     * @private
     * @param {number} fromX - Starting point x
     * @param {number} fromY - Starting point y
     * @param {number} cpX - Control point x
     * @param {number} cpY - Control point y
     * @param {number} cpX2 - Second Control point x
     * @param {number} cpY2 - Second Control point y
     * @param {number} toX - Destination point x
     * @param {number} toY - Destination point y
     * @return {number} Length of bezier curve
     */


    Graphics.prototype._bezierCurveLength = function _bezierCurveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY) {
        var n = 10;
        var result = 0.0;
        var t = 0.0;
        var t2 = 0.0;
        var t3 = 0.0;
        var nt = 0.0;
        var nt2 = 0.0;
        var nt3 = 0.0;
        var x = 0.0;
        var y = 0.0;
        var dx = 0.0;
        var dy = 0.0;
        var prevX = fromX;
        var prevY = fromY;

        for (var i = 1; i <= n; ++i) {
            t = i / n;
            t2 = t * t;
            t3 = t2 * t;
            nt = 1.0 - t;
            nt2 = nt * nt;
            nt3 = nt2 * nt;

            x = nt3 * fromX + 3.0 * nt2 * t * cpX + 3.0 * nt * t2 * cpX2 + t3 * toX;
            y = nt3 * fromY + 3.0 * nt2 * t * cpY + 3 * nt * t2 * cpY2 + t3 * toY;
            dx = prevX - x;
            dy = prevY - y;
            prevX = x;
            prevY = y;

            result += Math.sqrt(dx * dx + dy * dy);
        }

        return result;
    };

    /**
     * Calculate number of segments for the curve based on its length to ensure its smoothness.
     *
     * @private
     * @param {number} length - length of curve
     * @return {number} Number of segments
     */


    Graphics.prototype._segmentsCount = function _segmentsCount(length) {
        var result = Math.ceil(length / Graphics.CURVES.maxLength);

        if (result < Graphics.CURVES.minSegments) {
            result = Graphics.CURVES.minSegments;
        } else if (result > Graphics.CURVES.maxSegments) {
            result = Graphics.CURVES.maxSegments;
        }

        return result;
    };

    /**
     * Specifies the line style used for subsequent calls to Graphics methods such as the lineTo()
     * method or the drawCircle() method.
     *
     * @param {number} [lineWidth=0] - width of the line to draw, will update the objects stored style
     * @param {number} [color=0] - color of the line to draw, will update the objects stored style
     * @param {number} [alpha=1] - alpha of the line to draw, will update the objects stored style
     * @param {number} [alignment=0.5] - alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */


    Graphics.prototype.lineStyle = function lineStyle() {
        var lineWidth = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var color = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var alpha = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
        var alignment = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.5;

        this.lineWidth = lineWidth;
        this.lineColor = color;
        this.lineAlpha = alpha;
        this.lineAlignment = alignment;

        if (this.currentPath) {
            if (this.currentPath.shape.points.length) {
                // halfway through a line? start a new one!
                var shape = new _math.Polygon(this.currentPath.shape.points.slice(-2));

                shape.closed = false;

                this.drawShape(shape);
            } else {
                // otherwise its empty so lets just set the line properties
                this.currentPath.lineWidth = this.lineWidth;
                this.currentPath.lineColor = this.lineColor;
                this.currentPath.lineAlpha = this.lineAlpha;
                this.currentPath.lineAlignment = this.lineAlignment;
            }
        }

        return this;
    };

    /**
     * Moves the current drawing position to x, y.
     *
     * @param {number} x - the X coordinate to move to
     * @param {number} y - the Y coordinate to move to
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */


    Graphics.prototype.moveTo = function moveTo(x, y) {
        var shape = new _math.Polygon([x, y]);

        shape.closed = false;
        this.drawShape(shape);

        return this;
    };

    /**
     * Draws a line using the current line style from the current drawing position to (x, y);
     * The current drawing position is then set to (x, y).
     *
     * @param {number} x - the X coordinate to draw to
     * @param {number} y - the Y coordinate to draw to
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */


    Graphics.prototype.lineTo = function lineTo(x, y) {
        var points = this.currentPath.shape.points;

        var fromX = points[points.length - 2];
        var fromY = points[points.length - 1];

        if (fromX !== x || fromY !== y) {
            points.push(x, y);
            this.dirty++;
        }

        return this;
    };

    /**
     * Calculate the points for a quadratic bezier curve and then draws it.
     * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c
     *
     * @param {number} cpX - Control point x
     * @param {number} cpY - Control point y
     * @param {number} toX - Destination point x
     * @param {number} toY - Destination point y
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */


    Graphics.prototype.quadraticCurveTo = function quadraticCurveTo(cpX, cpY, toX, toY) {
        if (this.currentPath) {
            if (this.currentPath.shape.points.length === 0) {
                this.currentPath.shape.points = [0, 0];
            }
        } else {
            this.moveTo(0, 0);
        }

        var points = this.currentPath.shape.points;
        var xa = 0;
        var ya = 0;

        if (points.length === 0) {
            this.moveTo(0, 0);
        }

        var fromX = points[points.length - 2];
        var fromY = points[points.length - 1];
        var n = Graphics.CURVES.adaptive ? this._segmentsCount(this._quadraticCurveLength(fromX, fromY, cpX, cpY, toX, toY)) : 20;

        for (var i = 1; i <= n; ++i) {
            var j = i / n;

            xa = fromX + (cpX - fromX) * j;
            ya = fromY + (cpY - fromY) * j;

            points.push(xa + (cpX + (toX - cpX) * j - xa) * j, ya + (cpY + (toY - cpY) * j - ya) * j);
        }

        this.dirty++;

        return this;
    };

    /**
     * Calculate the points for a bezier curve and then draws it.
     *
     * @param {number} cpX - Control point x
     * @param {number} cpY - Control point y
     * @param {number} cpX2 - Second Control point x
     * @param {number} cpY2 - Second Control point y
     * @param {number} toX - Destination point x
     * @param {number} toY - Destination point y
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */


    Graphics.prototype.bezierCurveTo = function bezierCurveTo(cpX, cpY, cpX2, cpY2, toX, toY) {
        if (this.currentPath) {
            if (this.currentPath.shape.points.length === 0) {
                this.currentPath.shape.points = [0, 0];
            }
        } else {
            this.moveTo(0, 0);
        }

        var points = this.currentPath.shape.points;

        var fromX = points[points.length - 2];
        var fromY = points[points.length - 1];

        points.length -= 2;

        var n = Graphics.CURVES.adaptive ? this._segmentsCount(this._bezierCurveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY)) : 20;

        (0, _bezierCurveTo3.default)(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY, n, points);

        this.dirty++;

        return this;
    };

    /**
     * The arcTo() method creates an arc/curve between two tangents on the canvas.
     *
     * "borrowed" from https://code.google.com/p/fxcanvas/ - thanks google!
     *
     * @param {number} x1 - The x-coordinate of the beginning of the arc
     * @param {number} y1 - The y-coordinate of the beginning of the arc
     * @param {number} x2 - The x-coordinate of the end of the arc
     * @param {number} y2 - The y-coordinate of the end of the arc
     * @param {number} radius - The radius of the arc
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */


    Graphics.prototype.arcTo = function arcTo(x1, y1, x2, y2, radius) {
        if (this.currentPath) {
            if (this.currentPath.shape.points.length === 0) {
                this.currentPath.shape.points.push(x1, y1);
            }
        } else {
            this.moveTo(x1, y1);
        }

        var points = this.currentPath.shape.points;
        var fromX = points[points.length - 2];
        var fromY = points[points.length - 1];
        var a1 = fromY - y1;
        var b1 = fromX - x1;
        var a2 = y2 - y1;
        var b2 = x2 - x1;
        var mm = Math.abs(a1 * b2 - b1 * a2);

        if (mm < 1.0e-8 || radius === 0) {
            if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1) {
                points.push(x1, y1);
            }
        } else {
            var dd = a1 * a1 + b1 * b1;
            var cc = a2 * a2 + b2 * b2;
            var tt = a1 * a2 + b1 * b2;
            var k1 = radius * Math.sqrt(dd) / mm;
            var k2 = radius * Math.sqrt(cc) / mm;
            var j1 = k1 * tt / dd;
            var j2 = k2 * tt / cc;
            var cx = k1 * b2 + k2 * b1;
            var cy = k1 * a2 + k2 * a1;
            var px = b1 * (k2 + j1);
            var py = a1 * (k2 + j1);
            var qx = b2 * (k1 + j2);
            var qy = a2 * (k1 + j2);
            var startAngle = Math.atan2(py - cy, px - cx);
            var endAngle = Math.atan2(qy - cy, qx - cx);

            this.arc(cx + x1, cy + y1, radius, startAngle, endAngle, b1 * a2 > b2 * a1);
        }

        this.dirty++;

        return this;
    };

    /**
     * The arc method creates an arc/curve (used to create circles, or parts of circles).
     *
     * @param {number} cx - The x-coordinate of the center of the circle
     * @param {number} cy - The y-coordinate of the center of the circle
     * @param {number} radius - The radius of the circle
     * @param {number} startAngle - The starting angle, in radians (0 is at the 3 o'clock position
     *  of the arc's circle)
     * @param {number} endAngle - The ending angle, in radians
     * @param {boolean} [anticlockwise=false] - Specifies whether the drawing should be
     *  counter-clockwise or clockwise. False is default, and indicates clockwise, while true
     *  indicates counter-clockwise.
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */


    Graphics.prototype.arc = function arc(cx, cy, radius, startAngle, endAngle) {
        var anticlockwise = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;

        if (startAngle === endAngle) {
            return this;
        }

        if (!anticlockwise && endAngle <= startAngle) {
            endAngle += _const.PI_2;
        } else if (anticlockwise && startAngle <= endAngle) {
            startAngle += _const.PI_2;
        }

        var sweep = endAngle - startAngle;
        var segs = Graphics.CURVES.adaptive ? this._segmentsCount(Math.abs(sweep) * radius) : Math.ceil(Math.abs(sweep) / _const.PI_2) * 40;

        if (sweep === 0) {
            return this;
        }

        var startX = cx + Math.cos(startAngle) * radius;
        var startY = cy + Math.sin(startAngle) * radius;

        // If the currentPath exists, take its points. Otherwise call `moveTo` to start a path.
        var points = this.currentPath ? this.currentPath.shape.points : null;

        if (points) {
            // We check how far our start is from the last existing point
            var xDiff = Math.abs(points[points.length - 2] - startX);
            var yDiff = Math.abs(points[points.length - 1] - startY);

            if (xDiff < 0.001 && yDiff < 0.001) {
                // If the point is very close, we don't add it, since this would lead to artifacts
                // during tesselation due to floating point imprecision.
            } else {
                points.push(startX, startY);
            }
        } else {
            this.moveTo(startX, startY);
            points = this.currentPath.shape.points;
        }

        var theta = sweep / (segs * 2);
        var theta2 = theta * 2;

        var cTheta = Math.cos(theta);
        var sTheta = Math.sin(theta);

        var segMinus = segs - 1;

        var remainder = segMinus % 1 / segMinus;

        for (var i = 0; i <= segMinus; ++i) {
            var real = i + remainder * i;

            var angle = theta + startAngle + theta2 * real;

            var c = Math.cos(angle);
            var s = -Math.sin(angle);

            points.push((cTheta * c + sTheta * s) * radius + cx, (cTheta * -s + sTheta * c) * radius + cy);
        }

        this.dirty++;

        return this;
    };

    /**
     * Specifies a simple one-color fill that subsequent calls to other Graphics methods
     * (such as lineTo() or drawCircle()) use when drawing.
     *
     * @param {number} [color=0] - the color of the fill
     * @param {number} [alpha=1] - the alpha of the fill
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */


    Graphics.prototype.beginFill = function beginFill() {
        var color = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var alpha = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

        this.filling = true;
        this.fillColor = color;
        this.fillAlpha = alpha;

        if (this.currentPath) {
            if (this.currentPath.shape.points.length <= 2) {
                this.currentPath.fill = this.filling;
                this.currentPath.fillColor = this.fillColor;
                this.currentPath.fillAlpha = this.fillAlpha;
            }
        }

        return this;
    };

    /**
     * Applies a fill to the lines and shapes that were added since the last call to the beginFill() method.
     *
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */


    Graphics.prototype.endFill = function endFill() {
        this.filling = false;
        this.fillColor = null;
        this.fillAlpha = 1;

        return this;
    };

    /**
     *
     * @param {number} x - The X coord of the top-left of the rectangle
     * @param {number} y - The Y coord of the top-left of the rectangle
     * @param {number} width - The width of the rectangle
     * @param {number} height - The height of the rectangle
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */


    Graphics.prototype.drawRect = function drawRect(x, y, width, height) {
        this.drawShape(new _math.Rectangle(x, y, width, height));

        return this;
    };

    /**
     *
     * @param {number} x - The X coord of the top-left of the rectangle
     * @param {number} y - The Y coord of the top-left of the rectangle
     * @param {number} width - The width of the rectangle
     * @param {number} height - The height of the rectangle
     * @param {number} radius - Radius of the rectangle corners
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */


    Graphics.prototype.drawRoundedRect = function drawRoundedRect(x, y, width, height, radius) {
        this.drawShape(new _math.RoundedRectangle(x, y, width, height, radius));

        return this;
    };

    /**
     * Draws a circle.
     *
     * @param {number} x - The X coordinate of the center of the circle
     * @param {number} y - The Y coordinate of the center of the circle
     * @param {number} radius - The radius of the circle
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */


    Graphics.prototype.drawCircle = function drawCircle(x, y, radius) {
        this.drawShape(new _math.Circle(x, y, radius));

        return this;
    };

    /**
     * Draws an ellipse.
     *
     * @param {number} x - The X coordinate of the center of the ellipse
     * @param {number} y - The Y coordinate of the center of the ellipse
     * @param {number} width - The half width of the ellipse
     * @param {number} height - The half height of the ellipse
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */


    Graphics.prototype.drawEllipse = function drawEllipse(x, y, width, height) {
        this.drawShape(new _math.Ellipse(x, y, width, height));

        return this;
    };

    /**
     * Draws a polygon using the given path.
     *
     * @param {number[]|PIXI.Point[]|PIXI.Polygon} path - The path data used to construct the polygon.
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */


    Graphics.prototype.drawPolygon = function drawPolygon(path) {
        // prevents an argument assignment deopt
        // see section 3.1: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments
        var points = path;

        var closed = true;

        if (points instanceof _math.Polygon) {
            closed = points.closed;
            points = points.points;
        }

        if (!Array.isArray(points)) {
            // prevents an argument leak deopt
            // see section 3.2: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments
            points = new Array(arguments.length);

            for (var i = 0; i < points.length; ++i) {
                points[i] = arguments[i]; // eslint-disable-line prefer-rest-params
            }
        }

        var shape = new _math.Polygon(points);

        shape.closed = closed;

        this.drawShape(shape);

        return this;
    };

    /**
     * Draw a star shape with an abitrary number of points.
     *
     * @param {number} x - Center X position of the star
     * @param {number} y - Center Y position of the star
     * @param {number} points - The number of points of the star, must be > 1
     * @param {number} radius - The outer radius of the star
     * @param {number} [innerRadius] - The inner radius between points, default half `radius`
     * @param {number} [rotation=0] - The rotation of the star in radians, where 0 is vertical
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */


    Graphics.prototype.drawStar = function drawStar(x, y, points, radius, innerRadius) {
        var rotation = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;

        innerRadius = innerRadius || radius / 2;

        var startAngle = -1 * Math.PI / 2 + rotation;
        var len = points * 2;
        var delta = _const.PI_2 / len;
        var polygon = [];

        for (var i = 0; i < len; i++) {
            var r = i % 2 ? innerRadius : radius;
            var angle = i * delta + startAngle;

            polygon.push(x + r * Math.cos(angle), y + r * Math.sin(angle));
        }

        return this.drawPolygon(polygon);
    };

    /**
     * Clears the graphics that were drawn to this Graphics object, and resets fill and line style settings.
     *
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */


    Graphics.prototype.clear = function clear() {
        if (this.lineWidth || this.filling || this.graphicsData.length > 0) {
            this.lineWidth = 0;
            this.lineAlignment = 0.5;

            this.filling = false;

            this.boundsDirty = -1;
            this.canvasTintDirty = -1;
            this.dirty++;
            this.clearDirty++;
            this.graphicsData.length = 0;
        }

        this.currentPath = null;
        this._spriteRect = null;

        return this;
    };

    /**
     * True if graphics consists of one rectangle, and thus, can be drawn like a Sprite and
     * masked with gl.scissor.
     *
     * @returns {boolean} True if only 1 rect.
     */


    Graphics.prototype.isFastRect = function isFastRect() {
        return this.graphicsData.length === 1 && this.graphicsData[0].shape.type === _const.SHAPES.RECT && !this.graphicsData[0].lineWidth;
    };

    /**
     * Renders the object using the WebGL renderer
     *
     * @private
     * @param {PIXI.WebGLRenderer} renderer - The renderer
     */


    Graphics.prototype._renderWebGL = function _renderWebGL(renderer) {
        // if the sprite is not visible or the alpha is 0 then no need to render this element
        if (this.dirty !== this.fastRectDirty) {
            this.fastRectDirty = this.dirty;
            this._fastRect = this.isFastRect();
        }

        // TODO this check can be moved to dirty?
        if (this._fastRect) {
            this._renderSpriteRect(renderer);
        } else {
            renderer.setObjectRenderer(renderer.plugins.graphics);
            renderer.plugins.graphics.render(this);
        }
    };

    /**
     * Renders a sprite rectangle.
     *
     * @private
     * @param {PIXI.WebGLRenderer} renderer - The renderer
     */


    Graphics.prototype._renderSpriteRect = function _renderSpriteRect(renderer) {
        var rect = this.graphicsData[0].shape;

        if (!this._spriteRect) {
            this._spriteRect = new _Sprite2.default(new _Texture2.default(_Texture2.default.WHITE));
        }

        var sprite = this._spriteRect;
        var fillColor = this.graphicsData[0].fillColor;

        if (this.tint === 0xffffff) {
            sprite.tint = fillColor;
        } else if (this.tint !== this._prevRectTint || fillColor !== this._prevRectFillColor) {
            var t1 = tempColor1;
            var t2 = tempColor2;

            (0, _utils.hex2rgb)(fillColor, t1);
            (0, _utils.hex2rgb)(this.tint, t2);

            t1[0] *= t2[0];
            t1[1] *= t2[1];
            t1[2] *= t2[2];

            sprite.tint = (0, _utils.rgb2hex)(t1);

            this._prevRectTint = this.tint;
            this._prevRectFillColor = fillColor;
        }

        sprite.alpha = this.graphicsData[0].fillAlpha;
        sprite.worldAlpha = this.worldAlpha * sprite.alpha;
        sprite.blendMode = this.blendMode;

        sprite._texture._frame.width = rect.width;
        sprite._texture._frame.height = rect.height;

        sprite.transform.worldTransform = this.transform.worldTransform;

        sprite.anchor.set(-rect.x / rect.width, -rect.y / rect.height);
        sprite._onAnchorUpdate();

        sprite._renderWebGL(renderer);
    };

    /**
     * Renders the object using the Canvas renderer
     *
     * @private
     * @param {PIXI.CanvasRenderer} renderer - The renderer
     */


    Graphics.prototype._renderCanvas = function _renderCanvas(renderer) {
        if (this.isMask === true) {
            return;
        }

        renderer.plugins.graphics.render(this);
    };

    /**
     * Retrieves the bounds of the graphic shape as a rectangle object
     *
     * @private
     */


    Graphics.prototype._calculateBounds = function _calculateBounds() {
        if (this.boundsDirty !== this.dirty) {
            this.boundsDirty = this.dirty;
            this.updateLocalBounds();

            this.cachedSpriteDirty = true;
        }

        var lb = this._localBounds;

        this._bounds.addFrame(this.transform, lb.minX, lb.minY, lb.maxX, lb.maxY);
    };

    /**
     * Tests if a point is inside this graphics object
     *
     * @param {PIXI.Point} point - the point to test
     * @return {boolean} the result of the test
     */


    Graphics.prototype.containsPoint = function containsPoint(point) {
        this.worldTransform.applyInverse(point, tempPoint);

        var graphicsData = this.graphicsData;

        for (var i = 0; i < graphicsData.length; ++i) {
            var data = graphicsData[i];

            if (!data.fill) {
                continue;
            }

            // only deal with fills..
            if (data.shape) {
                if (data.shape.contains(tempPoint.x, tempPoint.y)) {
                    if (data.holes) {
                        for (var _i = 0; _i < data.holes.length; _i++) {
                            var hole = data.holes[_i];

                            if (hole.contains(tempPoint.x, tempPoint.y)) {
                                return false;
                            }
                        }
                    }

                    return true;
                }
            }
        }

        return false;
    };

    /**
     * Update the bounds of the object
     *
     */


    Graphics.prototype.updateLocalBounds = function updateLocalBounds() {
        var minX = Infinity;
        var maxX = -Infinity;

        var minY = Infinity;
        var maxY = -Infinity;

        if (this.graphicsData.length) {
            var shape = 0;
            var x = 0;
            var y = 0;
            var w = 0;
            var h = 0;

            for (var i = 0; i < this.graphicsData.length; i++) {
                var data = this.graphicsData[i];
                var type = data.type;
                var lineWidth = data.lineWidth;
                var lineAlignment = data.lineAlignment;

                var lineOffset = lineWidth * lineAlignment;

                shape = data.shape;

                if (type === _const.SHAPES.RECT || type === _const.SHAPES.RREC) {
                    x = shape.x - lineOffset;
                    y = shape.y - lineOffset;
                    w = shape.width + lineOffset * 2;
                    h = shape.height + lineOffset * 2;

                    minX = x < minX ? x : minX;
                    maxX = x + w > maxX ? x + w : maxX;

                    minY = y < minY ? y : minY;
                    maxY = y + h > maxY ? y + h : maxY;
                } else if (type === _const.SHAPES.CIRC) {
                    x = shape.x;
                    y = shape.y;
                    w = shape.radius + lineOffset;
                    h = shape.radius + lineOffset;

                    minX = x - w < minX ? x - w : minX;
                    maxX = x + w > maxX ? x + w : maxX;

                    minY = y - h < minY ? y - h : minY;
                    maxY = y + h > maxY ? y + h : maxY;
                } else if (type === _const.SHAPES.ELIP) {
                    x = shape.x;
                    y = shape.y;
                    w = shape.width + lineOffset;
                    h = shape.height + lineOffset;

                    minX = x - w < minX ? x - w : minX;
                    maxX = x + w > maxX ? x + w : maxX;

                    minY = y - h < minY ? y - h : minY;
                    maxY = y + h > maxY ? y + h : maxY;
                } else {
                    // POLY
                    var points = shape.points;
                    var x2 = 0;
                    var y2 = 0;
                    var dx = 0;
                    var dy = 0;
                    var rw = 0;
                    var rh = 0;
                    var cx = 0;
                    var cy = 0;

                    for (var j = 0; j + 2 < points.length; j += 2) {
                        x = points[j];
                        y = points[j + 1];
                        x2 = points[j + 2];
                        y2 = points[j + 3];
                        dx = Math.abs(x2 - x);
                        dy = Math.abs(y2 - y);
                        h = lineOffset * 2;
                        w = Math.sqrt(dx * dx + dy * dy);

                        if (w < 1e-9) {
                            continue;
                        }

                        rw = (h / w * dy + dx) / 2;
                        rh = (h / w * dx + dy) / 2;
                        cx = (x2 + x) / 2;
                        cy = (y2 + y) / 2;

                        minX = cx - rw < minX ? cx - rw : minX;
                        maxX = cx + rw > maxX ? cx + rw : maxX;

                        minY = cy - rh < minY ? cy - rh : minY;
                        maxY = cy + rh > maxY ? cy + rh : maxY;
                    }
                }
            }
        } else {
            minX = 0;
            maxX = 0;
            minY = 0;
            maxY = 0;
        }

        var padding = this.boundsPadding;

        this._localBounds.minX = minX - padding;
        this._localBounds.maxX = maxX + padding;

        this._localBounds.minY = minY - padding;
        this._localBounds.maxY = maxY + padding;
    };

    /**
     * Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.
     *
     * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - The shape object to draw.
     * @return {PIXI.GraphicsData} The generated GraphicsData object.
     */


    Graphics.prototype.drawShape = function drawShape(shape) {
        if (this.currentPath) {
            // check current path!
            if (this.currentPath.shape.points.length <= 2) {
                this.graphicsData.pop();
            }
        }

        this.currentPath = null;

        var data = new _GraphicsData2.default(this.lineWidth, this.lineColor, this.lineAlpha, this.fillColor, this.fillAlpha, this.filling, this.nativeLines, shape, this.lineAlignment);

        this.graphicsData.push(data);

        if (data.type === _const.SHAPES.POLY) {
            data.shape.closed = data.shape.closed;
            this.currentPath = data;
        }

        this.dirty++;

        return data;
    };

    /**
     * Generates a canvas texture.
     *
     * @param {number} scaleMode - The scale mode of the texture.
     * @param {number} resolution - The resolution of the texture.
     * @return {PIXI.Texture} The new texture.
     */


    Graphics.prototype.generateCanvasTexture = function generateCanvasTexture(scaleMode) {
        var resolution = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

        var bounds = this.getLocalBounds();

        var canvasBuffer = _RenderTexture2.default.create(bounds.width, bounds.height, scaleMode, resolution);

        if (!canvasRenderer) {
            canvasRenderer = new _CanvasRenderer2.default();
        }

        this.transform.updateLocalTransform();
        this.transform.localTransform.copy(tempMatrix);

        tempMatrix.invert();

        tempMatrix.tx -= bounds.x;
        tempMatrix.ty -= bounds.y;

        canvasRenderer.render(this, canvasBuffer, true, tempMatrix);

        var texture = _Texture2.default.fromCanvas(canvasBuffer.baseTexture._canvasRenderTarget.canvas, scaleMode, 'graphics');

        texture.baseTexture.resolution = resolution;
        texture.baseTexture.update();

        return texture;
    };

    /**
     * Closes the current path.
     *
     * @return {PIXI.Graphics} Returns itself.
     */


    Graphics.prototype.closePath = function closePath() {
        // ok so close path assumes next one is a hole!
        var currentPath = this.currentPath;

        if (currentPath && currentPath.shape) {
            currentPath.shape.close();
        }

        return this;
    };

    /**
     * Adds a hole in the current path.
     *
     * @return {PIXI.Graphics} Returns itself.
     */


    Graphics.prototype.addHole = function addHole() {
        // this is a hole!
        var hole = this.graphicsData.pop();

        this.currentPath = this.graphicsData[this.graphicsData.length - 1];

        this.currentPath.addHole(hole.shape);
        this.currentPath = null;

        return this;
    };

    /**
     * Destroys the Graphics object.
     *
     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all
     *  options have been set to that value
     * @param {boolean} [options.children=false] - if set to true, all the children will have
     *  their destroy method called as well. 'options' will be passed on to those calls.
     * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true
     *  Should it destroy the texture of the child sprite
     * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true
     *  Should it destroy the base texture of the child sprite
     */


    Graphics.prototype.destroy = function destroy(options) {
        _Container.prototype.destroy.call(this, options);

        // destroy each of the GraphicsData objects
        for (var i = 0; i < this.graphicsData.length; ++i) {
            this.graphicsData[i].destroy();
        }

        // for each webgl data entry, destroy the WebGLGraphicsData
        for (var id in this._webGL) {
            for (var j = 0; j < this._webGL[id].data.length; ++j) {
                this._webGL[id].data[j].destroy();
            }
        }

        if (this._spriteRect) {
            this._spriteRect.destroy();
        }

        this.graphicsData = null;

        this.currentPath = null;
        this._webGL = null;
        this._localBounds = null;
    };

    return Graphics;
}(_Container3.default);

exports.default = Graphics;


Graphics._SPRITE_TEXTURE = null;

/**
 * Graphics curves resolution settings. If `adaptive` flag is set to `true`,
 * the resolution is calculated based on the curve's length to ensure better visual quality.
 * Adaptive draw works with `bezierCurveTo` and `quadraticCurveTo`.
 *
 * @static
 * @constant
 * @memberof PIXI.Graphics
 * @name CURVES
 * @type {object}
 * @property {boolean} adaptive=false - flag indicating if the resolution should be adaptive
 * @property {number} maxLength=10 - maximal length of a single segment of the curve (if adaptive = false, ignored)
 * @property {number} minSegments=8 - minimal number of segments in the curve (if adaptive = false, ignored)
 * @property {number} maxSegments=2048 - maximal number of segments in the curve (if adaptive = false, ignored)
 */
Graphics.CURVES = {
    adaptive: false,
    maxLength: 10,
    minSegments: 8,
    maxSegments: 2048
};

},{"../const":53,"../display/Bounds":54,"../display/Container":55,"../math":77,"../renderers/canvas/CanvasRenderer":84,"../sprites/Sprite":109,"../textures/RenderTexture":120,"../textures/Texture":122,"../utils":132,"./GraphicsData":61,"./utils/bezierCurveTo":63}],61:[function(require,module,exports){
"use strict";

exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * A GraphicsData object.
 *
 * @class
 * @memberof PIXI
 */
var GraphicsData = function () {
  /**
   *
   * @param {number} lineWidth - the width of the line to draw
   * @param {number} lineColor - the color of the line to draw
   * @param {number} lineAlpha - the alpha of the line to draw
   * @param {number} fillColor - the color of the fill
   * @param {number} fillAlpha - the alpha of the fill
   * @param {boolean} fill - whether or not the shape is filled with a colour
   * @param {boolean} nativeLines - the method for drawing lines
   * @param {PIXI.Circle|PIXI.Rectangle|PIXI.Ellipse|PIXI.Polygon} shape - The shape object to draw.
   * @param {number} lineAlignment - the alignment of the line.
   */
  function GraphicsData(lineWidth, lineColor, lineAlpha, fillColor, fillAlpha, fill, nativeLines, shape, lineAlignment) {
    _classCallCheck(this, GraphicsData);

    /**
     * the width of the line to draw
     * @member {number}
     */
    this.lineWidth = lineWidth;

    /**
     * The alignment of any lines drawn (0.5 = middle, 1 = outter, 0 = inner).
     *
     * @member {number}
     * @default 0
     */
    this.lineAlignment = lineAlignment;

    /**
     * if true the liens will be draw using LINES instead of TRIANGLE_STRIP
     * @member {boolean}
     */
    this.nativeLines = nativeLines;

    /**
     * the color of the line to draw
     * @member {number}
     */
    this.lineColor = lineColor;

    /**
     * the alpha of the line to draw
     * @member {number}
     */
    this.lineAlpha = lineAlpha;

    /**
     * cached tint of the line to draw
     * @member {number}
     * @private
     */
    this._lineTint = lineColor;

    /**
     * the color of the fill
     * @member {number}
     */
    this.fillColor = fillColor;

    /**
     * the alpha of the fill
     * @member {number}
     */
    this.fillAlpha = fillAlpha;

    /**
     * cached tint of the fill
     * @member {number}
     * @private
     */
    this._fillTint = fillColor;

    /**
     * whether or not the shape is filled with a colour
     * @member {boolean}
     */
    this.fill = fill;

    this.holes = [];

    /**
     * The shape object to draw.
     * @member {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle}
     */
    this.shape = shape;

    /**
     * The type of the shape, see the Const.Shapes file for all the existing types,
     * @member {number}
     */
    this.type = shape.type;
  }

  /**
   * Creates a new GraphicsData object with the same values as this one.
   *
   * @return {PIXI.GraphicsData} Cloned GraphicsData object
   */


  GraphicsData.prototype.clone = function clone() {
    return new GraphicsData(this.lineWidth, this.lineColor, this.lineAlpha, this.fillColor, this.fillAlpha, this.fill, this.nativeLines, this.shape, this.lineAlignment);
  };

  /**
   * Adds a hole to the shape.
   *
   * @param {PIXI.Rectangle|PIXI.Circle} shape - The shape of the hole.
   */


  GraphicsData.prototype.addHole = function addHole(shape) {
    this.holes.push(shape);
  };

  /**
   * Destroys the Graphics data.
   */


  GraphicsData.prototype.destroy = function destroy() {
    this.shape = null;
    this.holes = null;
  };

  return GraphicsData;
}();

exports.default = GraphicsData;

},{}],62:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _CanvasRenderer = require('../../renderers/canvas/CanvasRenderer');

var _CanvasRenderer2 = _interopRequireDefault(_CanvasRenderer);

var _const = require('../../const');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @author Mat Groves
 *
 * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/
 * for creating the original PixiJS version!
 * Also a thanks to https://github.com/bchevalier for tweaking the tint and alpha so that they
 * now share 4 bytes on the vertex buffer
 *
 * Heavily inspired by LibGDX's CanvasGraphicsRenderer:
 * https://github.com/libgdx/libgdx/blob/1.0.0/gdx/src/com/badlogic/gdx/graphics/glutils/ShapeRenderer.java
 */

/**
 * Renderer dedicated to drawing and batching graphics objects.
 *
 * @class
 * @private
 * @memberof PIXI
 */
var CanvasGraphicsRenderer = function () {
    /**
     * @param {PIXI.CanvasRenderer} renderer - The current PIXI renderer.
     */
    function CanvasGraphicsRenderer(renderer) {
        _classCallCheck(this, CanvasGraphicsRenderer);

        this.renderer = renderer;
    }

    /**
     * Renders a Graphics object to a canvas.
     *
     * @param {PIXI.Graphics} graphics - the actual graphics object to render
     */


    CanvasGraphicsRenderer.prototype.render = function render(graphics) {
        var renderer = this.renderer;
        var context = renderer.context;
        var worldAlpha = graphics.worldAlpha;
        var transform = graphics.transform.worldTransform;
        var resolution = renderer.resolution;

        context.setTransform(transform.a * resolution, transform.b * resolution, transform.c * resolution, transform.d * resolution, transform.tx * resolution, transform.ty * resolution);

        // update tint if graphics was dirty
        if (graphics.canvasTintDirty !== graphics.dirty || graphics._prevTint !== graphics.tint) {
            this.updateGraphicsTint(graphics);
        }

        renderer.setBlendMode(graphics.blendMode);

        for (var i = 0; i < graphics.graphicsData.length; i++) {
            var data = graphics.graphicsData[i];
            var shape = data.shape;

            var fillColor = data._fillTint;
            var lineColor = data._lineTint;

            context.lineWidth = data.lineWidth;

            if (data.type === _const.SHAPES.POLY) {
                context.beginPath();

                var points = shape.points;
                var holes = data.holes;
                var outerArea = void 0;
                var innerArea = void 0;
                var px = void 0;
                var py = void 0;

                context.moveTo(points[0], points[1]);

                for (var j = 2; j < points.length; j += 2) {
                    context.lineTo(points[j], points[j + 1]);
                }

                // if the first and last point are the same close the path - much neater :)
                if (shape.closed) {
                    context.closePath();
                }

                if (holes.length > 0) {
                    outerArea = 0;
                    px = points[0];
                    py = points[1];
                    for (var _j = 2; _j + 2 < points.length; _j += 2) {
                        outerArea += (points[_j] - px) * (points[_j + 3] - py) - (points[_j + 2] - px) * (points[_j + 1] - py);
                    }

                    for (var k = 0; k < holes.length; k++) {
                        points = holes[k].points;

                        if (!points) {
                            continue;
                        }

                        innerArea = 0;
                        px = points[0];
                        py = points[1];
                        for (var _j2 = 2; _j2 + 2 < points.length; _j2 += 2) {
                            innerArea += (points[_j2] - px) * (points[_j2 + 3] - py) - (points[_j2 + 2] - px) * (points[_j2 + 1] - py);
                        }

                        if (innerArea * outerArea < 0) {
                            context.moveTo(points[0], points[1]);

                            for (var _j3 = 2; _j3 < points.length; _j3 += 2) {
                                context.lineTo(points[_j3], points[_j3 + 1]);
                            }
                        } else {
                            context.moveTo(points[points.length - 2], points[points.length - 1]);

                            for (var _j4 = points.length - 4; _j4 >= 0; _j4 -= 2) {
                                context.lineTo(points[_j4], points[_j4 + 1]);
                            }
                        }

                        if (holes[k].close) {
                            context.closePath();
                        }
                    }
                }

                if (data.fill) {
                    context.globalAlpha = data.fillAlpha * worldAlpha;
                    context.fillStyle = '#' + ('00000' + (fillColor | 0).toString(16)).substr(-6);
                    context.fill();
                }
                if (data.lineWidth) {
                    context.globalAlpha = data.lineAlpha * worldAlpha;
                    context.strokeStyle = '#' + ('00000' + (lineColor | 0).toString(16)).substr(-6);
                    context.stroke();
                }
            } else if (data.type === _const.SHAPES.RECT) {
                if (data.fillColor || data.fillColor === 0) {
                    context.globalAlpha = data.fillAlpha * worldAlpha;
                    context.fillStyle = '#' + ('00000' + (fillColor | 0).toString(16)).substr(-6);
                    context.fillRect(shape.x, shape.y, shape.width, shape.height);
                }
                if (data.lineWidth) {
                    context.globalAlpha = data.lineAlpha * worldAlpha;
                    context.strokeStyle = '#' + ('00000' + (lineColor | 0).toString(16)).substr(-6);
                    context.strokeRect(shape.x, shape.y, shape.width, shape.height);
                }
            } else if (data.type === _const.SHAPES.CIRC) {
                // TODO - need to be Undefined!
                context.beginPath();
                context.arc(shape.x, shape.y, shape.radius, 0, 2 * Math.PI);
                context.closePath();

                if (data.fill) {
                    context.globalAlpha = data.fillAlpha * worldAlpha;
                    context.fillStyle = '#' + ('00000' + (fillColor | 0).toString(16)).substr(-6);
                    context.fill();
                }
                if (data.lineWidth) {
                    context.globalAlpha = data.lineAlpha * worldAlpha;
                    context.strokeStyle = '#' + ('00000' + (lineColor | 0).toString(16)).substr(-6);
                    context.stroke();
                }
            } else if (data.type === _const.SHAPES.ELIP) {
                // ellipse code taken from: http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas

                var w = shape.width * 2;
                var h = shape.height * 2;

                var x = shape.x - w / 2;
                var y = shape.y - h / 2;

                context.beginPath();

                var kappa = 0.5522848;
                var ox = w / 2 * kappa; // control point offset horizontal
                var oy = h / 2 * kappa; // control point offset vertical
                var xe = x + w; // x-end
                var ye = y + h; // y-end
                var xm = x + w / 2; // x-middle
                var ym = y + h / 2; // y-middle

                context.moveTo(x, ym);
                context.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
                context.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
                context.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
                context.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);

                context.closePath();

                if (data.fill) {
                    context.globalAlpha = data.fillAlpha * worldAlpha;
                    context.fillStyle = '#' + ('00000' + (fillColor | 0).toString(16)).substr(-6);
                    context.fill();
                }
                if (data.lineWidth) {
                    context.globalAlpha = data.lineAlpha * worldAlpha;
                    context.strokeStyle = '#' + ('00000' + (lineColor | 0).toString(16)).substr(-6);
                    context.stroke();
                }
            } else if (data.type === _const.SHAPES.RREC) {
                var rx = shape.x;
                var ry = shape.y;
                var width = shape.width;
                var height = shape.height;
                var radius = shape.radius;

                var maxRadius = Math.min(width, height) / 2 | 0;

                radius = radius > maxRadius ? maxRadius : radius;

                context.beginPath();
                context.moveTo(rx, ry + radius);
                context.lineTo(rx, ry + height - radius);
                context.quadraticCurveTo(rx, ry + height, rx + radius, ry + height);
                context.lineTo(rx + width - radius, ry + height);
                context.quadraticCurveTo(rx + width, ry + height, rx + width, ry + height - radius);
                context.lineTo(rx + width, ry + radius);
                context.quadraticCurveTo(rx + width, ry, rx + width - radius, ry);
                context.lineTo(rx + radius, ry);
                context.quadraticCurveTo(rx, ry, rx, ry + radius);
                context.closePath();

                if (data.fillColor || data.fillColor === 0) {
                    context.globalAlpha = data.fillAlpha * worldAlpha;
                    context.fillStyle = '#' + ('00000' + (fillColor | 0).toString(16)).substr(-6);
                    context.fill();
                }

                if (data.lineWidth) {
                    context.globalAlpha = data.lineAlpha * worldAlpha;
                    context.strokeStyle = '#' + ('00000' + (lineColor | 0).toString(16)).substr(-6);
                    context.stroke();
                }
            }
        }
    };

    /**
     * Updates the tint of a graphics object
     *
     * @private
     * @param {PIXI.Graphics} graphics - the graphics that will have its tint updated
     */


    CanvasGraphicsRenderer.prototype.updateGraphicsTint = function updateGraphicsTint(graphics) {
        graphics._prevTint = graphics.tint;
        graphics.canvasTintDirty = graphics.dirty;

        var tintR = (graphics.tint >> 16 & 0xFF) / 255;
        var tintG = (graphics.tint >> 8 & 0xFF) / 255;
        var tintB = (graphics.tint & 0xFF) / 255;

        for (var i = 0; i < graphics.graphicsData.length; ++i) {
            var data = graphics.graphicsData[i];

            var fillColor = data.fillColor | 0;
            var lineColor = data.lineColor | 0;

            // super inline, cos optimization :)
            data._fillTint = ((fillColor >> 16 & 0xFF) / 255 * tintR * 255 << 16) + ((fillColor >> 8 & 0xFF) / 255 * tintG * 255 << 8) + (fillColor & 0xFF) / 255 * tintB * 255;

            data._lineTint = ((lineColor >> 16 & 0xFF) / 255 * tintR * 255 << 16) + ((lineColor >> 8 & 0xFF) / 255 * tintG * 255 << 8) + (lineColor & 0xFF) / 255 * tintB * 255;
        }
    };

    /**
     * Renders a polygon.
     *
     * @param {PIXI.Point[]} points - The points to render
     * @param {boolean} close - Should the polygon be closed
     * @param {CanvasRenderingContext2D} context - The rendering context to use
     */


    CanvasGraphicsRenderer.prototype.renderPolygon = function renderPolygon(points, close, context) {
        context.moveTo(points[0], points[1]);

        for (var j = 1; j < points.length / 2; ++j) {
            context.lineTo(points[j * 2], points[j * 2 + 1]);
        }

        if (close) {
            context.closePath();
        }
    };

    /**
     * destroy graphics object
     *
     */


    CanvasGraphicsRenderer.prototype.destroy = function destroy() {
        this.renderer = null;
    };

    return CanvasGraphicsRenderer;
}();

exports.default = CanvasGraphicsRenderer;


_CanvasRenderer2.default.registerPlugin('graphics', CanvasGraphicsRenderer);

},{"../../const":53,"../../renderers/canvas/CanvasRenderer":84}],63:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.default = bezierCurveTo;
/**
 * Calculate the points for a bezier curve and then draws it.
 *
 * Ignored from docs since it is not directly exposed.
 *
 * @ignore
 * @param {number} fromX - Starting point x
 * @param {number} fromY - Starting point y
 * @param {number} cpX - Control point x
 * @param {number} cpY - Control point y
 * @param {number} cpX2 - Second Control point x
 * @param {number} cpY2 - Second Control point y
 * @param {number} toX - Destination point x
 * @param {number} toY - Destination point y
 * @param {number} n - Number of segments approximating the bezier curve
 * @param {number[]} [path=[]] - Path array to push points into
 * @return {number[]} Array of points of the curve
 */
function bezierCurveTo(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY, n) {
    var path = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : [];

    var dt = 0;
    var dt2 = 0;
    var dt3 = 0;
    var t2 = 0;
    var t3 = 0;

    path.push(fromX, fromY);

    for (var i = 1, j = 0; i <= n; ++i) {
        j = i / n;

        dt = 1 - j;
        dt2 = dt * dt;
        dt3 = dt2 * dt;

        t2 = j * j;
        t3 = t2 * j;

        path.push(dt3 * fromX + 3 * dt2 * j * cpX + 3 * dt * t2 * cpX2 + t3 * toX, dt3 * fromY + 3 * dt2 * j * cpY + 3 * dt * t2 * cpY2 + t3 * toY);
    }

    return path;
}

},{}],64:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _utils = require('../../utils');

var _const = require('../../const');

var _ObjectRenderer2 = require('../../renderers/webgl/utils/ObjectRenderer');

var _ObjectRenderer3 = _interopRequireDefault(_ObjectRenderer2);

var _WebGLRenderer = require('../../renderers/webgl/WebGLRenderer');

var _WebGLRenderer2 = _interopRequireDefault(_WebGLRenderer);

var _WebGLGraphicsData = require('./WebGLGraphicsData');

var _WebGLGraphicsData2 = _interopRequireDefault(_WebGLGraphicsData);

var _PrimitiveShader = require('./shaders/PrimitiveShader');

var _PrimitiveShader2 = _interopRequireDefault(_PrimitiveShader);

var _buildPoly = require('./utils/buildPoly');

var _buildPoly2 = _interopRequireDefault(_buildPoly);

var _buildRectangle = require('./utils/buildRectangle');

var _buildRectangle2 = _interopRequireDefault(_buildRectangle);

var _buildRoundedRectangle = require('./utils/buildRoundedRectangle');

var _buildRoundedRectangle2 = _interopRequireDefault(_buildRoundedRectangle);

var _buildCircle = require('./utils/buildCircle');

var _buildCircle2 = _interopRequireDefault(_buildCircle);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Renders the graphics object.
 *
 * @class
 * @memberof PIXI
 * @extends PIXI.ObjectRenderer
 */
var GraphicsRenderer = function (_ObjectRenderer) {
    _inherits(GraphicsRenderer, _ObjectRenderer);

    /**
     * @param {PIXI.WebGLRenderer} renderer - The renderer this object renderer works for.
     */
    function GraphicsRenderer(renderer) {
        _classCallCheck(this, GraphicsRenderer);

        var _this = _possibleConstructorReturn(this, _ObjectRenderer.call(this, renderer));

        _this.graphicsDataPool = [];

        _this.primitiveShader = null;

        _this.gl = renderer.gl;

        // easy access!
        _this.CONTEXT_UID = 0;
        return _this;
    }

    /**
     * Called when there is a WebGL context change
     *
     * @private
     *
     */


    GraphicsRenderer.prototype.onContextChange = function onContextChange() {
        this.gl = this.renderer.gl;
        this.CONTEXT_UID = this.renderer.CONTEXT_UID;
        this.primitiveShader = new _PrimitiveShader2.default(this.gl);
    };

    /**
     * Destroys this renderer.
     *
     */


    GraphicsRenderer.prototype.destroy = function destroy() {
        _ObjectRenderer3.default.prototype.destroy.call(this);

        for (var i = 0; i < this.graphicsDataPool.length; ++i) {
            this.graphicsDataPool[i].destroy();
        }

        this.graphicsDataPool = null;
    };

    /**
     * Renders a graphics object.
     *
     * @param {PIXI.Graphics} graphics - The graphics object to render.
     */


    GraphicsRenderer.prototype.render = function render(graphics) {
        var renderer = this.renderer;
        var gl = renderer.gl;

        var webGLData = void 0;
        var webGL = graphics._webGL[this.CONTEXT_UID];

        if (!webGL || graphics.dirty !== webGL.dirty) {
            this.updateGraphics(graphics);

            webGL = graphics._webGL[this.CONTEXT_UID];
        }

        // This  could be speeded up for sure!
        var shader = this.primitiveShader;

        renderer.bindShader(shader);
        renderer.state.setBlendMode(graphics.blendMode);

        for (var i = 0, n = webGL.data.length; i < n; i++) {
            webGLData = webGL.data[i];
            var shaderTemp = webGLData.shader;

            renderer.bindShader(shaderTemp);
            shaderTemp.uniforms.translationMatrix = graphics.transform.worldTransform.toArray(true);
            shaderTemp.uniforms.tint = (0, _utils.hex2rgb)(graphics.tint);
            shaderTemp.uniforms.alpha = graphics.worldAlpha;

            renderer.bindVao(webGLData.vao);

            if (webGLData.nativeLines) {
                gl.drawArrays(gl.LINES, 0, webGLData.points.length / 6);
            } else {
                webGLData.vao.draw(gl.TRIANGLE_STRIP, webGLData.indices.length);
            }
        }
    };

    /**
     * Updates the graphics object
     *
     * @private
     * @param {PIXI.Graphics} graphics - The graphics object to update
     */


    GraphicsRenderer.prototype.updateGraphics = function updateGraphics(graphics) {
        var gl = this.renderer.gl;

        // get the contexts graphics object
        var webGL = graphics._webGL[this.CONTEXT_UID];

        // if the graphics object does not exist in the webGL context time to create it!
        if (!webGL) {
            webGL = graphics._webGL[this.CONTEXT_UID] = { lastIndex: 0, data: [], gl: gl, clearDirty: -1, dirty: -1 };
        }

        // flag the graphics as not dirty as we are about to update it...
        webGL.dirty = graphics.dirty;

        // if the user cleared the graphics object we will need to clear every object
        if (graphics.clearDirty !== webGL.clearDirty) {
            webGL.clearDirty = graphics.clearDirty;

            // loop through and return all the webGLDatas to the object pool so than can be reused later on
            for (var i = 0; i < webGL.data.length; i++) {
                this.graphicsDataPool.push(webGL.data[i]);
            }

            // clear the array and reset the index..
            webGL.data.length = 0;
            webGL.lastIndex = 0;
        }

        var webGLData = void 0;
        var webGLDataNativeLines = void 0;

        // loop through the graphics datas and construct each one..
        // if the object is a complex fill then the new stencil buffer technique will be used
        // other wise graphics objects will be pushed into a batch..
        for (var _i = webGL.lastIndex; _i < graphics.graphicsData.length; _i++) {
            var data = graphics.graphicsData[_i];

            // TODO - this can be simplified
            webGLData = this.getWebGLData(webGL, 0);

            if (data.nativeLines && data.lineWidth) {
                webGLDataNativeLines = this.getWebGLData(webGL, 0, true);
                webGL.lastIndex++;
            }

            if (data.type === _const.SHAPES.POLY) {
                (0, _buildPoly2.default)(data, webGLData, webGLDataNativeLines);
            }
            if (data.type === _const.SHAPES.RECT) {
                (0, _buildRectangle2.default)(data, webGLData, webGLDataNativeLines);
            } else if (data.type === _const.SHAPES.CIRC || data.type === _const.SHAPES.ELIP) {
                (0, _buildCircle2.default)(data, webGLData, webGLDataNativeLines);
            } else if (data.type === _const.SHAPES.RREC) {
                (0, _buildRoundedRectangle2.default)(data, webGLData, webGLDataNativeLines);
            }

            webGL.lastIndex++;
        }

        this.renderer.bindVao(null);

        // upload all the dirty data...
        for (var _i2 = 0; _i2 < webGL.data.length; _i2++) {
            webGLData = webGL.data[_i2];

            if (webGLData.dirty) {
                webGLData.upload();
            }
        }
    };

    /**
     *
     * @private
     * @param {WebGLRenderingContext} gl - the current WebGL drawing context
     * @param {number} type - TODO @Alvin
     * @param {number} nativeLines - indicate whether the webGLData use for nativeLines.
     * @return {*} TODO
     */


    GraphicsRenderer.prototype.getWebGLData = function getWebGLData(gl, type, nativeLines) {
        var webGLData = gl.data[gl.data.length - 1];

        if (!webGLData || webGLData.nativeLines !== nativeLines || webGLData.points.length > 320000) {
            webGLData = this.graphicsDataPool.pop() || new _WebGLGraphicsData2.default(this.renderer.gl, this.primitiveShader, this.renderer.state.attribsState);
            webGLData.nativeLines = nativeLines;
            webGLData.reset(type);
            gl.data.push(webGLData);
        }

        webGLData.dirty = true;

        return webGLData;
    };

    return GraphicsRenderer;
}(_ObjectRenderer3.default);

exports.default = GraphicsRenderer;


_WebGLRenderer2.default.registerPlugin('graphics', GraphicsRenderer);

},{"../../const":53,"../../renderers/webgl/WebGLRenderer":91,"../../renderers/webgl/utils/ObjectRenderer":101,"../../utils":132,"./WebGLGraphicsData":65,"./shaders/PrimitiveShader":66,"./utils/buildCircle":67,"./utils/buildPoly":69,"./utils/buildRectangle":70,"./utils/buildRoundedRectangle":71}],65:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _pixiGlCore = require('pixi-gl-core');

var _pixiGlCore2 = _interopRequireDefault(_pixiGlCore);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * An object containing WebGL specific properties to be used by the WebGL renderer
 *
 * @class
 * @private
 * @memberof PIXI
 */
var WebGLGraphicsData = function () {
  /**
   * @param {WebGLRenderingContext} gl - The current WebGL drawing context
   * @param {PIXI.Shader} shader - The shader
   * @param {object} attribsState - The state for the VAO
   */
  function WebGLGraphicsData(gl, shader, attribsState) {
    _classCallCheck(this, WebGLGraphicsData);

    /**
     * The current WebGL drawing context
     *
     * @member {WebGLRenderingContext}
     */
    this.gl = gl;

    // TODO does this need to be split before uploading??
    /**
     * An array of color components (r,g,b)
     * @member {number[]}
     */
    this.color = [0, 0, 0]; // color split!

    /**
     * An array of points to draw
     * @member {PIXI.Point[]}
     */
    this.points = [];

    /**
     * The indices of the vertices
     * @member {number[]}
     */
    this.indices = [];
    /**
     * The main buffer
     * @member {WebGLBuffer}
     */
    this.buffer = _pixiGlCore2.default.GLBuffer.createVertexBuffer(gl);

    /**
     * The index buffer
     * @member {WebGLBuffer}
     */
    this.indexBuffer = _pixiGlCore2.default.GLBuffer.createIndexBuffer(gl);

    /**
     * Whether this graphics is dirty or not
     * @member {boolean}
     */
    this.dirty = true;

    /**
     * Whether this graphics is nativeLines or not
     * @member {boolean}
     */
    this.nativeLines = false;

    this.glPoints = null;
    this.glIndices = null;

    /**
     *
     * @member {PIXI.Shader}
     */
    this.shader = shader;

    this.vao = new _pixiGlCore2.default.VertexArrayObject(gl, attribsState).addIndex(this.indexBuffer).addAttribute(this.buffer, shader.attributes.aVertexPosition, gl.FLOAT, false, 4 * 6, 0).addAttribute(this.buffer, shader.attributes.aColor, gl.FLOAT, false, 4 * 6, 2 * 4);
  }

  /**
   * Resets the vertices and the indices
   */


  WebGLGraphicsData.prototype.reset = function reset() {
    this.points.length = 0;
    this.indices.length = 0;
  };

  /**
   * Binds the buffers and uploads the data
   */


  WebGLGraphicsData.prototype.upload = function upload() {
    this.glPoints = new Float32Array(this.points);
    this.buffer.upload(this.glPoints);

    this.glIndices = new Uint16Array(this.indices);
    this.indexBuffer.upload(this.glIndices);

    this.dirty = false;
  };

  /**
   * Empties all the data
   */


  WebGLGraphicsData.prototype.destroy = function destroy() {
    this.color = null;
    this.points = null;
    this.indices = null;

    this.vao.destroy();
    this.buffer.destroy();
    this.indexBuffer.destroy();

    this.gl = null;

    this.buffer = null;
    this.indexBuffer = null;

    this.glPoints = null;
    this.glIndices = null;
  };

  return WebGLGraphicsData;
}();

exports.default = WebGLGraphicsData;

},{"pixi-gl-core":36}],66:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _Shader2 = require('../../../Shader');

var _Shader3 = _interopRequireDefault(_Shader2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * This shader is used to draw simple primitive shapes for {@link PIXI.Graphics}.
 *
 * @class
 * @memberof PIXI
 * @extends PIXI.Shader
 */
var PrimitiveShader = function (_Shader) {
    _inherits(PrimitiveShader, _Shader);

    /**
     * @param {WebGLRenderingContext} gl - The webgl shader manager this shader works for.
     */
    function PrimitiveShader(gl) {
        _classCallCheck(this, PrimitiveShader);

        return _possibleConstructorReturn(this, _Shader.call(this, gl,
        // vertex shader
        ['attribute vec2 aVertexPosition;', 'attribute vec4 aColor;', 'uniform mat3 translationMatrix;', 'uniform mat3 projectionMatrix;', 'uniform float alpha;', 'uniform vec3 tint;', 'varying vec4 vColor;', 'void main(void){', '   gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);', '   vColor = aColor * vec4(tint * alpha, alpha);', '}'].join('\n'),
        // fragment shader
        ['varying vec4 vColor;', 'void main(void){', '   gl_FragColor = vColor;', '}'].join('\n')));
    }

    return PrimitiveShader;
}(_Shader3.default);

exports.default = PrimitiveShader;

},{"../../../Shader":51}],67:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.default = buildCircle;

var _buildLine = require('./buildLine');

var _buildLine2 = _interopRequireDefault(_buildLine);

var _const = require('../../../const');

var _utils = require('../../../utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Builds a circle to draw
 *
 * Ignored from docs since it is not directly exposed.
 *
 * @ignore
 * @private
 * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object to draw
 * @param {object} webGLData - an object containing all the webGL-specific information to create this shape
 * @param {object} webGLDataNativeLines - an object containing all the webGL-specific information to create nativeLines
 */
function buildCircle(graphicsData, webGLData, webGLDataNativeLines) {
    // need to convert points to a nice regular data
    var circleData = graphicsData.shape;
    var x = circleData.x;
    var y = circleData.y;
    var width = void 0;
    var height = void 0;

    // TODO - bit hacky??
    if (graphicsData.type === _const.SHAPES.CIRC) {
        width = circleData.radius;
        height = circleData.radius;
    } else {
        width = circleData.width;
        height = circleData.height;
    }

    if (width === 0 || height === 0) {
        return;
    }

    var totalSegs = Math.floor(30 * Math.sqrt(circleData.radius)) || Math.floor(15 * Math.sqrt(circleData.width + circleData.height));

    var seg = Math.PI * 2 / totalSegs;

    if (graphicsData.fill) {
        var color = (0, _utils.hex2rgb)(graphicsData.fillColor);
        var alpha = graphicsData.fillAlpha;

        var r = color[0] * alpha;
        var g = color[1] * alpha;
        var b = color[2] * alpha;

        var verts = webGLData.points;
        var indices = webGLData.indices;

        var vecPos = verts.length / 6;

        indices.push(vecPos);

        for (var i = 0; i < totalSegs + 1; i++) {
            verts.push(x, y, r, g, b, alpha);

            verts.push(x + Math.sin(seg * i) * width, y + Math.cos(seg * i) * height, r, g, b, alpha);

            indices.push(vecPos++, vecPos++);
        }

        indices.push(vecPos - 1);
    }

    if (graphicsData.lineWidth) {
        var tempPoints = graphicsData.points;

        graphicsData.points = [];

        for (var _i = 0; _i < totalSegs; _i++) {
            graphicsData.points.push(x + Math.sin(seg * -_i) * width, y + Math.cos(seg * -_i) * height);
        }

        graphicsData.points.push(graphicsData.points[0], graphicsData.points[1]);

        (0, _buildLine2.default)(graphicsData, webGLData, webGLDataNativeLines);

        graphicsData.points = tempPoints;
    }
}

},{"../../../const":53,"../../../utils":132,"./buildLine":68}],68:[function(require,module,exports){
'use strict';

exports.__esModule = true;

exports.default = function (graphicsData, webGLData, webGLDataNativeLines) {
    if (graphicsData.nativeLines) {
        buildNativeLine(graphicsData, webGLDataNativeLines);
    } else {
        buildLine(graphicsData, webGLData);
    }
};

var _math = require('../../../math');

var _utils = require('../../../utils');

/**
 * Builds a line to draw using the poligon method.
 *
 * Ignored from docs since it is not directly exposed.
 *
 * @ignore
 * @private
 * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties
 * @param {object} webGLData - an object containing all the webGL-specific information to create this shape
 */
function buildLine(graphicsData, webGLData) {
    // TODO OPTIMISE!
    var points = graphicsData.points;

    if (points.length === 0) {
        return;
    }
    // if the line width is an odd number add 0.5 to align to a whole pixel
    // commenting this out fixes #711 and #1620
    // if (graphicsData.lineWidth%2)
    // {
    //     for (i = 0; i < points.length; i++)
    //     {
    //         points[i] += 0.5;
    //     }
    // }

    // get first and last point.. figure out the middle!
    var firstPoint = new _math.Point(points[0], points[1]);
    var lastPoint = new _math.Point(points[points.length - 2], points[points.length - 1]);

    // if the first point is the last point - gonna have issues :)
    if (firstPoint.x === lastPoint.x && firstPoint.y === lastPoint.y) {
        // need to clone as we are going to slightly modify the shape..
        points = points.slice();

        points.pop();
        points.pop();

        lastPoint = new _math.Point(points[points.length - 2], points[points.length - 1]);

        var midPointX = lastPoint.x + (firstPoint.x - lastPoint.x) * 0.5;
        var midPointY = lastPoint.y + (firstPoint.y - lastPoint.y) * 0.5;

        points.unshift(midPointX, midPointY);
        points.push(midPointX, midPointY);
    }

    var verts = webGLData.points;
    var indices = webGLData.indices;
    var length = points.length / 2;
    var indexCount = points.length;
    var indexStart = verts.length / 6;

    // DRAW the Line
    var width = graphicsData.lineWidth / 2;

    // sort color
    var color = (0, _utils.hex2rgb)(graphicsData.lineColor);
    var alpha = graphicsData.lineAlpha;
    var r = color[0] * alpha;
    var g = color[1] * alpha;
    var b = color[2] * alpha;

    var p1x = points[0];
    var p1y = points[1];
    var p2x = points[2];
    var p2y = points[3];
    var p3x = 0;
    var p3y = 0;

    var perpx = -(p1y - p2y);
    var perpy = p1x - p2x;
    var perp2x = 0;
    var perp2y = 0;
    var perp3x = 0;
    var perp3y = 0;

    var dist = Math.sqrt(perpx * perpx + perpy * perpy);

    perpx /= dist;
    perpy /= dist;
    perpx *= width;
    perpy *= width;

    var ratio = graphicsData.lineAlignment; // 0.5;
    var r1 = (1 - ratio) * 2;
    var r2 = ratio * 2;

    // start
    verts.push(p1x - perpx * r1, p1y - perpy * r1, r, g, b, alpha);

    verts.push(p1x + perpx * r2, p1y + perpy * r2, r, g, b, alpha);

    for (var i = 1; i < length - 1; ++i) {
        p1x = points[(i - 1) * 2];
        p1y = points[(i - 1) * 2 + 1];

        p2x = points[i * 2];
        p2y = points[i * 2 + 1];

        p3x = points[(i + 1) * 2];
        p3y = points[(i + 1) * 2 + 1];

        perpx = -(p1y - p2y);
        perpy = p1x - p2x;

        dist = Math.sqrt(perpx * perpx + perpy * perpy);
        perpx /= dist;
        perpy /= dist;
        perpx *= width;
        perpy *= width;

        perp2x = -(p2y - p3y);
        perp2y = p2x - p3x;

        dist = Math.sqrt(perp2x * perp2x + perp2y * perp2y);
        perp2x /= dist;
        perp2y /= dist;
        perp2x *= width;
        perp2y *= width;

        var a1 = -perpy + p1y - (-perpy + p2y);
        var b1 = -perpx + p2x - (-perpx + p1x);
        var c1 = (-perpx + p1x) * (-perpy + p2y) - (-perpx + p2x) * (-perpy + p1y);
        var a2 = -perp2y + p3y - (-perp2y + p2y);
        var b2 = -perp2x + p2x - (-perp2x + p3x);
        var c2 = (-perp2x + p3x) * (-perp2y + p2y) - (-perp2x + p2x) * (-perp2y + p3y);

        var denom = a1 * b2 - a2 * b1;

        if (Math.abs(denom) < 0.1) {
            denom += 10.1;
            verts.push(p2x - perpx * r1, p2y - perpy * r1, r, g, b, alpha);

            verts.push(p2x + perpx * r2, p2y + perpy * r2, r, g, b, alpha);

            continue;
        }

        var px = (b1 * c2 - b2 * c1) / denom;
        var py = (a2 * c1 - a1 * c2) / denom;
        var pdist = (px - p2x) * (px - p2x) + (py - p2y) * (py - p2y);

        if (pdist > 196 * width * width) {
            perp3x = perpx - perp2x;
            perp3y = perpy - perp2y;

            dist = Math.sqrt(perp3x * perp3x + perp3y * perp3y);
            perp3x /= dist;
            perp3y /= dist;
            perp3x *= width;
            perp3y *= width;

            verts.push(p2x - perp3x * r1, p2y - perp3y * r1);
            verts.push(r, g, b, alpha);

            verts.push(p2x + perp3x * r2, p2y + perp3y * r2);
            verts.push(r, g, b, alpha);

            verts.push(p2x - perp3x * r2 * r1, p2y - perp3y * r1);
            verts.push(r, g, b, alpha);

            indexCount++;
        } else {
            verts.push(p2x + (px - p2x) * r1, p2y + (py - p2y) * r1);
            verts.push(r, g, b, alpha);

            verts.push(p2x - (px - p2x) * r2, p2y - (py - p2y) * r2);
            verts.push(r, g, b, alpha);
        }
    }

    p1x = points[(length - 2) * 2];
    p1y = points[(length - 2) * 2 + 1];

    p2x = points[(length - 1) * 2];
    p2y = points[(length - 1) * 2 + 1];

    perpx = -(p1y - p2y);
    perpy = p1x - p2x;

    dist = Math.sqrt(perpx * perpx + perpy * perpy);
    perpx /= dist;
    perpy /= dist;
    perpx *= width;
    perpy *= width;

    verts.push(p2x - perpx * r1, p2y - perpy * r1);
    verts.push(r, g, b, alpha);

    verts.push(p2x + perpx * r2, p2y + perpy * r2);
    verts.push(r, g, b, alpha);

    indices.push(indexStart);

    for (var _i = 0; _i < indexCount; ++_i) {
        indices.push(indexStart++);
    }

    indices.push(indexStart - 1);
}

/**
 * Builds a line to draw using the gl.drawArrays(gl.LINES) method
 *
 * Ignored from docs since it is not directly exposed.
 *
 * @ignore
 * @private
 * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties
 * @param {object} webGLData - an object containing all the webGL-specific information to create this shape
 */


/**
 * Builds a line to draw
 *
 * Ignored from docs since it is not directly exposed.
 *
 * @ignore
 * @private
 * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties
 * @param {object} webGLData - an object containing all the webGL-specific information to create this shape
 * @param {object} webGLDataNativeLines - an object containing all the webGL-specific information to create nativeLines
 */
function buildNativeLine(graphicsData, webGLData) {
    var i = 0;
    var points = graphicsData.points;

    if (points.length === 0) return;

    var verts = webGLData.points;
    var length = points.length / 2;

    // sort color
    var color = (0, _utils.hex2rgb)(graphicsData.lineColor);
    var alpha = graphicsData.lineAlpha;
    var r = color[0] * alpha;
    var g = color[1] * alpha;
    var b = color[2] * alpha;

    for (i = 1; i < length; i++) {
        var p1x = points[(i - 1) * 2];
        var p1y = points[(i - 1) * 2 + 1];

        var p2x = points[i * 2];
        var p2y = points[i * 2 + 1];

        verts.push(p1x, p1y);
        verts.push(r, g, b, alpha);

        verts.push(p2x, p2y);
        verts.push(r, g, b, alpha);
    }
}

},{"../../../math":77,"../../../utils":132}],69:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.default = buildPoly;

var _buildLine = require('./buildLine');

var _buildLine2 = _interopRequireDefault(_buildLine);

var _utils = require('../../../utils');

var _earcut = require('earcut');

var _earcut2 = _interopRequireDefault(_earcut);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Builds a polygon to draw
 *
 * Ignored from docs since it is not directly exposed.
 *
 * @ignore
 * @private
 * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties
 * @param {object} webGLData - an object containing all the webGL-specific information to create this shape
 * @param {object} webGLDataNativeLines - an object containing all the webGL-specific information to create nativeLines
 */
function buildPoly(graphicsData, webGLData, webGLDataNativeLines) {
    graphicsData.points = graphicsData.shape.points.slice();

    var points = graphicsData.points;

    if (graphicsData.fill && points.length >= 6) {
        var holeArray = [];
        // Process holes..
        var holes = graphicsData.holes;

        for (var i = 0; i < holes.length; i++) {
            var hole = holes[i];

            holeArray.push(points.length / 2);

            points = points.concat(hole.points);
        }

        // get first and last point.. figure out the middle!
        var verts = webGLData.points;
        var indices = webGLData.indices;

        var length = points.length / 2;

        // sort color
        var color = (0, _utils.hex2rgb)(graphicsData.fillColor);
        var alpha = graphicsData.fillAlpha;
        var r = color[0] * alpha;
        var g = color[1] * alpha;
        var b = color[2] * alpha;

        var triangles = (0, _earcut2.default)(points, holeArray, 2);

        if (!triangles) {
            return;
        }

        var vertPos = verts.length / 6;

        for (var _i = 0; _i < triangles.length; _i += 3) {
            indices.push(triangles[_i] + vertPos);
            indices.push(triangles[_i] + vertPos);
            indices.push(triangles[_i + 1] + vertPos);
            indices.push(triangles[_i + 2] + vertPos);
            indices.push(triangles[_i + 2] + vertPos);
        }

        for (var _i2 = 0; _i2 < length; _i2++) {
            verts.push(points[_i2 * 2], points[_i2 * 2 + 1], r, g, b, alpha);
        }
    }

    if (graphicsData.lineWidth > 0) {
        (0, _buildLine2.default)(graphicsData, webGLData, webGLDataNativeLines);
    }
}

},{"../../../utils":132,"./buildLine":68,"earcut":23}],70:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.default = buildRectangle;

var _buildLine = require('./buildLine');

var _buildLine2 = _interopRequireDefault(_buildLine);

var _utils = require('../../../utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Builds a rectangle to draw
 *
 * Ignored from docs since it is not directly exposed.
 *
 * @ignore
 * @private
 * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties
 * @param {object} webGLData - an object containing all the webGL-specific information to create this shape
 * @param {object} webGLDataNativeLines - an object containing all the webGL-specific information to create nativeLines
 */
function buildRectangle(graphicsData, webGLData, webGLDataNativeLines) {
    // --- //
    // need to convert points to a nice regular data
    //
    var rectData = graphicsData.shape;
    var x = rectData.x;
    var y = rectData.y;
    var width = rectData.width;
    var height = rectData.height;

    if (graphicsData.fill) {
        var color = (0, _utils.hex2rgb)(graphicsData.fillColor);
        var alpha = graphicsData.fillAlpha;

        var r = color[0] * alpha;
        var g = color[1] * alpha;
        var b = color[2] * alpha;

        var verts = webGLData.points;
        var indices = webGLData.indices;

        var vertPos = verts.length / 6;

        // start
        verts.push(x, y);
        verts.push(r, g, b, alpha);

        verts.push(x + width, y);
        verts.push(r, g, b, alpha);

        verts.push(x, y + height);
        verts.push(r, g, b, alpha);

        verts.push(x + width, y + height);
        verts.push(r, g, b, alpha);

        // insert 2 dead triangles..
        indices.push(vertPos, vertPos, vertPos + 1, vertPos + 2, vertPos + 3, vertPos + 3);
    }

    if (graphicsData.lineWidth) {
        var tempPoints = graphicsData.points;

        graphicsData.points = [x, y, x + width, y, x + width, y + height, x, y + height, x, y];

        (0, _buildLine2.default)(graphicsData, webGLData, webGLDataNativeLines);

        graphicsData.points = tempPoints;
    }
}

},{"../../../utils":132,"./buildLine":68}],71:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.default = buildRoundedRectangle;

var _earcut = require('earcut');

var _earcut2 = _interopRequireDefault(_earcut);

var _buildLine = require('./buildLine');

var _buildLine2 = _interopRequireDefault(_buildLine);

var _utils = require('../../../utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Builds a rounded rectangle to draw
 *
 * Ignored from docs since it is not directly exposed.
 *
 * @ignore
 * @private
 * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties
 * @param {object} webGLData - an object containing all the webGL-specific information to create this shape
 * @param {object} webGLDataNativeLines - an object containing all the webGL-specific information to create nativeLines
 */
function buildRoundedRectangle(graphicsData, webGLData, webGLDataNativeLines) {
    var rrectData = graphicsData.shape;
    var x = rrectData.x;
    var y = rrectData.y;
    var width = rrectData.width;
    var height = rrectData.height;

    var radius = rrectData.radius;

    var recPoints = [];

    recPoints.push(x + radius, y);
    quadraticBezierCurve(x + width - radius, y, x + width, y, x + width, y + radius, recPoints);
    quadraticBezierCurve(x + width, y + height - radius, x + width, y + height, x + width - radius, y + height, recPoints);
    quadraticBezierCurve(x + radius, y + height, x, y + height, x, y + height - radius, recPoints);
    quadraticBezierCurve(x, y + radius, x, y, x + radius + 0.0000000001, y, recPoints);

    // this tiny number deals with the issue that occurs when points overlap and earcut fails to triangulate the item.
    // TODO - fix this properly, this is not very elegant.. but it works for now.

    if (graphicsData.fill) {
        var color = (0, _utils.hex2rgb)(graphicsData.fillColor);
        var alpha = graphicsData.fillAlpha;

        var r = color[0] * alpha;
        var g = color[1] * alpha;
        var b = color[2] * alpha;

        var verts = webGLData.points;
        var indices = webGLData.indices;

        var vecPos = verts.length / 6;

        var triangles = (0, _earcut2.default)(recPoints, null, 2);

        for (var i = 0, j = triangles.length; i < j; i += 3) {
            indices.push(triangles[i] + vecPos);
            indices.push(triangles[i] + vecPos);
            indices.push(triangles[i + 1] + vecPos);
            indices.push(triangles[i + 2] + vecPos);
            indices.push(triangles[i + 2] + vecPos);
        }

        for (var _i = 0, _j = recPoints.length; _i < _j; _i++) {
            verts.push(recPoints[_i], recPoints[++_i], r, g, b, alpha);
        }
    }

    if (graphicsData.lineWidth) {
        var tempPoints = graphicsData.points;

        graphicsData.points = recPoints;

        (0, _buildLine2.default)(graphicsData, webGLData, webGLDataNativeLines);

        graphicsData.points = tempPoints;
    }
}

/**
 * Calculate a single point for a quadratic bezier curve.
 * Utility function used by quadraticBezierCurve.
 * Ignored from docs since it is not directly exposed.
 *
 * @ignore
 * @private
 * @param {number} n1 - first number
 * @param {number} n2 - second number
 * @param {number} perc - percentage
 * @return {number} the result
 *
 */
function getPt(n1, n2, perc) {
    var diff = n2 - n1;

    return n1 + diff * perc;
}

/**
 * Calculate the points for a quadratic bezier curve. (helper function..)
 * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c
 *
 * Ignored from docs since it is not directly exposed.
 *
 * @ignore
 * @private
 * @param {number} fromX - Origin point x
 * @param {number} fromY - Origin point x
 * @param {number} cpX - Control point x
 * @param {number} cpY - Control point y
 * @param {number} toX - Destination point x
 * @param {number} toY - Destination point y
 * @param {number[]} [out=[]] - The output array to add points into. If not passed, a new array is created.
 * @return {number[]} an array of points
 */
function quadraticBezierCurve(fromX, fromY, cpX, cpY, toX, toY) {
    var out = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : [];

    var n = 20;
    var points = out;

    var xa = 0;
    var ya = 0;
    var xb = 0;
    var yb = 0;
    var x = 0;
    var y = 0;

    for (var i = 0, j = 0; i <= n; ++i) {
        j = i / n;

        // The Green Line
        xa = getPt(fromX, cpX, j);
        ya = getPt(fromY, cpY, j);
        xb = getPt(cpX, toX, j);
        yb = getPt(cpY, toY, j);

        // The Black Dot
        x = getPt(xa, xb, j);
        y = getPt(ya, yb, j);

        points.push(x, y);
    }

    return points;
}

},{"../../../utils":132,"./buildLine":68,"earcut":23}],72:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.autoDetectRenderer = exports.Application = exports.Filter = exports.SpriteMaskFilter = exports.Quad = exports.RenderTarget = exports.ObjectRenderer = exports.WebGLManager = exports.Shader = exports.CanvasRenderTarget = exports.TextureUvs = exports.VideoBaseTexture = exports.BaseRenderTexture = exports.RenderTexture = exports.BaseTexture = exports.TextureMatrix = exports.Texture = exports.Spritesheet = exports.CanvasGraphicsRenderer = exports.GraphicsRenderer = exports.GraphicsData = exports.Graphics = exports.TextMetrics = exports.TextStyle = exports.Text = exports.SpriteRenderer = exports.CanvasTinter = exports.CanvasSpriteRenderer = exports.Sprite = exports.TransformBase = exports.TransformStatic = exports.Transform = exports.Container = exports.DisplayObject = exports.Bounds = exports.glCore = exports.WebGLRenderer = exports.CanvasRenderer = exports.ticker = exports.utils = exports.settings = undefined;

var _const = require('./const');

Object.keys(_const).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _const[key];
    }
  });
});

var _math = require('./math');

Object.keys(_math).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _math[key];
    }
  });
});

var _pixiGlCore = require('pixi-gl-core');

Object.defineProperty(exports, 'glCore', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_pixiGlCore).default;
  }
});

var _Bounds = require('./display/Bounds');

Object.defineProperty(exports, 'Bounds', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Bounds).default;
  }
});

var _DisplayObject = require('./display/DisplayObject');

Object.defineProperty(exports, 'DisplayObject', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_DisplayObject).default;
  }
});

var _Container = require('./display/Container');

Object.defineProperty(exports, 'Container', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Container).default;
  }
});

var _Transform = require('./display/Transform');

Object.defineProperty(exports, 'Transform', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Transform).default;
  }
});

var _TransformStatic = require('./display/TransformStatic');

Object.defineProperty(exports, 'TransformStatic', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_TransformStatic).default;
  }
});

var _TransformBase = require('./display/TransformBase');

Object.defineProperty(exports, 'TransformBase', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_TransformBase).default;
  }
});

var _Sprite = require('./sprites/Sprite');

Object.defineProperty(exports, 'Sprite', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Sprite).default;
  }
});

var _CanvasSpriteRenderer = require('./sprites/canvas/CanvasSpriteRenderer');

Object.defineProperty(exports, 'CanvasSpriteRenderer', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_CanvasSpriteRenderer).default;
  }
});

var _CanvasTinter = require('./sprites/canvas/CanvasTinter');

Object.defineProperty(exports, 'CanvasTinter', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_CanvasTinter).default;
  }
});

var _SpriteRenderer = require('./sprites/webgl/SpriteRenderer');

Object.defineProperty(exports, 'SpriteRenderer', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_SpriteRenderer).default;
  }
});

var _Text = require('./text/Text');

Object.defineProperty(exports, 'Text', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Text).default;
  }
});

var _TextStyle = require('./text/TextStyle');

Object.defineProperty(exports, 'TextStyle', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_TextStyle).default;
  }
});

var _TextMetrics = require('./text/TextMetrics');

Object.defineProperty(exports, 'TextMetrics', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_TextMetrics).default;
  }
});

var _Graphics = require('./graphics/Graphics');

Object.defineProperty(exports, 'Graphics', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Graphics).default;
  }
});

var _GraphicsData = require('./graphics/GraphicsData');

Object.defineProperty(exports, 'GraphicsData', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_GraphicsData).default;
  }
});

var _GraphicsRenderer = require('./graphics/webgl/GraphicsRenderer');

Object.defineProperty(exports, 'GraphicsRenderer', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_GraphicsRenderer).default;
  }
});

var _CanvasGraphicsRenderer = require('./graphics/canvas/CanvasGraphicsRenderer');

Object.defineProperty(exports, 'CanvasGraphicsRenderer', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_CanvasGraphicsRenderer).default;
  }
});

var _Spritesheet = require('./textures/Spritesheet');

Object.defineProperty(exports, 'Spritesheet', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Spritesheet).default;
  }
});

var _Texture = require('./textures/Texture');

Object.defineProperty(exports, 'Texture', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Texture).default;
  }
});

var _TextureMatrix = require('./textures/TextureMatrix');

Object.defineProperty(exports, 'TextureMatrix', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_TextureMatrix).default;
  }
});

var _BaseTexture = require('./textures/BaseTexture');

Object.defineProperty(exports, 'BaseTexture', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_BaseTexture).default;
  }
});

var _RenderTexture = require('./textures/RenderTexture');

Object.defineProperty(exports, 'RenderTexture', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_RenderTexture).default;
  }
});

var _BaseRenderTexture = require('./textures/BaseRenderTexture');

Object.defineProperty(exports, 'BaseRenderTexture', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_BaseRenderTexture).default;
  }
});

var _VideoBaseTexture = require('./textures/VideoBaseTexture');

Object.defineProperty(exports, 'VideoBaseTexture', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_VideoBaseTexture).default;
  }
});

var _TextureUvs = require('./textures/TextureUvs');

Object.defineProperty(exports, 'TextureUvs', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_TextureUvs).default;
  }
});

var _CanvasRenderTarget = require('./renderers/canvas/utils/CanvasRenderTarget');

Object.defineProperty(exports, 'CanvasRenderTarget', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_CanvasRenderTarget).default;
  }
});

var _Shader = require('./Shader');

Object.defineProperty(exports, 'Shader', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Shader).default;
  }
});

var _WebGLManager = require('./renderers/webgl/managers/WebGLManager');

Object.defineProperty(exports, 'WebGLManager', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_WebGLManager).default;
  }
});

var _ObjectRenderer = require('./renderers/webgl/utils/ObjectRenderer');

Object.defineProperty(exports, 'ObjectRenderer', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_ObjectRenderer).default;
  }
});

var _RenderTarget = require('./renderers/webgl/utils/RenderTarget');

Object.defineProperty(exports, 'RenderTarget', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_RenderTarget).default;
  }
});

var _Quad = require('./renderers/webgl/utils/Quad');

Object.defineProperty(exports, 'Quad', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Quad).default;
  }
});

var _SpriteMaskFilter = require('./renderers/webgl/filters/spriteMask/SpriteMaskFilter');

Object.defineProperty(exports, 'SpriteMaskFilter', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_SpriteMaskFilter).default;
  }
});

var _Filter = require('./renderers/webgl/filters/Filter');

Object.defineProperty(exports, 'Filter', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Filter).default;
  }
});

var _Application = require('./Application');

Object.defineProperty(exports, 'Application', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Application).default;
  }
});

var _autoDetectRenderer = require('./autoDetectRenderer');

Object.defineProperty(exports, 'autoDetectRenderer', {
  enumerable: true,
  get: function get() {
    return _autoDetectRenderer.autoDetectRenderer;
  }
});

var _utils = require('./utils');

var utils = _interopRequireWildcard(_utils);

var _ticker = require('./ticker');

var ticker = _interopRequireWildcard(_ticker);

var _settings = require('./settings');

var _settings2 = _interopRequireDefault(_settings);

var _CanvasRenderer = require('./renderers/canvas/CanvasRenderer');

var _CanvasRenderer2 = _interopRequireDefault(_CanvasRenderer);

var _WebGLRenderer = require('./renderers/webgl/WebGLRenderer');

var _WebGLRenderer2 = _interopRequireDefault(_WebGLRenderer);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.settings = _settings2.default;
exports.utils = utils;
exports.ticker = ticker;
exports.CanvasRenderer = _CanvasRenderer2.default;
exports.WebGLRenderer = _WebGLRenderer2.default; /**
                                                  * @namespace PIXI
                                                  */

},{"./Application":50,"./Shader":51,"./autoDetectRenderer":52,"./const":53,"./display/Bounds":54,"./display/Container":55,"./display/DisplayObject":56,"./display/Transform":57,"./display/TransformBase":58,"./display/TransformStatic":59,"./graphics/Graphics":60,"./graphics/GraphicsData":61,"./graphics/canvas/CanvasGraphicsRenderer":62,"./graphics/webgl/GraphicsRenderer":64,"./math":77,"./renderers/canvas/CanvasRenderer":84,"./renderers/canvas/utils/CanvasRenderTarget":86,"./renderers/webgl/WebGLRenderer":91,"./renderers/webgl/filters/Filter":93,"./renderers/webgl/filters/spriteMask/SpriteMaskFilter":96,"./renderers/webgl/managers/WebGLManager":100,"./renderers/webgl/utils/ObjectRenderer":101,"./renderers/webgl/utils/Quad":102,"./renderers/webgl/utils/RenderTarget":103,"./settings":108,"./sprites/Sprite":109,"./sprites/canvas/CanvasSpriteRenderer":110,"./sprites/canvas/CanvasTinter":111,"./sprites/webgl/SpriteRenderer":113,"./text/Text":115,"./text/TextMetrics":116,"./text/TextStyle":117,"./textures/BaseRenderTexture":118,"./textures/BaseTexture":119,"./textures/RenderTexture":120,"./textures/Spritesheet":121,"./textures/Texture":122,"./textures/TextureMatrix":123,"./textures/TextureUvs":124,"./textures/VideoBaseTexture":125,"./ticker":128,"./utils":132,"pixi-gl-core":36}],73:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _Matrix = require('./Matrix');

var _Matrix2 = _interopRequireDefault(_Matrix);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1]; // Your friendly neighbour https://en.wikipedia.org/wiki/Dihedral_group of order 16

var uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1];
var vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1];
var vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1];
var tempMatrices = [];

var mul = [];

function signum(x) {
    if (x < 0) {
        return -1;
    }
    if (x > 0) {
        return 1;
    }

    return 0;
}

function init() {
    for (var i = 0; i < 16; i++) {
        var row = [];

        mul.push(row);

        for (var j = 0; j < 16; j++) {
            var _ux = signum(ux[i] * ux[j] + vx[i] * uy[j]);
            var _uy = signum(uy[i] * ux[j] + vy[i] * uy[j]);
            var _vx = signum(ux[i] * vx[j] + vx[i] * vy[j]);
            var _vy = signum(uy[i] * vx[j] + vy[i] * vy[j]);

            for (var k = 0; k < 16; k++) {
                if (ux[k] === _ux && uy[k] === _uy && vx[k] === _vx && vy[k] === _vy) {
                    row.push(k);
                    break;
                }
            }
        }
    }

    for (var _i = 0; _i < 16; _i++) {
        var mat = new _Matrix2.default();

        mat.set(ux[_i], uy[_i], vx[_i], vy[_i], 0, 0);
        tempMatrices.push(mat);
    }
}

init();

/**
 * Implements Dihedral Group D_8, see [group D4]{@link http://mathworld.wolfram.com/DihedralGroupD4.html},
 * D8 is the same but with diagonals. Used for texture rotations.
 *
 * Vector xX(i), xY(i) is U-axis of sprite with rotation i
 * Vector yY(i), yY(i) is V-axis of sprite with rotation i
 * Rotations: 0 grad (0), 90 grad (2), 180 grad (4), 270 grad (6)
 * Mirrors: vertical (8), main diagonal (10), horizontal (12), reverse diagonal (14)
 * This is the small part of gameofbombs.com portal system. It works.
 *
 * @author Ivan @ivanpopelyshev
 * @class
 * @memberof PIXI
 */
var GroupD8 = {
    E: 0,
    SE: 1,
    S: 2,
    SW: 3,
    W: 4,
    NW: 5,
    N: 6,
    NE: 7,
    MIRROR_VERTICAL: 8,
    MIRROR_HORIZONTAL: 12,
    uX: function uX(ind) {
        return ux[ind];
    },
    uY: function uY(ind) {
        return uy[ind];
    },
    vX: function vX(ind) {
        return vx[ind];
    },
    vY: function vY(ind) {
        return vy[ind];
    },
    inv: function inv(rotation) {
        if (rotation & 8) {
            return rotation & 15;
        }

        return -rotation & 7;
    },
    add: function add(rotationSecond, rotationFirst) {
        return mul[rotationSecond][rotationFirst];
    },
    sub: function sub(rotationSecond, rotationFirst) {
        return mul[rotationSecond][GroupD8.inv(rotationFirst)];
    },

    /**
     * Adds 180 degrees to rotation. Commutative operation.
     *
     * @memberof PIXI.GroupD8
     * @param {number} rotation - The number to rotate.
     * @returns {number} rotated number
     */
    rotate180: function rotate180(rotation) {
        return rotation ^ 4;
    },

    /**
     * Direction of main vector can be horizontal, vertical or diagonal.
     * Some objects work with vertical directions different.
     *
     * @memberof PIXI.GroupD8
     * @param {number} rotation - The number to check.
     * @returns {boolean} Whether or not the direction is vertical
     */
    isVertical: function isVertical(rotation) {
        return (rotation & 3) === 2;
    },

    /**
     * @memberof PIXI.GroupD8
     * @param {number} dx - TODO
     * @param {number} dy - TODO
     *
     * @return {number} TODO
     */
    byDirection: function byDirection(dx, dy) {
        if (Math.abs(dx) * 2 <= Math.abs(dy)) {
            if (dy >= 0) {
                return GroupD8.S;
            }

            return GroupD8.N;
        } else if (Math.abs(dy) * 2 <= Math.abs(dx)) {
            if (dx > 0) {
                return GroupD8.E;
            }

            return GroupD8.W;
        } else if (dy > 0) {
            if (dx > 0) {
                return GroupD8.SE;
            }

            return GroupD8.SW;
        } else if (dx > 0) {
            return GroupD8.NE;
        }

        return GroupD8.NW;
    },

    /**
     * Helps sprite to compensate texture packer rotation.
     *
     * @memberof PIXI.GroupD8
     * @param {PIXI.Matrix} matrix - sprite world matrix
     * @param {number} rotation - The rotation factor to use.
     * @param {number} tx - sprite anchoring
     * @param {number} ty - sprite anchoring
     */
    matrixAppendRotationInv: function matrixAppendRotationInv(matrix, rotation) {
        var tx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var ty = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

        // Packer used "rotation", we use "inv(rotation)"
        var mat = tempMatrices[GroupD8.inv(rotation)];

        mat.tx = tx;
        mat.ty = ty;
        matrix.append(mat);
    }
};

exports.default = GroupD8;

},{"./Matrix":74}],74:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Point = require('./Point');

var _Point2 = _interopRequireDefault(_Point);

var _const = require('../const');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * The PixiJS Matrix class as an object, which makes it a lot faster,
 * here is a representation of it :
 * | a | c | tx|
 * | b | d | ty|
 * | 0 | 0 | 1 |
 *
 * @class
 * @memberof PIXI
 */
var Matrix = function () {
    /**
     * @param {number} [a=1] - x scale
     * @param {number} [b=0] - x skew
     * @param {number} [c=0] - y skew
     * @param {number} [d=1] - y scale
     * @param {number} [tx=0] - x translation
     * @param {number} [ty=0] - y translation
     */
    function Matrix() {
        var a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
        var b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var c = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var d = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
        var tx = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
        var ty = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;

        _classCallCheck(this, Matrix);

        /**
         * @member {number}
         * @default 1
         */
        this.a = a;

        /**
         * @member {number}
         * @default 0
         */
        this.b = b;

        /**
         * @member {number}
         * @default 0
         */
        this.c = c;

        /**
         * @member {number}
         * @default 1
         */
        this.d = d;

        /**
         * @member {number}
         * @default 0
         */
        this.tx = tx;

        /**
         * @member {number}
         * @default 0
         */
        this.ty = ty;

        this.array = null;
    }

    /**
     * Creates a Matrix object based on the given array. The Element to Matrix mapping order is as follows:
     *
     * a = array[0]
     * b = array[1]
     * c = array[3]
     * d = array[4]
     * tx = array[2]
     * ty = array[5]
     *
     * @param {number[]} array - The array that the matrix will be populated from.
     */


    Matrix.prototype.fromArray = function fromArray(array) {
        this.a = array[0];
        this.b = array[1];
        this.c = array[3];
        this.d = array[4];
        this.tx = array[2];
        this.ty = array[5];
    };

    /**
     * sets the matrix properties
     *
     * @param {number} a - Matrix component
     * @param {number} b - Matrix component
     * @param {number} c - Matrix component
     * @param {number} d - Matrix component
     * @param {number} tx - Matrix component
     * @param {number} ty - Matrix component
     *
     * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
     */


    Matrix.prototype.set = function set(a, b, c, d, tx, ty) {
        this.a = a;
        this.b = b;
        this.c = c;
        this.d = d;
        this.tx = tx;
        this.ty = ty;

        return this;
    };

    /**
     * Creates an array from the current Matrix object.
     *
     * @param {boolean} transpose - Whether we need to transpose the matrix or not
     * @param {Float32Array} [out=new Float32Array(9)] - If provided the array will be assigned to out
     * @return {number[]} the newly created array which contains the matrix
     */


    Matrix.prototype.toArray = function toArray(transpose, out) {
        if (!this.array) {
            this.array = new Float32Array(9);
        }

        var array = out || this.array;

        if (transpose) {
            array[0] = this.a;
            array[1] = this.b;
            array[2] = 0;
            array[3] = this.c;
            array[4] = this.d;
            array[5] = 0;
            array[6] = this.tx;
            array[7] = this.ty;
            array[8] = 1;
        } else {
            array[0] = this.a;
            array[1] = this.c;
            array[2] = this.tx;
            array[3] = this.b;
            array[4] = this.d;
            array[5] = this.ty;
            array[6] = 0;
            array[7] = 0;
            array[8] = 1;
        }

        return array;
    };

    /**
     * Get a new position with the current transformation applied.
     * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)
     *
     * @param {PIXI.Point} pos - The origin
     * @param {PIXI.Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)
     * @return {PIXI.Point} The new point, transformed through this matrix
     */


    Matrix.prototype.apply = function apply(pos, newPos) {
        newPos = newPos || new _Point2.default();

        var x = pos.x;
        var y = pos.y;

        newPos.x = this.a * x + this.c * y + this.tx;
        newPos.y = this.b * x + this.d * y + this.ty;

        return newPos;
    };

    /**
     * Get a new position with the inverse of the current transformation applied.
     * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)
     *
     * @param {PIXI.Point} pos - The origin
     * @param {PIXI.Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)
     * @return {PIXI.Point} The new point, inverse-transformed through this matrix
     */


    Matrix.prototype.applyInverse = function applyInverse(pos, newPos) {
        newPos = newPos || new _Point2.default();

        var id = 1 / (this.a * this.d + this.c * -this.b);

        var x = pos.x;
        var y = pos.y;

        newPos.x = this.d * id * x + -this.c * id * y + (this.ty * this.c - this.tx * this.d) * id;
        newPos.y = this.a * id * y + -this.b * id * x + (-this.ty * this.a + this.tx * this.b) * id;

        return newPos;
    };

    /**
     * Translates the matrix on the x and y.
     *
     * @param {number} x How much to translate x by
     * @param {number} y How much to translate y by
     * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
     */


    Matrix.prototype.translate = function translate(x, y) {
        this.tx += x;
        this.ty += y;

        return this;
    };

    /**
     * Applies a scale transformation to the matrix.
     *
     * @param {number} x The amount to scale horizontally
     * @param {number} y The amount to scale vertically
     * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
     */


    Matrix.prototype.scale = function scale(x, y) {
        this.a *= x;
        this.d *= y;
        this.c *= x;
        this.b *= y;
        this.tx *= x;
        this.ty *= y;

        return this;
    };

    /**
     * Applies a rotation transformation to the matrix.
     *
     * @param {number} angle - The angle in radians.
     * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
     */


    Matrix.prototype.rotate = function rotate(angle) {
        var cos = Math.cos(angle);
        var sin = Math.sin(angle);

        var a1 = this.a;
        var c1 = this.c;
        var tx1 = this.tx;

        this.a = a1 * cos - this.b * sin;
        this.b = a1 * sin + this.b * cos;
        this.c = c1 * cos - this.d * sin;
        this.d = c1 * sin + this.d * cos;
        this.tx = tx1 * cos - this.ty * sin;
        this.ty = tx1 * sin + this.ty * cos;

        return this;
    };

    /**
     * Appends the given Matrix to this Matrix.
     *
     * @param {PIXI.Matrix} matrix - The matrix to append.
     * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
     */


    Matrix.prototype.append = function append(matrix) {
        var a1 = this.a;
        var b1 = this.b;
        var c1 = this.c;
        var d1 = this.d;

        this.a = matrix.a * a1 + matrix.b * c1;
        this.b = matrix.a * b1 + matrix.b * d1;
        this.c = matrix.c * a1 + matrix.d * c1;
        this.d = matrix.c * b1 + matrix.d * d1;

        this.tx = matrix.tx * a1 + matrix.ty * c1 + this.tx;
        this.ty = matrix.tx * b1 + matrix.ty * d1 + this.ty;

        return this;
    };

    /**
     * Sets the matrix based on all the available properties
     *
     * @param {number} x - Position on the x axis
     * @param {number} y - Position on the y axis
     * @param {number} pivotX - Pivot on the x axis
     * @param {number} pivotY - Pivot on the y axis
     * @param {number} scaleX - Scale on the x axis
     * @param {number} scaleY - Scale on the y axis
     * @param {number} rotation - Rotation in radians
     * @param {number} skewX - Skew on the x axis
     * @param {number} skewY - Skew on the y axis
     * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
     */


    Matrix.prototype.setTransform = function setTransform(x, y, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY) {
        this.a = Math.cos(rotation + skewY) * scaleX;
        this.b = Math.sin(rotation + skewY) * scaleX;
        this.c = -Math.sin(rotation - skewX) * scaleY;
        this.d = Math.cos(rotation - skewX) * scaleY;

        this.tx = x - (pivotX * this.a + pivotY * this.c);
        this.ty = y - (pivotX * this.b + pivotY * this.d);

        return this;
    };

    /**
     * Prepends the given Matrix to this Matrix.
     *
     * @param {PIXI.Matrix} matrix - The matrix to prepend
     * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
     */


    Matrix.prototype.prepend = function prepend(matrix) {
        var tx1 = this.tx;

        if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1) {
            var a1 = this.a;
            var c1 = this.c;

            this.a = a1 * matrix.a + this.b * matrix.c;
            this.b = a1 * matrix.b + this.b * matrix.d;
            this.c = c1 * matrix.a + this.d * matrix.c;
            this.d = c1 * matrix.b + this.d * matrix.d;
        }

        this.tx = tx1 * matrix.a + this.ty * matrix.c + matrix.tx;
        this.ty = tx1 * matrix.b + this.ty * matrix.d + matrix.ty;

        return this;
    };

    /**
     * Decomposes the matrix (x, y, scaleX, scaleY, and rotation) and sets the properties on to a transform.
     *
     * @param {PIXI.Transform|PIXI.TransformStatic} transform - The transform to apply the properties to.
     * @return {PIXI.Transform|PIXI.TransformStatic} The transform with the newly applied properties
     */


    Matrix.prototype.decompose = function decompose(transform) {
        // sort out rotation / skew..
        var a = this.a;
        var b = this.b;
        var c = this.c;
        var d = this.d;

        var skewX = -Math.atan2(-c, d);
        var skewY = Math.atan2(b, a);

        var delta = Math.abs(skewX + skewY);

        if (delta < 0.00001 || Math.abs(_const.PI_2 - delta) < 0.00001) {
            transform.rotation = skewY;
            transform.skew.x = transform.skew.y = 0;
        } else {
            transform.rotation = 0;
            transform.skew.x = skewX;
            transform.skew.y = skewY;
        }

        // next set scale
        transform.scale.x = Math.sqrt(a * a + b * b);
        transform.scale.y = Math.sqrt(c * c + d * d);

        // next set position
        transform.position.x = this.tx;
        transform.position.y = this.ty;

        return transform;
    };

    /**
     * Inverts this matrix
     *
     * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
     */


    Matrix.prototype.invert = function invert() {
        var a1 = this.a;
        var b1 = this.b;
        var c1 = this.c;
        var d1 = this.d;
        var tx1 = this.tx;
        var n = a1 * d1 - b1 * c1;

        this.a = d1 / n;
        this.b = -b1 / n;
        this.c = -c1 / n;
        this.d = a1 / n;
        this.tx = (c1 * this.ty - d1 * tx1) / n;
        this.ty = -(a1 * this.ty - b1 * tx1) / n;

        return this;
    };

    /**
     * Resets this Matix to an identity (default) matrix.
     *
     * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
     */


    Matrix.prototype.identity = function identity() {
        this.a = 1;
        this.b = 0;
        this.c = 0;
        this.d = 1;
        this.tx = 0;
        this.ty = 0;

        return this;
    };

    /**
     * Creates a new Matrix object with the same values as this one.
     *
     * @return {PIXI.Matrix} A copy of this matrix. Good for chaining method calls.
     */


    Matrix.prototype.clone = function clone() {
        var matrix = new Matrix();

        matrix.a = this.a;
        matrix.b = this.b;
        matrix.c = this.c;
        matrix.d = this.d;
        matrix.tx = this.tx;
        matrix.ty = this.ty;

        return matrix;
    };

    /**
     * Changes the values of the given matrix to be the same as the ones in this matrix
     *
     * @param {PIXI.Matrix} matrix - The matrix to copy from.
     * @return {PIXI.Matrix} The matrix given in parameter with its values updated.
     */


    Matrix.prototype.copy = function copy(matrix) {
        matrix.a = this.a;
        matrix.b = this.b;
        matrix.c = this.c;
        matrix.d = this.d;
        matrix.tx = this.tx;
        matrix.ty = this.ty;

        return matrix;
    };

    /**
     * A default (identity) matrix
     *
     * @static
     * @const
     */


    _createClass(Matrix, null, [{
        key: 'IDENTITY',
        get: function get() {
            return new Matrix();
        }

        /**
         * A temp matrix
         *
         * @static
         * @const
         */

    }, {
        key: 'TEMP_MATRIX',
        get: function get() {
            return new Matrix();
        }
    }]);

    return Matrix;
}();

exports.default = Matrix;

},{"../const":53,"./Point":76}],75:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * The Point object represents a location in a two-dimensional coordinate system, where x represents
 * the horizontal axis and y represents the vertical axis.
 * An observable point is a point that triggers a callback when the point's position is changed.
 *
 * @class
 * @memberof PIXI
 */
var ObservablePoint = function () {
    /**
     * @param {Function} cb - callback when changed
     * @param {object} scope - owner of callback
     * @param {number} [x=0] - position of the point on the x axis
     * @param {number} [y=0] - position of the point on the y axis
     */
    function ObservablePoint(cb, scope) {
        var x = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var y = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

        _classCallCheck(this, ObservablePoint);

        this._x = x;
        this._y = y;

        this.cb = cb;
        this.scope = scope;
    }

    /**
     * Creates a clone of this point.
     * The callback and scope params can be overidden otherwise they will default
     * to the clone object's values.
     *
     * @override
     * @param {Function} [cb=null] - callback when changed
     * @param {object} [scope=null] - owner of callback
     * @return {PIXI.ObservablePoint} a copy of the point
     */


    ObservablePoint.prototype.clone = function clone() {
        var cb = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
        var scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

        var _cb = cb || this.cb;
        var _scope = scope || this.scope;

        return new ObservablePoint(_cb, _scope, this._x, this._y);
    };

    /**
     * Sets the point to a new x and y position.
     * If y is omitted, both x and y will be set to x.
     *
     * @param {number} [x=0] - position of the point on the x axis
     * @param {number} [y=0] - position of the point on the y axis
     */


    ObservablePoint.prototype.set = function set(x, y) {
        var _x = x || 0;
        var _y = y || (y !== 0 ? _x : 0);

        if (this._x !== _x || this._y !== _y) {
            this._x = _x;
            this._y = _y;
            this.cb.call(this.scope);
        }
    };

    /**
     * Copies the data from another point
     *
     * @param {PIXI.Point|PIXI.ObservablePoint} point - point to copy from
     */


    ObservablePoint.prototype.copy = function copy(point) {
        if (this._x !== point.x || this._y !== point.y) {
            this._x = point.x;
            this._y = point.y;
            this.cb.call(this.scope);
        }
    };

    /**
     * Returns true if the given point is equal to this point
     *
     * @param {PIXI.Point|PIXI.ObservablePoint} p - The point to check
     * @returns {boolean} Whether the given point equal to this point
     */


    ObservablePoint.prototype.equals = function equals(p) {
        return p.x === this._x && p.y === this._y;
    };

    /**
     * The position of the displayObject on the x axis relative to the local coordinates of the parent.
     *
     * @member {number}
     */


    _createClass(ObservablePoint, [{
        key: "x",
        get: function get() {
            return this._x;
        },
        set: function set(value) // eslint-disable-line require-jsdoc
        {
            if (this._x !== value) {
                this._x = value;
                this.cb.call(this.scope);
            }
        }

        /**
         * The position of the displayObject on the x axis relative to the local coordinates of the parent.
         *
         * @member {number}
         */

    }, {
        key: "y",
        get: function get() {
            return this._y;
        },
        set: function set(value) // eslint-disable-line require-jsdoc
        {
            if (this._y !== value) {
                this._y = value;
                this.cb.call(this.scope);
            }
        }
    }]);

    return ObservablePoint;
}();

exports.default = ObservablePoint;

},{}],76:[function(require,module,exports){
"use strict";

exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * The Point object represents a location in a two-dimensional coordinate system, where x represents
 * the horizontal axis and y represents the vertical axis.
 *
 * @class
 * @memberof PIXI
 */
var Point = function () {
  /**
   * @param {number} [x=0] - position of the point on the x axis
   * @param {number} [y=0] - position of the point on the y axis
   */
  function Point() {
    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

    _classCallCheck(this, Point);

    /**
     * @member {number}
     * @default 0
     */
    this.x = x;

    /**
     * @member {number}
     * @default 0
     */
    this.y = y;
  }

  /**
   * Creates a clone of this point
   *
   * @return {PIXI.Point} a copy of the point
   */


  Point.prototype.clone = function clone() {
    return new Point(this.x, this.y);
  };

  /**
   * Copies x and y from the given point
   *
   * @param {PIXI.Point} p - The point to copy.
   */


  Point.prototype.copy = function copy(p) {
    this.set(p.x, p.y);
  };

  /**
   * Returns true if the given point is equal to this point
   *
   * @param {PIXI.Point} p - The point to check
   * @returns {boolean} Whether the given point equal to this point
   */


  Point.prototype.equals = function equals(p) {
    return p.x === this.x && p.y === this.y;
  };

  /**
   * Sets the point to a new x and y position.
   * If y is omitted, both x and y will be set to x.
   *
   * @param {number} [x=0] - position of the point on the x axis
   * @param {number} [y=0] - position of the point on the y axis
   */


  Point.prototype.set = function set(x, y) {
    this.x = x || 0;
    this.y = y || (y !== 0 ? this.x : 0);
  };

  return Point;
}();

exports.default = Point;

},{}],77:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _Point = require('./Point');

Object.defineProperty(exports, 'Point', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Point).default;
  }
});

var _ObservablePoint = require('./ObservablePoint');

Object.defineProperty(exports, 'ObservablePoint', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_ObservablePoint).default;
  }
});

var _Matrix = require('./Matrix');

Object.defineProperty(exports, 'Matrix', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Matrix).default;
  }
});

var _GroupD = require('./GroupD8');

Object.defineProperty(exports, 'GroupD8', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_GroupD).default;
  }
});

var _Circle = require('./shapes/Circle');

Object.defineProperty(exports, 'Circle', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Circle).default;
  }
});

var _Ellipse = require('./shapes/Ellipse');

Object.defineProperty(exports, 'Ellipse', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Ellipse).default;
  }
});

var _Polygon = require('./shapes/Polygon');

Object.defineProperty(exports, 'Polygon', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Polygon).default;
  }
});

var _Rectangle = require('./shapes/Rectangle');

Object.defineProperty(exports, 'Rectangle', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Rectangle).default;
  }
});

var _RoundedRectangle = require('./shapes/RoundedRectangle');

Object.defineProperty(exports, 'RoundedRectangle', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_RoundedRectangle).default;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

},{"./GroupD8":73,"./Matrix":74,"./ObservablePoint":75,"./Point":76,"./shapes/Circle":78,"./shapes/Ellipse":79,"./shapes/Polygon":80,"./shapes/Rectangle":81,"./shapes/RoundedRectangle":82}],78:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _Rectangle = require('./Rectangle');

var _Rectangle2 = _interopRequireDefault(_Rectangle);

var _const = require('../../const');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * The Circle object can be used to specify a hit area for displayObjects
 *
 * @class
 * @memberof PIXI
 */
var Circle = function () {
  /**
   * @param {number} [x=0] - The X coordinate of the center of this circle
   * @param {number} [y=0] - The Y coordinate of the center of this circle
   * @param {number} [radius=0] - The radius of the circle
   */
  function Circle() {
    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var radius = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

    _classCallCheck(this, Circle);

    /**
     * @member {number}
     * @default 0
     */
    this.x = x;

    /**
     * @member {number}
     * @default 0
     */
    this.y = y;

    /**
     * @member {number}
     * @default 0
     */
    this.radius = radius;

    /**
     * The type of the object, mainly used to avoid `instanceof` checks
     *
     * @member {number}
     * @readOnly
     * @default PIXI.SHAPES.CIRC
     * @see PIXI.SHAPES
     */
    this.type = _const.SHAPES.CIRC;
  }

  /**
   * Creates a clone of this Circle instance
   *
   * @return {PIXI.Circle} a copy of the Circle
   */


  Circle.prototype.clone = function clone() {
    return new Circle(this.x, this.y, this.radius);
  };

  /**
   * Checks whether the x and y coordinates given are contained within this circle
   *
   * @param {number} x - The X coordinate of the point to test
   * @param {number} y - The Y coordinate of the point to test
   * @return {boolean} Whether the x/y coordinates are within this Circle
   */


  Circle.prototype.contains = function contains(x, y) {
    if (this.radius <= 0) {
      return false;
    }

    var r2 = this.radius * this.radius;
    var dx = this.x - x;
    var dy = this.y - y;

    dx *= dx;
    dy *= dy;

    return dx + dy <= r2;
  };

  /**
  * Returns the framing rectangle of the circle as a Rectangle object
  *
  * @return {PIXI.Rectangle} the framing rectangle
  */


  Circle.prototype.getBounds = function getBounds() {
    return new _Rectangle2.default(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);
  };

  return Circle;
}();

exports.default = Circle;

},{"../../const":53,"./Rectangle":81}],79:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _Rectangle = require('./Rectangle');

var _Rectangle2 = _interopRequireDefault(_Rectangle);

var _const = require('../../const');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * The Ellipse object can be used to specify a hit area for displayObjects
 *
 * @class
 * @memberof PIXI
 */
var Ellipse = function () {
  /**
   * @param {number} [x=0] - The X coordinate of the center of this ellipse
   * @param {number} [y=0] - The Y coordinate of the center of this ellipse
   * @param {number} [halfWidth=0] - The half width of this ellipse
   * @param {number} [halfHeight=0] - The half height of this ellipse
   */
  function Ellipse() {
    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var halfWidth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var halfHeight = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

    _classCallCheck(this, Ellipse);

    /**
     * @member {number}
     * @default 0
     */
    this.x = x;

    /**
     * @member {number}
     * @default 0
     */
    this.y = y;

    /**
     * @member {number}
     * @default 0
     */
    this.width = halfWidth;

    /**
     * @member {number}
     * @default 0
     */
    this.height = halfHeight;

    /**
     * The type of the object, mainly used to avoid `instanceof` checks
     *
     * @member {number}
     * @readOnly
     * @default PIXI.SHAPES.ELIP
     * @see PIXI.SHAPES
     */
    this.type = _const.SHAPES.ELIP;
  }

  /**
   * Creates a clone of this Ellipse instance
   *
   * @return {PIXI.Ellipse} a copy of the ellipse
   */


  Ellipse.prototype.clone = function clone() {
    return new Ellipse(this.x, this.y, this.width, this.height);
  };

  /**
   * Checks whether the x and y coordinates given are contained within this ellipse
   *
   * @param {number} x - The X coordinate of the point to test
   * @param {number} y - The Y coordinate of the point to test
   * @return {boolean} Whether the x/y coords are within this ellipse
   */


  Ellipse.prototype.contains = function contains(x, y) {
    if (this.width <= 0 || this.height <= 0) {
      return false;
    }

    // normalize the coords to an ellipse with center 0,0
    var normx = (x - this.x) / this.width;
    var normy = (y - this.y) / this.height;

    normx *= normx;
    normy *= normy;

    return normx + normy <= 1;
  };

  /**
   * Returns the framing rectangle of the ellipse as a Rectangle object
   *
   * @return {PIXI.Rectangle} the framing rectangle
   */


  Ellipse.prototype.getBounds = function getBounds() {
    return new _Rectangle2.default(this.x - this.width, this.y - this.height, this.width, this.height);
  };

  return Ellipse;
}();

exports.default = Ellipse;

},{"../../const":53,"./Rectangle":81}],80:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _Point = require('../Point');

var _Point2 = _interopRequireDefault(_Point);

var _const = require('../../const');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class
 * @memberof PIXI
 */
var Polygon = function () {
    /**
     * @param {PIXI.Point[]|number[]} points - This can be an array of Points
     *  that form the polygon, a flat array of numbers that will be interpreted as [x,y, x,y, ...], or
     *  the arguments passed can be all the points of the polygon e.g.
     *  `new PIXI.Polygon(new PIXI.Point(), new PIXI.Point(), ...)`, or the arguments passed can be flat
     *  x,y values e.g. `new Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are Numbers.
     */
    function Polygon() {
        for (var _len = arguments.length, points = Array(_len), _key = 0; _key < _len; _key++) {
            points[_key] = arguments[_key];
        }

        _classCallCheck(this, Polygon);

        if (Array.isArray(points[0])) {
            points = points[0];
        }

        // if this is an array of points, convert it to a flat array of numbers
        if (points[0] instanceof _Point2.default) {
            var p = [];

            for (var i = 0, il = points.length; i < il; i++) {
                p.push(points[i].x, points[i].y);
            }

            points = p;
        }

        this.closed = true;

        /**
         * An array of the points of this polygon
         *
         * @member {number[]}
         */
        this.points = points;

        /**
         * The type of the object, mainly used to avoid `instanceof` checks
         *
         * @member {number}
         * @readOnly
         * @default PIXI.SHAPES.POLY
         * @see PIXI.SHAPES
         */
        this.type = _const.SHAPES.POLY;
    }

    /**
     * Creates a clone of this polygon
     *
     * @return {PIXI.Polygon} a copy of the polygon
     */


    Polygon.prototype.clone = function clone() {
        return new Polygon(this.points.slice());
    };

    /**
     * Closes the polygon, adding points if necessary.
     *
     */


    Polygon.prototype.close = function close() {
        var points = this.points;

        // close the poly if the value is true!
        if (points[0] !== points[points.length - 2] || points[1] !== points[points.length - 1]) {
            points.push(points[0], points[1]);
        }
    };

    /**
     * Checks whether the x and y coordinates passed to this function are contained within this polygon
     *
     * @param {number} x - The X coordinate of the point to test
     * @param {number} y - The Y coordinate of the point to test
     * @return {boolean} Whether the x/y coordinates are within this polygon
     */


    Polygon.prototype.contains = function contains(x, y) {
        var inside = false;

        // use some raycasting to test hits
        // https://github.com/substack/point-in-polygon/blob/master/index.js
        var length = this.points.length / 2;

        for (var i = 0, j = length - 1; i < length; j = i++) {
            var xi = this.points[i * 2];
            var yi = this.points[i * 2 + 1];
            var xj = this.points[j * 2];
            var yj = this.points[j * 2 + 1];
            var intersect = yi > y !== yj > y && x < (xj - xi) * ((y - yi) / (yj - yi)) + xi;

            if (intersect) {
                inside = !inside;
            }
        }

        return inside;
    };

    return Polygon;
}();

exports.default = Polygon;

},{"../../const":53,"../Point":76}],81:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _const = require('../../const');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Rectangle object is an area defined by its position, as indicated by its top-left corner
 * point (x, y) and by its width and its height.
 *
 * @class
 * @memberof PIXI
 */
var Rectangle = function () {
  /**
   * @param {number} [x=0] - The X coordinate of the upper-left corner of the rectangle
   * @param {number} [y=0] - The Y coordinate of the upper-left corner of the rectangle
   * @param {number} [width=0] - The overall width of this rectangle
   * @param {number} [height=0] - The overall height of this rectangle
   */
  function Rectangle() {
    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var width = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var height = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

    _classCallCheck(this, Rectangle);

    /**
     * @member {number}
     * @default 0
     */
    this.x = Number(x);

    /**
     * @member {number}
     * @default 0
     */
    this.y = Number(y);

    /**
     * @member {number}
     * @default 0
     */
    this.width = Number(width);

    /**
     * @member {number}
     * @default 0
     */
    this.height = Number(height);

    /**
     * The type of the object, mainly used to avoid `instanceof` checks
     *
     * @member {number}
     * @readOnly
     * @default PIXI.SHAPES.RECT
     * @see PIXI.SHAPES
     */
    this.type = _const.SHAPES.RECT;
  }

  /**
   * returns the left edge of the rectangle
   *
   * @member {number}
   */


  /**
   * Creates a clone of this Rectangle
   *
   * @return {PIXI.Rectangle} a copy of the rectangle
   */
  Rectangle.prototype.clone = function clone() {
    return new Rectangle(this.x, this.y, this.width, this.height);
  };

  /**
   * Copies another rectangle to this one.
   *
   * @param {PIXI.Rectangle} rectangle - The rectangle to copy.
   * @return {PIXI.Rectangle} Returns itself.
   */


  Rectangle.prototype.copy = function copy(rectangle) {
    this.x = rectangle.x;
    this.y = rectangle.y;
    this.width = rectangle.width;
    this.height = rectangle.height;

    return this;
  };

  /**
   * Checks whether the x and y coordinates given are contained within this Rectangle
   *
   * @param {number} x - The X coordinate of the point to test
   * @param {number} y - The Y coordinate of the point to test
   * @return {boolean} Whether the x/y coordinates are within this Rectangle
   */


  Rectangle.prototype.contains = function contains(x, y) {
    if (this.width <= 0 || this.height <= 0) {
      return false;
    }

    if (x >= this.x && x < this.x + this.width) {
      if (y >= this.y && y < this.y + this.height) {
        return true;
      }
    }

    return false;
  };

  /**
   * Pads the rectangle making it grow in all directions.
   *
   * @param {number} paddingX - The horizontal padding amount.
   * @param {number} [paddingY] - The vertical padding amount.
   */


  Rectangle.prototype.pad = function pad(paddingX, paddingY) {
    paddingX = paddingX || 0;
    paddingY = paddingY || (paddingY !== 0 ? paddingX : 0);

    this.x -= paddingX;
    this.y -= paddingY;

    this.width += paddingX * 2;
    this.height += paddingY * 2;
  };

  /**
   * Fits this rectangle around the passed one.
   *
   * @param {PIXI.Rectangle} rectangle - The rectangle to fit.
   */


  Rectangle.prototype.fit = function fit(rectangle) {
    var x1 = Math.max(this.x, rectangle.x);
    var x2 = Math.min(this.x + this.width, rectangle.x + rectangle.width);
    var y1 = Math.max(this.y, rectangle.y);
    var y2 = Math.min(this.y + this.height, rectangle.y + rectangle.height);

    this.x = x1;
    this.width = Math.max(x2 - x1, 0);
    this.y = y1;
    this.height = Math.max(y2 - y1, 0);
  };

  /**
   * Enlarges this rectangle to include the passed rectangle.
   *
   * @param {PIXI.Rectangle} rectangle - The rectangle to include.
   */


  Rectangle.prototype.enlarge = function enlarge(rectangle) {
    var x1 = Math.min(this.x, rectangle.x);
    var x2 = Math.max(this.x + this.width, rectangle.x + rectangle.width);
    var y1 = Math.min(this.y, rectangle.y);
    var y2 = Math.max(this.y + this.height, rectangle.y + rectangle.height);

    this.x = x1;
    this.width = x2 - x1;
    this.y = y1;
    this.height = y2 - y1;
  };

  /**
   * Enlarges rectangle that way its corners lie on grid
   *
   * @param {number} [resolution=1] resolution
   * @param {number} [eps=0.001] precision
   */


  Rectangle.prototype.ceil = function ceil() {
    var resolution = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    var eps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.001;

    var x2 = Math.ceil((this.x + this.width - eps) * resolution) / resolution;
    var y2 = Math.ceil((this.y + this.height - eps) * resolution) / resolution;

    this.x = Math.floor((this.x + eps) * resolution) / resolution;
    this.y = Math.floor((this.y + eps) * resolution) / resolution;

    this.width = x2 - this.x;
    this.height = y2 - this.y;
  };

  _createClass(Rectangle, [{
    key: 'left',
    get: function get() {
      return this.x;
    }

    /**
     * returns the right edge of the rectangle
     *
     * @member {number}
     */

  }, {
    key: 'right',
    get: function get() {
      return this.x + this.width;
    }

    /**
     * returns the top edge of the rectangle
     *
     * @member {number}
     */

  }, {
    key: 'top',
    get: function get() {
      return this.y;
    }

    /**
     * returns the bottom edge of the rectangle
     *
     * @member {number}
     */

  }, {
    key: 'bottom',
    get: function get() {
      return this.y + this.height;
    }

    /**
     * A constant empty rectangle.
     *
     * @static
     * @constant
     */

  }], [{
    key: 'EMPTY',
    get: function get() {
      return new Rectangle(0, 0, 0, 0);
    }
  }]);

  return Rectangle;
}();

exports.default = Rectangle;

},{"../../const":53}],82:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _const = require('../../const');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * The Rounded Rectangle object is an area that has nice rounded corners, as indicated by its
 * top-left corner point (x, y) and by its width and its height and its radius.
 *
 * @class
 * @memberof PIXI
 */
var RoundedRectangle = function () {
    /**
     * @param {number} [x=0] - The X coordinate of the upper-left corner of the rounded rectangle
     * @param {number} [y=0] - The Y coordinate of the upper-left corner of the rounded rectangle
     * @param {number} [width=0] - The overall width of this rounded rectangle
     * @param {number} [height=0] - The overall height of this rounded rectangle
     * @param {number} [radius=20] - Controls the radius of the rounded corners
     */
    function RoundedRectangle() {
        var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var width = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var height = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
        var radius = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 20;

        _classCallCheck(this, RoundedRectangle);

        /**
         * @member {number}
         * @default 0
         */
        this.x = x;

        /**
         * @member {number}
         * @default 0
         */
        this.y = y;

        /**
         * @member {number}
         * @default 0
         */
        this.width = width;

        /**
         * @member {number}
         * @default 0
         */
        this.height = height;

        /**
         * @member {number}
         * @default 20
         */
        this.radius = radius;

        /**
         * The type of the object, mainly used to avoid `instanceof` checks
         *
         * @member {number}
         * @readonly
         * @default PIXI.SHAPES.RREC
         * @see PIXI.SHAPES
         */
        this.type = _const.SHAPES.RREC;
    }

    /**
     * Creates a clone of this Rounded Rectangle
     *
     * @return {PIXI.RoundedRectangle} a copy of the rounded rectangle
     */


    RoundedRectangle.prototype.clone = function clone() {
        return new RoundedRectangle(this.x, this.y, this.width, this.height, this.radius);
    };

    /**
     * Checks whether the x and y coordinates given are contained within this Rounded Rectangle
     *
     * @param {number} x - The X coordinate of the point to test
     * @param {number} y - The Y coordinate of the point to test
     * @return {boolean} Whether the x/y coordinates are within this Rounded Rectangle
     */


    RoundedRectangle.prototype.contains = function contains(x, y) {
        if (this.width <= 0 || this.height <= 0) {
            return false;
        }
        if (x >= this.x && x <= this.x + this.width) {
            if (y >= this.y && y <= this.y + this.height) {
                if (y >= this.y + this.radius && y <= this.y + this.height - this.radius || x >= this.x + this.radius && x <= this.x + this.width - this.radius) {
                    return true;
                }
                var dx = x - (this.x + this.radius);
                var dy = y - (this.y + this.radius);
                var radius2 = this.radius * this.radius;

                if (dx * dx + dy * dy <= radius2) {
                    return true;
                }
                dx = x - (this.x + this.width - this.radius);
                if (dx * dx + dy * dy <= radius2) {
                    return true;
                }
                dy = y - (this.y + this.height - this.radius);
                if (dx * dx + dy * dy <= radius2) {
                    return true;
                }
                dx = x - (this.x + this.radius);
                if (dx * dx + dy * dy <= radius2) {
                    return true;
                }
            }
        }

        return false;
    };

    return RoundedRectangle;
}();

exports.default = RoundedRectangle;

},{"../../const":53}],83:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _utils = require('../utils');

var _math = require('../math');

var _const = require('../const');

var _settings = require('../settings');

var _settings2 = _interopRequireDefault(_settings);

var _Container = require('../display/Container');

var _Container2 = _interopRequireDefault(_Container);

var _RenderTexture = require('../textures/RenderTexture');

var _RenderTexture2 = _interopRequireDefault(_RenderTexture);

var _eventemitter = require('eventemitter3');

var _eventemitter2 = _interopRequireDefault(_eventemitter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var tempMatrix = new _math.Matrix();

/**
 * The SystemRenderer is the base for a PixiJS Renderer. It is extended by the {@link PIXI.CanvasRenderer}
 * and {@link PIXI.WebGLRenderer} which can be used for rendering a PixiJS scene.
 *
 * @abstract
 * @class
 * @extends EventEmitter
 * @memberof PIXI
 */

var SystemRenderer = function (_EventEmitter) {
  _inherits(SystemRenderer, _EventEmitter);

  // eslint-disable-next-line valid-jsdoc
  /**
   * @param {string} system - The name of the system this renderer is for.
   * @param {object} [options] - The optional renderer parameters
   * @param {number} [options.width=800] - the width of the screen
   * @param {number} [options.height=600] - the height of the screen
   * @param {HTMLCanvasElement} [options.view] - the canvas to use as a view, optional
   * @param {boolean} [options.transparent=false] - If the render view is transparent, default false
   * @param {boolean} [options.autoResize=false] - If the render view is automatically resized, default false
   * @param {boolean} [options.antialias=false] - sets antialias (only applicable in chrome at the moment)
   * @param {number} [options.resolution=1] - The resolution / device pixel ratio of the renderer. The
   *  resolution of the renderer retina would be 2.
   * @param {boolean} [options.preserveDrawingBuffer=false] - enables drawing buffer preservation,
   *  enable this if you need to call toDataUrl on the webgl context.
   * @param {boolean} [options.clearBeforeRender=true] - This sets if the renderer will clear the canvas or
   *      not before the new render pass.
   * @param {number} [options.backgroundColor=0x000000] - The background color of the rendered area
   *  (shown if not transparent).
   * @param {boolean} [options.roundPixels=false] - If true PixiJS will Math.floor() x/y values when rendering,
   *  stopping pixel interpolation.
   */
  function SystemRenderer(system, options, arg2, arg3) {
    _classCallCheck(this, SystemRenderer);

    var _this = _possibleConstructorReturn(this, _EventEmitter.call(this));

    (0, _utils.sayHello)(system);

    // Support for constructor(system, screenWidth, screenHeight, options)
    if (typeof options === 'number') {
      options = Object.assign({
        width: options,
        height: arg2 || _settings2.default.RENDER_OPTIONS.height
      }, arg3);
    }

    // Add the default render options
    options = Object.assign({}, _settings2.default.RENDER_OPTIONS, options);

    /**
     * The supplied constructor options.
     *
     * @member {Object}
     * @readOnly
     */
    _this.options = options;

    /**
     * The type of the renderer.
     *
     * @member {number}
     * @default PIXI.RENDERER_TYPE.UNKNOWN
     * @see PIXI.RENDERER_TYPE
     */
    _this.type = _const.RENDERER_TYPE.UNKNOWN;

    /**
     * Measurements of the screen. (0, 0, screenWidth, screenHeight)
     *
     * Its safe to use as filterArea or hitArea for whole stage
     *
     * @member {PIXI.Rectangle}
     */
    _this.screen = new _math.Rectangle(0, 0, options.width, options.height);

    /**
     * The canvas element that everything is drawn to
     *
     * @member {HTMLCanvasElement}
     */
    _this.view = options.view || document.createElement('canvas');

    /**
     * The resolution / device pixel ratio of the renderer
     *
     * @member {number}
     * @default 1
     */
    _this.resolution = options.resolution || _settings2.default.RESOLUTION;

    /**
     * Whether the render view is transparent
     *
     * @member {boolean}
     */
    _this.transparent = options.transparent;

    /**
     * Whether css dimensions of canvas view should be resized to screen dimensions automatically
     *
     * @member {boolean}
     */
    _this.autoResize = options.autoResize || false;

    /**
     * Tracks the blend modes useful for this renderer.
     *
     * @member {object<string, mixed>}
     */
    _this.blendModes = null;

    /**
     * The value of the preserveDrawingBuffer flag affects whether or not the contents of
     * the stencil buffer is retained after rendering.
     *
     * @member {boolean}
     */
    _this.preserveDrawingBuffer = options.preserveDrawingBuffer;

    /**
     * This sets if the CanvasRenderer will clear the canvas or not before the new render pass.
     * If the scene is NOT transparent PixiJS will use a canvas sized fillRect operation every
     * frame to set the canvas background color. If the scene is transparent PixiJS will use clearRect
     * to clear the canvas every frame. Disable this by setting this to false. For example if
     * your game has a canvas filling background image you often don't need this set.
     *
     * @member {boolean}
     * @default
     */
    _this.clearBeforeRender = options.clearBeforeRender;

    /**
     * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.
     * Handy for crisp pixel art and speed on legacy devices.
     *
     * @member {boolean}
     */
    _this.roundPixels = options.roundPixels;

    /**
     * The background color as a number.
     *
     * @member {number}
     * @private
     */
    _this._backgroundColor = 0x000000;

    /**
     * The background color as an [R, G, B] array.
     *
     * @member {number[]}
     * @private
     */
    _this._backgroundColorRgba = [0, 0, 0, 0];

    /**
     * The background color as a string.
     *
     * @member {string}
     * @private
     */
    _this._backgroundColorString = '#000000';

    _this.backgroundColor = options.backgroundColor || _this._backgroundColor; // run bg color setter

    /**
     * This temporary display object used as the parent of the currently being rendered item
     *
     * @member {PIXI.DisplayObject}
     * @private
     */
    _this._tempDisplayObjectParent = new _Container2.default();

    /**
     * The last root object that the renderer tried to render.
     *
     * @member {PIXI.DisplayObject}
     * @private
     */
    _this._lastObjectRendered = _this._tempDisplayObjectParent;
    return _this;
  }

  /**
   * Same as view.width, actual number of pixels in the canvas by horizontal
   *
   * @member {number}
   * @readonly
   * @default 800
   */


  /**
   * Resizes the screen and canvas to the specified width and height
   * Canvas dimensions are multiplied by resolution
   *
   * @param {number} screenWidth - the new width of the screen
   * @param {number} screenHeight - the new height of the screen
   */
  SystemRenderer.prototype.resize = function resize(screenWidth, screenHeight) {
    this.screen.width = screenWidth;
    this.screen.height = screenHeight;

    this.view.width = screenWidth * this.resolution;
    this.view.height = screenHeight * this.resolution;

    if (this.autoResize) {
      this.view.style.width = screenWidth + 'px';
      this.view.style.height = screenHeight + 'px';
    }
  };

  /**
   * Useful function that returns a texture of the display object that can then be used to create sprites
   * This can be quite useful if your displayObject is complicated and needs to be reused multiple times.
   *
   * @param {PIXI.DisplayObject} displayObject - The displayObject the object will be generated from
   * @param {number} scaleMode - Should be one of the scaleMode consts
   * @param {number} resolution - The resolution / device pixel ratio of the texture being generated
   * @param {PIXI.Rectangle} [region] - The region of the displayObject, that shall be rendered,
   *        if no region is specified, defaults to the local bounds of the displayObject.
   * @return {PIXI.Texture} a texture of the graphics object
   */


  SystemRenderer.prototype.generateTexture = function generateTexture(displayObject, scaleMode, resolution, region) {
    region = region || displayObject.getLocalBounds();

    var renderTexture = _RenderTexture2.default.create(region.width | 0, region.height | 0, scaleMode, resolution);

    tempMatrix.tx = -region.x;
    tempMatrix.ty = -region.y;

    this.render(displayObject, renderTexture, false, tempMatrix, !!displayObject.parent);

    return renderTexture;
  };

  /**
   * Removes everything from the renderer and optionally removes the Canvas DOM element.
   *
   * @param {boolean} [removeView=false] - Removes the Canvas element from the DOM.
   */


  SystemRenderer.prototype.destroy = function destroy(removeView) {
    if (removeView && this.view.parentNode) {
      this.view.parentNode.removeChild(this.view);
    }

    this.type = _const.RENDERER_TYPE.UNKNOWN;

    this.view = null;

    this.screen = null;

    this.resolution = 0;

    this.transparent = false;

    this.autoResize = false;

    this.blendModes = null;

    this.options = null;

    this.preserveDrawingBuffer = false;
    this.clearBeforeRender = false;

    this.roundPixels = false;

    this._backgroundColor = 0;
    this._backgroundColorRgba = null;
    this._backgroundColorString = null;

    this._tempDisplayObjectParent = null;
    this._lastObjectRendered = null;
  };

  /**
   * The background color to fill if not transparent
   *
   * @member {number}
   */


  _createClass(SystemRenderer, [{
    key: 'width',
    get: function get() {
      return this.view.width;
    }

    /**
     * Same as view.height, actual number of pixels in the canvas by vertical
     *
     * @member {number}
     * @readonly
     * @default 600
     */

  }, {
    key: 'height',
    get: function get() {
      return this.view.height;
    }
  }, {
    key: 'backgroundColor',
    get: function get() {
      return this._backgroundColor;
    },
    set: function set(value) // eslint-disable-line require-jsdoc
    {
      this._backgroundColor = value;
      this._backgroundColorString = (0, _utils.hex2string)(value);
      (0, _utils.hex2rgb)(value, this._backgroundColorRgba);
    }
  }]);

  return SystemRenderer;
}(_eventemitter2.default);

exports.default = SystemRenderer;

},{"../const":53,"../display/Container":55,"../math":77,"../settings":108,"../textures/RenderTexture":120,"../utils":132,"eventemitter3":24}],84:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _SystemRenderer2 = require('../SystemRenderer');

var _SystemRenderer3 = _interopRequireDefault(_SystemRenderer2);

var _CanvasMaskManager = require('./utils/CanvasMaskManager');

var _CanvasMaskManager2 = _interopRequireDefault(_CanvasMaskManager);

var _CanvasRenderTarget = require('./utils/CanvasRenderTarget');

var _CanvasRenderTarget2 = _interopRequireDefault(_CanvasRenderTarget);

var _mapCanvasBlendModesToPixi = require('./utils/mapCanvasBlendModesToPixi');

var _mapCanvasBlendModesToPixi2 = _interopRequireDefault(_mapCanvasBlendModesToPixi);

var _utils = require('../../utils');

var _const = require('../../const');

var _settings = require('../../settings');

var _settings2 = _interopRequireDefault(_settings);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The CanvasRenderer draws the scene and all its content onto a 2d canvas. This renderer should
 * be used for browsers that do not support WebGL. Don't forget to add the CanvasRenderer.view to
 * your DOM or you will not see anything :)
 *
 * @class
 * @memberof PIXI
 * @extends PIXI.SystemRenderer
 */
var CanvasRenderer = function (_SystemRenderer) {
    _inherits(CanvasRenderer, _SystemRenderer);

    // eslint-disable-next-line valid-jsdoc
    /**
     * @param {object} [options] - The optional renderer parameters
     * @param {number} [options.width=800] - the width of the screen
     * @param {number} [options.height=600] - the height of the screen
     * @param {HTMLCanvasElement} [options.view] - the canvas to use as a view, optional
     * @param {boolean} [options.transparent=false] - If the render view is transparent, default false
     * @param {boolean} [options.autoResize=false] - If the render view is automatically resized, default false
     * @param {boolean} [options.antialias=false] - sets antialias (only applicable in chrome at the moment)
     * @param {number} [options.resolution=1] - The resolution / device pixel ratio of the renderer. The
     *  resolution of the renderer retina would be 2.
     * @param {boolean} [options.preserveDrawingBuffer=false] - enables drawing buffer preservation,
     *  enable this if you need to call toDataUrl on the webgl context.
     * @param {boolean} [options.clearBeforeRender=true] - This sets if the renderer will clear the canvas or
     *      not before the new render pass.
     * @param {number} [options.backgroundColor=0x000000] - The background color of the rendered area
     *  (shown if not transparent).
     * @param {boolean} [options.roundPixels=false] - If true PixiJS will Math.floor() x/y values when rendering,
     *  stopping pixel interpolation.
     */
    function CanvasRenderer(options, arg2, arg3) {
        _classCallCheck(this, CanvasRenderer);

        var _this = _possibleConstructorReturn(this, _SystemRenderer.call(this, 'Canvas', options, arg2, arg3));

        _this.type = _const.RENDERER_TYPE.CANVAS;

        /**
         * The root canvas 2d context that everything is drawn with.
         *
         * @member {CanvasRenderingContext2D}
         */
        _this.rootContext = _this.view.getContext('2d', { alpha: _this.transparent });

        /**
         * The currently active canvas 2d context (could change with renderTextures)
         *
         * @member {CanvasRenderingContext2D}
         */
        _this.context = _this.rootContext;

        /**
         * Boolean flag controlling canvas refresh.
         *
         * @member {boolean}
         */
        _this.refresh = true;

        /**
         * Instance of a CanvasMaskManager, handles masking when using the canvas renderer.
         *
         * @member {PIXI.CanvasMaskManager}
         */
        _this.maskManager = new _CanvasMaskManager2.default(_this);

        /**
         * The canvas property used to set the canvas smoothing property.
         *
         * @member {string}
         */
        _this.smoothProperty = 'imageSmoothingEnabled';

        if (!_this.rootContext.imageSmoothingEnabled) {
            if (_this.rootContext.webkitImageSmoothingEnabled) {
                _this.smoothProperty = 'webkitImageSmoothingEnabled';
            } else if (_this.rootContext.mozImageSmoothingEnabled) {
                _this.smoothProperty = 'mozImageSmoothingEnabled';
            } else if (_this.rootContext.oImageSmoothingEnabled) {
                _this.smoothProperty = 'oImageSmoothingEnabled';
            } else if (_this.rootContext.msImageSmoothingEnabled) {
                _this.smoothProperty = 'msImageSmoothingEnabled';
            }
        }

        _this.initPlugins();

        _this.blendModes = (0, _mapCanvasBlendModesToPixi2.default)();
        _this._activeBlendMode = null;

        _this.renderingToScreen = false;

        _this.resize(_this.options.width, _this.options.height);

        /**
         * Fired after rendering finishes.
         *
         * @event PIXI.CanvasRenderer#postrender
         */

        /**
         * Fired before rendering starts.
         *
         * @event PIXI.CanvasRenderer#prerender
         */
        return _this;
    }

    /**
     * Renders the object to this canvas view
     *
     * @param {PIXI.DisplayObject} displayObject - The object to be rendered
     * @param {PIXI.RenderTexture} [renderTexture] - A render texture to be rendered to.
     *  If unset, it will render to the root context.
     * @param {boolean} [clear=false] - Whether to clear the canvas before drawing
     * @param {PIXI.Matrix} [transform] - A transformation to be applied
     * @param {boolean} [skipUpdateTransform=false] - Whether to skip the update transform
     */


    CanvasRenderer.prototype.render = function render(displayObject, renderTexture, clear, transform, skipUpdateTransform) {
        if (!this.view) {
            return;
        }

        // can be handy to know!
        this.renderingToScreen = !renderTexture;

        this.emit('prerender');

        var rootResolution = this.resolution;

        if (renderTexture) {
            renderTexture = renderTexture.baseTexture || renderTexture;

            if (!renderTexture._canvasRenderTarget) {
                renderTexture._canvasRenderTarget = new _CanvasRenderTarget2.default(renderTexture.width, renderTexture.height, renderTexture.resolution);
                renderTexture.source = renderTexture._canvasRenderTarget.canvas;
                renderTexture.valid = true;
            }

            this.context = renderTexture._canvasRenderTarget.context;
            this.resolution = renderTexture._canvasRenderTarget.resolution;
        } else {
            this.context = this.rootContext;
        }

        var context = this.context;

        if (!renderTexture) {
            this._lastObjectRendered = displayObject;
        }

        if (!skipUpdateTransform) {
            // update the scene graph
            var cacheParent = displayObject.parent;
            var tempWt = this._tempDisplayObjectParent.transform.worldTransform;

            if (transform) {
                transform.copy(tempWt);

                // lets not forget to flag the parent transform as dirty...
                this._tempDisplayObjectParent.transform._worldID = -1;
            } else {
                tempWt.identity();
            }

            displayObject.parent = this._tempDisplayObjectParent;

            displayObject.updateTransform();
            displayObject.parent = cacheParent;
            // displayObject.hitArea = //TODO add a temp hit area
        }

        context.save();
        context.setTransform(1, 0, 0, 1, 0, 0);
        context.globalAlpha = 1;
        this._activeBlendMode = _const.BLEND_MODES.NORMAL;
        context.globalCompositeOperation = this.blendModes[_const.BLEND_MODES.NORMAL];

        if (navigator.isCocoonJS && this.view.screencanvas) {
            context.fillStyle = 'black';
            context.clear();
        }

        if (clear !== undefined ? clear : this.clearBeforeRender) {
            if (this.renderingToScreen) {
                if (this.transparent) {
                    context.clearRect(0, 0, this.width, this.height);
                } else {
                    context.fillStyle = this._backgroundColorString;
                    context.fillRect(0, 0, this.width, this.height);
                }
            } // else {
            // TODO: implement background for CanvasRenderTarget or RenderTexture?
            // }
        }

        // TODO RENDER TARGET STUFF HERE..
        var tempContext = this.context;

        this.context = context;
        displayObject.renderCanvas(this);
        this.context = tempContext;

        context.restore();

        this.resolution = rootResolution;

        this.emit('postrender');
    };

    /**
     * Clear the canvas of renderer.
     *
     * @param {string} [clearColor] - Clear the canvas with this color, except the canvas is transparent.
     */


    CanvasRenderer.prototype.clear = function clear(clearColor) {
        var context = this.context;

        clearColor = clearColor || this._backgroundColorString;

        if (!this.transparent && clearColor) {
            context.fillStyle = clearColor;
            context.fillRect(0, 0, this.width, this.height);
        } else {
            context.clearRect(0, 0, this.width, this.height);
        }
    };

    /**
     * Sets the blend mode of the renderer.
     *
     * @param {number} blendMode - See {@link PIXI.BLEND_MODES} for valid values.
     */


    CanvasRenderer.prototype.setBlendMode = function setBlendMode(blendMode) {
        if (this._activeBlendMode === blendMode) {
            return;
        }

        this._activeBlendMode = blendMode;
        this.context.globalCompositeOperation = this.blendModes[blendMode];
    };

    /**
     * Removes everything from the renderer and optionally removes the Canvas DOM element.
     *
     * @param {boolean} [removeView=false] - Removes the Canvas element from the DOM.
     */


    CanvasRenderer.prototype.destroy = function destroy(removeView) {
        this.destroyPlugins();

        // call the base destroy
        _SystemRenderer.prototype.destroy.call(this, removeView);

        this.context = null;

        this.refresh = true;

        this.maskManager.destroy();
        this.maskManager = null;

        this.smoothProperty = null;
    };

    /**
     * Resizes the canvas view to the specified width and height.
     *
     * @extends PIXI.SystemRenderer#resize
     *
     * @param {number} screenWidth - the new width of the screen
     * @param {number} screenHeight - the new height of the screen
     */


    CanvasRenderer.prototype.resize = function resize(screenWidth, screenHeight) {
        _SystemRenderer.prototype.resize.call(this, screenWidth, screenHeight);

        // reset the scale mode.. oddly this seems to be reset when the canvas is resized.
        // surely a browser bug?? Let PixiJS fix that for you..
        if (this.smoothProperty) {
            this.rootContext[this.smoothProperty] = _settings2.default.SCALE_MODE === _const.SCALE_MODES.LINEAR;
        }
    };

    /**
     * Checks if blend mode has changed.
     */


    CanvasRenderer.prototype.invalidateBlendMode = function invalidateBlendMode() {
        this._activeBlendMode = this.blendModes.indexOf(this.context.globalCompositeOperation);
    };

    return CanvasRenderer;
}(_SystemRenderer3.default);

/**
 * Collection of installed plugins. These are included by default in PIXI, but can be excluded
 * by creating a custom build. Consult the README for more information about creating custom
 * builds and excluding plugins.
 * @name PIXI.CanvasRenderer#plugins
 * @type {object}
 * @readonly
 * @property {PIXI.accessibility.AccessibilityManager} accessibility Support tabbing interactive elements.
 * @property {PIXI.extract.CanvasExtract} extract Extract image data from renderer.
 * @property {PIXI.interaction.InteractionManager} interaction Handles mouse, touch and pointer events.
 * @property {PIXI.prepare.CanvasPrepare} prepare Pre-render display objects.
 */

/**
 * Adds a plugin to the renderer.
 *
 * @method PIXI.CanvasRenderer#registerPlugin
 * @param {string} pluginName - The name of the plugin.
 * @param {Function} ctor - The constructor function or class for the plugin.
 */

exports.default = CanvasRenderer;
_utils.pluginTarget.mixin(CanvasRenderer);

},{"../../const":53,"../../settings":108,"../../utils":132,"../SystemRenderer":83,"./utils/CanvasMaskManager":85,"./utils/CanvasRenderTarget":86,"./utils/mapCanvasBlendModesToPixi":88}],85:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _const = require('../../../const');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * A set of functions used to handle masking.
 *
 * @class
 * @memberof PIXI
 */
var CanvasMaskManager = function () {
    /**
     * @param {PIXI.CanvasRenderer} renderer - The canvas renderer.
     */
    function CanvasMaskManager(renderer) {
        _classCallCheck(this, CanvasMaskManager);

        this.renderer = renderer;
    }

    /**
     * This method adds it to the current stack of masks.
     *
     * @param {object} maskData - the maskData that will be pushed
     */


    CanvasMaskManager.prototype.pushMask = function pushMask(maskData) {
        var renderer = this.renderer;

        renderer.context.save();

        var cacheAlpha = maskData.alpha;
        var transform = maskData.transform.worldTransform;
        var resolution = renderer.resolution;

        renderer.context.setTransform(transform.a * resolution, transform.b * resolution, transform.c * resolution, transform.d * resolution, transform.tx * resolution, transform.ty * resolution);

        // TODO suport sprite alpha masks??
        // lots of effort required. If demand is great enough..
        if (!maskData._texture) {
            this.renderGraphicsShape(maskData);
            renderer.context.clip();
        }

        maskData.worldAlpha = cacheAlpha;
    };

    /**
     * Renders a PIXI.Graphics shape.
     *
     * @param {PIXI.Graphics} graphics - The object to render.
     */


    CanvasMaskManager.prototype.renderGraphicsShape = function renderGraphicsShape(graphics) {
        var context = this.renderer.context;
        var len = graphics.graphicsData.length;

        if (len === 0) {
            return;
        }

        context.beginPath();

        for (var i = 0; i < len; i++) {
            var data = graphics.graphicsData[i];
            var shape = data.shape;

            if (data.type === _const.SHAPES.POLY) {
                var points = shape.points;
                var holes = data.holes;
                var outerArea = void 0;
                var innerArea = void 0;

                context.moveTo(points[0], points[1]);

                for (var j = 2; j < points.length; j += 2) {
                    context.lineTo(points[j], points[j + 1]);
                }

                // if the first and last point are the same close the path - much neater :)
                if (points[0] === points[points.length - 2] && points[1] === points[points.length - 1]) {
                    context.closePath();
                }

                if (holes.length > 0) {
                    outerArea = 0;
                    for (var _j = 0; _j < points.length; _j += 2) {
                        outerArea += points[_j] * points[_j + 3] - points[_j + 1] * points[_j + 2];
                    }

                    for (var k = 0; k < holes.length; k++) {
                        points = holes[k].points;

                        innerArea = 0;
                        for (var _j2 = 0; _j2 < points.length; _j2 += 2) {
                            innerArea += points[_j2] * points[_j2 + 3] - points[_j2 + 1] * points[_j2 + 2];
                        }

                        context.moveTo(points[0], points[1]);

                        if (innerArea * outerArea < 0) {
                            for (var _j3 = 2; _j3 < points.length; _j3 += 2) {
                                context.lineTo(points[_j3], points[_j3 + 1]);
                            }
                        } else {
                            for (var _j4 = points.length - 2; _j4 >= 2; _j4 -= 2) {
                                context.lineTo(points[_j4], points[_j4 + 1]);
                            }
                        }
                    }
                }
            } else if (data.type === _const.SHAPES.RECT) {
                context.rect(shape.x, shape.y, shape.width, shape.height);
                context.closePath();
            } else if (data.type === _const.SHAPES.CIRC) {
                // TODO - need to be Undefined!
                context.arc(shape.x, shape.y, shape.radius, 0, 2 * Math.PI);
                context.closePath();
            } else if (data.type === _const.SHAPES.ELIP) {
                // ellipse code taken from: http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas

                var w = shape.width * 2;
                var h = shape.height * 2;

                var x = shape.x - w / 2;
                var y = shape.y - h / 2;

                var kappa = 0.5522848;
                var ox = w / 2 * kappa; // control point offset horizontal
                var oy = h / 2 * kappa; // control point offset vertical
                var xe = x + w; // x-end
                var ye = y + h; // y-end
                var xm = x + w / 2; // x-middle
                var ym = y + h / 2; // y-middle

                context.moveTo(x, ym);
                context.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
                context.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
                context.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
                context.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
                context.closePath();
            } else if (data.type === _const.SHAPES.RREC) {
                var rx = shape.x;
                var ry = shape.y;
                var width = shape.width;
                var height = shape.height;
                var radius = shape.radius;

                var maxRadius = Math.min(width, height) / 2 | 0;

                radius = radius > maxRadius ? maxRadius : radius;

                context.moveTo(rx, ry + radius);
                context.lineTo(rx, ry + height - radius);
                context.quadraticCurveTo(rx, ry + height, rx + radius, ry + height);
                context.lineTo(rx + width - radius, ry + height);
                context.quadraticCurveTo(rx + width, ry + height, rx + width, ry + height - radius);
                context.lineTo(rx + width, ry + radius);
                context.quadraticCurveTo(rx + width, ry, rx + width - radius, ry);
                context.lineTo(rx + radius, ry);
                context.quadraticCurveTo(rx, ry, rx, ry + radius);
                context.closePath();
            }
        }
    };

    /**
     * Restores the current drawing context to the state it was before the mask was applied.
     *
     * @param {PIXI.CanvasRenderer} renderer - The renderer context to use.
     */


    CanvasMaskManager.prototype.popMask = function popMask(renderer) {
        renderer.context.restore();
        renderer.invalidateBlendMode();
    };

    /**
     * Destroys this canvas mask manager.
     *
     */


    CanvasMaskManager.prototype.destroy = function destroy() {
        /* empty */
    };

    return CanvasMaskManager;
}();

exports.default = CanvasMaskManager;

},{"../../../const":53}],86:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _settings = require('../../../settings');

var _settings2 = _interopRequireDefault(_settings);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Creates a Canvas element of the given size.
 *
 * @class
 * @memberof PIXI
 */
var CanvasRenderTarget = function () {
  /**
   * @param {number} width - the width for the newly created canvas
   * @param {number} height - the height for the newly created canvas
   * @param {number} [resolution=1] - The resolution / device pixel ratio of the canvas
   */
  function CanvasRenderTarget(width, height, resolution) {
    _classCallCheck(this, CanvasRenderTarget);

    /**
     * The Canvas object that belongs to this CanvasRenderTarget.
     *
     * @member {HTMLCanvasElement}
     */
    this.canvas = document.createElement('canvas');

    /**
     * A CanvasRenderingContext2D object representing a two-dimensional rendering context.
     *
     * @member {CanvasRenderingContext2D}
     */
    this.context = this.canvas.getContext('2d');

    this.resolution = resolution || _settings2.default.RESOLUTION;

    this.resize(width, height);
  }

  /**
   * Clears the canvas that was created by the CanvasRenderTarget class.
   *
   * @private
   */


  CanvasRenderTarget.prototype.clear = function clear() {
    this.context.setTransform(1, 0, 0, 1, 0, 0);
    this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
  };

  /**
   * Resizes the canvas to the specified width and height.
   *
   * @param {number} width - the new width of the canvas
   * @param {number} height - the new height of the canvas
   */


  CanvasRenderTarget.prototype.resize = function resize(width, height) {
    this.canvas.width = width * this.resolution;
    this.canvas.height = height * this.resolution;
  };

  /**
   * Destroys this canvas.
   *
   */


  CanvasRenderTarget.prototype.destroy = function destroy() {
    this.context = null;
    this.canvas = null;
  };

  /**
   * The width of the canvas buffer in pixels.
   *
   * @member {number}
   */


  _createClass(CanvasRenderTarget, [{
    key: 'width',
    get: function get() {
      return this.canvas.width;
    },
    set: function set(val) // eslint-disable-line require-jsdoc
    {
      this.canvas.width = val;
    }

    /**
     * The height of the canvas buffer in pixels.
     *
     * @member {number}
     */

  }, {
    key: 'height',
    get: function get() {
      return this.canvas.height;
    },
    set: function set(val) // eslint-disable-line require-jsdoc
    {
      this.canvas.height = val;
    }
  }]);

  return CanvasRenderTarget;
}();

exports.default = CanvasRenderTarget;

},{"../../../settings":108}],87:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.default = canUseNewCanvasBlendModes;
/**
 * Creates a little colored canvas
 *
 * @ignore
 * @param {string} color - The color to make the canvas
 * @return {canvas} a small canvas element
 */
function createColoredCanvas(color) {
    var canvas = document.createElement('canvas');

    canvas.width = 6;
    canvas.height = 1;

    var context = canvas.getContext('2d');

    context.fillStyle = color;
    context.fillRect(0, 0, 6, 1);

    return canvas;
}

/**
 * Checks whether the Canvas BlendModes are supported by the current browser
 *
 * @return {boolean} whether they are supported
 */
function canUseNewCanvasBlendModes() {
    if (typeof document === 'undefined') {
        return false;
    }

    var magenta = createColoredCanvas('#ff00ff');
    var yellow = createColoredCanvas('#ffff00');

    var canvas = document.createElement('canvas');

    canvas.width = 6;
    canvas.height = 1;

    var context = canvas.getContext('2d');

    context.globalCompositeOperation = 'multiply';
    context.drawImage(magenta, 0, 0);
    context.drawImage(yellow, 2, 0);

    var imageData = context.getImageData(2, 0, 1, 1);

    if (!imageData) {
        return false;
    }

    var data = imageData.data;

    return data[0] === 255 && data[1] === 0 && data[2] === 0;
}

},{}],88:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.default = mapCanvasBlendModesToPixi;

var _const = require('../../../const');

var _canUseNewCanvasBlendModes = require('./canUseNewCanvasBlendModes');

var _canUseNewCanvasBlendModes2 = _interopRequireDefault(_canUseNewCanvasBlendModes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Maps blend combinations to Canvas.
 *
 * @memberof PIXI
 * @function mapCanvasBlendModesToPixi
 * @private
 * @param {string[]} [array=[]] - The array to output into.
 * @return {string[]} Mapped modes.
 */
function mapCanvasBlendModesToPixi() {
    var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

    if ((0, _canUseNewCanvasBlendModes2.default)()) {
        array[_const.BLEND_MODES.NORMAL] = 'source-over';
        array[_const.BLEND_MODES.ADD] = 'lighter'; // IS THIS OK???
        array[_const.BLEND_MODES.MULTIPLY] = 'multiply';
        array[_const.BLEND_MODES.SCREEN] = 'screen';
        array[_const.BLEND_MODES.OVERLAY] = 'overlay';
        array[_const.BLEND_MODES.DARKEN] = 'darken';
        array[_const.BLEND_MODES.LIGHTEN] = 'lighten';
        array[_const.BLEND_MODES.COLOR_DODGE] = 'color-dodge';
        array[_const.BLEND_MODES.COLOR_BURN] = 'color-burn';
        array[_const.BLEND_MODES.HARD_LIGHT] = 'hard-light';
        array[_const.BLEND_MODES.SOFT_LIGHT] = 'soft-light';
        array[_const.BLEND_MODES.DIFFERENCE] = 'difference';
        array[_const.BLEND_MODES.EXCLUSION] = 'exclusion';
        array[_const.BLEND_MODES.HUE] = 'hue';
        array[_const.BLEND_MODES.SATURATION] = 'saturate';
        array[_const.BLEND_MODES.COLOR] = 'color';
        array[_const.BLEND_MODES.LUMINOSITY] = 'luminosity';
    } else {
        // this means that the browser does not support the cool new blend modes in canvas 'cough' ie 'cough'
        array[_const.BLEND_MODES.NORMAL] = 'source-over';
        array[_const.BLEND_MODES.ADD] = 'lighter'; // IS THIS OK???
        array[_const.BLEND_MODES.MULTIPLY] = 'source-over';
        array[_const.BLEND_MODES.SCREEN] = 'source-over';
        array[_const.BLEND_MODES.OVERLAY] = 'source-over';
        array[_const.BLEND_MODES.DARKEN] = 'source-over';
        array[_const.BLEND_MODES.LIGHTEN] = 'source-over';
        array[_const.BLEND_MODES.COLOR_DODGE] = 'source-over';
        array[_const.BLEND_MODES.COLOR_BURN] = 'source-over';
        array[_const.BLEND_MODES.HARD_LIGHT] = 'source-over';
        array[_const.BLEND_MODES.SOFT_LIGHT] = 'source-over';
        array[_const.BLEND_MODES.DIFFERENCE] = 'source-over';
        array[_const.BLEND_MODES.EXCLUSION] = 'source-over';
        array[_const.BLEND_MODES.HUE] = 'source-over';
        array[_const.BLEND_MODES.SATURATION] = 'source-over';
        array[_const.BLEND_MODES.COLOR] = 'source-over';
        array[_const.BLEND_MODES.LUMINOSITY] = 'source-over';
    }
    // not-premultiplied, only for webgl
    array[_const.BLEND_MODES.NORMAL_NPM] = array[_const.BLEND_MODES.NORMAL];
    array[_const.BLEND_MODES.ADD_NPM] = array[_const.BLEND_MODES.ADD];
    array[_const.BLEND_MODES.SCREEN_NPM] = array[_const.BLEND_MODES.SCREEN];

    return array;
}

},{"../../../const":53,"./canUseNewCanvasBlendModes":87}],89:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _const = require('../../const');

var _settings = require('../../settings');

var _settings2 = _interopRequireDefault(_settings);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * TextureGarbageCollector. This class manages the GPU and ensures that it does not get clogged
 * up with textures that are no longer being used.
 *
 * @class
 * @memberof PIXI
 */
var TextureGarbageCollector = function () {
    /**
     * @param {PIXI.WebGLRenderer} renderer - The renderer this manager works for.
     */
    function TextureGarbageCollector(renderer) {
        _classCallCheck(this, TextureGarbageCollector);

        this.renderer = renderer;

        this.count = 0;
        this.checkCount = 0;
        this.maxIdle = _settings2.default.GC_MAX_IDLE;
        this.checkCountMax = _settings2.default.GC_MAX_CHECK_COUNT;
        this.mode = _settings2.default.GC_MODE;
    }

    /**
     * Checks to see when the last time a texture was used
     * if the texture has not been used for a specified amount of time it will be removed from the GPU
     */


    TextureGarbageCollector.prototype.update = function update() {
        this.count++;

        if (this.mode === _const.GC_MODES.MANUAL) {
            return;
        }

        this.checkCount++;

        if (this.checkCount > this.checkCountMax) {
            this.checkCount = 0;

            this.run();
        }
    };

    /**
     * Checks to see when the last time a texture was used
     * if the texture has not been used for a specified amount of time it will be removed from the GPU
     */


    TextureGarbageCollector.prototype.run = function run() {
        var tm = this.renderer.textureManager;
        var managedTextures = tm._managedTextures;
        var wasRemoved = false;

        for (var i = 0; i < managedTextures.length; i++) {
            var texture = managedTextures[i];

            // only supports non generated textures at the moment!
            if (!texture._glRenderTargets && this.count - texture.touched > this.maxIdle) {
                tm.destroyTexture(texture, true);
                managedTextures[i] = null;
                wasRemoved = true;
            }
        }

        if (wasRemoved) {
            var j = 0;

            for (var _i = 0; _i < managedTextures.length; _i++) {
                if (managedTextures[_i] !== null) {
                    managedTextures[j++] = managedTextures[_i];
                }
            }

            managedTextures.length = j;
        }
    };

    /**
     * Removes all the textures within the specified displayObject and its children from the GPU
     *
     * @param {PIXI.DisplayObject} displayObject - the displayObject to remove the textures from.
     */


    TextureGarbageCollector.prototype.unload = function unload(displayObject) {
        var tm = this.renderer.textureManager;

        // only destroy non generated textures
        if (displayObject._texture && displayObject._texture._glRenderTargets) {
            tm.destroyTexture(displayObject._texture, true);
        }

        for (var i = displayObject.children.length - 1; i >= 0; i--) {
            this.unload(displayObject.children[i]);
        }
    };

    return TextureGarbageCollector;
}();

exports.default = TextureGarbageCollector;

},{"../../const":53,"../../settings":108}],90:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _pixiGlCore = require('pixi-gl-core');

var _const = require('../../const');

var _RenderTarget = require('./utils/RenderTarget');

var _RenderTarget2 = _interopRequireDefault(_RenderTarget);

var _utils = require('../../utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Helper class to create a webGL Texture
 *
 * @class
 * @memberof PIXI
 */
var TextureManager = function () {
    /**
     * @param {PIXI.WebGLRenderer} renderer - A reference to the current renderer
     */
    function TextureManager(renderer) {
        _classCallCheck(this, TextureManager);

        /**
         * A reference to the current renderer
         *
         * @member {PIXI.WebGLRenderer}
         */
        this.renderer = renderer;

        /**
         * The current WebGL rendering context
         *
         * @member {WebGLRenderingContext}
         */
        this.gl = renderer.gl;

        /**
         * Track textures in the renderer so we can no longer listen to them on destruction.
         *
         * @member {Array<*>}
         * @private
         */
        this._managedTextures = [];
    }

    /**
     * Binds a texture.
     *
     */


    TextureManager.prototype.bindTexture = function bindTexture() {}
    // empty


    /**
     * Gets a texture.
     *
     */
    ;

    TextureManager.prototype.getTexture = function getTexture() {}
    // empty


    /**
     * Updates and/or Creates a WebGL texture for the renderer's context.
     *
     * @param {PIXI.BaseTexture|PIXI.Texture} texture - the texture to update
     * @param {number} location - the location the texture will be bound to.
     * @return {GLTexture} The gl texture.
     */
    ;

    TextureManager.prototype.updateTexture = function updateTexture(texture, location) {
        // assume it good!
        // texture = texture.baseTexture || texture;

        var gl = this.gl;

        var isRenderTexture = !!texture._glRenderTargets;

        if (!texture.hasLoaded) {
            return null;
        }

        var boundTextures = this.renderer.boundTextures;

        // if the location is undefined then this may have been called by n event.
        // this being the case the texture may already be bound to a slot. As a texture can only be bound once
        // we need to find its current location if it exists.
        if (location === undefined) {
            location = 0;

            // TODO maybe we can use texture bound ids later on...
            // check if texture is already bound..
            for (var i = 0; i < boundTextures.length; ++i) {
                if (boundTextures[i] === texture) {
                    location = i;
                    break;
                }
            }
        }

        boundTextures[location] = texture;

        gl.activeTexture(gl.TEXTURE0 + location);

        var glTexture = texture._glTextures[this.renderer.CONTEXT_UID];

        if (!glTexture) {
            if (isRenderTexture) {
                var renderTarget = new _RenderTarget2.default(this.gl, texture.width, texture.height, texture.scaleMode, texture.resolution);

                renderTarget.resize(texture.width, texture.height);
                texture._glRenderTargets[this.renderer.CONTEXT_UID] = renderTarget;
                glTexture = renderTarget.texture;

                // framebuffer constructor disactivates current framebuffer
                if (!this.renderer._activeRenderTarget.root) {
                    this.renderer._activeRenderTarget.frameBuffer.bind();
                }
            } else {
                glTexture = new _pixiGlCore.GLTexture(this.gl, null, null, null, null);
                glTexture.bind(location);
                glTexture.premultiplyAlpha = true;
                glTexture.upload(texture.source);
            }

            texture._glTextures[this.renderer.CONTEXT_UID] = glTexture;

            texture.on('update', this.updateTexture, this);
            texture.on('dispose', this.destroyTexture, this);

            this._managedTextures.push(texture);

            if (texture.isPowerOfTwo) {
                if (texture.mipmap) {
                    glTexture.enableMipmap();
                }

                if (texture.wrapMode === _const.WRAP_MODES.CLAMP) {
                    glTexture.enableWrapClamp();
                } else if (texture.wrapMode === _const.WRAP_MODES.REPEAT) {
                    glTexture.enableWrapRepeat();
                } else {
                    glTexture.enableWrapMirrorRepeat();
                }
            } else {
                glTexture.enableWrapClamp();
            }

            if (texture.scaleMode === _const.SCALE_MODES.NEAREST) {
                glTexture.enableNearestScaling();
            } else {
                glTexture.enableLinearScaling();
            }
        }
        // the texture already exists so we only need to update it..
        else if (isRenderTexture) {
                texture._glRenderTargets[this.renderer.CONTEXT_UID].resize(texture.width, texture.height);
            } else {
                glTexture.upload(texture.source);
            }

        return glTexture;
    };

    /**
     * Deletes the texture from WebGL
     *
     * @param {PIXI.BaseTexture|PIXI.Texture} texture - the texture to destroy
     * @param {boolean} [skipRemove=false] - Whether to skip removing the texture from the TextureManager.
     */


    TextureManager.prototype.destroyTexture = function destroyTexture(texture, skipRemove) {
        texture = texture.baseTexture || texture;

        if (!texture.hasLoaded) {
            return;
        }

        var renderer = this.renderer;
        var uid = renderer.CONTEXT_UID;
        var glTextures = texture._glTextures;
        var glRenderTargets = texture._glRenderTargets;

        if (glTextures[uid]) {
            renderer.unbindTexture(texture);

            glTextures[uid].destroy();
            texture.off('update', this.updateTexture, this);
            texture.off('dispose', this.destroyTexture, this);

            delete glTextures[uid];

            if (!skipRemove) {
                var i = this._managedTextures.indexOf(texture);

                if (i !== -1) {
                    (0, _utils.removeItems)(this._managedTextures, i, 1);
                }
            }
        }

        if (glRenderTargets && glRenderTargets[uid]) {
            if (renderer._activeRenderTarget === glRenderTargets[uid]) {
                renderer.bindRenderTarget(renderer.rootRenderTarget);
            }

            glRenderTargets[uid].destroy();
            delete glRenderTargets[uid];
        }
    };

    /**
     * Deletes all the textures from WebGL
     */


    TextureManager.prototype.removeAll = function removeAll() {
        // empty all the old gl textures as they are useless now
        for (var i = 0; i < this._managedTextures.length; ++i) {
            var texture = this._managedTextures[i];

            if (texture._glTextures[this.renderer.CONTEXT_UID]) {
                delete texture._glTextures[this.renderer.CONTEXT_UID];
            }
        }
    };

    /**
     * Destroys this manager and removes all its textures
     */


    TextureManager.prototype.destroy = function destroy() {
        // destroy managed textures
        for (var i = 0; i < this._managedTextures.length; ++i) {
            var texture = this._managedTextures[i];

            this.destroyTexture(texture, true);

            texture.off('update', this.updateTexture, this);
            texture.off('dispose', this.destroyTexture, this);
        }

        this._managedTextures = null;
    };

    return TextureManager;
}();

exports.default = TextureManager;

},{"../../const":53,"../../utils":132,"./utils/RenderTarget":103,"pixi-gl-core":36}],91:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _SystemRenderer2 = require('../SystemRenderer');

var _SystemRenderer3 = _interopRequireDefault(_SystemRenderer2);

var _MaskManager = require('./managers/MaskManager');

var _MaskManager2 = _interopRequireDefault(_MaskManager);

var _StencilManager = require('./managers/StencilManager');

var _StencilManager2 = _interopRequireDefault(_StencilManager);

var _FilterManager = require('./managers/FilterManager');

var _FilterManager2 = _interopRequireDefault(_FilterManager);

var _RenderTarget = require('./utils/RenderTarget');

var _RenderTarget2 = _interopRequireDefault(_RenderTarget);

var _ObjectRenderer = require('./utils/ObjectRenderer');

var _ObjectRenderer2 = _interopRequireDefault(_ObjectRenderer);

var _TextureManager = require('./TextureManager');

var _TextureManager2 = _interopRequireDefault(_TextureManager);

var _BaseTexture = require('../../textures/BaseTexture');

var _BaseTexture2 = _interopRequireDefault(_BaseTexture);

var _TextureGarbageCollector = require('./TextureGarbageCollector');

var _TextureGarbageCollector2 = _interopRequireDefault(_TextureGarbageCollector);

var _WebGLState = require('./WebGLState');

var _WebGLState2 = _interopRequireDefault(_WebGLState);

var _mapWebGLDrawModesToPixi = require('./utils/mapWebGLDrawModesToPixi');

var _mapWebGLDrawModesToPixi2 = _interopRequireDefault(_mapWebGLDrawModesToPixi);

var _validateContext = require('./utils/validateContext');

var _validateContext2 = _interopRequireDefault(_validateContext);

var _utils = require('../../utils');

var _pixiGlCore = require('pixi-gl-core');

var _pixiGlCore2 = _interopRequireDefault(_pixiGlCore);

var _const = require('../../const');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var CONTEXT_UID = 0;

/**
 * The WebGLRenderer draws the scene and all its content onto a webGL enabled canvas. This renderer
 * should be used for browsers that support webGL. This Render works by automatically managing webGLBatchs.
 * So no need for Sprite Batches or Sprite Clouds.
 * Don't forget to add the view to your DOM or you will not see anything :)
 *
 * @class
 * @memberof PIXI
 * @extends PIXI.SystemRenderer
 */

var WebGLRenderer = function (_SystemRenderer) {
    _inherits(WebGLRenderer, _SystemRenderer);

    // eslint-disable-next-line valid-jsdoc
    /**
     *
     * @param {object} [options] - The optional renderer parameters
     * @param {number} [options.width=800] - the width of the screen
     * @param {number} [options.height=600] - the height of the screen
     * @param {HTMLCanvasElement} [options.view] - the canvas to use as a view, optional
     * @param {boolean} [options.transparent=false] - If the render view is transparent, default false
     * @param {boolean} [options.autoResize=false] - If the render view is automatically resized, default false
     * @param {boolean} [options.antialias=false] - sets antialias. If not available natively then FXAA
     *  antialiasing is used
     * @param {boolean} [options.forceFXAA=false] - forces FXAA antialiasing to be used over native.
     *  FXAA is faster, but may not always look as great
     * @param {number} [options.resolution=1] - The resolution / device pixel ratio of the renderer.
     *  The resolution of the renderer retina would be 2.
     * @param {boolean} [options.clearBeforeRender=true] - This sets if the renderer will clear
     *  the canvas or not before the new render pass. If you wish to set this to false, you *must* set
     *  preserveDrawingBuffer to `true`.
     * @param {boolean} [options.preserveDrawingBuffer=false] - enables drawing buffer preservation,
     *  enable this if you need to call toDataUrl on the webgl context.
     * @param {boolean} [options.roundPixels=false] - If true PixiJS will Math.floor() x/y values when
     *  rendering, stopping pixel interpolation.
     * @param {number} [options.backgroundColor=0x000000] - The background color of the rendered area
     *  (shown if not transparent).
     * @param {boolean} [options.legacy=false] - If true PixiJS will aim to ensure compatibility
     *  with older / less advanced devices. If you experience unexplained flickering try setting this to true.
     * @param {string} [options.powerPreference] - Parameter passed to webgl context, set to "high-performance"
     *  for devices with dual graphics card
     */
    function WebGLRenderer(options, arg2, arg3) {
        _classCallCheck(this, WebGLRenderer);

        var _this = _possibleConstructorReturn(this, _SystemRenderer.call(this, 'WebGL', options, arg2, arg3));

        _this.legacy = _this.options.legacy;

        if (_this.legacy) {
            _pixiGlCore2.default.VertexArrayObject.FORCE_NATIVE = true;
        }

        /**
         * The type of this renderer as a standardised const
         *
         * @member {number}
         * @see PIXI.RENDERER_TYPE
         */
        _this.type = _const.RENDERER_TYPE.WEBGL;

        _this.handleContextLost = _this.handleContextLost.bind(_this);
        _this.handleContextRestored = _this.handleContextRestored.bind(_this);

        _this.view.addEventListener('webglcontextlost', _this.handleContextLost, false);
        _this.view.addEventListener('webglcontextrestored', _this.handleContextRestored, false);

        /**
         * The options passed in to create a new webgl context.
         *
         * @member {object}
         * @private
         */
        _this._contextOptions = {
            alpha: _this.transparent,
            antialias: _this.options.antialias,
            premultipliedAlpha: _this.transparent && _this.transparent !== 'notMultiplied',
            stencil: true,
            preserveDrawingBuffer: _this.options.preserveDrawingBuffer,
            powerPreference: _this.options.powerPreference
        };

        _this._backgroundColorRgba[3] = _this.transparent ? 0 : 1;

        /**
         * Manages the masks using the stencil buffer.
         *
         * @member {PIXI.MaskManager}
         */
        _this.maskManager = new _MaskManager2.default(_this);

        /**
         * Manages the stencil buffer.
         *
         * @member {PIXI.StencilManager}
         */
        _this.stencilManager = new _StencilManager2.default(_this);

        /**
         * An empty renderer.
         *
         * @member {PIXI.ObjectRenderer}
         */
        _this.emptyRenderer = new _ObjectRenderer2.default(_this);

        /**
         * The currently active ObjectRenderer.
         *
         * @member {PIXI.ObjectRenderer}
         */
        _this.currentRenderer = _this.emptyRenderer;

        /**
         * Manages textures
         * @member {PIXI.TextureManager}
         */
        _this.textureManager = null;

        /**
         * Manages the filters.
         *
         * @member {PIXI.FilterManager}
         */
        _this.filterManager = null;

        _this.initPlugins();

        /**
         * The current WebGL rendering context, it is created here
         *
         * @member {WebGLRenderingContext}
         */
        // initialize the context so it is ready for the managers.
        if (_this.options.context) {
            // checks to see if a context is valid..
            (0, _validateContext2.default)(_this.options.context);
        }

        _this.gl = _this.options.context || _pixiGlCore2.default.createContext(_this.view, _this._contextOptions);

        _this.CONTEXT_UID = CONTEXT_UID++;

        /**
         * The currently active ObjectRenderer.
         *
         * @member {PIXI.WebGLState}
         */
        _this.state = new _WebGLState2.default(_this.gl);

        _this.renderingToScreen = true;

        /**
         * Holds the current state of textures bound to the GPU.
         * @type {Array}
         */
        _this.boundTextures = null;

        /**
         * Holds the current shader
         *
         * @member {PIXI.Shader}
         */
        _this._activeShader = null;

        _this._activeVao = null;

        /**
         * Holds the current render target
         *
         * @member {PIXI.RenderTarget}
         */
        _this._activeRenderTarget = null;

        _this._initContext();

        // map some webGL blend and drawmodes..
        _this.drawModes = (0, _mapWebGLDrawModesToPixi2.default)(_this.gl);

        _this._nextTextureLocation = 0;

        _this.setBlendMode(0);

        /**
         * Fired after rendering finishes.
         *
         * @event PIXI.WebGLRenderer#postrender
         */

        /**
         * Fired before rendering starts.
         *
         * @event PIXI.WebGLRenderer#prerender
         */

        /**
         * Fired when the WebGL context is set.
         *
         * @event PIXI.WebGLRenderer#context
         * @param {WebGLRenderingContext} gl - WebGL context.
         */
        return _this;
    }

    /**
     * Creates the WebGL context
     *
     * @private
     */


    WebGLRenderer.prototype._initContext = function _initContext() {
        var gl = this.gl;

        // restore a context if it was previously lost
        if (gl.isContextLost() && gl.getExtension('WEBGL_lose_context')) {
            gl.getExtension('WEBGL_lose_context').restoreContext();
        }

        var maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);

        this._activeShader = null;
        this._activeVao = null;

        this.boundTextures = new Array(maxTextures);
        this.emptyTextures = new Array(maxTextures);

        /**
         * Did someone temper with textures state? We'll overwrite them when we need to unbind something.
         * @member {boolean}
         * @private
         */
        this._unknownBoundTextures = false;

        // create a texture manager...
        this.textureManager = new _TextureManager2.default(this);
        this.filterManager = new _FilterManager2.default(this);
        this.textureGC = new _TextureGarbageCollector2.default(this);

        this.state.resetToDefault();

        this.rootRenderTarget = new _RenderTarget2.default(gl, this.width, this.height, null, this.resolution, true);
        this.rootRenderTarget.clearColor = this._backgroundColorRgba;

        this.bindRenderTarget(this.rootRenderTarget);

        // now lets fill up the textures with empty ones!
        var emptyGLTexture = new _pixiGlCore2.default.GLTexture.fromData(gl, null, 1, 1);

        var tempObj = { _glTextures: {} };

        tempObj._glTextures[this.CONTEXT_UID] = {};

        for (var i = 0; i < maxTextures; i++) {
            var empty = new _BaseTexture2.default();

            empty._glTextures[this.CONTEXT_UID] = emptyGLTexture;

            this.boundTextures[i] = tempObj;
            this.emptyTextures[i] = empty;
            this.bindTexture(null, i);
        }

        this.emit('context', gl);

        // setup the width/height properties and gl viewport
        this.resize(this.screen.width, this.screen.height);
    };

    /**
     * Renders the object to its webGL view
     *
     * @param {PIXI.DisplayObject} displayObject - the object to be rendered
     * @param {PIXI.RenderTexture} renderTexture - The render texture to render to.
     * @param {boolean} [clear] - Should the canvas be cleared before the new render
     * @param {PIXI.Matrix} [transform] - A transform to apply to the render texture before rendering.
     * @param {boolean} [skipUpdateTransform] - Should we skip the update transform pass?
     */


    WebGLRenderer.prototype.render = function render(displayObject, renderTexture, clear, transform, skipUpdateTransform) {
        // can be handy to know!
        this.renderingToScreen = !renderTexture;

        this.emit('prerender');

        // no point rendering if our context has been blown up!
        if (!this.gl || this.gl.isContextLost()) {
            return;
        }

        this._nextTextureLocation = 0;

        if (!renderTexture) {
            this._lastObjectRendered = displayObject;
        }

        if (!skipUpdateTransform) {
            // update the scene graph
            var cacheParent = displayObject.parent;

            displayObject.parent = this._tempDisplayObjectParent;
            displayObject.updateTransform();
            displayObject.parent = cacheParent;
            // displayObject.hitArea = //TODO add a temp hit area
        }

        this.bindRenderTexture(renderTexture, transform);

        this.currentRenderer.start();

        if (clear !== undefined ? clear : this.clearBeforeRender) {
            this._activeRenderTarget.clear();
        }

        displayObject.renderWebGL(this);

        // apply transform..
        this.currentRenderer.flush();

        // this.setObjectRenderer(this.emptyRenderer);

        this.textureGC.update();

        this.emit('postrender');
    };

    /**
     * Changes the current renderer to the one given in parameter
     *
     * @param {PIXI.ObjectRenderer} objectRenderer - The object renderer to use.
     */


    WebGLRenderer.prototype.setObjectRenderer = function setObjectRenderer(objectRenderer) {
        if (this.currentRenderer === objectRenderer) {
            return;
        }

        this.currentRenderer.stop();
        this.currentRenderer = objectRenderer;
        this.currentRenderer.start();
    };

    /**
     * This should be called if you wish to do some custom rendering
     * It will basically render anything that may be batched up such as sprites
     *
     */


    WebGLRenderer.prototype.flush = function flush() {
        this.setObjectRenderer(this.emptyRenderer);
    };

    /**
     * Resizes the webGL view to the specified width and height.
     *
     * @param {number} screenWidth - the new width of the screen
     * @param {number} screenHeight - the new height of the screen
     */


    WebGLRenderer.prototype.resize = function resize(screenWidth, screenHeight) {
        //  if(width * this.resolution === this.width && height * this.resolution === this.height)return;

        _SystemRenderer3.default.prototype.resize.call(this, screenWidth, screenHeight);

        this.rootRenderTarget.resize(screenWidth, screenHeight);

        if (this._activeRenderTarget === this.rootRenderTarget) {
            this.rootRenderTarget.activate();

            if (this._activeShader) {
                this._activeShader.uniforms.projectionMatrix = this.rootRenderTarget.projectionMatrix.toArray(true);
            }
        }
    };

    /**
     * Resizes the webGL view to the specified width and height.
     *
     * @param {number} blendMode - the desired blend mode
     */


    WebGLRenderer.prototype.setBlendMode = function setBlendMode(blendMode) {
        this.state.setBlendMode(blendMode);
    };

    /**
     * Erases the active render target and fills the drawing area with a colour
     *
     * @param {number} [clearColor] - The colour
     */


    WebGLRenderer.prototype.clear = function clear(clearColor) {
        this._activeRenderTarget.clear(clearColor);
    };

    /**
     * Sets the transform of the active render target to the given matrix
     *
     * @param {PIXI.Matrix} matrix - The transformation matrix
     */


    WebGLRenderer.prototype.setTransform = function setTransform(matrix) {
        this._activeRenderTarget.transform = matrix;
    };

    /**
     * Erases the render texture and fills the drawing area with a colour
     *
     * @param {PIXI.RenderTexture} renderTexture - The render texture to clear
     * @param {number} [clearColor] - The colour
     * @return {PIXI.WebGLRenderer} Returns itself.
     */


    WebGLRenderer.prototype.clearRenderTexture = function clearRenderTexture(renderTexture, clearColor) {
        var baseTexture = renderTexture.baseTexture;
        var renderTarget = baseTexture._glRenderTargets[this.CONTEXT_UID];

        if (renderTarget) {
            renderTarget.clear(clearColor);
        }

        return this;
    };

    /**
     * Binds a render texture for rendering
     *
     * @param {PIXI.RenderTexture} renderTexture - The render texture to render
     * @param {PIXI.Matrix} transform - The transform to be applied to the render texture
     * @return {PIXI.WebGLRenderer} Returns itself.
     */


    WebGLRenderer.prototype.bindRenderTexture = function bindRenderTexture(renderTexture, transform) {
        var renderTarget = void 0;

        if (renderTexture) {
            var baseTexture = renderTexture.baseTexture;

            if (!baseTexture._glRenderTargets[this.CONTEXT_UID]) {
                // bind the current texture
                this.textureManager.updateTexture(baseTexture, 0);
            }

            this.unbindTexture(baseTexture);

            renderTarget = baseTexture._glRenderTargets[this.CONTEXT_UID];
            renderTarget.setFrame(renderTexture.frame);
        } else {
            renderTarget = this.rootRenderTarget;
        }

        renderTarget.transform = transform;
        this.bindRenderTarget(renderTarget);

        return this;
    };

    /**
     * Changes the current render target to the one given in parameter
     *
     * @param {PIXI.RenderTarget} renderTarget - the new render target
     * @return {PIXI.WebGLRenderer} Returns itself.
     */


    WebGLRenderer.prototype.bindRenderTarget = function bindRenderTarget(renderTarget) {
        if (renderTarget !== this._activeRenderTarget) {
            this._activeRenderTarget = renderTarget;
            renderTarget.activate();

            if (this._activeShader) {
                this._activeShader.uniforms.projectionMatrix = renderTarget.projectionMatrix.toArray(true);
            }

            this.stencilManager.setMaskStack(renderTarget.stencilMaskStack);
        }

        return this;
    };

    /**
     * Changes the current shader to the one given in parameter
     *
     * @param {PIXI.Shader} shader - the new shader
     * @param {boolean} [autoProject=true] - Whether automatically set the projection matrix
     * @return {PIXI.WebGLRenderer} Returns itself.
     */


    WebGLRenderer.prototype.bindShader = function bindShader(shader, autoProject) {
        // TODO cache
        if (this._activeShader !== shader) {
            this._activeShader = shader;
            shader.bind();

            // `autoProject` normally would be a default parameter set to true
            // but because of how Babel transpiles default parameters
            // it hinders the performance of this method.
            if (autoProject !== false) {
                // automatically set the projection matrix
                shader.uniforms.projectionMatrix = this._activeRenderTarget.projectionMatrix.toArray(true);
            }
        }

        return this;
    };

    /**
     * Binds the texture. This will return the location of the bound texture.
     * It may not be the same as the one you pass in. This is due to optimisation that prevents
     * needless binding of textures. For example if the texture is already bound it will return the
     * current location of the texture instead of the one provided. To bypass this use force location
     *
     * @param {PIXI.Texture} texture - the new texture
     * @param {number} location - the suggested texture location
     * @param {boolean} forceLocation - force the location
     * @return {number} bound texture location
     */


    WebGLRenderer.prototype.bindTexture = function bindTexture(texture, location, forceLocation) {
        texture = texture || this.emptyTextures[location];
        texture = texture.baseTexture || texture;
        texture.touched = this.textureGC.count;

        if (!forceLocation) {
            // TODO - maybe look into adding boundIds.. save us the loop?
            for (var i = 0; i < this.boundTextures.length; i++) {
                if (this.boundTextures[i] === texture) {
                    return i;
                }
            }

            if (location === undefined) {
                this._nextTextureLocation++;
                this._nextTextureLocation %= this.boundTextures.length;
                location = this.boundTextures.length - this._nextTextureLocation - 1;
            }
        } else {
            location = location || 0;
        }

        var gl = this.gl;
        var glTexture = texture._glTextures[this.CONTEXT_UID];

        if (!glTexture) {
            // this will also bind the texture..
            this.textureManager.updateTexture(texture, location);
        } else {
            // bind the current texture
            this.boundTextures[location] = texture;
            gl.activeTexture(gl.TEXTURE0 + location);
            gl.bindTexture(gl.TEXTURE_2D, glTexture.texture);
        }

        return location;
    };

    /**
    * unbinds the texture ...
    *
    * @param {PIXI.Texture} texture - the texture to unbind
    * @return {PIXI.WebGLRenderer} Returns itself.
    */


    WebGLRenderer.prototype.unbindTexture = function unbindTexture(texture) {
        var gl = this.gl;

        texture = texture.baseTexture || texture;

        if (this._unknownBoundTextures) {
            this._unknownBoundTextures = false;
            // someone changed webGL state,
            // we have to be sure that our texture does not appear in multitexture renderer samplers

            for (var i = 0; i < this.boundTextures.length; i++) {
                if (this.boundTextures[i] === this.emptyTextures[i]) {
                    gl.activeTexture(gl.TEXTURE0 + i);
                    gl.bindTexture(gl.TEXTURE_2D, this.emptyTextures[i]._glTextures[this.CONTEXT_UID].texture);
                }
            }
        }

        for (var _i = 0; _i < this.boundTextures.length; _i++) {
            if (this.boundTextures[_i] === texture) {
                this.boundTextures[_i] = this.emptyTextures[_i];

                gl.activeTexture(gl.TEXTURE0 + _i);
                gl.bindTexture(gl.TEXTURE_2D, this.emptyTextures[_i]._glTextures[this.CONTEXT_UID].texture);
            }
        }

        return this;
    };

    /**
     * Creates a new VAO from this renderer's context and state.
     *
     * @return {VertexArrayObject} The new VAO.
     */


    WebGLRenderer.prototype.createVao = function createVao() {
        return new _pixiGlCore2.default.VertexArrayObject(this.gl, this.state.attribState);
    };

    /**
     * Changes the current Vao to the one given in parameter
     *
     * @param {PIXI.VertexArrayObject} vao - the new Vao
     * @return {PIXI.WebGLRenderer} Returns itself.
     */


    WebGLRenderer.prototype.bindVao = function bindVao(vao) {
        if (this._activeVao === vao) {
            return this;
        }

        if (vao) {
            vao.bind();
        } else if (this._activeVao) {
            // TODO this should always be true i think?
            this._activeVao.unbind();
        }

        this._activeVao = vao;

        return this;
    };

    /**
     * Resets the WebGL state so you can render things however you fancy!
     *
     * @return {PIXI.WebGLRenderer} Returns itself.
     */


    WebGLRenderer.prototype.reset = function reset() {
        this.setObjectRenderer(this.emptyRenderer);

        this.bindVao(null);
        this._activeShader = null;
        this._activeRenderTarget = this.rootRenderTarget;

        this._unknownBoundTextures = true;

        for (var i = 0; i < this.boundTextures.length; i++) {
            this.boundTextures[i] = this.emptyTextures[i];
        }

        // bind the main frame buffer (the screen);
        this.rootRenderTarget.activate();

        this.state.resetToDefault();

        return this;
    };

    /**
     * Handles a lost webgl context
     *
     * @private
     * @param {WebGLContextEvent} event - The context lost event.
     */


    WebGLRenderer.prototype.handleContextLost = function handleContextLost(event) {
        event.preventDefault();
    };

    /**
     * Handles a restored webgl context
     *
     * @private
     */


    WebGLRenderer.prototype.handleContextRestored = function handleContextRestored() {
        this.textureManager.removeAll();
        this.filterManager.destroy(true);
        this._initContext();
    };

    /**
     * Removes everything from the renderer (event listeners, spritebatch, etc...)
     *
     * @param {boolean} [removeView=false] - Removes the Canvas element from the DOM.
     *  See: https://github.com/pixijs/pixi.js/issues/2233
     */


    WebGLRenderer.prototype.destroy = function destroy(removeView) {
        this.destroyPlugins();

        // remove listeners
        this.view.removeEventListener('webglcontextlost', this.handleContextLost);
        this.view.removeEventListener('webglcontextrestored', this.handleContextRestored);

        this.textureManager.destroy();

        // call base destroy
        _SystemRenderer.prototype.destroy.call(this, removeView);

        this.uid = 0;

        // destroy the managers
        this.maskManager.destroy();
        this.stencilManager.destroy();
        this.filterManager.destroy();

        this.maskManager = null;
        this.filterManager = null;
        this.textureManager = null;
        this.currentRenderer = null;

        this.handleContextLost = null;
        this.handleContextRestored = null;

        this._contextOptions = null;
        this.gl.useProgram(null);

        if (this.gl.getExtension('WEBGL_lose_context')) {
            this.gl.getExtension('WEBGL_lose_context').loseContext();
        }

        this.gl = null;

        // this = null;
    };

    return WebGLRenderer;
}(_SystemRenderer3.default);

/**
 * Collection of installed plugins. These are included by default in PIXI, but can be excluded
 * by creating a custom build. Consult the README for more information about creating custom
 * builds and excluding plugins.
 * @name PIXI.WebGLRenderer#plugins
 * @type {object}
 * @readonly
 * @property {PIXI.accessibility.AccessibilityManager} accessibility Support tabbing interactive elements.
 * @property {PIXI.extract.WebGLExtract} extract Extract image data from renderer.
 * @property {PIXI.interaction.InteractionManager} interaction Handles mouse, touch and pointer events.
 * @property {PIXI.prepare.WebGLPrepare} prepare Pre-render display objects.
 */

/**
 * Adds a plugin to the renderer.
 *
 * @method PIXI.WebGLRenderer#registerPlugin
 * @param {string} pluginName - The name of the plugin.
 * @param {Function} ctor - The constructor function or class for the plugin.
 */

exports.default = WebGLRenderer;
_utils.pluginTarget.mixin(WebGLRenderer);

},{"../../const":53,"../../textures/BaseTexture":119,"../../utils":132,"../SystemRenderer":83,"./TextureGarbageCollector":89,"./TextureManager":90,"./WebGLState":92,"./managers/FilterManager":97,"./managers/MaskManager":98,"./managers/StencilManager":99,"./utils/ObjectRenderer":101,"./utils/RenderTarget":103,"./utils/mapWebGLDrawModesToPixi":106,"./utils/validateContext":107,"pixi-gl-core":36}],92:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _mapWebGLBlendModesToPixi = require('./utils/mapWebGLBlendModesToPixi');

var _mapWebGLBlendModesToPixi2 = _interopRequireDefault(_mapWebGLBlendModesToPixi);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var BLEND = 0;
var DEPTH_TEST = 1;
var FRONT_FACE = 2;
var CULL_FACE = 3;
var BLEND_FUNC = 4;

/**
 * A WebGL state machines
 *
 * @memberof PIXI
 * @class
 */

var WebGLState = function () {
    /**
     * @param {WebGLRenderingContext} gl - The current WebGL rendering context
     */
    function WebGLState(gl) {
        _classCallCheck(this, WebGLState);

        /**
         * The current active state
         *
         * @member {Uint8Array}
         */
        this.activeState = new Uint8Array(16);

        /**
         * The default state
         *
         * @member {Uint8Array}
         */
        this.defaultState = new Uint8Array(16);

        // default blend mode..
        this.defaultState[0] = 1;

        /**
         * The current state index in the stack
         *
         * @member {number}
         * @private
         */
        this.stackIndex = 0;

        /**
         * The stack holding all the different states
         *
         * @member {Array<*>}
         * @private
         */
        this.stack = [];

        /**
         * The current WebGL rendering context
         *
         * @member {WebGLRenderingContext}
         */
        this.gl = gl;

        this.maxAttribs = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);

        this.attribState = {
            tempAttribState: new Array(this.maxAttribs),
            attribState: new Array(this.maxAttribs)
        };

        this.blendModes = (0, _mapWebGLBlendModesToPixi2.default)(gl);

        // check we have vao..
        this.nativeVaoExtension = gl.getExtension('OES_vertex_array_object') || gl.getExtension('MOZ_OES_vertex_array_object') || gl.getExtension('WEBKIT_OES_vertex_array_object');
    }

    /**
     * Pushes a new active state
     */


    WebGLState.prototype.push = function push() {
        // next state..
        var state = this.stack[this.stackIndex];

        if (!state) {
            state = this.stack[this.stackIndex] = new Uint8Array(16);
        }

        ++this.stackIndex;

        // copy state..
        // set active state so we can force overrides of gl state
        for (var i = 0; i < this.activeState.length; i++) {
            state[i] = this.activeState[i];
        }
    };

    /**
     * Pops a state out
     */


    WebGLState.prototype.pop = function pop() {
        var state = this.stack[--this.stackIndex];

        this.setState(state);
    };

    /**
     * Sets the current state
     *
     * @param {*} state - The state to set.
     */


    WebGLState.prototype.setState = function setState(state) {
        this.setBlend(state[BLEND]);
        this.setDepthTest(state[DEPTH_TEST]);
        this.setFrontFace(state[FRONT_FACE]);
        this.setCullFace(state[CULL_FACE]);
        this.setBlendMode(state[BLEND_FUNC]);
    };

    /**
     * Enables or disabled blending.
     *
     * @param {boolean} value - Turn on or off webgl blending.
     */


    WebGLState.prototype.setBlend = function setBlend(value) {
        value = value ? 1 : 0;

        if (this.activeState[BLEND] === value) {
            return;
        }

        this.activeState[BLEND] = value;
        this.gl[value ? 'enable' : 'disable'](this.gl.BLEND);
    };

    /**
     * Sets the blend mode.
     *
     * @param {number} value - The blend mode to set to.
     */


    WebGLState.prototype.setBlendMode = function setBlendMode(value) {
        if (value === this.activeState[BLEND_FUNC]) {
            return;
        }

        this.activeState[BLEND_FUNC] = value;

        var mode = this.blendModes[value];

        if (mode.length === 2) {
            this.gl.blendFunc(mode[0], mode[1]);
        } else {
            this.gl.blendFuncSeparate(mode[0], mode[1], mode[2], mode[3]);
        }
    };

    /**
     * Sets whether to enable or disable depth test.
     *
     * @param {boolean} value - Turn on or off webgl depth testing.
     */


    WebGLState.prototype.setDepthTest = function setDepthTest(value) {
        value = value ? 1 : 0;

        if (this.activeState[DEPTH_TEST] === value) {
            return;
        }

        this.activeState[DEPTH_TEST] = value;
        this.gl[value ? 'enable' : 'disable'](this.gl.DEPTH_TEST);
    };

    /**
     * Sets whether to enable or disable cull face.
     *
     * @param {boolean} value - Turn on or off webgl cull face.
     */


    WebGLState.prototype.setCullFace = function setCullFace(value) {
        value = value ? 1 : 0;

        if (this.activeState[CULL_FACE] === value) {
            return;
        }

        this.activeState[CULL_FACE] = value;
        this.gl[value ? 'enable' : 'disable'](this.gl.CULL_FACE);
    };

    /**
     * Sets the gl front face.
     *
     * @param {boolean} value - true is clockwise and false is counter-clockwise
     */


    WebGLState.prototype.setFrontFace = function setFrontFace(value) {
        value = value ? 1 : 0;

        if (this.activeState[FRONT_FACE] === value) {
            return;
        }

        this.activeState[FRONT_FACE] = value;
        this.gl.frontFace(this.gl[value ? 'CW' : 'CCW']);
    };

    /**
     * Disables all the vaos in use
     *
     */


    WebGLState.prototype.resetAttributes = function resetAttributes() {
        for (var i = 0; i < this.attribState.tempAttribState.length; i++) {
            this.attribState.tempAttribState[i] = 0;
        }

        for (var _i = 0; _i < this.attribState.attribState.length; _i++) {
            this.attribState.attribState[_i] = 0;
        }

        // im going to assume one is always active for performance reasons.
        for (var _i2 = 1; _i2 < this.maxAttribs; _i2++) {
            this.gl.disableVertexAttribArray(_i2);
        }
    };

    // used
    /**
     * Resets all the logic and disables the vaos
     */


    WebGLState.prototype.resetToDefault = function resetToDefault() {
        // unbind any VAO if they exist..
        if (this.nativeVaoExtension) {
            this.nativeVaoExtension.bindVertexArrayOES(null);
        }

        // reset all attributes..
        this.resetAttributes();

        // set active state so we can force overrides of gl state
        for (var i = 0; i < this.activeState.length; ++i) {
            this.activeState[i] = 32;
        }

        this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, false);

        this.setState(this.defaultState);
    };

    return WebGLState;
}();

exports.default = WebGLState;

},{"./utils/mapWebGLBlendModesToPixi":105}],93:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _extractUniformsFromSrc = require('./extractUniformsFromSrc');

var _extractUniformsFromSrc2 = _interopRequireDefault(_extractUniformsFromSrc);

var _utils = require('../../../utils');

var _const = require('../../../const');

var _settings = require('../../../settings');

var _settings2 = _interopRequireDefault(_settings);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SOURCE_KEY_MAP = {};

// let math = require('../../../math');
/**
 * @class
 * @memberof PIXI
 * @extends PIXI.Shader
 */

var Filter = function () {
  /**
   * @param {string} [vertexSrc] - The source of the vertex shader.
   * @param {string} [fragmentSrc] - The source of the fragment shader.
   * @param {object} [uniformData] - Custom uniforms to use to augment the built-in ones.
   */
  function Filter(vertexSrc, fragmentSrc, uniformData) {
    _classCallCheck(this, Filter);

    /**
     * The vertex shader.
     *
     * @member {string}
     */
    this.vertexSrc = vertexSrc || Filter.defaultVertexSrc;

    /**
     * The fragment shader.
     *
     * @member {string}
     */
    this.fragmentSrc = fragmentSrc || Filter.defaultFragmentSrc;

    this._blendMode = _const.BLEND_MODES.NORMAL;

    this.uniformData = uniformData || (0, _extractUniformsFromSrc2.default)(this.vertexSrc, this.fragmentSrc, 'projectionMatrix|uSampler');

    /**
     * An object containing the current values of custom uniforms.
     * @example <caption>Updating the value of a custom uniform</caption>
     * filter.uniforms.time = performance.now();
     *
     * @member {object}
     */
    this.uniforms = {};

    for (var i in this.uniformData) {
      this.uniforms[i] = this.uniformData[i].value;
      if (this.uniformData[i].type) {
        this.uniformData[i].type = this.uniformData[i].type.toLowerCase();
      }
    }

    // this is where we store shader references..
    // TODO we could cache this!
    this.glShaders = {};

    // used for caching.. sure there is a better way!
    if (!SOURCE_KEY_MAP[this.vertexSrc + this.fragmentSrc]) {
      SOURCE_KEY_MAP[this.vertexSrc + this.fragmentSrc] = (0, _utils.uid)();
    }

    this.glShaderKey = SOURCE_KEY_MAP[this.vertexSrc + this.fragmentSrc];

    /**
     * The padding of the filter. Some filters require extra space to breath such as a blur.
     * Increasing this will add extra width and height to the bounds of the object that the
     * filter is applied to.
     *
     * @member {number}
     */
    this.padding = 4;

    /**
     * The resolution of the filter. Setting this to be lower will lower the quality but
     * increase the performance of the filter.
     *
     * @member {number}
     */
    this.resolution = _settings2.default.FILTER_RESOLUTION;

    /**
     * If enabled is true the filter is applied, if false it will not.
     *
     * @member {boolean}
     */
    this.enabled = true;

    /**
     * If enabled, PixiJS will fit the filter area into boundaries for better performance.
     * Switch it off if it does not work for specific shader.
     *
     * @member {boolean}
     */
    this.autoFit = true;
  }

  /**
   * Applies the filter
   *
   * @param {PIXI.FilterManager} filterManager - The renderer to retrieve the filter from
   * @param {PIXI.RenderTarget} input - The input render target.
   * @param {PIXI.RenderTarget} output - The target to output to.
   * @param {boolean} clear - Should the output be cleared before rendering to it
   * @param {object} [currentState] - It's current state of filter.
   *        There are some useful properties in the currentState :
   *        target, filters, sourceFrame, destinationFrame, renderTarget, resolution
   */


  Filter.prototype.apply = function apply(filterManager, input, output, clear, currentState) // eslint-disable-line no-unused-vars
  {
    // --- //
    //  this.uniforms.filterMatrix = filterManager.calculateSpriteMatrix(tempMatrix, window.panda );

    // do as you please!

    filterManager.applyFilter(this, input, output, clear);

    // or just do a regular render..
  };

  /**
   * Sets the blendmode of the filter
   *
   * @member {number}
   * @default PIXI.BLEND_MODES.NORMAL
   */


  _createClass(Filter, [{
    key: 'blendMode',
    get: function get() {
      return this._blendMode;
    },
    set: function set(value) // eslint-disable-line require-jsdoc
    {
      this._blendMode = value;
    }

    /**
     * The default vertex shader source
     *
     * @static
     * @constant
     */

  }], [{
    key: 'defaultVertexSrc',
    get: function get() {
      return ['attribute vec2 aVertexPosition;', 'attribute vec2 aTextureCoord;', 'uniform mat3 projectionMatrix;', 'uniform mat3 filterMatrix;', 'varying vec2 vTextureCoord;', 'varying vec2 vFilterCoord;', 'void main(void){', '   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);', '   vFilterCoord = ( filterMatrix * vec3( aTextureCoord, 1.0)  ).xy;', '   vTextureCoord = aTextureCoord ;', '}'].join('\n');
    }

    /**
     * The default fragment shader source
     *
     * @static
     * @constant
     */

  }, {
    key: 'defaultFragmentSrc',
    get: function get() {
      return ['varying vec2 vTextureCoord;', 'varying vec2 vFilterCoord;', 'uniform sampler2D uSampler;', 'uniform sampler2D filterSampler;', 'void main(void){', '   vec4 masky = texture2D(filterSampler, vFilterCoord);', '   vec4 sample = texture2D(uSampler, vTextureCoord);', '   vec4 color;', '   if(mod(vFilterCoord.x, 1.0) > 0.5)', '   {', '     color = vec4(1.0, 0.0, 0.0, 1.0);', '   }', '   else', '   {', '     color = vec4(0.0, 1.0, 0.0, 1.0);', '   }',
      // '   gl_FragColor = vec4(mod(vFilterCoord.x, 1.5), vFilterCoord.y,0.0,1.0);',
      '   gl_FragColor = mix(sample, masky, 0.5);', '   gl_FragColor *= sample.a;', '}'].join('\n');
    }
  }]);

  return Filter;
}();

exports.default = Filter;

},{"../../../const":53,"../../../settings":108,"../../../utils":132,"./extractUniformsFromSrc":94}],94:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.default = extractUniformsFromSrc;

var _pixiGlCore = require('pixi-gl-core');

var _pixiGlCore2 = _interopRequireDefault(_pixiGlCore);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var defaultValue = _pixiGlCore2.default.shader.defaultValue;

function extractUniformsFromSrc(vertexSrc, fragmentSrc, mask) {
    var vertUniforms = extractUniformsFromString(vertexSrc, mask);
    var fragUniforms = extractUniformsFromString(fragmentSrc, mask);

    return Object.assign(vertUniforms, fragUniforms);
}

function extractUniformsFromString(string) {
    var maskRegex = new RegExp('^(projectionMatrix|uSampler|filterArea|filterClamp)$');

    var uniforms = {};
    var nameSplit = void 0;

    // clean the lines a little - remove extra spaces / tabs etc
    // then split along ';'
    var lines = string.replace(/\s+/g, ' ').split(/\s*;\s*/);

    // loop through..
    for (var i = 0; i < lines.length; i++) {
        var line = lines[i].trim();

        if (line.indexOf('uniform') > -1) {
            var splitLine = line.split(' ');
            var type = splitLine[1];

            var name = splitLine[2];
            var size = 1;

            if (name.indexOf('[') > -1) {
                // array!
                nameSplit = name.split(/\[|]/);
                name = nameSplit[0];
                size *= Number(nameSplit[1]);
            }

            if (!name.match(maskRegex)) {
                uniforms[name] = {
                    value: defaultValue(type, size),
                    name: name,
                    type: type
                };
            }
        }
    }

    return uniforms;
}

},{"pixi-gl-core":36}],95:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.calculateScreenSpaceMatrix = calculateScreenSpaceMatrix;
exports.calculateNormalizedScreenSpaceMatrix = calculateNormalizedScreenSpaceMatrix;
exports.calculateSpriteMatrix = calculateSpriteMatrix;

var _math = require('../../../math');

/**
 * Calculates the mapped matrix
 * @param filterArea {Rectangle} The filter area
 * @param sprite {Sprite} the target sprite
 * @param outputMatrix {Matrix} @alvin
 * @private
 */
// TODO playing around here.. this is temporary - (will end up in the shader)
// this returns a matrix that will normalise map filter cords in the filter to screen space
function calculateScreenSpaceMatrix(outputMatrix, filterArea, textureSize) {
    // let worldTransform = sprite.worldTransform.copy(Matrix.TEMP_MATRIX),
    // let texture = {width:1136, height:700};//sprite._texture.baseTexture;

    // TODO unwrap?
    var mappedMatrix = outputMatrix.identity();

    mappedMatrix.translate(filterArea.x / textureSize.width, filterArea.y / textureSize.height);

    mappedMatrix.scale(textureSize.width, textureSize.height);

    return mappedMatrix;
}

function calculateNormalizedScreenSpaceMatrix(outputMatrix, filterArea, textureSize) {
    var mappedMatrix = outputMatrix.identity();

    mappedMatrix.translate(filterArea.x / textureSize.width, filterArea.y / textureSize.height);

    var translateScaleX = textureSize.width / filterArea.width;
    var translateScaleY = textureSize.height / filterArea.height;

    mappedMatrix.scale(translateScaleX, translateScaleY);

    return mappedMatrix;
}

// this will map the filter coord so that a texture can be used based on the transform of a sprite
function calculateSpriteMatrix(outputMatrix, filterArea, textureSize, sprite) {
    var orig = sprite._texture.orig;
    var mappedMatrix = outputMatrix.set(textureSize.width, 0, 0, textureSize.height, filterArea.x, filterArea.y);
    var worldTransform = sprite.worldTransform.copy(_math.Matrix.TEMP_MATRIX);

    worldTransform.invert();
    mappedMatrix.prepend(worldTransform);
    mappedMatrix.scale(1.0 / orig.width, 1.0 / orig.height);
    mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);

    return mappedMatrix;
}

},{"../../../math":77}],96:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _Filter2 = require('../Filter');

var _Filter3 = _interopRequireDefault(_Filter2);

var _math = require('../../../../math');

var _path = require('path');

var _TextureMatrix = require('../../../../textures/TextureMatrix');

var _TextureMatrix2 = _interopRequireDefault(_TextureMatrix);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The SpriteMaskFilter class
 *
 * @class
 * @extends PIXI.Filter
 * @memberof PIXI
 */
var SpriteMaskFilter = function (_Filter) {
    _inherits(SpriteMaskFilter, _Filter);

    /**
     * @param {PIXI.Sprite} sprite - the target sprite
     */
    function SpriteMaskFilter(sprite) {
        _classCallCheck(this, SpriteMaskFilter);

        var maskMatrix = new _math.Matrix();

        var _this = _possibleConstructorReturn(this, _Filter.call(this, 'attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 otherMatrix;\n\nvarying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\n}\n', 'varying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform sampler2D mask;\nuniform float alpha;\nuniform vec4 maskClamp;\n\nvoid main(void)\n{\n    float clip = step(3.5,\n        step(maskClamp.x, vMaskCoord.x) +\n        step(maskClamp.y, vMaskCoord.y) +\n        step(vMaskCoord.x, maskClamp.z) +\n        step(vMaskCoord.y, maskClamp.w));\n\n    vec4 original = texture2D(uSampler, vTextureCoord);\n    vec4 masky = texture2D(mask, vMaskCoord);\n\n    original *= (masky.r * masky.a * alpha * clip);\n\n    gl_FragColor = original;\n}\n'));

        sprite.renderable = false;

        _this.maskSprite = sprite;
        _this.maskMatrix = maskMatrix;
        return _this;
    }

    /**
     * Applies the filter
     *
     * @param {PIXI.FilterManager} filterManager - The renderer to retrieve the filter from
     * @param {PIXI.RenderTarget} input - The input render target.
     * @param {PIXI.RenderTarget} output - The target to output to.
     * @param {boolean} clear - Should the output be cleared before rendering to it
     */


    SpriteMaskFilter.prototype.apply = function apply(filterManager, input, output, clear) {
        var maskSprite = this.maskSprite;
        var tex = this.maskSprite.texture;

        if (!tex.valid) {
            return;
        }
        if (!tex.transform) {
            // margin = 0.0, let it bleed a bit, shader code becomes easier
            // assuming that atlas textures were made with 1-pixel padding
            tex.transform = new _TextureMatrix2.default(tex, 0.0);
        }
        tex.transform.update();

        this.uniforms.mask = tex;
        this.uniforms.otherMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, maskSprite).prepend(tex.transform.mapCoord);
        this.uniforms.alpha = maskSprite.worldAlpha;
        this.uniforms.maskClamp = tex.transform.uClampFrame;

        filterManager.applyFilter(this, input, output, clear);
    };

    return SpriteMaskFilter;
}(_Filter3.default);

exports.default = SpriteMaskFilter;

},{"../../../../math":77,"../../../../textures/TextureMatrix":123,"../Filter":93,"path":1}],97:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _WebGLManager2 = require('./WebGLManager');

var _WebGLManager3 = _interopRequireDefault(_WebGLManager2);

var _RenderTarget = require('../utils/RenderTarget');

var _RenderTarget2 = _interopRequireDefault(_RenderTarget);

var _Quad = require('../utils/Quad');

var _Quad2 = _interopRequireDefault(_Quad);

var _math = require('../../../math');

var _Shader = require('../../../Shader');

var _Shader2 = _interopRequireDefault(_Shader);

var _filterTransforms = require('../filters/filterTransforms');

var filterTransforms = _interopRequireWildcard(_filterTransforms);

var _bitTwiddle = require('bit-twiddle');

var _bitTwiddle2 = _interopRequireDefault(_bitTwiddle);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @ignore
 * @class
 */
var FilterState = function () {
    /**
     *
     */
    function FilterState() {
        _classCallCheck(this, FilterState);

        this.renderTarget = null;
        this.target = null;
        this.resolution = 1;

        // those three objects are used only for root
        // re-assigned for everything else
        this.sourceFrame = new _math.Rectangle();
        this.destinationFrame = new _math.Rectangle();
        this.filters = [];
    }

    /**
     * clears the state
     */


    FilterState.prototype.clear = function clear() {
        this.filters = null;
        this.target = null;
        this.renderTarget = null;
    };

    return FilterState;
}();

var screenKey = 'screen';

/**
 * @class
 * @memberof PIXI
 * @extends PIXI.WebGLManager
 */

var FilterManager = function (_WebGLManager) {
    _inherits(FilterManager, _WebGLManager);

    /**
     * @param {PIXI.WebGLRenderer} renderer - The renderer this manager works for.
     */
    function FilterManager(renderer) {
        _classCallCheck(this, FilterManager);

        var _this = _possibleConstructorReturn(this, _WebGLManager.call(this, renderer));

        _this.gl = _this.renderer.gl;
        // know about sprites!
        _this.quad = new _Quad2.default(_this.gl, renderer.state.attribState);

        _this.shaderCache = {};
        // todo add default!
        _this.pool = {};

        _this.filterData = null;

        _this.managedFilters = [];

        _this.renderer.on('prerender', _this.onPrerender, _this);

        _this._screenWidth = renderer.view.width;
        _this._screenHeight = renderer.view.height;
        return _this;
    }

    /**
     * Adds a new filter to the manager.
     *
     * @param {PIXI.DisplayObject} target - The target of the filter to render.
     * @param {PIXI.Filter[]} filters - The filters to apply.
     */


    FilterManager.prototype.pushFilter = function pushFilter(target, filters) {
        var renderer = this.renderer;

        var filterData = this.filterData;

        if (!filterData) {
            filterData = this.renderer._activeRenderTarget.filterStack;

            // add new stack
            var filterState = new FilterState();

            filterState.sourceFrame = filterState.destinationFrame = this.renderer._activeRenderTarget.size;
            filterState.renderTarget = renderer._activeRenderTarget;

            this.renderer._activeRenderTarget.filterData = filterData = {
                index: 0,
                stack: [filterState]
            };

            this.filterData = filterData;
        }

        // get the current filter state..
        var currentState = filterData.stack[++filterData.index];
        var renderTargetFrame = filterData.stack[0].destinationFrame;

        if (!currentState) {
            currentState = filterData.stack[filterData.index] = new FilterState();
        }

        var fullScreen = target.filterArea && target.filterArea.x === 0 && target.filterArea.y === 0 && target.filterArea.width === renderer.screen.width && target.filterArea.height === renderer.screen.height;

        // for now we go off the filter of the first resolution..
        var resolution = filters[0].resolution;
        var padding = filters[0].padding | 0;
        var targetBounds = fullScreen ? renderer.screen : target.filterArea || target.getBounds(true);
        var sourceFrame = currentState.sourceFrame;
        var destinationFrame = currentState.destinationFrame;

        sourceFrame.x = (targetBounds.x * resolution | 0) / resolution;
        sourceFrame.y = (targetBounds.y * resolution | 0) / resolution;
        sourceFrame.width = (targetBounds.width * resolution | 0) / resolution;
        sourceFrame.height = (targetBounds.height * resolution | 0) / resolution;

        if (!fullScreen) {
            if (filterData.stack[0].renderTarget.transform) {//

                // TODO we should fit the rect around the transform..
            } else if (filters[0].autoFit) {
                sourceFrame.fit(renderTargetFrame);
            }

            // lets apply the padding After we fit the element to the screen.
            // this should stop the strange side effects that can occur when cropping to the edges
            sourceFrame.pad(padding);
        }

        destinationFrame.width = sourceFrame.width;
        destinationFrame.height = sourceFrame.height;

        // lets play the padding after we fit the element to the screen.
        // this should stop the strange side effects that can occur when cropping to the edges

        var renderTarget = this.getPotRenderTarget(renderer.gl, sourceFrame.width, sourceFrame.height, resolution);

        currentState.target = target;
        currentState.filters = filters;
        currentState.resolution = resolution;
        currentState.renderTarget = renderTarget;

        // bind the render target to draw the shape in the top corner..

        renderTarget.setFrame(destinationFrame, sourceFrame);

        // bind the render target
        renderer.bindRenderTarget(renderTarget);
        renderTarget.clear();
    };

    /**
     * Pops off the filter and applies it.
     *
     */


    FilterManager.prototype.popFilter = function popFilter() {
        var filterData = this.filterData;

        var lastState = filterData.stack[filterData.index - 1];
        var currentState = filterData.stack[filterData.index];

        this.quad.map(currentState.renderTarget.size, currentState.sourceFrame).upload();

        var filters = currentState.filters;

        if (filters.length === 1) {
            filters[0].apply(this, currentState.renderTarget, lastState.renderTarget, false, currentState);
            this.freePotRenderTarget(currentState.renderTarget);
        } else {
            var flip = currentState.renderTarget;
            var flop = this.getPotRenderTarget(this.renderer.gl, currentState.sourceFrame.width, currentState.sourceFrame.height, currentState.resolution);

            flop.setFrame(currentState.destinationFrame, currentState.sourceFrame);

            // finally lets clear the render target before drawing to it..
            flop.clear();

            var i = 0;

            for (i = 0; i < filters.length - 1; ++i) {
                filters[i].apply(this, flip, flop, true, currentState);

                var t = flip;

                flip = flop;
                flop = t;
            }

            filters[i].apply(this, flip, lastState.renderTarget, false, currentState);

            this.freePotRenderTarget(flip);
            this.freePotRenderTarget(flop);
        }

        currentState.clear();
        filterData.index--;

        if (filterData.index === 0) {
            this.filterData = null;
        }
    };

    /**
     * Draws a filter.
     *
     * @param {PIXI.Filter} filter - The filter to draw.
     * @param {PIXI.RenderTarget} input - The input render target.
     * @param {PIXI.RenderTarget} output - The target to output to.
     * @param {boolean} clear - Should the output be cleared before rendering to it
     */


    FilterManager.prototype.applyFilter = function applyFilter(filter, input, output, clear) {
        var renderer = this.renderer;
        var gl = renderer.gl;

        var shader = filter.glShaders[renderer.CONTEXT_UID];

        // caching..
        if (!shader) {
            if (filter.glShaderKey) {
                shader = this.shaderCache[filter.glShaderKey];

                if (!shader) {
                    shader = new _Shader2.default(this.gl, filter.vertexSrc, filter.fragmentSrc);

                    filter.glShaders[renderer.CONTEXT_UID] = this.shaderCache[filter.glShaderKey] = shader;
                    this.managedFilters.push(filter);
                }
            } else {
                shader = filter.glShaders[renderer.CONTEXT_UID] = new _Shader2.default(this.gl, filter.vertexSrc, filter.fragmentSrc);
                this.managedFilters.push(filter);
            }

            // TODO - this only needs to be done once?
            renderer.bindVao(null);

            this.quad.initVao(shader);
        }

        renderer.bindVao(this.quad.vao);

        renderer.bindRenderTarget(output);

        if (clear) {
            gl.disable(gl.SCISSOR_TEST);
            renderer.clear(); // [1, 1, 1, 1]);
            gl.enable(gl.SCISSOR_TEST);
        }

        // in case the render target is being masked using a scissor rect
        if (output === renderer.maskManager.scissorRenderTarget) {
            renderer.maskManager.pushScissorMask(null, renderer.maskManager.scissorData);
        }

        renderer.bindShader(shader);

        // free unit 0 for us, doesn't matter what was there
        // don't try to restore it, because syncUniforms can upload it to another slot
        // and it'll be a problem
        var tex = this.renderer.emptyTextures[0];

        this.renderer.boundTextures[0] = tex;
        // this syncs the PixiJS filters  uniforms with glsl uniforms
        this.syncUniforms(shader, filter);

        renderer.state.setBlendMode(filter.blendMode);

        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, input.texture.texture);

        this.quad.vao.draw(this.renderer.gl.TRIANGLES, 6, 0);

        gl.bindTexture(gl.TEXTURE_2D, tex._glTextures[this.renderer.CONTEXT_UID].texture);
    };

    /**
     * Uploads the uniforms of the filter.
     *
     * @param {GLShader} shader - The underlying gl shader.
     * @param {PIXI.Filter} filter - The filter we are synchronizing.
     */


    FilterManager.prototype.syncUniforms = function syncUniforms(shader, filter) {
        var uniformData = filter.uniformData;
        var uniforms = filter.uniforms;

        // 0 is reserved for the PixiJS texture so we start at 1!
        var textureCount = 1;
        var currentState = void 0;

        // filterArea and filterClamp that are handled by FilterManager directly
        // they must not appear in uniformData

        if (shader.uniforms.filterArea) {
            currentState = this.filterData.stack[this.filterData.index];

            var filterArea = shader.uniforms.filterArea;

            filterArea[0] = currentState.renderTarget.size.width;
            filterArea[1] = currentState.renderTarget.size.height;
            filterArea[2] = currentState.sourceFrame.x;
            filterArea[3] = currentState.sourceFrame.y;

            shader.uniforms.filterArea = filterArea;
        }

        // use this to clamp displaced texture coords so they belong to filterArea
        // see displacementFilter fragment shader for an example
        if (shader.uniforms.filterClamp) {
            currentState = currentState || this.filterData.stack[this.filterData.index];

            var filterClamp = shader.uniforms.filterClamp;

            filterClamp[0] = 0;
            filterClamp[1] = 0;
            filterClamp[2] = (currentState.sourceFrame.width - 1) / currentState.renderTarget.size.width;
            filterClamp[3] = (currentState.sourceFrame.height - 1) / currentState.renderTarget.size.height;

            shader.uniforms.filterClamp = filterClamp;
        }

        // TODO Caching layer..
        for (var i in uniformData) {
            if (!shader.uniforms.data[i]) {
                continue;
            }

            var type = uniformData[i].type;

            if (type === 'sampler2d' && uniforms[i] !== 0) {
                if (uniforms[i].baseTexture) {
                    shader.uniforms[i] = this.renderer.bindTexture(uniforms[i].baseTexture, textureCount);
                } else {
                    shader.uniforms[i] = textureCount;

                    // TODO
                    // this is helpful as renderTargets can also be set.
                    // Although thinking about it, we could probably
                    // make the filter texture cache return a RenderTexture
                    // rather than a renderTarget
                    var gl = this.renderer.gl;

                    this.renderer.boundTextures[textureCount] = this.renderer.emptyTextures[textureCount];
                    gl.activeTexture(gl.TEXTURE0 + textureCount);

                    uniforms[i].texture.bind();
                }

                textureCount++;
            } else if (type === 'mat3') {
                // check if its PixiJS matrix..
                if (uniforms[i].a !== undefined) {
                    shader.uniforms[i] = uniforms[i].toArray(true);
                } else {
                    shader.uniforms[i] = uniforms[i];
                }
            } else if (type === 'vec2') {
                // check if its a point..
                if (uniforms[i].x !== undefined) {
                    var val = shader.uniforms[i] || new Float32Array(2);

                    val[0] = uniforms[i].x;
                    val[1] = uniforms[i].y;
                    shader.uniforms[i] = val;
                } else {
                    shader.uniforms[i] = uniforms[i];
                }
            } else if (type === 'float') {
                if (shader.uniforms.data[i].value !== uniformData[i]) {
                    shader.uniforms[i] = uniforms[i];
                }
            } else {
                shader.uniforms[i] = uniforms[i];
            }
        }
    };

    /**
     * Gets a render target from the pool, or creates a new one.
     *
     * @param {boolean} clear - Should we clear the render texture when we get it?
     * @param {number} resolution - The resolution of the target.
     * @return {PIXI.RenderTarget} The new render target
     */


    FilterManager.prototype.getRenderTarget = function getRenderTarget(clear, resolution) {
        var currentState = this.filterData.stack[this.filterData.index];
        var renderTarget = this.getPotRenderTarget(this.renderer.gl, currentState.sourceFrame.width, currentState.sourceFrame.height, resolution || currentState.resolution);

        renderTarget.setFrame(currentState.destinationFrame, currentState.sourceFrame);

        return renderTarget;
    };

    /**
     * Returns a render target to the pool.
     *
     * @param {PIXI.RenderTarget} renderTarget - The render target to return.
     */


    FilterManager.prototype.returnRenderTarget = function returnRenderTarget(renderTarget) {
        this.freePotRenderTarget(renderTarget);
    };

    /**
     * Calculates the mapped matrix.
     *
     * TODO playing around here.. this is temporary - (will end up in the shader)
     * this returns a matrix that will normalise map filter cords in the filter to screen space
     *
     * @param {PIXI.Matrix} outputMatrix - the matrix to output to.
     * @return {PIXI.Matrix} The mapped matrix.
     */


    FilterManager.prototype.calculateScreenSpaceMatrix = function calculateScreenSpaceMatrix(outputMatrix) {
        var currentState = this.filterData.stack[this.filterData.index];

        return filterTransforms.calculateScreenSpaceMatrix(outputMatrix, currentState.sourceFrame, currentState.renderTarget.size);
    };

    /**
     * Multiply vTextureCoord to this matrix to achieve (0,0,1,1) for filterArea
     *
     * @param {PIXI.Matrix} outputMatrix - The matrix to output to.
     * @return {PIXI.Matrix} The mapped matrix.
     */


    FilterManager.prototype.calculateNormalizedScreenSpaceMatrix = function calculateNormalizedScreenSpaceMatrix(outputMatrix) {
        var currentState = this.filterData.stack[this.filterData.index];

        return filterTransforms.calculateNormalizedScreenSpaceMatrix(outputMatrix, currentState.sourceFrame, currentState.renderTarget.size, currentState.destinationFrame);
    };

    /**
     * This will map the filter coord so that a texture can be used based on the transform of a sprite
     *
     * @param {PIXI.Matrix} outputMatrix - The matrix to output to.
     * @param {PIXI.Sprite} sprite - The sprite to map to.
     * @return {PIXI.Matrix} The mapped matrix.
     */


    FilterManager.prototype.calculateSpriteMatrix = function calculateSpriteMatrix(outputMatrix, sprite) {
        var currentState = this.filterData.stack[this.filterData.index];

        return filterTransforms.calculateSpriteMatrix(outputMatrix, currentState.sourceFrame, currentState.renderTarget.size, sprite);
    };

    /**
     * Destroys this Filter Manager.
     *
     * @param {boolean} [contextLost=false] context was lost, do not free shaders
     *
     */


    FilterManager.prototype.destroy = function destroy() {
        var contextLost = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

        var renderer = this.renderer;
        var filters = this.managedFilters;

        renderer.off('prerender', this.onPrerender, this);

        for (var i = 0; i < filters.length; i++) {
            if (!contextLost) {
                filters[i].glShaders[renderer.CONTEXT_UID].destroy();
            }
            delete filters[i].glShaders[renderer.CONTEXT_UID];
        }

        this.shaderCache = {};
        if (!contextLost) {
            this.emptyPool();
        } else {
            this.pool = {};
        }
    };

    /**
     * Gets a Power-of-Two render texture.
     *
     * TODO move to a separate class could be on renderer?
     * also - could cause issue with multiple contexts?
     *
     * @private
     * @param {WebGLRenderingContext} gl - The webgl rendering context
     * @param {number} minWidth - The minimum width of the render target.
     * @param {number} minHeight - The minimum height of the render target.
     * @param {number} resolution - The resolution of the render target.
     * @return {PIXI.RenderTarget} The new render target.
     */


    FilterManager.prototype.getPotRenderTarget = function getPotRenderTarget(gl, minWidth, minHeight, resolution) {
        var key = screenKey;

        minWidth *= resolution;
        minHeight *= resolution;

        if (minWidth !== this._screenWidth || minHeight !== this._screenHeight) {
            // TODO you could return a bigger texture if there is not one in the pool?
            minWidth = _bitTwiddle2.default.nextPow2(minWidth);
            minHeight = _bitTwiddle2.default.nextPow2(minHeight);
            key = (minWidth & 0xFFFF) << 16 | minHeight & 0xFFFF;
        }

        if (!this.pool[key]) {
            this.pool[key] = [];
        }

        var renderTarget = this.pool[key].pop();

        // creating render target will cause texture to be bound!
        if (!renderTarget) {
            // temporary bypass cache..
            var tex = this.renderer.boundTextures[0];

            gl.activeTexture(gl.TEXTURE0);

            // internally - this will cause a texture to be bound..
            renderTarget = new _RenderTarget2.default(gl, minWidth, minHeight, null, 1);

            // set the current one back
            gl.bindTexture(gl.TEXTURE_2D, tex._glTextures[this.renderer.CONTEXT_UID].texture);
        }

        // manually tweak the resolution...
        // this will not modify the size of the frame buffer, just its resolution.
        renderTarget.resolution = resolution;
        renderTarget.defaultFrame.width = renderTarget.size.width = minWidth / resolution;
        renderTarget.defaultFrame.height = renderTarget.size.height = minHeight / resolution;
        renderTarget.filterPoolKey = key;

        return renderTarget;
    };

    /**
     * Empties the texture pool.
     *
     */


    FilterManager.prototype.emptyPool = function emptyPool() {
        for (var i in this.pool) {
            var textures = this.pool[i];

            if (textures) {
                for (var j = 0; j < textures.length; j++) {
                    textures[j].destroy(true);
                }
            }
        }

        this.pool = {};
    };

    /**
     * Frees a render target back into the pool.
     *
     * @param {PIXI.RenderTarget} renderTarget - The renderTarget to free
     */


    FilterManager.prototype.freePotRenderTarget = function freePotRenderTarget(renderTarget) {
        this.pool[renderTarget.filterPoolKey].push(renderTarget);
    };

    /**
     * Called before the renderer starts rendering.
     *
     */


    FilterManager.prototype.onPrerender = function onPrerender() {
        if (this._screenWidth !== this.renderer.view.width || this._screenHeight !== this.renderer.view.height) {
            this._screenWidth = this.renderer.view.width;
            this._screenHeight = this.renderer.view.height;

            var textures = this.pool[screenKey];

            if (textures) {
                for (var j = 0; j < textures.length; j++) {
                    textures[j].destroy(true);
                }
            }
            this.pool[screenKey] = [];
        }
    };

    return FilterManager;
}(_WebGLManager3.default);

exports.default = FilterManager;

},{"../../../Shader":51,"../../../math":77,"../filters/filterTransforms":95,"../utils/Quad":102,"../utils/RenderTarget":103,"./WebGLManager":100,"bit-twiddle":22}],98:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _WebGLManager2 = require('./WebGLManager');

var _WebGLManager3 = _interopRequireDefault(_WebGLManager2);

var _SpriteMaskFilter = require('../filters/spriteMask/SpriteMaskFilter');

var _SpriteMaskFilter2 = _interopRequireDefault(_SpriteMaskFilter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class
 * @extends PIXI.WebGLManager
 * @memberof PIXI
 */
var MaskManager = function (_WebGLManager) {
    _inherits(MaskManager, _WebGLManager);

    /**
     * @param {PIXI.WebGLRenderer} renderer - The renderer this manager works for.
     */
    function MaskManager(renderer) {
        _classCallCheck(this, MaskManager);

        // TODO - we don't need both!
        var _this = _possibleConstructorReturn(this, _WebGLManager.call(this, renderer));

        _this.scissor = false;
        _this.scissorData = null;
        _this.scissorRenderTarget = null;

        _this.enableScissor = true;

        _this.alphaMaskPool = [];
        _this.alphaMaskIndex = 0;
        return _this;
    }

    /**
     * Applies the Mask and adds it to the current filter stack.
     *
     * @param {PIXI.DisplayObject} target - Display Object to push the mask to
     * @param {PIXI.Sprite|PIXI.Graphics} maskData - The masking data.
     */


    MaskManager.prototype.pushMask = function pushMask(target, maskData) {
        // TODO the root check means scissor rect will not
        // be used on render textures more info here:
        // https://github.com/pixijs/pixi.js/pull/3545

        if (maskData.texture) {
            this.pushSpriteMask(target, maskData);
        } else if (this.enableScissor && !this.scissor && this.renderer._activeRenderTarget.root && !this.renderer.stencilManager.stencilMaskStack.length && maskData.isFastRect()) {
            var matrix = maskData.worldTransform;

            var rot = Math.atan2(matrix.b, matrix.a);

            // use the nearest degree!
            rot = Math.round(rot * (180 / Math.PI));

            if (rot % 90) {
                this.pushStencilMask(maskData);
            } else {
                this.pushScissorMask(target, maskData);
            }
        } else {
            this.pushStencilMask(maskData);
        }
    };

    /**
     * Removes the last mask from the mask stack and doesn't return it.
     *
     * @param {PIXI.DisplayObject} target - Display Object to pop the mask from
     * @param {PIXI.Sprite|PIXI.Graphics} maskData - The masking data.
     */


    MaskManager.prototype.popMask = function popMask(target, maskData) {
        if (maskData.texture) {
            this.popSpriteMask(target, maskData);
        } else if (this.enableScissor && !this.renderer.stencilManager.stencilMaskStack.length) {
            this.popScissorMask(target, maskData);
        } else {
            this.popStencilMask(target, maskData);
        }
    };

    /**
     * Applies the Mask and adds it to the current filter stack.
     *
     * @param {PIXI.RenderTarget} target - Display Object to push the sprite mask to
     * @param {PIXI.Sprite} maskData - Sprite to be used as the mask
     */


    MaskManager.prototype.pushSpriteMask = function pushSpriteMask(target, maskData) {
        var alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex];

        if (!alphaMaskFilter) {
            alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex] = [new _SpriteMaskFilter2.default(maskData)];
        }

        alphaMaskFilter[0].resolution = this.renderer.resolution;
        alphaMaskFilter[0].maskSprite = maskData;

        var stashFilterArea = target.filterArea;

        target.filterArea = maskData.getBounds(true);
        this.renderer.filterManager.pushFilter(target, alphaMaskFilter);
        target.filterArea = stashFilterArea;

        this.alphaMaskIndex++;
    };

    /**
     * Removes the last filter from the filter stack and doesn't return it.
     *
     */


    MaskManager.prototype.popSpriteMask = function popSpriteMask() {
        this.renderer.filterManager.popFilter();
        this.alphaMaskIndex--;
    };

    /**
     * Applies the Mask and adds it to the current filter stack.
     *
     * @param {PIXI.Sprite|PIXI.Graphics} maskData - The masking data.
     */


    MaskManager.prototype.pushStencilMask = function pushStencilMask(maskData) {
        this.renderer.currentRenderer.stop();
        this.renderer.stencilManager.pushStencil(maskData);
    };

    /**
     * Removes the last filter from the filter stack and doesn't return it.
     *
     */


    MaskManager.prototype.popStencilMask = function popStencilMask() {
        this.renderer.currentRenderer.stop();
        this.renderer.stencilManager.popStencil();
    };

    /**
     *
     * @param {PIXI.DisplayObject} target - Display Object to push the mask to
     * @param {PIXI.Graphics} maskData - The masking data.
     */


    MaskManager.prototype.pushScissorMask = function pushScissorMask(target, maskData) {
        maskData.renderable = true;

        var renderTarget = this.renderer._activeRenderTarget;

        var bounds = maskData.getBounds();

        bounds.fit(renderTarget.size);
        maskData.renderable = false;

        this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST);

        var resolution = this.renderer.resolution;

        this.renderer.gl.scissor(bounds.x * resolution, (renderTarget.root ? renderTarget.size.height - bounds.y - bounds.height : bounds.y) * resolution, bounds.width * resolution, bounds.height * resolution);

        this.scissorRenderTarget = renderTarget;
        this.scissorData = maskData;
        this.scissor = true;
    };

    /**
     *
     *
     */


    MaskManager.prototype.popScissorMask = function popScissorMask() {
        this.scissorRenderTarget = null;
        this.scissorData = null;
        this.scissor = false;

        // must be scissor!
        var gl = this.renderer.gl;

        gl.disable(gl.SCISSOR_TEST);
    };

    return MaskManager;
}(_WebGLManager3.default);

exports.default = MaskManager;

},{"../filters/spriteMask/SpriteMaskFilter":96,"./WebGLManager":100}],99:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _WebGLManager2 = require('./WebGLManager');

var _WebGLManager3 = _interopRequireDefault(_WebGLManager2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class
 * @extends PIXI.WebGLManager
 * @memberof PIXI
 */
var StencilManager = function (_WebGLManager) {
    _inherits(StencilManager, _WebGLManager);

    /**
     * @param {PIXI.WebGLRenderer} renderer - The renderer this manager works for.
     */
    function StencilManager(renderer) {
        _classCallCheck(this, StencilManager);

        var _this = _possibleConstructorReturn(this, _WebGLManager.call(this, renderer));

        _this.stencilMaskStack = null;
        return _this;
    }

    /**
     * Changes the mask stack that is used by this manager.
     *
     * @param {PIXI.Graphics[]} stencilMaskStack - The mask stack
     */


    StencilManager.prototype.setMaskStack = function setMaskStack(stencilMaskStack) {
        this.stencilMaskStack = stencilMaskStack;

        var gl = this.renderer.gl;

        if (stencilMaskStack.length === 0) {
            gl.disable(gl.STENCIL_TEST);
        } else {
            gl.enable(gl.STENCIL_TEST);
        }
    };

    /**
     * Applies the Mask and adds it to the current stencil stack. @alvin
     *
     * @param {PIXI.Graphics} graphics - The mask
     */


    StencilManager.prototype.pushStencil = function pushStencil(graphics) {
        this.renderer.setObjectRenderer(this.renderer.plugins.graphics);

        this.renderer._activeRenderTarget.attachStencilBuffer();

        var gl = this.renderer.gl;
        var prevMaskCount = this.stencilMaskStack.length;

        if (prevMaskCount === 0) {
            gl.enable(gl.STENCIL_TEST);
        }

        this.stencilMaskStack.push(graphics);

        // Increment the reference stencil value where the new mask overlaps with the old ones.
        gl.colorMask(false, false, false, false);
        gl.stencilFunc(gl.EQUAL, prevMaskCount, this._getBitwiseMask());
        gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR);
        this.renderer.plugins.graphics.render(graphics);

        this._useCurrent();
    };

    /**
     * Removes the last mask from the stencil stack. @alvin
     */


    StencilManager.prototype.popStencil = function popStencil() {
        this.renderer.setObjectRenderer(this.renderer.plugins.graphics);

        var gl = this.renderer.gl;
        var graphics = this.stencilMaskStack.pop();

        if (this.stencilMaskStack.length === 0) {
            // the stack is empty!
            gl.disable(gl.STENCIL_TEST);
            gl.clear(gl.STENCIL_BUFFER_BIT);
            gl.clearStencil(0);
        } else {
            // Decrement the reference stencil value where the popped mask overlaps with the other ones
            gl.colorMask(false, false, false, false);
            gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR);
            this.renderer.plugins.graphics.render(graphics);

            this._useCurrent();
        }
    };

    /**
     * Setup renderer to use the current stencil data.
     */


    StencilManager.prototype._useCurrent = function _useCurrent() {
        var gl = this.renderer.gl;

        gl.colorMask(true, true, true, true);
        gl.stencilFunc(gl.EQUAL, this.stencilMaskStack.length, this._getBitwiseMask());
        gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
    };

    /**
     * Fill 1s equal to the number of acitve stencil masks.
     *
     * @return {number} The bitwise mask.
     */


    StencilManager.prototype._getBitwiseMask = function _getBitwiseMask() {
        return (1 << this.stencilMaskStack.length) - 1;
    };

    /**
     * Destroys the mask stack.
     *
     */


    StencilManager.prototype.destroy = function destroy() {
        _WebGLManager3.default.prototype.destroy.call(this);

        this.stencilMaskStack.stencilStack = null;
    };

    return StencilManager;
}(_WebGLManager3.default);

exports.default = StencilManager;

},{"./WebGLManager":100}],100:[function(require,module,exports){
'use strict';

exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class
 * @memberof PIXI
 */
var WebGLManager = function () {
  /**
   * @param {PIXI.WebGLRenderer} renderer - The renderer this manager works for.
   */
  function WebGLManager(renderer) {
    _classCallCheck(this, WebGLManager);

    /**
     * The renderer this manager works for.
     *
     * @member {PIXI.WebGLRenderer}
     */
    this.renderer = renderer;

    this.renderer.on('context', this.onContextChange, this);
  }

  /**
   * Generic method called when there is a WebGL context change.
   *
   */


  WebGLManager.prototype.onContextChange = function onContextChange() {}
  // do some codes init!


  /**
   * Generic destroy methods to be overridden by the subclass
   *
   */
  ;

  WebGLManager.prototype.destroy = function destroy() {
    this.renderer.off('context', this.onContextChange, this);

    this.renderer = null;
  };

  return WebGLManager;
}();

exports.default = WebGLManager;

},{}],101:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _WebGLManager2 = require('../managers/WebGLManager');

var _WebGLManager3 = _interopRequireDefault(_WebGLManager2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Base for a common object renderer that can be used as a system renderer plugin.
 *
 * @class
 * @extends PIXI.WebGLManager
 * @memberof PIXI
 */
var ObjectRenderer = function (_WebGLManager) {
  _inherits(ObjectRenderer, _WebGLManager);

  function ObjectRenderer() {
    _classCallCheck(this, ObjectRenderer);

    return _possibleConstructorReturn(this, _WebGLManager.apply(this, arguments));
  }

  /**
   * Starts the renderer and sets the shader
   *
   */
  ObjectRenderer.prototype.start = function start() {}
  // set the shader..


  /**
   * Stops the renderer
   *
   */
  ;

  ObjectRenderer.prototype.stop = function stop() {
    this.flush();
  };

  /**
   * Stub method for rendering content and emptying the current batch.
   *
   */


  ObjectRenderer.prototype.flush = function flush() {}
  // flush!


  /**
   * Renders an object
   *
   * @param {PIXI.DisplayObject} object - The object to render.
   */
  ;

  ObjectRenderer.prototype.render = function render(object) // eslint-disable-line no-unused-vars
  {
    // render the object
  };

  return ObjectRenderer;
}(_WebGLManager3.default);

exports.default = ObjectRenderer;

},{"../managers/WebGLManager":100}],102:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _pixiGlCore = require('pixi-gl-core');

var _pixiGlCore2 = _interopRequireDefault(_pixiGlCore);

var _createIndicesForQuads = require('../../../utils/createIndicesForQuads');

var _createIndicesForQuads2 = _interopRequireDefault(_createIndicesForQuads);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Helper class to create a quad
 *
 * @class
 * @memberof PIXI
 */
var Quad = function () {
  /**
   * @param {WebGLRenderingContext} gl - The gl context for this quad to use.
   * @param {object} state - TODO: Description
   */
  function Quad(gl, state) {
    _classCallCheck(this, Quad);

    /**
     * the current WebGL drawing context
     *
     * @member {WebGLRenderingContext}
     */
    this.gl = gl;

    /**
     * An array of vertices
     *
     * @member {Float32Array}
     */
    this.vertices = new Float32Array([-1, -1, 1, -1, 1, 1, -1, 1]);

    /**
     * The Uvs of the quad
     *
     * @member {Float32Array}
     */
    this.uvs = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);

    this.interleaved = new Float32Array(8 * 2);

    for (var i = 0; i < 4; i++) {
      this.interleaved[i * 4] = this.vertices[i * 2];
      this.interleaved[i * 4 + 1] = this.vertices[i * 2 + 1];
      this.interleaved[i * 4 + 2] = this.uvs[i * 2];
      this.interleaved[i * 4 + 3] = this.uvs[i * 2 + 1];
    }

    /**
     * An array containing the indices of the vertices
     *
     * @member {Uint16Array}
     */
    this.indices = (0, _createIndicesForQuads2.default)(1);

    /**
     * The vertex buffer
     *
     * @member {glCore.GLBuffer}
     */
    this.vertexBuffer = _pixiGlCore2.default.GLBuffer.createVertexBuffer(gl, this.interleaved, gl.STATIC_DRAW);

    /**
     * The index buffer
     *
     * @member {glCore.GLBuffer}
     */
    this.indexBuffer = _pixiGlCore2.default.GLBuffer.createIndexBuffer(gl, this.indices, gl.STATIC_DRAW);

    /**
     * The vertex array object
     *
     * @member {glCore.VertexArrayObject}
     */
    this.vao = new _pixiGlCore2.default.VertexArrayObject(gl, state);
  }

  /**
   * Initialises the vaos and uses the shader.
   *
   * @param {PIXI.Shader} shader - the shader to use
   */


  Quad.prototype.initVao = function initVao(shader) {
    this.vao.clear().addIndex(this.indexBuffer).addAttribute(this.vertexBuffer, shader.attributes.aVertexPosition, this.gl.FLOAT, false, 4 * 4, 0).addAttribute(this.vertexBuffer, shader.attributes.aTextureCoord, this.gl.FLOAT, false, 4 * 4, 2 * 4);
  };

  /**
   * Maps two Rectangle to the quad.
   *
   * @param {PIXI.Rectangle} targetTextureFrame - the first rectangle
   * @param {PIXI.Rectangle} destinationFrame - the second rectangle
   * @return {PIXI.Quad} Returns itself.
   */


  Quad.prototype.map = function map(targetTextureFrame, destinationFrame) {
    var x = 0; // destinationFrame.x / targetTextureFrame.width;
    var y = 0; // destinationFrame.y / targetTextureFrame.height;

    this.uvs[0] = x;
    this.uvs[1] = y;

    this.uvs[2] = x + destinationFrame.width / targetTextureFrame.width;
    this.uvs[3] = y;

    this.uvs[4] = x + destinationFrame.width / targetTextureFrame.width;
    this.uvs[5] = y + destinationFrame.height / targetTextureFrame.height;

    this.uvs[6] = x;
    this.uvs[7] = y + destinationFrame.height / targetTextureFrame.height;

    x = destinationFrame.x;
    y = destinationFrame.y;

    this.vertices[0] = x;
    this.vertices[1] = y;

    this.vertices[2] = x + destinationFrame.width;
    this.vertices[3] = y;

    this.vertices[4] = x + destinationFrame.width;
    this.vertices[5] = y + destinationFrame.height;

    this.vertices[6] = x;
    this.vertices[7] = y + destinationFrame.height;

    return this;
  };

  /**
   * Binds the buffer and uploads the data
   *
   * @return {PIXI.Quad} Returns itself.
   */


  Quad.prototype.upload = function upload() {
    for (var i = 0; i < 4; i++) {
      this.interleaved[i * 4] = this.vertices[i * 2];
      this.interleaved[i * 4 + 1] = this.vertices[i * 2 + 1];
      this.interleaved[i * 4 + 2] = this.uvs[i * 2];
      this.interleaved[i * 4 + 3] = this.uvs[i * 2 + 1];
    }

    this.vertexBuffer.upload(this.interleaved);

    return this;
  };

  /**
   * Removes this quad from WebGL
   */


  Quad.prototype.destroy = function destroy() {
    var gl = this.gl;

    gl.deleteBuffer(this.vertexBuffer);
    gl.deleteBuffer(this.indexBuffer);
  };

  return Quad;
}();

exports.default = Quad;

},{"../../../utils/createIndicesForQuads":130,"pixi-gl-core":36}],103:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _math = require('../../../math');

var _const = require('../../../const');

var _settings = require('../../../settings');

var _settings2 = _interopRequireDefault(_settings);

var _pixiGlCore = require('pixi-gl-core');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class
 * @memberof PIXI
 */
var RenderTarget = function () {
  /**
   * @param {WebGLRenderingContext} gl - The current WebGL drawing context
   * @param {number} [width=0] - the horizontal range of the filter
   * @param {number} [height=0] - the vertical range of the filter
   * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values
   * @param {number} [resolution=1] - The current resolution / device pixel ratio
   * @param {boolean} [root=false] - Whether this object is the root element or not
   */
  function RenderTarget(gl, width, height, scaleMode, resolution, root) {
    _classCallCheck(this, RenderTarget);

    // TODO Resolution could go here ( eg low res blurs )

    /**
     * The current WebGL drawing context.
     *
     * @member {WebGLRenderingContext}
     */
    this.gl = gl;

    // next time to create a frame buffer and texture

    /**
     * A frame buffer
     *
     * @member {PIXI.glCore.GLFramebuffer}
     */
    this.frameBuffer = null;

    /**
     * The texture
     *
     * @member {PIXI.glCore.GLTexture}
     */
    this.texture = null;

    /**
     * The background colour of this render target, as an array of [r,g,b,a] values
     *
     * @member {number[]}
     */
    this.clearColor = [0, 0, 0, 0];

    /**
     * The size of the object as a rectangle
     *
     * @member {PIXI.Rectangle}
     */
    this.size = new _math.Rectangle(0, 0, 1, 1);

    /**
     * The current resolution / device pixel ratio
     *
     * @member {number}
     * @default 1
     */
    this.resolution = resolution || _settings2.default.RESOLUTION;

    /**
     * The projection matrix
     *
     * @member {PIXI.Matrix}
     */
    this.projectionMatrix = new _math.Matrix();

    /**
     * The object's transform
     *
     * @member {PIXI.Matrix}
     */
    this.transform = null;

    /**
     * The frame.
     *
     * @member {PIXI.Rectangle}
     */
    this.frame = null;

    /**
     * The stencil buffer stores masking data for the render target
     *
     * @member {glCore.GLBuffer}
     */
    this.defaultFrame = new _math.Rectangle();
    this.destinationFrame = null;
    this.sourceFrame = null;

    /**
     * The stencil buffer stores masking data for the render target
     *
     * @member {glCore.GLBuffer}
     */
    this.stencilBuffer = null;

    /**
     * The data structure for the stencil masks
     *
     * @member {PIXI.Graphics[]}
     */
    this.stencilMaskStack = [];

    /**
     * Stores filter data for the render target
     *
     * @member {object[]}
     */
    this.filterData = null;

    /**
     * The key for pooled texture of FilterSystem
     * @private
     * @member {string}
     */
    this.filterPoolKey = '';

    /**
     * The scale mode.
     *
     * @member {number}
     * @default PIXI.settings.SCALE_MODE
     * @see PIXI.SCALE_MODES
     */
    this.scaleMode = scaleMode !== undefined ? scaleMode : _settings2.default.SCALE_MODE;

    /**
     * Whether this object is the root element or not
     *
     * @member {boolean}
     * @default false
     */
    this.root = root || false;

    if (!this.root) {
      this.frameBuffer = _pixiGlCore.GLFramebuffer.createRGBA(gl, 100, 100);

      if (this.scaleMode === _const.SCALE_MODES.NEAREST) {
        this.frameBuffer.texture.enableNearestScaling();
      } else {
        this.frameBuffer.texture.enableLinearScaling();
      }
      /*
          A frame buffer needs a target to render to..
          create a texture and bind it attach it to the framebuffer..
       */

      // this is used by the base texture
      this.texture = this.frameBuffer.texture;
    } else {
      // make it a null framebuffer..
      this.frameBuffer = new _pixiGlCore.GLFramebuffer(gl, 100, 100);
      this.frameBuffer.framebuffer = null;
    }

    this.setFrame();

    this.resize(width, height);
  }

  /**
   * Clears the filter texture.
   *
   * @param {number[]} [clearColor=this.clearColor] - Array of [r,g,b,a] to clear the framebuffer
   */


  RenderTarget.prototype.clear = function clear(clearColor) {
    var cc = clearColor || this.clearColor;

    this.frameBuffer.clear(cc[0], cc[1], cc[2], cc[3]); // r,g,b,a);
  };

  /**
   * Binds the stencil buffer.
   *
   */


  RenderTarget.prototype.attachStencilBuffer = function attachStencilBuffer() {
    // TODO check if stencil is done?
    /**
     * The stencil buffer is used for masking in pixi
     * lets create one and then add attach it to the framebuffer..
     */
    if (!this.root) {
      this.frameBuffer.enableStencil();
    }
  };

  /**
   * Sets the frame of the render target.
   *
   * @param {Rectangle} destinationFrame - The destination frame.
   * @param {Rectangle} sourceFrame - The source frame.
   */


  RenderTarget.prototype.setFrame = function setFrame(destinationFrame, sourceFrame) {
    this.destinationFrame = destinationFrame || this.destinationFrame || this.defaultFrame;
    this.sourceFrame = sourceFrame || this.sourceFrame || this.destinationFrame;
  };

  /**
   * Binds the buffers and initialises the viewport.
   *
   */


  RenderTarget.prototype.activate = function activate() {
    // TODO refactor usage of frame..
    var gl = this.gl;

    // make sure the texture is unbound!
    this.frameBuffer.bind();

    this.calculateProjection(this.destinationFrame, this.sourceFrame);

    if (this.transform) {
      this.projectionMatrix.append(this.transform);
    }

    // TODO add a check as them may be the same!
    if (this.destinationFrame !== this.sourceFrame) {
      gl.enable(gl.SCISSOR_TEST);
      gl.scissor(this.destinationFrame.x | 0, this.destinationFrame.y | 0, this.destinationFrame.width * this.resolution | 0, this.destinationFrame.height * this.resolution | 0);
    } else {
      gl.disable(gl.SCISSOR_TEST);
    }

    // TODO - does not need to be updated all the time??
    gl.viewport(this.destinationFrame.x | 0, this.destinationFrame.y | 0, this.destinationFrame.width * this.resolution | 0, this.destinationFrame.height * this.resolution | 0);
  };

  /**
   * Updates the projection matrix based on a projection frame (which is a rectangle)
   *
   * @param {Rectangle} destinationFrame - The destination frame.
   * @param {Rectangle} sourceFrame - The source frame.
   */


  RenderTarget.prototype.calculateProjection = function calculateProjection(destinationFrame, sourceFrame) {
    var pm = this.projectionMatrix;

    sourceFrame = sourceFrame || destinationFrame;

    pm.identity();

    // TODO: make dest scale source
    if (!this.root) {
      pm.a = 1 / destinationFrame.width * 2;
      pm.d = 1 / destinationFrame.height * 2;

      pm.tx = -1 - sourceFrame.x * pm.a;
      pm.ty = -1 - sourceFrame.y * pm.d;
    } else {
      pm.a = 1 / destinationFrame.width * 2;
      pm.d = -1 / destinationFrame.height * 2;

      pm.tx = -1 - sourceFrame.x * pm.a;
      pm.ty = 1 - sourceFrame.y * pm.d;
    }
  };

  /**
   * Resizes the texture to the specified width and height
   *
   * @param {number} width - the new width of the texture
   * @param {number} height - the new height of the texture
   */


  RenderTarget.prototype.resize = function resize(width, height) {
    width = width | 0;
    height = height | 0;

    if (this.size.width === width && this.size.height === height) {
      return;
    }

    this.size.width = width;
    this.size.height = height;

    this.defaultFrame.width = width;
    this.defaultFrame.height = height;

    this.frameBuffer.resize(width * this.resolution, height * this.resolution);

    var projectionFrame = this.frame || this.size;

    this.calculateProjection(projectionFrame);
  };

  /**
   * Destroys the render target.
   *
   */


  RenderTarget.prototype.destroy = function destroy() {
    if (this.frameBuffer.stencil) {
      this.gl.deleteRenderbuffer(this.frameBuffer.stencil);
    }
    this.frameBuffer.destroy();

    this.frameBuffer = null;
    this.texture = null;
  };

  return RenderTarget;
}();

exports.default = RenderTarget;

},{"../../../const":53,"../../../math":77,"../../../settings":108,"pixi-gl-core":36}],104:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.default = checkMaxIfStatmentsInShader;

var _pixiGlCore = require('pixi-gl-core');

var _pixiGlCore2 = _interopRequireDefault(_pixiGlCore);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var fragTemplate = ['precision mediump float;', 'void main(void){', 'float test = 0.1;', '%forloop%', 'gl_FragColor = vec4(0.0);', '}'].join('\n');

function checkMaxIfStatmentsInShader(maxIfs, gl) {
    var createTempContext = !gl;

    // @if DEBUG
    if (maxIfs === 0) {
        throw new Error('Invalid value of `0` passed to `checkMaxIfStatementsInShader`');
    }
    // @endif

    if (createTempContext) {
        var tinyCanvas = document.createElement('canvas');

        tinyCanvas.width = 1;
        tinyCanvas.height = 1;

        gl = _pixiGlCore2.default.createContext(tinyCanvas);
    }

    var shader = gl.createShader(gl.FRAGMENT_SHADER);

    while (true) // eslint-disable-line no-constant-condition
    {
        var fragmentSrc = fragTemplate.replace(/%forloop%/gi, generateIfTestSrc(maxIfs));

        gl.shaderSource(shader, fragmentSrc);
        gl.compileShader(shader);

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            maxIfs = maxIfs / 2 | 0;
        } else {
            // valid!
            break;
        }
    }

    if (createTempContext) {
        // get rid of context
        if (gl.getExtension('WEBGL_lose_context')) {
            gl.getExtension('WEBGL_lose_context').loseContext();
        }
    }

    return maxIfs;
}

function generateIfTestSrc(maxIfs) {
    var src = '';

    for (var i = 0; i < maxIfs; ++i) {
        if (i > 0) {
            src += '\nelse ';
        }

        if (i < maxIfs - 1) {
            src += 'if(test == ' + i + '.0){}';
        }
    }

    return src;
}

},{"pixi-gl-core":36}],105:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.default = mapWebGLBlendModesToPixi;

var _const = require('../../../const');

/**
 * Maps gl blend combinations to WebGL.
 *
 * @memberof PIXI
 * @function mapWebGLBlendModesToPixi
 * @private
 * @param {WebGLRenderingContext} gl - The rendering context.
 * @param {string[]} [array=[]] - The array to output into.
 * @return {string[]} Mapped modes.
 */
function mapWebGLBlendModesToPixi(gl) {
    var array = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

    // TODO - premultiply alpha would be different.
    // add a boolean for that!
    array[_const.BLEND_MODES.NORMAL] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[_const.BLEND_MODES.ADD] = [gl.ONE, gl.ONE];
    array[_const.BLEND_MODES.MULTIPLY] = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[_const.BLEND_MODES.SCREEN] = [gl.ONE, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[_const.BLEND_MODES.OVERLAY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[_const.BLEND_MODES.DARKEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[_const.BLEND_MODES.LIGHTEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[_const.BLEND_MODES.COLOR_DODGE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[_const.BLEND_MODES.COLOR_BURN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[_const.BLEND_MODES.HARD_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[_const.BLEND_MODES.SOFT_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[_const.BLEND_MODES.DIFFERENCE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[_const.BLEND_MODES.EXCLUSION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[_const.BLEND_MODES.HUE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[_const.BLEND_MODES.SATURATION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[_const.BLEND_MODES.COLOR] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[_const.BLEND_MODES.LUMINOSITY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];

    // not-premultiplied blend modes
    array[_const.BLEND_MODES.NORMAL_NPM] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[_const.BLEND_MODES.ADD_NPM] = [gl.SRC_ALPHA, gl.ONE, gl.ONE, gl.ONE];
    array[_const.BLEND_MODES.SCREEN_NPM] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];

    return array;
}

},{"../../../const":53}],106:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.default = mapWebGLDrawModesToPixi;

var _const = require('../../../const');

/**
 * Generic Mask Stack data structure.
 *
 * @memberof PIXI
 * @function mapWebGLDrawModesToPixi
 * @private
 * @param {WebGLRenderingContext} gl - The current WebGL drawing context
 * @param {object} [object={}] - The object to map into
 * @return {object} The mapped draw modes.
 */
function mapWebGLDrawModesToPixi(gl) {
  var object = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  object[_const.DRAW_MODES.POINTS] = gl.POINTS;
  object[_const.DRAW_MODES.LINES] = gl.LINES;
  object[_const.DRAW_MODES.LINE_LOOP] = gl.LINE_LOOP;
  object[_const.DRAW_MODES.LINE_STRIP] = gl.LINE_STRIP;
  object[_const.DRAW_MODES.TRIANGLES] = gl.TRIANGLES;
  object[_const.DRAW_MODES.TRIANGLE_STRIP] = gl.TRIANGLE_STRIP;
  object[_const.DRAW_MODES.TRIANGLE_FAN] = gl.TRIANGLE_FAN;

  return object;
}

},{"../../../const":53}],107:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.default = validateContext;
function validateContext(gl) {
    var attributes = gl.getContextAttributes();

    // this is going to be fairly simple for now.. but at least we have room to grow!
    if (!attributes.stencil) {
        /* eslint-disable no-console */
        console.warn('Provided WebGL context does not have a stencil buffer, masks may not render correctly');
        /* eslint-enable no-console */
    }
}

},{}],108:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _maxRecommendedTextures = require('./utils/maxRecommendedTextures');

var _maxRecommendedTextures2 = _interopRequireDefault(_maxRecommendedTextures);

var _canUploadSameBuffer = require('./utils/canUploadSameBuffer');

var _canUploadSameBuffer2 = _interopRequireDefault(_canUploadSameBuffer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * User's customizable globals for overriding the default PIXI settings, such
 * as a renderer's default resolution, framerate, float percision, etc.
 * @example
 * // Use the native window resolution as the default resolution
 * // will support high-density displays when rendering
 * PIXI.settings.RESOLUTION = window.devicePixelRatio.
 *
 * // Disable interpolation when scaling, will make texture be pixelated
 * PIXI.settings.SCALE_MODE = PIXI.SCALE_MODES.NEAREST;
 * @namespace PIXI.settings
 */
exports.default = {

  /**
   * Target frames per millisecond.
   *
   * @static
   * @memberof PIXI.settings
   * @type {number}
   * @default 0.06
   */
  TARGET_FPMS: 0.06,

  /**
   * If set to true WebGL will attempt make textures mimpaped by default.
   * Mipmapping will only succeed if the base texture uploaded has power of two dimensions.
   *
   * @static
   * @memberof PIXI.settings
   * @type {boolean}
   * @default true
   */
  MIPMAP_TEXTURES: true,

  /**
   * Default resolution / device pixel ratio of the renderer.
   *
   * @static
   * @memberof PIXI.settings
   * @type {number}
   * @default 1
   */
  RESOLUTION: 1,

  /**
   * Default filter resolution.
   *
   * @static
   * @memberof PIXI.settings
   * @type {number}
   * @default 1
   */
  FILTER_RESOLUTION: 1,

  /**
   * The maximum textures that this device supports.
   *
   * @static
   * @memberof PIXI.settings
   * @type {number}
   * @default 32
   */
  SPRITE_MAX_TEXTURES: (0, _maxRecommendedTextures2.default)(32),

  // TODO: maybe change to SPRITE.BATCH_SIZE: 2000
  // TODO: maybe add PARTICLE.BATCH_SIZE: 15000

  /**
   * The default sprite batch size.
   *
   * The default aims to balance desktop and mobile devices.
   *
   * @static
   * @memberof PIXI.settings
   * @type {number}
   * @default 4096
   */
  SPRITE_BATCH_SIZE: 4096,

  /**
   * The prefix that denotes a URL is for a retina asset.
   *
   * @static
   * @memberof PIXI.settings
   * @type {RegExp}
   * @example `@2x`
   * @default /@([0-9\.]+)x/
   */
  RETINA_PREFIX: /@([0-9\.]+)x/,

  /**
   * The default render options if none are supplied to {@link PIXI.WebGLRenderer}
   * or {@link PIXI.CanvasRenderer}.
   *
   * @static
   * @constant
   * @memberof PIXI.settings
   * @type {object}
   * @property {HTMLCanvasElement} view=null
   * @property {number} resolution=1
   * @property {boolean} antialias=false
   * @property {boolean} forceFXAA=false
   * @property {boolean} autoResize=false
   * @property {boolean} transparent=false
   * @property {number} backgroundColor=0x000000
   * @property {boolean} clearBeforeRender=true
   * @property {boolean} preserveDrawingBuffer=false
   * @property {boolean} roundPixels=false
   * @property {number} width=800
   * @property {number} height=600
   * @property {boolean} legacy=false
   */
  RENDER_OPTIONS: {
    view: null,
    antialias: false,
    forceFXAA: false,
    autoResize: false,
    transparent: false,
    backgroundColor: 0x000000,
    clearBeforeRender: true,
    preserveDrawingBuffer: false,
    roundPixels: false,
    width: 800,
    height: 600,
    legacy: false
  },

  /**
   * Default transform type.
   *
   * @static
   * @memberof PIXI.settings
   * @type {PIXI.TRANSFORM_MODE}
   * @default PIXI.TRANSFORM_MODE.STATIC
   */
  TRANSFORM_MODE: 0,

  /**
   * Default Garbage Collection mode.
   *
   * @static
   * @memberof PIXI.settings
   * @type {PIXI.GC_MODES}
   * @default PIXI.GC_MODES.AUTO
   */
  GC_MODE: 0,

  /**
   * Default Garbage Collection max idle.
   *
   * @static
   * @memberof PIXI.settings
   * @type {number}
   * @default 3600
   */
  GC_MAX_IDLE: 60 * 60,

  /**
   * Default Garbage Collection maximum check count.
   *
   * @static
   * @memberof PIXI.settings
   * @type {number}
   * @default 600
   */
  GC_MAX_CHECK_COUNT: 60 * 10,

  /**
   * Default wrap modes that are supported by pixi.
   *
   * @static
   * @memberof PIXI.settings
   * @type {PIXI.WRAP_MODES}
   * @default PIXI.WRAP_MODES.CLAMP
   */
  WRAP_MODE: 0,

  /**
   * The scale modes that are supported by pixi.
   *
   * @static
   * @memberof PIXI.settings
   * @type {PIXI.SCALE_MODES}
   * @default PIXI.SCALE_MODES.LINEAR
   */
  SCALE_MODE: 0,

  /**
   * Default specify float precision in vertex shader.
   *
   * @static
   * @memberof PIXI.settings
   * @type {PIXI.PRECISION}
   * @default PIXI.PRECISION.HIGH
   */
  PRECISION_VERTEX: 'highp',

  /**
   * Default specify float precision in fragment shader.
   *
   * @static
   * @memberof PIXI.settings
   * @type {PIXI.PRECISION}
   * @default PIXI.PRECISION.MEDIUM
   */
  PRECISION_FRAGMENT: 'mediump',

  /**
   * Can we upload the same buffer in a single frame?
   *
   * @static
   * @constant
   * @memberof PIXI.settings
   * @type {boolean}
   */
  CAN_UPLOAD_SAME_BUFFER: (0, _canUploadSameBuffer2.default)(),

  /**
   * Default Mesh `canvasPadding`.
   *
   * @see PIXI.mesh.Mesh#canvasPadding
   * @static
   * @constant
   * @memberof PIXI.settings
   * @type {number}
   */
  MESH_CANVAS_PADDING: 0
};

},{"./utils/canUploadSameBuffer":129,"./utils/maxRecommendedTextures":134}],109:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = require('../math');

var _utils = require('../utils');

var _const = require('../const');

var _Texture = require('../textures/Texture');

var _Texture2 = _interopRequireDefault(_Texture);

var _Container2 = require('../display/Container');

var _Container3 = _interopRequireDefault(_Container2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var tempPoint = new _math.Point();

/**
 * The Sprite object is the base for all textured objects that are rendered to the screen
 *
 * A sprite can be created directly from an image like this:
 *
 * ```js
 * let sprite = new PIXI.Sprite.fromImage('assets/image.png');
 * ```
 *
 * The more efficient way to create sprites is using a {@link PIXI.Spritesheet}:
 *
 * ```js
 * PIXI.loader.add("assets/spritesheet.json").load(setup);
 *
 * function setup() {
 *   let sheet = PIXI.loader.resources["assets/spritesheet.json"].spritesheet;
 *   let sprite = new PIXI.Sprite(sheet.textures["image.png"]);
 *   ...
 * }
 * ```
 *
 * @class
 * @extends PIXI.Container
 * @memberof PIXI
 */

var Sprite = function (_Container) {
    _inherits(Sprite, _Container);

    /**
     * @param {PIXI.Texture} texture - The texture for this sprite
     */
    function Sprite(texture) {
        _classCallCheck(this, Sprite);

        /**
         * The anchor sets the origin point of the texture.
         * The default is 0,0 or taken from the {@link PIXI.Texture#defaultAnchor|Texture}
         * passed to the constructor. A value of 0,0 means the texture's origin is the top left.
         * Setting the anchor to 0.5,0.5 means the texture's origin is centered.
         * Setting the anchor to 1,1 would mean the texture's origin point will be the bottom right corner.
         * Note: Updating the {@link PIXI.Texture#defaultAnchor} after a Texture is
         * created does _not_ update the Sprite's anchor values.
         *
         * @member {PIXI.ObservablePoint}
         * @private
         */
        var _this = _possibleConstructorReturn(this, _Container.call(this));

        _this._anchor = new _math.ObservablePoint(_this._onAnchorUpdate, _this, texture ? texture.defaultAnchor.x : 0, texture ? texture.defaultAnchor.y : 0);

        /**
         * The texture that the sprite is using
         *
         * @private
         * @member {PIXI.Texture}
         */
        _this._texture = null;

        /**
         * The width of the sprite (this is initially set by the texture)
         *
         * @private
         * @member {number}
         */
        _this._width = 0;

        /**
         * The height of the sprite (this is initially set by the texture)
         *
         * @private
         * @member {number}
         */
        _this._height = 0;

        /**
         * The tint applied to the sprite. This is a hex value. A value of 0xFFFFFF will remove any tint effect.
         *
         * @private
         * @member {number}
         * @default 0xFFFFFF
         */
        _this._tint = null;
        _this._tintRGB = null;
        _this.tint = 0xFFFFFF;

        /**
         * The blend mode to be applied to the sprite. Apply a value of `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.
         *
         * @member {number}
         * @default PIXI.BLEND_MODES.NORMAL
         * @see PIXI.BLEND_MODES
         */
        _this.blendMode = _const.BLEND_MODES.NORMAL;

        /**
         * The shader that will be used to render the sprite. Set to null to remove a current shader.
         *
         * @member {PIXI.Filter|PIXI.Shader}
         */
        _this.shader = null;

        /**
         * An internal cached value of the tint.
         *
         * @private
         * @member {number}
         * @default 0xFFFFFF
         */
        _this.cachedTint = 0xFFFFFF;

        // call texture setter
        _this.texture = texture || _Texture2.default.EMPTY;

        /**
         * this is used to store the vertex data of the sprite (basically a quad)
         *
         * @private
         * @member {Float32Array}
         */
        _this.vertexData = new Float32Array(8);

        /**
         * This is used to calculate the bounds of the object IF it is a trimmed sprite
         *
         * @private
         * @member {Float32Array}
         */
        _this.vertexTrimmedData = null;

        _this._transformID = -1;
        _this._textureID = -1;

        _this._transformTrimmedID = -1;
        _this._textureTrimmedID = -1;

        /**
         * Plugin that is responsible for rendering this element.
         * Allows to customize the rendering process without overriding '_renderWebGL' & '_renderCanvas' methods.
         *
         * @member {string}
         * @default 'sprite'
         */
        _this.pluginName = 'sprite';
        return _this;
    }

    /**
     * When the texture is updated, this event will fire to update the scale and frame
     *
     * @private
     */


    Sprite.prototype._onTextureUpdate = function _onTextureUpdate() {
        this._textureID = -1;
        this._textureTrimmedID = -1;
        this.cachedTint = 0xFFFFFF;

        // so if _width is 0 then width was not set..
        if (this._width) {
            this.scale.x = (0, _utils.sign)(this.scale.x) * this._width / this._texture.orig.width;
        }

        if (this._height) {
            this.scale.y = (0, _utils.sign)(this.scale.y) * this._height / this._texture.orig.height;
        }
    };

    /**
     * Called when the anchor position updates.
     *
     * @private
     */


    Sprite.prototype._onAnchorUpdate = function _onAnchorUpdate() {
        this._transformID = -1;
        this._transformTrimmedID = -1;
    };

    /**
     * calculates worldTransform * vertices, store it in vertexData
     */


    Sprite.prototype.calculateVertices = function calculateVertices() {
        if (this._transformID === this.transform._worldID && this._textureID === this._texture._updateID) {
            return;
        }

        this._transformID = this.transform._worldID;
        this._textureID = this._texture._updateID;

        // set the vertex data

        var texture = this._texture;
        var wt = this.transform.worldTransform;
        var a = wt.a;
        var b = wt.b;
        var c = wt.c;
        var d = wt.d;
        var tx = wt.tx;
        var ty = wt.ty;
        var vertexData = this.vertexData;
        var trim = texture.trim;
        var orig = texture.orig;
        var anchor = this._anchor;

        var w0 = 0;
        var w1 = 0;
        var h0 = 0;
        var h1 = 0;

        if (trim) {
            // if the sprite is trimmed and is not a tilingsprite then we need to add the extra
            // space before transforming the sprite coords.
            w1 = trim.x - anchor._x * orig.width;
            w0 = w1 + trim.width;

            h1 = trim.y - anchor._y * orig.height;
            h0 = h1 + trim.height;
        } else {
            w1 = -anchor._x * orig.width;
            w0 = w1 + orig.width;

            h1 = -anchor._y * orig.height;
            h0 = h1 + orig.height;
        }

        // xy
        vertexData[0] = a * w1 + c * h1 + tx;
        vertexData[1] = d * h1 + b * w1 + ty;

        // xy
        vertexData[2] = a * w0 + c * h1 + tx;
        vertexData[3] = d * h1 + b * w0 + ty;

        // xy
        vertexData[4] = a * w0 + c * h0 + tx;
        vertexData[5] = d * h0 + b * w0 + ty;

        // xy
        vertexData[6] = a * w1 + c * h0 + tx;
        vertexData[7] = d * h0 + b * w1 + ty;
    };

    /**
     * calculates worldTransform * vertices for a non texture with a trim. store it in vertexTrimmedData
     * This is used to ensure that the true width and height of a trimmed texture is respected
     */


    Sprite.prototype.calculateTrimmedVertices = function calculateTrimmedVertices() {
        if (!this.vertexTrimmedData) {
            this.vertexTrimmedData = new Float32Array(8);
        } else if (this._transformTrimmedID === this.transform._worldID && this._textureTrimmedID === this._texture._updateID) {
            return;
        }

        this._transformTrimmedID = this.transform._worldID;
        this._textureTrimmedID = this._texture._updateID;

        // lets do some special trim code!
        var texture = this._texture;
        var vertexData = this.vertexTrimmedData;
        var orig = texture.orig;
        var anchor = this._anchor;

        // lets calculate the new untrimmed bounds..
        var wt = this.transform.worldTransform;
        var a = wt.a;
        var b = wt.b;
        var c = wt.c;
        var d = wt.d;
        var tx = wt.tx;
        var ty = wt.ty;

        var w1 = -anchor._x * orig.width;
        var w0 = w1 + orig.width;

        var h1 = -anchor._y * orig.height;
        var h0 = h1 + orig.height;

        // xy
        vertexData[0] = a * w1 + c * h1 + tx;
        vertexData[1] = d * h1 + b * w1 + ty;

        // xy
        vertexData[2] = a * w0 + c * h1 + tx;
        vertexData[3] = d * h1 + b * w0 + ty;

        // xy
        vertexData[4] = a * w0 + c * h0 + tx;
        vertexData[5] = d * h0 + b * w0 + ty;

        // xy
        vertexData[6] = a * w1 + c * h0 + tx;
        vertexData[7] = d * h0 + b * w1 + ty;
    };

    /**
    *
    * Renders the object using the WebGL renderer
    *
    * @private
    * @param {PIXI.WebGLRenderer} renderer - The webgl renderer to use.
    */


    Sprite.prototype._renderWebGL = function _renderWebGL(renderer) {
        this.calculateVertices();

        renderer.setObjectRenderer(renderer.plugins[this.pluginName]);
        renderer.plugins[this.pluginName].render(this);
    };

    /**
    * Renders the object using the Canvas renderer
    *
    * @private
    * @param {PIXI.CanvasRenderer} renderer - The renderer
    */


    Sprite.prototype._renderCanvas = function _renderCanvas(renderer) {
        renderer.plugins[this.pluginName].render(this);
    };

    /**
     * Updates the bounds of the sprite.
     *
     * @private
     */


    Sprite.prototype._calculateBounds = function _calculateBounds() {
        var trim = this._texture.trim;
        var orig = this._texture.orig;

        // First lets check to see if the current texture has a trim..
        if (!trim || trim.width === orig.width && trim.height === orig.height) {
            // no trim! lets use the usual calculations..
            this.calculateVertices();
            this._bounds.addQuad(this.vertexData);
        } else {
            // lets calculate a special trimmed bounds...
            this.calculateTrimmedVertices();
            this._bounds.addQuad(this.vertexTrimmedData);
        }
    };

    /**
     * Gets the local bounds of the sprite object.
     *
     * @param {PIXI.Rectangle} rect - The output rectangle.
     * @return {PIXI.Rectangle} The bounds.
     */


    Sprite.prototype.getLocalBounds = function getLocalBounds(rect) {
        // we can do a fast local bounds if the sprite has no children!
        if (this.children.length === 0) {
            this._bounds.minX = this._texture.orig.width * -this._anchor._x;
            this._bounds.minY = this._texture.orig.height * -this._anchor._y;
            this._bounds.maxX = this._texture.orig.width * (1 - this._anchor._x);
            this._bounds.maxY = this._texture.orig.height * (1 - this._anchor._y);

            if (!rect) {
                if (!this._localBoundsRect) {
                    this._localBoundsRect = new _math.Rectangle();
                }

                rect = this._localBoundsRect;
            }

            return this._bounds.getRectangle(rect);
        }

        return _Container.prototype.getLocalBounds.call(this, rect);
    };

    /**
     * Tests if a point is inside this sprite
     *
     * @param {PIXI.Point} point - the point to test
     * @return {boolean} the result of the test
     */


    Sprite.prototype.containsPoint = function containsPoint(point) {
        this.worldTransform.applyInverse(point, tempPoint);

        var width = this._texture.orig.width;
        var height = this._texture.orig.height;
        var x1 = -width * this.anchor.x;
        var y1 = 0;

        if (tempPoint.x >= x1 && tempPoint.x < x1 + width) {
            y1 = -height * this.anchor.y;

            if (tempPoint.y >= y1 && tempPoint.y < y1 + height) {
                return true;
            }
        }

        return false;
    };

    /**
     * Destroys this sprite and optionally its texture and children
     *
     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options
     *  have been set to that value
     * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy
     *      method called as well. 'options' will be passed on to those calls.
     * @param {boolean} [options.texture=false] - Should it destroy the current texture of the sprite as well
     * @param {boolean} [options.baseTexture=false] - Should it destroy the base texture of the sprite as well
     */


    Sprite.prototype.destroy = function destroy(options) {
        _Container.prototype.destroy.call(this, options);

        this._texture.off('update', this._onTextureUpdate, this);

        this._anchor = null;

        var destroyTexture = typeof options === 'boolean' ? options : options && options.texture;

        if (destroyTexture) {
            var destroyBaseTexture = typeof options === 'boolean' ? options : options && options.baseTexture;

            this._texture.destroy(!!destroyBaseTexture);
        }

        this._texture = null;
        this.shader = null;
    };

    // some helper functions..

    /**
     * Helper function that creates a new sprite based on the source you provide.
     * The source can be - frame id, image url, video url, canvas element, video element, base texture
     *
     * @static
     * @param {number|string|PIXI.BaseTexture|HTMLCanvasElement|HTMLVideoElement} source Source to create texture from
     * @return {PIXI.Sprite} The newly created sprite
     */


    Sprite.from = function from(source) {
        return new Sprite(_Texture2.default.from(source));
    };

    /**
     * Helper function that creates a sprite that will contain a texture from the TextureCache based on the frameId
     * The frame ids are created when a Texture packer file has been loaded
     *
     * @static
     * @param {string} frameId - The frame Id of the texture in the cache
     * @return {PIXI.Sprite} A new Sprite using a texture from the texture cache matching the frameId
     */


    Sprite.fromFrame = function fromFrame(frameId) {
        var texture = _utils.TextureCache[frameId];

        if (!texture) {
            throw new Error('The frameId "' + frameId + '" does not exist in the texture cache');
        }

        return new Sprite(texture);
    };

    /**
     * Helper function that creates a sprite that will contain a texture based on an image url
     * If the image is not in the texture cache it will be loaded
     *
     * @static
     * @param {string} imageId - The image url of the texture
     * @param {boolean} [crossorigin=(auto)] - if you want to specify the cross-origin parameter
     * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - if you want to specify the scale mode,
     *  see {@link PIXI.SCALE_MODES} for possible values
     * @return {PIXI.Sprite} A new Sprite using a texture from the texture cache matching the image id
     */


    Sprite.fromImage = function fromImage(imageId, crossorigin, scaleMode) {
        return new Sprite(_Texture2.default.fromImage(imageId, crossorigin, scaleMode));
    };

    /**
     * The width of the sprite, setting this will actually modify the scale to achieve the value set
     *
     * @member {number}
     */


    _createClass(Sprite, [{
        key: 'width',
        get: function get() {
            return Math.abs(this.scale.x) * this._texture.orig.width;
        },
        set: function set(value) // eslint-disable-line require-jsdoc
        {
            var s = (0, _utils.sign)(this.scale.x) || 1;

            this.scale.x = s * value / this._texture.orig.width;
            this._width = value;
        }

        /**
         * The height of the sprite, setting this will actually modify the scale to achieve the value set
         *
         * @member {number}
         */

    }, {
        key: 'height',
        get: function get() {
            return Math.abs(this.scale.y) * this._texture.orig.height;
        },
        set: function set(value) // eslint-disable-line require-jsdoc
        {
            var s = (0, _utils.sign)(this.scale.y) || 1;

            this.scale.y = s * value / this._texture.orig.height;
            this._height = value;
        }

        /**
         * The anchor sets the origin point of the texture.
         * The default is 0,0 or taken from the {@link PIXI.Texture|Texture} passed to the constructor.
         * Setting the texture at a later point of time does not change the anchor.
         *
         * 0,0 means the texture's origin is the top left, 0.5,0.5 is the center, 1,1 the bottom right corner.
         *
         * @member {PIXI.ObservablePoint}
         */

    }, {
        key: 'anchor',
        get: function get() {
            return this._anchor;
        },
        set: function set(value) // eslint-disable-line require-jsdoc
        {
            this._anchor.copy(value);
        }

        /**
         * The tint applied to the sprite. This is a hex value.
         * A value of 0xFFFFFF will remove any tint effect.
         *
         * @member {number}
         * @default 0xFFFFFF
         */

    }, {
        key: 'tint',
        get: function get() {
            return this._tint;
        },
        set: function set(value) // eslint-disable-line require-jsdoc
        {
            this._tint = value;
            this._tintRGB = (value >> 16) + (value & 0xff00) + ((value & 0xff) << 16);
        }

        /**
         * The texture that the sprite is using
         *
         * @member {PIXI.Texture}
         */

    }, {
        key: 'texture',
        get: function get() {
            return this._texture;
        },
        set: function set(value) // eslint-disable-line require-jsdoc
        {
            if (this._texture === value) {
                return;
            }

            this._texture = value || _Texture2.default.EMPTY;
            this.cachedTint = 0xFFFFFF;

            this._textureID = -1;
            this._textureTrimmedID = -1;

            if (value) {
                // wait for the texture to load
                if (value.baseTexture.hasLoaded) {
                    this._onTextureUpdate();
                } else {
                    value.once('update', this._onTextureUpdate, this);
                }
            }
        }
    }]);

    return Sprite;
}(_Container3.default);

exports.default = Sprite;

},{"../const":53,"../display/Container":55,"../math":77,"../textures/Texture":122,"../utils":132}],110:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _CanvasRenderer = require('../../renderers/canvas/CanvasRenderer');

var _CanvasRenderer2 = _interopRequireDefault(_CanvasRenderer);

var _const = require('../../const');

var _math = require('../../math');

var _CanvasTinter = require('./CanvasTinter');

var _CanvasTinter2 = _interopRequireDefault(_CanvasTinter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var canvasRenderWorldTransform = new _math.Matrix();

/**
 * @author Mat Groves
 *
 * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/
 * for creating the original PixiJS version!
 * Also a thanks to https://github.com/bchevalier for tweaking the tint and alpha so that they now
 * share 4 bytes on the vertex buffer
 *
 * Heavily inspired by LibGDX's CanvasSpriteRenderer:
 * https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/CanvasSpriteRenderer.java
 */

/**
 * Renderer dedicated to drawing and batching sprites.
 *
 * @class
 * @private
 * @memberof PIXI
 */

var CanvasSpriteRenderer = function () {
    /**
     * @param {PIXI.WebGLRenderer} renderer -The renderer sprite this batch works for.
     */
    function CanvasSpriteRenderer(renderer) {
        _classCallCheck(this, CanvasSpriteRenderer);

        this.renderer = renderer;
    }

    /**
     * Renders the sprite object.
     *
     * @param {PIXI.Sprite} sprite - the sprite to render when using this spritebatch
     */


    CanvasSpriteRenderer.prototype.render = function render(sprite) {
        var texture = sprite._texture;
        var renderer = this.renderer;

        var width = texture._frame.width;
        var height = texture._frame.height;

        var wt = sprite.transform.worldTransform;
        var dx = 0;
        var dy = 0;

        if (texture.orig.width <= 0 || texture.orig.height <= 0 || !texture.baseTexture.source) {
            return;
        }

        renderer.setBlendMode(sprite.blendMode);

        //  Ignore null sources
        if (texture.valid) {
            renderer.context.globalAlpha = sprite.worldAlpha;

            // If smoothingEnabled is supported and we need to change the smoothing property for sprite texture
            var smoothingEnabled = texture.baseTexture.scaleMode === _const.SCALE_MODES.LINEAR;

            if (renderer.smoothProperty && renderer.context[renderer.smoothProperty] !== smoothingEnabled) {
                renderer.context[renderer.smoothProperty] = smoothingEnabled;
            }

            if (texture.trim) {
                dx = texture.trim.width / 2 + texture.trim.x - sprite.anchor.x * texture.orig.width;
                dy = texture.trim.height / 2 + texture.trim.y - sprite.anchor.y * texture.orig.height;
            } else {
                dx = (0.5 - sprite.anchor.x) * texture.orig.width;
                dy = (0.5 - sprite.anchor.y) * texture.orig.height;
            }

            if (texture.rotate) {
                wt.copy(canvasRenderWorldTransform);
                wt = canvasRenderWorldTransform;
                _math.GroupD8.matrixAppendRotationInv(wt, texture.rotate, dx, dy);
                // the anchor has already been applied above, so lets set it to zero
                dx = 0;
                dy = 0;
            }

            dx -= width / 2;
            dy -= height / 2;

            // Allow for pixel rounding
            if (renderer.roundPixels) {
                renderer.context.setTransform(wt.a, wt.b, wt.c, wt.d, wt.tx * renderer.resolution | 0, wt.ty * renderer.resolution | 0);

                dx = dx | 0;
                dy = dy | 0;
            } else {
                renderer.context.setTransform(wt.a, wt.b, wt.c, wt.d, wt.tx * renderer.resolution, wt.ty * renderer.resolution);
            }

            var resolution = texture.baseTexture.resolution;

            if (sprite.tint !== 0xFFFFFF) {
                if (sprite.cachedTint !== sprite.tint || sprite.tintedTexture.tintId !== sprite._texture._updateID) {
                    sprite.cachedTint = sprite.tint;

                    // TODO clean up caching - how to clean up the caches?
                    sprite.tintedTexture = _CanvasTinter2.default.getTintedTexture(sprite, sprite.tint);
                }

                renderer.context.drawImage(sprite.tintedTexture, 0, 0, width * resolution, height * resolution, dx * renderer.resolution, dy * renderer.resolution, width * renderer.resolution, height * renderer.resolution);
            } else {
                renderer.context.drawImage(texture.baseTexture.source, texture._frame.x * resolution, texture._frame.y * resolution, width * resolution, height * resolution, dx * renderer.resolution, dy * renderer.resolution, width * renderer.resolution, height * renderer.resolution);
            }
        }
    };

    /**
     * destroy the sprite object.
     *
     */


    CanvasSpriteRenderer.prototype.destroy = function destroy() {
        this.renderer = null;
    };

    return CanvasSpriteRenderer;
}();

exports.default = CanvasSpriteRenderer;


_CanvasRenderer2.default.registerPlugin('sprite', CanvasSpriteRenderer);

},{"../../const":53,"../../math":77,"../../renderers/canvas/CanvasRenderer":84,"./CanvasTinter":111}],111:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _utils = require('../../utils');

var _canUseNewCanvasBlendModes = require('../../renderers/canvas/utils/canUseNewCanvasBlendModes');

var _canUseNewCanvasBlendModes2 = _interopRequireDefault(_canUseNewCanvasBlendModes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Utility methods for Sprite/Texture tinting.
 *
 * @class
 * @memberof PIXI
 */
var CanvasTinter = {
    /**
     * Basically this method just needs a sprite and a color and tints the sprite with the given color.
     *
     * @memberof PIXI.CanvasTinter
     * @param {PIXI.Sprite} sprite - the sprite to tint
     * @param {number} color - the color to use to tint the sprite with
     * @return {HTMLCanvasElement} The tinted canvas
     */
    getTintedTexture: function getTintedTexture(sprite, color) {
        var texture = sprite._texture;

        color = CanvasTinter.roundColor(color);

        var stringColor = '#' + ('00000' + (color | 0).toString(16)).substr(-6);

        texture.tintCache = texture.tintCache || {};

        var cachedTexture = texture.tintCache[stringColor];

        var canvas = void 0;

        if (cachedTexture) {
            if (cachedTexture.tintId === texture._updateID) {
                return texture.tintCache[stringColor];
            }

            canvas = texture.tintCache[stringColor];
        } else {
            canvas = CanvasTinter.canvas || document.createElement('canvas');
        }

        CanvasTinter.tintMethod(texture, color, canvas);

        canvas.tintId = texture._updateID;

        if (CanvasTinter.convertTintToImage) {
            // is this better?
            var tintImage = new Image();

            tintImage.src = canvas.toDataURL();

            texture.tintCache[stringColor] = tintImage;
        } else {
            texture.tintCache[stringColor] = canvas;
            // if we are not converting the texture to an image then we need to lose the reference to the canvas
            CanvasTinter.canvas = null;
        }

        return canvas;
    },

    /**
     * Tint a texture using the 'multiply' operation.
     *
     * @memberof PIXI.CanvasTinter
     * @param {PIXI.Texture} texture - the texture to tint
     * @param {number} color - the color to use to tint the sprite with
     * @param {HTMLCanvasElement} canvas - the current canvas
     */
    tintWithMultiply: function tintWithMultiply(texture, color, canvas) {
        var context = canvas.getContext('2d');
        var crop = texture._frame.clone();
        var resolution = texture.baseTexture.resolution;

        crop.x *= resolution;
        crop.y *= resolution;
        crop.width *= resolution;
        crop.height *= resolution;

        canvas.width = Math.ceil(crop.width);
        canvas.height = Math.ceil(crop.height);

        context.save();
        context.fillStyle = '#' + ('00000' + (color | 0).toString(16)).substr(-6);

        context.fillRect(0, 0, crop.width, crop.height);

        context.globalCompositeOperation = 'multiply';

        context.drawImage(texture.baseTexture.source, crop.x, crop.y, crop.width, crop.height, 0, 0, crop.width, crop.height);

        context.globalCompositeOperation = 'destination-atop';

        context.drawImage(texture.baseTexture.source, crop.x, crop.y, crop.width, crop.height, 0, 0, crop.width, crop.height);
        context.restore();
    },

    /**
     * Tint a texture using the 'overlay' operation.
     *
     * @memberof PIXI.CanvasTinter
     * @param {PIXI.Texture} texture - the texture to tint
     * @param {number} color - the color to use to tint the sprite with
     * @param {HTMLCanvasElement} canvas - the current canvas
     */
    tintWithOverlay: function tintWithOverlay(texture, color, canvas) {
        var context = canvas.getContext('2d');
        var crop = texture._frame.clone();
        var resolution = texture.baseTexture.resolution;

        crop.x *= resolution;
        crop.y *= resolution;
        crop.width *= resolution;
        crop.height *= resolution;

        canvas.width = Math.ceil(crop.width);
        canvas.height = Math.ceil(crop.height);

        context.save();
        context.globalCompositeOperation = 'copy';
        context.fillStyle = '#' + ('00000' + (color | 0).toString(16)).substr(-6);
        context.fillRect(0, 0, crop.width, crop.height);

        context.globalCompositeOperation = 'destination-atop';
        context.drawImage(texture.baseTexture.source, crop.x, crop.y, crop.width, crop.height, 0, 0, crop.width, crop.height);

        // context.globalCompositeOperation = 'copy';
        context.restore();
    },


    /**
     * Tint a texture pixel per pixel.
     *
     * @memberof PIXI.CanvasTinter
     * @param {PIXI.Texture} texture - the texture to tint
     * @param {number} color - the color to use to tint the sprite with
     * @param {HTMLCanvasElement} canvas - the current canvas
     */
    tintWithPerPixel: function tintWithPerPixel(texture, color, canvas) {
        var context = canvas.getContext('2d');
        var crop = texture._frame.clone();
        var resolution = texture.baseTexture.resolution;

        crop.x *= resolution;
        crop.y *= resolution;
        crop.width *= resolution;
        crop.height *= resolution;

        canvas.width = Math.ceil(crop.width);
        canvas.height = Math.ceil(crop.height);

        context.save();
        context.globalCompositeOperation = 'copy';
        context.drawImage(texture.baseTexture.source, crop.x, crop.y, crop.width, crop.height, 0, 0, crop.width, crop.height);
        context.restore();

        var rgbValues = (0, _utils.hex2rgb)(color);
        var r = rgbValues[0];
        var g = rgbValues[1];
        var b = rgbValues[2];

        var pixelData = context.getImageData(0, 0, crop.width, crop.height);

        var pixels = pixelData.data;

        for (var i = 0; i < pixels.length; i += 4) {
            pixels[i + 0] *= r;
            pixels[i + 1] *= g;
            pixels[i + 2] *= b;
        }

        context.putImageData(pixelData, 0, 0);
    },

    /**
     * Rounds the specified color according to the CanvasTinter.cacheStepsPerColorChannel.
     *
     * @memberof PIXI.CanvasTinter
     * @param {number} color - the color to round, should be a hex color
     * @return {number} The rounded color.
     */
    roundColor: function roundColor(color) {
        var step = CanvasTinter.cacheStepsPerColorChannel;

        var rgbValues = (0, _utils.hex2rgb)(color);

        rgbValues[0] = Math.min(255, rgbValues[0] / step * step);
        rgbValues[1] = Math.min(255, rgbValues[1] / step * step);
        rgbValues[2] = Math.min(255, rgbValues[2] / step * step);

        return (0, _utils.rgb2hex)(rgbValues);
    },

    /**
     * Number of steps which will be used as a cap when rounding colors.
     *
     * @memberof PIXI.CanvasTinter
     * @type {number}
     */
    cacheStepsPerColorChannel: 8,

    /**
     * Tint cache boolean flag.
     *
     * @memberof PIXI.CanvasTinter
     * @type {boolean}
     */
    convertTintToImage: false,

    /**
     * Whether or not the Canvas BlendModes are supported, consequently the ability to tint using the multiply method.
     *
     * @memberof PIXI.CanvasTinter
     * @type {boolean}
     */
    canUseMultiply: (0, _canUseNewCanvasBlendModes2.default)(),

    /**
     * The tinting method that will be used.
     *
     * @memberof PIXI.CanvasTinter
     * @type {tintMethodFunctionType}
     */
    tintMethod: 0
};

CanvasTinter.tintMethod = CanvasTinter.canUseMultiply ? CanvasTinter.tintWithMultiply : CanvasTinter.tintWithPerPixel;

/**
 * The tintMethod type.
 *
 * @memberof PIXI.CanvasTinter
 * @callback tintMethodFunctionType
 * @param texture {PIXI.Texture} the texture to tint
 * @param color {number} the color to use to tint the sprite with
 * @param canvas {HTMLCanvasElement} the current canvas
 */

exports.default = CanvasTinter;

},{"../../renderers/canvas/utils/canUseNewCanvasBlendModes":87,"../../utils":132}],112:[function(require,module,exports){
"use strict";

exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class
 * @memberof PIXI
 */
var Buffer = function () {
  /**
   * @param {number} size - The size of the buffer in bytes.
   */
  function Buffer(size) {
    _classCallCheck(this, Buffer);

    this.vertices = new ArrayBuffer(size);

    /**
     * View on the vertices as a Float32Array for positions
     *
     * @member {Float32Array}
     */
    this.float32View = new Float32Array(this.vertices);

    /**
     * View on the vertices as a Uint32Array for uvs
     *
     * @member {Float32Array}
     */
    this.uint32View = new Uint32Array(this.vertices);
  }

  /**
   * Destroys the buffer.
   *
   */


  Buffer.prototype.destroy = function destroy() {
    this.vertices = null;
    this.positions = null;
    this.uvs = null;
    this.colors = null;
  };

  return Buffer;
}();

exports.default = Buffer;

},{}],113:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _ObjectRenderer2 = require('../../renderers/webgl/utils/ObjectRenderer');

var _ObjectRenderer3 = _interopRequireDefault(_ObjectRenderer2);

var _WebGLRenderer = require('../../renderers/webgl/WebGLRenderer');

var _WebGLRenderer2 = _interopRequireDefault(_WebGLRenderer);

var _createIndicesForQuads = require('../../utils/createIndicesForQuads');

var _createIndicesForQuads2 = _interopRequireDefault(_createIndicesForQuads);

var _generateMultiTextureShader = require('./generateMultiTextureShader');

var _generateMultiTextureShader2 = _interopRequireDefault(_generateMultiTextureShader);

var _checkMaxIfStatmentsInShader = require('../../renderers/webgl/utils/checkMaxIfStatmentsInShader');

var _checkMaxIfStatmentsInShader2 = _interopRequireDefault(_checkMaxIfStatmentsInShader);

var _BatchBuffer = require('./BatchBuffer');

var _BatchBuffer2 = _interopRequireDefault(_BatchBuffer);

var _settings = require('../../settings');

var _settings2 = _interopRequireDefault(_settings);

var _utils = require('../../utils');

var _pixiGlCore = require('pixi-gl-core');

var _pixiGlCore2 = _interopRequireDefault(_pixiGlCore);

var _bitTwiddle = require('bit-twiddle');

var _bitTwiddle2 = _interopRequireDefault(_bitTwiddle);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var TICK = 0;
var TEXTURE_TICK = 0;

/**
 * Renderer dedicated to drawing and batching sprites.
 *
 * @class
 * @private
 * @memberof PIXI
 * @extends PIXI.ObjectRenderer
 */

var SpriteRenderer = function (_ObjectRenderer) {
    _inherits(SpriteRenderer, _ObjectRenderer);

    /**
     * @param {PIXI.WebGLRenderer} renderer - The renderer this sprite batch works for.
     */
    function SpriteRenderer(renderer) {
        _classCallCheck(this, SpriteRenderer);

        /**
         * Number of values sent in the vertex buffer.
         * aVertexPosition(2), aTextureCoord(1), aColor(1), aTextureId(1) = 5
         *
         * @member {number}
         */
        var _this = _possibleConstructorReturn(this, _ObjectRenderer.call(this, renderer));

        _this.vertSize = 5;

        /**
         * The size of the vertex information in bytes.
         *
         * @member {number}
         */
        _this.vertByteSize = _this.vertSize * 4;

        /**
         * The number of images in the SpriteRenderer before it flushes.
         *
         * @member {number}
         */
        _this.size = _settings2.default.SPRITE_BATCH_SIZE; // 2000 is a nice balance between mobile / desktop

        // the total number of bytes in our batch
        // let numVerts = this.size * 4 * this.vertByteSize;

        _this.buffers = [];
        for (var i = 1; i <= _bitTwiddle2.default.nextPow2(_this.size); i *= 2) {
            _this.buffers.push(new _BatchBuffer2.default(i * 4 * _this.vertByteSize));
        }

        /**
         * Holds the indices of the geometry (quads) to draw
         *
         * @member {Uint16Array}
         */
        _this.indices = (0, _createIndicesForQuads2.default)(_this.size);

        /**
         * The default shaders that is used if a sprite doesn't have a more specific one.
         * there is a shader for each number of textures that can be rendererd.
         * These shaders will also be generated on the fly as required.
         * @member {PIXI.Shader[]}
         */
        _this.shader = null;

        _this.currentIndex = 0;
        _this.groups = [];

        for (var k = 0; k < _this.size; k++) {
            _this.groups[k] = { textures: [], textureCount: 0, ids: [], size: 0, start: 0, blend: 0 };
        }

        _this.sprites = [];

        _this.vertexBuffers = [];
        _this.vaos = [];

        _this.vaoMax = 2;
        _this.vertexCount = 0;

        _this.renderer.on('prerender', _this.onPrerender, _this);
        return _this;
    }

    /**
     * Sets up the renderer context and necessary buffers.
     *
     * @private
     */


    SpriteRenderer.prototype.onContextChange = function onContextChange() {
        var gl = this.renderer.gl;

        if (this.renderer.legacy) {
            this.MAX_TEXTURES = 1;
        } else {
            // step 1: first check max textures the GPU can handle.
            this.MAX_TEXTURES = Math.min(gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS), _settings2.default.SPRITE_MAX_TEXTURES);

            // step 2: check the maximum number of if statements the shader can have too..
            this.MAX_TEXTURES = (0, _checkMaxIfStatmentsInShader2.default)(this.MAX_TEXTURES, gl);
        }

        this.shader = (0, _generateMultiTextureShader2.default)(gl, this.MAX_TEXTURES);

        // create a couple of buffers
        this.indexBuffer = _pixiGlCore2.default.GLBuffer.createIndexBuffer(gl, this.indices, gl.STATIC_DRAW);

        // we use the second shader as the first one depending on your browser may omit aTextureId
        // as it is not used by the shader so is optimized out.

        this.renderer.bindVao(null);

        var attrs = this.shader.attributes;

        for (var i = 0; i < this.vaoMax; i++) {
            /* eslint-disable max-len */
            var vertexBuffer = this.vertexBuffers[i] = _pixiGlCore2.default.GLBuffer.createVertexBuffer(gl, null, gl.STREAM_DRAW);
            /* eslint-enable max-len */

            // build the vao object that will render..
            var vao = this.renderer.createVao().addIndex(this.indexBuffer).addAttribute(vertexBuffer, attrs.aVertexPosition, gl.FLOAT, false, this.vertByteSize, 0).addAttribute(vertexBuffer, attrs.aTextureCoord, gl.UNSIGNED_SHORT, true, this.vertByteSize, 2 * 4).addAttribute(vertexBuffer, attrs.aColor, gl.UNSIGNED_BYTE, true, this.vertByteSize, 3 * 4);

            if (attrs.aTextureId) {
                vao.addAttribute(vertexBuffer, attrs.aTextureId, gl.FLOAT, false, this.vertByteSize, 4 * 4);
            }

            this.vaos[i] = vao;
        }

        this.vao = this.vaos[0];
        this.currentBlendMode = 99999;

        this.boundTextures = new Array(this.MAX_TEXTURES);
    };

    /**
     * Called before the renderer starts rendering.
     *
     */


    SpriteRenderer.prototype.onPrerender = function onPrerender() {
        this.vertexCount = 0;
    };

    /**
     * Renders the sprite object.
     *
     * @param {PIXI.Sprite} sprite - the sprite to render when using this spritebatch
     */


    SpriteRenderer.prototype.render = function render(sprite) {
        // TODO set blend modes..
        // check texture..
        if (this.currentIndex >= this.size) {
            this.flush();
        }

        // get the uvs for the texture

        // if the uvs have not updated then no point rendering just yet!
        if (!sprite._texture._uvs) {
            return;
        }

        // push a texture.
        // increment the batchsize
        this.sprites[this.currentIndex++] = sprite;
    };

    /**
     * Renders the content and empties the current batch.
     *
     */


    SpriteRenderer.prototype.flush = function flush() {
        if (this.currentIndex === 0) {
            return;
        }

        var gl = this.renderer.gl;
        var MAX_TEXTURES = this.MAX_TEXTURES;

        var np2 = _bitTwiddle2.default.nextPow2(this.currentIndex);
        var log2 = _bitTwiddle2.default.log2(np2);
        var buffer = this.buffers[log2];

        var sprites = this.sprites;
        var groups = this.groups;

        var float32View = buffer.float32View;
        var uint32View = buffer.uint32View;

        var boundTextures = this.boundTextures;
        var rendererBoundTextures = this.renderer.boundTextures;
        var touch = this.renderer.textureGC.count;

        var index = 0;
        var nextTexture = void 0;
        var currentTexture = void 0;
        var groupCount = 1;
        var textureCount = 0;
        var currentGroup = groups[0];
        var vertexData = void 0;
        var uvs = void 0;
        var blendMode = _utils.premultiplyBlendMode[sprites[0]._texture.baseTexture.premultipliedAlpha ? 1 : 0][sprites[0].blendMode];

        currentGroup.textureCount = 0;
        currentGroup.start = 0;
        currentGroup.blend = blendMode;

        TICK++;

        var i = void 0;

        // copy textures..
        for (i = 0; i < MAX_TEXTURES; ++i) {
            var bt = rendererBoundTextures[i];

            if (bt._enabled === TICK) {
                boundTextures[i] = this.renderer.emptyTextures[i];
                continue;
            }

            boundTextures[i] = bt;
            bt._virtalBoundId = i;
            bt._enabled = TICK;
        }
        TICK++;

        for (i = 0; i < this.currentIndex; ++i) {
            // upload the sprite elemetns...
            // they have all ready been calculated so we just need to push them into the buffer.
            var sprite = sprites[i];

            sprites[i] = null;

            nextTexture = sprite._texture.baseTexture;

            var spriteBlendMode = _utils.premultiplyBlendMode[Number(nextTexture.premultipliedAlpha)][sprite.blendMode];

            if (blendMode !== spriteBlendMode) {
                // finish a group..
                blendMode = spriteBlendMode;

                // force the batch to break!
                currentTexture = null;
                textureCount = MAX_TEXTURES;
                TICK++;
            }

            if (currentTexture !== nextTexture) {
                currentTexture = nextTexture;

                if (nextTexture._enabled !== TICK) {
                    if (textureCount === MAX_TEXTURES) {
                        TICK++;

                        currentGroup.size = i - currentGroup.start;

                        textureCount = 0;

                        currentGroup = groups[groupCount++];
                        currentGroup.blend = blendMode;
                        currentGroup.textureCount = 0;
                        currentGroup.start = i;
                    }

                    nextTexture.touched = touch;

                    if (nextTexture._virtalBoundId === -1) {
                        for (var j = 0; j < MAX_TEXTURES; ++j) {
                            var tIndex = (j + TEXTURE_TICK) % MAX_TEXTURES;

                            var t = boundTextures[tIndex];

                            if (t._enabled !== TICK) {
                                TEXTURE_TICK++;

                                t._virtalBoundId = -1;

                                nextTexture._virtalBoundId = tIndex;

                                boundTextures[tIndex] = nextTexture;
                                break;
                            }
                        }
                    }

                    nextTexture._enabled = TICK;

                    currentGroup.textureCount++;
                    currentGroup.ids[textureCount] = nextTexture._virtalBoundId;
                    currentGroup.textures[textureCount++] = nextTexture;
                }
            }

            vertexData = sprite.vertexData;

            // TODO this sum does not need to be set each frame..
            uvs = sprite._texture._uvs.uvsUint32;

            if (this.renderer.roundPixels) {
                var resolution = this.renderer.resolution;

                // xy
                float32View[index] = (vertexData[0] * resolution | 0) / resolution;
                float32View[index + 1] = (vertexData[1] * resolution | 0) / resolution;

                // xy
                float32View[index + 5] = (vertexData[2] * resolution | 0) / resolution;
                float32View[index + 6] = (vertexData[3] * resolution | 0) / resolution;

                // xy
                float32View[index + 10] = (vertexData[4] * resolution | 0) / resolution;
                float32View[index + 11] = (vertexData[5] * resolution | 0) / resolution;

                // xy
                float32View[index + 15] = (vertexData[6] * resolution | 0) / resolution;
                float32View[index + 16] = (vertexData[7] * resolution | 0) / resolution;
            } else {
                // xy
                float32View[index] = vertexData[0];
                float32View[index + 1] = vertexData[1];

                // xy
                float32View[index + 5] = vertexData[2];
                float32View[index + 6] = vertexData[3];

                // xy
                float32View[index + 10] = vertexData[4];
                float32View[index + 11] = vertexData[5];

                // xy
                float32View[index + 15] = vertexData[6];
                float32View[index + 16] = vertexData[7];
            }

            uint32View[index + 2] = uvs[0];
            uint32View[index + 7] = uvs[1];
            uint32View[index + 12] = uvs[2];
            uint32View[index + 17] = uvs[3];
            /* eslint-disable max-len */
            var alpha = Math.min(sprite.worldAlpha, 1.0);
            // we dont call extra function if alpha is 1.0, that's faster
            var argb = alpha < 1.0 && nextTexture.premultipliedAlpha ? (0, _utils.premultiplyTint)(sprite._tintRGB, alpha) : sprite._tintRGB + (alpha * 255 << 24);

            uint32View[index + 3] = uint32View[index + 8] = uint32View[index + 13] = uint32View[index + 18] = argb;
            float32View[index + 4] = float32View[index + 9] = float32View[index + 14] = float32View[index + 19] = nextTexture._virtalBoundId;
            /* eslint-enable max-len */

            index += 20;
        }

        currentGroup.size = i - currentGroup.start;

        if (!_settings2.default.CAN_UPLOAD_SAME_BUFFER) {
            // this is still needed for IOS performance..
            // it really does not like uploading to the same buffer in a single frame!
            if (this.vaoMax <= this.vertexCount) {
                this.vaoMax++;

                var attrs = this.shader.attributes;

                /* eslint-disable max-len */
                var vertexBuffer = this.vertexBuffers[this.vertexCount] = _pixiGlCore2.default.GLBuffer.createVertexBuffer(gl, null, gl.STREAM_DRAW);
                /* eslint-enable max-len */

                // build the vao object that will render..
                var vao = this.renderer.createVao().addIndex(this.indexBuffer).addAttribute(vertexBuffer, attrs.aVertexPosition, gl.FLOAT, false, this.vertByteSize, 0).addAttribute(vertexBuffer, attrs.aTextureCoord, gl.UNSIGNED_SHORT, true, this.vertByteSize, 2 * 4).addAttribute(vertexBuffer, attrs.aColor, gl.UNSIGNED_BYTE, true, this.vertByteSize, 3 * 4);

                if (attrs.aTextureId) {
                    vao.addAttribute(vertexBuffer, attrs.aTextureId, gl.FLOAT, false, this.vertByteSize, 4 * 4);
                }

                this.vaos[this.vertexCount] = vao;
            }

            this.renderer.bindVao(this.vaos[this.vertexCount]);

            this.vertexBuffers[this.vertexCount].upload(buffer.vertices, 0, false);

            this.vertexCount++;
        } else {
            // lets use the faster option, always use buffer number 0
            this.vertexBuffers[this.vertexCount].upload(buffer.vertices, 0, true);
        }

        for (i = 0; i < MAX_TEXTURES; ++i) {
            rendererBoundTextures[i]._virtalBoundId = -1;
        }

        // render the groups..
        for (i = 0; i < groupCount; ++i) {
            var group = groups[i];
            var groupTextureCount = group.textureCount;

            for (var _j = 0; _j < groupTextureCount; _j++) {
                currentTexture = group.textures[_j];

                // reset virtual ids..
                // lets do a quick check..
                if (rendererBoundTextures[group.ids[_j]] !== currentTexture) {
                    this.renderer.bindTexture(currentTexture, group.ids[_j], true);
                }

                // reset the virtualId..
                currentTexture._virtalBoundId = -1;
            }

            // set the blend mode..
            this.renderer.state.setBlendMode(group.blend);

            gl.drawElements(gl.TRIANGLES, group.size * 6, gl.UNSIGNED_SHORT, group.start * 6 * 2);
        }

        // reset elements for the next flush
        this.currentIndex = 0;
    };

    /**
     * Starts a new sprite batch.
     */


    SpriteRenderer.prototype.start = function start() {
        this.renderer.bindShader(this.shader);

        if (_settings2.default.CAN_UPLOAD_SAME_BUFFER) {
            // bind buffer #0, we don't need others
            this.renderer.bindVao(this.vaos[this.vertexCount]);

            this.vertexBuffers[this.vertexCount].bind();
        }
    };

    /**
     * Stops and flushes the current batch.
     *
     */


    SpriteRenderer.prototype.stop = function stop() {
        this.flush();
    };

    /**
     * Destroys the SpriteRenderer.
     *
     */


    SpriteRenderer.prototype.destroy = function destroy() {
        for (var i = 0; i < this.vaoMax; i++) {
            if (this.vertexBuffers[i]) {
                this.vertexBuffers[i].destroy();
            }
            if (this.vaos[i]) {
                this.vaos[i].destroy();
            }
        }

        if (this.indexBuffer) {
            this.indexBuffer.destroy();
        }

        this.renderer.off('prerender', this.onPrerender, this);

        _ObjectRenderer.prototype.destroy.call(this);

        if (this.shader) {
            this.shader.destroy();
            this.shader = null;
        }

        this.vertexBuffers = null;
        this.vaos = null;
        this.indexBuffer = null;
        this.indices = null;

        this.sprites = null;

        for (var _i = 0; _i < this.buffers.length; ++_i) {
            this.buffers[_i].destroy();
        }
    };

    return SpriteRenderer;
}(_ObjectRenderer3.default);

exports.default = SpriteRenderer;


_WebGLRenderer2.default.registerPlugin('sprite', SpriteRenderer);

},{"../../renderers/webgl/WebGLRenderer":91,"../../renderers/webgl/utils/ObjectRenderer":101,"../../renderers/webgl/utils/checkMaxIfStatmentsInShader":104,"../../settings":108,"../../utils":132,"../../utils/createIndicesForQuads":130,"./BatchBuffer":112,"./generateMultiTextureShader":114,"bit-twiddle":22,"pixi-gl-core":36}],114:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.default = generateMultiTextureShader;

var _Shader = require('../../Shader');

var _Shader2 = _interopRequireDefault(_Shader);

var _path = require('path');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var fragTemplate = ['varying vec2 vTextureCoord;', 'varying vec4 vColor;', 'varying float vTextureId;', 'uniform sampler2D uSamplers[%count%];', 'void main(void){', 'vec4 color;', '%forloop%', 'gl_FragColor = color * vColor;', '}'].join('\n');

function generateMultiTextureShader(gl, maxTextures) {
    var vertexSrc = 'precision highp float;\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\nattribute float aTextureId;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\n\nvoid main(void){\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vTextureId = aTextureId;\n    vColor = aColor;\n}\n';
    var fragmentSrc = fragTemplate;

    fragmentSrc = fragmentSrc.replace(/%count%/gi, maxTextures);
    fragmentSrc = fragmentSrc.replace(/%forloop%/gi, generateSampleSrc(maxTextures));

    var shader = new _Shader2.default(gl, vertexSrc, fragmentSrc);

    var sampleValues = [];

    for (var i = 0; i < maxTextures; i++) {
        sampleValues[i] = i;
    }

    shader.bind();
    shader.uniforms.uSamplers = sampleValues;

    return shader;
}

function generateSampleSrc(maxTextures) {
    var src = '';

    src += '\n';
    src += '\n';

    for (var i = 0; i < maxTextures; i++) {
        if (i > 0) {
            src += '\nelse ';
        }

        if (i < maxTextures - 1) {
            src += 'if(vTextureId < ' + i + '.5)';
        }

        src += '\n{';
        src += '\n\tcolor = texture2D(uSamplers[' + i + '], vTextureCoord);';
        src += '\n}';
    }

    src += '\n';
    src += '\n';

    return src;
}

},{"../../Shader":51,"path":1}],115:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Sprite2 = require('../sprites/Sprite');

var _Sprite3 = _interopRequireDefault(_Sprite2);

var _Texture = require('../textures/Texture');

var _Texture2 = _interopRequireDefault(_Texture);

var _math = require('../math');

var _utils = require('../utils');

var _const = require('../const');

var _settings = require('../settings');

var _settings2 = _interopRequireDefault(_settings);

var _TextStyle = require('./TextStyle');

var _TextStyle2 = _interopRequireDefault(_TextStyle);

var _TextMetrics = require('./TextMetrics');

var _TextMetrics2 = _interopRequireDefault(_TextMetrics);

var _trimCanvas = require('../utils/trimCanvas');

var _trimCanvas2 = _interopRequireDefault(_trimCanvas);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint max-depth: [2, 8] */


var defaultDestroyOptions = {
    texture: true,
    children: false,
    baseTexture: true
};

/**
 * A Text Object will create a line or multiple lines of text. To split a line you can use '\n' in your text string,
 * or add a wordWrap property set to true and and wordWrapWidth property with a value in the style object.
 *
 * A Text can be created directly from a string and a style object,
 * which can be generated [here](https://pixijs.io/pixi-text-style).
 *
 * ```js
 * let text = new PIXI.Text('This is a PixiJS text',{fontFamily : 'Arial', fontSize: 24, fill : 0xff1010, align : 'center'});
 * ```
 *
 * @class
 * @extends PIXI.Sprite
 * @memberof PIXI
 */

var Text = function (_Sprite) {
    _inherits(Text, _Sprite);

    /**
     * @param {string} text - The string that you would like the text to display
     * @param {object|PIXI.TextStyle} [style] - The style parameters
     * @param {HTMLCanvasElement} [canvas] - The canvas element for drawing text
     */
    function Text(text, style, canvas) {
        _classCallCheck(this, Text);

        canvas = canvas || document.createElement('canvas');

        canvas.width = 3;
        canvas.height = 3;

        var texture = _Texture2.default.fromCanvas(canvas, _settings2.default.SCALE_MODE, 'text');

        texture.orig = new _math.Rectangle();
        texture.trim = new _math.Rectangle();

        // base texture is already automatically added to the cache, now adding the actual texture
        var _this = _possibleConstructorReturn(this, _Sprite.call(this, texture));

        _Texture2.default.addToCache(_this._texture, _this._texture.baseTexture.textureCacheIds[0]);

        /**
         * The canvas element that everything is drawn to
         *
         * @member {HTMLCanvasElement}
         */
        _this.canvas = canvas;

        /**
         * The canvas 2d context that everything is drawn with
         * @member {CanvasRenderingContext2D}
         */
        _this.context = _this.canvas.getContext('2d');

        /**
         * The resolution / device pixel ratio of the canvas. This is set automatically by the renderer.
         * @member {number}
         * @default 1
         */
        _this.resolution = _settings2.default.RESOLUTION;

        /**
         * Private tracker for the current text.
         *
         * @member {string}
         * @private
         */
        _this._text = null;

        /**
         * Private tracker for the current style.
         *
         * @member {object}
         * @private
         */
        _this._style = null;
        /**
         * Private listener to track style changes.
         *
         * @member {Function}
         * @private
         */
        _this._styleListener = null;

        /**
         * Private tracker for the current font.
         *
         * @member {string}
         * @private
         */
        _this._font = '';

        _this.text = text;
        _this.style = style;

        _this.localStyleID = -1;
        return _this;
    }

    /**
     * Renders text and updates it when needed.
     *
     * @private
     * @param {boolean} respectDirty - Whether to abort updating the text if the Text isn't dirty and the function is called.
     */


    Text.prototype.updateText = function updateText(respectDirty) {
        var style = this._style;

        // check if style has changed..
        if (this.localStyleID !== style.styleID) {
            this.dirty = true;
            this.localStyleID = style.styleID;
        }

        if (!this.dirty && respectDirty) {
            return;
        }

        this._font = this._style.toFontString();

        var context = this.context;
        var measured = _TextMetrics2.default.measureText(this._text, this._style, this._style.wordWrap, this.canvas);
        var width = measured.width;
        var height = measured.height;
        var lines = measured.lines;
        var lineHeight = measured.lineHeight;
        var lineWidths = measured.lineWidths;
        var maxLineWidth = measured.maxLineWidth;
        var fontProperties = measured.fontProperties;

        this.canvas.width = Math.ceil((Math.max(1, width) + style.padding * 2) * this.resolution);
        this.canvas.height = Math.ceil((Math.max(1, height) + style.padding * 2) * this.resolution);

        context.scale(this.resolution, this.resolution);

        context.clearRect(0, 0, this.canvas.width, this.canvas.height);

        context.font = this._font;
        context.strokeStyle = style.stroke;
        context.lineWidth = style.strokeThickness;
        context.textBaseline = style.textBaseline;
        context.lineJoin = style.lineJoin;
        context.miterLimit = style.miterLimit;

        var linePositionX = void 0;
        var linePositionY = void 0;

        if (style.dropShadow) {
            context.fillStyle = style.dropShadowColor;
            context.globalAlpha = style.dropShadowAlpha;
            context.shadowBlur = style.dropShadowBlur;

            if (style.dropShadowBlur > 0) {
                context.shadowColor = style.dropShadowColor;
            }

            var xShadowOffset = Math.cos(style.dropShadowAngle) * style.dropShadowDistance;
            var yShadowOffset = Math.sin(style.dropShadowAngle) * style.dropShadowDistance;

            for (var i = 0; i < lines.length; i++) {
                linePositionX = style.strokeThickness / 2;
                linePositionY = style.strokeThickness / 2 + i * lineHeight + fontProperties.ascent;

                if (style.align === 'right') {
                    linePositionX += maxLineWidth - lineWidths[i];
                } else if (style.align === 'center') {
                    linePositionX += (maxLineWidth - lineWidths[i]) / 2;
                }

                if (style.fill) {
                    this.drawLetterSpacing(lines[i], linePositionX + xShadowOffset + style.padding, linePositionY + yShadowOffset + style.padding);

                    if (style.stroke && style.strokeThickness) {
                        context.strokeStyle = style.dropShadowColor;
                        this.drawLetterSpacing(lines[i], linePositionX + xShadowOffset + style.padding, linePositionY + yShadowOffset + style.padding, true);
                        context.strokeStyle = style.stroke;
                    }
                }
            }
        }

        // reset the shadow blur and alpha that was set by the drop shadow, for the regular text
        context.shadowBlur = 0;
        context.globalAlpha = 1;

        // set canvas text styles
        context.fillStyle = this._generateFillStyle(style, lines);

        // draw lines line by line
        for (var _i = 0; _i < lines.length; _i++) {
            linePositionX = style.strokeThickness / 2;
            linePositionY = style.strokeThickness / 2 + _i * lineHeight + fontProperties.ascent;

            if (style.align === 'right') {
                linePositionX += maxLineWidth - lineWidths[_i];
            } else if (style.align === 'center') {
                linePositionX += (maxLineWidth - lineWidths[_i]) / 2;
            }

            if (style.stroke && style.strokeThickness) {
                this.drawLetterSpacing(lines[_i], linePositionX + style.padding, linePositionY + style.padding, true);
            }

            if (style.fill) {
                this.drawLetterSpacing(lines[_i], linePositionX + style.padding, linePositionY + style.padding);
            }
        }

        this.updateTexture();
    };

    /**
     * Render the text with letter-spacing.
     * @param {string} text - The text to draw
     * @param {number} x - Horizontal position to draw the text
     * @param {number} y - Vertical position to draw the text
     * @param {boolean} [isStroke=false] - Is this drawing for the outside stroke of the
     *  text? If not, it's for the inside fill
     * @private
     */


    Text.prototype.drawLetterSpacing = function drawLetterSpacing(text, x, y) {
        var isStroke = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

        var style = this._style;

        // letterSpacing of 0 means normal
        var letterSpacing = style.letterSpacing;

        if (letterSpacing === 0) {
            if (isStroke) {
                this.context.strokeText(text, x, y);
            } else {
                this.context.fillText(text, x, y);
            }

            return;
        }

        var characters = String.prototype.split.call(text, '');
        var currentPosition = x;
        var index = 0;
        var current = '';

        while (index < text.length) {
            current = characters[index++];
            if (isStroke) {
                this.context.strokeText(current, currentPosition, y);
            } else {
                this.context.fillText(current, currentPosition, y);
            }
            currentPosition += this.context.measureText(current).width + letterSpacing;
        }
    };

    /**
     * Updates texture size based on canvas size
     *
     * @private
     */


    Text.prototype.updateTexture = function updateTexture() {
        var canvas = this.canvas;

        if (this._style.trim) {
            var trimmed = (0, _trimCanvas2.default)(canvas);

            if (trimmed.data) {
                canvas.width = trimmed.width;
                canvas.height = trimmed.height;
                this.context.putImageData(trimmed.data, 0, 0);
            }
        }

        var texture = this._texture;
        var style = this._style;
        var padding = style.trim ? 0 : style.padding;
        var baseTexture = texture.baseTexture;

        baseTexture.hasLoaded = true;
        baseTexture.resolution = this.resolution;

        baseTexture.realWidth = canvas.width;
        baseTexture.realHeight = canvas.height;
        baseTexture.width = canvas.width / this.resolution;
        baseTexture.height = canvas.height / this.resolution;

        texture.trim.width = texture._frame.width = canvas.width / this.resolution;
        texture.trim.height = texture._frame.height = canvas.height / this.resolution;
        texture.trim.x = -padding;
        texture.trim.y = -padding;

        texture.orig.width = texture._frame.width - padding * 2;
        texture.orig.height = texture._frame.height - padding * 2;

        // call sprite onTextureUpdate to update scale if _width or _height were set
        this._onTextureUpdate();

        baseTexture.emit('update', baseTexture);

        this.dirty = false;
    };

    /**
     * Renders the object using the WebGL renderer
     *
     * @param {PIXI.WebGLRenderer} renderer - The renderer
     */


    Text.prototype.renderWebGL = function renderWebGL(renderer) {
        if (this.resolution !== renderer.resolution) {
            this.resolution = renderer.resolution;
            this.dirty = true;
        }

        this.updateText(true);

        _Sprite.prototype.renderWebGL.call(this, renderer);
    };

    /**
     * Renders the object using the Canvas renderer
     *
     * @private
     * @param {PIXI.CanvasRenderer} renderer - The renderer
     */


    Text.prototype._renderCanvas = function _renderCanvas(renderer) {
        if (this.resolution !== renderer.resolution) {
            this.resolution = renderer.resolution;
            this.dirty = true;
        }

        this.updateText(true);

        _Sprite.prototype._renderCanvas.call(this, renderer);
    };

    /**
     * Gets the local bounds of the text object.
     *
     * @param {Rectangle} rect - The output rectangle.
     * @return {Rectangle} The bounds.
     */


    Text.prototype.getLocalBounds = function getLocalBounds(rect) {
        this.updateText(true);

        return _Sprite.prototype.getLocalBounds.call(this, rect);
    };

    /**
     * calculates the bounds of the Text as a rectangle. The bounds calculation takes the worldTransform into account.
     */


    Text.prototype._calculateBounds = function _calculateBounds() {
        this.updateText(true);
        this.calculateVertices();
        // if we have already done this on THIS frame.
        this._bounds.addQuad(this.vertexData);
    };

    /**
     * Method to be called upon a TextStyle change.
     * @private
     */


    Text.prototype._onStyleChange = function _onStyleChange() {
        this.dirty = true;
    };

    /**
     * Generates the fill style. Can automatically generate a gradient based on the fill style being an array
     *
     * @private
     * @param {object} style - The style.
     * @param {string[]} lines - The lines of text.
     * @return {string|number|CanvasGradient} The fill style
     */


    Text.prototype._generateFillStyle = function _generateFillStyle(style, lines) {
        if (!Array.isArray(style.fill)) {
            return style.fill;
        }

        // cocoon on canvas+ cannot generate textures, so use the first colour instead
        if (navigator.isCocoonJS) {
            return style.fill[0];
        }

        // the gradient will be evenly spaced out according to how large the array is.
        // ['#FF0000', '#00FF00', '#0000FF'] would created stops at 0.25, 0.5 and 0.75
        var gradient = void 0;
        var totalIterations = void 0;
        var currentIteration = void 0;
        var stop = void 0;

        var width = this.canvas.width / this.resolution;
        var height = this.canvas.height / this.resolution;

        // make a copy of the style settings, so we can manipulate them later
        var fill = style.fill.slice();
        var fillGradientStops = style.fillGradientStops.slice();

        // wanting to evenly distribute the fills. So an array of 4 colours should give fills of 0.25, 0.5 and 0.75
        if (!fillGradientStops.length) {
            var lengthPlus1 = fill.length + 1;

            for (var i = 1; i < lengthPlus1; ++i) {
                fillGradientStops.push(i / lengthPlus1);
            }
        }

        // stop the bleeding of the last gradient on the line above to the top gradient of the this line
        // by hard defining the first gradient colour at point 0, and last gradient colour at point 1
        fill.unshift(style.fill[0]);
        fillGradientStops.unshift(0);

        fill.push(style.fill[style.fill.length - 1]);
        fillGradientStops.push(1);

        if (style.fillGradientType === _const.TEXT_GRADIENT.LINEAR_VERTICAL) {
            // start the gradient at the top center of the canvas, and end at the bottom middle of the canvas
            gradient = this.context.createLinearGradient(width / 2, 0, width / 2, height);

            // we need to repeat the gradient so that each individual line of text has the same vertical gradient effect
            // ['#FF0000', '#00FF00', '#0000FF'] over 2 lines would create stops at 0.125, 0.25, 0.375, 0.625, 0.75, 0.875
            totalIterations = (fill.length + 1) * lines.length;
            currentIteration = 0;
            for (var _i2 = 0; _i2 < lines.length; _i2++) {
                currentIteration += 1;
                for (var j = 0; j < fill.length; j++) {
                    if (typeof fillGradientStops[j] === 'number') {
                        stop = fillGradientStops[j] / lines.length + _i2 / lines.length;
                    } else {
                        stop = currentIteration / totalIterations;
                    }
                    gradient.addColorStop(stop, fill[j]);
                    currentIteration++;
                }
            }
        } else {
            // start the gradient at the center left of the canvas, and end at the center right of the canvas
            gradient = this.context.createLinearGradient(0, height / 2, width, height / 2);

            // can just evenly space out the gradients in this case, as multiple lines makes no difference
            // to an even left to right gradient
            totalIterations = fill.length + 1;
            currentIteration = 1;

            for (var _i3 = 0; _i3 < fill.length; _i3++) {
                if (typeof fillGradientStops[_i3] === 'number') {
                    stop = fillGradientStops[_i3];
                } else {
                    stop = currentIteration / totalIterations;
                }
                gradient.addColorStop(stop, fill[_i3]);
                currentIteration++;
            }
        }

        return gradient;
    };

    /**
     * Destroys this text object.
     * Note* Unlike a Sprite, a Text object will automatically destroy its baseTexture and texture as
     * the majority of the time the texture will not be shared with any other Sprites.
     *
     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options
     *  have been set to that value
     * @param {boolean} [options.children=false] - if set to true, all the children will have their
     *  destroy method called as well. 'options' will be passed on to those calls.
     * @param {boolean} [options.texture=true] - Should it destroy the current texture of the sprite as well
     * @param {boolean} [options.baseTexture=true] - Should it destroy the base texture of the sprite as well
     */


    Text.prototype.destroy = function destroy(options) {
        if (typeof options === 'boolean') {
            options = { children: options };
        }

        options = Object.assign({}, defaultDestroyOptions, options);

        _Sprite.prototype.destroy.call(this, options);

        // make sure to reset the the context and canvas.. dont want this hanging around in memory!
        this.context = null;
        this.canvas = null;

        this._style = null;
    };

    /**
     * The width of the Text, setting this will actually modify the scale to achieve the value set
     *
     * @member {number}
     */


    _createClass(Text, [{
        key: 'width',
        get: function get() {
            this.updateText(true);

            return Math.abs(this.scale.x) * this._texture.orig.width;
        },
        set: function set(value) // eslint-disable-line require-jsdoc
        {
            this.updateText(true);

            var s = (0, _utils.sign)(this.scale.x) || 1;

            this.scale.x = s * value / this._texture.orig.width;
            this._width = value;
        }

        /**
         * The height of the Text, setting this will actually modify the scale to achieve the value set
         *
         * @member {number}
         */

    }, {
        key: 'height',
        get: function get() {
            this.updateText(true);

            return Math.abs(this.scale.y) * this._texture.orig.height;
        },
        set: function set(value) // eslint-disable-line require-jsdoc
        {
            this.updateText(true);

            var s = (0, _utils.sign)(this.scale.y) || 1;

            this.scale.y = s * value / this._texture.orig.height;
            this._height = value;
        }

        /**
         * Set the style of the text. Set up an event listener to listen for changes on the style
         * object and mark the text as dirty.
         *
         * @member {object|PIXI.TextStyle}
         */

    }, {
        key: 'style',
        get: function get() {
            return this._style;
        },
        set: function set(style) // eslint-disable-line require-jsdoc
        {
            style = style || {};

            if (style instanceof _TextStyle2.default) {
                this._style = style;
            } else {
                this._style = new _TextStyle2.default(style);
            }

            this.localStyleID = -1;
            this.dirty = true;
        }

        /**
         * Set the copy for the text object. To split a line you can use '\n'.
         *
         * @member {string}
         */

    }, {
        key: 'text',
        get: function get() {
            return this._text;
        },
        set: function set(text) // eslint-disable-line require-jsdoc
        {
            text = String(text === '' || text === null || text === undefined ? ' ' : text);

            if (this._text === text) {
                return;
            }
            this._text = text;
            this.dirty = true;
        }
    }]);

    return Text;
}(_Sprite3.default);

exports.default = Text;

},{"../const":53,"../math":77,"../settings":108,"../sprites/Sprite":109,"../textures/Texture":122,"../utils":132,"../utils/trimCanvas":137,"./TextMetrics":116,"./TextStyle":117}],116:[function(require,module,exports){
'use strict';

exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * The TextMetrics object represents the measurement of a block of text with a specified style.
 *
 * ```js
 * let style = new PIXI.TextStyle({fontFamily : 'Arial', fontSize: 24, fill : 0xff1010, align : 'center'})
 * let textMetrics = PIXI.TextMetrics.measureText('Your text', style)
 * ```
 *
 * @class
 * @memberOf PIXI
 */
var TextMetrics = function () {
    /**
     * @param {string} text - the text that was measured
     * @param {PIXI.TextStyle} style - the style that was measured
     * @param {number} width - the measured width of the text
     * @param {number} height - the measured height of the text
     * @param {array} lines - an array of the lines of text broken by new lines and wrapping if specified in style
     * @param {array} lineWidths - an array of the line widths for each line matched to `lines`
     * @param {number} lineHeight - the measured line height for this style
     * @param {number} maxLineWidth - the maximum line width for all measured lines
     * @param {Object} fontProperties - the font properties object from TextMetrics.measureFont
     */
    function TextMetrics(text, style, width, height, lines, lineWidths, lineHeight, maxLineWidth, fontProperties) {
        _classCallCheck(this, TextMetrics);

        this.text = text;
        this.style = style;
        this.width = width;
        this.height = height;
        this.lines = lines;
        this.lineWidths = lineWidths;
        this.lineHeight = lineHeight;
        this.maxLineWidth = maxLineWidth;
        this.fontProperties = fontProperties;
    }

    /**
     * Measures the supplied string of text and returns a Rectangle.
     *
     * @param {string} text - the text to measure.
     * @param {PIXI.TextStyle} style - the text style to use for measuring
     * @param {boolean} [wordWrap] - optional override for if word-wrap should be applied to the text.
     * @param {HTMLCanvasElement} [canvas] - optional specification of the canvas to use for measuring.
     * @return {PIXI.TextMetrics} measured width and height of the text.
     */


    TextMetrics.measureText = function measureText(text, style, wordWrap) {
        var canvas = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : TextMetrics._canvas;

        wordWrap = wordWrap === undefined || wordWrap === null ? style.wordWrap : wordWrap;
        var font = style.toFontString();
        var fontProperties = TextMetrics.measureFont(font);
        var context = canvas.getContext('2d');

        context.font = font;

        var outputText = wordWrap ? TextMetrics.wordWrap(text, style, canvas) : text;
        var lines = outputText.split(/(?:\r\n|\r|\n)/);
        var lineWidths = new Array(lines.length);
        var maxLineWidth = 0;

        for (var i = 0; i < lines.length; i++) {
            var lineWidth = context.measureText(lines[i]).width + (lines[i].length - 1) * style.letterSpacing;

            lineWidths[i] = lineWidth;
            maxLineWidth = Math.max(maxLineWidth, lineWidth);
        }
        var width = maxLineWidth + style.strokeThickness;

        if (style.dropShadow) {
            width += style.dropShadowDistance;
        }

        var lineHeight = style.lineHeight || fontProperties.fontSize + style.strokeThickness;
        var height = Math.max(lineHeight, fontProperties.fontSize + style.strokeThickness) + (lines.length - 1) * (lineHeight + style.leading);

        if (style.dropShadow) {
            height += style.dropShadowDistance;
        }

        return new TextMetrics(text, style, width, height, lines, lineWidths, lineHeight + style.leading, maxLineWidth, fontProperties);
    };

    /**
     * Applies newlines to a string to have it optimally fit into the horizontal
     * bounds set by the Text object's wordWrapWidth property.
     *
     * @private
     * @param {string} text - String to apply word wrapping to
     * @param {PIXI.TextStyle} style - the style to use when wrapping
     * @param {HTMLCanvasElement} [canvas] - optional specification of the canvas to use for measuring.
     * @return {string} New string with new lines applied where required
     */


    TextMetrics.wordWrap = function wordWrap(text, style) {
        var canvas = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : TextMetrics._canvas;

        var context = canvas.getContext('2d');

        var width = 0;
        var line = '';
        var lines = '';

        var cache = {};
        var letterSpacing = style.letterSpacing,
            whiteSpace = style.whiteSpace;

        // How to handle whitespaces

        var collapseSpaces = TextMetrics.collapseSpaces(whiteSpace);
        var collapseNewlines = TextMetrics.collapseNewlines(whiteSpace);

        // whether or not spaces may be added to the beginning of lines
        var canPrependSpaces = !collapseSpaces;

        // There is letterSpacing after every char except the last one
        // t_h_i_s_' '_i_s_' '_a_n_' '_e_x_a_m_p_l_e_' '_!
        // so for convenience the above needs to be compared to width + 1 extra letterSpace
        // t_h_i_s_' '_i_s_' '_a_n_' '_e_x_a_m_p_l_e_' '_!_
        // ________________________________________________
        // And then the final space is simply no appended to each line
        var wordWrapWidth = style.wordWrapWidth + letterSpacing;

        // break text into words, spaces and newline chars
        var tokens = TextMetrics.tokenize(text);

        for (var i = 0; i < tokens.length; i++) {
            // get the word, space or newlineChar
            var token = tokens[i];

            // if word is a new line
            if (TextMetrics.isNewline(token)) {
                // keep the new line
                if (!collapseNewlines) {
                    lines += TextMetrics.addLine(line);
                    canPrependSpaces = !collapseSpaces;
                    line = '';
                    width = 0;
                    continue;
                }

                // if we should collapse new lines
                // we simply convert it into a space
                token = ' ';
            }

            // if we should collapse repeated whitespaces
            if (collapseSpaces) {
                // check both this and the last tokens for spaces
                var currIsBreakingSpace = TextMetrics.isBreakingSpace(token);
                var lastIsBreakingSpace = TextMetrics.isBreakingSpace(line[line.length - 1]);

                if (currIsBreakingSpace && lastIsBreakingSpace) {
                    continue;
                }
            }

            // get word width from cache if possible
            var tokenWidth = TextMetrics.getFromCache(token, letterSpacing, cache, context);

            // word is longer than desired bounds
            if (tokenWidth > wordWrapWidth) {
                // if we are not already at the beginning of a line
                if (line !== '') {
                    // start newlines for overflow words
                    lines += TextMetrics.addLine(line);
                    line = '';
                    width = 0;
                }

                // break large word over multiple lines
                if (TextMetrics.canBreakWords(token, style.breakWords)) {
                    // break word into characters
                    var characters = token.split('');

                    // loop the characters
                    for (var j = 0; j < characters.length; j++) {
                        var char = characters[j];

                        var k = 1;
                        // we are not at the end of the token

                        while (characters[j + k]) {
                            var nextChar = characters[j + k];
                            var lastChar = char[char.length - 1];

                            // should not split chars
                            if (!TextMetrics.canBreakChars(lastChar, nextChar, token, j, style.breakWords)) {
                                // combine chars & move forward one
                                char += nextChar;
                            } else {
                                break;
                            }

                            k++;
                        }

                        j += char.length - 1;

                        var characterWidth = TextMetrics.getFromCache(char, letterSpacing, cache, context);

                        if (characterWidth + width > wordWrapWidth) {
                            lines += TextMetrics.addLine(line);
                            canPrependSpaces = false;
                            line = '';
                            width = 0;
                        }

                        line += char;
                        width += characterWidth;
                    }
                }

                // run word out of the bounds
                else {
                        // if there are words in this line already
                        // finish that line and start a new one
                        if (line.length > 0) {
                            lines += TextMetrics.addLine(line);
                            line = '';
                            width = 0;
                        }

                        var isLastToken = i === tokens.length - 1;

                        // give it its own line if it's not the end
                        lines += TextMetrics.addLine(token, !isLastToken);
                        canPrependSpaces = false;
                        line = '';
                        width = 0;
                    }
            }

            // word could fit
            else {
                    // word won't fit because of existing words
                    // start a new line
                    if (tokenWidth + width > wordWrapWidth) {
                        // if its a space we don't want it
                        canPrependSpaces = false;

                        // add a new line
                        lines += TextMetrics.addLine(line);

                        // start a new line
                        line = '';
                        width = 0;
                    }

                    // don't add spaces to the beginning of lines
                    if (line.length > 0 || !TextMetrics.isBreakingSpace(token) || canPrependSpaces) {
                        // add the word to the current line
                        line += token;

                        // update width counter
                        width += tokenWidth;
                    }
                }
        }

        lines += TextMetrics.addLine(line, false);

        return lines;
    };

    /**
     * Convienience function for logging each line added during the wordWrap
     * method
     *
     * @private
     * @param  {string}   line        - The line of text to add
     * @param  {boolean}  newLine     - Add new line character to end
     * @return {string}   A formatted line
     */


    TextMetrics.addLine = function addLine(line) {
        var newLine = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

        line = TextMetrics.trimRight(line);

        line = newLine ? line + '\n' : line;

        return line;
    };

    /**
     * Gets & sets the widths of calculated characters in a cache object
     *
     * @private
     * @param  {string}                    key            The key
     * @param  {number}                    letterSpacing  The letter spacing
     * @param  {object}                    cache          The cache
     * @param  {CanvasRenderingContext2D}  context        The canvas context
     * @return {number}                    The from cache.
     */


    TextMetrics.getFromCache = function getFromCache(key, letterSpacing, cache, context) {
        var width = cache[key];

        if (width === undefined) {
            var spacing = key.length * letterSpacing;

            width = context.measureText(key).width + spacing;
            cache[key] = width;
        }

        return width;
    };

    /**
     * Determines whether we should collapse breaking spaces
     *
     * @private
     * @param  {string}   whiteSpace  The TextStyle property whiteSpace
     * @return {boolean}  should collapse
     */


    TextMetrics.collapseSpaces = function collapseSpaces(whiteSpace) {
        return whiteSpace === 'normal' || whiteSpace === 'pre-line';
    };

    /**
     * Determines whether we should collapse newLine chars
     *
     * @private
     * @param  {string}   whiteSpace  The white space
     * @return {boolean}  should collapse
     */


    TextMetrics.collapseNewlines = function collapseNewlines(whiteSpace) {
        return whiteSpace === 'normal';
    };

    /**
     * trims breaking whitespaces from string
     *
     * @private
     * @param  {string}  text  The text
     * @return {string}  trimmed string
     */


    TextMetrics.trimRight = function trimRight(text) {
        if (typeof text !== 'string') {
            return '';
        }

        for (var i = text.length - 1; i >= 0; i--) {
            var char = text[i];

            if (!TextMetrics.isBreakingSpace(char)) {
                break;
            }

            text = text.slice(0, -1);
        }

        return text;
    };

    /**
     * Determines if char is a newline.
     *
     * @private
     * @param  {string}  char  The character
     * @return {boolean}  True if newline, False otherwise.
     */


    TextMetrics.isNewline = function isNewline(char) {
        if (typeof char !== 'string') {
            return false;
        }

        return TextMetrics._newlines.indexOf(char.charCodeAt(0)) >= 0;
    };

    /**
     * Determines if char is a breaking whitespace.
     *
     * @private
     * @param  {string}  char  The character
     * @return {boolean}  True if whitespace, False otherwise.
     */


    TextMetrics.isBreakingSpace = function isBreakingSpace(char) {
        if (typeof char !== 'string') {
            return false;
        }

        return TextMetrics._breakingSpaces.indexOf(char.charCodeAt(0)) >= 0;
    };

    /**
     * Splits a string into words, breaking-spaces and newLine characters
     *
     * @private
     * @param  {string}  text       The text
     * @return {array}  A tokenized array
     */


    TextMetrics.tokenize = function tokenize(text) {
        var tokens = [];
        var token = '';

        if (typeof text !== 'string') {
            return tokens;
        }

        for (var i = 0; i < text.length; i++) {
            var char = text[i];

            if (TextMetrics.isBreakingSpace(char) || TextMetrics.isNewline(char)) {
                if (token !== '') {
                    tokens.push(token);
                    token = '';
                }

                tokens.push(char);

                continue;
            }

            token += char;
        }

        if (token !== '') {
            tokens.push(token);
        }

        return tokens;
    };

    /**
     * This method exists to be easily overridden
     * It allows one to customise which words should break
     * Examples are if the token is CJK or numbers.
     * It must return a boolean.
     *
     * @private
     * @param  {string}  token       The token
     * @param  {boolean}  breakWords  The style attr break words
     * @return {boolean} whether to break word or not
     */


    TextMetrics.canBreakWords = function canBreakWords(token, breakWords) {
        return breakWords;
    };

    /**
     * This method exists to be easily overridden
     * It allows one to determine whether a pair of characters
     * should be broken by newlines
     * For example certain characters in CJK langs or numbers.
     * It must return a boolean.
     *
     * @private
     * @param  {string}  char      The character
     * @param  {string}  nextChar  The next character
     * @param  {string}  token     The token/word the characters are from
     * @param  {number}  index     The index in the token of the char
     * @param  {boolean}  breakWords  The style attr break words
     * @return {boolean} whether to break word or not
     */


    TextMetrics.canBreakChars = function canBreakChars(char, nextChar, token, index, breakWords) // eslint-disable-line no-unused-vars
    {
        return true;
    };

    /**
     * Calculates the ascent, descent and fontSize of a given font-style
     *
     * @static
     * @param {string} font - String representing the style of the font
     * @return {PIXI.TextMetrics~FontMetrics} Font properties object
     */


    TextMetrics.measureFont = function measureFont(font) {
        // as this method is used for preparing assets, don't recalculate things if we don't need to
        if (TextMetrics._fonts[font]) {
            return TextMetrics._fonts[font];
        }

        var properties = {};

        var canvas = TextMetrics._canvas;
        var context = TextMetrics._context;

        context.font = font;

        var metricsString = TextMetrics.METRICS_STRING + TextMetrics.BASELINE_SYMBOL;
        var width = Math.ceil(context.measureText(metricsString).width);
        var baseline = Math.ceil(context.measureText(TextMetrics.BASELINE_SYMBOL).width);
        var height = 2 * baseline;

        baseline = baseline * TextMetrics.BASELINE_MULTIPLIER | 0;

        canvas.width = width;
        canvas.height = height;

        context.fillStyle = '#f00';
        context.fillRect(0, 0, width, height);

        context.font = font;

        context.textBaseline = 'alphabetic';
        context.fillStyle = '#000';
        context.fillText(metricsString, 0, baseline);

        var imagedata = context.getImageData(0, 0, width, height).data;
        var pixels = imagedata.length;
        var line = width * 4;

        var i = 0;
        var idx = 0;
        var stop = false;

        // ascent. scan from top to bottom until we find a non red pixel
        for (i = 0; i < baseline; ++i) {
            for (var j = 0; j < line; j += 4) {
                if (imagedata[idx + j] !== 255) {
                    stop = true;
                    break;
                }
            }
            if (!stop) {
                idx += line;
            } else {
                break;
            }
        }

        properties.ascent = baseline - i;

        idx = pixels - line;
        stop = false;

        // descent. scan from bottom to top until we find a non red pixel
        for (i = height; i > baseline; --i) {
            for (var _j = 0; _j < line; _j += 4) {
                if (imagedata[idx + _j] !== 255) {
                    stop = true;
                    break;
                }
            }

            if (!stop) {
                idx -= line;
            } else {
                break;
            }
        }

        properties.descent = i - baseline;
        properties.fontSize = properties.ascent + properties.descent;

        TextMetrics._fonts[font] = properties;

        return properties;
    };

    /**
     * Clear font metrics in metrics cache.
     *
     * @static
     * @param {string} [font] - font name. If font name not set then clear cache for all fonts.
     */


    TextMetrics.clearMetrics = function clearMetrics() {
        var font = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

        if (font) {
            delete TextMetrics._fonts[font];
        } else {
            TextMetrics._fonts = {};
        }
    };

    return TextMetrics;
}();

/**
 * Internal return object for {@link PIXI.TextMetrics.measureFont `TextMetrics.measureFont`}.
 * @class FontMetrics
 * @memberof PIXI.TextMetrics~
 * @property {number} ascent - The ascent distance
 * @property {number} descent - The descent distance
 * @property {number} fontSize - Font size from ascent to descent
 */

exports.default = TextMetrics;
var canvas = document.createElement('canvas');

canvas.width = canvas.height = 10;

/**
 * Cached canvas element for measuring text
 * @memberof PIXI.TextMetrics
 * @type {HTMLCanvasElement}
 * @private
 */
TextMetrics._canvas = canvas;

/**
 * Cache for context to use.
 * @memberof PIXI.TextMetrics
 * @type {CanvasRenderingContext2D}
 * @private
 */
TextMetrics._context = canvas.getContext('2d');

/**
 * Cache of PIXI.TextMetrics~FontMetrics objects.
 * @memberof PIXI.TextMetrics
 * @type {Object}
 * @private
 */
TextMetrics._fonts = {};

/**
 * String used for calculate font metrics.
 * @static
 * @memberof PIXI.TextMetrics
 * @name METRICS_STRING
 * @type {string}
 * @default |Éq
 */
TextMetrics.METRICS_STRING = '|Éq';

/**
 * Baseline symbol for calculate font metrics.
 * @static
 * @memberof PIXI.TextMetrics
 * @name BASELINE_SYMBOL
 * @type {string}
 * @default M
 */
TextMetrics.BASELINE_SYMBOL = 'M';

/**
 * Baseline multiplier for calculate font metrics.
 * @static
 * @memberof PIXI.TextMetrics
 * @name BASELINE_MULTIPLIER
 * @type {number}
 * @default 1.4
 */
TextMetrics.BASELINE_MULTIPLIER = 1.4;

/**
 * Cache of new line chars.
 * @memberof PIXI.TextMetrics
 * @type {number[]}
 * @private
 */
TextMetrics._newlines = [0x000A, // line feed
0x000D];

/**
 * Cache of breaking spaces.
 * @memberof PIXI.TextMetrics
 * @type {number[]}
 * @private
 */
TextMetrics._breakingSpaces = [0x0009, // character tabulation
0x0020, // space
0x2000, // en quad
0x2001, // em quad
0x2002, // en space
0x2003, // em space
0x2004, // three-per-em space
0x2005, // four-per-em space
0x2006, // six-per-em space
0x2008, // punctuation space
0x2009, // thin space
0x200A, // hair space
0x205F, // medium mathematical space
0x3000];

},{}],117:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // disabling eslint for now, going to rewrite this in v5
/* eslint-disable */

var _const = require('../const');

var _utils = require('../utils');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var defaultStyle = {
    align: 'left',
    breakWords: false,
    dropShadow: false,
    dropShadowAlpha: 1,
    dropShadowAngle: Math.PI / 6,
    dropShadowBlur: 0,
    dropShadowColor: 'black',
    dropShadowDistance: 5,
    fill: 'black',
    fillGradientType: _const.TEXT_GRADIENT.LINEAR_VERTICAL,
    fillGradientStops: [],
    fontFamily: 'Arial',
    fontSize: 26,
    fontStyle: 'normal',
    fontVariant: 'normal',
    fontWeight: 'normal',
    letterSpacing: 0,
    lineHeight: 0,
    lineJoin: 'miter',
    miterLimit: 10,
    padding: 0,
    stroke: 'black',
    strokeThickness: 0,
    textBaseline: 'alphabetic',
    trim: false,
    whiteSpace: 'pre',
    wordWrap: false,
    wordWrapWidth: 100,
    leading: 0
};

var genericFontFamilies = ['serif', 'sans-serif', 'monospace', 'cursive', 'fantasy', 'system-ui'];

/**
 * A TextStyle Object decorates a Text Object. It can be shared between
 * multiple Text objects. Changing the style will update all text objects using it.
 * It can be generated [here](https://pixijs.io/pixi-text-style).
 *
 * @class
 * @memberof PIXI
 */

var TextStyle = function () {
    /**
     * @param {object} [style] - The style parameters
     * @param {string} [style.align='left'] - Alignment for multiline text ('left', 'center' or 'right'),
     *  does not affect single line text
     * @param {boolean} [style.breakWords=false] - Indicates if lines can be wrapped within words, it
     *  needs wordWrap to be set to true
     * @param {boolean} [style.dropShadow=false] - Set a drop shadow for the text
     * @param {number} [style.dropShadowAlpha=1] - Set alpha for the drop shadow
     * @param {number} [style.dropShadowAngle=Math.PI/6] - Set a angle of the drop shadow
     * @param {number} [style.dropShadowBlur=0] - Set a shadow blur radius
     * @param {string|number} [style.dropShadowColor='black'] - A fill style to be used on the dropshadow e.g 'red', '#00FF00'
     * @param {number} [style.dropShadowDistance=5] - Set a distance of the drop shadow
     * @param {string|string[]|number|number[]|CanvasGradient|CanvasPattern} [style.fill='black'] - A canvas
     *  fillstyle that will be used on the text e.g 'red', '#00FF00'. Can be an array to create a gradient
     *  eg ['#000000','#FFFFFF']
     * {@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillStyle|MDN}
     * @param {number} [style.fillGradientType=PIXI.TEXT_GRADIENT.LINEAR_VERTICAL] - If fill is an array of colours
     *  to create a gradient, this can change the type/direction of the gradient. See {@link PIXI.TEXT_GRADIENT}
     * @param {number[]} [style.fillGradientStops] - If fill is an array of colours to create a gradient, this array can set
     * the stop points (numbers between 0 and 1) for the color, overriding the default behaviour of evenly spacing them.
     * @param {string|string[]} [style.fontFamily='Arial'] - The font family
     * @param {number|string} [style.fontSize=26] - The font size (as a number it converts to px, but as a string,
     *  equivalents are '26px','20pt','160%' or '1.6em')
     * @param {string} [style.fontStyle='normal'] - The font style ('normal', 'italic' or 'oblique')
     * @param {string} [style.fontVariant='normal'] - The font variant ('normal' or 'small-caps')
     * @param {string} [style.fontWeight='normal'] - The font weight ('normal', 'bold', 'bolder', 'lighter' and '100',
     *  '200', '300', '400', '500', '600', '700', 800' or '900')
     * @param {number} [style.leading=0] - The space between lines
     * @param {number} [style.letterSpacing=0] - The amount of spacing between letters, default is 0
     * @param {number} [style.lineHeight] - The line height, a number that represents the vertical space that a letter uses
     * @param {string} [style.lineJoin='miter'] - The lineJoin property sets the type of corner created, it can resolve
     *      spiked text issues. Possible values "miter" (creates a sharp corner), "round" (creates a round corner) or "bevel"
     *      (creates a squared corner).
     * @param {number} [style.miterLimit=10] - The miter limit to use when using the 'miter' lineJoin mode. This can reduce
     *      or increase the spikiness of rendered text.
     * @param {number} [style.padding=0] - Occasionally some fonts are cropped. Adding some padding will prevent this from
     *     happening by adding padding to all sides of the text.
     * @param {string|number} [style.stroke='black'] - A canvas fillstyle that will be used on the text stroke
     *  e.g 'blue', '#FCFF00'
     * @param {number} [style.strokeThickness=0] - A number that represents the thickness of the stroke.
     *  Default is 0 (no stroke)
     * @param {boolean} [style.trim=false] - Trim transparent borders
     * @param {string} [style.textBaseline='alphabetic'] - The baseline of the text that is rendered.
     * @param {boolean} [style.whiteSpace='pre'] - Determines whether newlines & spaces are collapsed or preserved "normal"
     *      (collapse, collapse), "pre" (preserve, preserve) | "pre-line" (preserve, collapse). It needs wordWrap to be set to true
     * @param {boolean} [style.wordWrap=false] - Indicates if word wrap should be used
     * @param {number} [style.wordWrapWidth=100] - The width at which text will wrap, it needs wordWrap to be set to true
     */
    function TextStyle(style) {
        _classCallCheck(this, TextStyle);

        this.styleID = 0;

        this.reset();

        deepCopyProperties(this, style, style);
    }

    /**
     * Creates a new TextStyle object with the same values as this one.
     * Note that the only the properties of the object are cloned.
     *
     * @return {PIXI.TextStyle} New cloned TextStyle object
     */


    TextStyle.prototype.clone = function clone() {
        var clonedProperties = {};

        deepCopyProperties(clonedProperties, this, defaultStyle);

        return new TextStyle(clonedProperties);
    };

    /**
     * Resets all properties to the defaults specified in TextStyle.prototype._default
     */


    TextStyle.prototype.reset = function reset() {
        deepCopyProperties(this, defaultStyle, defaultStyle);
    };

    /**
     * Alignment for multiline text ('left', 'center' or 'right'), does not affect single line text
     *
     * @member {string}
     */


    /**
     * Generates a font style string to use for `TextMetrics.measureFont()`.
     *
     * @return {string} Font style string, for passing to `TextMetrics.measureFont()`
     */
    TextStyle.prototype.toFontString = function toFontString() {
        // build canvas api font setting from individual components. Convert a numeric this.fontSize to px
        var fontSizeString = typeof this.fontSize === 'number' ? this.fontSize + 'px' : this.fontSize;

        // Clean-up fontFamily property by quoting each font name
        // this will support font names with spaces
        var fontFamilies = this.fontFamily;

        if (!Array.isArray(this.fontFamily)) {
            fontFamilies = this.fontFamily.split(',');
        }

        for (var i = fontFamilies.length - 1; i >= 0; i--) {
            // Trim any extra white-space
            var fontFamily = fontFamilies[i].trim();

            // Check if font is already escaped in quotes except for CSS generic fonts
            if (!/([\"\'])[^\'\"]+\1/.test(fontFamily) && genericFontFamilies.indexOf(fontFamily) < 0) {
                fontFamily = '"' + fontFamily + '"';
            }
            fontFamilies[i] = fontFamily;
        }

        return this.fontStyle + ' ' + this.fontVariant + ' ' + this.fontWeight + ' ' + fontSizeString + ' ' + fontFamilies.join(',');
    };

    _createClass(TextStyle, [{
        key: 'align',
        get: function get() {
            return this._align;
        },
        set: function set(align) // eslint-disable-line require-jsdoc
        {
            if (this._align !== align) {
                this._align = align;
                this.styleID++;
            }
        }

        /**
         * Indicates if lines can be wrapped within words, it needs wordWrap to be set to true
         *
         * @member {boolean}
         */

    }, {
        key: 'breakWords',
        get: function get() {
            return this._breakWords;
        },
        set: function set(breakWords) // eslint-disable-line require-jsdoc
        {
            if (this._breakWords !== breakWords) {
                this._breakWords = breakWords;
                this.styleID++;
            }
        }

        /**
         * Set a drop shadow for the text
         *
         * @member {boolean}
         */

    }, {
        key: 'dropShadow',
        get: function get() {
            return this._dropShadow;
        },
        set: function set(dropShadow) // eslint-disable-line require-jsdoc
        {
            if (this._dropShadow !== dropShadow) {
                this._dropShadow = dropShadow;
                this.styleID++;
            }
        }

        /**
         * Set alpha for the drop shadow
         *
         * @member {number}
         */

    }, {
        key: 'dropShadowAlpha',
        get: function get() {
            return this._dropShadowAlpha;
        },
        set: function set(dropShadowAlpha) // eslint-disable-line require-jsdoc
        {
            if (this._dropShadowAlpha !== dropShadowAlpha) {
                this._dropShadowAlpha = dropShadowAlpha;
                this.styleID++;
            }
        }

        /**
         * Set a angle of the drop shadow
         *
         * @member {number}
         */

    }, {
        key: 'dropShadowAngle',
        get: function get() {
            return this._dropShadowAngle;
        },
        set: function set(dropShadowAngle) // eslint-disable-line require-jsdoc
        {
            if (this._dropShadowAngle !== dropShadowAngle) {
                this._dropShadowAngle = dropShadowAngle;
                this.styleID++;
            }
        }

        /**
         * Set a shadow blur radius
         *
         * @member {number}
         */

    }, {
        key: 'dropShadowBlur',
        get: function get() {
            return this._dropShadowBlur;
        },
        set: function set(dropShadowBlur) // eslint-disable-line require-jsdoc
        {
            if (this._dropShadowBlur !== dropShadowBlur) {
                this._dropShadowBlur = dropShadowBlur;
                this.styleID++;
            }
        }

        /**
         * A fill style to be used on the dropshadow e.g 'red', '#00FF00'
         *
         * @member {string|number}
         */

    }, {
        key: 'dropShadowColor',
        get: function get() {
            return this._dropShadowColor;
        },
        set: function set(dropShadowColor) // eslint-disable-line require-jsdoc
        {
            var outputColor = getColor(dropShadowColor);
            if (this._dropShadowColor !== outputColor) {
                this._dropShadowColor = outputColor;
                this.styleID++;
            }
        }

        /**
         * Set a distance of the drop shadow
         *
         * @member {number}
         */

    }, {
        key: 'dropShadowDistance',
        get: function get() {
            return this._dropShadowDistance;
        },
        set: function set(dropShadowDistance) // eslint-disable-line require-jsdoc
        {
            if (this._dropShadowDistance !== dropShadowDistance) {
                this._dropShadowDistance = dropShadowDistance;
                this.styleID++;
            }
        }

        /**
         * A canvas fillstyle that will be used on the text e.g 'red', '#00FF00'.
         * Can be an array to create a gradient eg ['#000000','#FFFFFF']
         * {@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillStyle|MDN}
         *
         * @member {string|string[]|number|number[]|CanvasGradient|CanvasPattern}
         */

    }, {
        key: 'fill',
        get: function get() {
            return this._fill;
        },
        set: function set(fill) // eslint-disable-line require-jsdoc
        {
            var outputColor = getColor(fill);
            if (this._fill !== outputColor) {
                this._fill = outputColor;
                this.styleID++;
            }
        }

        /**
         * If fill is an array of colours to create a gradient, this can change the type/direction of the gradient.
         * See {@link PIXI.TEXT_GRADIENT}
         *
         * @member {number}
         */

    }, {
        key: 'fillGradientType',
        get: function get() {
            return this._fillGradientType;
        },
        set: function set(fillGradientType) // eslint-disable-line require-jsdoc
        {
            if (this._fillGradientType !== fillGradientType) {
                this._fillGradientType = fillGradientType;
                this.styleID++;
            }
        }

        /**
         * If fill is an array of colours to create a gradient, this array can set the stop points
         * (numbers between 0 and 1) for the color, overriding the default behaviour of evenly spacing them.
         *
         * @member {number[]}
         */

    }, {
        key: 'fillGradientStops',
        get: function get() {
            return this._fillGradientStops;
        },
        set: function set(fillGradientStops) // eslint-disable-line require-jsdoc
        {
            if (!areArraysEqual(this._fillGradientStops, fillGradientStops)) {
                this._fillGradientStops = fillGradientStops;
                this.styleID++;
            }
        }

        /**
         * The font family
         *
         * @member {string|string[]}
         */

    }, {
        key: 'fontFamily',
        get: function get() {
            return this._fontFamily;
        },
        set: function set(fontFamily) // eslint-disable-line require-jsdoc
        {
            if (this.fontFamily !== fontFamily) {
                this._fontFamily = fontFamily;
                this.styleID++;
            }
        }

        /**
         * The font size
         * (as a number it converts to px, but as a string, equivalents are '26px','20pt','160%' or '1.6em')
         *
         * @member {number|string}
         */

    }, {
        key: 'fontSize',
        get: function get() {
            return this._fontSize;
        },
        set: function set(fontSize) // eslint-disable-line require-jsdoc
        {
            if (this._fontSize !== fontSize) {
                this._fontSize = fontSize;
                this.styleID++;
            }
        }

        /**
         * The font style
         * ('normal', 'italic' or 'oblique')
         *
         * @member {string}
         */

    }, {
        key: 'fontStyle',
        get: function get() {
            return this._fontStyle;
        },
        set: function set(fontStyle) // eslint-disable-line require-jsdoc
        {
            if (this._fontStyle !== fontStyle) {
                this._fontStyle = fontStyle;
                this.styleID++;
            }
        }

        /**
         * The font variant
         * ('normal' or 'small-caps')
         *
         * @member {string}
         */

    }, {
        key: 'fontVariant',
        get: function get() {
            return this._fontVariant;
        },
        set: function set(fontVariant) // eslint-disable-line require-jsdoc
        {
            if (this._fontVariant !== fontVariant) {
                this._fontVariant = fontVariant;
                this.styleID++;
            }
        }

        /**
         * The font weight
         * ('normal', 'bold', 'bolder', 'lighter' and '100', '200', '300', '400', '500', '600', '700', 800' or '900')
         *
         * @member {string}
         */

    }, {
        key: 'fontWeight',
        get: function get() {
            return this._fontWeight;
        },
        set: function set(fontWeight) // eslint-disable-line require-jsdoc
        {
            if (this._fontWeight !== fontWeight) {
                this._fontWeight = fontWeight;
                this.styleID++;
            }
        }

        /**
         * The amount of spacing between letters, default is 0
         *
         * @member {number}
         */

    }, {
        key: 'letterSpacing',
        get: function get() {
            return this._letterSpacing;
        },
        set: function set(letterSpacing) // eslint-disable-line require-jsdoc
        {
            if (this._letterSpacing !== letterSpacing) {
                this._letterSpacing = letterSpacing;
                this.styleID++;
            }
        }

        /**
         * The line height, a number that represents the vertical space that a letter uses
         *
         * @member {number}
         */

    }, {
        key: 'lineHeight',
        get: function get() {
            return this._lineHeight;
        },
        set: function set(lineHeight) // eslint-disable-line require-jsdoc
        {
            if (this._lineHeight !== lineHeight) {
                this._lineHeight = lineHeight;
                this.styleID++;
            }
        }

        /**
         * The space between lines
         *
         * @member {number}
         */

    }, {
        key: 'leading',
        get: function get() {
            return this._leading;
        },
        set: function set(leading) // eslint-disable-line require-jsdoc
        {
            if (this._leading !== leading) {
                this._leading = leading;
                this.styleID++;
            }
        }

        /**
         * The lineJoin property sets the type of corner created, it can resolve spiked text issues.
         * Default is 'miter' (creates a sharp corner).
         *
         * @member {string}
         */

    }, {
        key: 'lineJoin',
        get: function get() {
            return this._lineJoin;
        },
        set: function set(lineJoin) // eslint-disable-line require-jsdoc
        {
            if (this._lineJoin !== lineJoin) {
                this._lineJoin = lineJoin;
                this.styleID++;
            }
        }

        /**
         * The miter limit to use when using the 'miter' lineJoin mode
         * This can reduce or increase the spikiness of rendered text.
         *
         * @member {number}
         */

    }, {
        key: 'miterLimit',
        get: function get() {
            return this._miterLimit;
        },
        set: function set(miterLimit) // eslint-disable-line require-jsdoc
        {
            if (this._miterLimit !== miterLimit) {
                this._miterLimit = miterLimit;
                this.styleID++;
            }
        }

        /**
         * Occasionally some fonts are cropped. Adding some padding will prevent this from happening
         * by adding padding to all sides of the text.
         *
         * @member {number}
         */

    }, {
        key: 'padding',
        get: function get() {
            return this._padding;
        },
        set: function set(padding) // eslint-disable-line require-jsdoc
        {
            if (this._padding !== padding) {
                this._padding = padding;
                this.styleID++;
            }
        }

        /**
         * A canvas fillstyle that will be used on the text stroke
         * e.g 'blue', '#FCFF00'
         *
         * @member {string|number}
         */

    }, {
        key: 'stroke',
        get: function get() {
            return this._stroke;
        },
        set: function set(stroke) // eslint-disable-line require-jsdoc
        {
            var outputColor = getColor(stroke);
            if (this._stroke !== outputColor) {
                this._stroke = outputColor;
                this.styleID++;
            }
        }

        /**
         * A number that represents the thickness of the stroke.
         * Default is 0 (no stroke)
         *
         * @member {number}
         */

    }, {
        key: 'strokeThickness',
        get: function get() {
            return this._strokeThickness;
        },
        set: function set(strokeThickness) // eslint-disable-line require-jsdoc
        {
            if (this._strokeThickness !== strokeThickness) {
                this._strokeThickness = strokeThickness;
                this.styleID++;
            }
        }

        /**
         * The baseline of the text that is rendered.
         *
         * @member {string}
         */

    }, {
        key: 'textBaseline',
        get: function get() {
            return this._textBaseline;
        },
        set: function set(textBaseline) // eslint-disable-line require-jsdoc
        {
            if (this._textBaseline !== textBaseline) {
                this._textBaseline = textBaseline;
                this.styleID++;
            }
        }

        /**
         * Trim transparent borders
         *
         * @member {boolean}
         */

    }, {
        key: 'trim',
        get: function get() {
            return this._trim;
        },
        set: function set(trim) // eslint-disable-line require-jsdoc
        {
            if (this._trim !== trim) {
                this._trim = trim;
                this.styleID++;
            }
        }

        /**
         * How newlines and spaces should be handled.
         * Default is 'pre' (preserve, preserve).
         *
         *  value       | New lines     |   Spaces
         *  ---         | ---           |   ---
         * 'normal'     | Collapse      |   Collapse
         * 'pre'        | Preserve      |   Preserve
         * 'pre-line'   | Preserve      |   Collapse
         *
         * @member {string}
         */

    }, {
        key: 'whiteSpace',
        get: function get() {
            return this._whiteSpace;
        },
        set: function set(whiteSpace) // eslint-disable-line require-jsdoc
        {
            if (this._whiteSpace !== whiteSpace) {
                this._whiteSpace = whiteSpace;
                this.styleID++;
            }
        }

        /**
         * Indicates if word wrap should be used
         *
         * @member {boolean}
         */

    }, {
        key: 'wordWrap',
        get: function get() {
            return this._wordWrap;
        },
        set: function set(wordWrap) // eslint-disable-line require-jsdoc
        {
            if (this._wordWrap !== wordWrap) {
                this._wordWrap = wordWrap;
                this.styleID++;
            }
        }

        /**
         * The width at which text will wrap, it needs wordWrap to be set to true
         *
         * @member {number}
         */

    }, {
        key: 'wordWrapWidth',
        get: function get() {
            return this._wordWrapWidth;
        },
        set: function set(wordWrapWidth) // eslint-disable-line require-jsdoc
        {
            if (this._wordWrapWidth !== wordWrapWidth) {
                this._wordWrapWidth = wordWrapWidth;
                this.styleID++;
            }
        }
    }]);

    return TextStyle;
}();

/**
 * Utility function to convert hexadecimal colors to strings, and simply return the color if it's a string.
 * @private
 * @param {number|number[]} color
 * @return {string} The color as a string.
 */


exports.default = TextStyle;
function getSingleColor(color) {
    if (typeof color === 'number') {
        return (0, _utils.hex2string)(color);
    } else if (typeof color === 'string') {
        if (color.indexOf('0x') === 0) {
            color = color.replace('0x', '#');
        }
    }

    return color;
}

/**
 * Utility function to convert hexadecimal colors to strings, and simply return the color if it's a string.
 * This version can also convert array of colors
 * @private
 * @param {number|number[]} color
 * @return {string} The color as a string.
 */
function getColor(color) {
    if (!Array.isArray(color)) {
        return getSingleColor(color);
    } else {
        for (var i = 0; i < color.length; ++i) {
            color[i] = getSingleColor(color[i]);
        }

        return color;
    }
}

/**
 * Utility function to convert hexadecimal colors to strings, and simply return the color if it's a string.
 * This version can also convert array of colors
 * @private
 * @param {Array} array1 First array to compare
 * @param {Array} array2 Second array to compare
 * @return {boolean} Do the arrays contain the same values in the same order
 */
function areArraysEqual(array1, array2) {
    if (!Array.isArray(array1) || !Array.isArray(array2)) {
        return false;
    }

    if (array1.length !== array2.length) {
        return false;
    }

    for (var i = 0; i < array1.length; ++i) {
        if (array1[i] !== array2[i]) {
            return false;
        }
    }

    return true;
}

/**
 * Utility function to ensure that object properties are copied by value, and not by reference
 * @private
 * @param {Object} target Target object to copy properties into
 * @param {Object} source Source object for the proporties to copy
 * @param {string} propertyObj Object containing properties names we want to loop over
 */
function deepCopyProperties(target, source, propertyObj) {
    for (var prop in propertyObj) {
        if (Array.isArray(source[prop])) {
            target[prop] = source[prop].slice();
        } else {
            target[prop] = source[prop];
        }
    }
}

},{"../const":53,"../utils":132}],118:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _BaseTexture2 = require('./BaseTexture');

var _BaseTexture3 = _interopRequireDefault(_BaseTexture2);

var _settings = require('../settings');

var _settings2 = _interopRequireDefault(_settings);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * A BaseRenderTexture is a special texture that allows any PixiJS display object to be rendered to it.
 *
 * __Hint__: All DisplayObjects (i.e. Sprites) that render to a BaseRenderTexture should be preloaded
 * otherwise black rectangles will be drawn instead.
 *
 * A BaseRenderTexture takes a snapshot of any Display Object given to its render method. The position
 * and rotation of the given Display Objects is ignored. For example:
 *
 * ```js
 * let renderer = PIXI.autoDetectRenderer(1024, 1024);
 * let baseRenderTexture = new PIXI.BaseRenderTexture(800, 600);
 * let renderTexture = new PIXI.RenderTexture(baseRenderTexture);
 * let sprite = PIXI.Sprite.fromImage("spinObj_01.png");
 *
 * sprite.position.x = 800/2;
 * sprite.position.y = 600/2;
 * sprite.anchor.x = 0.5;
 * sprite.anchor.y = 0.5;
 *
 * renderer.render(sprite, renderTexture);
 * ```
 *
 * The Sprite in this case will be rendered using its local transform. To render this sprite at 0,0
 * you can clear the transform
 *
 * ```js
 *
 * sprite.setTransform()
 *
 * let baseRenderTexture = new PIXI.BaseRenderTexture(100, 100);
 * let renderTexture = new PIXI.RenderTexture(baseRenderTexture);
 *
 * renderer.render(sprite, renderTexture);  // Renders to center of RenderTexture
 * ```
 *
 * @class
 * @extends PIXI.BaseTexture
 * @memberof PIXI
 */
var BaseRenderTexture = function (_BaseTexture) {
  _inherits(BaseRenderTexture, _BaseTexture);

  /**
   * @param {number} [width=100] - The width of the base render texture
   * @param {number} [height=100] - The height of the base render texture
   * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values
   * @param {number} [resolution=1] - The resolution / device pixel ratio of the texture being generated
   */
  function BaseRenderTexture() {
    var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;
    var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;
    var scaleMode = arguments[2];
    var resolution = arguments[3];

    _classCallCheck(this, BaseRenderTexture);

    var _this = _possibleConstructorReturn(this, _BaseTexture.call(this, null, scaleMode));

    _this.resolution = resolution || _settings2.default.RESOLUTION;

    _this.width = Math.ceil(width);
    _this.height = Math.ceil(height);

    _this.realWidth = _this.width * _this.resolution;
    _this.realHeight = _this.height * _this.resolution;

    _this.scaleMode = scaleMode !== undefined ? scaleMode : _settings2.default.SCALE_MODE;
    _this.hasLoaded = true;

    /**
     * A map of renderer IDs to webgl renderTargets
     *
     * @private
     * @member {object<number, WebGLTexture>}
     */
    _this._glRenderTargets = {};

    /**
     * A reference to the canvas render target (we only need one as this can be shared across renderers)
     *
     * @private
     * @member {object<number, WebGLTexture>}
     */
    _this._canvasRenderTarget = null;

    /**
     * This will let the renderer know if the texture is valid. If it's not then it cannot be rendered.
     *
     * @member {boolean}
     */
    _this.valid = false;
    return _this;
  }

  /**
   * Resizes the BaseRenderTexture.
   *
   * @param {number} width - The width to resize to.
   * @param {number} height - The height to resize to.
   */


  BaseRenderTexture.prototype.resize = function resize(width, height) {
    width = Math.ceil(width);
    height = Math.ceil(height);

    if (width === this.width && height === this.height) {
      return;
    }

    this.valid = width > 0 && height > 0;

    this.width = width;
    this.height = height;

    this.realWidth = this.width * this.resolution;
    this.realHeight = this.height * this.resolution;

    if (!this.valid) {
      return;
    }

    this.emit('update', this);
  };

  /**
   * Destroys this texture
   *
   */


  BaseRenderTexture.prototype.destroy = function destroy() {
    _BaseTexture.prototype.destroy.call(this, true);
    this.renderer = null;
  };

  return BaseRenderTexture;
}(_BaseTexture3.default);

exports.default = BaseRenderTexture;

},{"../settings":108,"./BaseTexture":119}],119:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _utils = require('../utils');

var _settings = require('../settings');

var _settings2 = _interopRequireDefault(_settings);

var _eventemitter = require('eventemitter3');

var _eventemitter2 = _interopRequireDefault(_eventemitter);

var _determineCrossOrigin = require('../utils/determineCrossOrigin');

var _determineCrossOrigin2 = _interopRequireDefault(_determineCrossOrigin);

var _bitTwiddle = require('bit-twiddle');

var _bitTwiddle2 = _interopRequireDefault(_bitTwiddle);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * A texture stores the information that represents an image. All textures have a base texture.
 *
 * @class
 * @extends EventEmitter
 * @memberof PIXI
 */
var BaseTexture = function (_EventEmitter) {
    _inherits(BaseTexture, _EventEmitter);

    /**
     * @param {HTMLImageElement|HTMLCanvasElement} [source] - the source object of the texture.
     * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values
     * @param {number} [resolution=1] - The resolution / device pixel ratio of the texture
     */
    function BaseTexture(source, scaleMode, resolution) {
        _classCallCheck(this, BaseTexture);

        var _this = _possibleConstructorReturn(this, _EventEmitter.call(this));

        _this.uid = (0, _utils.uid)();

        _this.touched = 0;

        /**
         * The resolution / device pixel ratio of the texture
         *
         * @member {number}
         * @default 1
         */
        _this.resolution = resolution || _settings2.default.RESOLUTION;

        /**
         * The width of the base texture set when the image has loaded
         *
         * @readonly
         * @member {number}
         */
        _this.width = 100;

        /**
         * The height of the base texture set when the image has loaded
         *
         * @readonly
         * @member {number}
         */
        _this.height = 100;

        // TODO docs
        // used to store the actual dimensions of the source
        /**
         * Used to store the actual width of the source of this texture
         *
         * @readonly
         * @member {number}
         */
        _this.realWidth = 100;
        /**
         * Used to store the actual height of the source of this texture
         *
         * @readonly
         * @member {number}
         */
        _this.realHeight = 100;

        /**
         * The scale mode to apply when scaling this texture
         *
         * @member {number}
         * @default PIXI.settings.SCALE_MODE
         * @see PIXI.SCALE_MODES
         */
        _this.scaleMode = scaleMode !== undefined ? scaleMode : _settings2.default.SCALE_MODE;

        /**
         * Set to true once the base texture has successfully loaded.
         *
         * This is never true if the underlying source fails to load or has no texture data.
         *
         * @readonly
         * @member {boolean}
         */
        _this.hasLoaded = false;

        /**
         * Set to true if the source is currently loading.
         *
         * If an Image source is loading the 'loaded' or 'error' event will be
         * dispatched when the operation ends. An underyling source that is
         * immediately-available bypasses loading entirely.
         *
         * @readonly
         * @member {boolean}
         */
        _this.isLoading = false;

        /**
         * The image source that is used to create the texture.
         *
         * TODO: Make this a setter that calls loadSource();
         *
         * @readonly
         * @member {HTMLImageElement|HTMLCanvasElement}
         */
        _this.source = null; // set in loadSource, if at all

        /**
         * The image source that is used to create the texture. This is used to
         * store the original Svg source when it is replaced with a canvas element.
         *
         * TODO: Currently not in use but could be used when re-scaling svg.
         *
         * @readonly
         * @member {Image}
         */
        _this.origSource = null; // set in loadSvg, if at all

        /**
         * Type of image defined in source, eg. `png` or `svg`
         *
         * @readonly
         * @member {string}
         */
        _this.imageType = null; // set in updateImageType

        /**
         * Scale for source image. Used with Svg images to scale them before rasterization.
         *
         * @readonly
         * @member {number}
         */
        _this.sourceScale = 1.0;

        /**
         * Controls if RGB channels should be pre-multiplied by Alpha  (WebGL only)
         * All blend modes, and shaders written for default value. Change it on your own risk.
         *
         * @member {boolean}
         * @default true
         */
        _this.premultipliedAlpha = true;

        /**
         * The image url of the texture
         *
         * @member {string}
         */
        _this.imageUrl = null;

        /**
         * Whether or not the texture is a power of two, try to use power of two textures as much
         * as you can
         *
         * @private
         * @member {boolean}
         */
        _this.isPowerOfTwo = false;

        // used for webGL

        /**
         *
         * Set this to true if a mipmap of this texture needs to be generated. This value needs
         * to be set before the texture is used
         * Also the texture must be a power of two size to work
         *
         * @member {boolean}
         * @see PIXI.MIPMAP_TEXTURES
         */
        _this.mipmap = _settings2.default.MIPMAP_TEXTURES;

        /**
         *
         * WebGL Texture wrap mode
         *
         * @member {number}
         * @see PIXI.WRAP_MODES
         */
        _this.wrapMode = _settings2.default.WRAP_MODE;

        /**
         * A map of renderer IDs to webgl textures
         *
         * @private
         * @member {object<number, WebGLTexture>}
         */
        _this._glTextures = {};

        _this._enabled = 0;
        _this._virtalBoundId = -1;

        /**
         * If the object has been destroyed via destroy(). If true, it should not be used.
         *
         * @member {boolean}
         * @private
         * @readonly
         */
        _this._destroyed = false;

        /**
         * The ids under which this BaseTexture has been added to the base texture cache. This is
         * automatically set as long as BaseTexture.addToCache is used, but may not be set if a
         * BaseTexture is added directly to the BaseTextureCache array.
         *
         * @member {string[]}
         */
        _this.textureCacheIds = [];

        // if no source passed don't try to load
        if (source) {
            _this.loadSource(source);
        }

        /**
         * Fired when a not-immediately-available source finishes loading.
         *
         * @protected
         * @event PIXI.BaseTexture#loaded
         * @param {PIXI.BaseTexture} baseTexture - Resource loaded.
         */

        /**
         * Fired when a not-immediately-available source fails to load.
         *
         * @protected
         * @event PIXI.BaseTexture#error
         * @param {PIXI.BaseTexture} baseTexture - Resource errored.
         */

        /**
         * Fired when BaseTexture is updated.
         *
         * @protected
         * @event PIXI.BaseTexture#update
         * @param {PIXI.BaseTexture} baseTexture - Instance of texture being updated.
         */

        /**
         * Fired when BaseTexture is destroyed.
         *
         * @protected
         * @event PIXI.BaseTexture#dispose
         * @param {PIXI.BaseTexture} baseTexture - Instance of texture being destroyed.
         */
        return _this;
    }

    /**
     * Updates the texture on all the webgl renderers, this also assumes the src has changed.
     *
     * @fires PIXI.BaseTexture#update
     */


    BaseTexture.prototype.update = function update() {
        // Svg size is handled during load
        if (this.imageType !== 'svg') {
            this.realWidth = this.source.naturalWidth || this.source.videoWidth || this.source.width;
            this.realHeight = this.source.naturalHeight || this.source.videoHeight || this.source.height;

            this._updateDimensions();
        }

        this.emit('update', this);
    };

    /**
     * Update dimensions from real values
     */


    BaseTexture.prototype._updateDimensions = function _updateDimensions() {
        this.width = this.realWidth / this.resolution;
        this.height = this.realHeight / this.resolution;

        this.isPowerOfTwo = _bitTwiddle2.default.isPow2(this.realWidth) && _bitTwiddle2.default.isPow2(this.realHeight);
    };

    /**
     * Load a source.
     *
     * If the source is not-immediately-available, such as an image that needs to be
     * downloaded, then the 'loaded' or 'error' event will be dispatched in the future
     * and `hasLoaded` will remain false after this call.
     *
     * The logic state after calling `loadSource` directly or indirectly (eg. `fromImage`, `new BaseTexture`) is:
     *
     *     if (texture.hasLoaded) {
     *        // texture ready for use
     *     } else if (texture.isLoading) {
     *        // listen to 'loaded' and/or 'error' events on texture
     *     } else {
     *        // not loading, not going to load UNLESS the source is reloaded
     *        // (it may still make sense to listen to the events)
     *     }
     *
     * @protected
     * @param {HTMLImageElement|HTMLCanvasElement} source - the source object of the texture.
     */


    BaseTexture.prototype.loadSource = function loadSource(source) {
        var wasLoading = this.isLoading;

        this.hasLoaded = false;
        this.isLoading = false;

        if (wasLoading && this.source) {
            this.source.onload = null;
            this.source.onerror = null;
        }

        var firstSourceLoaded = !this.source;

        this.source = source;

        // Apply source if loaded. Otherwise setup appropriate loading monitors.
        if ((source.src && source.complete || source.getContext) && source.width && source.height) {
            this._updateImageType();

            if (this.imageType === 'svg') {
                this._loadSvgSource();
            } else {
                this._sourceLoaded();
            }

            if (firstSourceLoaded) {
                // send loaded event if previous source was null and we have been passed a pre-loaded IMG element
                this.emit('loaded', this);
            }
        } else if (!source.getContext) {
            // Image fail / not ready
            this.isLoading = true;

            var scope = this;

            source.onload = function () {
                scope._updateImageType();
                source.onload = null;
                source.onerror = null;

                if (!scope.isLoading) {
                    return;
                }

                scope.isLoading = false;
                scope._sourceLoaded();

                if (scope.imageType === 'svg') {
                    scope._loadSvgSource();

                    return;
                }

                scope.emit('loaded', scope);
            };

            source.onerror = function () {
                source.onload = null;
                source.onerror = null;

                if (!scope.isLoading) {
                    return;
                }

                scope.isLoading = false;
                scope.emit('error', scope);
            };

            // Per http://www.w3.org/TR/html5/embedded-content-0.html#the-img-element
            //   "The value of `complete` can thus change while a script is executing."
            // So complete needs to be re-checked after the callbacks have been added..
            // NOTE: complete will be true if the image has no src so best to check if the src is set.
            if (source.complete && source.src) {
                // ..and if we're complete now, no need for callbacks
                source.onload = null;
                source.onerror = null;

                if (scope.imageType === 'svg') {
                    scope._loadSvgSource();

                    return;
                }

                this.isLoading = false;

                if (source.width && source.height) {
                    this._sourceLoaded();

                    // If any previous subscribers possible
                    if (wasLoading) {
                        this.emit('loaded', this);
                    }
                }
                // If any previous subscribers possible
                else if (wasLoading) {
                        this.emit('error', this);
                    }
            }
        }
    };

    /**
     * Updates type of the source image.
     */


    BaseTexture.prototype._updateImageType = function _updateImageType() {
        if (!this.imageUrl) {
            return;
        }

        var dataUri = (0, _utils.decomposeDataUri)(this.imageUrl);
        var imageType = void 0;

        if (dataUri && dataUri.mediaType === 'image') {
            // Check for subType validity
            var firstSubType = dataUri.subType.split('+')[0];

            imageType = (0, _utils.getUrlFileExtension)('.' + firstSubType);

            if (!imageType) {
                throw new Error('Invalid image type in data URI.');
            }
        } else {
            imageType = (0, _utils.getUrlFileExtension)(this.imageUrl);

            if (!imageType) {
                imageType = 'png';
            }
        }

        this.imageType = imageType;
    };

    /**
     * Checks if `source` is an SVG image and whether it's loaded via a URL or a data URI. Then calls
     * `_loadSvgSourceUsingDataUri` or `_loadSvgSourceUsingXhr`.
     */


    BaseTexture.prototype._loadSvgSource = function _loadSvgSource() {
        if (this.imageType !== 'svg') {
            // Do nothing if source is not svg
            return;
        }

        var dataUri = (0, _utils.decomposeDataUri)(this.imageUrl);

        if (dataUri) {
            this._loadSvgSourceUsingDataUri(dataUri);
        } else {
            // We got an URL, so we need to do an XHR to check the svg size
            this._loadSvgSourceUsingXhr();
        }
    };

    /**
     * Reads an SVG string from data URI and then calls `_loadSvgSourceUsingString`.
     *
     * @param {string} dataUri - The data uri to load from.
     */


    BaseTexture.prototype._loadSvgSourceUsingDataUri = function _loadSvgSourceUsingDataUri(dataUri) {
        var svgString = void 0;

        if (dataUri.encoding === 'base64') {
            if (!atob) {
                throw new Error('Your browser doesn\'t support base64 conversions.');
            }
            svgString = atob(dataUri.data);
        } else {
            svgString = dataUri.data;
        }

        this._loadSvgSourceUsingString(svgString);
    };

    /**
     * Loads an SVG string from `imageUrl` using XHR and then calls `_loadSvgSourceUsingString`.
     */


    BaseTexture.prototype._loadSvgSourceUsingXhr = function _loadSvgSourceUsingXhr() {
        var _this2 = this;

        var svgXhr = new XMLHttpRequest();

        // This throws error on IE, so SVG Document can't be used
        // svgXhr.responseType = 'document';

        // This is not needed since we load the svg as string (breaks IE too)
        // but overrideMimeType() can be used to force the response to be parsed as XML
        // svgXhr.overrideMimeType('image/svg+xml');

        svgXhr.onload = function () {
            if (svgXhr.readyState !== svgXhr.DONE || svgXhr.status !== 200) {
                throw new Error('Failed to load SVG using XHR.');
            }

            _this2._loadSvgSourceUsingString(svgXhr.response);
        };

        svgXhr.onerror = function () {
            return _this2.emit('error', _this2);
        };

        svgXhr.open('GET', this.imageUrl, true);
        svgXhr.send();
    };

    /**
     * Loads texture using an SVG string. The original SVG Image is stored as `origSource` and the
     * created canvas is the new `source`. The SVG is scaled using `sourceScale`. Called by
     * `_loadSvgSourceUsingXhr` or `_loadSvgSourceUsingDataUri`.
     *
     * @param  {string} svgString SVG source as string
     *
     * @fires PIXI.BaseTexture#loaded
     */


    BaseTexture.prototype._loadSvgSourceUsingString = function _loadSvgSourceUsingString(svgString) {
        var svgSize = (0, _utils.getSvgSize)(svgString);

        var svgWidth = svgSize.width;
        var svgHeight = svgSize.height;

        if (!svgWidth || !svgHeight) {
            throw new Error('The SVG image must have width and height defined (in pixels), canvas API needs them.');
        }

        // Scale realWidth and realHeight
        this.realWidth = Math.round(svgWidth * this.sourceScale);
        this.realHeight = Math.round(svgHeight * this.sourceScale);

        this._updateDimensions();

        // Create a canvas element
        var canvas = document.createElement('canvas');

        canvas.width = this.realWidth;
        canvas.height = this.realHeight;
        canvas._pixiId = 'canvas_' + (0, _utils.uid)();

        // Draw the Svg to the canvas
        canvas.getContext('2d').drawImage(this.source, 0, 0, svgWidth, svgHeight, 0, 0, this.realWidth, this.realHeight);

        // Replace the original source image with the canvas
        this.origSource = this.source;
        this.source = canvas;

        // Add also the canvas in cache (destroy clears by `imageUrl` and `source._pixiId`)
        BaseTexture.addToCache(this, canvas._pixiId);

        this.isLoading = false;
        this._sourceLoaded();
        this.emit('loaded', this);
    };

    /**
     * Used internally to update the width, height, and some other tracking vars once
     * a source has successfully loaded.
     *
     * @private
     */


    BaseTexture.prototype._sourceLoaded = function _sourceLoaded() {
        this.hasLoaded = true;
        this.update();
    };

    /**
     * Destroys this base texture
     *
     */


    BaseTexture.prototype.destroy = function destroy() {
        if (this.imageUrl) {
            delete _utils.TextureCache[this.imageUrl];

            this.imageUrl = null;

            if (!navigator.isCocoonJS) {
                this.source.src = '';
            }
        }

        this.source = null;

        this.dispose();

        BaseTexture.removeFromCache(this);
        this.textureCacheIds = null;

        this._destroyed = true;
    };

    /**
     * Frees the texture from WebGL memory without destroying this texture object.
     * This means you can still use the texture later which will upload it to GPU
     * memory again.
     *
     * @fires PIXI.BaseTexture#dispose
     */


    BaseTexture.prototype.dispose = function dispose() {
        this.emit('dispose', this);
    };

    /**
     * Changes the source image of the texture.
     * The original source must be an Image element.
     *
     * @param {string} newSrc - the path of the image
     */


    BaseTexture.prototype.updateSourceImage = function updateSourceImage(newSrc) {
        this.source.src = newSrc;

        this.loadSource(this.source);
    };

    /**
     * Helper function that creates a base texture from the given image url.
     * If the image is not in the base texture cache it will be created and loaded.
     *
     * @static
     * @param {string} imageUrl - The image url of the texture
     * @param {boolean} [crossorigin=(auto)] - Should use anonymous CORS? Defaults to true if the URL is not a data-URI.
     * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values
     * @param {number} [sourceScale=(auto)] - Scale for the original image, used with Svg images.
     * @return {PIXI.BaseTexture} The new base texture.
     */


    BaseTexture.fromImage = function fromImage(imageUrl, crossorigin, scaleMode, sourceScale) {
        var baseTexture = _utils.BaseTextureCache[imageUrl];

        if (!baseTexture) {
            // new Image() breaks tex loading in some versions of Chrome.
            // See https://code.google.com/p/chromium/issues/detail?id=238071
            var image = new Image(); // document.createElement('img');

            if (crossorigin === undefined && imageUrl.indexOf('data:') !== 0) {
                image.crossOrigin = (0, _determineCrossOrigin2.default)(imageUrl);
            } else if (crossorigin) {
                image.crossOrigin = typeof crossorigin === 'string' ? crossorigin : 'anonymous';
            }

            baseTexture = new BaseTexture(image, scaleMode);
            baseTexture.imageUrl = imageUrl;

            if (sourceScale) {
                baseTexture.sourceScale = sourceScale;
            }

            // if there is an @2x at the end of the url we are going to assume its a highres image
            baseTexture.resolution = (0, _utils.getResolutionOfUrl)(imageUrl);

            image.src = imageUrl; // Setting this triggers load

            BaseTexture.addToCache(baseTexture, imageUrl);
        }

        return baseTexture;
    };

    /**
     * Helper function that creates a base texture from the given canvas element.
     *
     * @static
     * @param {HTMLCanvasElement} canvas - The canvas element source of the texture
     * @param {number} scaleMode - See {@link PIXI.SCALE_MODES} for possible values
     * @param {string} [origin='canvas'] - A string origin of who created the base texture
     * @return {PIXI.BaseTexture} The new base texture.
     */


    BaseTexture.fromCanvas = function fromCanvas(canvas, scaleMode) {
        var origin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'canvas';

        if (!canvas._pixiId) {
            canvas._pixiId = origin + '_' + (0, _utils.uid)();
        }

        var baseTexture = _utils.BaseTextureCache[canvas._pixiId];

        if (!baseTexture) {
            baseTexture = new BaseTexture(canvas, scaleMode);
            BaseTexture.addToCache(baseTexture, canvas._pixiId);
        }

        return baseTexture;
    };

    /**
     * Helper function that creates a base texture based on the source you provide.
     * The source can be - image url, image element, canvas element. If the
     * source is an image url or an image element and not in the base texture
     * cache, it will be created and loaded.
     *
     * @static
     * @param {string|HTMLImageElement|HTMLCanvasElement} source - The source to create base texture from.
     * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values
     * @param {number} [sourceScale=(auto)] - Scale for the original image, used with Svg images.
     * @return {PIXI.BaseTexture} The new base texture.
     */


    BaseTexture.from = function from(source, scaleMode, sourceScale) {
        if (typeof source === 'string') {
            return BaseTexture.fromImage(source, undefined, scaleMode, sourceScale);
        } else if (source instanceof HTMLImageElement) {
            var imageUrl = source.src;
            var baseTexture = _utils.BaseTextureCache[imageUrl];

            if (!baseTexture) {
                baseTexture = new BaseTexture(source, scaleMode);
                baseTexture.imageUrl = imageUrl;

                if (sourceScale) {
                    baseTexture.sourceScale = sourceScale;
                }

                // if there is an @2x at the end of the url we are going to assume its a highres image
                baseTexture.resolution = (0, _utils.getResolutionOfUrl)(imageUrl);

                BaseTexture.addToCache(baseTexture, imageUrl);
            }

            return baseTexture;
        } else if (source instanceof HTMLCanvasElement) {
            return BaseTexture.fromCanvas(source, scaleMode);
        }

        // lets assume its a base texture!
        return source;
    };

    /**
     * Adds a BaseTexture to the global BaseTextureCache. This cache is shared across the whole PIXI object.
     *
     * @static
     * @param {PIXI.BaseTexture} baseTexture - The BaseTexture to add to the cache.
     * @param {string} id - The id that the BaseTexture will be stored against.
     */


    BaseTexture.addToCache = function addToCache(baseTexture, id) {
        if (id) {
            if (baseTexture.textureCacheIds.indexOf(id) === -1) {
                baseTexture.textureCacheIds.push(id);
            }

            // @if DEBUG
            /* eslint-disable no-console */
            if (_utils.BaseTextureCache[id]) {
                console.warn('BaseTexture added to the cache with an id [' + id + '] that already had an entry');
            }
            /* eslint-enable no-console */
            // @endif

            _utils.BaseTextureCache[id] = baseTexture;
        }
    };

    /**
     * Remove a BaseTexture from the global BaseTextureCache.
     *
     * @static
     * @param {string|PIXI.BaseTexture} baseTexture - id of a BaseTexture to be removed, or a BaseTexture instance itself.
     * @return {PIXI.BaseTexture|null} The BaseTexture that was removed.
     */


    BaseTexture.removeFromCache = function removeFromCache(baseTexture) {
        if (typeof baseTexture === 'string') {
            var baseTextureFromCache = _utils.BaseTextureCache[baseTexture];

            if (baseTextureFromCache) {
                var index = baseTextureFromCache.textureCacheIds.indexOf(baseTexture);

                if (index > -1) {
                    baseTextureFromCache.textureCacheIds.splice(index, 1);
                }

                delete _utils.BaseTextureCache[baseTexture];

                return baseTextureFromCache;
            }
        } else if (baseTexture && baseTexture.textureCacheIds) {
            for (var i = 0; i < baseTexture.textureCacheIds.length; ++i) {
                delete _utils.BaseTextureCache[baseTexture.textureCacheIds[i]];
            }

            baseTexture.textureCacheIds.length = 0;

            return baseTexture;
        }

        return null;
    };

    return BaseTexture;
}(_eventemitter2.default);

exports.default = BaseTexture;

},{"../settings":108,"../utils":132,"../utils/determineCrossOrigin":131,"bit-twiddle":22,"eventemitter3":24}],120:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _BaseRenderTexture = require('./BaseRenderTexture');

var _BaseRenderTexture2 = _interopRequireDefault(_BaseRenderTexture);

var _Texture2 = require('./Texture');

var _Texture3 = _interopRequireDefault(_Texture2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * A RenderTexture is a special texture that allows any PixiJS display object to be rendered to it.
 *
 * __Hint__: All DisplayObjects (i.e. Sprites) that render to a RenderTexture should be preloaded
 * otherwise black rectangles will be drawn instead.
 *
 * A RenderTexture takes a snapshot of any Display Object given to its render method. For example:
 *
 * ```js
 * let renderer = PIXI.autoDetectRenderer(1024, 1024);
 * let renderTexture = PIXI.RenderTexture.create(800, 600);
 * let sprite = PIXI.Sprite.fromImage("spinObj_01.png");
 *
 * sprite.position.x = 800/2;
 * sprite.position.y = 600/2;
 * sprite.anchor.x = 0.5;
 * sprite.anchor.y = 0.5;
 *
 * renderer.render(sprite, renderTexture);
 * ```
 *
 * The Sprite in this case will be rendered using its local transform. To render this sprite at 0,0
 * you can clear the transform
 *
 * ```js
 *
 * sprite.setTransform()
 *
 * let renderTexture = new PIXI.RenderTexture.create(100, 100);
 *
 * renderer.render(sprite, renderTexture);  // Renders to center of RenderTexture
 * ```
 *
 * @class
 * @extends PIXI.Texture
 * @memberof PIXI
 */
var RenderTexture = function (_Texture) {
    _inherits(RenderTexture, _Texture);

    /**
     * @param {PIXI.BaseRenderTexture} baseRenderTexture - The renderer used for this RenderTexture
     * @param {PIXI.Rectangle} [frame] - The rectangle frame of the texture to show
     */
    function RenderTexture(baseRenderTexture, frame) {
        _classCallCheck(this, RenderTexture);

        // support for legacy..
        var _legacyRenderer = null;

        if (!(baseRenderTexture instanceof _BaseRenderTexture2.default)) {
            /* eslint-disable prefer-rest-params, no-console */
            var width = arguments[1];
            var height = arguments[2];
            var scaleMode = arguments[3];
            var resolution = arguments[4];

            // we have an old render texture..
            console.warn('Please use RenderTexture.create(' + width + ', ' + height + ') instead of the ctor directly.');
            _legacyRenderer = arguments[0];
            /* eslint-enable prefer-rest-params, no-console */

            frame = null;
            baseRenderTexture = new _BaseRenderTexture2.default(width, height, scaleMode, resolution);
        }

        /**
         * The base texture object that this texture uses
         *
         * @member {BaseTexture}
         */

        var _this = _possibleConstructorReturn(this, _Texture.call(this, baseRenderTexture, frame));

        _this.legacyRenderer = _legacyRenderer;

        /**
         * This will let the renderer know if the texture is valid. If it's not then it cannot be rendered.
         *
         * @member {boolean}
         */
        _this.valid = true;

        _this._updateUvs();
        return _this;
    }

    /**
     * Resizes the RenderTexture.
     *
     * @param {number} width - The width to resize to.
     * @param {number} height - The height to resize to.
     * @param {boolean} doNotResizeBaseTexture - Should the baseTexture.width and height values be resized as well?
     */


    RenderTexture.prototype.resize = function resize(width, height, doNotResizeBaseTexture) {
        width = Math.ceil(width);
        height = Math.ceil(height);

        // TODO - could be not required..
        this.valid = width > 0 && height > 0;

        this._frame.width = this.orig.width = width;
        this._frame.height = this.orig.height = height;

        if (!doNotResizeBaseTexture) {
            this.baseTexture.resize(width, height);
        }

        this._updateUvs();
    };

    /**
     * A short hand way of creating a render texture.
     *
     * @param {number} [width=100] - The width of the render texture
     * @param {number} [height=100] - The height of the render texture
     * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values
     * @param {number} [resolution=1] - The resolution / device pixel ratio of the texture being generated
     * @return {PIXI.RenderTexture} The new render texture
     */


    RenderTexture.create = function create(width, height, scaleMode, resolution) {
        return new RenderTexture(new _BaseRenderTexture2.default(width, height, scaleMode, resolution));
    };

    return RenderTexture;
}(_Texture3.default);

exports.default = RenderTexture;

},{"./BaseRenderTexture":118,"./Texture":122}],121:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _ = require('../');

var _utils = require('../utils');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Utility class for maintaining reference to a collection
 * of Textures on a single Spritesheet.
 *
 * To access a sprite sheet from your code pass its JSON data file to Pixi's loader:
 *
 * ```js
 * PIXI.loader.add("images/spritesheet.json").load(setup);
 *
 * function setup() {
 *   let sheet = PIXI.loader.resources["images/spritesheet.json"].spritesheet;
 *   ...
 * }
 * ```
 * With the `sheet.textures` you can create Sprite objects,`sheet.animations` can be used to create an AnimatedSprite.
 *
 * Sprite sheets can be packed using tools like {@link https://codeandweb.com/texturepacker|TexturePacker},
 * {@link https://renderhjs.net/shoebox/|Shoebox} or {@link https://github.com/krzysztof-o/spritesheet.js|Spritesheet.js}.
 * Default anchor points (see {@link PIXI.Texture#defaultAnchor}) and grouping of animation sprites are currently only
 * supported by TexturePacker.
 *
 * @class
 * @memberof PIXI
 */
var Spritesheet = function () {
    _createClass(Spritesheet, null, [{
        key: 'BATCH_SIZE',

        /**
         * The maximum number of Textures to build per process.
         *
         * @type {number}
         * @default 1000
         */
        get: function get() {
            return 1000;
        }

        /**
         * @param {PIXI.BaseTexture} baseTexture Reference to the source BaseTexture object.
         * @param {Object} data - Spritesheet image data.
         * @param {string} [resolutionFilename] - The filename to consider when determining
         *        the resolution of the spritesheet. If not provided, the imageUrl will
         *        be used on the BaseTexture.
         */

    }]);

    function Spritesheet(baseTexture, data) {
        var resolutionFilename = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

        _classCallCheck(this, Spritesheet);

        /**
         * Reference to ths source texture
         * @type {PIXI.BaseTexture}
         */
        this.baseTexture = baseTexture;

        /**
         * A map containing all textures of the sprite sheet.
         * Can be used to create a {@link PIXI.Sprite|Sprite}:
         * ```js
         * new PIXI.Sprite(sheet.textures["image.png"]);
         * ```
         * @member {Object}
         */
        this.textures = {};

        /**
         * A map containing the textures for each animation.
         * Can be used to create an {@link PIXI.extras.AnimatedSprite|AnimatedSprite}:
         * ```js
         * new PIXI.extras.AnimatedSprite(sheet.animations["anim_name"])
         * ```
         * @member {Object}
         */
        this.animations = {};

        /**
         * Reference to the original JSON data.
         * @type {Object}
         */
        this.data = data;

        /**
         * The resolution of the spritesheet.
         * @type {number}
         */
        this.resolution = this._updateResolution(resolutionFilename || this.baseTexture.imageUrl);

        /**
         * Map of spritesheet frames.
         * @type {Object}
         * @private
         */
        this._frames = this.data.frames;

        /**
         * Collection of frame names.
         * @type {string[]}
         * @private
         */
        this._frameKeys = Object.keys(this._frames);

        /**
         * Current batch index being processed.
         * @type {number}
         * @private
         */
        this._batchIndex = 0;

        /**
         * Callback when parse is completed.
         * @type {Function}
         * @private
         */
        this._callback = null;
    }

    /**
     * Generate the resolution from the filename or fallback
     * to the meta.scale field of the JSON data.
     *
     * @private
     * @param {string} resolutionFilename - The filename to use for resolving
     *        the default resolution.
     * @return {number} Resolution to use for spritesheet.
     */


    Spritesheet.prototype._updateResolution = function _updateResolution(resolutionFilename) {
        var scale = this.data.meta.scale;

        // Use a defaultValue of `null` to check if a url-based resolution is set
        var resolution = (0, _utils.getResolutionOfUrl)(resolutionFilename, null);

        // No resolution found via URL
        if (resolution === null) {
            // Use the scale value or default to 1
            resolution = scale !== undefined ? parseFloat(scale) : 1;
        }

        // For non-1 resolutions, update baseTexture
        if (resolution !== 1) {
            this.baseTexture.resolution = resolution;
            this.baseTexture.update();
        }

        return resolution;
    };

    /**
     * Parser spritesheet from loaded data. This is done asynchronously
     * to prevent creating too many Texture within a single process.
     *
     * @param {Function} callback - Callback when complete returns
     *        a map of the Textures for this spritesheet.
     */


    Spritesheet.prototype.parse = function parse(callback) {
        this._batchIndex = 0;
        this._callback = callback;

        if (this._frameKeys.length <= Spritesheet.BATCH_SIZE) {
            this._processFrames(0);
            this._processAnimations();
            this._parseComplete();
        } else {
            this._nextBatch();
        }
    };

    /**
     * Process a batch of frames
     *
     * @private
     * @param {number} initialFrameIndex - The index of frame to start.
     */


    Spritesheet.prototype._processFrames = function _processFrames(initialFrameIndex) {
        var frameIndex = initialFrameIndex;
        var maxFrames = Spritesheet.BATCH_SIZE;
        var sourceScale = this.baseTexture.sourceScale;

        while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length) {
            var i = this._frameKeys[frameIndex];
            var data = this._frames[i];
            var rect = data.frame;

            if (rect) {
                var frame = null;
                var trim = null;
                var sourceSize = data.trimmed !== false && data.sourceSize ? data.sourceSize : data.frame;

                var orig = new _.Rectangle(0, 0, Math.floor(sourceSize.w * sourceScale) / this.resolution, Math.floor(sourceSize.h * sourceScale) / this.resolution);

                if (data.rotated) {
                    frame = new _.Rectangle(Math.floor(rect.x * sourceScale) / this.resolution, Math.floor(rect.y * sourceScale) / this.resolution, Math.floor(rect.h * sourceScale) / this.resolution, Math.floor(rect.w * sourceScale) / this.resolution);
                } else {
                    frame = new _.Rectangle(Math.floor(rect.x * sourceScale) / this.resolution, Math.floor(rect.y * sourceScale) / this.resolution, Math.floor(rect.w * sourceScale) / this.resolution, Math.floor(rect.h * sourceScale) / this.resolution);
                }

                //  Check to see if the sprite is trimmed
                if (data.trimmed !== false && data.spriteSourceSize) {
                    trim = new _.Rectangle(Math.floor(data.spriteSourceSize.x * sourceScale) / this.resolution, Math.floor(data.spriteSourceSize.y * sourceScale) / this.resolution, Math.floor(rect.w * sourceScale) / this.resolution, Math.floor(rect.h * sourceScale) / this.resolution);
                }

                this.textures[i] = new _.Texture(this.baseTexture, frame, orig, trim, data.rotated ? 2 : 0, data.anchor);

                // lets also add the frame to pixi's global cache for fromFrame and fromImage functions
                _.Texture.addToCache(this.textures[i], i);
            }

            frameIndex++;
        }
    };

    /**
     * Parse animations config
     *
     * @private
     */


    Spritesheet.prototype._processAnimations = function _processAnimations() {
        var animations = this.data.animations || {};

        for (var animName in animations) {
            this.animations[animName] = [];
            for (var _iterator = animations[animName], _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
                var _ref;

                if (_isArray) {
                    if (_i >= _iterator.length) break;
                    _ref = _iterator[_i++];
                } else {
                    _i = _iterator.next();
                    if (_i.done) break;
                    _ref = _i.value;
                }

                var frameName = _ref;

                this.animations[animName].push(this.textures[frameName]);
            }
        }
    };

    /**
     * The parse has completed.
     *
     * @private
     */


    Spritesheet.prototype._parseComplete = function _parseComplete() {
        var callback = this._callback;

        this._callback = null;
        this._batchIndex = 0;
        callback.call(this, this.textures);
    };

    /**
     * Begin the next batch of textures.
     *
     * @private
     */


    Spritesheet.prototype._nextBatch = function _nextBatch() {
        var _this = this;

        this._processFrames(this._batchIndex * Spritesheet.BATCH_SIZE);
        this._batchIndex++;
        setTimeout(function () {
            if (_this._batchIndex * Spritesheet.BATCH_SIZE < _this._frameKeys.length) {
                _this._nextBatch();
            } else {
                _this._processAnimations();
                _this._parseComplete();
            }
        }, 0);
    };

    /**
     * Destroy Spritesheet and don't use after this.
     *
     * @param {boolean} [destroyBase=false] Whether to destroy the base texture as well
     */


    Spritesheet.prototype.destroy = function destroy() {
        var destroyBase = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

        for (var i in this.textures) {
            this.textures[i].destroy();
        }
        this._frames = null;
        this._frameKeys = null;
        this.data = null;
        this.textures = null;
        if (destroyBase) {
            this.baseTexture.destroy();
        }
        this.baseTexture = null;
    };

    return Spritesheet;
}();

exports.default = Spritesheet;

},{"../":72,"../utils":132}],122:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _BaseTexture = require('./BaseTexture');

var _BaseTexture2 = _interopRequireDefault(_BaseTexture);

var _VideoBaseTexture = require('./VideoBaseTexture');

var _VideoBaseTexture2 = _interopRequireDefault(_VideoBaseTexture);

var _TextureUvs = require('./TextureUvs');

var _TextureUvs2 = _interopRequireDefault(_TextureUvs);

var _eventemitter = require('eventemitter3');

var _eventemitter2 = _interopRequireDefault(_eventemitter);

var _math = require('../math');

var _utils = require('../utils');

var _settings = require('../settings');

var _settings2 = _interopRequireDefault(_settings);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * A texture stores the information that represents an image or part of an image. It cannot be added
 * to the display list directly. Instead use it as the texture for a Sprite. If no frame is provided
 * then the whole image is used.
 *
 * You can directly create a texture from an image and then reuse it multiple times like this :
 *
 * ```js
 * let texture = PIXI.Texture.fromImage('assets/image.png');
 * let sprite1 = new PIXI.Sprite(texture);
 * let sprite2 = new PIXI.Sprite(texture);
 * ```
 *
 * Textures made from SVGs, loaded or not, cannot be used before the file finishes processing.
 * You can check for this by checking the sprite's _textureID property.
 * ```js
 * var texture = PIXI.Texture.fromImage('assets/image.svg');
 * var sprite1 = new PIXI.Sprite(texture);
 * //sprite1._textureID should not be undefined if the texture has finished processing the SVG file
 * ```
 * You can use a ticker or rAF to ensure your sprites load the finished textures after processing. See issue #3068.
 *
 * @class
 * @extends EventEmitter
 * @memberof PIXI
 */
var Texture = function (_EventEmitter) {
    _inherits(Texture, _EventEmitter);

    /**
     * @param {PIXI.BaseTexture} baseTexture - The base texture source to create the texture from
     * @param {PIXI.Rectangle} [frame] - The rectangle frame of the texture to show
     * @param {PIXI.Rectangle} [orig] - The area of original texture
     * @param {PIXI.Rectangle} [trim] - Trimmed rectangle of original texture
     * @param {number} [rotate] - indicates how the texture was rotated by texture packer. See {@link PIXI.GroupD8}
     * @param {PIXI.Point} [anchor] - Default anchor point used for sprite placement / rotation
     */
    function Texture(baseTexture, frame, orig, trim, rotate, anchor) {
        _classCallCheck(this, Texture);

        /**
         * Does this Texture have any frame data assigned to it?
         *
         * @member {boolean}
         */
        var _this = _possibleConstructorReturn(this, _EventEmitter.call(this));

        _this.noFrame = false;

        if (!frame) {
            _this.noFrame = true;
            frame = new _math.Rectangle(0, 0, 1, 1);
        }

        if (baseTexture instanceof Texture) {
            baseTexture = baseTexture.baseTexture;
        }

        /**
         * The base texture that this texture uses.
         *
         * @member {PIXI.BaseTexture}
         */
        _this.baseTexture = baseTexture;

        /**
         * This is the area of the BaseTexture image to actually copy to the Canvas / WebGL when rendering,
         * irrespective of the actual frame size or placement (which can be influenced by trimmed texture atlases)
         *
         * @member {PIXI.Rectangle}
         */
        _this._frame = frame;

        /**
         * This is the trimmed area of original texture, before it was put in atlas
         * Please call `_updateUvs()` after you change coordinates of `trim` manually.
         *
         * @member {PIXI.Rectangle}
         */
        _this.trim = trim;

        /**
         * This will let the renderer know if the texture is valid. If it's not then it cannot be rendered.
         *
         * @member {boolean}
         */
        _this.valid = false;

        /**
         * This will let a renderer know that a texture has been updated (used mainly for webGL uv updates)
         *
         * @member {boolean}
         */
        _this.requiresUpdate = false;

        /**
         * The WebGL UV data cache.
         *
         * @member {PIXI.TextureUvs}
         * @private
         */
        _this._uvs = null;

        /**
         * This is the area of original texture, before it was put in atlas
         *
         * @member {PIXI.Rectangle}
         */
        _this.orig = orig || frame; // new Rectangle(0, 0, 1, 1);

        _this._rotate = Number(rotate || 0);

        if (rotate === true) {
            // this is old texturepacker legacy, some games/libraries are passing "true" for rotated textures
            _this._rotate = 2;
        } else if (_this._rotate % 2 !== 0) {
            throw new Error('attempt to use diamond-shaped UVs. If you are sure, set rotation manually');
        }

        if (baseTexture.hasLoaded) {
            if (_this.noFrame) {
                frame = new _math.Rectangle(0, 0, baseTexture.width, baseTexture.height);

                // if there is no frame we should monitor for any base texture changes..
                baseTexture.on('update', _this.onBaseTextureUpdated, _this);
            }
            _this.frame = frame;
        } else {
            baseTexture.once('loaded', _this.onBaseTextureLoaded, _this);
        }

        /**
         * Anchor point that is used as default if sprite is created with this texture.
         * Changing the `defaultAnchor` at a later point of time will not update Sprite's anchor point.
         * @member {PIXI.Point}
         * @default {0,0}
         */
        _this.defaultAnchor = anchor ? new _math.Point(anchor.x, anchor.y) : new _math.Point(0, 0);

        /**
         * Fired when the texture is updated. This happens if the frame or the baseTexture is updated.
         *
         * @event PIXI.Texture#update
         * @protected
         * @param {PIXI.Texture} texture - Instance of texture being updated.
         */

        _this._updateID = 0;

        /**
         * Contains data for uvs. May contain clamp settings and some matrices.
         * Its a bit heavy, so by default that object is not created.
         * @member {PIXI.TextureMatrix}
         * @default null
         */
        _this.transform = null;

        /**
         * The ids under which this Texture has been added to the texture cache. This is
         * automatically set as long as Texture.addToCache is used, but may not be set if a
         * Texture is added directly to the TextureCache array.
         *
         * @member {string[]}
         */
        _this.textureCacheIds = [];
        return _this;
    }

    /**
     * Updates this texture on the gpu.
     *
     */


    Texture.prototype.update = function update() {
        this.baseTexture.update();
    };

    /**
     * Called when the base texture is loaded
     *
     * @private
     * @param {PIXI.BaseTexture} baseTexture - The base texture.
     */


    Texture.prototype.onBaseTextureLoaded = function onBaseTextureLoaded(baseTexture) {
        this._updateID++;

        // TODO this code looks confusing.. boo to abusing getters and setters!
        if (this.noFrame) {
            this.frame = new _math.Rectangle(0, 0, baseTexture.width, baseTexture.height);
        } else {
            this.frame = this._frame;
        }

        this.baseTexture.on('update', this.onBaseTextureUpdated, this);
        this.emit('update', this);
    };

    /**
     * Called when the base texture is updated
     *
     * @private
     * @param {PIXI.BaseTexture} baseTexture - The base texture.
     */


    Texture.prototype.onBaseTextureUpdated = function onBaseTextureUpdated(baseTexture) {
        this._updateID++;

        this._frame.width = baseTexture.width;
        this._frame.height = baseTexture.height;

        this.emit('update', this);
    };

    /**
     * Destroys this texture
     *
     * @param {boolean} [destroyBase=false] Whether to destroy the base texture as well
     */


    Texture.prototype.destroy = function destroy(destroyBase) {
        if (this.baseTexture) {
            if (destroyBase) {
                // delete the texture if it exists in the texture cache..
                // this only needs to be removed if the base texture is actually destroyed too..
                if (_utils.TextureCache[this.baseTexture.imageUrl]) {
                    Texture.removeFromCache(this.baseTexture.imageUrl);
                }

                this.baseTexture.destroy();
            }

            this.baseTexture.off('update', this.onBaseTextureUpdated, this);
            this.baseTexture.off('loaded', this.onBaseTextureLoaded, this);

            this.baseTexture = null;
        }

        this._frame = null;
        this._uvs = null;
        this.trim = null;
        this.orig = null;

        this.valid = false;

        Texture.removeFromCache(this);
        this.textureCacheIds = null;
    };

    /**
     * Creates a new texture object that acts the same as this one.
     *
     * @return {PIXI.Texture} The new texture
     */


    Texture.prototype.clone = function clone() {
        return new Texture(this.baseTexture, this.frame, this.orig, this.trim, this.rotate, this.defaultAnchor);
    };

    /**
     * Updates the internal WebGL UV cache. Use it after you change `frame` or `trim` of the texture.
     */


    Texture.prototype._updateUvs = function _updateUvs() {
        if (!this._uvs) {
            this._uvs = new _TextureUvs2.default();
        }

        this._uvs.set(this._frame, this.baseTexture, this.rotate);

        this._updateID++;
    };

    /**
     * Helper function that creates a Texture object from the given image url.
     * If the image is not in the texture cache it will be  created and loaded.
     *
     * @static
     * @param {string} imageUrl - The image url of the texture
     * @param {boolean} [crossorigin] - Whether requests should be treated as crossorigin
     * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values
     * @param {number} [sourceScale=(auto)] - Scale for the original image, used with SVG images.
     * @return {PIXI.Texture} The newly created texture
     */


    Texture.fromImage = function fromImage(imageUrl, crossorigin, scaleMode, sourceScale) {
        var texture = _utils.TextureCache[imageUrl];

        if (!texture) {
            texture = new Texture(_BaseTexture2.default.fromImage(imageUrl, crossorigin, scaleMode, sourceScale));
            Texture.addToCache(texture, imageUrl);
        }

        return texture;
    };

    /**
     * Helper function that creates a sprite that will contain a texture from the TextureCache based on the frameId
     * The frame ids are created when a Texture packer file has been loaded
     *
     * @static
     * @param {string} frameId - The frame Id of the texture in the cache
     * @return {PIXI.Texture} The newly created texture
     */


    Texture.fromFrame = function fromFrame(frameId) {
        var texture = _utils.TextureCache[frameId];

        if (!texture) {
            throw new Error('The frameId "' + frameId + '" does not exist in the texture cache');
        }

        return texture;
    };

    /**
     * Helper function that creates a new Texture based on the given canvas element.
     *
     * @static
     * @param {HTMLCanvasElement} canvas - The canvas element source of the texture
     * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values
     * @param {string} [origin='canvas'] - A string origin of who created the base texture
     * @return {PIXI.Texture} The newly created texture
     */


    Texture.fromCanvas = function fromCanvas(canvas, scaleMode) {
        var origin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'canvas';

        return new Texture(_BaseTexture2.default.fromCanvas(canvas, scaleMode, origin));
    };

    /**
     * Helper function that creates a new Texture based on the given video element.
     *
     * @static
     * @param {HTMLVideoElement|string} video - The URL or actual element of the video
     * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values
     * @param {boolean} [crossorigin=(auto)] - Should use anonymous CORS? Defaults to true if the URL is not a data-URI.
     * @param {boolean} [autoPlay=true] - Start playing video as soon as it is loaded
     * @return {PIXI.Texture} The newly created texture
     */


    Texture.fromVideo = function fromVideo(video, scaleMode, crossorigin, autoPlay) {
        if (typeof video === 'string') {
            return Texture.fromVideoUrl(video, scaleMode, crossorigin, autoPlay);
        }

        return new Texture(_VideoBaseTexture2.default.fromVideo(video, scaleMode, autoPlay));
    };

    /**
     * Helper function that creates a new Texture based on the video url.
     *
     * @static
     * @param {string} videoUrl - URL of the video
     * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values
     * @param {boolean} [crossorigin=(auto)] - Should use anonymous CORS? Defaults to true if the URL is not a data-URI.
     * @param {boolean} [autoPlay=true] - Start playing video as soon as it is loaded
     * @return {PIXI.Texture} The newly created texture
     */


    Texture.fromVideoUrl = function fromVideoUrl(videoUrl, scaleMode, crossorigin, autoPlay) {
        return new Texture(_VideoBaseTexture2.default.fromUrl(videoUrl, scaleMode, crossorigin, autoPlay));
    };

    /**
     * Helper function that creates a new Texture based on the source you provide.
     * The source can be - frame id, image url, video url, canvas element, video element, base texture
     *
     * @static
     * @param {number|string|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement|PIXI.BaseTexture}
     *        source - Source to create texture from
     * @return {PIXI.Texture} The newly created texture
     */


    Texture.from = function from(source) {
        // TODO auto detect cross origin..
        // TODO pass in scale mode?
        if (typeof source === 'string') {
            var texture = _utils.TextureCache[source];

            if (!texture) {
                // check if its a video..
                var isVideo = source.match(/\.(mp4|webm|ogg|h264|avi|mov)$/) !== null;

                if (isVideo) {
                    return Texture.fromVideoUrl(source);
                }

                return Texture.fromImage(source);
            }

            return texture;
        } else if (source instanceof HTMLImageElement) {
            return new Texture(_BaseTexture2.default.from(source));
        } else if (source instanceof HTMLCanvasElement) {
            return Texture.fromCanvas(source, _settings2.default.SCALE_MODE, 'HTMLCanvasElement');
        } else if (source instanceof HTMLVideoElement) {
            return Texture.fromVideo(source);
        } else if (source instanceof _BaseTexture2.default) {
            return new Texture(source);
        }

        // lets assume its a texture!
        return source;
    };

    /**
     * Create a texture from a source and add to the cache.
     *
     * @static
     * @param {HTMLImageElement|HTMLCanvasElement} source - The input source.
     * @param {String} imageUrl - File name of texture, for cache and resolving resolution.
     * @param {String} [name] - Human readible name for the texture cache. If no name is
     *        specified, only `imageUrl` will be used as the cache ID.
     * @return {PIXI.Texture} Output texture
     */


    Texture.fromLoader = function fromLoader(source, imageUrl, name) {
        var baseTexture = new _BaseTexture2.default(source, undefined, (0, _utils.getResolutionOfUrl)(imageUrl));
        var texture = new Texture(baseTexture);

        baseTexture.imageUrl = imageUrl;

        // No name, use imageUrl instead
        if (!name) {
            name = imageUrl;
        }

        // lets also add the frame to pixi's global cache for fromFrame and fromImage fucntions
        _BaseTexture2.default.addToCache(texture.baseTexture, name);
        Texture.addToCache(texture, name);

        // also add references by url if they are different.
        if (name !== imageUrl) {
            _BaseTexture2.default.addToCache(texture.baseTexture, imageUrl);
            Texture.addToCache(texture, imageUrl);
        }

        return texture;
    };

    /**
     * Adds a Texture to the global TextureCache. This cache is shared across the whole PIXI object.
     *
     * @static
     * @param {PIXI.Texture} texture - The Texture to add to the cache.
     * @param {string} id - The id that the Texture will be stored against.
     */


    Texture.addToCache = function addToCache(texture, id) {
        if (id) {
            if (texture.textureCacheIds.indexOf(id) === -1) {
                texture.textureCacheIds.push(id);
            }

            // @if DEBUG
            /* eslint-disable no-console */
            if (_utils.TextureCache[id]) {
                console.warn('Texture added to the cache with an id [' + id + '] that already had an entry');
            }
            /* eslint-enable no-console */
            // @endif

            _utils.TextureCache[id] = texture;
        }
    };

    /**
     * Remove a Texture from the global TextureCache.
     *
     * @static
     * @param {string|PIXI.Texture} texture - id of a Texture to be removed, or a Texture instance itself
     * @return {PIXI.Texture|null} The Texture that was removed
     */


    Texture.removeFromCache = function removeFromCache(texture) {
        if (typeof texture === 'string') {
            var textureFromCache = _utils.TextureCache[texture];

            if (textureFromCache) {
                var index = textureFromCache.textureCacheIds.indexOf(texture);

                if (index > -1) {
                    textureFromCache.textureCacheIds.splice(index, 1);
                }

                delete _utils.TextureCache[texture];

                return textureFromCache;
            }
        } else if (texture && texture.textureCacheIds) {
            for (var i = 0; i < texture.textureCacheIds.length; ++i) {
                // Check that texture matches the one being passed in before deleting it from the cache.
                if (_utils.TextureCache[texture.textureCacheIds[i]] === texture) {
                    delete _utils.TextureCache[texture.textureCacheIds[i]];
                }
            }

            texture.textureCacheIds.length = 0;

            return texture;
        }

        return null;
    };

    /**
     * The frame specifies the region of the base texture that this texture uses.
     * Please call `_updateUvs()` after you change coordinates of `frame` manually.
     *
     * @member {PIXI.Rectangle}
     */


    _createClass(Texture, [{
        key: 'frame',
        get: function get() {
            return this._frame;
        },
        set: function set(frame) // eslint-disable-line require-jsdoc
        {
            this._frame = frame;

            this.noFrame = false;

            var x = frame.x,
                y = frame.y,
                width = frame.width,
                height = frame.height;

            var xNotFit = x + width > this.baseTexture.width;
            var yNotFit = y + height > this.baseTexture.height;

            if (xNotFit || yNotFit) {
                var relationship = xNotFit && yNotFit ? 'and' : 'or';
                var errorX = 'X: ' + x + ' + ' + width + ' = ' + (x + width) + ' > ' + this.baseTexture.width;
                var errorY = 'Y: ' + y + ' + ' + height + ' = ' + (y + height) + ' > ' + this.baseTexture.height;

                throw new Error('Texture Error: frame does not fit inside the base Texture dimensions: ' + (errorX + ' ' + relationship + ' ' + errorY));
            }

            // this.valid = width && height && this.baseTexture.source && this.baseTexture.hasLoaded;
            this.valid = width && height && this.baseTexture.hasLoaded;

            if (!this.trim && !this.rotate) {
                this.orig = frame;
            }

            if (this.valid) {
                this._updateUvs();
            }
        }

        /**
         * Indicates whether the texture is rotated inside the atlas
         * set to 2 to compensate for texture packer rotation
         * set to 6 to compensate for spine packer rotation
         * can be used to rotate or mirror sprites
         * See {@link PIXI.GroupD8} for explanation
         *
         * @member {number}
         */

    }, {
        key: 'rotate',
        get: function get() {
            return this._rotate;
        },
        set: function set(rotate) // eslint-disable-line require-jsdoc
        {
            this._rotate = rotate;
            if (this.valid) {
                this._updateUvs();
            }
        }

        /**
         * The width of the Texture in pixels.
         *
         * @member {number}
         */

    }, {
        key: 'width',
        get: function get() {
            return this.orig.width;
        }

        /**
         * The height of the Texture in pixels.
         *
         * @member {number}
         */

    }, {
        key: 'height',
        get: function get() {
            return this.orig.height;
        }
    }]);

    return Texture;
}(_eventemitter2.default);

exports.default = Texture;


function createWhiteTexture() {
    var canvas = document.createElement('canvas');

    canvas.width = 10;
    canvas.height = 10;

    var context = canvas.getContext('2d');

    context.fillStyle = 'white';
    context.fillRect(0, 0, 10, 10);

    return new Texture(new _BaseTexture2.default(canvas));
}

function removeAllHandlers(tex) {
    tex.destroy = function _emptyDestroy() {/* empty */};
    tex.on = function _emptyOn() {/* empty */};
    tex.once = function _emptyOnce() {/* empty */};
    tex.emit = function _emptyEmit() {/* empty */};
}

/**
 * An empty texture, used often to not have to create multiple empty textures.
 * Can not be destroyed.
 *
 * @static
 * @constant
 */
Texture.EMPTY = new Texture(new _BaseTexture2.default());
removeAllHandlers(Texture.EMPTY);
removeAllHandlers(Texture.EMPTY.baseTexture);

/**
 * A white texture of 10x10 size, used for graphics and other things
 * Can not be destroyed.
 *
 * @static
 * @constant
 */
Texture.WHITE = createWhiteTexture();
removeAllHandlers(Texture.WHITE);
removeAllHandlers(Texture.WHITE.baseTexture);

},{"../math":77,"../settings":108,"../utils":132,"./BaseTexture":119,"./TextureUvs":124,"./VideoBaseTexture":125,"eventemitter3":24}],123:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Matrix = require('../math/Matrix');

var _Matrix2 = _interopRequireDefault(_Matrix);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var tempMat = new _Matrix2.default();

/**
 * Class controls uv transform and frame clamp for texture
 * Can be used in Texture "transform" field, or separately, you can use different clamp settings on the same texture.
 * If you want to add support for texture region of certain feature or filter, that's what you're looking for.
 *
 * @see PIXI.Texture
 * @see PIXI.mesh.Mesh
 * @see PIXI.extras.TilingSprite
 * @class
 * @memberof PIXI
 */

var TextureMatrix = function () {
    /**
     *
     * @param {PIXI.Texture} texture observed texture
     * @param {number} [clampMargin] Changes frame clamping, 0.5 by default. Use -0.5 for extra border.
     * @constructor
     */
    function TextureMatrix(texture, clampMargin) {
        _classCallCheck(this, TextureMatrix);

        this._texture = texture;

        this.mapCoord = new _Matrix2.default();

        this.uClampFrame = new Float32Array(4);

        this.uClampOffset = new Float32Array(2);

        this._lastTextureID = -1;

        /**
         * Changes frame clamping
         * Works with TilingSprite and Mesh
         * Change to 1.5 if you texture has repeated right and bottom lines, that leads to smoother borders
         *
         * @default 0
         * @member {number}
         */
        this.clampOffset = 0;

        /**
         * Changes frame clamping
         * Works with TilingSprite and Mesh
         * Change to -0.5 to add a pixel to the edge, recommended for transparent trimmed textures in atlas
         *
         * @default 0.5
         * @member {number}
         */
        this.clampMargin = typeof clampMargin === 'undefined' ? 0.5 : clampMargin;
    }

    /**
     * texture property
     * @member {PIXI.Texture}
     */


    /**
     * Multiplies uvs array to transform
     * @param {Float32Array} uvs mesh uvs
     * @param {Float32Array} [out=uvs] output
     * @returns {Float32Array} output
     */
    TextureMatrix.prototype.multiplyUvs = function multiplyUvs(uvs, out) {
        if (out === undefined) {
            out = uvs;
        }

        var mat = this.mapCoord;

        for (var i = 0; i < uvs.length; i += 2) {
            var x = uvs[i];
            var y = uvs[i + 1];

            out[i] = x * mat.a + y * mat.c + mat.tx;
            out[i + 1] = x * mat.b + y * mat.d + mat.ty;
        }

        return out;
    };

    /**
     * updates matrices if texture was changed
     * @param {boolean} forceUpdate if true, matrices will be updated any case
     * @returns {boolean} whether or not it was updated
     */


    TextureMatrix.prototype.update = function update(forceUpdate) {
        var tex = this._texture;

        if (!tex || !tex.valid) {
            return false;
        }

        if (!forceUpdate && this._lastTextureID === tex._updateID) {
            return false;
        }

        this._lastTextureID = tex._updateID;

        var uvs = tex._uvs;

        this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);

        var orig = tex.orig;
        var trim = tex.trim;

        if (trim) {
            tempMat.set(orig.width / trim.width, 0, 0, orig.height / trim.height, -trim.x / trim.width, -trim.y / trim.height);
            this.mapCoord.append(tempMat);
        }

        var texBase = tex.baseTexture;
        var frame = this.uClampFrame;
        var margin = this.clampMargin / texBase.resolution;
        var offset = this.clampOffset;

        frame[0] = (tex._frame.x + margin + offset) / texBase.width;
        frame[1] = (tex._frame.y + margin + offset) / texBase.height;
        frame[2] = (tex._frame.x + tex._frame.width - margin + offset) / texBase.width;
        frame[3] = (tex._frame.y + tex._frame.height - margin + offset) / texBase.height;
        this.uClampOffset[0] = offset / texBase.realWidth;
        this.uClampOffset[1] = offset / texBase.realHeight;

        return true;
    };

    _createClass(TextureMatrix, [{
        key: 'texture',
        get: function get() {
            return this._texture;
        },
        set: function set(value) // eslint-disable-line require-jsdoc
        {
            this._texture = value;
            this._lastTextureID = -1;
        }
    }]);

    return TextureMatrix;
}();

exports.default = TextureMatrix;

},{"../math/Matrix":74}],124:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _GroupD = require('../math/GroupD8');

var _GroupD2 = _interopRequireDefault(_GroupD);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * A standard object to store the Uvs of a texture
 *
 * @class
 * @private
 * @memberof PIXI
 */
var TextureUvs = function () {
    /**
     *
     */
    function TextureUvs() {
        _classCallCheck(this, TextureUvs);

        this.x0 = 0;
        this.y0 = 0;

        this.x1 = 1;
        this.y1 = 0;

        this.x2 = 1;
        this.y2 = 1;

        this.x3 = 0;
        this.y3 = 1;

        this.uvsUint32 = new Uint32Array(4);
    }

    /**
     * Sets the texture Uvs based on the given frame information.
     *
     * @private
     * @param {PIXI.Rectangle} frame - The frame of the texture
     * @param {PIXI.Rectangle} baseFrame - The base frame of the texture
     * @param {number} rotate - Rotation of frame, see {@link PIXI.GroupD8}
     */


    TextureUvs.prototype.set = function set(frame, baseFrame, rotate) {
        var tw = baseFrame.width;
        var th = baseFrame.height;

        if (rotate) {
            // width and height div 2 div baseFrame size
            var w2 = frame.width / 2 / tw;
            var h2 = frame.height / 2 / th;

            // coordinates of center
            var cX = frame.x / tw + w2;
            var cY = frame.y / th + h2;

            rotate = _GroupD2.default.add(rotate, _GroupD2.default.NW); // NW is top-left corner
            this.x0 = cX + w2 * _GroupD2.default.uX(rotate);
            this.y0 = cY + h2 * _GroupD2.default.uY(rotate);

            rotate = _GroupD2.default.add(rotate, 2); // rotate 90 degrees clockwise
            this.x1 = cX + w2 * _GroupD2.default.uX(rotate);
            this.y1 = cY + h2 * _GroupD2.default.uY(rotate);

            rotate = _GroupD2.default.add(rotate, 2);
            this.x2 = cX + w2 * _GroupD2.default.uX(rotate);
            this.y2 = cY + h2 * _GroupD2.default.uY(rotate);

            rotate = _GroupD2.default.add(rotate, 2);
            this.x3 = cX + w2 * _GroupD2.default.uX(rotate);
            this.y3 = cY + h2 * _GroupD2.default.uY(rotate);
        } else {
            this.x0 = frame.x / tw;
            this.y0 = frame.y / th;

            this.x1 = (frame.x + frame.width) / tw;
            this.y1 = frame.y / th;

            this.x2 = (frame.x + frame.width) / tw;
            this.y2 = (frame.y + frame.height) / th;

            this.x3 = frame.x / tw;
            this.y3 = (frame.y + frame.height) / th;
        }

        this.uvsUint32[0] = (Math.round(this.y0 * 65535) & 0xFFFF) << 16 | Math.round(this.x0 * 65535) & 0xFFFF;
        this.uvsUint32[1] = (Math.round(this.y1 * 65535) & 0xFFFF) << 16 | Math.round(this.x1 * 65535) & 0xFFFF;
        this.uvsUint32[2] = (Math.round(this.y2 * 65535) & 0xFFFF) << 16 | Math.round(this.x2 * 65535) & 0xFFFF;
        this.uvsUint32[3] = (Math.round(this.y3 * 65535) & 0xFFFF) << 16 | Math.round(this.x3 * 65535) & 0xFFFF;
    };

    return TextureUvs;
}();

exports.default = TextureUvs;

},{"../math/GroupD8":73}],125:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _BaseTexture2 = require('./BaseTexture');

var _BaseTexture3 = _interopRequireDefault(_BaseTexture2);

var _utils = require('../utils');

var _ticker = require('../ticker');

var _const = require('../const');

var _determineCrossOrigin = require('../utils/determineCrossOrigin');

var _determineCrossOrigin2 = _interopRequireDefault(_determineCrossOrigin);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * A texture of a [playing] Video.
 *
 * Video base textures mimic PixiJS BaseTexture.from.... method in their creation process.
 *
 * This can be used in several ways, such as:
 *
 * ```js
 * let texture = PIXI.VideoBaseTexture.fromUrl('http://mydomain.com/video.mp4');
 *
 * let texture = PIXI.VideoBaseTexture.fromUrl({ src: 'http://mydomain.com/video.mp4', mime: 'video/mp4' });
 *
 * let texture = PIXI.VideoBaseTexture.fromUrls(['/video.webm', '/video.mp4']);
 *
 * let texture = PIXI.VideoBaseTexture.fromUrls([
 *     { src: '/video.webm', mime: 'video/webm' },
 *     { src: '/video.mp4', mime: 'video/mp4' }
 * ]);
 * ```
 *
 * See the ["deus" demo](http://www.goodboydigital.com/pixijs/examples/deus/).
 *
 * @class
 * @extends PIXI.BaseTexture
 * @memberof PIXI
 */
var VideoBaseTexture = function (_BaseTexture) {
    _inherits(VideoBaseTexture, _BaseTexture);

    /**
     * @param {HTMLVideoElement} source - Video source
     * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values
     * @param {boolean} [autoPlay=true] - Start playing video as soon as it is loaded
     */
    function VideoBaseTexture(source, scaleMode) {
        var autoPlay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

        _classCallCheck(this, VideoBaseTexture);

        if (!source) {
            throw new Error('No video source element specified.');
        }

        // hook in here to check if video is already available.
        // BaseTexture looks for a source.complete boolean, plus width & height.

        if ((source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA) && source.width && source.height) {
            source.complete = true;
        }

        var _this = _possibleConstructorReturn(this, _BaseTexture.call(this, source, scaleMode));

        _this.width = source.videoWidth;
        _this.height = source.videoHeight;

        _this._autoUpdate = true;
        _this._isAutoUpdating = false;

        /**
         * When set to true will automatically play videos used by this texture once
         * they are loaded. If false, it will not modify the playing state.
         *
         * @member {boolean}
         * @default true
         */
        _this.autoPlay = autoPlay;

        _this.update = _this.update.bind(_this);
        _this._onCanPlay = _this._onCanPlay.bind(_this);

        source.addEventListener('play', _this._onPlayStart.bind(_this));
        source.addEventListener('pause', _this._onPlayStop.bind(_this));
        _this.hasLoaded = false;
        _this.__loaded = false;

        if (!_this._isSourceReady()) {
            source.addEventListener('canplay', _this._onCanPlay);
            source.addEventListener('canplaythrough', _this._onCanPlay);
        } else {
            _this._onCanPlay();
        }
        return _this;
    }

    /**
     * Returns true if the underlying source is playing.
     *
     * @private
     * @return {boolean} True if playing.
     */


    VideoBaseTexture.prototype._isSourcePlaying = function _isSourcePlaying() {
        var source = this.source;

        return source.currentTime > 0 && source.paused === false && source.ended === false && source.readyState > 2;
    };

    /**
     * Returns true if the underlying source is ready for playing.
     *
     * @private
     * @return {boolean} True if ready.
     */


    VideoBaseTexture.prototype._isSourceReady = function _isSourceReady() {
        return this.source.readyState === 3 || this.source.readyState === 4;
    };

    /**
     * Runs the update loop when the video is ready to play
     *
     * @private
     */


    VideoBaseTexture.prototype._onPlayStart = function _onPlayStart() {
        // Just in case the video has not received its can play even yet..
        if (!this.hasLoaded) {
            this._onCanPlay();
        }

        if (!this._isAutoUpdating && this.autoUpdate) {
            _ticker.shared.add(this.update, this, _const.UPDATE_PRIORITY.HIGH);
            this._isAutoUpdating = true;
        }
    };

    /**
     * Fired when a pause event is triggered, stops the update loop
     *
     * @private
     */


    VideoBaseTexture.prototype._onPlayStop = function _onPlayStop() {
        if (this._isAutoUpdating) {
            _ticker.shared.remove(this.update, this);
            this._isAutoUpdating = false;
        }
    };

    /**
     * Fired when the video is loaded and ready to play
     *
     * @private
     */


    VideoBaseTexture.prototype._onCanPlay = function _onCanPlay() {
        this.hasLoaded = true;

        if (this.source) {
            this.source.removeEventListener('canplay', this._onCanPlay);
            this.source.removeEventListener('canplaythrough', this._onCanPlay);

            this.width = this.source.videoWidth;
            this.height = this.source.videoHeight;

            // prevent multiple loaded dispatches..
            if (!this.__loaded) {
                this.__loaded = true;
                this.emit('loaded', this);
            }

            if (this._isSourcePlaying()) {
                this._onPlayStart();
            } else if (this.autoPlay) {
                this.source.play();
            }
        }
    };

    /**
     * Destroys this texture
     *
     */


    VideoBaseTexture.prototype.destroy = function destroy() {
        if (this._isAutoUpdating) {
            _ticker.shared.remove(this.update, this);
        }

        if (this.source && this.source._pixiId) {
            _BaseTexture3.default.removeFromCache(this.source._pixiId);
            delete this.source._pixiId;

            this.source.pause();
            this.source.src = '';
            this.source.load();
        }

        _BaseTexture.prototype.destroy.call(this);
    };

    /**
     * Mimic PixiJS BaseTexture.from.... method.
     *
     * @static
     * @param {HTMLVideoElement} video - Video to create texture from
     * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values
     * @param {boolean} [autoPlay=true] - Start playing video as soon as it is loaded
     * @return {PIXI.VideoBaseTexture} Newly created VideoBaseTexture
     */


    VideoBaseTexture.fromVideo = function fromVideo(video, scaleMode, autoPlay) {
        if (!video._pixiId) {
            video._pixiId = 'video_' + (0, _utils.uid)();
        }

        var baseTexture = _utils.BaseTextureCache[video._pixiId];

        if (!baseTexture) {
            baseTexture = new VideoBaseTexture(video, scaleMode, autoPlay);
            _BaseTexture3.default.addToCache(baseTexture, video._pixiId);
        }

        return baseTexture;
    };

    /**
     * Helper function that creates a new BaseTexture based on the given video element.
     * This BaseTexture can then be used to create a texture
     *
     * @static
     * @param {string|object|string[]|object[]} videoSrc - The URL(s) for the video.
     * @param {string} [videoSrc.src] - One of the source urls for the video
     * @param {string} [videoSrc.mime] - The mimetype of the video (e.g. 'video/mp4'). If not specified
     *  the url's extension will be used as the second part of the mime type.
     * @param {number} scaleMode - See {@link PIXI.SCALE_MODES} for possible values
     * @param {boolean} [crossorigin=(auto)] - Should use anonymous CORS? Defaults to true if the URL is not a data-URI.
     * @param {boolean} [autoPlay=true] - Start playing video as soon as it is loaded
     * @return {PIXI.VideoBaseTexture} Newly created VideoBaseTexture
     */


    VideoBaseTexture.fromUrl = function fromUrl(videoSrc, scaleMode, crossorigin, autoPlay) {
        var video = document.createElement('video');

        video.setAttribute('webkit-playsinline', '');
        video.setAttribute('playsinline', '');

        var url = Array.isArray(videoSrc) ? videoSrc[0].src || videoSrc[0] : videoSrc.src || videoSrc;

        if (crossorigin === undefined && url.indexOf('data:') !== 0) {
            video.crossOrigin = (0, _determineCrossOrigin2.default)(url);
        } else if (crossorigin) {
            video.crossOrigin = typeof crossorigin === 'string' ? crossorigin : 'anonymous';
        }

        // array of objects or strings
        if (Array.isArray(videoSrc)) {
            for (var i = 0; i < videoSrc.length; ++i) {
                video.appendChild(createSource(videoSrc[i].src || videoSrc[i], videoSrc[i].mime));
            }
        }
        // single object or string
        else {
                video.appendChild(createSource(url, videoSrc.mime));
            }

        video.load();

        return VideoBaseTexture.fromVideo(video, scaleMode, autoPlay);
    };

    /**
     * Should the base texture automatically update itself, set to true by default
     *
     * @member {boolean}
     */


    _createClass(VideoBaseTexture, [{
        key: 'autoUpdate',
        get: function get() {
            return this._autoUpdate;
        },
        set: function set(value) // eslint-disable-line require-jsdoc
        {
            if (value !== this._autoUpdate) {
                this._autoUpdate = value;

                if (!this._autoUpdate && this._isAutoUpdating) {
                    _ticker.shared.remove(this.update, this);
                    this._isAutoUpdating = false;
                } else if (this._autoUpdate && !this._isAutoUpdating) {
                    _ticker.shared.add(this.update, this, _const.UPDATE_PRIORITY.HIGH);
                    this._isAutoUpdating = true;
                }
            }
        }
    }]);

    return VideoBaseTexture;
}(_BaseTexture3.default);

exports.default = VideoBaseTexture;


VideoBaseTexture.fromUrls = VideoBaseTexture.fromUrl;

function createSource(path, type) {
    if (!type) {
        var purePath = path.split('?').shift().toLowerCase();

        type = 'video/' + purePath.substr(purePath.lastIndexOf('.') + 1);
    }

    var source = document.createElement('source');

    source.src = path;
    source.type = type;

    return source;
}

},{"../const":53,"../ticker":128,"../utils":132,"../utils/determineCrossOrigin":131,"./BaseTexture":119}],126:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _settings = require('../settings');

var _settings2 = _interopRequireDefault(_settings);

var _const = require('../const');

var _TickerListener = require('./TickerListener');

var _TickerListener2 = _interopRequireDefault(_TickerListener);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * A Ticker class that runs an update loop that other objects listen to.
 * This class is composed around listeners
 * meant for execution on the next requested animation frame.
 * Animation frames are requested only when necessary,
 * e.g. When the ticker is started and the emitter has listeners.
 *
 * @class
 * @memberof PIXI.ticker
 */
var Ticker = function () {
    /**
     *
     */
    function Ticker() {
        var _this = this;

        _classCallCheck(this, Ticker);

        /**
         * The first listener. All new listeners added are chained on this.
         * @private
         * @type {TickerListener}
         */
        this._head = new _TickerListener2.default(null, null, Infinity);

        /**
         * Internal current frame request ID
         * @private
         */
        this._requestId = null;

        /**
         * Internal value managed by minFPS property setter and getter.
         * This is the maximum allowed milliseconds between updates.
         * @private
         */
        this._maxElapsedMS = 100;

        /**
         * Whether or not this ticker should invoke the method
         * {@link PIXI.ticker.Ticker#start} automatically
         * when a listener is added.
         *
         * @member {boolean}
         * @default false
         */
        this.autoStart = false;

        /**
         * Scalar time value from last frame to this frame.
         * This value is capped by setting {@link PIXI.ticker.Ticker#minFPS}
         * and is scaled with {@link PIXI.ticker.Ticker#speed}.
         * **Note:** The cap may be exceeded by scaling.
         *
         * @member {number}
         * @default 1
         */
        this.deltaTime = 1;

        /**
         * Time elapsed in milliseconds from last frame to this frame.
         * Opposed to what the scalar {@link PIXI.ticker.Ticker#deltaTime}
         * is based, this value is neither capped nor scaled.
         * If the platform supports DOMHighResTimeStamp,
         * this value will have a precision of 1 µs.
         * Defaults to target frame time
         *
         * @member {number}
         * @default 16.66
         */
        this.elapsedMS = 1 / _settings2.default.TARGET_FPMS;

        /**
         * The last time {@link PIXI.ticker.Ticker#update} was invoked.
         * This value is also reset internally outside of invoking
         * update, but only when a new animation frame is requested.
         * If the platform supports DOMHighResTimeStamp,
         * this value will have a precision of 1 µs.
         *
         * @member {number}
         * @default -1
         */
        this.lastTime = -1;

        /**
         * Factor of current {@link PIXI.ticker.Ticker#deltaTime}.
         * @example
         * // Scales ticker.deltaTime to what would be
         * // the equivalent of approximately 120 FPS
         * ticker.speed = 2;
         *
         * @member {number}
         * @default 1
         */
        this.speed = 1;

        /**
         * Whether or not this ticker has been started.
         * `true` if {@link PIXI.ticker.Ticker#start} has been called.
         * `false` if {@link PIXI.ticker.Ticker#stop} has been called.
         * While `false`, this value may change to `true` in the
         * event of {@link PIXI.ticker.Ticker#autoStart} being `true`
         * and a listener is added.
         *
         * @member {boolean}
         * @default false
         */
        this.started = false;

        /**
         * Internal tick method bound to ticker instance.
         * This is because in early 2015, Function.bind
         * is still 60% slower in high performance scenarios.
         * Also separating frame requests from update method
         * so listeners may be called at any time and with
         * any animation API, just invoke ticker.update(time).
         *
         * @private
         * @param {number} time - Time since last tick.
         */
        this._tick = function (time) {
            _this._requestId = null;

            if (_this.started) {
                // Invoke listeners now
                _this.update(time);
                // Listener side effects may have modified ticker state.
                if (_this.started && _this._requestId === null && _this._head.next) {
                    _this._requestId = requestAnimationFrame(_this._tick);
                }
            }
        };
    }

    /**
     * Conditionally requests a new animation frame.
     * If a frame has not already been requested, and if the internal
     * emitter has listeners, a new frame is requested.
     *
     * @private
     */


    Ticker.prototype._requestIfNeeded = function _requestIfNeeded() {
        if (this._requestId === null && this._head.next) {
            // ensure callbacks get correct delta
            this.lastTime = performance.now();
            this._requestId = requestAnimationFrame(this._tick);
        }
    };

    /**
     * Conditionally cancels a pending animation frame.
     *
     * @private
     */


    Ticker.prototype._cancelIfNeeded = function _cancelIfNeeded() {
        if (this._requestId !== null) {
            cancelAnimationFrame(this._requestId);
            this._requestId = null;
        }
    };

    /**
     * Conditionally requests a new animation frame.
     * If the ticker has been started it checks if a frame has not already
     * been requested, and if the internal emitter has listeners. If these
     * conditions are met, a new frame is requested. If the ticker has not
     * been started, but autoStart is `true`, then the ticker starts now,
     * and continues with the previous conditions to request a new frame.
     *
     * @private
     */


    Ticker.prototype._startIfPossible = function _startIfPossible() {
        if (this.started) {
            this._requestIfNeeded();
        } else if (this.autoStart) {
            this.start();
        }
    };

    /**
     * Register a handler for tick events. Calls continuously unless
     * it is removed or the ticker is stopped.
     *
     * @param {Function} fn - The listener function to be added for updates
     * @param {Function} [context] - The listener context
     * @param {number} [priority=PIXI.UPDATE_PRIORITY.NORMAL] - The priority for emitting
     * @returns {PIXI.ticker.Ticker} This instance of a ticker
     */


    Ticker.prototype.add = function add(fn, context) {
        var priority = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _const.UPDATE_PRIORITY.NORMAL;

        return this._addListener(new _TickerListener2.default(fn, context, priority));
    };

    /**
     * Add a handler for the tick event which is only execute once.
     *
     * @param {Function} fn - The listener function to be added for one update
     * @param {Function} [context] - The listener context
     * @param {number} [priority=PIXI.UPDATE_PRIORITY.NORMAL] - The priority for emitting
     * @returns {PIXI.ticker.Ticker} This instance of a ticker
     */


    Ticker.prototype.addOnce = function addOnce(fn, context) {
        var priority = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _const.UPDATE_PRIORITY.NORMAL;

        return this._addListener(new _TickerListener2.default(fn, context, priority, true));
    };

    /**
     * Internally adds the event handler so that it can be sorted by priority.
     * Priority allows certain handler (user, AnimatedSprite, Interaction) to be run
     * before the rendering.
     *
     * @private
     * @param {TickerListener} listener - Current listener being added.
     * @returns {PIXI.ticker.Ticker} This instance of a ticker
     */


    Ticker.prototype._addListener = function _addListener(listener) {
        // For attaching to head
        var current = this._head.next;
        var previous = this._head;

        // Add the first item
        if (!current) {
            listener.connect(previous);
        } else {
            // Go from highest to lowest priority
            while (current) {
                if (listener.priority > current.priority) {
                    listener.connect(previous);
                    break;
                }
                previous = current;
                current = current.next;
            }

            // Not yet connected
            if (!listener.previous) {
                listener.connect(previous);
            }
        }

        this._startIfPossible();

        return this;
    };

    /**
     * Removes any handlers matching the function and context parameters.
     * If no handlers are left after removing, then it cancels the animation frame.
     *
     * @param {Function} fn - The listener function to be removed
     * @param {Function} [context] - The listener context to be removed
     * @returns {PIXI.ticker.Ticker} This instance of a ticker
     */


    Ticker.prototype.remove = function remove(fn, context) {
        var listener = this._head.next;

        while (listener) {
            // We found a match, lets remove it
            // no break to delete all possible matches
            // incase a listener was added 2+ times
            if (listener.match(fn, context)) {
                listener = listener.destroy();
            } else {
                listener = listener.next;
            }
        }

        if (!this._head.next) {
            this._cancelIfNeeded();
        }

        return this;
    };

    /**
     * Starts the ticker. If the ticker has listeners
     * a new animation frame is requested at this point.
     */


    Ticker.prototype.start = function start() {
        if (!this.started) {
            this.started = true;
            this._requestIfNeeded();
        }
    };

    /**
     * Stops the ticker. If the ticker has requested
     * an animation frame it is canceled at this point.
     */


    Ticker.prototype.stop = function stop() {
        if (this.started) {
            this.started = false;
            this._cancelIfNeeded();
        }
    };

    /**
     * Destroy the ticker and don't use after this. Calling
     * this method removes all references to internal events.
     */


    Ticker.prototype.destroy = function destroy() {
        this.stop();

        var listener = this._head.next;

        while (listener) {
            listener = listener.destroy(true);
        }

        this._head.destroy();
        this._head = null;
    };

    /**
     * Triggers an update. An update entails setting the
     * current {@link PIXI.ticker.Ticker#elapsedMS},
     * the current {@link PIXI.ticker.Ticker#deltaTime},
     * invoking all listeners with current deltaTime,
     * and then finally setting {@link PIXI.ticker.Ticker#lastTime}
     * with the value of currentTime that was provided.
     * This method will be called automatically by animation
     * frame callbacks if the ticker instance has been started
     * and listeners are added.
     *
     * @param {number} [currentTime=performance.now()] - the current time of execution
     */


    Ticker.prototype.update = function update() {
        var currentTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : performance.now();

        var elapsedMS = void 0;

        // If the difference in time is zero or negative, we ignore most of the work done here.
        // If there is no valid difference, then should be no reason to let anyone know about it.
        // A zero delta, is exactly that, nothing should update.
        //
        // The difference in time can be negative, and no this does not mean time traveling.
        // This can be the result of a race condition between when an animation frame is requested
        // on the current JavaScript engine event loop, and when the ticker's start method is invoked
        // (which invokes the internal _requestIfNeeded method). If a frame is requested before
        // _requestIfNeeded is invoked, then the callback for the animation frame the ticker requests,
        // can receive a time argument that can be less than the lastTime value that was set within
        // _requestIfNeeded. This difference is in microseconds, but this is enough to cause problems.
        //
        // This check covers this browser engine timing issue, as well as if consumers pass an invalid
        // currentTime value. This may happen if consumers opt-out of the autoStart, and update themselves.

        if (currentTime > this.lastTime) {
            // Save uncapped elapsedMS for measurement
            elapsedMS = this.elapsedMS = currentTime - this.lastTime;

            // cap the milliseconds elapsed used for deltaTime
            if (elapsedMS > this._maxElapsedMS) {
                elapsedMS = this._maxElapsedMS;
            }

            this.deltaTime = elapsedMS * _settings2.default.TARGET_FPMS * this.speed;

            // Cache a local reference, in-case ticker is destroyed
            // during the emit, we can still check for head.next
            var head = this._head;

            // Invoke listeners added to internal emitter
            var listener = head.next;

            while (listener) {
                listener = listener.emit(this.deltaTime);
            }

            if (!head.next) {
                this._cancelIfNeeded();
            }
        } else {
            this.deltaTime = this.elapsedMS = 0;
        }

        this.lastTime = currentTime;
    };

    /**
     * The frames per second at which this ticker is running.
     * The default is approximately 60 in most modern browsers.
     * **Note:** This does not factor in the value of
     * {@link PIXI.ticker.Ticker#speed}, which is specific
     * to scaling {@link PIXI.ticker.Ticker#deltaTime}.
     *
     * @member {number}
     * @readonly
     */


    _createClass(Ticker, [{
        key: 'FPS',
        get: function get() {
            return 1000 / this.elapsedMS;
        }

        /**
         * Manages the maximum amount of milliseconds allowed to
         * elapse between invoking {@link PIXI.ticker.Ticker#update}.
         * This value is used to cap {@link PIXI.ticker.Ticker#deltaTime},
         * but does not effect the measured value of {@link PIXI.ticker.Ticker#FPS}.
         * When setting this property it is clamped to a value between
         * `0` and `PIXI.settings.TARGET_FPMS * 1000`.
         *
         * @member {number}
         * @default 10
         */

    }, {
        key: 'minFPS',
        get: function get() {
            return 1000 / this._maxElapsedMS;
        },
        set: function set(fps) // eslint-disable-line require-jsdoc
        {
            // Clamp: 0 to TARGET_FPMS
            var minFPMS = Math.min(Math.max(0, fps) / 1000, _settings2.default.TARGET_FPMS);

            this._maxElapsedMS = 1 / minFPMS;
        }
    }]);

    return Ticker;
}();

exports.default = Ticker;

},{"../const":53,"../settings":108,"./TickerListener":127}],127:[function(require,module,exports){
"use strict";

exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Internal class for handling the priority sorting of ticker handlers.
 *
 * @private
 * @class
 * @memberof PIXI.ticker
 */
var TickerListener = function () {
    /**
     * Constructor
     *
     * @param {Function} fn - The listener function to be added for one update
     * @param {Function} [context=null] - The listener context
     * @param {number} [priority=0] - The priority for emitting
     * @param {boolean} [once=false] - If the handler should fire once
     */
    function TickerListener(fn) {
        var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        var priority = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var once = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

        _classCallCheck(this, TickerListener);

        /**
         * The handler function to execute.
         * @member {Function}
         */
        this.fn = fn;

        /**
         * The calling to execute.
         * @member {Function}
         */
        this.context = context;

        /**
         * The current priority.
         * @member {number}
         */
        this.priority = priority;

        /**
         * If this should only execute once.
         * @member {boolean}
         */
        this.once = once;

        /**
         * The next item in chain.
         * @member {TickerListener}
         */
        this.next = null;

        /**
         * The previous item in chain.
         * @member {TickerListener}
         */
        this.previous = null;

        /**
         * `true` if this listener has been destroyed already.
         * @member {boolean}
         * @private
         */
        this._destroyed = false;
    }

    /**
     * Simple compare function to figure out if a function and context match.
     *
     * @param {Function} fn - The listener function to be added for one update
     * @param {Function} context - The listener context
     * @return {boolean} `true` if the listener match the arguments
     */


    TickerListener.prototype.match = function match(fn, context) {
        context = context || null;

        return this.fn === fn && this.context === context;
    };

    /**
     * Emit by calling the current function.
     * @param {number} deltaTime - time since the last emit.
     * @return {TickerListener} Next ticker
     */


    TickerListener.prototype.emit = function emit(deltaTime) {
        if (this.fn) {
            if (this.context) {
                this.fn.call(this.context, deltaTime);
            } else {
                this.fn(deltaTime);
            }
        }

        var redirect = this.next;

        if (this.once) {
            this.destroy(true);
        }

        // Soft-destroying should remove
        // the next reference
        if (this._destroyed) {
            this.next = null;
        }

        return redirect;
    };

    /**
     * Connect to the list.
     * @param {TickerListener} previous - Input node, previous listener
     */


    TickerListener.prototype.connect = function connect(previous) {
        this.previous = previous;
        if (previous.next) {
            previous.next.previous = this;
        }
        this.next = previous.next;
        previous.next = this;
    };

    /**
     * Destroy and don't use after this.
     * @param {boolean} [hard = false] `true` to remove the `next` reference, this
     *        is considered a hard destroy. Soft destroy maintains the next reference.
     * @return {TickerListener} The listener to redirect while emitting or removing.
     */


    TickerListener.prototype.destroy = function destroy() {
        var hard = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

        this._destroyed = true;
        this.fn = null;
        this.context = null;

        // Disconnect, hook up next and previous
        if (this.previous) {
            this.previous.next = this.next;
        }

        if (this.next) {
            this.next.previous = this.previous;
        }

        // Redirect to the next item
        var redirect = this.next;

        // Remove references
        this.next = hard ? null : redirect;
        this.previous = null;

        return redirect;
    };

    return TickerListener;
}();

exports.default = TickerListener;

},{}],128:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.Ticker = exports.shared = undefined;

var _Ticker = require('./Ticker');

var _Ticker2 = _interopRequireDefault(_Ticker);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * The shared ticker instance used by {@link PIXI.extras.AnimatedSprite}.
 * and by {@link PIXI.interaction.InteractionManager}.
 * The property {@link PIXI.ticker.Ticker#autoStart} is set to `true`
 * for this instance. Please follow the examples for usage, including
 * how to opt-out of auto-starting the shared ticker.
 *
 * @example
 * let ticker = PIXI.ticker.shared;
 * // Set this to prevent starting this ticker when listeners are added.
 * // By default this is true only for the PIXI.ticker.shared instance.
 * ticker.autoStart = false;
 * // FYI, call this to ensure the ticker is stopped. It should be stopped
 * // if you have not attempted to render anything yet.
 * ticker.stop();
 * // Call this when you are ready for a running shared ticker.
 * ticker.start();
 *
 * @example
 * // You may use the shared ticker to render...
 * let renderer = PIXI.autoDetectRenderer(800, 600);
 * let stage = new PIXI.Container();
 * let interactionManager = PIXI.interaction.InteractionManager(renderer);
 * document.body.appendChild(renderer.view);
 * ticker.add(function (time) {
 *     renderer.render(stage);
 * });
 *
 * @example
 * // Or you can just update it manually.
 * ticker.autoStart = false;
 * ticker.stop();
 * function animate(time) {
 *     ticker.update(time);
 *     renderer.render(stage);
 *     requestAnimationFrame(animate);
 * }
 * animate(performance.now());
 *
 * @type {PIXI.ticker.Ticker}
 * @memberof PIXI.ticker
 */
var shared = new _Ticker2.default();

shared.autoStart = true;
shared.destroy = function () {
  // protect destroying shared ticker
  // this is used by other internal systems
  // like AnimatedSprite and InteractionManager
};

/**
 * This namespace contains an API for interacting with PIXI's internal global update loop.
 *
 * This ticker is used for rendering, {@link PIXI.extras.AnimatedSprite AnimatedSprite},
 * {@link PIXI.interaction.InteractionManager InteractionManager} and many other time-based PIXI systems.
 * @example
 * const ticker = new PIXI.ticker.Ticker();
 * ticker.stop();
 * ticker.add((deltaTime) => {
 *   // do something every frame
 * });
 * ticker.start();
 * @namespace PIXI.ticker
 */
exports.shared = shared;
exports.Ticker = _Ticker2.default;

},{"./Ticker":126}],129:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.default = canUploadSameBuffer;
function canUploadSameBuffer() {
	// Uploading the same buffer multiple times in a single frame can cause perf issues.
	// Apparent on IOS so only check for that at the moment
	// this check may become more complex if this issue pops up elsewhere.
	var ios = !!navigator.platform && /iPad|iPhone|iPod/.test(navigator.platform);

	return !ios;
}

},{}],130:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.default = createIndicesForQuads;
/**
 * Generic Mask Stack data structure
 *
 * @memberof PIXI
 * @function createIndicesForQuads
 * @private
 * @param {number} size - Number of quads
 * @return {Uint16Array} indices
 */
function createIndicesForQuads(size) {
    // the total number of indices in our array, there are 6 points per quad.

    var totalIndices = size * 6;

    var indices = new Uint16Array(totalIndices);

    // fill the indices with the quads to draw
    for (var i = 0, j = 0; i < totalIndices; i += 6, j += 4) {
        indices[i + 0] = j + 0;
        indices[i + 1] = j + 1;
        indices[i + 2] = j + 2;
        indices[i + 3] = j + 0;
        indices[i + 4] = j + 2;
        indices[i + 5] = j + 3;
    }

    return indices;
}

},{}],131:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.default = determineCrossOrigin;

var _url2 = require('url');

var _url3 = _interopRequireDefault(_url2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var tempAnchor = void 0;

/**
 * Sets the `crossOrigin` property for this resource based on if the url
 * for this resource is cross-origin. If crossOrigin was manually set, this
 * function does nothing.
 * Nipped from the resource loader!
 *
 * @ignore
 * @param {string} url - The url to test.
 * @param {object} [loc=window.location] - The location object to test against.
 * @return {string} The crossOrigin value to use (or empty string for none).
 */
function determineCrossOrigin(url) {
    var loc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window.location;

    // data: and javascript: urls are considered same-origin
    if (url.indexOf('data:') === 0) {
        return '';
    }

    // default is window.location
    loc = loc || window.location;

    if (!tempAnchor) {
        tempAnchor = document.createElement('a');
    }

    // let the browser determine the full href for the url of this resource and then
    // parse with the node url lib, we can't use the properties of the anchor element
    // because they don't work in IE9 :(
    tempAnchor.href = url;
    url = _url3.default.parse(tempAnchor.href);

    var samePort = !url.port && loc.port === '' || url.port === loc.port;

    // if cross origin
    if (url.hostname !== loc.hostname || !samePort || url.protocol !== loc.protocol) {
        return 'anonymous';
    }

    return '';
}

},{"url":7}],132:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.premultiplyBlendMode = exports.BaseTextureCache = exports.TextureCache = exports.earcut = exports.mixins = exports.pluginTarget = exports.EventEmitter = exports.removeItems = exports.isMobile = undefined;
exports.uid = uid;
exports.hex2rgb = hex2rgb;
exports.hex2string = hex2string;
exports.rgb2hex = rgb2hex;
exports.getResolutionOfUrl = getResolutionOfUrl;
exports.decomposeDataUri = decomposeDataUri;
exports.getUrlFileExtension = getUrlFileExtension;
exports.getSvgSize = getSvgSize;
exports.skipHello = skipHello;
exports.sayHello = sayHello;
exports.isWebGLSupported = isWebGLSupported;
exports.sign = sign;
exports.destroyTextureCache = destroyTextureCache;
exports.clearTextureCache = clearTextureCache;
exports.correctBlendMode = correctBlendMode;
exports.premultiplyTint = premultiplyTint;
exports.premultiplyRgba = premultiplyRgba;
exports.premultiplyTintToRgba = premultiplyTintToRgba;

var _const = require('../const');

var _settings = require('../settings');

var _settings2 = _interopRequireDefault(_settings);

var _eventemitter = require('eventemitter3');

var _eventemitter2 = _interopRequireDefault(_eventemitter);

var _pluginTarget = require('./pluginTarget');

var _pluginTarget2 = _interopRequireDefault(_pluginTarget);

var _mixin = require('./mixin');

var mixins = _interopRequireWildcard(_mixin);

var _ismobilejs = require('ismobilejs');

var isMobile = _interopRequireWildcard(_ismobilejs);

var _removeArrayItems = require('remove-array-items');

var _removeArrayItems2 = _interopRequireDefault(_removeArrayItems);

var _mapPremultipliedBlendModes = require('./mapPremultipliedBlendModes');

var _mapPremultipliedBlendModes2 = _interopRequireDefault(_mapPremultipliedBlendModes);

var _earcut = require('earcut');

var _earcut2 = _interopRequireDefault(_earcut);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var nextUid = 0;
var saidHello = false;

/**
 * Generalized convenience utilities for PIXI.
 * @example
 * // Extend PIXI's internal Event Emitter.
 * class MyEmitter extends PIXI.utils.EventEmitter {
 *   constructor() {
 *      super();
 *      console.log("Emitter created!");
 *   }
 * }
 *
 * // Get info on current device
 * console.log(PIXI.utils.isMobile);
 *
 * // Convert hex color to string
 * console.log(PIXI.utils.hex2string(0xff00ff)); // returns: "#ff00ff"
 * @namespace PIXI.utils
 */
exports.isMobile = isMobile;
exports.removeItems = _removeArrayItems2.default;
exports.EventEmitter = _eventemitter2.default;
exports.pluginTarget = _pluginTarget2.default;
exports.mixins = mixins;
exports.earcut = _earcut2.default;

/**
 * Gets the next unique identifier
 *
 * @memberof PIXI.utils
 * @function uid
 * @return {number} The next unique identifier to use.
 */

function uid() {
    return ++nextUid;
}

/**
 * Converts a hex color number to an [R, G, B] array
 *
 * @memberof PIXI.utils
 * @function hex2rgb
 * @param {number} hex - The number to convert
 * @param  {number[]} [out=[]] If supplied, this array will be used rather than returning a new one
 * @return {number[]} An array representing the [R, G, B] of the color.
 */
function hex2rgb(hex, out) {
    out = out || [];

    out[0] = (hex >> 16 & 0xFF) / 255;
    out[1] = (hex >> 8 & 0xFF) / 255;
    out[2] = (hex & 0xFF) / 255;

    return out;
}

/**
 * Converts a hex color number to a string.
 *
 * @memberof PIXI.utils
 * @function hex2string
 * @param {number} hex - Number in hex
 * @return {string} The string color.
 */
function hex2string(hex) {
    hex = hex.toString(16);
    hex = '000000'.substr(0, 6 - hex.length) + hex;

    return '#' + hex;
}

/**
 * Converts a color as an [R, G, B] array to a hex number
 *
 * @memberof PIXI.utils
 * @function rgb2hex
 * @param {number[]} rgb - rgb array
 * @return {number} The color number
 */
function rgb2hex(rgb) {
    return (rgb[0] * 255 << 16) + (rgb[1] * 255 << 8) + (rgb[2] * 255 | 0);
}

/**
 * get the resolution / device pixel ratio of an asset by looking for the prefix
 * used by spritesheets and image urls
 *
 * @memberof PIXI.utils
 * @function getResolutionOfUrl
 * @param {string} url - the image path
 * @param {number} [defaultValue=1] - the defaultValue if no filename prefix is set.
 * @return {number} resolution / device pixel ratio of an asset
 */
function getResolutionOfUrl(url, defaultValue) {
    var resolution = _settings2.default.RETINA_PREFIX.exec(url);

    if (resolution) {
        return parseFloat(resolution[1]);
    }

    return defaultValue !== undefined ? defaultValue : 1;
}

/**
 * Typedef for decomposeDataUri return object.
 *
 * @typedef {object} PIXI.utils~DecomposedDataUri
 * @property {mediaType} Media type, eg. `image`
 * @property {subType} Sub type, eg. `png`
 * @property {encoding} Data encoding, eg. `base64`
 * @property {data} The actual data
 */

/**
 * Split a data URI into components. Returns undefined if
 * parameter `dataUri` is not a valid data URI.
 *
 * @memberof PIXI.utils
 * @function decomposeDataUri
 * @param {string} dataUri - the data URI to check
 * @return {PIXI.utils~DecomposedDataUri|undefined} The decomposed data uri or undefined
 */
function decomposeDataUri(dataUri) {
    var dataUriMatch = _const.DATA_URI.exec(dataUri);

    if (dataUriMatch) {
        return {
            mediaType: dataUriMatch[1] ? dataUriMatch[1].toLowerCase() : undefined,
            subType: dataUriMatch[2] ? dataUriMatch[2].toLowerCase() : undefined,
            charset: dataUriMatch[3] ? dataUriMatch[3].toLowerCase() : undefined,
            encoding: dataUriMatch[4] ? dataUriMatch[4].toLowerCase() : undefined,
            data: dataUriMatch[5]
        };
    }

    return undefined;
}

/**
 * Get type of the image by regexp for extension. Returns undefined for unknown extensions.
 *
 * @memberof PIXI.utils
 * @function getUrlFileExtension
 * @param {string} url - the image path
 * @return {string|undefined} image extension
 */
function getUrlFileExtension(url) {
    var extension = _const.URL_FILE_EXTENSION.exec(url);

    if (extension) {
        return extension[1].toLowerCase();
    }

    return undefined;
}

/**
 * Typedef for Size object.
 *
 * @typedef {object} PIXI.utils~Size
 * @property {width} Width component
 * @property {height} Height component
 */

/**
 * Get size from an svg string using regexp.
 *
 * @memberof PIXI.utils
 * @function getSvgSize
 * @param {string} svgString - a serialized svg element
 * @return {PIXI.utils~Size|undefined} image extension
 */
function getSvgSize(svgString) {
    var sizeMatch = _const.SVG_SIZE.exec(svgString);
    var size = {};

    if (sizeMatch) {
        size[sizeMatch[1]] = Math.round(parseFloat(sizeMatch[3]));
        size[sizeMatch[5]] = Math.round(parseFloat(sizeMatch[7]));
    }

    return size;
}

/**
 * Skips the hello message of renderers that are created after this is run.
 *
 * @function skipHello
 * @memberof PIXI.utils
 */
function skipHello() {
    saidHello = true;
}

/**
 * Logs out the version and renderer information for this running instance of PIXI.
 * If you don't want to see this message you can run `PIXI.utils.skipHello()` before
 * creating your renderer. Keep in mind that doing that will forever makes you a jerk face.
 *
 * @static
 * @function sayHello
 * @memberof PIXI.utils
 * @param {string} type - The string renderer type to log.
 */
function sayHello(type) {
    if (saidHello) {
        return;
    }

    if (navigator.userAgent.toLowerCase().indexOf('chrome') > -1) {
        var args = ['\n %c %c %c PixiJS ' + _const.VERSION + ' - \u2730 ' + type + ' \u2730  %c  %c  http://www.pixijs.com/  %c %c \u2665%c\u2665%c\u2665 \n\n', 'background: #ff66a5; padding:5px 0;', 'background: #ff66a5; padding:5px 0;', 'color: #ff66a5; background: #030307; padding:5px 0;', 'background: #ff66a5; padding:5px 0;', 'background: #ffc3dc; padding:5px 0;', 'background: #ff66a5; padding:5px 0;', 'color: #ff2424; background: #fff; padding:5px 0;', 'color: #ff2424; background: #fff; padding:5px 0;', 'color: #ff2424; background: #fff; padding:5px 0;'];

        window.console.log.apply(console, args);
    } else if (window.console) {
        window.console.log('PixiJS ' + _const.VERSION + ' - ' + type + ' - http://www.pixijs.com/');
    }

    saidHello = true;
}

/**
 * Helper for checking for webgl support
 *
 * @memberof PIXI.utils
 * @function isWebGLSupported
 * @return {boolean} is webgl supported
 */
function isWebGLSupported() {
    var contextOptions = { stencil: true, failIfMajorPerformanceCaveat: true };

    try {
        if (!window.WebGLRenderingContext) {
            return false;
        }

        var canvas = document.createElement('canvas');
        var gl = canvas.getContext('webgl', contextOptions) || canvas.getContext('experimental-webgl', contextOptions);

        var success = !!(gl && gl.getContextAttributes().stencil);

        if (gl) {
            var loseContext = gl.getExtension('WEBGL_lose_context');

            if (loseContext) {
                loseContext.loseContext();
            }
        }

        gl = null;

        return success;
    } catch (e) {
        return false;
    }
}

/**
 * Returns sign of number
 *
 * @memberof PIXI.utils
 * @function sign
 * @param {number} n - the number to check the sign of
 * @returns {number} 0 if `n` is 0, -1 if `n` is negative, 1 if `n` is positive
 */
function sign(n) {
    if (n === 0) return 0;

    return n < 0 ? -1 : 1;
}

/**
 * @todo Describe property usage
 *
 * @memberof PIXI.utils
 * @private
 */
var TextureCache = exports.TextureCache = Object.create(null);

/**
 * @todo Describe property usage
 *
 * @memberof PIXI.utils
 * @private
 */
var BaseTextureCache = exports.BaseTextureCache = Object.create(null);

/**
 * Destroys all texture in the cache
 *
 * @memberof PIXI.utils
 * @function destroyTextureCache
 */
function destroyTextureCache() {
    var key = void 0;

    for (key in TextureCache) {
        TextureCache[key].destroy();
    }
    for (key in BaseTextureCache) {
        BaseTextureCache[key].destroy();
    }
}

/**
 * Removes all textures from cache, but does not destroy them
 *
 * @memberof PIXI.utils
 * @function clearTextureCache
 */
function clearTextureCache() {
    var key = void 0;

    for (key in TextureCache) {
        delete TextureCache[key];
    }
    for (key in BaseTextureCache) {
        delete BaseTextureCache[key];
    }
}

/**
 * maps premultiply flag and blendMode to adjusted blendMode
 * @memberof PIXI.utils
 * @const premultiplyBlendMode
 * @type {Array<number[]>}
 */
var premultiplyBlendMode = exports.premultiplyBlendMode = (0, _mapPremultipliedBlendModes2.default)();

/**
 * changes blendMode according to texture format
 *
 * @memberof PIXI.utils
 * @function correctBlendMode
 * @param {number} blendMode supposed blend mode
 * @param {boolean} premultiplied  whether source is premultiplied
 * @returns {number} true blend mode for this texture
 */
function correctBlendMode(blendMode, premultiplied) {
    return premultiplyBlendMode[premultiplied ? 1 : 0][blendMode];
}

/**
 * premultiplies tint
 *
 * @memberof PIXI.utils
 * @param {number} tint integet RGB
 * @param {number} alpha floating point alpha (0.0-1.0)
 * @returns {number} tint multiplied by alpha
 */
function premultiplyTint(tint, alpha) {
    if (alpha === 1.0) {
        return (alpha * 255 << 24) + tint;
    }
    if (alpha === 0.0) {
        return 0;
    }
    var R = tint >> 16 & 0xFF;
    var G = tint >> 8 & 0xFF;
    var B = tint & 0xFF;

    R = R * alpha + 0.5 | 0;
    G = G * alpha + 0.5 | 0;
    B = B * alpha + 0.5 | 0;

    return (alpha * 255 << 24) + (R << 16) + (G << 8) + B;
}

/**
 * combines rgb and alpha to out array
 *
 * @memberof PIXI.utils
 * @param {Float32Array|number[]} rgb input rgb
 * @param {number} alpha alpha param
 * @param {Float32Array} [out] output
 * @param {boolean} [premultiply=true] do premultiply it
 * @returns {Float32Array} vec4 rgba
 */
function premultiplyRgba(rgb, alpha, out, premultiply) {
    out = out || new Float32Array(4);
    if (premultiply || premultiply === undefined) {
        out[0] = rgb[0] * alpha;
        out[1] = rgb[1] * alpha;
        out[2] = rgb[2] * alpha;
    } else {
        out[0] = rgb[0];
        out[1] = rgb[1];
        out[2] = rgb[2];
    }
    out[3] = alpha;

    return out;
}

/**
 * converts integer tint and float alpha to vec4 form, premultiplies by default
 *
 * @memberof PIXI.utils
 * @param {number} tint input tint
 * @param {number} alpha alpha param
 * @param {Float32Array} [out] output
 * @param {boolean} [premultiply=true] do premultiply it
 * @returns {Float32Array} vec4 rgba
 */
function premultiplyTintToRgba(tint, alpha, out, premultiply) {
    out = out || new Float32Array(4);
    out[0] = (tint >> 16 & 0xFF) / 255.0;
    out[1] = (tint >> 8 & 0xFF) / 255.0;
    out[2] = (tint & 0xFF) / 255.0;
    if (premultiply || premultiply === undefined) {
        out[0] *= alpha;
        out[1] *= alpha;
        out[2] *= alpha;
    }
    out[3] = alpha;

    return out;
}

},{"../const":53,"../settings":108,"./mapPremultipliedBlendModes":133,"./mixin":135,"./pluginTarget":136,"earcut":23,"eventemitter3":24,"ismobilejs":25,"remove-array-items":197}],133:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.default = mapPremultipliedBlendModes;

var _const = require('../const');

/**
 * Corrects PixiJS blend, takes premultiplied alpha into account
 *
 * @memberof PIXI
 * @function mapPremultipliedBlendModes
 * @private
 * @param {Array<number[]>} [array] - The array to output into.
 * @return {Array<number[]>} Mapped modes.
 */

function mapPremultipliedBlendModes() {
    var pm = [];
    var npm = [];

    for (var i = 0; i < 32; i++) {
        pm[i] = i;
        npm[i] = i;
    }

    pm[_const.BLEND_MODES.NORMAL_NPM] = _const.BLEND_MODES.NORMAL;
    pm[_const.BLEND_MODES.ADD_NPM] = _const.BLEND_MODES.ADD;
    pm[_const.BLEND_MODES.SCREEN_NPM] = _const.BLEND_MODES.SCREEN;

    npm[_const.BLEND_MODES.NORMAL] = _const.BLEND_MODES.NORMAL_NPM;
    npm[_const.BLEND_MODES.ADD] = _const.BLEND_MODES.ADD_NPM;
    npm[_const.BLEND_MODES.SCREEN] = _const.BLEND_MODES.SCREEN_NPM;

    var array = [];

    array.push(npm);
    array.push(pm);

    return array;
}

},{"../const":53}],134:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.default = maxRecommendedTextures;

var _ismobilejs = require('ismobilejs');

var _ismobilejs2 = _interopRequireDefault(_ismobilejs);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function maxRecommendedTextures(max) {
    if (_ismobilejs2.default.tablet || _ismobilejs2.default.phone) {
        // check if the res is iphone 6 or higher..
        return 4;
    }

    // desktop should be ok
    return max;
}

},{"ismobilejs":25}],135:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.mixin = mixin;
exports.delayMixin = delayMixin;
exports.performMixins = performMixins;
/**
 * Mixes all enumerable properties and methods from a source object to a target object.
 *
 * @memberof PIXI.utils.mixins
 * @function mixin
 * @param {object} target The prototype or instance that properties and methods should be added to.
 * @param {object} source The source of properties and methods to mix in.
 */
function mixin(target, source) {
    if (!target || !source) return;
    // in ES8/ES2017, this would be really easy:
    // Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));

    // get all the enumerable property keys
    var keys = Object.keys(source);

    // loop through properties
    for (var i = 0; i < keys.length; ++i) {
        var propertyName = keys[i];

        // Set the property using the property descriptor - this works for accessors and normal value properties
        Object.defineProperty(target, propertyName, Object.getOwnPropertyDescriptor(source, propertyName));
    }
}

var mixins = [];

/**
 * Queues a mixin to be handled towards the end of the initialization of PIXI, so that deprecation
 * can take effect.
 *
 * @memberof PIXI.utils.mixins
 * @function delayMixin
 * @private
 * @param {object} target The prototype or instance that properties and methods should be added to.
 * @param {object} source The source of properties and methods to mix in.
 */
function delayMixin(target, source) {
    mixins.push(target, source);
}

/**
 * Handles all mixins queued via delayMixin().
 *
 * @memberof PIXI.utils.mixins
 * @function performMixins
 * @private
 */
function performMixins() {
    for (var i = 0; i < mixins.length; i += 2) {
        mixin(mixins[i], mixins[i + 1]);
    }
    mixins.length = 0;
}

},{}],136:[function(require,module,exports){
"use strict";

exports.__esModule = true;
/**
 * Mixins functionality to make an object have "plugins".
 *
 * @example
 *      function MyObject() {}
 *
 *      pluginTarget.mixin(MyObject);
 *
 * @mixin
 * @memberof PIXI.utils
 * @param {object} obj - The object to mix into.
 */
function pluginTarget(obj) {
    obj.__plugins = {};

    /**
     * Adds a plugin to an object
     *
     * @param {string} pluginName - The events that should be listed.
     * @param {Function} ctor - The constructor function for the plugin.
     */
    obj.registerPlugin = function registerPlugin(pluginName, ctor) {
        obj.__plugins[pluginName] = ctor;
    };

    /**
     * Instantiates all the plugins of this object
     *
     */
    obj.prototype.initPlugins = function initPlugins() {
        this.plugins = this.plugins || {};

        for (var o in obj.__plugins) {
            this.plugins[o] = new obj.__plugins[o](this);
        }
    };

    /**
     * Removes all the plugins of this object
     *
     */
    obj.prototype.destroyPlugins = function destroyPlugins() {
        for (var o in this.plugins) {
            this.plugins[o].destroy();
            this.plugins[o] = null;
        }

        this.plugins = null;
    };
}

exports.default = {
    /**
     * Mixes in the properties of the pluginTarget into another object
     *
     * @param {object} obj - The obj to mix into
     */
    mixin: function mixin(obj) {
        pluginTarget(obj);
    }
};

},{}],137:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.default = trimCanvas;
/**
 * Trim transparent borders from a canvas
 *
 * @memberof PIXI
 * @function trimCanvas
 * @private
 * @param {HTMLCanvasElement} canvas - the canvas to trim
 * @returns {object} Trim data
 */
function trimCanvas(canvas) {
    // https://gist.github.com/remy/784508

    var width = canvas.width;
    var height = canvas.height;

    var context = canvas.getContext('2d');
    var imageData = context.getImageData(0, 0, width, height);
    var pixels = imageData.data;
    var len = pixels.length;

    var bound = {
        top: null,
        left: null,
        right: null,
        bottom: null
    };
    var data = null;
    var i = void 0;
    var x = void 0;
    var y = void 0;

    for (i = 0; i < len; i += 4) {
        if (pixels[i + 3] !== 0) {
            x = i / 4 % width;
            y = ~~(i / 4 / width);

            if (bound.top === null) {
                bound.top = y;
            }

            if (bound.left === null) {
                bound.left = x;
            } else if (x < bound.left) {
                bound.left = x;
            }

            if (bound.right === null) {
                bound.right = x + 1;
            } else if (bound.right < x) {
                bound.right = x + 1;
            }

            if (bound.bottom === null) {
                bound.bottom = y;
            } else if (bound.bottom < y) {
                bound.bottom = y;
            }
        }
    }

    if (bound.top !== null) {
        width = bound.right - bound.left;
        height = bound.bottom - bound.top + 1;
        data = context.getImageData(bound.left, bound.top, width, height);
    }

    return {
        height: height,
        width: width,
        data: data
    };
}

},{}],138:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.default = deprecation;
// provide method to give a stack track for warnings
// useful for tracking-down where deprecated methods/properties/classes
// are being used within the code

// A map of warning messages already fired
var warnings = {};

// provide method to give a stack track for warnings
// useful for tracking-down where deprecated methods/properties/classes
// are being used within the code
function warn(msg) {
    // Ignore duplicat
    if (warnings[msg]) {
        return;
    }

    /* eslint-disable no-console */
    var stack = new Error().stack;

    // Handle IE < 10 and Safari < 6
    if (typeof stack === 'undefined') {
        console.warn('Deprecation Warning: ', msg);
    } else {
        // chop off the stack trace which includes pixi.js internal calls
        stack = stack.split('\n').splice(3).join('\n');

        if (console.groupCollapsed) {
            console.groupCollapsed('%cDeprecation Warning: %c%s', 'color:#614108;background:#fffbe6', 'font-weight:normal;color:#614108;background:#fffbe6', msg);
            console.warn(stack);
            console.groupEnd();
        } else {
            console.warn('Deprecation Warning: ', msg);
            console.warn(stack);
        }
    }
    /* eslint-enable no-console */

    warnings[msg] = true;
}

function deprecation(core) {
    var mesh = core.mesh,
        particles = core.particles,
        extras = core.extras,
        filters = core.filters,
        prepare = core.prepare,
        loaders = core.loaders,
        interaction = core.interaction;


    Object.defineProperties(core, {

        /**
         * @class
         * @private
         * @name SpriteBatch
         * @memberof PIXI
         * @see PIXI.ParticleContainer
         * @throws {ReferenceError} SpriteBatch does not exist any more, please use the new ParticleContainer instead.
         * @deprecated since version 3.0.0
         */
        SpriteBatch: {
            get: function get() {
                throw new ReferenceError('SpriteBatch does not exist any more, ' + 'please use the new ParticleContainer instead.');
            }
        },

        /**
         * @class
         * @private
         * @name AssetLoader
         * @memberof PIXI
         * @see PIXI.loaders.Loader
         * @throws {ReferenceError} The loader system was overhauled in PixiJS v3,
         * please see the new PIXI.loaders.Loader class.
         * @deprecated since version 3.0.0
         */
        AssetLoader: {
            get: function get() {
                throw new ReferenceError('The loader system was overhauled in PixiJS v3, ' + 'please see the new PIXI.loaders.Loader class.');
            }
        },

        /**
         * @class
         * @private
         * @name Stage
         * @memberof PIXI
         * @see PIXI.Container
         * @deprecated since version 3.0.0
         */
        Stage: {
            get: function get() {
                warn('You do not need to use a PIXI Stage any more, you can simply render any container.');

                return core.Container;
            }
        },

        /**
         * @class
         * @private
         * @name DisplayObjectContainer
         * @memberof PIXI
         * @see PIXI.Container
         * @deprecated since version 3.0.0
         */
        DisplayObjectContainer: {
            get: function get() {
                warn('DisplayObjectContainer has been shortened to Container, please use Container from now on.');

                return core.Container;
            }
        },

        /**
         * @class
         * @private
         * @name Strip
         * @memberof PIXI
         * @see PIXI.mesh.Mesh
         * @deprecated since version 3.0.0
         */
        Strip: {
            get: function get() {
                warn('The Strip class has been renamed to Mesh and moved to mesh.Mesh, please use mesh.Mesh from now on.');

                return mesh.Mesh;
            }
        },

        /**
         * @class
         * @private
         * @name Rope
         * @memberof PIXI
         * @see PIXI.mesh.Rope
         * @deprecated since version 3.0.0
         */
        Rope: {
            get: function get() {
                warn('The Rope class has been moved to mesh.Rope, please use mesh.Rope from now on.');

                return mesh.Rope;
            }
        },

        /**
         * @class
         * @private
         * @name ParticleContainer
         * @memberof PIXI
         * @see PIXI.particles.ParticleContainer
         * @deprecated since version 4.0.0
         */
        ParticleContainer: {
            get: function get() {
                warn('The ParticleContainer class has been moved to particles.ParticleContainer, ' + 'please use particles.ParticleContainer from now on.');

                return particles.ParticleContainer;
            }
        },

        /**
         * @class
         * @private
         * @name MovieClip
         * @memberof PIXI
         * @see PIXI.extras.MovieClip
         * @deprecated since version 3.0.0
         */
        MovieClip: {
            get: function get() {
                warn('The MovieClip class has been moved to extras.AnimatedSprite, please use extras.AnimatedSprite.');

                return extras.AnimatedSprite;
            }
        },

        /**
         * @class
         * @private
         * @name TilingSprite
         * @memberof PIXI
         * @see PIXI.extras.TilingSprite
         * @deprecated since version 3.0.0
         */
        TilingSprite: {
            get: function get() {
                warn('The TilingSprite class has been moved to extras.TilingSprite, ' + 'please use extras.TilingSprite from now on.');

                return extras.TilingSprite;
            }
        },

        /**
         * @class
         * @private
         * @name BitmapText
         * @memberof PIXI
         * @see PIXI.extras.BitmapText
         * @deprecated since version 3.0.0
         */
        BitmapText: {
            get: function get() {
                warn('The BitmapText class has been moved to extras.BitmapText, ' + 'please use extras.BitmapText from now on.');

                return extras.BitmapText;
            }
        },

        /**
         * @class
         * @private
         * @name blendModes
         * @memberof PIXI
         * @see PIXI.BLEND_MODES
         * @deprecated since version 3.0.0
         */
        blendModes: {
            get: function get() {
                warn('The blendModes has been moved to BLEND_MODES, please use BLEND_MODES from now on.');

                return core.BLEND_MODES;
            }
        },

        /**
         * @class
         * @private
         * @name scaleModes
         * @memberof PIXI
         * @see PIXI.SCALE_MODES
         * @deprecated since version 3.0.0
         */
        scaleModes: {
            get: function get() {
                warn('The scaleModes has been moved to SCALE_MODES, please use SCALE_MODES from now on.');

                return core.SCALE_MODES;
            }
        },

        /**
         * @class
         * @private
         * @name BaseTextureCache
         * @memberof PIXI
         * @see PIXI.utils.BaseTextureCache
         * @deprecated since version 3.0.0
         */
        BaseTextureCache: {
            get: function get() {
                warn('The BaseTextureCache class has been moved to utils.BaseTextureCache, ' + 'please use utils.BaseTextureCache from now on.');

                return core.utils.BaseTextureCache;
            }
        },

        /**
         * @class
         * @private
         * @name TextureCache
         * @memberof PIXI
         * @see PIXI.utils.TextureCache
         * @deprecated since version 3.0.0
         */
        TextureCache: {
            get: function get() {
                warn('The TextureCache class has been moved to utils.TextureCache, ' + 'please use utils.TextureCache from now on.');

                return core.utils.TextureCache;
            }
        },

        /**
         * @namespace
         * @private
         * @name math
         * @memberof PIXI
         * @see PIXI
         * @deprecated since version 3.0.6
         */
        math: {
            get: function get() {
                warn('The math namespace is deprecated, please access members already accessible on PIXI.');

                return core;
            }
        },

        /**
         * @class
         * @private
         * @name PIXI.AbstractFilter
         * @see PIXI.Filter
         * @deprecated since version 3.0.6
         */
        AbstractFilter: {
            get: function get() {
                warn('AstractFilter has been renamed to Filter, please use PIXI.Filter');

                return core.Filter;
            }
        },

        /**
         * @class
         * @private
         * @name PIXI.TransformManual
         * @see PIXI.TransformBase
         * @deprecated since version 4.0.0
         */
        TransformManual: {
            get: function get() {
                warn('TransformManual has been renamed to TransformBase, please update your pixi-spine');

                return core.TransformBase;
            }
        },

        /**
         * @static
         * @constant
         * @name PIXI.TARGET_FPMS
         * @see PIXI.settings.TARGET_FPMS
         * @deprecated since version 4.2.0
         */
        TARGET_FPMS: {
            get: function get() {
                warn('PIXI.TARGET_FPMS has been deprecated, please use PIXI.settings.TARGET_FPMS');

                return core.settings.TARGET_FPMS;
            },
            set: function set(value) {
                warn('PIXI.TARGET_FPMS has been deprecated, please use PIXI.settings.TARGET_FPMS');

                core.settings.TARGET_FPMS = value;
            }
        },

        /**
         * @static
         * @constant
         * @name PIXI.FILTER_RESOLUTION
         * @see PIXI.settings.FILTER_RESOLUTION
         * @deprecated since version 4.2.0
         */
        FILTER_RESOLUTION: {
            get: function get() {
                warn('PIXI.FILTER_RESOLUTION has been deprecated, please use PIXI.settings.FILTER_RESOLUTION');

                return core.settings.FILTER_RESOLUTION;
            },
            set: function set(value) {
                warn('PIXI.FILTER_RESOLUTION has been deprecated, please use PIXI.settings.FILTER_RESOLUTION');

                core.settings.FILTER_RESOLUTION = value;
            }
        },

        /**
         * @static
         * @constant
         * @name PIXI.RESOLUTION
         * @see PIXI.settings.RESOLUTION
         * @deprecated since version 4.2.0
         */
        RESOLUTION: {
            get: function get() {
                warn('PIXI.RESOLUTION has been deprecated, please use PIXI.settings.RESOLUTION');

                return core.settings.RESOLUTION;
            },
            set: function set(value) {
                warn('PIXI.RESOLUTION has been deprecated, please use PIXI.settings.RESOLUTION');

                core.settings.RESOLUTION = value;
            }
        },

        /**
         * @static
         * @constant
         * @name PIXI.MIPMAP_TEXTURES
         * @see PIXI.settings.MIPMAP_TEXTURES
         * @deprecated since version 4.2.0
         */
        MIPMAP_TEXTURES: {
            get: function get() {
                warn('PIXI.MIPMAP_TEXTURES has been deprecated, please use PIXI.settings.MIPMAP_TEXTURES');

                return core.settings.MIPMAP_TEXTURES;
            },
            set: function set(value) {
                warn('PIXI.MIPMAP_TEXTURES has been deprecated, please use PIXI.settings.MIPMAP_TEXTURES');

                core.settings.MIPMAP_TEXTURES = value;
            }
        },

        /**
         * @static
         * @constant
         * @name PIXI.SPRITE_BATCH_SIZE
         * @see PIXI.settings.SPRITE_BATCH_SIZE
         * @deprecated since version 4.2.0
         */
        SPRITE_BATCH_SIZE: {
            get: function get() {
                warn('PIXI.SPRITE_BATCH_SIZE has been deprecated, please use PIXI.settings.SPRITE_BATCH_SIZE');

                return core.settings.SPRITE_BATCH_SIZE;
            },
            set: function set(value) {
                warn('PIXI.SPRITE_BATCH_SIZE has been deprecated, please use PIXI.settings.SPRITE_BATCH_SIZE');

                core.settings.SPRITE_BATCH_SIZE = value;
            }
        },

        /**
         * @static
         * @constant
         * @name PIXI.SPRITE_MAX_TEXTURES
         * @see PIXI.settings.SPRITE_MAX_TEXTURES
         * @deprecated since version 4.2.0
         */
        SPRITE_MAX_TEXTURES: {
            get: function get() {
                warn('PIXI.SPRITE_MAX_TEXTURES has been deprecated, please use PIXI.settings.SPRITE_MAX_TEXTURES');

                return core.settings.SPRITE_MAX_TEXTURES;
            },
            set: function set(value) {
                warn('PIXI.SPRITE_MAX_TEXTURES has been deprecated, please use PIXI.settings.SPRITE_MAX_TEXTURES');

                core.settings.SPRITE_MAX_TEXTURES = value;
            }
        },

        /**
         * @static
         * @constant
         * @name PIXI.RETINA_PREFIX
         * @see PIXI.settings.RETINA_PREFIX
         * @deprecated since version 4.2.0
         */
        RETINA_PREFIX: {
            get: function get() {
                warn('PIXI.RETINA_PREFIX has been deprecated, please use PIXI.settings.RETINA_PREFIX');

                return core.settings.RETINA_PREFIX;
            },
            set: function set(value) {
                warn('PIXI.RETINA_PREFIX has been deprecated, please use PIXI.settings.RETINA_PREFIX');

                core.settings.RETINA_PREFIX = value;
            }
        },

        /**
         * @static
         * @constant
         * @name PIXI.DEFAULT_RENDER_OPTIONS
         * @see PIXI.settings.RENDER_OPTIONS
         * @deprecated since version 4.2.0
         */
        DEFAULT_RENDER_OPTIONS: {
            get: function get() {
                warn('PIXI.DEFAULT_RENDER_OPTIONS has been deprecated, please use PIXI.settings.DEFAULT_RENDER_OPTIONS');

                return core.settings.RENDER_OPTIONS;
            }
        }
    });

    // Move the default properties to settings
    var defaults = [{ parent: 'TRANSFORM_MODE', target: 'TRANSFORM_MODE' }, { parent: 'GC_MODES', target: 'GC_MODE' }, { parent: 'WRAP_MODES', target: 'WRAP_MODE' }, { parent: 'SCALE_MODES', target: 'SCALE_MODE' }, { parent: 'PRECISION', target: 'PRECISION_FRAGMENT' }];

    var _loop = function _loop(i) {
        var deprecation = defaults[i];

        Object.defineProperty(core[deprecation.parent], 'DEFAULT', {
            get: function get() {
                warn('PIXI.' + deprecation.parent + '.DEFAULT has been deprecated, ' + ('please use PIXI.settings.' + deprecation.target));

                return core.settings[deprecation.target];
            },
            set: function set(value) {
                warn('PIXI.' + deprecation.parent + '.DEFAULT has been deprecated, ' + ('please use PIXI.settings.' + deprecation.target));

                core.settings[deprecation.target] = value;
            }
        });
    };

    for (var i = 0; i < defaults.length; i++) {
        _loop(i);
    }

    Object.defineProperties(core.settings, {

        /**
         * @static
         * @name PRECISION
         * @memberof PIXI.settings
         * @see PIXI.PRECISION
         * @deprecated since version 4.4.0
         */
        PRECISION: {
            get: function get() {
                warn('PIXI.settings.PRECISION has been deprecated, please use PIXI.settings.PRECISION_FRAGMENT');

                return core.settings.PRECISION_FRAGMENT;
            },
            set: function set(value) {
                warn('PIXI.settings.PRECISION has been deprecated, please use PIXI.settings.PRECISION_FRAGMENT');

                core.settings.PRECISION_FRAGMENT = value;
            }
        }
    });

    if (extras.AnimatedSprite) {
        Object.defineProperties(extras, {

            /**
             * @class
             * @name MovieClip
             * @memberof PIXI.extras
             * @see PIXI.extras.AnimatedSprite
             * @deprecated since version 4.2.0
             */
            MovieClip: {
                get: function get() {
                    warn('The MovieClip class has been renamed to AnimatedSprite, please use AnimatedSprite from now on.');

                    return extras.AnimatedSprite;
                }
            }
        });
    }

    if (extras) {
        Object.defineProperties(extras, {
            /**
             * @class
             * @name TextureTransform
             * @memberof PIXI.extras
             * @see PIXI.TextureMatrix
             * @deprecated since version 4.6.0
             */
            TextureTransform: {
                get: function get() {
                    warn('The TextureTransform class has been renamed to TextureMatrix, ' + 'please use PIXI.TextureMatrix from now on.');

                    return core.TextureMatrix;
                }
            }
        });
    }

    core.DisplayObject.prototype.generateTexture = function generateTexture(renderer, scaleMode, resolution) {
        warn('generateTexture has moved to the renderer, please use renderer.generateTexture(displayObject)');

        return renderer.generateTexture(this, scaleMode, resolution);
    };

    core.Graphics.prototype.generateTexture = function generateTexture(scaleMode, resolution) {
        warn('graphics generate texture has moved to the renderer. ' + 'Or to render a graphics to a texture using canvas please use generateCanvasTexture');

        return this.generateCanvasTexture(scaleMode, resolution);
    };

    /**
     * @method
     * @name PIXI.GroupD8.isSwapWidthHeight
     * @see PIXI.GroupD8.isVertical
     * @param {number} rotation - The number to check.
     * @returns {boolean} Whether or not the direction is vertical
     * @deprecated since version 4.6.0
     */
    core.GroupD8.isSwapWidthHeight = function isSwapWidthHeight(rotation) {
        warn('GroupD8.isSwapWidthHeight was renamed to GroupD8.isVertical');

        return core.GroupD8.isVertical(rotation);
    };

    core.RenderTexture.prototype.render = function render(displayObject, matrix, clear, updateTransform) {
        this.legacyRenderer.render(displayObject, this, clear, matrix, !updateTransform);
        warn('RenderTexture.render is now deprecated, please use renderer.render(displayObject, renderTexture)');
    };

    core.RenderTexture.prototype.getImage = function getImage(target) {
        warn('RenderTexture.getImage is now deprecated, please use renderer.extract.image(target)');

        return this.legacyRenderer.extract.image(target);
    };

    core.RenderTexture.prototype.getBase64 = function getBase64(target) {
        warn('RenderTexture.getBase64 is now deprecated, please use renderer.extract.base64(target)');

        return this.legacyRenderer.extract.base64(target);
    };

    core.RenderTexture.prototype.getCanvas = function getCanvas(target) {
        warn('RenderTexture.getCanvas is now deprecated, please use renderer.extract.canvas(target)');

        return this.legacyRenderer.extract.canvas(target);
    };

    core.RenderTexture.prototype.getPixels = function getPixels(target) {
        warn('RenderTexture.getPixels is now deprecated, please use renderer.extract.pixels(target)');

        return this.legacyRenderer.pixels(target);
    };

    /**
     * @method
     * @private
     * @name PIXI.Sprite#setTexture
     * @see PIXI.Sprite#texture
     * @deprecated since version 3.0.0
     * @param {PIXI.Texture} texture - The texture to set to.
     */
    core.Sprite.prototype.setTexture = function setTexture(texture) {
        this.texture = texture;
        warn('setTexture is now deprecated, please use the texture property, e.g : sprite.texture = texture;');
    };

    if (extras.BitmapText) {
        /**
         * @method
         * @name PIXI.extras.BitmapText#setText
         * @see PIXI.extras.BitmapText#text
         * @deprecated since version 3.0.0
         * @param {string} text - The text to set to.
         */
        extras.BitmapText.prototype.setText = function setText(text) {
            this.text = text;
            warn('setText is now deprecated, please use the text property, e.g : myBitmapText.text = \'my text\';');
        };
    }

    /**
     * @method
     * @name PIXI.Text#setText
     * @see PIXI.Text#text
     * @deprecated since version 3.0.0
     * @param {string} text - The text to set to.
     */
    core.Text.prototype.setText = function setText(text) {
        this.text = text;
        warn('setText is now deprecated, please use the text property, e.g : myText.text = \'my text\';');
    };

    /**
     * Calculates the ascent, descent and fontSize of a given fontStyle
     *
     * @name PIXI.Text.calculateFontProperties
     * @see PIXI.TextMetrics.measureFont
     * @deprecated since version 4.5.0
     * @param {string} font - String representing the style of the font
     * @return {Object} Font properties object
     */
    core.Text.calculateFontProperties = function calculateFontProperties(font) {
        warn('Text.calculateFontProperties is now deprecated, please use the TextMetrics.measureFont');

        return core.TextMetrics.measureFont(font);
    };

    Object.defineProperties(core.Text, {
        fontPropertiesCache: {
            get: function get() {
                warn('Text.fontPropertiesCache is deprecated');

                return core.TextMetrics._fonts;
            }
        },
        fontPropertiesCanvas: {
            get: function get() {
                warn('Text.fontPropertiesCanvas is deprecated');

                return core.TextMetrics._canvas;
            }
        },
        fontPropertiesContext: {
            get: function get() {
                warn('Text.fontPropertiesContext is deprecated');

                return core.TextMetrics._context;
            }
        }
    });

    /**
     * @method
     * @name PIXI.Text#setStyle
     * @see PIXI.Text#style
     * @deprecated since version 3.0.0
     * @param {*} style - The style to set to.
     */
    core.Text.prototype.setStyle = function setStyle(style) {
        this.style = style;
        warn('setStyle is now deprecated, please use the style property, e.g : myText.style = style;');
    };

    /**
     * @method
     * @name PIXI.Text#determineFontProperties
     * @see PIXI.Text#measureFontProperties
     * @deprecated since version 4.2.0
     * @private
     * @param {string} fontStyle - String representing the style of the font
     * @return {Object} Font properties object
     */
    core.Text.prototype.determineFontProperties = function determineFontProperties(fontStyle) {
        warn('determineFontProperties is now deprecated, please use TextMetrics.measureFont method');

        return core.TextMetrics.measureFont(fontStyle);
    };

    /**
     * @method
     * @name PIXI.Text.getFontStyle
     * @see PIXI.TextMetrics.getFontStyle
     * @deprecated since version 4.5.0
     * @param {PIXI.TextStyle} style - The style to use.
     * @return {string} Font string
     */
    core.Text.getFontStyle = function getFontStyle(style) {
        warn('getFontStyle is now deprecated, please use TextStyle.toFontString() instead');

        style = style || {};

        if (!(style instanceof core.TextStyle)) {
            style = new core.TextStyle(style);
        }

        return style.toFontString();
    };

    Object.defineProperties(core.TextStyle.prototype, {
        /**
         * Set all properties of a font as a single string
         *
         * @name PIXI.TextStyle#font
         * @deprecated since version 4.0.0
         */
        font: {
            get: function get() {
                warn('text style property \'font\' is now deprecated, please use the ' + '\'fontFamily\', \'fontSize\', \'fontStyle\', \'fontVariant\' and \'fontWeight\' properties from now on');

                var fontSizeString = typeof this._fontSize === 'number' ? this._fontSize + 'px' : this._fontSize;

                return this._fontStyle + ' ' + this._fontVariant + ' ' + this._fontWeight + ' ' + fontSizeString + ' ' + this._fontFamily;
            },
            set: function set(font) {
                warn('text style property \'font\' is now deprecated, please use the ' + '\'fontFamily\',\'fontSize\',fontStyle\',\'fontVariant\' and \'fontWeight\' properties from now on');

                // can work out fontStyle from search of whole string
                if (font.indexOf('italic') > 1) {
                    this._fontStyle = 'italic';
                } else if (font.indexOf('oblique') > -1) {
                    this._fontStyle = 'oblique';
                } else {
                    this._fontStyle = 'normal';
                }

                // can work out fontVariant from search of whole string
                if (font.indexOf('small-caps') > -1) {
                    this._fontVariant = 'small-caps';
                } else {
                    this._fontVariant = 'normal';
                }

                // fontWeight and fontFamily are tricker to find, but it's easier to find the fontSize due to it's units
                var splits = font.split(' ');
                var fontSizeIndex = -1;

                this._fontSize = 26;
                for (var i = 0; i < splits.length; ++i) {
                    if (splits[i].match(/(px|pt|em|%)/)) {
                        fontSizeIndex = i;
                        this._fontSize = splits[i];
                        break;
                    }
                }

                // we can now search for fontWeight as we know it must occur before the fontSize
                this._fontWeight = 'normal';
                for (var _i = 0; _i < fontSizeIndex; ++_i) {
                    if (splits[_i].match(/(bold|bolder|lighter|100|200|300|400|500|600|700|800|900)/)) {
                        this._fontWeight = splits[_i];
                        break;
                    }
                }

                // and finally join everything together after the fontSize in case the font family has multiple words
                if (fontSizeIndex > -1 && fontSizeIndex < splits.length - 1) {
                    this._fontFamily = '';
                    for (var _i2 = fontSizeIndex + 1; _i2 < splits.length; ++_i2) {
                        this._fontFamily += splits[_i2] + ' ';
                    }

                    this._fontFamily = this._fontFamily.slice(0, -1);
                } else {
                    this._fontFamily = 'Arial';
                }

                this.styleID++;
            }
        }
    });

    /**
     * @method
     * @name PIXI.Texture#setFrame
     * @see PIXI.Texture#setFrame
     * @deprecated since version 3.0.0
     * @param {PIXI.Rectangle} frame - The frame to set.
     */
    core.Texture.prototype.setFrame = function setFrame(frame) {
        this.frame = frame;
        warn('setFrame is now deprecated, please use the frame property, e.g: myTexture.frame = frame;');
    };

    /**
     * @static
     * @function
     * @name PIXI.Texture.addTextureToCache
     * @see PIXI.Texture.addToCache
     * @deprecated since 4.5.0
     * @param {PIXI.Texture} texture - The Texture to add to the cache.
     * @param {string} id - The id that the texture will be stored against.
     */
    core.Texture.addTextureToCache = function addTextureToCache(texture, id) {
        core.Texture.addToCache(texture, id);
        warn('Texture.addTextureToCache is deprecated, please use Texture.addToCache from now on.');
    };

    /**
     * @static
     * @function
     * @name PIXI.Texture.removeTextureFromCache
     * @see PIXI.Texture.removeFromCache
     * @deprecated since 4.5.0
     * @param {string} id - The id of the texture to be removed
     * @return {PIXI.Texture|null} The texture that was removed
     */
    core.Texture.removeTextureFromCache = function removeTextureFromCache(id) {
        warn('Texture.removeTextureFromCache is deprecated, please use Texture.removeFromCache from now on. ' + 'Be aware that Texture.removeFromCache does not automatically its BaseTexture from the BaseTextureCache. ' + 'For that, use BaseTexture.removeFromCache');

        core.BaseTexture.removeFromCache(id);

        return core.Texture.removeFromCache(id);
    };

    Object.defineProperties(filters, {

        /**
         * @class
         * @private
         * @name PIXI.filters.AbstractFilter
         * @see PIXI.AbstractFilter
         * @deprecated since version 3.0.6
         */
        AbstractFilter: {
            get: function get() {
                warn('AstractFilter has been renamed to Filter, please use PIXI.Filter');

                return core.AbstractFilter;
            }
        },

        /**
         * @class
         * @private
         * @name PIXI.filters.SpriteMaskFilter
         * @see PIXI.SpriteMaskFilter
         * @deprecated since version 3.0.6
         */
        SpriteMaskFilter: {
            get: function get() {
                warn('filters.SpriteMaskFilter is an undocumented alias, please use SpriteMaskFilter from now on.');

                return core.SpriteMaskFilter;
            }
        },

        /**
         * @class
         * @private
         * @name PIXI.filters.VoidFilter
         * @see PIXI.filters.AlphaFilter
         * @deprecated since version 4.5.7
         */
        VoidFilter: {
            get: function get() {
                warn('VoidFilter has been renamed to AlphaFilter, please use PIXI.filters.AlphaFilter');

                return filters.AlphaFilter;
            }
        }
    });

    /**
     * @method
     * @name PIXI.utils.uuid
     * @see PIXI.utils.uid
     * @deprecated since version 3.0.6
     * @return {number} The uid
     */
    core.utils.uuid = function () {
        warn('utils.uuid() is deprecated, please use utils.uid() from now on.');

        return core.utils.uid();
    };

    /**
     * @method
     * @name PIXI.utils.canUseNewCanvasBlendModes
     * @see PIXI.CanvasTinter
     * @deprecated
     * @return {boolean} Can use blend modes.
     */
    core.utils.canUseNewCanvasBlendModes = function () {
        warn('utils.canUseNewCanvasBlendModes() is deprecated, please use CanvasTinter.canUseMultiply from now on');

        return core.CanvasTinter.canUseMultiply;
    };

    var saidHello = true;

    /**
     * @name PIXI.utils._saidHello
     * @type {boolean}
     * @see PIXI.utils.skipHello
     * @deprecated since 4.1.0
     */
    Object.defineProperty(core.utils, '_saidHello', {
        set: function set(bool) {
            if (bool) {
                warn('PIXI.utils._saidHello is deprecated, please use PIXI.utils.skipHello()');
                this.skipHello();
            }
            saidHello = bool;
        },
        get: function get() {
            return saidHello;
        }
    });

    if (prepare.BasePrepare) {
        /**
         * @method
         * @name PIXI.prepare.BasePrepare#register
         * @see PIXI.prepare.BasePrepare#registerFindHook
         * @deprecated since version 4.4.2
         * @param {Function} [addHook] - Function call that takes two parameters: `item:*, queue:Array`
         *        function must return `true` if it was able to add item to the queue.
         * @param {Function} [uploadHook] - Function call that takes two parameters: `prepare:CanvasPrepare, item:*` and
         *        function must return `true` if it was able to handle upload of item.
         * @return {PIXI.BasePrepare} Instance of plugin for chaining.
         */
        prepare.BasePrepare.prototype.register = function register(addHook, uploadHook) {
            warn('renderer.plugins.prepare.register is now deprecated, ' + 'please use renderer.plugins.prepare.registerFindHook & renderer.plugins.prepare.registerUploadHook');

            if (addHook) {
                this.registerFindHook(addHook);
            }

            if (uploadHook) {
                this.registerUploadHook(uploadHook);
            }

            return this;
        };
    }

    if (prepare.canvas) {
        /**
         * The number of graphics or textures to upload to the GPU.
         *
         * @name PIXI.prepare.canvas.UPLOADS_PER_FRAME
         * @static
         * @type {number}
         * @see PIXI.prepare.BasePrepare.limiter
         * @deprecated since 4.2.0
         */
        Object.defineProperty(prepare.canvas, 'UPLOADS_PER_FRAME', {
            set: function set() {
                warn('PIXI.CanvasPrepare.UPLOADS_PER_FRAME has been removed. Please set ' + 'renderer.plugins.prepare.limiter.maxItemsPerFrame on your renderer');
                // because we don't have a reference to the renderer, we can't actually set
                // the uploads per frame, so we'll have to stick with the warning.
            },
            get: function get() {
                warn('PIXI.CanvasPrepare.UPLOADS_PER_FRAME has been removed. Please use ' + 'renderer.plugins.prepare.limiter');

                return NaN;
            }
        });
    }

    if (prepare.webgl) {
        /**
         * The number of graphics or textures to upload to the GPU.
         *
         * @name PIXI.prepare.webgl.UPLOADS_PER_FRAME
         * @static
         * @type {number}
         * @see PIXI.prepare.BasePrepare.limiter
         * @deprecated since 4.2.0
         */
        Object.defineProperty(prepare.webgl, 'UPLOADS_PER_FRAME', {
            set: function set() {
                warn('PIXI.WebGLPrepare.UPLOADS_PER_FRAME has been removed. Please set ' + 'renderer.plugins.prepare.limiter.maxItemsPerFrame on your renderer');
                // because we don't have a reference to the renderer, we can't actually set
                // the uploads per frame, so we'll have to stick with the warning.
            },
            get: function get() {
                warn('PIXI.WebGLPrepare.UPLOADS_PER_FRAME has been removed. Please use ' + 'renderer.plugins.prepare.limiter');

                return NaN;
            }
        });
    }

    if (loaders.Loader) {
        var Resource = loaders.Resource;
        var Loader = loaders.Loader;

        Object.defineProperties(Resource.prototype, {
            isJson: {
                get: function get() {
                    warn('The isJson property is deprecated, please use `resource.type === Resource.TYPE.JSON`.');

                    return this.type === Resource.TYPE.JSON;
                }
            },
            isXml: {
                get: function get() {
                    warn('The isXml property is deprecated, please use `resource.type === Resource.TYPE.XML`.');

                    return this.type === Resource.TYPE.XML;
                }
            },
            isImage: {
                get: function get() {
                    warn('The isImage property is deprecated, please use `resource.type === Resource.TYPE.IMAGE`.');

                    return this.type === Resource.TYPE.IMAGE;
                }
            },
            isAudio: {
                get: function get() {
                    warn('The isAudio property is deprecated, please use `resource.type === Resource.TYPE.AUDIO`.');

                    return this.type === Resource.TYPE.AUDIO;
                }
            },
            isVideo: {
                get: function get() {
                    warn('The isVideo property is deprecated, please use `resource.type === Resource.TYPE.VIDEO`.');

                    return this.type === Resource.TYPE.VIDEO;
                }
            }
        });

        Object.defineProperties(Loader.prototype, {
            before: {
                get: function get() {
                    warn('The before() method is deprecated, please use pre().');

                    return this.pre;
                }
            },
            after: {
                get: function get() {
                    warn('The after() method is deprecated, please use use().');

                    return this.use;
                }
            }
        });
    }

    if (interaction.interactiveTarget) {
        /**
         * @name PIXI.interaction.interactiveTarget#defaultCursor
         * @static
         * @type {number}
         * @see PIXI.interaction.interactiveTarget#cursor
         * @deprecated since 4.3.0
         */
        Object.defineProperty(interaction.interactiveTarget, 'defaultCursor', {
            set: function set(value) {
                warn('Property defaultCursor has been replaced with \'cursor\'. ');
                this.cursor = value;
            },
            get: function get() {
                warn('Property defaultCursor has been replaced with \'cursor\'. ');

                return this.cursor;
            }
        });
    }

    if (interaction.InteractionManager) {
        /**
         * @name PIXI.interaction.InteractionManager#defaultCursorStyle
         * @static
         * @type {string}
         * @see PIXI.interaction.InteractionManager#cursorStyles
         * @deprecated since 4.3.0
         */
        Object.defineProperty(interaction.InteractionManager, 'defaultCursorStyle', {
            set: function set(value) {
                warn('Property defaultCursorStyle has been replaced with \'cursorStyles.default\'. ');
                this.cursorStyles.default = value;
            },
            get: function get() {
                warn('Property defaultCursorStyle has been replaced with \'cursorStyles.default\'. ');

                return this.cursorStyles.default;
            }
        });

        /**
         * @name PIXI.interaction.InteractionManager#currentCursorStyle
         * @static
         * @type {string}
         * @see PIXI.interaction.InteractionManager#cursorStyles
         * @deprecated since 4.3.0
         */
        Object.defineProperty(interaction.InteractionManager, 'currentCursorStyle', {
            set: function set(value) {
                warn('Property currentCursorStyle has been removed.' + 'See the currentCursorMode property, which works differently.');
                this.currentCursorMode = value;
            },
            get: function get() {
                warn('Property currentCursorStyle has been removed.' + 'See the currentCursorMode property, which works differently.');

                return this.currentCursorMode;
            }
        });
    }
}

},{}],139:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _core = require('../../core');

var core = _interopRequireWildcard(_core);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var TEMP_RECT = new core.Rectangle();

/**
 * The extract manager provides functionality to export content from the renderers.
 *
 * An instance of this class is automatically created by default, and can be found at renderer.plugins.extract
 *
 * @class
 * @memberof PIXI.extract
 */

var CanvasExtract = function () {
    /**
     * @param {PIXI.CanvasRenderer} renderer - A reference to the current renderer
     */
    function CanvasExtract(renderer) {
        _classCallCheck(this, CanvasExtract);

        this.renderer = renderer;
        /**
         * Collection of methods for extracting data (image, pixels, etc.) from a display object or render texture
         *
         * @member {PIXI.extract.CanvasExtract} extract
         * @memberof PIXI.CanvasRenderer#
         * @see PIXI.extract.CanvasExtract
         */
        renderer.extract = this;
    }

    /**
     * Will return a HTML Image of the target
     *
     * @param {PIXI.DisplayObject|PIXI.RenderTexture} target - A displayObject or renderTexture
     *  to convert. If left empty will use use the main renderer
     * @return {HTMLImageElement} HTML Image of the target
     */


    CanvasExtract.prototype.image = function image(target) {
        var image = new Image();

        image.src = this.base64(target);

        return image;
    };

    /**
     * Will return a a base64 encoded string of this target. It works by calling
     *  `CanvasExtract.getCanvas` and then running toDataURL on that.
     *
     * @param {PIXI.DisplayObject|PIXI.RenderTexture} target - A displayObject or renderTexture
     *  to convert. If left empty will use use the main renderer
     * @return {string} A base64 encoded string of the texture.
     */


    CanvasExtract.prototype.base64 = function base64(target) {
        return this.canvas(target).toDataURL();
    };

    /**
     * Creates a Canvas element, renders this target to it and then returns it.
     *
     * @param {PIXI.DisplayObject|PIXI.RenderTexture} target - A displayObject or renderTexture
     *  to convert. If left empty will use use the main renderer
     * @return {HTMLCanvasElement} A Canvas element with the texture rendered on.
     */


    CanvasExtract.prototype.canvas = function canvas(target) {
        var renderer = this.renderer;
        var context = void 0;
        var resolution = void 0;
        var frame = void 0;
        var renderTexture = void 0;

        if (target) {
            if (target instanceof core.RenderTexture) {
                renderTexture = target;
            } else {
                renderTexture = renderer.generateTexture(target);
            }
        }

        if (renderTexture) {
            context = renderTexture.baseTexture._canvasRenderTarget.context;
            resolution = renderTexture.baseTexture._canvasRenderTarget.resolution;
            frame = renderTexture.frame;
        } else {
            context = renderer.rootContext;
            resolution = renderer.resolution;
            frame = TEMP_RECT;
            frame.width = this.renderer.width;
            frame.height = this.renderer.height;
        }

        var width = frame.width * resolution;
        var height = frame.height * resolution;

        var canvasBuffer = new core.CanvasRenderTarget(width, height, 1);
        var canvasData = context.getImageData(frame.x * resolution, frame.y * resolution, width, height);

        canvasBuffer.context.putImageData(canvasData, 0, 0);

        // send the canvas back..
        return canvasBuffer.canvas;
    };

    /**
     * Will return a one-dimensional array containing the pixel data of the entire texture in RGBA
     * order, with integer values between 0 and 255 (included).
     *
     * @param {PIXI.DisplayObject|PIXI.RenderTexture} target - A displayObject or renderTexture
     *  to convert. If left empty will use use the main renderer
     * @return {Uint8ClampedArray} One-dimensional array containing the pixel data of the entire texture
     */


    CanvasExtract.prototype.pixels = function pixels(target) {
        var renderer = this.renderer;
        var context = void 0;
        var resolution = void 0;
        var frame = void 0;
        var renderTexture = void 0;

        if (target) {
            if (target instanceof core.RenderTexture) {
                renderTexture = target;
            } else {
                renderTexture = renderer.generateTexture(target);
            }
        }

        if (renderTexture) {
            context = renderTexture.baseTexture._canvasRenderTarget.context;
            resolution = renderTexture.baseTexture._canvasRenderTarget.resolution;
            frame = renderTexture.frame;
        } else {
            context = renderer.rootContext;

            frame = TEMP_RECT;
            frame.width = renderer.width;
            frame.height = renderer.height;
        }

        return context.getImageData(0, 0, frame.width * resolution, frame.height * resolution).data;
    };

    /**
     * Destroys the extract
     *
     */


    CanvasExtract.prototype.destroy = function destroy() {
        this.renderer.extract = null;
        this.renderer = null;
    };

    return CanvasExtract;
}();

exports.default = CanvasExtract;


core.CanvasRenderer.registerPlugin('extract', CanvasExtract);

},{"../../core":72}],140:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _WebGLExtract = require('./webgl/WebGLExtract');

Object.defineProperty(exports, 'webgl', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_WebGLExtract).default;
  }
});

var _CanvasExtract = require('./canvas/CanvasExtract');

Object.defineProperty(exports, 'canvas', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_CanvasExtract).default;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

},{"./canvas/CanvasExtract":139,"./webgl/WebGLExtract":141}],141:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _core = require('../../core');

var core = _interopRequireWildcard(_core);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var TEMP_RECT = new core.Rectangle();
var BYTES_PER_PIXEL = 4;

/**
 * The extract manager provides functionality to export content from the renderers.
 *
 * An instance of this class is automatically created by default, and can be found at renderer.plugins.extract
 *
 * @class
 * @memberof PIXI.extract
 */

var WebGLExtract = function () {
    /**
     * @param {PIXI.WebGLRenderer} renderer - A reference to the current renderer
     */
    function WebGLExtract(renderer) {
        _classCallCheck(this, WebGLExtract);

        this.renderer = renderer;
        /**
         * Collection of methods for extracting data (image, pixels, etc.) from a display object or render texture
         *
         * @member {PIXI.extract.WebGLExtract} extract
         * @memberof PIXI.WebGLRenderer#
         * @see PIXI.extract.WebGLExtract
         */
        renderer.extract = this;
    }

    /**
     * Will return a HTML Image of the target
     *
     * @param {PIXI.DisplayObject|PIXI.RenderTexture} target - A displayObject or renderTexture
     *  to convert. If left empty will use use the main renderer
     * @return {HTMLImageElement} HTML Image of the target
     */


    WebGLExtract.prototype.image = function image(target) {
        var image = new Image();

        image.src = this.base64(target);

        return image;
    };

    /**
     * Will return a a base64 encoded string of this target. It works by calling
     *  `WebGLExtract.getCanvas` and then running toDataURL on that.
     *
     * @param {PIXI.DisplayObject|PIXI.RenderTexture} target - A displayObject or renderTexture
     *  to convert. If left empty will use use the main renderer
     * @return {string} A base64 encoded string of the texture.
     */


    WebGLExtract.prototype.base64 = function base64(target) {
        return this.canvas(target).toDataURL();
    };

    /**
     * Creates a Canvas element, renders this target to it and then returns it.
     *
     * @param {PIXI.DisplayObject|PIXI.RenderTexture} target - A displayObject or renderTexture
     *  to convert. If left empty will use use the main renderer
     * @return {HTMLCanvasElement} A Canvas element with the texture rendered on.
     */


    WebGLExtract.prototype.canvas = function canvas(target) {
        var renderer = this.renderer;
        var textureBuffer = void 0;
        var resolution = void 0;
        var frame = void 0;
        var flipY = false;
        var renderTexture = void 0;
        var generated = false;

        if (target) {
            if (target instanceof core.RenderTexture) {
                renderTexture = target;
            } else {
                renderTexture = this.renderer.generateTexture(target);
                generated = true;
            }
        }

        if (renderTexture) {
            textureBuffer = renderTexture.baseTexture._glRenderTargets[this.renderer.CONTEXT_UID];
            resolution = textureBuffer.resolution;
            frame = renderTexture.frame;
            flipY = false;
        } else {
            textureBuffer = this.renderer.rootRenderTarget;
            resolution = textureBuffer.resolution;
            flipY = true;

            frame = TEMP_RECT;
            frame.width = textureBuffer.size.width;
            frame.height = textureBuffer.size.height;
        }

        var width = frame.width * resolution;
        var height = frame.height * resolution;

        var canvasBuffer = new core.CanvasRenderTarget(width, height, 1);

        if (textureBuffer) {
            // bind the buffer
            renderer.bindRenderTarget(textureBuffer);

            // set up an array of pixels
            var webglPixels = new Uint8Array(BYTES_PER_PIXEL * width * height);

            // read pixels to the array
            var gl = renderer.gl;

            gl.readPixels(frame.x * resolution, frame.y * resolution, width, height, gl.RGBA, gl.UNSIGNED_BYTE, webglPixels);

            // add the pixels to the canvas
            var canvasData = canvasBuffer.context.getImageData(0, 0, width, height);

            canvasData.data.set(webglPixels);

            canvasBuffer.context.putImageData(canvasData, 0, 0);

            // pulling pixels
            if (flipY) {
                canvasBuffer.context.scale(1, -1);
                canvasBuffer.context.drawImage(canvasBuffer.canvas, 0, -height);
            }
        }

        if (generated) {
            renderTexture.destroy(true);
        }
        // send the canvas back..

        return canvasBuffer.canvas;
    };

    /**
     * Will return a one-dimensional array containing the pixel data of the entire texture in RGBA
     * order, with integer values between 0 and 255 (included).
     *
     * @param {PIXI.DisplayObject|PIXI.RenderTexture} target - A displayObject or renderTexture
     *  to convert. If left empty will use use the main renderer
     * @return {Uint8ClampedArray} One-dimensional array containing the pixel data of the entire texture
     */


    WebGLExtract.prototype.pixels = function pixels(target) {
        var renderer = this.renderer;
        var textureBuffer = void 0;
        var resolution = void 0;
        var frame = void 0;
        var renderTexture = void 0;
        var generated = false;

        if (target) {
            if (target instanceof core.RenderTexture) {
                renderTexture = target;
            } else {
                renderTexture = this.renderer.generateTexture(target);
                generated = true;
            }
        }

        if (renderTexture) {
            textureBuffer = renderTexture.baseTexture._glRenderTargets[this.renderer.CONTEXT_UID];
            resolution = textureBuffer.resolution;
            frame = renderTexture.frame;
        } else {
            textureBuffer = this.renderer.rootRenderTarget;
            resolution = textureBuffer.resolution;

            frame = TEMP_RECT;
            frame.width = textureBuffer.size.width;
            frame.height = textureBuffer.size.height;
        }

        var width = frame.width * resolution;
        var height = frame.height * resolution;

        var webglPixels = new Uint8Array(BYTES_PER_PIXEL * width * height);

        if (textureBuffer) {
            // bind the buffer
            renderer.bindRenderTarget(textureBuffer);
            // read pixels to the array
            var gl = renderer.gl;

            gl.readPixels(frame.x * resolution, frame.y * resolution, width, height, gl.RGBA, gl.UNSIGNED_BYTE, webglPixels);
        }

        if (generated) {
            renderTexture.destroy(true);
        }

        return webglPixels;
    };

    /**
     * Destroys the extract
     *
     */


    WebGLExtract.prototype.destroy = function destroy() {
        this.renderer.extract = null;
        this.renderer = null;
    };

    return WebGLExtract;
}();

exports.default = WebGLExtract;


core.WebGLRenderer.registerPlugin('extract', WebGLExtract);

},{"../../core":72}],142:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _core = require('../core');

var core = _interopRequireWildcard(_core);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @typedef PIXI.extras.AnimatedSprite~FrameObject
 * @type {object}
 * @property {PIXI.Texture} texture - The {@link PIXI.Texture} of the frame
 * @property {number} time - the duration of the frame in ms
 */

/**
 * An AnimatedSprite is a simple way to display an animation depicted by a list of textures.
 *
 * ```js
 * let alienImages = ["image_sequence_01.png","image_sequence_02.png","image_sequence_03.png","image_sequence_04.png"];
 * let textureArray = [];
 *
 * for (let i=0; i < 4; i++)
 * {
 *      let texture = PIXI.Texture.fromImage(alienImages[i]);
 *      textureArray.push(texture);
 * };
 *
 * let animatedSprite = new PIXI.extras.AnimatedSprite(textureArray);
 * ```
 *
 * The more efficient and simpler way to create an animated sprite is using a {@link PIXI.Spritesheet}
 * containing the animation definitions:
 *
 * ```js
 * PIXI.loader.add("assets/spritesheet.json").load(setup);
 *
 * function setup() {
 *   let sheet = PIXI.loader.resources["assets/spritesheet.json"].spritesheet;
 *   animatedSprite = new PIXI.extras.AnimatedSprite(sheet.animations["image_sequence"]);
 *   ...
 * }
 * ```
 *
 * @class
 * @extends PIXI.Sprite
 * @memberof PIXI.extras
 */
var AnimatedSprite = function (_core$Sprite) {
    _inherits(AnimatedSprite, _core$Sprite);

    /**
     * @param {PIXI.Texture[]|PIXI.extras.AnimatedSprite~FrameObject[]} textures - an array of {@link PIXI.Texture} or frame
     *  objects that make up the animation
     * @param {boolean} [autoUpdate=true] - Whether to use PIXI.ticker.shared to auto update animation time.
     */
    function AnimatedSprite(textures, autoUpdate) {
        _classCallCheck(this, AnimatedSprite);

        /**
         * @private
         */
        var _this = _possibleConstructorReturn(this, _core$Sprite.call(this, textures[0] instanceof core.Texture ? textures[0] : textures[0].texture));

        _this._textures = null;

        /**
         * @private
         */
        _this._durations = null;

        _this.textures = textures;

        /**
         * `true` uses PIXI.ticker.shared to auto update animation time.
         * @type {boolean}
         * @default true
         * @private
         */
        _this._autoUpdate = autoUpdate !== false;

        /**
         * The speed that the AnimatedSprite will play at. Higher is faster, lower is slower
         *
         * @member {number}
         * @default 1
         */
        _this.animationSpeed = 1;

        /**
         * Whether or not the animate sprite repeats after playing.
         *
         * @member {boolean}
         * @default true
         */
        _this.loop = true;

        /**
         * Update anchor to [Texture's defaultAnchor]{@link PIXI.Texture#defaultAnchor} when frame changes.
         *
         * Useful with [sprite sheet animations]{@link PIXI.Spritesheet#animations} created with tools.
         * Changing anchor for each frame allows to pin sprite origin to certain moving feature
         * of the frame (e.g. left foot).
         *
         * Note: Enabling this will override any previously set `anchor` on each frame change.
         *
         * @member {boolean}
         * @default false
         */
        _this.updateAnchor = false;

        /**
         * Function to call when a AnimatedSprite finishes playing
         *
         * @member {Function}
         */
        _this.onComplete = null;

        /**
         * Function to call when a AnimatedSprite changes which texture is being rendered
         *
         * @member {Function}
         */
        _this.onFrameChange = null;

        /**
        * Function to call when 'loop' is true, and an AnimatedSprite is played and loops around to start again
        *
        * @member {Function}
        */
        _this.onLoop = null;

        /**
         * Elapsed time since animation has been started, used internally to display current texture
         *
         * @member {number}
         * @private
         */
        _this._currentTime = 0;

        /**
         * Indicates if the AnimatedSprite is currently playing
         *
         * @member {boolean}
         * @readonly
         */
        _this.playing = false;
        return _this;
    }

    /**
     * Stops the AnimatedSprite
     *
     */


    AnimatedSprite.prototype.stop = function stop() {
        if (!this.playing) {
            return;
        }

        this.playing = false;
        if (this._autoUpdate) {
            core.ticker.shared.remove(this.update, this);
        }
    };

    /**
     * Plays the AnimatedSprite
     *
     */


    AnimatedSprite.prototype.play = function play() {
        if (this.playing) {
            return;
        }

        this.playing = true;
        if (this._autoUpdate) {
            core.ticker.shared.add(this.update, this, core.UPDATE_PRIORITY.HIGH);
        }
    };

    /**
     * Stops the AnimatedSprite and goes to a specific frame
     *
     * @param {number} frameNumber - frame index to stop at
     */


    AnimatedSprite.prototype.gotoAndStop = function gotoAndStop(frameNumber) {
        this.stop();

        var previousFrame = this.currentFrame;

        this._currentTime = frameNumber;

        if (previousFrame !== this.currentFrame) {
            this.updateTexture();
        }
    };

    /**
     * Goes to a specific frame and begins playing the AnimatedSprite
     *
     * @param {number} frameNumber - frame index to start at
     */


    AnimatedSprite.prototype.gotoAndPlay = function gotoAndPlay(frameNumber) {
        var previousFrame = this.currentFrame;

        this._currentTime = frameNumber;

        if (previousFrame !== this.currentFrame) {
            this.updateTexture();
        }

        this.play();
    };

    /**
     * Updates the object transform for rendering.
     *
     * @private
     * @param {number} deltaTime - Time since last tick.
     */


    AnimatedSprite.prototype.update = function update(deltaTime) {
        var elapsed = this.animationSpeed * deltaTime;
        var previousFrame = this.currentFrame;

        if (this._durations !== null) {
            var lag = this._currentTime % 1 * this._durations[this.currentFrame];

            lag += elapsed / 60 * 1000;

            while (lag < 0) {
                this._currentTime--;
                lag += this._durations[this.currentFrame];
            }

            var sign = Math.sign(this.animationSpeed * deltaTime);

            this._currentTime = Math.floor(this._currentTime);

            while (lag >= this._durations[this.currentFrame]) {
                lag -= this._durations[this.currentFrame] * sign;
                this._currentTime += sign;
            }

            this._currentTime += lag / this._durations[this.currentFrame];
        } else {
            this._currentTime += elapsed;
        }

        if (this._currentTime < 0 && !this.loop) {
            this.gotoAndStop(0);

            if (this.onComplete) {
                this.onComplete();
            }
        } else if (this._currentTime >= this._textures.length && !this.loop) {
            this.gotoAndStop(this._textures.length - 1);

            if (this.onComplete) {
                this.onComplete();
            }
        } else if (previousFrame !== this.currentFrame) {
            if (this.loop && this.onLoop) {
                if (this.animationSpeed > 0 && this.currentFrame < previousFrame) {
                    this.onLoop();
                } else if (this.animationSpeed < 0 && this.currentFrame > previousFrame) {
                    this.onLoop();
                }
            }

            this.updateTexture();
        }
    };

    /**
     * Updates the displayed texture to match the current frame index
     *
     * @private
     */


    AnimatedSprite.prototype.updateTexture = function updateTexture() {
        this._texture = this._textures[this.currentFrame];
        this._textureID = -1;
        this.cachedTint = 0xFFFFFF;

        if (this.updateAnchor) {
            this._anchor.copy(this._texture.defaultAnchor);
        }

        if (this.onFrameChange) {
            this.onFrameChange(this.currentFrame);
        }
    };

    /**
     * Stops the AnimatedSprite and destroys it
     *
     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options
     *  have been set to that value
     * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy
     *      method called as well. 'options' will be passed on to those calls.
     * @param {boolean} [options.texture=false] - Should it destroy the current texture of the sprite as well
     * @param {boolean} [options.baseTexture=false] - Should it destroy the base texture of the sprite as well
     */


    AnimatedSprite.prototype.destroy = function destroy(options) {
        this.stop();
        _core$Sprite.prototype.destroy.call(this, options);
    };

    /**
     * A short hand way of creating a movieclip from an array of frame ids
     *
     * @static
     * @param {string[]} frames - The array of frames ids the movieclip will use as its texture frames
     * @return {AnimatedSprite} The new animated sprite with the specified frames.
     */


    AnimatedSprite.fromFrames = function fromFrames(frames) {
        var textures = [];

        for (var i = 0; i < frames.length; ++i) {
            textures.push(core.Texture.fromFrame(frames[i]));
        }

        return new AnimatedSprite(textures);
    };

    /**
     * A short hand way of creating a movieclip from an array of image ids
     *
     * @static
     * @param {string[]} images - the array of image urls the movieclip will use as its texture frames
     * @return {AnimatedSprite} The new animate sprite with the specified images as frames.
     */


    AnimatedSprite.fromImages = function fromImages(images) {
        var textures = [];

        for (var i = 0; i < images.length; ++i) {
            textures.push(core.Texture.fromImage(images[i]));
        }

        return new AnimatedSprite(textures);
    };

    /**
     * totalFrames is the total number of frames in the AnimatedSprite. This is the same as number of textures
     * assigned to the AnimatedSprite.
     *
     * @readonly
     * @member {number}
     * @default 0
     */


    _createClass(AnimatedSprite, [{
        key: 'totalFrames',
        get: function get() {
            return this._textures.length;
        }

        /**
         * The array of textures used for this AnimatedSprite
         *
         * @member {PIXI.Texture[]}
         */

    }, {
        key: 'textures',
        get: function get() {
            return this._textures;
        },
        set: function set(value) // eslint-disable-line require-jsdoc
        {
            if (value[0] instanceof core.Texture) {
                this._textures = value;
                this._durations = null;
            } else {
                this._textures = [];
                this._durations = [];

                for (var i = 0; i < value.length; i++) {
                    this._textures.push(value[i].texture);
                    this._durations.push(value[i].time);
                }
            }
            this.gotoAndStop(0);
            this.updateTexture();
        }

        /**
        * The AnimatedSprites current frame index
        *
        * @member {number}
        * @readonly
        */

    }, {
        key: 'currentFrame',
        get: function get() {
            var currentFrame = Math.floor(this._currentTime) % this._textures.length;

            if (currentFrame < 0) {
                currentFrame += this._textures.length;
            }

            return currentFrame;
        }
    }]);

    return AnimatedSprite;
}(core.Sprite);

exports.default = AnimatedSprite;

},{"../core":72}],143:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _core = require('../core');

var core = _interopRequireWildcard(_core);

var _ObservablePoint = require('../core/math/ObservablePoint');

var _ObservablePoint2 = _interopRequireDefault(_ObservablePoint);

var _utils = require('../core/utils');

var _settings = require('../core/settings');

var _settings2 = _interopRequireDefault(_settings);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * A BitmapText object will create a line or multiple lines of text using bitmap font. To
 * split a line you can use '\n', '\r' or '\r\n' in your string. You can generate the fnt files using:
 *
 * A BitmapText can only be created when the font is loaded
 *
 * ```js
 * // in this case the font is in a file called 'desyrel.fnt'
 * let bitmapText = new PIXI.extras.BitmapText("text using a fancy font!", {font: "35px Desyrel", align: "right"});
 * ```
 *
 * http://www.angelcode.com/products/bmfont/ for windows or
 * http://www.bmglyph.com/ for mac.
 *
 * @class
 * @extends PIXI.Container
 * @memberof PIXI.extras
 */
var BitmapText = function (_core$Container) {
    _inherits(BitmapText, _core$Container);

    /**
     * @param {string} text - The copy that you would like the text to display
     * @param {object} style - The style parameters
     * @param {string|object} style.font - The font descriptor for the object, can be passed as a string of form
     *      "24px FontName" or "FontName" or as an object with explicit name/size properties.
     * @param {string} [style.font.name] - The bitmap font id
     * @param {number} [style.font.size] - The size of the font in pixels, e.g. 24
     * @param {string} [style.align='left'] - Alignment for multiline text ('left', 'center' or 'right'), does not affect
     *      single line text
     * @param {number} [style.tint=0xFFFFFF] - The tint color
     */
    function BitmapText(text) {
        var style = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        _classCallCheck(this, BitmapText);

        /**
         * Private tracker for the width of the overall text
         *
         * @member {number}
         * @private
         */
        var _this = _possibleConstructorReturn(this, _core$Container.call(this));

        _this._textWidth = 0;

        /**
         * Private tracker for the height of the overall text
         *
         * @member {number}
         * @private
         */
        _this._textHeight = 0;

        /**
         * Private tracker for the letter sprite pool.
         *
         * @member {PIXI.Sprite[]}
         * @private
         */
        _this._glyphs = [];

        /**
         * Private tracker for the current style.
         *
         * @member {object}
         * @private
         */
        _this._font = {
            tint: style.tint !== undefined ? style.tint : 0xFFFFFF,
            align: style.align || 'left',
            name: null,
            size: 0
        };

        /**
         * Private tracker for the current font.
         *
         * @member {object}
         * @private
         */
        _this.font = style.font; // run font setter

        /**
         * Private tracker for the current text.
         *
         * @member {string}
         * @private
         */
        _this._text = text;

        /**
         * The max width of this bitmap text in pixels. If the text provided is longer than the
         * value provided, line breaks will be automatically inserted in the last whitespace.
         * Disable by setting value to 0
         *
         * @member {number}
         * @private
         */
        _this._maxWidth = 0;

        /**
         * The max line height. This is useful when trying to use the total height of the Text,
         * ie: when trying to vertically align.
         *
         * @member {number}
         * @private
         */
        _this._maxLineHeight = 0;

        /**
         * Letter spacing. This is useful for setting the space between characters.
         * @member {number}
         * @private
         */
        _this._letterSpacing = 0;

        /**
         * Text anchor. read-only
         *
         * @member {PIXI.ObservablePoint}
         * @private
         */
        _this._anchor = new _ObservablePoint2.default(function () {
            _this.dirty = true;
        }, _this, 0, 0);

        /**
         * The dirty state of this object.
         *
         * @member {boolean}
         */
        _this.dirty = false;

        _this.updateText();
        return _this;
    }

    /**
     * Renders text and updates it when needed
     *
     * @private
     */


    BitmapText.prototype.updateText = function updateText() {
        var data = BitmapText.fonts[this._font.name];
        var scale = this._font.size / data.size;
        var pos = new core.Point();
        var chars = [];
        var lineWidths = [];
        var text = this.text.replace(/(?:\r\n|\r)/g, '\n');
        var textLength = text.length;
        var maxWidth = this._maxWidth * data.size / this._font.size;

        var prevCharCode = null;
        var lastLineWidth = 0;
        var maxLineWidth = 0;
        var line = 0;
        var lastBreakPos = -1;
        var lastBreakWidth = 0;
        var spacesRemoved = 0;
        var maxLineHeight = 0;

        for (var i = 0; i < textLength; i++) {
            var charCode = text.charCodeAt(i);
            var char = text.charAt(i);

            if (/(?:\s)/.test(char)) {
                lastBreakPos = i;
                lastBreakWidth = lastLineWidth;
            }

            if (char === '\r' || char === '\n') {
                lineWidths.push(lastLineWidth);
                maxLineWidth = Math.max(maxLineWidth, lastLineWidth);
                ++line;
                ++spacesRemoved;

                pos.x = 0;
                pos.y += data.lineHeight;
                prevCharCode = null;
                continue;
            }

            var charData = data.chars[charCode];

            if (!charData) {
                continue;
            }

            if (prevCharCode && charData.kerning[prevCharCode]) {
                pos.x += charData.kerning[prevCharCode];
            }

            chars.push({
                texture: charData.texture,
                line: line,
                charCode: charCode,
                position: new core.Point(pos.x + charData.xOffset + this._letterSpacing / 2, pos.y + charData.yOffset)
            });
            pos.x += charData.xAdvance + this._letterSpacing;
            lastLineWidth = pos.x;
            maxLineHeight = Math.max(maxLineHeight, charData.yOffset + charData.texture.height);
            prevCharCode = charCode;

            if (lastBreakPos !== -1 && maxWidth > 0 && pos.x > maxWidth) {
                ++spacesRemoved;
                core.utils.removeItems(chars, 1 + lastBreakPos - spacesRemoved, 1 + i - lastBreakPos);
                i = lastBreakPos;
                lastBreakPos = -1;

                lineWidths.push(lastBreakWidth);
                maxLineWidth = Math.max(maxLineWidth, lastBreakWidth);
                line++;

                pos.x = 0;
                pos.y += data.lineHeight;
                prevCharCode = null;
            }
        }

        var lastChar = text.charAt(text.length - 1);

        if (lastChar !== '\r' && lastChar !== '\n') {
            if (/(?:\s)/.test(lastChar)) {
                lastLineWidth = lastBreakWidth;
            }

            lineWidths.push(lastLineWidth);
            maxLineWidth = Math.max(maxLineWidth, lastLineWidth);
        }

        var lineAlignOffsets = [];

        for (var _i = 0; _i <= line; _i++) {
            var alignOffset = 0;

            if (this._font.align === 'right') {
                alignOffset = maxLineWidth - lineWidths[_i];
            } else if (this._font.align === 'center') {
                alignOffset = (maxLineWidth - lineWidths[_i]) / 2;
            }

            lineAlignOffsets.push(alignOffset);
        }

        var lenChars = chars.length;
        var tint = this.tint;

        for (var _i2 = 0; _i2 < lenChars; _i2++) {
            var c = this._glyphs[_i2]; // get the next glyph sprite

            if (c) {
                c.texture = chars[_i2].texture;
            } else {
                c = new core.Sprite(chars[_i2].texture);
                this._glyphs.push(c);
            }

            c.position.x = (chars[_i2].position.x + lineAlignOffsets[chars[_i2].line]) * scale;
            c.position.y = chars[_i2].position.y * scale;
            c.scale.x = c.scale.y = scale;
            c.tint = tint;

            if (!c.parent) {
                this.addChild(c);
            }
        }

        // remove unnecessary children.
        for (var _i3 = lenChars; _i3 < this._glyphs.length; ++_i3) {
            this.removeChild(this._glyphs[_i3]);
        }

        this._textWidth = maxLineWidth * scale;
        this._textHeight = (pos.y + data.lineHeight) * scale;

        // apply anchor
        if (this.anchor.x !== 0 || this.anchor.y !== 0) {
            for (var _i4 = 0; _i4 < lenChars; _i4++) {
                this._glyphs[_i4].x -= this._textWidth * this.anchor.x;
                this._glyphs[_i4].y -= this._textHeight * this.anchor.y;
            }
        }
        this._maxLineHeight = maxLineHeight * scale;
    };

    /**
     * Updates the transform of this object
     *
     * @private
     */


    BitmapText.prototype.updateTransform = function updateTransform() {
        this.validate();
        this.containerUpdateTransform();
    };

    /**
     * Validates text before calling parent's getLocalBounds
     *
     * @return {PIXI.Rectangle} The rectangular bounding area
     */


    BitmapText.prototype.getLocalBounds = function getLocalBounds() {
        this.validate();

        return _core$Container.prototype.getLocalBounds.call(this);
    };

    /**
     * Updates text when needed
     *
     * @private
     */


    BitmapText.prototype.validate = function validate() {
        if (this.dirty) {
            this.updateText();
            this.dirty = false;
        }
    };

    /**
     * The tint of the BitmapText object
     *
     * @member {number}
     */


    /**
     * Register a bitmap font with data and a texture.
     *
     * @static
     * @param {XMLDocument} xml - The XML document data.
     * @param {Object.<string, PIXI.Texture>|PIXI.Texture|PIXI.Texture[]} textures - List of textures for each page.
     *  If providing an object, the key is the `<page>` element's `file` attribute in the FNT file.
     * @return {Object} Result font object with font, size, lineHeight and char fields.
     */
    BitmapText.registerFont = function registerFont(xml, textures) {
        var data = {};
        var info = xml.getElementsByTagName('info')[0];
        var common = xml.getElementsByTagName('common')[0];
        var pages = xml.getElementsByTagName('page');
        var res = (0, _utils.getResolutionOfUrl)(pages[0].getAttribute('file'), _settings2.default.RESOLUTION);
        var pagesTextures = {};

        data.font = info.getAttribute('face');
        data.size = parseInt(info.getAttribute('size'), 10);
        data.lineHeight = parseInt(common.getAttribute('lineHeight'), 10) / res;
        data.chars = {};

        // Single texture, convert to list
        if (textures instanceof core.Texture) {
            textures = [textures];
        }

        // Convert the input Texture, Textures or object
        // into a page Texture lookup by "id"
        for (var i = 0; i < pages.length; i++) {
            var id = pages[i].getAttribute('id');
            var file = pages[i].getAttribute('file');

            pagesTextures[id] = textures instanceof Array ? textures[i] : textures[file];
        }

        // parse letters
        var letters = xml.getElementsByTagName('char');

        for (var _i5 = 0; _i5 < letters.length; _i5++) {
            var letter = letters[_i5];
            var charCode = parseInt(letter.getAttribute('id'), 10);
            var page = letter.getAttribute('page') || 0;
            var textureRect = new core.Rectangle(parseInt(letter.getAttribute('x'), 10) / res + pagesTextures[page].frame.x / res, parseInt(letter.getAttribute('y'), 10) / res + pagesTextures[page].frame.y / res, parseInt(letter.getAttribute('width'), 10) / res, parseInt(letter.getAttribute('height'), 10) / res);

            data.chars[charCode] = {
                xOffset: parseInt(letter.getAttribute('xoffset'), 10) / res,
                yOffset: parseInt(letter.getAttribute('yoffset'), 10) / res,
                xAdvance: parseInt(letter.getAttribute('xadvance'), 10) / res,
                kerning: {},
                texture: new core.Texture(pagesTextures[page].baseTexture, textureRect),
                page: page
            };
        }

        // parse kernings
        var kernings = xml.getElementsByTagName('kerning');

        for (var _i6 = 0; _i6 < kernings.length; _i6++) {
            var kerning = kernings[_i6];
            var first = parseInt(kerning.getAttribute('first'), 10) / res;
            var second = parseInt(kerning.getAttribute('second'), 10) / res;
            var amount = parseInt(kerning.getAttribute('amount'), 10) / res;

            if (data.chars[second]) {
                data.chars[second].kerning[first] = amount;
            }
        }

        // I'm leaving this as a temporary fix so we can test the bitmap fonts in v3
        // but it's very likely to change
        BitmapText.fonts[data.font] = data;

        return data;
    };

    _createClass(BitmapText, [{
        key: 'tint',
        get: function get() {
            return this._font.tint;
        },
        set: function set(value) // eslint-disable-line require-jsdoc
        {
            this._font.tint = typeof value === 'number' && value >= 0 ? value : 0xFFFFFF;

            this.dirty = true;
        }

        /**
         * The alignment of the BitmapText object
         *
         * @member {string}
         * @default 'left'
         */

    }, {
        key: 'align',
        get: function get() {
            return this._font.align;
        },
        set: function set(value) // eslint-disable-line require-jsdoc
        {
            this._font.align = value || 'left';

            this.dirty = true;
        }

        /**
         * The anchor sets the origin point of the text.
         * The default is 0,0 this means the text's origin is the top left
         * Setting the anchor to 0.5,0.5 means the text's origin is centered
         * Setting the anchor to 1,1 would mean the text's origin point will be the bottom right corner
         *
         * @member {PIXI.Point | number}
         */

    }, {
        key: 'anchor',
        get: function get() {
            return this._anchor;
        },
        set: function set(value) // eslint-disable-line require-jsdoc
        {
            if (typeof value === 'number') {
                this._anchor.set(value);
            } else {
                this._anchor.copy(value);
            }
        }

        /**
         * The font descriptor of the BitmapText object
         *
         * @member {string|object}
         */

    }, {
        key: 'font',
        get: function get() {
            return this._font;
        },
        set: function set(value) // eslint-disable-line require-jsdoc
        {
            if (!value) {
                return;
            }

            if (typeof value === 'string') {
                value = value.split(' ');

                this._font.name = value.length === 1 ? value[0] : value.slice(1).join(' ');
                this._font.size = value.length >= 2 ? parseInt(value[0], 10) : BitmapText.fonts[this._font.name].size;
            } else {
                this._font.name = value.name;
                this._font.size = typeof value.size === 'number' ? value.size : parseInt(value.size, 10);
            }

            this.dirty = true;
        }

        /**
         * The text of the BitmapText object
         *
         * @member {string}
         */

    }, {
        key: 'text',
        get: function get() {
            return this._text;
        },
        set: function set(value) // eslint-disable-line require-jsdoc
        {
            value = value.toString() || ' ';
            if (this._text === value) {
                return;
            }
            this._text = value;
            this.dirty = true;
        }

        /**
         * The max width of this bitmap text in pixels. If the text provided is longer than the
         * value provided, line breaks will be automatically inserted in the last whitespace.
         * Disable by setting value to 0
         *
         * @member {number}
         */

    }, {
        key: 'maxWidth',
        get: function get() {
            return this._maxWidth;
        },
        set: function set(value) // eslint-disable-line require-jsdoc
        {
            if (this._maxWidth === value) {
                return;
            }
            this._maxWidth = value;
            this.dirty = true;
        }

        /**
         * The max line height. This is useful when trying to use the total height of the Text,
         * ie: when trying to vertically align.
         *
         * @member {number}
         * @readonly
         */

    }, {
        key: 'maxLineHeight',
        get: function get() {
            this.validate();

            return this._maxLineHeight;
        }

        /**
         * The width of the overall text, different from fontSize,
         * which is defined in the style object
         *
         * @member {number}
         * @readonly
         */

    }, {
        key: 'textWidth',
        get: function get() {
            this.validate();

            return this._textWidth;
        }

        /**
         * Additional space between characters.
         *
         * @member {number}
         */

    }, {
        key: 'letterSpacing',
        get: function get() {
            return this._letterSpacing;
        },
        set: function set(value) // eslint-disable-line require-jsdoc
        {
            if (this._letterSpacing !== value) {
                this._letterSpacing = value;
                this.dirty = true;
            }
        }

        /**
         * The height of the overall text, different from fontSize,
         * which is defined in the style object
         *
         * @member {number}
         * @readonly
         */

    }, {
        key: 'textHeight',
        get: function get() {
            this.validate();

            return this._textHeight;
        }
    }]);

    return BitmapText;
}(core.Container);

exports.default = BitmapText;


BitmapText.fonts = {};

},{"../core":72,"../core/math/ObservablePoint":75,"../core/settings":108,"../core/utils":132}],144:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _core = require('../core');

var core = _interopRequireWildcard(_core);

var _CanvasTinter = require('../core/sprites/canvas/CanvasTinter');

var _CanvasTinter2 = _interopRequireDefault(_CanvasTinter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var tempPoint = new core.Point();

/**
 * A tiling sprite is a fast way of rendering a tiling image
 *
 * @class
 * @extends PIXI.Sprite
 * @memberof PIXI.extras
 */

var TilingSprite = function (_core$Sprite) {
    _inherits(TilingSprite, _core$Sprite);

    /**
     * @param {PIXI.Texture} texture - the texture of the tiling sprite
     * @param {number} [width=100] - the width of the tiling sprite
     * @param {number} [height=100] - the height of the tiling sprite
     */
    function TilingSprite(texture) {
        var width = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;
        var height = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 100;

        _classCallCheck(this, TilingSprite);

        /**
         * Tile transform
         *
         * @member {PIXI.TransformStatic}
         */
        var _this = _possibleConstructorReturn(this, _core$Sprite.call(this, texture));

        _this.tileTransform = new core.TransformStatic();

        // /// private

        /**
         * The with of the tiling sprite
         *
         * @member {number}
         * @private
         */
        _this._width = width;

        /**
         * The height of the tiling sprite
         *
         * @member {number}
         * @private
         */
        _this._height = height;

        /**
         * Canvas pattern
         *
         * @type {CanvasPattern}
         * @private
         */
        _this._canvasPattern = null;

        /**
         * transform that is applied to UV to get the texture coords
         *
         * @member {PIXI.TextureMatrix}
         */
        _this.uvTransform = texture.transform || new core.TextureMatrix(texture);

        /**
         * Plugin that is responsible for rendering this element.
         * Allows to customize the rendering process without overriding '_renderWebGL' method.
         *
         * @member {string}
         * @default 'tilingSprite'
         */
        _this.pluginName = 'tilingSprite';

        /**
         * Whether or not anchor affects uvs
         *
         * @member {boolean}
         * @default false
         */
        _this.uvRespectAnchor = false;
        return _this;
    }
    /**
     * Changes frame clamping in corresponding textureTransform, shortcut
     * Change to -0.5 to add a pixel to the edge, recommended for transparent trimmed textures in atlas
     *
     * @default 0.5
     * @member {number}
     */


    /**
     * @private
     */
    TilingSprite.prototype._onTextureUpdate = function _onTextureUpdate() {
        if (this.uvTransform) {
            this.uvTransform.texture = this._texture;
        }
        this.cachedTint = 0xFFFFFF;
    };

    /**
     * Renders the object using the WebGL renderer
     *
     * @private
     * @param {PIXI.WebGLRenderer} renderer - The renderer
     */


    TilingSprite.prototype._renderWebGL = function _renderWebGL(renderer) {
        // tweak our texture temporarily..
        var texture = this._texture;

        if (!texture || !texture.valid) {
            return;
        }

        this.tileTransform.updateLocalTransform();
        this.uvTransform.update();

        renderer.setObjectRenderer(renderer.plugins[this.pluginName]);
        renderer.plugins[this.pluginName].render(this);
    };

    /**
     * Renders the object using the Canvas renderer
     *
     * @private
     * @param {PIXI.CanvasRenderer} renderer - a reference to the canvas renderer
     */


    TilingSprite.prototype._renderCanvas = function _renderCanvas(renderer) {
        var texture = this._texture;

        if (!texture.baseTexture.hasLoaded) {
            return;
        }

        var context = renderer.context;
        var transform = this.worldTransform;
        var resolution = renderer.resolution;
        var isTextureRotated = texture.rotate === 2;
        var baseTexture = texture.baseTexture;
        var baseTextureResolution = baseTexture.resolution;
        var modX = this.tilePosition.x / this.tileScale.x % texture.orig.width * baseTextureResolution;
        var modY = this.tilePosition.y / this.tileScale.y % texture.orig.height * baseTextureResolution;

        // create a nice shiny pattern!
        if (this._textureID !== this._texture._updateID || this.cachedTint !== this.tint) {
            this._textureID = this._texture._updateID;
            // cut an object from a spritesheet..
            var tempCanvas = new core.CanvasRenderTarget(texture.orig.width, texture.orig.height, baseTextureResolution);

            // Tint the tiling sprite
            if (this.tint !== 0xFFFFFF) {
                this.tintedTexture = _CanvasTinter2.default.getTintedTexture(this, this.tint);
                tempCanvas.context.drawImage(this.tintedTexture, 0, 0);
            } else {
                var sx = texture._frame.x * baseTextureResolution;
                var sy = texture._frame.y * baseTextureResolution;
                var sWidth = texture._frame.width * baseTextureResolution;
                var sHeight = texture._frame.height * baseTextureResolution;
                var dWidth = (texture.trim ? texture.trim.width : texture.orig.width) * baseTextureResolution;
                var dHeight = (texture.trim ? texture.trim.height : texture.orig.height) * baseTextureResolution;
                var dx = (texture.trim ? texture.trim.x : 0) * baseTextureResolution;
                var dy = (texture.trim ? texture.trim.y : 0) * baseTextureResolution;

                if (isTextureRotated) {
                    // Apply rotation and transform
                    tempCanvas.context.rotate(-Math.PI / 2);
                    tempCanvas.context.translate(-dHeight, 0);
                    tempCanvas.context.drawImage(baseTexture.source, sx, sy, sWidth, sHeight, -dy, dx, dHeight, dWidth);
                } else {
                    tempCanvas.context.drawImage(baseTexture.source, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);
                }
            }

            this.cachedTint = this.tint;
            this._canvasPattern = tempCanvas.context.createPattern(tempCanvas.canvas, 'repeat');
        }

        // set context state..
        context.globalAlpha = this.worldAlpha;
        context.setTransform(transform.a * resolution, transform.b * resolution, transform.c * resolution, transform.d * resolution, transform.tx * resolution, transform.ty * resolution);

        renderer.setBlendMode(this.blendMode);

        // fill the pattern!
        context.fillStyle = this._canvasPattern;

        // TODO - this should be rolled into the setTransform above..
        context.scale(this.tileScale.x / baseTextureResolution, this.tileScale.y / baseTextureResolution);

        var anchorX = this.anchor.x * -this._width * baseTextureResolution;
        var anchorY = this.anchor.y * -this._height * baseTextureResolution;

        if (this.uvRespectAnchor) {
            context.translate(modX, modY);

            context.fillRect(-modX + anchorX, -modY + anchorY, this._width / this.tileScale.x * baseTextureResolution, this._height / this.tileScale.y * baseTextureResolution);
        } else {
            context.translate(modX + anchorX, modY + anchorY);

            context.fillRect(-modX, -modY, this._width / this.tileScale.x * baseTextureResolution, this._height / this.tileScale.y * baseTextureResolution);
        }
    };

    /**
     * Updates the bounds of the tiling sprite.
     *
     * @private
     */


    TilingSprite.prototype._calculateBounds = function _calculateBounds() {
        var minX = this._width * -this._anchor._x;
        var minY = this._height * -this._anchor._y;
        var maxX = this._width * (1 - this._anchor._x);
        var maxY = this._height * (1 - this._anchor._y);

        this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);
    };

    /**
     * Gets the local bounds of the sprite object.
     *
     * @param {PIXI.Rectangle} rect - The output rectangle.
     * @return {PIXI.Rectangle} The bounds.
     */


    TilingSprite.prototype.getLocalBounds = function getLocalBounds(rect) {
        // we can do a fast local bounds if the sprite has no children!
        if (this.children.length === 0) {
            this._bounds.minX = this._width * -this._anchor._x;
            this._bounds.minY = this._height * -this._anchor._y;
            this._bounds.maxX = this._width * (1 - this._anchor._x);
            this._bounds.maxY = this._height * (1 - this._anchor._y);

            if (!rect) {
                if (!this._localBoundsRect) {
                    this._localBoundsRect = new core.Rectangle();
                }

                rect = this._localBoundsRect;
            }

            return this._bounds.getRectangle(rect);
        }

        return _core$Sprite.prototype.getLocalBounds.call(this, rect);
    };

    /**
     * Checks if a point is inside this tiling sprite.
     *
     * @param {PIXI.Point} point - the point to check
     * @return {boolean} Whether or not the sprite contains the point.
     */


    TilingSprite.prototype.containsPoint = function containsPoint(point) {
        this.worldTransform.applyInverse(point, tempPoint);

        var width = this._width;
        var height = this._height;
        var x1 = -width * this.anchor._x;

        if (tempPoint.x >= x1 && tempPoint.x < x1 + width) {
            var y1 = -height * this.anchor._y;

            if (tempPoint.y >= y1 && tempPoint.y < y1 + height) {
                return true;
            }
        }

        return false;
    };

    /**
     * Destroys this sprite and optionally its texture and children
     *
     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options
     *  have been set to that value
     * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy
     *      method called as well. 'options' will be passed on to those calls.
     * @param {boolean} [options.texture=false] - Should it destroy the current texture of the sprite as well
     * @param {boolean} [options.baseTexture=false] - Should it destroy the base texture of the sprite as well
     */


    TilingSprite.prototype.destroy = function destroy(options) {
        _core$Sprite.prototype.destroy.call(this, options);

        this.tileTransform = null;
        this.uvTransform = null;
    };

    /**
     * Helper function that creates a new tiling sprite based on the source you provide.
     * The source can be - frame id, image url, video url, canvas element, video element, base texture
     *
     * @static
     * @param {number|string|PIXI.BaseTexture|HTMLCanvasElement|HTMLVideoElement} source - Source to create texture from
     * @param {number} width - the width of the tiling sprite
     * @param {number} height - the height of the tiling sprite
     * @return {PIXI.Texture} The newly created texture
     */


    TilingSprite.from = function from(source, width, height) {
        return new TilingSprite(core.Texture.from(source), width, height);
    };

    /**
     * Helper function that creates a tiling sprite that will use a texture from the TextureCache based on the frameId
     * The frame ids are created when a Texture packer file has been loaded
     *
     * @static
     * @param {string} frameId - The frame Id of the texture in the cache
     * @param {number} width - the width of the tiling sprite
     * @param {number} height - the height of the tiling sprite
     * @return {PIXI.extras.TilingSprite} A new TilingSprite using a texture from the texture cache matching the frameId
     */


    TilingSprite.fromFrame = function fromFrame(frameId, width, height) {
        var texture = core.utils.TextureCache[frameId];

        if (!texture) {
            throw new Error('The frameId "' + frameId + '" does not exist in the texture cache ' + this);
        }

        return new TilingSprite(texture, width, height);
    };

    /**
     * Helper function that creates a sprite that will contain a texture based on an image url
     * If the image is not in the texture cache it will be loaded
     *
     * @static
     * @param {string} imageId - The image url of the texture
     * @param {number} width - the width of the tiling sprite
     * @param {number} height - the height of the tiling sprite
     * @param {boolean} [crossorigin] - if you want to specify the cross-origin parameter
     * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - if you want to specify the scale mode,
     *  see {@link PIXI.SCALE_MODES} for possible values
     * @return {PIXI.extras.TilingSprite} A new TilingSprite using a texture from the texture cache matching the image id
     */


    TilingSprite.fromImage = function fromImage(imageId, width, height, crossorigin, scaleMode) {
        return new TilingSprite(core.Texture.fromImage(imageId, crossorigin, scaleMode), width, height);
    };

    /**
     * The width of the sprite, setting this will actually modify the scale to achieve the value set
     *
     * @member {number}
     */


    _createClass(TilingSprite, [{
        key: 'clampMargin',
        get: function get() {
            return this.uvTransform.clampMargin;
        },
        set: function set(value) // eslint-disable-line require-jsdoc
        {
            this.uvTransform.clampMargin = value;
            this.uvTransform.update(true);
        }

        /**
         * The scaling of the image that is being tiled
         *
         * @member {PIXI.ObservablePoint}
         */

    }, {
        key: 'tileScale',
        get: function get() {
            return this.tileTransform.scale;
        },
        set: function set(value) // eslint-disable-line require-jsdoc
        {
            this.tileTransform.scale.copy(value);
        }

        /**
         * The offset of the image that is being tiled
         *
         * @member {PIXI.ObservablePoint}
         */

    }, {
        key: 'tilePosition',
        get: function get() {
            return this.tileTransform.position;
        },
        set: function set(value) // eslint-disable-line require-jsdoc
        {
            this.tileTransform.position.copy(value);
        }
    }, {
        key: 'width',
        get: function get() {
            return this._width;
        },
        set: function set(value) // eslint-disable-line require-jsdoc
        {
            this._width = value;
        }

        /**
         * The height of the TilingSprite, setting this will actually modify the scale to achieve the value set
         *
         * @member {number}
         */

    }, {
        key: 'height',
        get: function get() {
            return this._height;
        },
        set: function set(value) // eslint-disable-line require-jsdoc
        {
            this._height = value;
        }
    }]);

    return TilingSprite;
}(core.Sprite);

exports.default = TilingSprite;

},{"../core":72,"../core/sprites/canvas/CanvasTinter":111}],145:[function(require,module,exports){
'use strict';

var _core = require('../core');

var core = _interopRequireWildcard(_core);

var _Texture = require('../core/textures/Texture');

var _Texture2 = _interopRequireDefault(_Texture);

var _BaseTexture = require('../core/textures/BaseTexture');

var _BaseTexture2 = _interopRequireDefault(_BaseTexture);

var _utils = require('../core/utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var DisplayObject = core.DisplayObject;
var _tempMatrix = new core.Matrix();

DisplayObject.prototype._cacheAsBitmap = false;
DisplayObject.prototype._cacheData = false;

// figured theres no point adding ALL the extra variables to prototype.
// this model can hold the information needed. This can also be generated on demand as
// most objects are not cached as bitmaps.
/**
 * @class
 * @ignore
 */

var CacheData =
/**
 *
 */
function CacheData() {
    _classCallCheck(this, CacheData);

    this.textureCacheId = null;

    this.originalRenderWebGL = null;
    this.originalRenderCanvas = null;
    this.originalCalculateBounds = null;
    this.originalGetLocalBounds = null;

    this.originalUpdateTransform = null;
    this.originalHitTest = null;
    this.originalDestroy = null;
    this.originalMask = null;
    this.originalFilterArea = null;
    this.sprite = null;
};

Object.defineProperties(DisplayObject.prototype, {
    /**
     * Set this to true if you want this display object to be cached as a bitmap.
     * This basically takes a snap shot of the display object as it is at that moment. It can
     * provide a performance benefit for complex static displayObjects.
     * To remove simply set this property to 'false'
     *
     * IMPORTANT GOTCHA - make sure that all your textures are preloaded BEFORE setting this property to true
     * as it will take a snapshot of what is currently there. If the textures have not loaded then they will not appear.
     *
     * @member {boolean}
     * @memberof PIXI.DisplayObject#
     */
    cacheAsBitmap: {
        get: function get() {
            return this._cacheAsBitmap;
        },
        set: function set(value) {
            if (this._cacheAsBitmap === value) {
                return;
            }

            this._cacheAsBitmap = value;

            var data = void 0;

            if (value) {
                if (!this._cacheData) {
                    this._cacheData = new CacheData();
                }

                data = this._cacheData;

                data.originalRenderWebGL = this.renderWebGL;
                data.originalRenderCanvas = this.renderCanvas;

                data.originalUpdateTransform = this.updateTransform;
                data.originalCalculateBounds = this.calculateBounds;
                data.originalGetLocalBounds = this.getLocalBounds;

                data.originalDestroy = this.destroy;

                data.originalContainsPoint = this.containsPoint;

                data.originalMask = this._mask;
                data.originalFilterArea = this.filterArea;

                this.renderWebGL = this._renderCachedWebGL;
                this.renderCanvas = this._renderCachedCanvas;

                this.destroy = this._cacheAsBitmapDestroy;
            } else {
                data = this._cacheData;

                if (data.sprite) {
                    this._destroyCachedDisplayObject();
                }

                this.renderWebGL = data.originalRenderWebGL;
                this.renderCanvas = data.originalRenderCanvas;
                this.calculateBounds = data.originalCalculateBounds;
                this.getLocalBounds = data.originalGetLocalBounds;

                this.destroy = data.originalDestroy;

                this.updateTransform = data.originalUpdateTransform;
                this.containsPoint = data.originalContainsPoint;

                this._mask = data.originalMask;
                this.filterArea = data.originalFilterArea;
            }
        }
    }
});

/**
 * Renders a cached version of the sprite with WebGL
 *
 * @private
 * @memberof PIXI.DisplayObject#
 * @param {PIXI.WebGLRenderer} renderer - the WebGL renderer
 */
DisplayObject.prototype._renderCachedWebGL = function _renderCachedWebGL(renderer) {
    if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
        return;
    }

    this._initCachedDisplayObject(renderer);

    this._cacheData.sprite.transform._worldID = this.transform._worldID;
    this._cacheData.sprite.worldAlpha = this.worldAlpha;
    this._cacheData.sprite._renderWebGL(renderer);
};

/**
 * Prepares the WebGL renderer to cache the sprite
 *
 * @private
 * @memberof PIXI.DisplayObject#
 * @param {PIXI.WebGLRenderer} renderer - the WebGL renderer
 */
DisplayObject.prototype._initCachedDisplayObject = function _initCachedDisplayObject(renderer) {
    if (this._cacheData && this._cacheData.sprite) {
        return;
    }

    // make sure alpha is set to 1 otherwise it will get rendered as invisible!
    var cacheAlpha = this.alpha;

    this.alpha = 1;

    // first we flush anything left in the renderer (otherwise it would get rendered to the cached texture)
    renderer.currentRenderer.flush();
    // this.filters= [];

    // next we find the dimensions of the untransformed object
    // this function also calls updatetransform on all its children as part of the measuring.
    // This means we don't need to update the transform again in this function
    // TODO pass an object to clone too? saves having to create a new one each time!
    var bounds = this.getLocalBounds().clone();

    // add some padding!
    if (this._filters && this._filters.length) {
        var padding = this._filters[0].padding;

        bounds.pad(padding);
    }

    bounds.ceil(core.settings.RESOLUTION);

    // for now we cache the current renderTarget that the webGL renderer is currently using.
    // this could be more elegent..
    var cachedRenderTarget = renderer._activeRenderTarget;
    // We also store the filter stack - I will definitely look to change how this works a little later down the line.
    var stack = renderer.filterManager.filterStack;

    // this renderTexture will be used to store the cached DisplayObject

    var renderTexture = core.RenderTexture.create(bounds.width, bounds.height);

    var textureCacheId = 'cacheAsBitmap_' + (0, _utils.uid)();

    this._cacheData.textureCacheId = textureCacheId;

    _BaseTexture2.default.addToCache(renderTexture.baseTexture, textureCacheId);
    _Texture2.default.addToCache(renderTexture, textureCacheId);

    // need to set //
    var m = _tempMatrix;

    m.tx = -bounds.x;
    m.ty = -bounds.y;

    // reset
    this.transform.worldTransform.identity();

    // set all properties to there original so we can render to a texture
    this.renderWebGL = this._cacheData.originalRenderWebGL;

    renderer.render(this, renderTexture, true, m, true);
    // now restore the state be setting the new properties

    renderer.bindRenderTarget(cachedRenderTarget);

    renderer.filterManager.filterStack = stack;

    this.renderWebGL = this._renderCachedWebGL;
    // the rest is the same as for Canvas
    this.updateTransform = this.displayObjectUpdateTransform;
    this.calculateBounds = this._calculateCachedBounds;
    this.getLocalBounds = this._getCachedLocalBounds;

    this._mask = null;
    this.filterArea = null;

    // create our cached sprite
    var cachedSprite = new core.Sprite(renderTexture);

    cachedSprite.transform.worldTransform = this.transform.worldTransform;
    cachedSprite.anchor.x = -(bounds.x / bounds.width);
    cachedSprite.anchor.y = -(bounds.y / bounds.height);
    cachedSprite.alpha = cacheAlpha;
    cachedSprite._bounds = this._bounds;

    this._cacheData.sprite = cachedSprite;

    this.transform._parentID = -1;
    // restore the transform of the cached sprite to avoid the nasty flicker..
    if (!this.parent) {
        this.parent = renderer._tempDisplayObjectParent;
        this.updateTransform();
        this.parent = null;
    } else {
        this.updateTransform();
    }

    // map the hit test..
    this.containsPoint = cachedSprite.containsPoint.bind(cachedSprite);
};

/**
 * Renders a cached version of the sprite with canvas
 *
 * @private
 * @memberof PIXI.DisplayObject#
 * @param {PIXI.WebGLRenderer} renderer - the WebGL renderer
 */
DisplayObject.prototype._renderCachedCanvas = function _renderCachedCanvas(renderer) {
    if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
        return;
    }

    this._initCachedDisplayObjectCanvas(renderer);

    this._cacheData.sprite.worldAlpha = this.worldAlpha;
    this._cacheData.sprite._renderCanvas(renderer);
};

// TODO this can be the same as the webGL verison.. will need to do a little tweaking first though..
/**
 * Prepares the Canvas renderer to cache the sprite
 *
 * @private
 * @memberof PIXI.DisplayObject#
 * @param {PIXI.WebGLRenderer} renderer - the WebGL renderer
 */
DisplayObject.prototype._initCachedDisplayObjectCanvas = function _initCachedDisplayObjectCanvas(renderer) {
    if (this._cacheData && this._cacheData.sprite) {
        return;
    }

    // get bounds actually transforms the object for us already!
    var bounds = this.getLocalBounds();

    var cacheAlpha = this.alpha;

    this.alpha = 1;

    var cachedRenderTarget = renderer.context;

    bounds.ceil(core.settings.RESOLUTION);

    var renderTexture = core.RenderTexture.create(bounds.width, bounds.height);

    var textureCacheId = 'cacheAsBitmap_' + (0, _utils.uid)();

    this._cacheData.textureCacheId = textureCacheId;

    _BaseTexture2.default.addToCache(renderTexture.baseTexture, textureCacheId);
    _Texture2.default.addToCache(renderTexture, textureCacheId);

    // need to set //
    var m = _tempMatrix;

    this.transform.localTransform.copy(m);
    m.invert();

    m.tx -= bounds.x;
    m.ty -= bounds.y;

    // m.append(this.transform.worldTransform.)
    // set all properties to there original so we can render to a texture
    this.renderCanvas = this._cacheData.originalRenderCanvas;

    // renderTexture.render(this, m, true);
    renderer.render(this, renderTexture, true, m, false);

    // now restore the state be setting the new properties
    renderer.context = cachedRenderTarget;

    this.renderCanvas = this._renderCachedCanvas;
    // the rest is the same as for WebGL
    this.updateTransform = this.displayObjectUpdateTransform;
    this.calculateBounds = this._calculateCachedBounds;
    this.getLocalBounds = this._getCachedLocalBounds;

    this._mask = null;
    this.filterArea = null;

    // create our cached sprite
    var cachedSprite = new core.Sprite(renderTexture);

    cachedSprite.transform.worldTransform = this.transform.worldTransform;
    cachedSprite.anchor.x = -(bounds.x / bounds.width);
    cachedSprite.anchor.y = -(bounds.y / bounds.height);
    cachedSprite.alpha = cacheAlpha;
    cachedSprite._bounds = this._bounds;

    this._cacheData.sprite = cachedSprite;

    this.transform._parentID = -1;
    // restore the transform of the cached sprite to avoid the nasty flicker..
    if (!this.parent) {
        this.parent = renderer._tempDisplayObjectParent;
        this.updateTransform();
        this.parent = null;
    } else {
        this.updateTransform();
    }

    // map the hit test..
    this.containsPoint = cachedSprite.containsPoint.bind(cachedSprite);
};

/**
 * Calculates the bounds of the cached sprite
 *
 * @private
 */
DisplayObject.prototype._calculateCachedBounds = function _calculateCachedBounds() {
    this._bounds.clear();
    this._cacheData.sprite.transform._worldID = this.transform._worldID;
    this._cacheData.sprite._calculateBounds();
    this._lastBoundsID = this._boundsID;
};

/**
 * Gets the bounds of the cached sprite.
 *
 * @private
 * @return {Rectangle} The local bounds.
 */
DisplayObject.prototype._getCachedLocalBounds = function _getCachedLocalBounds() {
    return this._cacheData.sprite.getLocalBounds();
};

/**
 * Destroys the cached sprite.
 *
 * @private
 */
DisplayObject.prototype._destroyCachedDisplayObject = function _destroyCachedDisplayObject() {
    this._cacheData.sprite._texture.destroy(true);
    this._cacheData.sprite = null;

    _BaseTexture2.default.removeFromCache(this._cacheData.textureCacheId);
    _Texture2.default.removeFromCache(this._cacheData.textureCacheId);

    this._cacheData.textureCacheId = null;
};

/**
 * Destroys the cached object.
 *
 * @private
 * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options
 *  have been set to that value.
 *  Used when destroying containers, see the Container.destroy method.
 */
DisplayObject.prototype._cacheAsBitmapDestroy = function _cacheAsBitmapDestroy(options) {
    this.cacheAsBitmap = false;
    this.destroy(options);
};

},{"../core":72,"../core/textures/BaseTexture":119,"../core/textures/Texture":122,"../core/utils":132}],146:[function(require,module,exports){
'use strict';

var _core = require('../core');

var core = _interopRequireWildcard(_core);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * The instance name of the object.
 *
 * @memberof PIXI.DisplayObject#
 * @member {string} name
 */
core.DisplayObject.prototype.name = null;

/**
 * Returns the display object in the container
 *
 * @method getChildByName
 * @memberof PIXI.Container#
 * @param {string} name - instance name
 * @return {PIXI.DisplayObject} The child with the specified name.
 */
core.Container.prototype.getChildByName = function getChildByName(name) {
    for (var i = 0; i < this.children.length; i++) {
        if (this.children[i].name === name) {
            return this.children[i];
        }
    }

    return null;
};

},{"../core":72}],147:[function(require,module,exports){
'use strict';

var _core = require('../core');

var core = _interopRequireWildcard(_core);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * Returns the global position of the displayObject. Does not depend on object scale, rotation and pivot.
 *
 * @method getGlobalPosition
 * @memberof PIXI.DisplayObject#
 * @param {Point} point - the point to write the global value to. If null a new point will be returned
 * @param {boolean} skipUpdate - setting to true will stop the transforms of the scene graph from
 *  being updated. This means the calculation returned MAY be out of date BUT will give you a
 *  nice performance boost
 * @return {Point} The updated point
 */
core.DisplayObject.prototype.getGlobalPosition = function getGlobalPosition() {
    var point = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new core.Point();
    var skipUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    if (this.parent) {
        this.parent.toGlobal(this.position, point, skipUpdate);
    } else {
        point.x = this.position.x;
        point.y = this.position.y;
    }

    return point;
};

},{"../core":72}],148:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.BitmapText = exports.TilingSpriteRenderer = exports.TilingSprite = exports.AnimatedSprite = undefined;

var _AnimatedSprite = require('./AnimatedSprite');

Object.defineProperty(exports, 'AnimatedSprite', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_AnimatedSprite).default;
  }
});

var _TilingSprite = require('./TilingSprite');

Object.defineProperty(exports, 'TilingSprite', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_TilingSprite).default;
  }
});

var _TilingSpriteRenderer = require('./webgl/TilingSpriteRenderer');

Object.defineProperty(exports, 'TilingSpriteRenderer', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_TilingSpriteRenderer).default;
  }
});

var _BitmapText = require('./BitmapText');

Object.defineProperty(exports, 'BitmapText', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_BitmapText).default;
  }
});

require('./cacheAsBitmap');

require('./getChildByName');

require('./getGlobalPosition');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// imported for side effect of extending the prototype only, contains no exports

},{"./AnimatedSprite":142,"./BitmapText":143,"./TilingSprite":144,"./cacheAsBitmap":145,"./getChildByName":146,"./getGlobalPosition":147,"./webgl/TilingSpriteRenderer":149}],149:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _core = require('../../core');

var core = _interopRequireWildcard(_core);

var _const = require('../../core/const');

var _path = require('path');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var tempMat = new core.Matrix();

/**
 * WebGL renderer plugin for tiling sprites
 *
 * @class
 * @memberof PIXI.extras
 * @extends PIXI.ObjectRenderer
 */

var TilingSpriteRenderer = function (_core$ObjectRenderer) {
    _inherits(TilingSpriteRenderer, _core$ObjectRenderer);

    /**
     * constructor for renderer
     *
     * @param {WebGLRenderer} renderer The renderer this tiling awesomeness works for.
     */
    function TilingSpriteRenderer(renderer) {
        _classCallCheck(this, TilingSpriteRenderer);

        var _this = _possibleConstructorReturn(this, _core$ObjectRenderer.call(this, renderer));

        _this.shader = null;
        _this.simpleShader = null;
        _this.quad = null;
        return _this;
    }

    /**
     * Sets up the renderer context and necessary buffers.
     *
     * @private
     */


    TilingSpriteRenderer.prototype.onContextChange = function onContextChange() {
        var gl = this.renderer.gl;

        this.shader = new core.Shader(gl, 'attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n', 'varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\nuniform mat3 uMapCoord;\nuniform vec4 uClampFrame;\nuniform vec2 uClampOffset;\n\nvoid main(void)\n{\n    vec2 coord = mod(vTextureCoord - uClampOffset, vec2(1.0, 1.0)) + uClampOffset;\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n    vec4 sample = texture2D(uSampler, coord);\n    gl_FragColor = sample * uColor;\n}\n');
        this.simpleShader = new core.Shader(gl, 'attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n', 'varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\n\nvoid main(void)\n{\n    vec4 sample = texture2D(uSampler, vTextureCoord);\n    gl_FragColor = sample * uColor;\n}\n');

        this.renderer.bindVao(null);
        this.quad = new core.Quad(gl, this.renderer.state.attribState);
        this.quad.initVao(this.shader);
    };

    /**
     *
     * @param {PIXI.extras.TilingSprite} ts tilingSprite to be rendered
     */


    TilingSpriteRenderer.prototype.render = function render(ts) {
        var renderer = this.renderer;
        var quad = this.quad;

        renderer.bindVao(quad.vao);

        var vertices = quad.vertices;

        vertices[0] = vertices[6] = ts._width * -ts.anchor.x;
        vertices[1] = vertices[3] = ts._height * -ts.anchor.y;

        vertices[2] = vertices[4] = ts._width * (1.0 - ts.anchor.x);
        vertices[5] = vertices[7] = ts._height * (1.0 - ts.anchor.y);

        if (ts.uvRespectAnchor) {
            vertices = quad.uvs;

            vertices[0] = vertices[6] = -ts.anchor.x;
            vertices[1] = vertices[3] = -ts.anchor.y;

            vertices[2] = vertices[4] = 1.0 - ts.anchor.x;
            vertices[5] = vertices[7] = 1.0 - ts.anchor.y;
        }

        quad.upload();

        var tex = ts._texture;
        var baseTex = tex.baseTexture;
        var lt = ts.tileTransform.localTransform;
        var uv = ts.uvTransform;
        var isSimple = baseTex.isPowerOfTwo && tex.frame.width === baseTex.width && tex.frame.height === baseTex.height;

        // auto, force repeat wrapMode for big tiling textures
        if (isSimple) {
            if (!baseTex._glTextures[renderer.CONTEXT_UID]) {
                if (baseTex.wrapMode === _const.WRAP_MODES.CLAMP) {
                    baseTex.wrapMode = _const.WRAP_MODES.REPEAT;
                }
            } else {
                isSimple = baseTex.wrapMode !== _const.WRAP_MODES.CLAMP;
            }
        }

        var shader = isSimple ? this.simpleShader : this.shader;

        renderer.bindShader(shader);

        var w = tex.width;
        var h = tex.height;
        var W = ts._width;
        var H = ts._height;

        tempMat.set(lt.a * w / W, lt.b * w / H, lt.c * h / W, lt.d * h / H, lt.tx / W, lt.ty / H);

        // that part is the same as above:
        // tempMat.identity();
        // tempMat.scale(tex.width, tex.height);
        // tempMat.prepend(lt);
        // tempMat.scale(1.0 / ts._width, 1.0 / ts._height);

        tempMat.invert();
        if (isSimple) {
            tempMat.prepend(uv.mapCoord);
        } else {
            shader.uniforms.uMapCoord = uv.mapCoord.toArray(true);
            shader.uniforms.uClampFrame = uv.uClampFrame;
            shader.uniforms.uClampOffset = uv.uClampOffset;
        }

        shader.uniforms.uTransform = tempMat.toArray(true);
        shader.uniforms.uColor = core.utils.premultiplyTintToRgba(ts.tint, ts.worldAlpha, shader.uniforms.uColor, baseTex.premultipliedAlpha);
        shader.uniforms.translationMatrix = ts.transform.worldTransform.toArray(true);

        shader.uniforms.uSampler = renderer.bindTexture(tex);

        renderer.setBlendMode(core.utils.correctBlendMode(ts.blendMode, baseTex.premultipliedAlpha));

        quad.vao.draw(this.renderer.gl.TRIANGLES, 6, 0);
    };

    return TilingSpriteRenderer;
}(core.ObjectRenderer);

exports.default = TilingSpriteRenderer;


core.WebGLRenderer.registerPlugin('tilingSprite', TilingSpriteRenderer);

},{"../../core":72,"../../core/const":53,"path":1}],150:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _core = require('../../core');

var core = _interopRequireWildcard(_core);

var _path = require('path');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Simplest filter - applies alpha
 *
 * Use this instead of Container's alpha property to avoid visual layering of individual elements.
 * AlphaFilter applies alpha evenly across the entire display object and any opaque elements it contains.
 * If elements are not opaque, they will blend with each other anyway.
 *
 * Very handy if you want to use common features of all filters:
 *
 * 1. Assign a blendMode to this filter, blend all elements inside display object with background.
 *
 * 2. To use clipping in display coordinates, assign a filterArea to the same container that has this filter.
 *
 * @class
 * @extends PIXI.Filter
 * @memberof PIXI.filters
 */
var AlphaFilter = function (_core$Filter) {
    _inherits(AlphaFilter, _core$Filter);

    /**
     * @param {number} [alpha=1] Amount of alpha from 0 to 1, where 0 is transparent
     */
    function AlphaFilter() {
        var alpha = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1.0;

        _classCallCheck(this, AlphaFilter);

        var _this = _possibleConstructorReturn(this, _core$Filter.call(this,
        // vertex shader
        'attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}',
        // fragment shader
        'varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float uAlpha;\n\nvoid main(void)\n{\n   gl_FragColor = texture2D(uSampler, vTextureCoord) * uAlpha;\n}\n'));

        _this.alpha = alpha;
        _this.glShaderKey = 'alpha';
        return _this;
    }

    /**
     * Coefficient for alpha multiplication
     *
     * @member {number}
     * @default 1
     */


    _createClass(AlphaFilter, [{
        key: 'alpha',
        get: function get() {
            return this.uniforms.uAlpha;
        },
        set: function set(value) // eslint-disable-line require-jsdoc
        {
            this.uniforms.uAlpha = value;
        }
    }]);

    return AlphaFilter;
}(core.Filter);

exports.default = AlphaFilter;

},{"../../core":72,"path":1}],151:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _core = require('../../core');

var core = _interopRequireWildcard(_core);

var _BlurXFilter = require('./BlurXFilter');

var _BlurXFilter2 = _interopRequireDefault(_BlurXFilter);

var _BlurYFilter = require('./BlurYFilter');

var _BlurYFilter2 = _interopRequireDefault(_BlurYFilter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The BlurFilter applies a Gaussian blur to an object.
 * The strength of the blur can be set for x- and y-axis separately.
 *
 * @class
 * @extends PIXI.Filter
 * @memberof PIXI.filters
 */
var BlurFilter = function (_core$Filter) {
    _inherits(BlurFilter, _core$Filter);

    /**
     * @param {number} strength - The strength of the blur filter.
     * @param {number} quality - The quality of the blur filter.
     * @param {number} resolution - The resolution of the blur filter.
     * @param {number} [kernelSize=5] - The kernelSize of the blur filter.Options: 5, 7, 9, 11, 13, 15.
     */
    function BlurFilter(strength, quality, resolution, kernelSize) {
        _classCallCheck(this, BlurFilter);

        var _this = _possibleConstructorReturn(this, _core$Filter.call(this));

        _this.blurXFilter = new _BlurXFilter2.default(strength, quality, resolution, kernelSize);
        _this.blurYFilter = new _BlurYFilter2.default(strength, quality, resolution, kernelSize);

        _this.padding = 0;
        _this.resolution = resolution || core.settings.RESOLUTION;
        _this.quality = quality || 4;
        _this.blur = strength || 8;
        return _this;
    }

    /**
     * Applies the filter.
     *
     * @param {PIXI.FilterManager} filterManager - The manager.
     * @param {PIXI.RenderTarget} input - The input target.
     * @param {PIXI.RenderTarget} output - The output target.
     */


    BlurFilter.prototype.apply = function apply(filterManager, input, output) {
        var renderTarget = filterManager.getRenderTarget(true);

        this.blurXFilter.apply(filterManager, input, renderTarget, true);
        this.blurYFilter.apply(filterManager, renderTarget, output, false);

        filterManager.returnRenderTarget(renderTarget);
    };

    /**
     * Sets the strength of both the blurX and blurY properties simultaneously
     *
     * @member {number}
     * @default 2
     */


    _createClass(BlurFilter, [{
        key: 'blur',
        get: function get() {
            return this.blurXFilter.blur;
        },
        set: function set(value) // eslint-disable-line require-jsdoc
        {
            this.blurXFilter.blur = this.blurYFilter.blur = value;
            this.padding = Math.max(Math.abs(this.blurXFilter.strength), Math.abs(this.blurYFilter.strength)) * 2;
        }

        /**
         * Sets the number of passes for blur. More passes means higher quaility bluring.
         *
         * @member {number}
         * @default 1
         */

    }, {
        key: 'quality',
        get: function get() {
            return this.blurXFilter.quality;
        },
        set: function set(value) // eslint-disable-line require-jsdoc
        {
            this.blurXFilter.quality = this.blurYFilter.quality = value;
        }

        /**
         * Sets the strength of the blurX property
         *
         * @member {number}
         * @default 2
         */

    }, {
        key: 'blurX',
        get: function get() {
            return this.blurXFilter.blur;
        },
        set: function set(value) // eslint-disable-line require-jsdoc
        {
            this.blurXFilter.blur = value;
            this.padding = Math.max(Math.abs(this.blurXFilter.strength), Math.abs(this.blurYFilter.strength)) * 2;
        }

        /**
         * Sets the strength of the blurY property
         *
         * @member {number}
         * @default 2
         */

    }, {
        key: 'blurY',
        get: function get() {
            return this.blurYFilter.blur;
        },
        set: function set(value) // eslint-disable-line require-jsdoc
        {
            this.blurYFilter.blur = value;
            this.padding = Math.max(Math.abs(this.blurXFilter.strength), Math.abs(this.blurYFilter.strength)) * 2;
        }

        /**
         * Sets the blendmode of the filter
         *
         * @member {number}
         * @default PIXI.BLEND_MODES.NORMAL
         */

    }, {
        key: 'blendMode',
        get: function get() {
            return this.blurYFilter._blendMode;
        },
        set: function set(value) // eslint-disable-line require-jsdoc
        {
            this.blurYFilter._blendMode = value;
        }
    }]);

    return BlurFilter;
}(core.Filter);

exports.default = BlurFilter;

},{"../../core":72,"./BlurXFilter":152,"./BlurYFilter":153}],152:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _core = require('../../core');

var core = _interopRequireWildcard(_core);

var _generateBlurVertSource = require('./generateBlurVertSource');

var _generateBlurVertSource2 = _interopRequireDefault(_generateBlurVertSource);

var _generateBlurFragSource = require('./generateBlurFragSource');

var _generateBlurFragSource2 = _interopRequireDefault(_generateBlurFragSource);

var _getMaxBlurKernelSize = require('./getMaxBlurKernelSize');

var _getMaxBlurKernelSize2 = _interopRequireDefault(_getMaxBlurKernelSize);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The BlurXFilter applies a horizontal Gaussian blur to an object.
 *
 * @class
 * @extends PIXI.Filter
 * @memberof PIXI.filters
 */
var BlurXFilter = function (_core$Filter) {
    _inherits(BlurXFilter, _core$Filter);

    /**
     * @param {number} strength - The strength of the blur filter.
     * @param {number} quality - The quality of the blur filter.
     * @param {number} resolution - The resolution of the blur filter.
     * @param {number} [kernelSize=5] - The kernelSize of the blur filter.Options: 5, 7, 9, 11, 13, 15.
     */
    function BlurXFilter(strength, quality, resolution, kernelSize) {
        _classCallCheck(this, BlurXFilter);

        kernelSize = kernelSize || 5;
        var vertSrc = (0, _generateBlurVertSource2.default)(kernelSize, true);
        var fragSrc = (0, _generateBlurFragSource2.default)(kernelSize);

        var _this = _possibleConstructorReturn(this, _core$Filter.call(this,
        // vertex shader
        vertSrc,
        // fragment shader
        fragSrc));

        _this.resolution = resolution || core.settings.RESOLUTION;

        _this._quality = 0;

        _this.quality = quality || 4;
        _this.strength = strength || 8;

        _this.firstRun = true;
        return _this;
    }

    /**
     * Applies the filter.
     *
     * @param {PIXI.FilterManager} filterManager - The manager.
     * @param {PIXI.RenderTarget} input - The input target.
     * @param {PIXI.RenderTarget} output - The output target.
     * @param {boolean} clear - Should the output be cleared before rendering?
     */


    BlurXFilter.prototype.apply = function apply(filterManager, input, output, clear) {
        if (this.firstRun) {
            var gl = filterManager.renderer.gl;
            var kernelSize = (0, _getMaxBlurKernelSize2.default)(gl);

            this.vertexSrc = (0, _generateBlurVertSource2.default)(kernelSize, true);
            this.fragmentSrc = (0, _generateBlurFragSource2.default)(kernelSize);

            this.firstRun = false;
        }

        this.uniforms.strength = 1 / output.size.width * (output.size.width / input.size.width);

        // screen space!
        this.uniforms.strength *= this.strength;
        this.uniforms.strength /= this.passes; // / this.passes//Math.pow(1, this.passes);

        if (this.passes === 1) {
            filterManager.applyFilter(this, input, output, clear);
        } else {
            var renderTarget = filterManager.getRenderTarget(true);
            var flip = input;
            var flop = renderTarget;

            for (var i = 0; i < this.passes - 1; i++) {
                filterManager.applyFilter(this, flip, flop, true);

                var temp = flop;

                flop = flip;
                flip = temp;
            }

            filterManager.applyFilter(this, flip, output, clear);

            filterManager.returnRenderTarget(renderTarget);
        }
    };

    /**
     * Sets the strength of both the blur.
     *
     * @member {number}
     * @default 16
     */


    _createClass(BlurXFilter, [{
        key: 'blur',
        get: function get() {
            return this.strength;
        },
        set: function set(value) // eslint-disable-line require-jsdoc
        {
            this.padding = Math.abs(value) * 2;
            this.strength = value;
        }

        /**
        * Sets the quality of the blur by modifying the number of passes. More passes means higher
        * quaility bluring but the lower the performance.
        *
        * @member {number}
        * @default 4
        */

    }, {
        key: 'quality',
        get: function get() {
            return this._quality;
        },
        set: function set(value) // eslint-disable-line require-jsdoc
        {
            this._quality = value;
            this.passes = value;
        }
    }]);

    return BlurXFilter;
}(core.Filter);

exports.default = BlurXFilter;

},{"../../core":72,"./generateBlurFragSource":154,"./generateBlurVertSource":155,"./getMaxBlurKernelSize":156}],153:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _core = require('../../core');

var core = _interopRequireWildcard(_core);

var _generateBlurVertSource = require('./generateBlurVertSource');

var _generateBlurVertSource2 = _interopRequireDefault(_generateBlurVertSource);

var _generateBlurFragSource = require('./generateBlurFragSource');

var _generateBlurFragSource2 = _interopRequireDefault(_generateBlurFragSource);

var _getMaxBlurKernelSize = require('./getMaxBlurKernelSize');

var _getMaxBlurKernelSize2 = _interopRequireDefault(_getMaxBlurKernelSize);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The BlurYFilter applies a horizontal Gaussian blur to an object.
 *
 * @class
 * @extends PIXI.Filter
 * @memberof PIXI.filters
 */
var BlurYFilter = function (_core$Filter) {
    _inherits(BlurYFilter, _core$Filter);

    /**
     * @param {number} strength - The strength of the blur filter.
     * @param {number} quality - The quality of the blur filter.
     * @param {number} resolution - The resolution of the blur filter.
     * @param {number} [kernelSize=5] - The kernelSize of the blur filter.Options: 5, 7, 9, 11, 13, 15.
     */
    function BlurYFilter(strength, quality, resolution, kernelSize) {
        _classCallCheck(this, BlurYFilter);

        kernelSize = kernelSize || 5;
        var vertSrc = (0, _generateBlurVertSource2.default)(kernelSize, false);
        var fragSrc = (0, _generateBlurFragSource2.default)(kernelSize);

        var _this = _possibleConstructorReturn(this, _core$Filter.call(this,
        // vertex shader
        vertSrc,
        // fragment shader
        fragSrc));

        _this.resolution = resolution || core.settings.RESOLUTION;

        _this._quality = 0;

        _this.quality = quality || 4;
        _this.strength = strength || 8;

        _this.firstRun = true;
        return _this;
    }

    /**
     * Applies the filter.
     *
     * @param {PIXI.FilterManager} filterManager - The manager.
     * @param {PIXI.RenderTarget} input - The input target.
     * @param {PIXI.RenderTarget} output - The output target.
     * @param {boolean} clear - Should the output be cleared before rendering?
     */


    BlurYFilter.prototype.apply = function apply(filterManager, input, output, clear) {
        if (this.firstRun) {
            var gl = filterManager.renderer.gl;
            var kernelSize = (0, _getMaxBlurKernelSize2.default)(gl);

            this.vertexSrc = (0, _generateBlurVertSource2.default)(kernelSize, false);
            this.fragmentSrc = (0, _generateBlurFragSource2.default)(kernelSize);

            this.firstRun = false;
        }

        this.uniforms.strength = 1 / output.size.height * (output.size.height / input.size.height);

        this.uniforms.strength *= this.strength;
        this.uniforms.strength /= this.passes;

        if (this.passes === 1) {
            filterManager.applyFilter(this, input, output, clear);
        } else {
            var renderTarget = filterManager.getRenderTarget(true);
            var flip = input;
            var flop = renderTarget;

            for (var i = 0; i < this.passes - 1; i++) {
                filterManager.applyFilter(this, flip, flop, true);

                var temp = flop;

                flop = flip;
                flip = temp;
            }

            filterManager.applyFilter(this, flip, output, clear);

            filterManager.returnRenderTarget(renderTarget);
        }
    };

    /**
     * Sets the strength of both the blur.
     *
     * @member {number}
     * @default 2
     */


    _createClass(BlurYFilter, [{
        key: 'blur',
        get: function get() {
            return this.strength;
        },
        set: function set(value) // eslint-disable-line require-jsdoc
        {
            this.padding = Math.abs(value) * 2;
            this.strength = value;
        }

        /**
         * Sets the quality of the blur by modifying the number of passes. More passes means higher
         * quaility bluring but the lower the performance.
         *
         * @member {number}
         * @default 4
         */

    }, {
        key: 'quality',
        get: function get() {
            return this._quality;
        },
        set: function set(value) // eslint-disable-line require-jsdoc
        {
            this._quality = value;
            this.passes = value;
        }
    }]);

    return BlurYFilter;
}(core.Filter);

exports.default = BlurYFilter;

},{"../../core":72,"./generateBlurFragSource":154,"./generateBlurVertSource":155,"./getMaxBlurKernelSize":156}],154:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.default = generateFragBlurSource;
var GAUSSIAN_VALUES = {
    5: [0.153388, 0.221461, 0.250301],
    7: [0.071303, 0.131514, 0.189879, 0.214607],
    9: [0.028532, 0.067234, 0.124009, 0.179044, 0.20236],
    11: [0.0093, 0.028002, 0.065984, 0.121703, 0.175713, 0.198596],
    13: [0.002406, 0.009255, 0.027867, 0.065666, 0.121117, 0.174868, 0.197641],
    15: [0.000489, 0.002403, 0.009246, 0.02784, 0.065602, 0.120999, 0.174697, 0.197448]
};

var fragTemplate = ['varying vec2 vBlurTexCoords[%size%];', 'uniform sampler2D uSampler;', 'void main(void)', '{', '    gl_FragColor = vec4(0.0);', '    %blur%', '}'].join('\n');

function generateFragBlurSource(kernelSize) {
    var kernel = GAUSSIAN_VALUES[kernelSize];
    var halfLength = kernel.length;

    var fragSource = fragTemplate;

    var blurLoop = '';
    var template = 'gl_FragColor += texture2D(uSampler, vBlurTexCoords[%index%]) * %value%;';
    var value = void 0;

    for (var i = 0; i < kernelSize; i++) {
        var blur = template.replace('%index%', i);

        value = i;

        if (i >= halfLength) {
            value = kernelSize - i - 1;
        }

        blur = blur.replace('%value%', kernel[value]);

        blurLoop += blur;
        blurLoop += '\n';
    }

    fragSource = fragSource.replace('%blur%', blurLoop);
    fragSource = fragSource.replace('%size%', kernelSize);

    return fragSource;
}

},{}],155:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.default = generateVertBlurSource;
var vertTemplate = ['attribute vec2 aVertexPosition;', 'attribute vec2 aTextureCoord;', 'uniform float strength;', 'uniform mat3 projectionMatrix;', 'varying vec2 vBlurTexCoords[%size%];', 'void main(void)', '{', 'gl_Position = vec4((projectionMatrix * vec3((aVertexPosition), 1.0)).xy, 0.0, 1.0);', '%blur%', '}'].join('\n');

function generateVertBlurSource(kernelSize, x) {
    var halfLength = Math.ceil(kernelSize / 2);

    var vertSource = vertTemplate;

    var blurLoop = '';
    var template = void 0;
    // let value;

    if (x) {
        template = 'vBlurTexCoords[%index%] = aTextureCoord + vec2(%sampleIndex% * strength, 0.0);';
    } else {
        template = 'vBlurTexCoords[%index%] = aTextureCoord + vec2(0.0, %sampleIndex% * strength);';
    }

    for (var i = 0; i < kernelSize; i++) {
        var blur = template.replace('%index%', i);

        // value = i;

        // if(i >= halfLength)
        // {
        //     value = kernelSize - i - 1;
        // }

        blur = blur.replace('%sampleIndex%', i - (halfLength - 1) + '.0');

        blurLoop += blur;
        blurLoop += '\n';
    }

    vertSource = vertSource.replace('%blur%', blurLoop);
    vertSource = vertSource.replace('%size%', kernelSize);

    return vertSource;
}

},{}],156:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.default = getMaxKernelSize;
function getMaxKernelSize(gl) {
    var maxVaryings = gl.getParameter(gl.MAX_VARYING_VECTORS);
    var kernelSize = 15;

    while (kernelSize > maxVaryings) {
        kernelSize -= 2;
    }

    return kernelSize;
}

},{}],157:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _core = require('../../core');

var core = _interopRequireWildcard(_core);

var _path = require('path');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ColorMatrixFilter class lets you apply a 5x4 matrix transformation on the RGBA
 * color and alpha values of every pixel on your displayObject to produce a result
 * with a new set of RGBA color and alpha values. It's pretty powerful!
 *
 * ```js
 *  let colorMatrix = new PIXI.filters.ColorMatrixFilter();
 *  container.filters = [colorMatrix];
 *  colorMatrix.contrast(2);
 * ```
 * @author Clément Chenebault <clement@goodboydigital.com>
 * @class
 * @extends PIXI.Filter
 * @memberof PIXI.filters
 */
var ColorMatrixFilter = function (_core$Filter) {
    _inherits(ColorMatrixFilter, _core$Filter);

    /**
     *
     */
    function ColorMatrixFilter() {
        _classCallCheck(this, ColorMatrixFilter);

        var _this = _possibleConstructorReturn(this, _core$Filter.call(this,
        // vertex shader
        'attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}',
        // fragment shader
        'varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform float m[20];\nuniform float uAlpha;\n\nvoid main(void)\n{\n    vec4 c = texture2D(uSampler, vTextureCoord);\n\n    if (uAlpha == 0.0) {\n        gl_FragColor = c;\n        return;\n    }\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (c.a > 0.0) {\n      c.rgb /= c.a;\n    }\n\n    vec4 result;\n\n    result.r = (m[0] * c.r);\n        result.r += (m[1] * c.g);\n        result.r += (m[2] * c.b);\n        result.r += (m[3] * c.a);\n        result.r += m[4];\n\n    result.g = (m[5] * c.r);\n        result.g += (m[6] * c.g);\n        result.g += (m[7] * c.b);\n        result.g += (m[8] * c.a);\n        result.g += m[9];\n\n    result.b = (m[10] * c.r);\n       result.b += (m[11] * c.g);\n       result.b += (m[12] * c.b);\n       result.b += (m[13] * c.a);\n       result.b += m[14];\n\n    result.a = (m[15] * c.r);\n       result.a += (m[16] * c.g);\n       result.a += (m[17] * c.b);\n       result.a += (m[18] * c.a);\n       result.a += m[19];\n\n    vec3 rgb = mix(c.rgb, result.rgb, uAlpha);\n\n    // Premultiply alpha again.\n    rgb *= result.a;\n\n    gl_FragColor = vec4(rgb, result.a);\n}\n'));

        _this.uniforms.m = [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0];

        _this.alpha = 1;
        return _this;
    }

    /**
     * Transforms current matrix and set the new one
     *
     * @param {number[]} matrix - 5x4 matrix
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */


    ColorMatrixFilter.prototype._loadMatrix = function _loadMatrix(matrix) {
        var multiply = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

        var newMatrix = matrix;

        if (multiply) {
            this._multiply(newMatrix, this.uniforms.m, matrix);
            newMatrix = this._colorMatrix(newMatrix);
        }

        // set the new matrix
        this.uniforms.m = newMatrix;
    };

    /**
     * Multiplies two mat5's
     *
     * @private
     * @param {number[]} out - 5x4 matrix the receiving matrix
     * @param {number[]} a - 5x4 matrix the first operand
     * @param {number[]} b - 5x4 matrix the second operand
     * @returns {number[]} 5x4 matrix
     */


    ColorMatrixFilter.prototype._multiply = function _multiply(out, a, b) {
        // Red Channel
        out[0] = a[0] * b[0] + a[1] * b[5] + a[2] * b[10] + a[3] * b[15];
        out[1] = a[0] * b[1] + a[1] * b[6] + a[2] * b[11] + a[3] * b[16];
        out[2] = a[0] * b[2] + a[1] * b[7] + a[2] * b[12] + a[3] * b[17];
        out[3] = a[0] * b[3] + a[1] * b[8] + a[2] * b[13] + a[3] * b[18];
        out[4] = a[0] * b[4] + a[1] * b[9] + a[2] * b[14] + a[3] * b[19] + a[4];

        // Green Channel
        out[5] = a[5] * b[0] + a[6] * b[5] + a[7] * b[10] + a[8] * b[15];
        out[6] = a[5] * b[1] + a[6] * b[6] + a[7] * b[11] + a[8] * b[16];
        out[7] = a[5] * b[2] + a[6] * b[7] + a[7] * b[12] + a[8] * b[17];
        out[8] = a[5] * b[3] + a[6] * b[8] + a[7] * b[13] + a[8] * b[18];
        out[9] = a[5] * b[4] + a[6] * b[9] + a[7] * b[14] + a[8] * b[19] + a[9];

        // Blue Channel
        out[10] = a[10] * b[0] + a[11] * b[5] + a[12] * b[10] + a[13] * b[15];
        out[11] = a[10] * b[1] + a[11] * b[6] + a[12] * b[11] + a[13] * b[16];
        out[12] = a[10] * b[2] + a[11] * b[7] + a[12] * b[12] + a[13] * b[17];
        out[13] = a[10] * b[3] + a[11] * b[8] + a[12] * b[13] + a[13] * b[18];
        out[14] = a[10] * b[4] + a[11] * b[9] + a[12] * b[14] + a[13] * b[19] + a[14];

        // Alpha Channel
        out[15] = a[15] * b[0] + a[16] * b[5] + a[17] * b[10] + a[18] * b[15];
        out[16] = a[15] * b[1] + a[16] * b[6] + a[17] * b[11] + a[18] * b[16];
        out[17] = a[15] * b[2] + a[16] * b[7] + a[17] * b[12] + a[18] * b[17];
        out[18] = a[15] * b[3] + a[16] * b[8] + a[17] * b[13] + a[18] * b[18];
        out[19] = a[15] * b[4] + a[16] * b[9] + a[17] * b[14] + a[18] * b[19] + a[19];

        return out;
    };

    /**
     * Create a Float32 Array and normalize the offset component to 0-1
     *
     * @private
     * @param {number[]} matrix - 5x4 matrix
     * @return {number[]} 5x4 matrix with all values between 0-1
     */


    ColorMatrixFilter.prototype._colorMatrix = function _colorMatrix(matrix) {
        // Create a Float32 Array and normalize the offset component to 0-1
        var m = new Float32Array(matrix);

        m[4] /= 255;
        m[9] /= 255;
        m[14] /= 255;
        m[19] /= 255;

        return m;
    };

    /**
     * Adjusts brightness
     *
     * @param {number} b - value of the brigthness (0-1, where 0 is black)
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */


    ColorMatrixFilter.prototype.brightness = function brightness(b, multiply) {
        var matrix = [b, 0, 0, 0, 0, 0, b, 0, 0, 0, 0, 0, b, 0, 0, 0, 0, 0, 1, 0];

        this._loadMatrix(matrix, multiply);
    };

    /**
     * Set the matrices in grey scales
     *
     * @param {number} scale - value of the grey (0-1, where 0 is black)
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */


    ColorMatrixFilter.prototype.greyscale = function greyscale(scale, multiply) {
        var matrix = [scale, scale, scale, 0, 0, scale, scale, scale, 0, 0, scale, scale, scale, 0, 0, 0, 0, 0, 1, 0];

        this._loadMatrix(matrix, multiply);
    };

    /**
     * Set the black and white matrice.
     *
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */


    ColorMatrixFilter.prototype.blackAndWhite = function blackAndWhite(multiply) {
        var matrix = [0.3, 0.6, 0.1, 0, 0, 0.3, 0.6, 0.1, 0, 0, 0.3, 0.6, 0.1, 0, 0, 0, 0, 0, 1, 0];

        this._loadMatrix(matrix, multiply);
    };

    /**
     * Set the hue property of the color
     *
     * @param {number} rotation - in degrees
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */


    ColorMatrixFilter.prototype.hue = function hue(rotation, multiply) {
        rotation = (rotation || 0) / 180 * Math.PI;

        var cosR = Math.cos(rotation);
        var sinR = Math.sin(rotation);
        var sqrt = Math.sqrt;

        /* a good approximation for hue rotation
         This matrix is far better than the versions with magic luminance constants
         formerly used here, but also used in the starling framework (flash) and known from this
         old part of the internet: quasimondo.com/archives/000565.php
          This new matrix is based on rgb cube rotation in space. Look here for a more descriptive
         implementation as a shader not a general matrix:
         https://github.com/evanw/glfx.js/blob/58841c23919bd59787effc0333a4897b43835412/src/filters/adjust/huesaturation.js
          This is the source for the code:
         see http://stackoverflow.com/questions/8507885/shift-hue-of-an-rgb-color/8510751#8510751
         */

        var w = 1 / 3;
        var sqrW = sqrt(w); // weight is

        var a00 = cosR + (1.0 - cosR) * w;
        var a01 = w * (1.0 - cosR) - sqrW * sinR;
        var a02 = w * (1.0 - cosR) + sqrW * sinR;

        var a10 = w * (1.0 - cosR) + sqrW * sinR;
        var a11 = cosR + w * (1.0 - cosR);
        var a12 = w * (1.0 - cosR) - sqrW * sinR;

        var a20 = w * (1.0 - cosR) - sqrW * sinR;
        var a21 = w * (1.0 - cosR) + sqrW * sinR;
        var a22 = cosR + w * (1.0 - cosR);

        var matrix = [a00, a01, a02, 0, 0, a10, a11, a12, 0, 0, a20, a21, a22, 0, 0, 0, 0, 0, 1, 0];

        this._loadMatrix(matrix, multiply);
    };

    /**
     * Set the contrast matrix, increase the separation between dark and bright
     * Increase contrast : shadows darker and highlights brighter
     * Decrease contrast : bring the shadows up and the highlights down
     *
     * @param {number} amount - value of the contrast (0-1)
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */


    ColorMatrixFilter.prototype.contrast = function contrast(amount, multiply) {
        var v = (amount || 0) + 1;
        var o = -0.5 * (v - 1);

        var matrix = [v, 0, 0, 0, o, 0, v, 0, 0, o, 0, 0, v, 0, o, 0, 0, 0, 1, 0];

        this._loadMatrix(matrix, multiply);
    };

    /**
     * Set the saturation matrix, increase the separation between colors
     * Increase saturation : increase contrast, brightness, and sharpness
     *
     * @param {number} amount - The saturation amount (0-1)
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */


    ColorMatrixFilter.prototype.saturate = function saturate() {
        var amount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var multiply = arguments[1];

        var x = amount * 2 / 3 + 1;
        var y = (x - 1) * -0.5;

        var matrix = [x, y, y, 0, 0, y, x, y, 0, 0, y, y, x, 0, 0, 0, 0, 0, 1, 0];

        this._loadMatrix(matrix, multiply);
    };

    /**
     * Desaturate image (remove color)
     *
     * Call the saturate function
     *
     */


    ColorMatrixFilter.prototype.desaturate = function desaturate() // eslint-disable-line no-unused-vars
    {
        this.saturate(-1);
    };

    /**
     * Negative image (inverse of classic rgb matrix)
     *
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */


    ColorMatrixFilter.prototype.negative = function negative(multiply) {
        var matrix = [-1, 0, 0, 1, 0, 0, -1, 0, 1, 0, 0, 0, -1, 1, 0, 0, 0, 0, 1, 0];

        this._loadMatrix(matrix, multiply);
    };

    /**
     * Sepia image
     *
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */


    ColorMatrixFilter.prototype.sepia = function sepia(multiply) {
        var matrix = [0.393, 0.7689999, 0.18899999, 0, 0, 0.349, 0.6859999, 0.16799999, 0, 0, 0.272, 0.5339999, 0.13099999, 0, 0, 0, 0, 0, 1, 0];

        this._loadMatrix(matrix, multiply);
    };

    /**
     * Color motion picture process invented in 1916 (thanks Dominic Szablewski)
     *
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */


    ColorMatrixFilter.prototype.technicolor = function technicolor(multiply) {
        var matrix = [1.9125277891456083, -0.8545344976951645, -0.09155508482755585, 0, 11.793603434377337, -0.3087833385928097, 1.7658908555458428, -0.10601743074722245, 0, -70.35205161461398, -0.231103377548616, -0.7501899197440212, 1.847597816108189, 0, 30.950940869491138, 0, 0, 0, 1, 0];

        this._loadMatrix(matrix, multiply);
    };

    /**
     * Polaroid filter
     *
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */


    ColorMatrixFilter.prototype.polaroid = function polaroid(multiply) {
        var matrix = [1.438, -0.062, -0.062, 0, 0, -0.122, 1.378, -0.122, 0, 0, -0.016, -0.016, 1.483, 0, 0, 0, 0, 0, 1, 0];

        this._loadMatrix(matrix, multiply);
    };

    /**
     * Filter who transforms : Red -> Blue and Blue -> Red
     *
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */


    ColorMatrixFilter.prototype.toBGR = function toBGR(multiply) {
        var matrix = [0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0];

        this._loadMatrix(matrix, multiply);
    };

    /**
     * Color reversal film introduced by Eastman Kodak in 1935. (thanks Dominic Szablewski)
     *
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */


    ColorMatrixFilter.prototype.kodachrome = function kodachrome(multiply) {
        var matrix = [1.1285582396593525, -0.3967382283601348, -0.03992559172921793, 0, 63.72958762196502, -0.16404339962244616, 1.0835251566291304, -0.05498805115633132, 0, 24.732407896706203, -0.16786010706155763, -0.5603416277695248, 1.6014850761964943, 0, 35.62982807460946, 0, 0, 0, 1, 0];

        this._loadMatrix(matrix, multiply);
    };

    /**
     * Brown delicious browni filter (thanks Dominic Szablewski)
     *
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */


    ColorMatrixFilter.prototype.browni = function browni(multiply) {
        var matrix = [0.5997023498159715, 0.34553243048391263, -0.2708298674538042, 0, 47.43192855600873, -0.037703249837783157, 0.8609577587992641, 0.15059552388459913, 0, -36.96841498319127, 0.24113635128153335, -0.07441037908422492, 0.44972182064877153, 0, -7.562075277591283, 0, 0, 0, 1, 0];

        this._loadMatrix(matrix, multiply);
    };

    /**
     * Vintage filter (thanks Dominic Szablewski)
     *
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */


    ColorMatrixFilter.prototype.vintage = function vintage(multiply) {
        var matrix = [0.6279345635605994, 0.3202183420819367, -0.03965408211312453, 0, 9.651285835294123, 0.02578397704808868, 0.6441188644374771, 0.03259127616149294, 0, 7.462829176470591, 0.0466055556782719, -0.0851232987247891, 0.5241648018700465, 0, 5.159190588235296, 0, 0, 0, 1, 0];

        this._loadMatrix(matrix, multiply);
    };

    /**
     * We don't know exactly what it does, kind of gradient map, but funny to play with!
     *
     * @param {number} desaturation - Tone values.
     * @param {number} toned - Tone values.
     * @param {string} lightColor - Tone values, example: `0xFFE580`
     * @param {string} darkColor - Tone values, example: `0xFFE580`
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */


    ColorMatrixFilter.prototype.colorTone = function colorTone(desaturation, toned, lightColor, darkColor, multiply) {
        desaturation = desaturation || 0.2;
        toned = toned || 0.15;
        lightColor = lightColor || 0xFFE580;
        darkColor = darkColor || 0x338000;

        var lR = (lightColor >> 16 & 0xFF) / 255;
        var lG = (lightColor >> 8 & 0xFF) / 255;
        var lB = (lightColor & 0xFF) / 255;

        var dR = (darkColor >> 16 & 0xFF) / 255;
        var dG = (darkColor >> 8 & 0xFF) / 255;
        var dB = (darkColor & 0xFF) / 255;

        var matrix = [0.3, 0.59, 0.11, 0, 0, lR, lG, lB, desaturation, 0, dR, dG, dB, toned, 0, lR - dR, lG - dG, lB - dB, 0, 0];

        this._loadMatrix(matrix, multiply);
    };

    /**
     * Night effect
     *
     * @param {number} intensity - The intensity of the night effect.
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */


    ColorMatrixFilter.prototype.night = function night(intensity, multiply) {
        intensity = intensity || 0.1;
        var matrix = [intensity * -2.0, -intensity, 0, 0, 0, -intensity, 0, intensity, 0, 0, 0, intensity, intensity * 2.0, 0, 0, 0, 0, 0, 1, 0];

        this._loadMatrix(matrix, multiply);
    };

    /**
     * Predator effect
     *
     * Erase the current matrix by setting a new indepent one
     *
     * @param {number} amount - how much the predator feels his future victim
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */


    ColorMatrixFilter.prototype.predator = function predator(amount, multiply) {
        var matrix = [
        // row 1
        11.224130630493164 * amount, -4.794486999511719 * amount, -2.8746118545532227 * amount, 0 * amount, 0.40342438220977783 * amount,
        // row 2
        -3.6330697536468506 * amount, 9.193157196044922 * amount, -2.951810836791992 * amount, 0 * amount, -1.316135048866272 * amount,
        // row 3
        -3.2184197902679443 * amount, -4.2375030517578125 * amount, 7.476448059082031 * amount, 0 * amount, 0.8044459223747253 * amount,
        // row 4
        0, 0, 0, 1, 0];

        this._loadMatrix(matrix, multiply);
    };

    /**
     * LSD effect
     *
     * Multiply the current matrix
     *
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */


    ColorMatrixFilter.prototype.lsd = function lsd(multiply) {
        var matrix = [2, -0.4, 0.5, 0, 0, -0.5, 2, -0.4, 0, 0, -0.4, -0.5, 3, 0, 0, 0, 0, 0, 1, 0];

        this._loadMatrix(matrix, multiply);
    };

    /**
     * Erase the current matrix by setting the default one
     *
     */


    ColorMatrixFilter.prototype.reset = function reset() {
        var matrix = [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0];

        this._loadMatrix(matrix, false);
    };

    /**
     * The matrix of the color matrix filter
     *
     * @member {number[]}
     * @default [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0]
     */


    _createClass(ColorMatrixFilter, [{
        key: 'matrix',
        get: function get() {
            return this.uniforms.m;
        },
        set: function set(value) // eslint-disable-line require-jsdoc
        {
            this.uniforms.m = value;
        }

        /**
         * The opacity value to use when mixing the original and resultant colors.
         *
         * When the value is 0, the original color is used without modification.
         * When the value is 1, the result color is used.
         * When in the range (0, 1) the color is interpolated between the original and result by this amount.
         *
         * @member {number}
         * @default 1
         */

    }, {
        key: 'alpha',
        get: function get() {
            return this.uniforms.uAlpha;
        },
        set: function set(value) // eslint-disable-line require-jsdoc
        {
            this.uniforms.uAlpha = value;
        }
    }]);

    return ColorMatrixFilter;
}(core.Filter);

// Americanized alias


exports.default = ColorMatrixFilter;
ColorMatrixFilter.prototype.grayscale = ColorMatrixFilter.prototype.greyscale;

},{"../../core":72,"path":1}],158:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _core = require('../../core');

var core = _interopRequireWildcard(_core);

var _path = require('path');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The DisplacementFilter class uses the pixel values from the specified texture
 * (called the displacement map) to perform a displacement of an object. You can
 * use this filter to apply all manor of crazy warping effects. Currently the r
 * property of the texture is used to offset the x and the g property of the texture
 * is used to offset the y.
 *
 * @class
 * @extends PIXI.Filter
 * @memberof PIXI.filters
 */
var DisplacementFilter = function (_core$Filter) {
    _inherits(DisplacementFilter, _core$Filter);

    /**
     * @param {PIXI.Sprite} sprite - The sprite used for the displacement map. (make sure its added to the scene!)
     * @param {number} scale - The scale of the displacement
     */
    function DisplacementFilter(sprite, scale) {
        _classCallCheck(this, DisplacementFilter);

        var maskMatrix = new core.Matrix();

        sprite.renderable = false;

        var _this = _possibleConstructorReturn(this, _core$Filter.call(this,
        // vertex shader
        'attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 filterMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec2 vFilterCoord;\n\nvoid main(void)\n{\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n   vFilterCoord = ( filterMatrix * vec3( aTextureCoord, 1.0)  ).xy;\n   vTextureCoord = aTextureCoord;\n}',
        // fragment shader
        'varying vec2 vFilterCoord;\nvarying vec2 vTextureCoord;\n\nuniform vec2 scale;\n\nuniform sampler2D uSampler;\nuniform sampler2D mapSampler;\n\nuniform vec4 filterArea;\nuniform vec4 filterClamp;\n\nvoid main(void)\n{\n  vec4 map =  texture2D(mapSampler, vFilterCoord);\n\n  map -= 0.5;\n  map.xy *= scale / filterArea.xy;\n\n  gl_FragColor = texture2D(uSampler, clamp(vec2(vTextureCoord.x + map.x, vTextureCoord.y + map.y), filterClamp.xy, filterClamp.zw));\n}\n'));

        _this.maskSprite = sprite;
        _this.maskMatrix = maskMatrix;

        _this.uniforms.mapSampler = sprite._texture;
        _this.uniforms.filterMatrix = maskMatrix;
        _this.uniforms.scale = { x: 1, y: 1 };

        if (scale === null || scale === undefined) {
            scale = 20;
        }

        _this.scale = new core.Point(scale, scale);
        return _this;
    }

    /**
     * Applies the filter.
     *
     * @param {PIXI.FilterManager} filterManager - The manager.
     * @param {PIXI.RenderTarget} input - The input target.
     * @param {PIXI.RenderTarget} output - The output target.
     */


    DisplacementFilter.prototype.apply = function apply(filterManager, input, output) {
        this.uniforms.filterMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, this.maskSprite);
        this.uniforms.scale.x = this.scale.x;
        this.uniforms.scale.y = this.scale.y;

        // draw the filter...
        filterManager.applyFilter(this, input, output);
    };

    /**
     * The texture used for the displacement map. Must be power of 2 sized texture.
     *
     * @member {PIXI.Texture}
     */


    _createClass(DisplacementFilter, [{
        key: 'map',
        get: function get() {
            return this.uniforms.mapSampler;
        },
        set: function set(value) // eslint-disable-line require-jsdoc
        {
            this.uniforms.mapSampler = value;
        }
    }]);

    return DisplacementFilter;
}(core.Filter);

exports.default = DisplacementFilter;

},{"../../core":72,"path":1}],159:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _core = require('../../core');

var core = _interopRequireWildcard(_core);

var _path = require('path');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 *
 * Basic FXAA implementation based on the code on geeks3d.com with the
 * modification that the texture2DLod stuff was removed since it's
 * unsupported by WebGL.
 *
 * @see https://github.com/mitsuhiko/webgl-meincraft
 *
 * @class
 * @extends PIXI.Filter
 * @memberof PIXI.filters
 *
 */
var FXAAFilter = function (_core$Filter) {
    _inherits(FXAAFilter, _core$Filter);

    /**
     *
     */
    function FXAAFilter() {
        _classCallCheck(this, FXAAFilter);

        // TODO - needs work
        return _possibleConstructorReturn(this, _core$Filter.call(this,
        // vertex shader
        '\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\nuniform vec4 filterArea;\n\nvarying vec2 vTextureCoord;\n\nvec2 mapCoord( vec2 coord )\n{\n    coord *= filterArea.xy;\n    coord += filterArea.zw;\n\n    return coord;\n}\n\nvec2 unmapCoord( vec2 coord )\n{\n    coord -= filterArea.zw;\n    coord /= filterArea.xy;\n\n    return coord;\n}\n\nvoid texcoords(vec2 fragCoord, vec2 resolution,\n               out vec2 v_rgbNW, out vec2 v_rgbNE,\n               out vec2 v_rgbSW, out vec2 v_rgbSE,\n               out vec2 v_rgbM) {\n    vec2 inverseVP = 1.0 / resolution.xy;\n    v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;\n    v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;\n    v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;\n    v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;\n    v_rgbM = vec2(fragCoord * inverseVP);\n}\n\nvoid main(void) {\n\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n   vTextureCoord = aTextureCoord;\n\n   vec2 fragCoord = vTextureCoord * filterArea.xy;\n\n   texcoords(fragCoord, filterArea.xy, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n}',
        // fragment shader
        'varying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\nvarying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec4 filterArea;\n\n/**\n Basic FXAA implementation based on the code on geeks3d.com with the\n modification that the texture2DLod stuff was removed since it\'s\n unsupported by WebGL.\n \n --\n \n From:\n https://github.com/mitsuhiko/webgl-meincraft\n \n Copyright (c) 2011 by Armin Ronacher.\n \n Some rights reserved.\n \n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are\n met:\n \n * Redistributions of source code must retain the above copyright\n notice, this list of conditions and the following disclaimer.\n \n * Redistributions in binary form must reproduce the above\n copyright notice, this list of conditions and the following\n disclaimer in the documentation and/or other materials provided\n with the distribution.\n \n * The names of the contributors may not be used to endorse or\n promote products derived from this software without specific\n prior written permission.\n \n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifndef FXAA_REDUCE_MIN\n#define FXAA_REDUCE_MIN   (1.0/ 128.0)\n#endif\n#ifndef FXAA_REDUCE_MUL\n#define FXAA_REDUCE_MUL   (1.0 / 8.0)\n#endif\n#ifndef FXAA_SPAN_MAX\n#define FXAA_SPAN_MAX     8.0\n#endif\n\n//optimized version for mobile, where dependent\n//texture reads can be a bottleneck\nvec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 resolution,\n          vec2 v_rgbNW, vec2 v_rgbNE,\n          vec2 v_rgbSW, vec2 v_rgbSE,\n          vec2 v_rgbM) {\n    vec4 color;\n    mediump vec2 inverseVP = vec2(1.0 / resolution.x, 1.0 / resolution.y);\n    vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;\n    vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;\n    vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;\n    vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;\n    vec4 texColor = texture2D(tex, v_rgbM);\n    vec3 rgbM  = texColor.xyz;\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n    \n    mediump vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n    \n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n    \n    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),\n              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n                  dir * rcpDirMin)) * inverseVP;\n    \n    vec3 rgbA = 0.5 * (\n                       texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +\n                       texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);\n    vec3 rgbB = rgbA * 0.5 + 0.25 * (\n                                     texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +\n                                     texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);\n    \n    float lumaB = dot(rgbB, luma);\n    if ((lumaB < lumaMin) || (lumaB > lumaMax))\n        color = vec4(rgbA, texColor.a);\n    else\n        color = vec4(rgbB, texColor.a);\n    return color;\n}\n\nvoid main() {\n\n      vec2 fragCoord = vTextureCoord * filterArea.xy;\n\n      vec4 color;\n\n    color = fxaa(uSampler, fragCoord, filterArea.xy, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n\n      gl_FragColor = color;\n}\n'));
    }

    return FXAAFilter;
}(core.Filter);

exports.default = FXAAFilter;

},{"../../core":72,"path":1}],160:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _FXAAFilter = require('./fxaa/FXAAFilter');

Object.defineProperty(exports, 'FXAAFilter', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_FXAAFilter).default;
  }
});

var _NoiseFilter = require('./noise/NoiseFilter');

Object.defineProperty(exports, 'NoiseFilter', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_NoiseFilter).default;
  }
});

var _DisplacementFilter = require('./displacement/DisplacementFilter');

Object.defineProperty(exports, 'DisplacementFilter', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_DisplacementFilter).default;
  }
});

var _BlurFilter = require('./blur/BlurFilter');

Object.defineProperty(exports, 'BlurFilter', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_BlurFilter).default;
  }
});

var _BlurXFilter = require('./blur/BlurXFilter');

Object.defineProperty(exports, 'BlurXFilter', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_BlurXFilter).default;
  }
});

var _BlurYFilter = require('./blur/BlurYFilter');

Object.defineProperty(exports, 'BlurYFilter', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_BlurYFilter).default;
  }
});

var _ColorMatrixFilter = require('./colormatrix/ColorMatrixFilter');

Object.defineProperty(exports, 'ColorMatrixFilter', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_ColorMatrixFilter).default;
  }
});

var _AlphaFilter = require('./alpha/AlphaFilter');

Object.defineProperty(exports, 'AlphaFilter', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_AlphaFilter).default;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

},{"./alpha/AlphaFilter":150,"./blur/BlurFilter":151,"./blur/BlurXFilter":152,"./blur/BlurYFilter":153,"./colormatrix/ColorMatrixFilter":157,"./displacement/DisplacementFilter":158,"./fxaa/FXAAFilter":159,"./noise/NoiseFilter":161}],161:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _core = require('../../core');

var core = _interopRequireWildcard(_core);

var _path = require('path');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @author Vico @vicocotea
 * original filter: https://github.com/evanw/glfx.js/blob/master/src/filters/adjust/noise.js
 */

/**
 * A Noise effect filter.
 *
 * @class
 * @extends PIXI.Filter
 * @memberof PIXI.filters
 */
var NoiseFilter = function (_core$Filter) {
    _inherits(NoiseFilter, _core$Filter);

    /**
     * @param {number} noise - The noise intensity, should be a normalized value in the range [0, 1].
     * @param {number} seed - A random seed for the noise generation. Default is `Math.random()`.
     */
    function NoiseFilter() {
        var noise = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0.5;
        var seed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Math.random();

        _classCallCheck(this, NoiseFilter);

        var _this = _possibleConstructorReturn(this, _core$Filter.call(this,
        // vertex shader
        'attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}',
        // fragment shader
        'precision highp float;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform float uNoise;\nuniform float uSeed;\nuniform sampler2D uSampler;\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main()\n{\n    vec4 color = texture2D(uSampler, vTextureCoord);\n    float randomValue = rand(gl_FragCoord.xy * uSeed);\n    float diff = (randomValue - 0.5) * uNoise;\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (color.a > 0.0) {\n        color.rgb /= color.a;\n    }\n\n    color.r += diff;\n    color.g += diff;\n    color.b += diff;\n\n    // Premultiply alpha again.\n    color.rgb *= color.a;\n\n    gl_FragColor = color;\n}\n'));

        _this.noise = noise;
        _this.seed = seed;
        return _this;
    }

    /**
     * The amount of noise to apply, this value should be in the range (0, 1].
     *
     * @member {number}
     * @default 0.5
     */


    _createClass(NoiseFilter, [{
        key: 'noise',
        get: function get() {
            return this.uniforms.uNoise;
        },
        set: function set(value) // eslint-disable-line require-jsdoc
        {
            this.uniforms.uNoise = value;
        }

        /**
         * A seed value to apply to the random noise generation. `Math.random()` is a good value to use.
         *
         * @member {number}
         */

    }, {
        key: 'seed',
        get: function get() {
            return this.uniforms.uSeed;
        },
        set: function set(value) // eslint-disable-line require-jsdoc
        {
            this.uniforms.uSeed = value;
        }
    }]);

    return NoiseFilter;
}(core.Filter);

exports.default = NoiseFilter;

},{"../../core":72,"path":1}],162:[function(require,module,exports){
(function (global){
'use strict';

exports.__esModule = true;
exports.loader = exports.prepare = exports.particles = exports.mesh = exports.loaders = exports.interaction = exports.filters = exports.extras = exports.extract = exports.accessibility = undefined;

var _polyfill = require('./polyfill');

Object.keys(_polyfill).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
            return _polyfill[key];
        }
    });
});

var _core = require('./core');

Object.keys(_core).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
            return _core[key];
        }
    });
});

var _deprecation = require('./deprecation');

var _deprecation2 = _interopRequireDefault(_deprecation);

var _accessibility = require('./accessibility');

var accessibility = _interopRequireWildcard(_accessibility);

var _extract = require('./extract');

var extract = _interopRequireWildcard(_extract);

var _extras = require('./extras');

var extras = _interopRequireWildcard(_extras);

var _filters = require('./filters');

var filters = _interopRequireWildcard(_filters);

var _interaction = require('./interaction');

var interaction = _interopRequireWildcard(_interaction);

var _loaders = require('./loaders');

var loaders = _interopRequireWildcard(_loaders);

var _mesh = require('./mesh');

var mesh = _interopRequireWildcard(_mesh);

var _particles = require('./particles');

var particles = _interopRequireWildcard(_particles);

var _prepare = require('./prepare');

var prepare = _interopRequireWildcard(_prepare);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// export core
_core.utils.mixins.performMixins();

/**
 * Alias for {@link PIXI.loaders.shared}.
 * @name loader
 * @memberof PIXI
 * @type {PIXI.loader.Loader}
 */


// handle mixins now, after all code has been added, including deprecation


// export libs
// import polyfills. Done as an export to make sure polyfills are imported first
var loader = loaders.shared || null;

exports.accessibility = accessibility;
exports.extract = extract;
exports.extras = extras;
exports.filters = filters;
exports.interaction = interaction;
exports.loaders = loaders;
exports.mesh = mesh;
exports.particles = particles;
exports.prepare = prepare;
exports.loader = loader;

// Apply the deprecations

if (typeof _deprecation2.default === 'function') {
    (0, _deprecation2.default)(exports);
}

// Always export PixiJS globally.
global.PIXI = exports; // eslint-disable-line

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./accessibility":49,"./core":72,"./deprecation":138,"./extract":140,"./extras":148,"./filters":160,"./interaction":167,"./loaders":170,"./mesh":179,"./particles":182,"./polyfill":189,"./prepare":193}],163:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _core = require('../core');

var core = _interopRequireWildcard(_core);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Holds all information related to an Interaction event
 *
 * @class
 * @memberof PIXI.interaction
 */
var InteractionData = function () {
  /**
   *
   */
  function InteractionData() {
    _classCallCheck(this, InteractionData);

    /**
     * This point stores the global coords of where the touch/mouse event happened
     *
     * @member {PIXI.Point}
     */
    this.global = new core.Point();

    /**
     * The target DisplayObject that was interacted with
     *
     * @member {PIXI.DisplayObject}
     */
    this.target = null;

    /**
     * When passed to an event handler, this will be the original DOM Event that was captured
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent
     * @see https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent
     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent
     * @member {MouseEvent|TouchEvent|PointerEvent}
     */
    this.originalEvent = null;

    /**
     * Unique identifier for this interaction
     *
     * @member {number}
     */
    this.identifier = null;

    /**
     * Indicates whether or not the pointer device that created the event is the primary pointer.
     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/isPrimary
     * @type {Boolean}
     */
    this.isPrimary = false;

    /**
     * Indicates which button was pressed on the mouse or pointer device to trigger the event.
     * @see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button
     * @type {number}
     */
    this.button = 0;

    /**
     * Indicates which buttons are pressed on the mouse or pointer device when the event is triggered.
     * @see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons
     * @type {number}
     */
    this.buttons = 0;

    /**
     * The width of the pointer's contact along the x-axis, measured in CSS pixels.
     * radiusX of TouchEvents will be represented by this value.
     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/width
     * @type {number}
     */
    this.width = 0;

    /**
     * The height of the pointer's contact along the y-axis, measured in CSS pixels.
     * radiusY of TouchEvents will be represented by this value.
     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/height
     * @type {number}
     */
    this.height = 0;

    /**
     * The angle, in degrees, between the pointer device and the screen.
     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tiltX
     * @type {number}
     */
    this.tiltX = 0;

    /**
     * The angle, in degrees, between the pointer device and the screen.
     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tiltY
     * @type {number}
     */
    this.tiltY = 0;

    /**
     * The type of pointer that triggered the event.
     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerType
     * @type {string}
     */
    this.pointerType = null;

    /**
     * Pressure applied by the pointing device during the event. A Touch's force property
     * will be represented by this value.
     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pressure
     * @type {number}
     */
    this.pressure = 0;

    /**
     * From TouchEvents (not PointerEvents triggered by touches), the rotationAngle of the Touch.
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Touch/rotationAngle
     * @type {number}
     */
    this.rotationAngle = 0;

    /**
     * Twist of a stylus pointer.
     * @see https://w3c.github.io/pointerevents/#pointerevent-interface
     * @type {number}
     */
    this.twist = 0;

    /**
     * Barrel pressure on a stylus pointer.
     * @see https://w3c.github.io/pointerevents/#pointerevent-interface
     * @type {number}
     */
    this.tangentialPressure = 0;
  }

  /**
   * The unique identifier of the pointer. It will be the same as `identifier`.
   * @readonly
   * @member {number}
   * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerId
   */


  /**
   * This will return the local coordinates of the specified displayObject for this InteractionData
   *
   * @param {PIXI.DisplayObject} displayObject - The DisplayObject that you would like the local
   *  coords off
   * @param {PIXI.Point} [point] - A Point object in which to store the value, optional (otherwise
   *  will create a new point)
   * @param {PIXI.Point} [globalPos] - A Point object containing your custom global coords, optional
   *  (otherwise will use the current global coords)
   * @return {PIXI.Point} A point containing the coordinates of the InteractionData position relative
   *  to the DisplayObject
   */
  InteractionData.prototype.getLocalPosition = function getLocalPosition(displayObject, point, globalPos) {
    return displayObject.worldTransform.applyInverse(globalPos || this.global, point);
  };

  /**
   * Copies properties from normalized event data.
   *
   * @param {Touch|MouseEvent|PointerEvent} event The normalized event data
   */


  InteractionData.prototype.copyEvent = function copyEvent(event) {
    // isPrimary should only change on touchstart/pointerdown, so we don't want to overwrite
    // it with "false" on later events when our shim for it on touch events might not be
    // accurate
    if (event.isPrimary) {
      this.isPrimary = true;
    }
    this.button = event.button;
    // event.buttons is not available in all browsers (ie. Safari), but it does have a non-standard
    // event.which property instead, which conveys the same information.
    this.buttons = Number.isInteger(event.buttons) ? event.buttons : event.which;
    this.width = event.width;
    this.height = event.height;
    this.tiltX = event.tiltX;
    this.tiltY = event.tiltY;
    this.pointerType = event.pointerType;
    this.pressure = event.pressure;
    this.rotationAngle = event.rotationAngle;
    this.twist = event.twist || 0;
    this.tangentialPressure = event.tangentialPressure || 0;
  };

  /**
   * Resets the data for pooling.
   */


  InteractionData.prototype.reset = function reset() {
    // isPrimary is the only property that we really need to reset - everything else is
    // guaranteed to be overwritten
    this.isPrimary = false;
  };

  _createClass(InteractionData, [{
    key: 'pointerId',
    get: function get() {
      return this.identifier;
    }
  }]);

  return InteractionData;
}();

exports.default = InteractionData;

},{"../core":72}],164:[function(require,module,exports){
"use strict";

exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Event class that mimics native DOM events.
 *
 * @class
 * @memberof PIXI.interaction
 */
var InteractionEvent = function () {
  /**
   *
   */
  function InteractionEvent() {
    _classCallCheck(this, InteractionEvent);

    /**
     * Whether this event will continue propagating in the tree
     *
     * @member {boolean}
     */
    this.stopped = false;

    /**
     * The object which caused this event to be dispatched.
     * For listener callback see {@link PIXI.interaction.InteractionEvent.currentTarget}.
     *
     * @member {PIXI.DisplayObject}
     */
    this.target = null;

    /**
     * The object whose event listener’s callback is currently being invoked.
     *
     * @member {PIXI.DisplayObject}
     */
    this.currentTarget = null;

    /**
     * Type of the event
     *
     * @member {string}
     */
    this.type = null;

    /**
     * InteractionData related to this event
     *
     * @member {PIXI.interaction.InteractionData}
     */
    this.data = null;
  }

  /**
   * Prevents event from reaching any objects other than the current object.
   *
   */


  InteractionEvent.prototype.stopPropagation = function stopPropagation() {
    this.stopped = true;
  };

  /**
   * Resets the event.
   */


  InteractionEvent.prototype.reset = function reset() {
    this.stopped = false;
    this.currentTarget = null;
    this.target = null;
  };

  return InteractionEvent;
}();

exports.default = InteractionEvent;

},{}],165:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _core = require('../core');

var core = _interopRequireWildcard(_core);

var _InteractionData = require('./InteractionData');

var _InteractionData2 = _interopRequireDefault(_InteractionData);

var _InteractionEvent = require('./InteractionEvent');

var _InteractionEvent2 = _interopRequireDefault(_InteractionEvent);

var _InteractionTrackingData = require('./InteractionTrackingData');

var _InteractionTrackingData2 = _interopRequireDefault(_InteractionTrackingData);

var _eventemitter = require('eventemitter3');

var _eventemitter2 = _interopRequireDefault(_eventemitter);

var _interactiveTarget = require('./interactiveTarget');

var _interactiveTarget2 = _interopRequireDefault(_interactiveTarget);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Mix interactiveTarget into core.DisplayObject.prototype, after deprecation has been handled
core.utils.mixins.delayMixin(core.DisplayObject.prototype, _interactiveTarget2.default);

var MOUSE_POINTER_ID = 1;

// helpers for hitTest() - only used inside hitTest()
var hitTestEvent = {
    target: null,
    data: {
        global: null
    }
};

/**
 * The interaction manager deals with mouse, touch and pointer events. Any DisplayObject can be interactive
 * if its interactive parameter is set to true
 * This manager also supports multitouch.
 *
 * An instance of this class is automatically created by default, and can be found at renderer.plugins.interaction
 *
 * @class
 * @extends EventEmitter
 * @memberof PIXI.interaction
 */

var InteractionManager = function (_EventEmitter) {
    _inherits(InteractionManager, _EventEmitter);

    /**
     * @param {PIXI.CanvasRenderer|PIXI.WebGLRenderer} renderer - A reference to the current renderer
     * @param {object} [options] - The options for the manager.
     * @param {boolean} [options.autoPreventDefault=true] - Should the manager automatically prevent default browser actions.
     * @param {number} [options.interactionFrequency=10] - Frequency increases the interaction events will be checked.
     */
    function InteractionManager(renderer, options) {
        _classCallCheck(this, InteractionManager);

        var _this = _possibleConstructorReturn(this, _EventEmitter.call(this));

        options = options || {};

        /**
         * The renderer this interaction manager works for.
         *
         * @member {PIXI.SystemRenderer}
         */
        _this.renderer = renderer;

        /**
         * Should default browser actions automatically be prevented.
         * Does not apply to pointer events for backwards compatibility
         * preventDefault on pointer events stops mouse events from firing
         * Thus, for every pointer event, there will always be either a mouse of touch event alongside it.
         *
         * @member {boolean}
         * @default true
         */
        _this.autoPreventDefault = options.autoPreventDefault !== undefined ? options.autoPreventDefault : true;

        /**
         * Frequency in milliseconds that the mousemove, moveover & mouseout interaction events will be checked.
         *
         * @member {number}
         * @default 10
         */
        _this.interactionFrequency = options.interactionFrequency || 10;

        /**
         * The mouse data
         *
         * @member {PIXI.interaction.InteractionData}
         */
        _this.mouse = new _InteractionData2.default();
        _this.mouse.identifier = MOUSE_POINTER_ID;

        // setting the mouse to start off far off screen will mean that mouse over does
        //  not get called before we even move the mouse.
        _this.mouse.global.set(-999999);

        /**
         * Actively tracked InteractionData
         *
         * @private
         * @member {Object.<number,PIXI.interation.InteractionData>}
         */
        _this.activeInteractionData = {};
        _this.activeInteractionData[MOUSE_POINTER_ID] = _this.mouse;

        /**
         * Pool of unused InteractionData
         *
         * @private
         * @member {PIXI.interation.InteractionData[]}
         */
        _this.interactionDataPool = [];

        /**
         * An event data object to handle all the event tracking/dispatching
         *
         * @member {object}
         */
        _this.eventData = new _InteractionEvent2.default();

        /**
         * The DOM element to bind to.
         *
         * @private
         * @member {HTMLElement}
         */
        _this.interactionDOMElement = null;

        /**
         * This property determines if mousemove and touchmove events are fired only when the cursor
         * is over the object.
         * Setting to true will make things work more in line with how the DOM verison works.
         * Setting to false can make things easier for things like dragging
         * It is currently set to false as this is how PixiJS used to work. This will be set to true in
         * future versions of pixi.
         *
         * @member {boolean}
         * @default false
         */
        _this.moveWhenInside = false;

        /**
         * Have events been attached to the dom element?
         *
         * @private
         * @member {boolean}
         */
        _this.eventsAdded = false;

        /**
         * Is the mouse hovering over the renderer?
         *
         * @private
         * @member {boolean}
         */
        _this.mouseOverRenderer = false;

        /**
         * Does the device support touch events
         * https://www.w3.org/TR/touch-events/
         *
         * @readonly
         * @member {boolean}
         */
        _this.supportsTouchEvents = 'ontouchstart' in window;

        /**
         * Does the device support pointer events
         * https://www.w3.org/Submission/pointer-events/
         *
         * @readonly
         * @member {boolean}
         */
        _this.supportsPointerEvents = !!window.PointerEvent;

        // this will make it so that you don't have to call bind all the time

        /**
         * @private
         * @member {Function}
         */
        _this.onPointerUp = _this.onPointerUp.bind(_this);
        _this.processPointerUp = _this.processPointerUp.bind(_this);

        /**
         * @private
         * @member {Function}
         */
        _this.onPointerCancel = _this.onPointerCancel.bind(_this);
        _this.processPointerCancel = _this.processPointerCancel.bind(_this);

        /**
         * @private
         * @member {Function}
         */
        _this.onPointerDown = _this.onPointerDown.bind(_this);
        _this.processPointerDown = _this.processPointerDown.bind(_this);

        /**
         * @private
         * @member {Function}
         */
        _this.onPointerMove = _this.onPointerMove.bind(_this);
        _this.processPointerMove = _this.processPointerMove.bind(_this);

        /**
         * @private
         * @member {Function}
         */
        _this.onPointerOut = _this.onPointerOut.bind(_this);
        _this.processPointerOverOut = _this.processPointerOverOut.bind(_this);

        /**
         * @private
         * @member {Function}
         */
        _this.onPointerOver = _this.onPointerOver.bind(_this);

        /**
         * Dictionary of how different cursor modes are handled. Strings are handled as CSS cursor
         * values, objects are handled as dictionaries of CSS values for interactionDOMElement,
         * and functions are called instead of changing the CSS.
         * Default CSS cursor values are provided for 'default' and 'pointer' modes.
         * @member {Object.<string, (string|Function|Object.<string, string>)>}
         */
        _this.cursorStyles = {
            default: 'inherit',
            pointer: 'pointer'
        };

        /**
         * The mode of the cursor that is being used.
         * The value of this is a key from the cursorStyles dictionary.
         *
         * @member {string}
         */
        _this.currentCursorMode = null;

        /**
         * Internal cached let.
         *
         * @private
         * @member {string}
         */
        _this.cursor = null;

        /**
         * Internal cached let.
         *
         * @private
         * @member {PIXI.Point}
         */
        _this._tempPoint = new core.Point();

        /**
         * The current resolution / device pixel ratio.
         *
         * @member {number}
         * @default 1
         */
        _this.resolution = 1;

        _this.setTargetElement(_this.renderer.view, _this.renderer.resolution);

        /**
         * Fired when a pointer device button (usually a mouse left-button) is pressed on the display
         * object.
         *
         * @event PIXI.interaction.InteractionManager#mousedown
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when a pointer device secondary button (usually a mouse right-button) is pressed
         * on the display object.
         *
         * @event PIXI.interaction.InteractionManager#rightdown
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when a pointer device button (usually a mouse left-button) is released over the display
         * object.
         *
         * @event PIXI.interaction.InteractionManager#mouseup
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when a pointer device secondary button (usually a mouse right-button) is released
         * over the display object.
         *
         * @event PIXI.interaction.InteractionManager#rightup
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when a pointer device button (usually a mouse left-button) is pressed and released on
         * the display object.
         *
         * @event PIXI.interaction.InteractionManager#click
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when a pointer device secondary button (usually a mouse right-button) is pressed
         * and released on the display object.
         *
         * @event PIXI.interaction.InteractionManager#rightclick
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when a pointer device button (usually a mouse left-button) is released outside the
         * display object that initially registered a
         * [mousedown]{@link PIXI.interaction.InteractionManager#event:mousedown}.
         *
         * @event PIXI.interaction.InteractionManager#mouseupoutside
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when a pointer device secondary button (usually a mouse right-button) is released
         * outside the display object that initially registered a
         * [rightdown]{@link PIXI.interaction.InteractionManager#event:rightdown}.
         *
         * @event PIXI.interaction.InteractionManager#rightupoutside
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when a pointer device (usually a mouse) is moved while over the display object
         *
         * @event PIXI.interaction.InteractionManager#mousemove
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when a pointer device (usually a mouse) is moved onto the display object
         *
         * @event PIXI.interaction.InteractionManager#mouseover
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when a pointer device (usually a mouse) is moved off the display object
         *
         * @event PIXI.interaction.InteractionManager#mouseout
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when a pointer device button is pressed on the display object.
         *
         * @event PIXI.interaction.InteractionManager#pointerdown
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when a pointer device button is released over the display object.
         * Not always fired when some buttons are held down while others are released. In those cases,
         * use [mousedown]{@link PIXI.interaction.InteractionManager#event:mousedown} and
         * [mouseup]{@link PIXI.interaction.InteractionManager#event:mouseup} instead.
         *
         * @event PIXI.interaction.InteractionManager#pointerup
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when the operating system cancels a pointer event
         *
         * @event PIXI.interaction.InteractionManager#pointercancel
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when a pointer device button is pressed and released on the display object.
         *
         * @event PIXI.interaction.InteractionManager#pointertap
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when a pointer device button is released outside the display object that initially
         * registered a [pointerdown]{@link PIXI.interaction.InteractionManager#event:pointerdown}.
         *
         * @event PIXI.interaction.InteractionManager#pointerupoutside
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when a pointer device is moved while over the display object
         *
         * @event PIXI.interaction.InteractionManager#pointermove
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when a pointer device is moved onto the display object
         *
         * @event PIXI.interaction.InteractionManager#pointerover
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when a pointer device is moved off the display object
         *
         * @event PIXI.interaction.InteractionManager#pointerout
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when a touch point is placed on the display object.
         *
         * @event PIXI.interaction.InteractionManager#touchstart
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when a touch point is removed from the display object.
         *
         * @event PIXI.interaction.InteractionManager#touchend
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when the operating system cancels a touch
         *
         * @event PIXI.interaction.InteractionManager#touchcancel
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when a touch point is placed and removed from the display object.
         *
         * @event PIXI.interaction.InteractionManager#tap
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when a touch point is removed outside of the display object that initially
         * registered a [touchstart]{@link PIXI.interaction.InteractionManager#event:touchstart}.
         *
         * @event PIXI.interaction.InteractionManager#touchendoutside
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when a touch point is moved along the display object.
         *
         * @event PIXI.interaction.InteractionManager#touchmove
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when a pointer device button (usually a mouse left-button) is pressed on the display.
         * object. DisplayObject's `interactive` property must be set to `true` to fire event.
         *
         * @event PIXI.DisplayObject#mousedown
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when a pointer device secondary button (usually a mouse right-button) is pressed
         * on the display object. DisplayObject's `interactive` property must be set to `true` to fire event.
         *
         * @event PIXI.DisplayObject#rightdown
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when a pointer device button (usually a mouse left-button) is released over the display
         * object. DisplayObject's `interactive` property must be set to `true` to fire event.
         *
         * @event PIXI.DisplayObject#mouseup
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when a pointer device secondary button (usually a mouse right-button) is released
         * over the display object. DisplayObject's `interactive` property must be set to `true` to fire event.
         *
         * @event PIXI.DisplayObject#rightup
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when a pointer device button (usually a mouse left-button) is pressed and released on
         * the display object. DisplayObject's `interactive` property must be set to `true` to fire event.
         *
         * @event PIXI.DisplayObject#click
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when a pointer device secondary button (usually a mouse right-button) is pressed
         * and released on the display object. DisplayObject's `interactive` property must be set to `true` to fire event.
         *
         * @event PIXI.DisplayObject#rightclick
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when a pointer device button (usually a mouse left-button) is released outside the
         * display object that initially registered a
         * [mousedown]{@link PIXI.DisplayObject#event:mousedown}.
         * DisplayObject's `interactive` property must be set to `true` to fire event.
         *
         * @event PIXI.DisplayObject#mouseupoutside
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when a pointer device secondary button (usually a mouse right-button) is released
         * outside the display object that initially registered a
         * [rightdown]{@link PIXI.DisplayObject#event:rightdown}.
         * DisplayObject's `interactive` property must be set to `true` to fire event.
         *
         * @event PIXI.DisplayObject#rightupoutside
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when a pointer device (usually a mouse) is moved while over the display object.
         * DisplayObject's `interactive` property must be set to `true` to fire event.
         *
         * @event PIXI.DisplayObject#mousemove
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when a pointer device (usually a mouse) is moved onto the display object.
         * DisplayObject's `interactive` property must be set to `true` to fire event.
         *
         * @event PIXI.DisplayObject#mouseover
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when a pointer device (usually a mouse) is moved off the display object.
         * DisplayObject's `interactive` property must be set to `true` to fire event.
         *
         * @event PIXI.DisplayObject#mouseout
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when a pointer device button is pressed on the display object.
         * DisplayObject's `interactive` property must be set to `true` to fire event.
         *
         * @event PIXI.DisplayObject#pointerdown
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when a pointer device button is released over the display object.
         * DisplayObject's `interactive` property must be set to `true` to fire event.
         *
         * @event PIXI.DisplayObject#pointerup
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when the operating system cancels a pointer event.
         * DisplayObject's `interactive` property must be set to `true` to fire event.
         *
         * @event PIXI.DisplayObject#pointercancel
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when a pointer device button is pressed and released on the display object.
         * DisplayObject's `interactive` property must be set to `true` to fire event.
         *
         * @event PIXI.DisplayObject#pointertap
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when a pointer device button is released outside the display object that initially
         * registered a [pointerdown]{@link PIXI.DisplayObject#event:pointerdown}.
         * DisplayObject's `interactive` property must be set to `true` to fire event.
         *
         * @event PIXI.DisplayObject#pointerupoutside
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when a pointer device is moved while over the display object.
         * DisplayObject's `interactive` property must be set to `true` to fire event.
         *
         * @event PIXI.DisplayObject#pointermove
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when a pointer device is moved onto the display object.
         * DisplayObject's `interactive` property must be set to `true` to fire event.
         *
         * @event PIXI.DisplayObject#pointerover
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when a pointer device is moved off the display object.
         * DisplayObject's `interactive` property must be set to `true` to fire event.
         *
         * @event PIXI.DisplayObject#pointerout
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when a touch point is placed on the display object.
         * DisplayObject's `interactive` property must be set to `true` to fire event.
         *
         * @event PIXI.DisplayObject#touchstart
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when a touch point is removed from the display object.
         * DisplayObject's `interactive` property must be set to `true` to fire event.
         *
         * @event PIXI.DisplayObject#touchend
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when the operating system cancels a touch.
         * DisplayObject's `interactive` property must be set to `true` to fire event.
         *
         * @event PIXI.DisplayObject#touchcancel
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when a touch point is placed and removed from the display object.
         * DisplayObject's `interactive` property must be set to `true` to fire event.
         *
         * @event PIXI.DisplayObject#tap
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when a touch point is removed outside of the display object that initially
         * registered a [touchstart]{@link PIXI.DisplayObject#event:touchstart}.
         * DisplayObject's `interactive` property must be set to `true` to fire event.
         *
         * @event PIXI.DisplayObject#touchendoutside
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when a touch point is moved along the display object.
         * DisplayObject's `interactive` property must be set to `true` to fire event.
         *
         * @event PIXI.DisplayObject#touchmove
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */
        return _this;
    }

    /**
     * Hit tests a point against the display tree, returning the first interactive object that is hit.
     *
     * @param {PIXI.Point} globalPoint - A point to hit test with, in global space.
     * @param {PIXI.Container} [root] - The root display object to start from. If omitted, defaults
     * to the last rendered root of the associated renderer.
     * @return {PIXI.DisplayObject} The hit display object, if any.
     */


    InteractionManager.prototype.hitTest = function hitTest(globalPoint, root) {
        // clear the target for our hit test
        hitTestEvent.target = null;
        // assign the global point
        hitTestEvent.data.global = globalPoint;
        // ensure safety of the root
        if (!root) {
            root = this.renderer._lastObjectRendered;
        }
        // run the hit test
        this.processInteractive(hitTestEvent, root, null, true);
        // return our found object - it'll be null if we didn't hit anything

        return hitTestEvent.target;
    };

    /**
     * Sets the DOM element which will receive mouse/touch events. This is useful for when you have
     * other DOM elements on top of the renderers Canvas element. With this you'll be bale to deletegate
     * another DOM element to receive those events.
     *
     * @param {HTMLCanvasElement} element - the DOM element which will receive mouse and touch events.
     * @param {number} [resolution=1] - The resolution / device pixel ratio of the new element (relative to the canvas).
     */


    InteractionManager.prototype.setTargetElement = function setTargetElement(element) {
        var resolution = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

        this.removeEvents();

        this.interactionDOMElement = element;

        this.resolution = resolution;

        this.addEvents();
    };

    /**
     * Registers all the DOM events
     *
     * @private
     */


    InteractionManager.prototype.addEvents = function addEvents() {
        if (!this.interactionDOMElement) {
            return;
        }

        core.ticker.shared.add(this.update, this, core.UPDATE_PRIORITY.INTERACTION);

        if (window.navigator.msPointerEnabled) {
            this.interactionDOMElement.style['-ms-content-zooming'] = 'none';
            this.interactionDOMElement.style['-ms-touch-action'] = 'none';
        } else if (this.supportsPointerEvents) {
            this.interactionDOMElement.style['touch-action'] = 'none';
        }

        /**
         * These events are added first, so that if pointer events are normalised, they are fired
         * in the same order as non-normalised events. ie. pointer event 1st, mouse / touch 2nd
         */
        if (this.supportsPointerEvents) {
            window.document.addEventListener('pointermove', this.onPointerMove, true);
            this.interactionDOMElement.addEventListener('pointerdown', this.onPointerDown, true);
            // pointerout is fired in addition to pointerup (for touch events) and pointercancel
            // we already handle those, so for the purposes of what we do in onPointerOut, we only
            // care about the pointerleave event
            this.interactionDOMElement.addEventListener('pointerleave', this.onPointerOut, true);
            this.interactionDOMElement.addEventListener('pointerover', this.onPointerOver, true);
            window.addEventListener('pointercancel', this.onPointerCancel, true);
            window.addEventListener('pointerup', this.onPointerUp, true);
        } else {
            window.document.addEventListener('mousemove', this.onPointerMove, true);
            this.interactionDOMElement.addEventListener('mousedown', this.onPointerDown, true);
            this.interactionDOMElement.addEventListener('mouseout', this.onPointerOut, true);
            this.interactionDOMElement.addEventListener('mouseover', this.onPointerOver, true);
            window.addEventListener('mouseup', this.onPointerUp, true);
        }

        // always look directly for touch events so that we can provide original data
        // In a future version we should change this to being just a fallback and rely solely on
        // PointerEvents whenever available
        if (this.supportsTouchEvents) {
            this.interactionDOMElement.addEventListener('touchstart', this.onPointerDown, true);
            this.interactionDOMElement.addEventListener('touchcancel', this.onPointerCancel, true);
            this.interactionDOMElement.addEventListener('touchend', this.onPointerUp, true);
            this.interactionDOMElement.addEventListener('touchmove', this.onPointerMove, true);
        }

        this.eventsAdded = true;
    };

    /**
     * Removes all the DOM events that were previously registered
     *
     * @private
     */


    InteractionManager.prototype.removeEvents = function removeEvents() {
        if (!this.interactionDOMElement) {
            return;
        }

        core.ticker.shared.remove(this.update, this);

        if (window.navigator.msPointerEnabled) {
            this.interactionDOMElement.style['-ms-content-zooming'] = '';
            this.interactionDOMElement.style['-ms-touch-action'] = '';
        } else if (this.supportsPointerEvents) {
            this.interactionDOMElement.style['touch-action'] = '';
        }

        if (this.supportsPointerEvents) {
            window.document.removeEventListener('pointermove', this.onPointerMove, true);
            this.interactionDOMElement.removeEventListener('pointerdown', this.onPointerDown, true);
            this.interactionDOMElement.removeEventListener('pointerleave', this.onPointerOut, true);
            this.interactionDOMElement.removeEventListener('pointerover', this.onPointerOver, true);
            window.removeEventListener('pointercancel', this.onPointerCancel, true);
            window.removeEventListener('pointerup', this.onPointerUp, true);
        } else {
            window.document.removeEventListener('mousemove', this.onPointerMove, true);
            this.interactionDOMElement.removeEventListener('mousedown', this.onPointerDown, true);
            this.interactionDOMElement.removeEventListener('mouseout', this.onPointerOut, true);
            this.interactionDOMElement.removeEventListener('mouseover', this.onPointerOver, true);
            window.removeEventListener('mouseup', this.onPointerUp, true);
        }

        if (this.supportsTouchEvents) {
            this.interactionDOMElement.removeEventListener('touchstart', this.onPointerDown, true);
            this.interactionDOMElement.removeEventListener('touchcancel', this.onPointerCancel, true);
            this.interactionDOMElement.removeEventListener('touchend', this.onPointerUp, true);
            this.interactionDOMElement.removeEventListener('touchmove', this.onPointerMove, true);
        }

        this.interactionDOMElement = null;

        this.eventsAdded = false;
    };

    /**
     * Updates the state of interactive objects.
     * Invoked by a throttled ticker update from {@link PIXI.ticker.shared}.
     *
     * @param {number} deltaTime - time delta since last tick
     */


    InteractionManager.prototype.update = function update(deltaTime) {
        this._deltaTime += deltaTime;

        if (this._deltaTime < this.interactionFrequency) {
            return;
        }

        this._deltaTime = 0;

        if (!this.interactionDOMElement) {
            return;
        }

        // if the user move the mouse this check has already been done using the mouse move!
        if (this.didMove) {
            this.didMove = false;

            return;
        }

        this.cursor = null;

        // Resets the flag as set by a stopPropagation call. This flag is usually reset by a user interaction of any kind,
        // but there was a scenario of a display object moving under a static mouse cursor.
        // In this case, mouseover and mouseevents would not pass the flag test in dispatchEvent function
        for (var k in this.activeInteractionData) {
            // eslint-disable-next-line no-prototype-builtins
            if (this.activeInteractionData.hasOwnProperty(k)) {
                var interactionData = this.activeInteractionData[k];

                if (interactionData.originalEvent && interactionData.pointerType !== 'touch') {
                    var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, interactionData.originalEvent, interactionData);

                    this.processInteractive(interactionEvent, this.renderer._lastObjectRendered, this.processPointerOverOut, true);
                }
            }
        }

        this.setCursorMode(this.cursor);

        // TODO
    };

    /**
     * Sets the current cursor mode, handling any callbacks or CSS style changes.
     *
     * @param {string} mode - cursor mode, a key from the cursorStyles dictionary
     */


    InteractionManager.prototype.setCursorMode = function setCursorMode(mode) {
        mode = mode || 'default';
        // if the mode didn't actually change, bail early
        if (this.currentCursorMode === mode) {
            return;
        }
        this.currentCursorMode = mode;
        var style = this.cursorStyles[mode];

        // only do things if there is a cursor style for it
        if (style) {
            switch (typeof style === 'undefined' ? 'undefined' : _typeof(style)) {
                case 'string':
                    // string styles are handled as cursor CSS
                    this.interactionDOMElement.style.cursor = style;
                    break;
                case 'function':
                    // functions are just called, and passed the cursor mode
                    style(mode);
                    break;
                case 'object':
                    // if it is an object, assume that it is a dictionary of CSS styles,
                    // apply it to the interactionDOMElement
                    Object.assign(this.interactionDOMElement.style, style);
                    break;
            }
        } else if (typeof mode === 'string' && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode)) {
            // if it mode is a string (not a Symbol) and cursorStyles doesn't have any entry
            // for the mode, then assume that the dev wants it to be CSS for the cursor.
            this.interactionDOMElement.style.cursor = mode;
        }
    };

    /**
     * Dispatches an event on the display object that was interacted with
     *
     * @param {PIXI.Container|PIXI.Sprite|PIXI.extras.TilingSprite} displayObject - the display object in question
     * @param {string} eventString - the name of the event (e.g, mousedown)
     * @param {object} eventData - the event data object
     * @private
     */


    InteractionManager.prototype.dispatchEvent = function dispatchEvent(displayObject, eventString, eventData) {
        if (!eventData.stopped) {
            eventData.currentTarget = displayObject;
            eventData.type = eventString;

            displayObject.emit(eventString, eventData);

            if (displayObject[eventString]) {
                displayObject[eventString](eventData);
            }
        }
    };

    /**
     * Maps x and y coords from a DOM object and maps them correctly to the PixiJS view. The
     * resulting value is stored in the point. This takes into account the fact that the DOM
     * element could be scaled and positioned anywhere on the screen.
     *
     * @param  {PIXI.Point} point - the point that the result will be stored in
     * @param  {number} x - the x coord of the position to map
     * @param  {number} y - the y coord of the position to map
     */


    InteractionManager.prototype.mapPositionToPoint = function mapPositionToPoint(point, x, y) {
        var rect = void 0;

        // IE 11 fix
        if (!this.interactionDOMElement.parentElement) {
            rect = { x: 0, y: 0, width: 0, height: 0 };
        } else {
            rect = this.interactionDOMElement.getBoundingClientRect();
        }

        var resolutionMultiplier = navigator.isCocoonJS ? this.resolution : 1.0 / this.resolution;

        point.x = (x - rect.left) * (this.interactionDOMElement.width / rect.width) * resolutionMultiplier;
        point.y = (y - rect.top) * (this.interactionDOMElement.height / rect.height) * resolutionMultiplier;
    };

    /**
     * This function is provides a neat way of crawling through the scene graph and running a
     * specified function on all interactive objects it finds. It will also take care of hit
     * testing the interactive objects and passes the hit across in the function.
     *
     * @private
     * @param {PIXI.interaction.InteractionEvent} interactionEvent - event containing the point that
     *  is tested for collision
     * @param {PIXI.Container|PIXI.Sprite|PIXI.extras.TilingSprite} displayObject - the displayObject
     *  that will be hit test (recursively crawls its children)
     * @param {Function} [func] - the function that will be called on each interactive object. The
     *  interactionEvent, displayObject and hit will be passed to the function
     * @param {boolean} [hitTest] - this indicates if the objects inside should be hit test against the point
     * @param {boolean} [interactive] - Whether the displayObject is interactive
     * @return {boolean} returns true if the displayObject hit the point
     */


    InteractionManager.prototype.processInteractive = function processInteractive(interactionEvent, displayObject, func, hitTest, interactive) {
        if (!displayObject || !displayObject.visible) {
            return false;
        }

        var point = interactionEvent.data.global;

        // Took a little while to rework this function correctly! But now it is done and nice and optimised. ^_^
        //
        // This function will now loop through all objects and then only hit test the objects it HAS
        // to, not all of them. MUCH faster..
        // An object will be hit test if the following is true:
        //
        // 1: It is interactive.
        // 2: It belongs to a parent that is interactive AND one of the parents children have not already been hit.
        //
        // As another little optimisation once an interactive object has been hit we can carry on
        // through the scenegraph, but we know that there will be no more hits! So we can avoid extra hit tests
        // A final optimisation is that an object is not hit test directly if a child has already been hit.

        interactive = displayObject.interactive || interactive;

        var hit = false;
        var interactiveParent = interactive;

        // Flag here can set to false if the event is outside the parents hitArea or mask
        var hitTestChildren = true;

        // If there is a hitArea, no need to test against anything else if the pointer is not within the hitArea
        // There is also no longer a need to hitTest children.
        if (displayObject.hitArea) {
            if (hitTest) {
                displayObject.worldTransform.applyInverse(point, this._tempPoint);
                if (!displayObject.hitArea.contains(this._tempPoint.x, this._tempPoint.y)) {
                    hitTest = false;
                    hitTestChildren = false;
                } else {
                    hit = true;
                }
            }
            interactiveParent = false;
        }
        // If there is a mask, no need to test against anything else if the pointer is not within the mask
        else if (displayObject._mask) {
                if (hitTest) {
                    if (!displayObject._mask.containsPoint(point)) {
                        hitTest = false;
                        hitTestChildren = false;
                    }
                }
            }

        // ** FREE TIP **! If an object is not interactive or has no buttons in it
        // (such as a game scene!) set interactiveChildren to false for that displayObject.
        // This will allow PixiJS to completely ignore and bypass checking the displayObjects children.
        if (hitTestChildren && displayObject.interactiveChildren && displayObject.children) {
            var children = displayObject.children;

            for (var i = children.length - 1; i >= 0; i--) {
                var child = children[i];

                // time to get recursive.. if this function will return if something is hit..
                var childHit = this.processInteractive(interactionEvent, child, func, hitTest, interactiveParent);

                if (childHit) {
                    // its a good idea to check if a child has lost its parent.
                    // this means it has been removed whilst looping so its best
                    if (!child.parent) {
                        continue;
                    }

                    // we no longer need to hit test any more objects in this container as we we
                    // now know the parent has been hit
                    interactiveParent = false;

                    // If the child is interactive , that means that the object hit was actually
                    // interactive and not just the child of an interactive object.
                    // This means we no longer need to hit test anything else. We still need to run
                    // through all objects, but we don't need to perform any hit tests.

                    if (childHit) {
                        if (interactionEvent.target) {
                            hitTest = false;
                        }
                        hit = true;
                    }
                }
            }
        }

        // no point running this if the item is not interactive or does not have an interactive parent.
        if (interactive) {
            // if we are hit testing (as in we have no hit any objects yet)
            // We also don't need to worry about hit testing if once of the displayObjects children
            // has already been hit - but only if it was interactive, otherwise we need to keep
            // looking for an interactive child, just in case we hit one
            if (hitTest && !interactionEvent.target) {
                // already tested against hitArea if it is defined
                if (!displayObject.hitArea && displayObject.containsPoint) {
                    if (displayObject.containsPoint(point)) {
                        hit = true;
                    }
                }
            }

            if (displayObject.interactive) {
                if (hit && !interactionEvent.target) {
                    interactionEvent.target = displayObject;
                }

                if (func) {
                    func(interactionEvent, displayObject, !!hit);
                }
            }
        }

        return hit;
    };

    /**
     * Is called when the pointer button is pressed down on the renderer element
     *
     * @private
     * @param {PointerEvent} originalEvent - The DOM event of a pointer button being pressed down
     */


    InteractionManager.prototype.onPointerDown = function onPointerDown(originalEvent) {
        // if we support touch events, then only use those for touch events, not pointer events
        if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') return;

        var events = this.normalizeToPointerData(originalEvent);

        /**
         * No need to prevent default on natural pointer events, as there are no side effects
         * Normalized events, however, may have the double mousedown/touchstart issue on the native android browser,
         * so still need to be prevented.
         */

        // Guaranteed that there will be at least one event in events, and all events must have the same pointer type

        if (this.autoPreventDefault && events[0].isNormalized) {
            originalEvent.preventDefault();
        }

        var eventLen = events.length;

        for (var i = 0; i < eventLen; i++) {
            var event = events[i];

            var interactionData = this.getInteractionDataForPointerId(event);

            var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);

            interactionEvent.data.originalEvent = originalEvent;

            this.processInteractive(interactionEvent, this.renderer._lastObjectRendered, this.processPointerDown, true);

            this.emit('pointerdown', interactionEvent);
            if (event.pointerType === 'touch') {
                this.emit('touchstart', interactionEvent);
            }
            // emit a mouse event for "pen" pointers, the way a browser would emit a fallback event
            else if (event.pointerType === 'mouse' || event.pointerType === 'pen') {
                    var isRightButton = event.button === 2;

                    this.emit(isRightButton ? 'rightdown' : 'mousedown', this.eventData);
                }
        }
    };

    /**
     * Processes the result of the pointer down check and dispatches the event if need be
     *
     * @private
     * @param {PIXI.interaction.InteractionEvent} interactionEvent - The interaction event wrapping the DOM event
     * @param {PIXI.Container|PIXI.Sprite|PIXI.extras.TilingSprite} displayObject - The display object that was tested
     * @param {boolean} hit - the result of the hit test on the display object
     */


    InteractionManager.prototype.processPointerDown = function processPointerDown(interactionEvent, displayObject, hit) {
        var data = interactionEvent.data;
        var id = interactionEvent.data.identifier;

        if (hit) {
            if (!displayObject.trackedPointers[id]) {
                displayObject.trackedPointers[id] = new _InteractionTrackingData2.default(id);
            }
            this.dispatchEvent(displayObject, 'pointerdown', interactionEvent);

            if (data.pointerType === 'touch') {
                this.dispatchEvent(displayObject, 'touchstart', interactionEvent);
            } else if (data.pointerType === 'mouse' || data.pointerType === 'pen') {
                var isRightButton = data.button === 2;

                if (isRightButton) {
                    displayObject.trackedPointers[id].rightDown = true;
                } else {
                    displayObject.trackedPointers[id].leftDown = true;
                }

                this.dispatchEvent(displayObject, isRightButton ? 'rightdown' : 'mousedown', interactionEvent);
            }
        }
    };

    /**
     * Is called when the pointer button is released on the renderer element
     *
     * @private
     * @param {PointerEvent} originalEvent - The DOM event of a pointer button being released
     * @param {boolean} cancelled - true if the pointer is cancelled
     * @param {Function} func - Function passed to {@link processInteractive}
     */


    InteractionManager.prototype.onPointerComplete = function onPointerComplete(originalEvent, cancelled, func) {
        var events = this.normalizeToPointerData(originalEvent);

        var eventLen = events.length;

        // if the event wasn't targeting our canvas, then consider it to be pointerupoutside
        // in all cases (unless it was a pointercancel)
        var eventAppend = originalEvent.target !== this.interactionDOMElement ? 'outside' : '';

        for (var i = 0; i < eventLen; i++) {
            var event = events[i];

            var interactionData = this.getInteractionDataForPointerId(event);

            var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);

            interactionEvent.data.originalEvent = originalEvent;

            // perform hit testing for events targeting our canvas or cancel events
            this.processInteractive(interactionEvent, this.renderer._lastObjectRendered, func, cancelled || !eventAppend);

            this.emit(cancelled ? 'pointercancel' : 'pointerup' + eventAppend, interactionEvent);

            if (event.pointerType === 'mouse' || event.pointerType === 'pen') {
                var isRightButton = event.button === 2;

                this.emit(isRightButton ? 'rightup' + eventAppend : 'mouseup' + eventAppend, interactionEvent);
            } else if (event.pointerType === 'touch') {
                this.emit(cancelled ? 'touchcancel' : 'touchend' + eventAppend, interactionEvent);
                this.releaseInteractionDataForPointerId(event.pointerId, interactionData);
            }
        }
    };

    /**
     * Is called when the pointer button is cancelled
     *
     * @private
     * @param {PointerEvent} event - The DOM event of a pointer button being released
     */


    InteractionManager.prototype.onPointerCancel = function onPointerCancel(event) {
        // if we support touch events, then only use those for touch events, not pointer events
        if (this.supportsTouchEvents && event.pointerType === 'touch') return;

        this.onPointerComplete(event, true, this.processPointerCancel);
    };

    /**
     * Processes the result of the pointer cancel check and dispatches the event if need be
     *
     * @private
     * @param {PIXI.interaction.InteractionEvent} interactionEvent - The interaction event wrapping the DOM event
     * @param {PIXI.Container|PIXI.Sprite|PIXI.extras.TilingSprite} displayObject - The display object that was tested
     */


    InteractionManager.prototype.processPointerCancel = function processPointerCancel(interactionEvent, displayObject) {
        var data = interactionEvent.data;

        var id = interactionEvent.data.identifier;

        if (displayObject.trackedPointers[id] !== undefined) {
            delete displayObject.trackedPointers[id];
            this.dispatchEvent(displayObject, 'pointercancel', interactionEvent);

            if (data.pointerType === 'touch') {
                this.dispatchEvent(displayObject, 'touchcancel', interactionEvent);
            }
        }
    };

    /**
     * Is called when the pointer button is released on the renderer element
     *
     * @private
     * @param {PointerEvent} event - The DOM event of a pointer button being released
     */


    InteractionManager.prototype.onPointerUp = function onPointerUp(event) {
        // if we support touch events, then only use those for touch events, not pointer events
        if (this.supportsTouchEvents && event.pointerType === 'touch') return;

        this.onPointerComplete(event, false, this.processPointerUp);
    };

    /**
     * Processes the result of the pointer up check and dispatches the event if need be
     *
     * @private
     * @param {PIXI.interaction.InteractionEvent} interactionEvent - The interaction event wrapping the DOM event
     * @param {PIXI.Container|PIXI.Sprite|PIXI.extras.TilingSprite} displayObject - The display object that was tested
     * @param {boolean} hit - the result of the hit test on the display object
     */


    InteractionManager.prototype.processPointerUp = function processPointerUp(interactionEvent, displayObject, hit) {
        var data = interactionEvent.data;

        var id = interactionEvent.data.identifier;

        var trackingData = displayObject.trackedPointers[id];

        var isTouch = data.pointerType === 'touch';

        var isMouse = data.pointerType === 'mouse' || data.pointerType === 'pen';
        // need to track mouse down status in the mouse block so that we can emit
        // event in a later block
        var isMouseTap = false;

        // Mouse only
        if (isMouse) {
            var isRightButton = data.button === 2;

            var flags = _InteractionTrackingData2.default.FLAGS;

            var test = isRightButton ? flags.RIGHT_DOWN : flags.LEFT_DOWN;

            var isDown = trackingData !== undefined && trackingData.flags & test;

            if (hit) {
                this.dispatchEvent(displayObject, isRightButton ? 'rightup' : 'mouseup', interactionEvent);

                if (isDown) {
                    this.dispatchEvent(displayObject, isRightButton ? 'rightclick' : 'click', interactionEvent);
                    // because we can confirm that the mousedown happened on this object, flag for later emit of pointertap
                    isMouseTap = true;
                }
            } else if (isDown) {
                this.dispatchEvent(displayObject, isRightButton ? 'rightupoutside' : 'mouseupoutside', interactionEvent);
            }
            // update the down state of the tracking data
            if (trackingData) {
                if (isRightButton) {
                    trackingData.rightDown = false;
                } else {
                    trackingData.leftDown = false;
                }
            }
        }

        // Pointers and Touches, and Mouse
        if (hit) {
            this.dispatchEvent(displayObject, 'pointerup', interactionEvent);
            if (isTouch) this.dispatchEvent(displayObject, 'touchend', interactionEvent);

            if (trackingData) {
                // emit pointertap if not a mouse, or if the mouse block decided it was a tap
                if (!isMouse || isMouseTap) {
                    this.dispatchEvent(displayObject, 'pointertap', interactionEvent);
                }
                if (isTouch) {
                    this.dispatchEvent(displayObject, 'tap', interactionEvent);
                    // touches are no longer over (if they ever were) when we get the touchend
                    // so we should ensure that we don't keep pretending that they are
                    trackingData.over = false;
                }
            }
        } else if (trackingData) {
            this.dispatchEvent(displayObject, 'pointerupoutside', interactionEvent);
            if (isTouch) this.dispatchEvent(displayObject, 'touchendoutside', interactionEvent);
        }
        // Only remove the tracking data if there is no over/down state still associated with it
        if (trackingData && trackingData.none) {
            delete displayObject.trackedPointers[id];
        }
    };

    /**
     * Is called when the pointer moves across the renderer element
     *
     * @private
     * @param {PointerEvent} originalEvent - The DOM event of a pointer moving
     */


    InteractionManager.prototype.onPointerMove = function onPointerMove(originalEvent) {
        // if we support touch events, then only use those for touch events, not pointer events
        if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') return;

        var events = this.normalizeToPointerData(originalEvent);

        if (events[0].pointerType === 'mouse' || events[0].pointerType === 'pen') {
            this.didMove = true;

            this.cursor = null;
        }

        var eventLen = events.length;

        for (var i = 0; i < eventLen; i++) {
            var event = events[i];

            var interactionData = this.getInteractionDataForPointerId(event);

            var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);

            interactionEvent.data.originalEvent = originalEvent;

            var interactive = event.pointerType === 'touch' ? this.moveWhenInside : true;

            this.processInteractive(interactionEvent, this.renderer._lastObjectRendered, this.processPointerMove, interactive);
            this.emit('pointermove', interactionEvent);
            if (event.pointerType === 'touch') this.emit('touchmove', interactionEvent);
            if (event.pointerType === 'mouse' || event.pointerType === 'pen') this.emit('mousemove', interactionEvent);
        }

        if (events[0].pointerType === 'mouse') {
            this.setCursorMode(this.cursor);

            // TODO BUG for parents interactive object (border order issue)
        }
    };

    /**
     * Processes the result of the pointer move check and dispatches the event if need be
     *
     * @private
     * @param {PIXI.interaction.InteractionEvent} interactionEvent - The interaction event wrapping the DOM event
     * @param {PIXI.Container|PIXI.Sprite|PIXI.extras.TilingSprite} displayObject - The display object that was tested
     * @param {boolean} hit - the result of the hit test on the display object
     */


    InteractionManager.prototype.processPointerMove = function processPointerMove(interactionEvent, displayObject, hit) {
        var data = interactionEvent.data;

        var isTouch = data.pointerType === 'touch';

        var isMouse = data.pointerType === 'mouse' || data.pointerType === 'pen';

        if (isMouse) {
            this.processPointerOverOut(interactionEvent, displayObject, hit);
        }

        if (!this.moveWhenInside || hit) {
            this.dispatchEvent(displayObject, 'pointermove', interactionEvent);
            if (isTouch) this.dispatchEvent(displayObject, 'touchmove', interactionEvent);
            if (isMouse) this.dispatchEvent(displayObject, 'mousemove', interactionEvent);
        }
    };

    /**
     * Is called when the pointer is moved out of the renderer element
     *
     * @private
     * @param {PointerEvent} originalEvent - The DOM event of a pointer being moved out
     */


    InteractionManager.prototype.onPointerOut = function onPointerOut(originalEvent) {
        // if we support touch events, then only use those for touch events, not pointer events
        if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') return;

        var events = this.normalizeToPointerData(originalEvent);

        // Only mouse and pointer can call onPointerOut, so events will always be length 1
        var event = events[0];

        if (event.pointerType === 'mouse') {
            this.mouseOverRenderer = false;
            this.setCursorMode(null);
        }

        var interactionData = this.getInteractionDataForPointerId(event);

        var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);

        interactionEvent.data.originalEvent = event;

        this.processInteractive(interactionEvent, this.renderer._lastObjectRendered, this.processPointerOverOut, false);

        this.emit('pointerout', interactionEvent);
        if (event.pointerType === 'mouse' || event.pointerType === 'pen') {
            this.emit('mouseout', interactionEvent);
        } else {
            // we can get touchleave events after touchend, so we want to make sure we don't
            // introduce memory leaks
            this.releaseInteractionDataForPointerId(interactionData.identifier);
        }
    };

    /**
     * Processes the result of the pointer over/out check and dispatches the event if need be
     *
     * @private
     * @param {PIXI.interaction.InteractionEvent} interactionEvent - The interaction event wrapping the DOM event
     * @param {PIXI.Container|PIXI.Sprite|PIXI.extras.TilingSprite} displayObject - The display object that was tested
     * @param {boolean} hit - the result of the hit test on the display object
     */


    InteractionManager.prototype.processPointerOverOut = function processPointerOverOut(interactionEvent, displayObject, hit) {
        var data = interactionEvent.data;

        var id = interactionEvent.data.identifier;

        var isMouse = data.pointerType === 'mouse' || data.pointerType === 'pen';

        var trackingData = displayObject.trackedPointers[id];

        // if we just moused over the display object, then we need to track that state
        if (hit && !trackingData) {
            trackingData = displayObject.trackedPointers[id] = new _InteractionTrackingData2.default(id);
        }

        if (trackingData === undefined) return;

        if (hit && this.mouseOverRenderer) {
            if (!trackingData.over) {
                trackingData.over = true;
                this.dispatchEvent(displayObject, 'pointerover', interactionEvent);
                if (isMouse) {
                    this.dispatchEvent(displayObject, 'mouseover', interactionEvent);
                }
            }

            // only change the cursor if it has not already been changed (by something deeper in the
            // display tree)
            if (isMouse && this.cursor === null) {
                this.cursor = displayObject.cursor;
            }
        } else if (trackingData.over) {
            trackingData.over = false;
            this.dispatchEvent(displayObject, 'pointerout', this.eventData);
            if (isMouse) {
                this.dispatchEvent(displayObject, 'mouseout', interactionEvent);
            }
            // if there is no mouse down information for the pointer, then it is safe to delete
            if (trackingData.none) {
                delete displayObject.trackedPointers[id];
            }
        }
    };

    /**
     * Is called when the pointer is moved into the renderer element
     *
     * @private
     * @param {PointerEvent} originalEvent - The DOM event of a pointer button being moved into the renderer view
     */


    InteractionManager.prototype.onPointerOver = function onPointerOver(originalEvent) {
        var events = this.normalizeToPointerData(originalEvent);

        // Only mouse and pointer can call onPointerOver, so events will always be length 1
        var event = events[0];

        var interactionData = this.getInteractionDataForPointerId(event);

        var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);

        interactionEvent.data.originalEvent = event;

        if (event.pointerType === 'mouse') {
            this.mouseOverRenderer = true;
        }

        this.emit('pointerover', interactionEvent);
        if (event.pointerType === 'mouse' || event.pointerType === 'pen') {
            this.emit('mouseover', interactionEvent);
        }
    };

    /**
     * Get InteractionData for a given pointerId. Store that data as well
     *
     * @private
     * @param {PointerEvent} event - Normalized pointer event, output from normalizeToPointerData
     * @return {PIXI.interaction.InteractionData} - Interaction data for the given pointer identifier
     */


    InteractionManager.prototype.getInteractionDataForPointerId = function getInteractionDataForPointerId(event) {
        var pointerId = event.pointerId;

        var interactionData = void 0;

        if (pointerId === MOUSE_POINTER_ID || event.pointerType === 'mouse') {
            interactionData = this.mouse;
        } else if (this.activeInteractionData[pointerId]) {
            interactionData = this.activeInteractionData[pointerId];
        } else {
            interactionData = this.interactionDataPool.pop() || new _InteractionData2.default();
            interactionData.identifier = pointerId;
            this.activeInteractionData[pointerId] = interactionData;
        }
        // copy properties from the event, so that we can make sure that touch/pointer specific
        // data is available
        interactionData.copyEvent(event);

        return interactionData;
    };

    /**
     * Return unused InteractionData to the pool, for a given pointerId
     *
     * @private
     * @param {number} pointerId - Identifier from a pointer event
     */


    InteractionManager.prototype.releaseInteractionDataForPointerId = function releaseInteractionDataForPointerId(pointerId) {
        var interactionData = this.activeInteractionData[pointerId];

        if (interactionData) {
            delete this.activeInteractionData[pointerId];
            interactionData.reset();
            this.interactionDataPool.push(interactionData);
        }
    };

    /**
     * Configure an InteractionEvent to wrap a DOM PointerEvent and InteractionData
     *
     * @private
     * @param {PIXI.interaction.InteractionEvent} interactionEvent - The event to be configured
     * @param {PointerEvent} pointerEvent - The DOM event that will be paired with the InteractionEvent
     * @param {PIXI.interaction.InteractionData} interactionData - The InteractionData that will be paired
     *        with the InteractionEvent
     * @return {PIXI.interaction.InteractionEvent} the interaction event that was passed in
     */


    InteractionManager.prototype.configureInteractionEventForDOMEvent = function configureInteractionEventForDOMEvent(interactionEvent, pointerEvent, interactionData) {
        interactionEvent.data = interactionData;

        this.mapPositionToPoint(interactionData.global, pointerEvent.clientX, pointerEvent.clientY);

        // This is the way InteractionManager processed touch events before the refactoring, so I've kept
        // it here. But it doesn't make that much sense to me, since mapPositionToPoint already factors
        // in this.resolution, so this just divides by this.resolution twice for touch events...
        if (navigator.isCocoonJS && pointerEvent.pointerType === 'touch') {
            interactionData.global.x = interactionData.global.x / this.resolution;
            interactionData.global.y = interactionData.global.y / this.resolution;
        }

        // Not really sure why this is happening, but it's how a previous version handled things
        if (pointerEvent.pointerType === 'touch') {
            pointerEvent.globalX = interactionData.global.x;
            pointerEvent.globalY = interactionData.global.y;
        }

        interactionData.originalEvent = pointerEvent;
        interactionEvent.reset();

        return interactionEvent;
    };

    /**
     * Ensures that the original event object contains all data that a regular pointer event would have
     *
     * @private
     * @param {TouchEvent|MouseEvent|PointerEvent} event - The original event data from a touch or mouse event
     * @return {PointerEvent[]} An array containing a single normalized pointer event, in the case of a pointer
     *  or mouse event, or a multiple normalized pointer events if there are multiple changed touches
     */


    InteractionManager.prototype.normalizeToPointerData = function normalizeToPointerData(event) {
        var normalizedEvents = [];

        if (this.supportsTouchEvents && event instanceof TouchEvent) {
            for (var i = 0, li = event.changedTouches.length; i < li; i++) {
                var touch = event.changedTouches[i];

                if (typeof touch.button === 'undefined') touch.button = event.touches.length ? 1 : 0;
                if (typeof touch.buttons === 'undefined') touch.buttons = event.touches.length ? 1 : 0;
                if (typeof touch.isPrimary === 'undefined') {
                    touch.isPrimary = event.touches.length === 1 && event.type === 'touchstart';
                }
                if (typeof touch.width === 'undefined') touch.width = touch.radiusX || 1;
                if (typeof touch.height === 'undefined') touch.height = touch.radiusY || 1;
                if (typeof touch.tiltX === 'undefined') touch.tiltX = 0;
                if (typeof touch.tiltY === 'undefined') touch.tiltY = 0;
                if (typeof touch.pointerType === 'undefined') touch.pointerType = 'touch';
                if (typeof touch.pointerId === 'undefined') touch.pointerId = touch.identifier || 0;
                if (typeof touch.pressure === 'undefined') touch.pressure = touch.force || 0.5;
                if (typeof touch.twist === 'undefined') touch.twist = 0;
                if (typeof touch.tangentialPressure === 'undefined') touch.tangentialPressure = 0;
                // TODO: Remove these, as layerX/Y is not a standard, is deprecated, has uneven
                // support, and the fill ins are not quite the same
                // offsetX/Y might be okay, but is not the same as clientX/Y when the canvas's top
                // left is not 0,0 on the page
                if (typeof touch.layerX === 'undefined') touch.layerX = touch.offsetX = touch.clientX;
                if (typeof touch.layerY === 'undefined') touch.layerY = touch.offsetY = touch.clientY;

                // mark the touch as normalized, just so that we know we did it
                touch.isNormalized = true;

                normalizedEvents.push(touch);
            }
        }
        // apparently PointerEvent subclasses MouseEvent, so yay
        else if (event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof window.PointerEvent))) {
                if (typeof event.isPrimary === 'undefined') event.isPrimary = true;
                if (typeof event.width === 'undefined') event.width = 1;
                if (typeof event.height === 'undefined') event.height = 1;
                if (typeof event.tiltX === 'undefined') event.tiltX = 0;
                if (typeof event.tiltY === 'undefined') event.tiltY = 0;
                if (typeof event.pointerType === 'undefined') event.pointerType = 'mouse';
                if (typeof event.pointerId === 'undefined') event.pointerId = MOUSE_POINTER_ID;
                if (typeof event.pressure === 'undefined') event.pressure = 0.5;
                if (typeof event.twist === 'undefined') event.twist = 0;
                if (typeof event.tangentialPressure === 'undefined') event.tangentialPressure = 0;

                // mark the mouse event as normalized, just so that we know we did it
                event.isNormalized = true;

                normalizedEvents.push(event);
            } else {
                normalizedEvents.push(event);
            }

        return normalizedEvents;
    };

    /**
     * Destroys the interaction manager
     *
     */


    InteractionManager.prototype.destroy = function destroy() {
        this.removeEvents();

        this.removeAllListeners();

        this.renderer = null;

        this.mouse = null;

        this.eventData = null;

        this.interactionDOMElement = null;

        this.onPointerDown = null;
        this.processPointerDown = null;

        this.onPointerUp = null;
        this.processPointerUp = null;

        this.onPointerCancel = null;
        this.processPointerCancel = null;

        this.onPointerMove = null;
        this.processPointerMove = null;

        this.onPointerOut = null;
        this.processPointerOverOut = null;

        this.onPointerOver = null;

        this._tempPoint = null;
    };

    return InteractionManager;
}(_eventemitter2.default);

exports.default = InteractionManager;


core.WebGLRenderer.registerPlugin('interaction', InteractionManager);
core.CanvasRenderer.registerPlugin('interaction', InteractionManager);

},{"../core":72,"./InteractionData":163,"./InteractionEvent":164,"./InteractionTrackingData":166,"./interactiveTarget":168,"eventemitter3":24}],166:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * DisplayObjects with the {@link PIXI.interaction.interactiveTarget} mixin use this class to track interactions
 *
 * @class
 * @private
 * @memberof PIXI.interaction
 */
var InteractionTrackingData = function () {
    /**
     * @param {number} pointerId - Unique pointer id of the event
     */
    function InteractionTrackingData(pointerId) {
        _classCallCheck(this, InteractionTrackingData);

        this._pointerId = pointerId;
        this._flags = InteractionTrackingData.FLAGS.NONE;
    }

    /**
     *
     * @private
     * @param {number} flag - The interaction flag to set
     * @param {boolean} yn - Should the flag be set or unset
     */


    InteractionTrackingData.prototype._doSet = function _doSet(flag, yn) {
        if (yn) {
            this._flags = this._flags | flag;
        } else {
            this._flags = this._flags & ~flag;
        }
    };

    /**
     * Unique pointer id of the event
     *
     * @readonly
     * @member {number}
     */


    _createClass(InteractionTrackingData, [{
        key: "pointerId",
        get: function get() {
            return this._pointerId;
        }

        /**
         * State of the tracking data, expressed as bit flags
         *
         * @member {number}
         * @memberof PIXI.interaction.InteractionTrackingData#
         */

    }, {
        key: "flags",
        get: function get() {
            return this._flags;
        }

        /**
         * Set the flags for the tracking data
         *
         * @param {number} flags - Flags to set
         */
        ,
        set: function set(flags) {
            this._flags = flags;
        }

        /**
         * Is the tracked event inactive (not over or down)?
         *
         * @member {number}
         * @memberof PIXI.interaction.InteractionTrackingData#
         */

    }, {
        key: "none",
        get: function get() {
            return this._flags === this.constructor.FLAGS.NONE;
        }

        /**
         * Is the tracked event over the DisplayObject?
         *
         * @member {boolean}
         * @memberof PIXI.interaction.InteractionTrackingData#
         */

    }, {
        key: "over",
        get: function get() {
            return (this._flags & this.constructor.FLAGS.OVER) !== 0;
        }

        /**
         * Set the over flag
         *
         * @param {boolean} yn - Is the event over?
         */
        ,
        set: function set(yn) {
            this._doSet(this.constructor.FLAGS.OVER, yn);
        }

        /**
         * Did the right mouse button come down in the DisplayObject?
         *
         * @member {boolean}
         * @memberof PIXI.interaction.InteractionTrackingData#
         */

    }, {
        key: "rightDown",
        get: function get() {
            return (this._flags & this.constructor.FLAGS.RIGHT_DOWN) !== 0;
        }

        /**
         * Set the right down flag
         *
         * @param {boolean} yn - Is the right mouse button down?
         */
        ,
        set: function set(yn) {
            this._doSet(this.constructor.FLAGS.RIGHT_DOWN, yn);
        }

        /**
         * Did the left mouse button come down in the DisplayObject?
         *
         * @member {boolean}
         * @memberof PIXI.interaction.InteractionTrackingData#
         */

    }, {
        key: "leftDown",
        get: function get() {
            return (this._flags & this.constructor.FLAGS.LEFT_DOWN) !== 0;
        }

        /**
         * Set the left down flag
         *
         * @param {boolean} yn - Is the left mouse button down?
         */
        ,
        set: function set(yn) {
            this._doSet(this.constructor.FLAGS.LEFT_DOWN, yn);
        }
    }]);

    return InteractionTrackingData;
}();

exports.default = InteractionTrackingData;


InteractionTrackingData.FLAGS = Object.freeze({
    NONE: 0,
    OVER: 1 << 0,
    LEFT_DOWN: 1 << 1,
    RIGHT_DOWN: 1 << 2
});

},{}],167:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _InteractionData = require('./InteractionData');

Object.defineProperty(exports, 'InteractionData', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_InteractionData).default;
  }
});

var _InteractionManager = require('./InteractionManager');

Object.defineProperty(exports, 'InteractionManager', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_InteractionManager).default;
  }
});

var _interactiveTarget = require('./interactiveTarget');

Object.defineProperty(exports, 'interactiveTarget', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_interactiveTarget).default;
  }
});

var _InteractionTrackingData = require('./InteractionTrackingData');

Object.defineProperty(exports, 'InteractionTrackingData', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_InteractionTrackingData).default;
  }
});

var _InteractionEvent = require('./InteractionEvent');

Object.defineProperty(exports, 'InteractionEvent', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_InteractionEvent).default;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

},{"./InteractionData":163,"./InteractionEvent":164,"./InteractionManager":165,"./InteractionTrackingData":166,"./interactiveTarget":168}],168:[function(require,module,exports){
'use strict';

exports.__esModule = true;
/**
 * Default property values of interactive objects
 * Used by {@link PIXI.interaction.InteractionManager} to automatically give all DisplayObjects these properties
 *
 * @private
 * @name interactiveTarget
 * @memberof PIXI.interaction
 * @example
 *      function MyObject() {}
 *
 *      Object.assign(
 *          core.DisplayObject.prototype,
 *          PIXI.interaction.interactiveTarget
 *      );
 */
exports.default = {

  /**
   * Enable interaction events for the DisplayObject. Touch, pointer and mouse
   * events will not be emitted unless `interactive` is set to `true`.
   *
   * @example
   * const sprite = new PIXI.Sprite(texture);
   * sprite.interactive = true;
   * sprite.on('tap', (event) => {
   *    //handle event
   * });
   * @member {boolean}
   * @memberof PIXI.DisplayObject#
   */
  interactive: false,

  /**
   * Determines if the children to the displayObject can be clicked/touched
   * Setting this to false allows PixiJS to bypass a recursive `hitTest` function
   *
   * @member {boolean}
   * @memberof PIXI.Container#
   */
  interactiveChildren: true,

  /**
   * Interaction shape. Children will be hit first, then this shape will be checked.
   * Setting this will cause this shape to be checked in hit tests rather than the displayObject's bounds.
   *
   * @example
   * const sprite = new PIXI.Sprite(texture);
   * sprite.interactive = true;
   * sprite.hitArea = new PIXI.Rectangle(0, 0, 100, 100);
   * @member {PIXI.Rectangle|PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.RoundedRectangle}
   * @memberof PIXI.DisplayObject#
   */
  hitArea: null,

  /**
   * If enabled, the mouse cursor use the pointer behavior when hovered over the displayObject if it is interactive
   * Setting this changes the 'cursor' property to `'pointer'`.
   *
   * @example
   * const sprite = new PIXI.Sprite(texture);
   * sprite.interactive = true;
   * sprite.buttonMode = true;
   * @member {boolean}
   * @memberof PIXI.DisplayObject#
   */
  get buttonMode() {
    return this.cursor === 'pointer';
  },
  set buttonMode(value) {
    if (value) {
      this.cursor = 'pointer';
    } else if (this.cursor === 'pointer') {
      this.cursor = null;
    }
  },

  /**
   * This defines what cursor mode is used when the mouse cursor
   * is hovered over the displayObject.
   *
   * @example
   * const sprite = new PIXI.Sprite(texture);
   * sprite.interactive = true;
   * sprite.cursor = 'wait';
   * @see https://developer.mozilla.org/en/docs/Web/CSS/cursor
   *
   * @member {string}
   * @memberof PIXI.DisplayObject#
   */
  cursor: null,

  /**
   * Internal set of all active pointers, by identifier
   *
   * @member {Map<number, InteractionTrackingData>}
   * @memberof PIXI.DisplayObject#
   * @private
   */
  get trackedPointers() {
    if (this._trackedPointers === undefined) this._trackedPointers = {};

    return this._trackedPointers;
  },

  /**
   * Map of all tracked pointers, by identifier. Use trackedPointers to access.
   *
   * @private
   * @type {Map<number, InteractionTrackingData>}
   */
  _trackedPointers: undefined
};

},{}],169:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.parse = parse;

exports.default = function () {
    return function bitmapFontParser(resource, next) {
        // skip if no data or not xml data
        if (!resource.data || resource.type !== _resourceLoader.Resource.TYPE.XML) {
            next();

            return;
        }

        // skip if not bitmap font data, using some silly duck-typing
        if (resource.data.getElementsByTagName('page').length === 0 || resource.data.getElementsByTagName('info').length === 0 || resource.data.getElementsByTagName('info')[0].getAttribute('face') === null) {
            next();

            return;
        }

        var xmlUrl = !resource.isDataUrl ? path.dirname(resource.url) : '';

        if (resource.isDataUrl) {
            if (xmlUrl === '.') {
                xmlUrl = '';
            }

            if (this.baseUrl && xmlUrl) {
                // if baseurl has a trailing slash then add one to xmlUrl so the replace works below
                if (this.baseUrl.charAt(this.baseUrl.length - 1) === '/') {
                    xmlUrl += '/';
                }
            }
        }

        // remove baseUrl from xmlUrl
        xmlUrl = xmlUrl.replace(this.baseUrl, '');

        // if there is an xmlUrl now, it needs a trailing slash. Ensure that it does if the string isn't empty.
        if (xmlUrl && xmlUrl.charAt(xmlUrl.length - 1) !== '/') {
            xmlUrl += '/';
        }

        var pages = resource.data.getElementsByTagName('page');
        var textures = {};

        // Handle completed, when the number of textures
        // load is the same number as references in the fnt file
        var completed = function completed(page) {
            textures[page.metadata.pageFile] = page.texture;

            if (Object.keys(textures).length === pages.length) {
                parse(resource, textures);
                next();
            }
        };

        for (var i = 0; i < pages.length; ++i) {
            var pageFile = pages[i].getAttribute('file');
            var url = xmlUrl + pageFile;
            var exists = false;

            // incase the image is loaded outside
            // using the same loader, resource will be available
            for (var name in this.resources) {
                var bitmapResource = this.resources[name];

                if (bitmapResource.url === url) {
                    bitmapResource.metadata.pageFile = pageFile;
                    if (bitmapResource.texture) {
                        completed(bitmapResource);
                    } else {
                        bitmapResource.onAfterMiddleware.add(completed);
                    }
                    exists = true;
                    break;
                }
            }

            // texture is not loaded, we'll attempt to add
            // it to the load and add the texture to the list
            if (!exists) {
                // Standard loading options for images
                var options = {
                    crossOrigin: resource.crossOrigin,
                    loadType: _resourceLoader.Resource.LOAD_TYPE.IMAGE,
                    metadata: Object.assign({ pageFile: pageFile }, resource.metadata.imageMetadata),
                    parentResource: resource
                };

                this.add(url, options, completed);
            }
        }
    };
};

var _path = require('path');

var path = _interopRequireWildcard(_path);

var _resourceLoader = require('resource-loader');

var _extras = require('../extras');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * Register a BitmapText font from loader resource.
 *
 * @function parseBitmapFontData
 * @memberof PIXI.loaders
 * @param {PIXI.loaders.Resource} resource - Loader resource.
 * @param {PIXI.Texture|PIXI.Texture[]} textures - List of textures for each page.
 */
function parse(resource, textures) {
    resource.bitmapFont = _extras.BitmapText.registerFont(resource.data, textures);
}

},{"../extras":148,"path":1,"resource-loader":202}],170:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.shared = exports.Resource = exports.textureParser = exports.getResourcePath = exports.spritesheetParser = exports.parseBitmapFontData = exports.bitmapFontParser = exports.Loader = undefined;

var _bitmapFontParser = require('./bitmapFontParser');

Object.defineProperty(exports, 'bitmapFontParser', {
    enumerable: true,
    get: function get() {
        return _interopRequireDefault(_bitmapFontParser).default;
    }
});
Object.defineProperty(exports, 'parseBitmapFontData', {
    enumerable: true,
    get: function get() {
        return _bitmapFontParser.parse;
    }
});

var _spritesheetParser = require('./spritesheetParser');

Object.defineProperty(exports, 'spritesheetParser', {
    enumerable: true,
    get: function get() {
        return _interopRequireDefault(_spritesheetParser).default;
    }
});
Object.defineProperty(exports, 'getResourcePath', {
    enumerable: true,
    get: function get() {
        return _spritesheetParser.getResourcePath;
    }
});

var _textureParser = require('./textureParser');

Object.defineProperty(exports, 'textureParser', {
    enumerable: true,
    get: function get() {
        return _interopRequireDefault(_textureParser).default;
    }
});

var _resourceLoader = require('resource-loader');

Object.defineProperty(exports, 'Resource', {
    enumerable: true,
    get: function get() {
        return _resourceLoader.Resource;
    }
});

var _Application = require('../core/Application');

var _Application2 = _interopRequireDefault(_Application);

var _loader = require('./loader');

var _loader2 = _interopRequireDefault(_loader);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * This namespace contains APIs which extends the {@link https://github.com/englercj/resource-loader resource-loader} module
 * for loading assets, data, and other resources dynamically.
 * @example
 * const loader = new PIXI.loaders.Loader();
 * loader.add('bunny', 'data/bunny.png')
 *       .add('spaceship', 'assets/spritesheet.json');
 * loader.load((loader, resources) => {
 *    // resources.bunny
 *    // resources.spaceship
 * });
 * @namespace PIXI.loaders
 */
exports.Loader = _loader2.default;


/**
 * A premade instance of the loader that can be used to load resources.
 * @name shared
 * @memberof PIXI.loaders
 * @type {PIXI.loaders.Loader}
 */
var shared = new _loader2.default();

shared.destroy = function () {
    // protect destroying shared loader
};

exports.shared = shared;

// Mixin the loader construction

var AppPrototype = _Application2.default.prototype;

AppPrototype._loader = null;

/**
 * Loader instance to help with asset loading.
 * @name PIXI.Application#loader
 * @type {PIXI.loaders.Loader}
 */
Object.defineProperty(AppPrototype, 'loader', {
    get: function get() {
        if (!this._loader) {
            var sharedLoader = this._options.sharedLoader;

            this._loader = sharedLoader ? shared : new _loader2.default();
        }

        return this._loader;
    }
});

// Override the destroy function
// making sure to destroy the current Loader
AppPrototype._parentDestroy = AppPrototype.destroy;
AppPrototype.destroy = function destroy(removeView, stageOptions) {
    if (this._loader) {
        this._loader.destroy();
        this._loader = null;
    }
    this._parentDestroy(removeView, stageOptions);
};

},{"../core/Application":50,"./bitmapFontParser":169,"./loader":171,"./spritesheetParser":172,"./textureParser":173,"resource-loader":202}],171:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _resourceLoader = require('resource-loader');

var _resourceLoader2 = _interopRequireDefault(_resourceLoader);

var _blob = require('resource-loader/lib/middlewares/parsing/blob');

var _eventemitter = require('eventemitter3');

var _eventemitter2 = _interopRequireDefault(_eventemitter);

var _textureParser = require('./textureParser');

var _textureParser2 = _interopRequireDefault(_textureParser);

var _spritesheetParser = require('./spritesheetParser');

var _spritesheetParser2 = _interopRequireDefault(_spritesheetParser);

var _bitmapFontParser = require('./bitmapFontParser');

var _bitmapFontParser2 = _interopRequireDefault(_bitmapFontParser);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 *
 * The new loader, extends Resource Loader by Chad Engler: https://github.com/englercj/resource-loader
 *
 * ```js
 * const loader = PIXI.loader; // PixiJS exposes a premade instance for you to use.
 * //or
 * const loader = new PIXI.loaders.Loader(); // you can also create your own if you want
 *
 * const sprites = {};
 *
 * // Chainable `add` to enqueue a resource
 * loader.add('bunny', 'data/bunny.png')
 *       .add('spaceship', 'assets/spritesheet.json');
 * loader.add('scoreFont', 'assets/score.fnt');
 *
 * // Chainable `pre` to add a middleware that runs for each resource, *before* loading that resource.
 * // This is useful to implement custom caching modules (using filesystem, indexeddb, memory, etc).
 * loader.pre(cachingMiddleware);
 *
 * // Chainable `use` to add a middleware that runs for each resource, *after* loading that resource.
 * // This is useful to implement custom parsing modules (like spritesheet parsers, spine parser, etc).
 * loader.use(parsingMiddleware);
 *
 * // The `load` method loads the queue of resources, and calls the passed in callback called once all
 * // resources have loaded.
 * loader.load((loader, resources) => {
 *     // resources is an object where the key is the name of the resource loaded and the value is the resource object.
 *     // They have a couple default properties:
 *     // - `url`: The URL that the resource was loaded from
 *     // - `error`: The error that happened when trying to load (if any)
 *     // - `data`: The raw data that was loaded
 *     // also may contain other properties based on the middleware that runs.
 *     sprites.bunny = new PIXI.TilingSprite(resources.bunny.texture);
 *     sprites.spaceship = new PIXI.TilingSprite(resources.spaceship.texture);
 *     sprites.scoreFont = new PIXI.TilingSprite(resources.scoreFont.texture);
 * });
 *
 * // throughout the process multiple signals can be dispatched.
 * loader.onProgress.add(() => {}); // called once per loaded/errored file
 * loader.onError.add(() => {}); // called once per errored file
 * loader.onLoad.add(() => {}); // called once per loaded file
 * loader.onComplete.add(() => {}); // called once when the queued resources all load.
 * ```
 *
 * @see https://github.com/englercj/resource-loader
 *
 * @class
 * @extends module:resource-loader.ResourceLoader
 * @memberof PIXI.loaders
 */
var Loader = function (_ResourceLoader) {
    _inherits(Loader, _ResourceLoader);

    /**
     * @param {string} [baseUrl=''] - The base url for all resources loaded by this loader.
     * @param {number} [concurrency=10] - The number of resources to load concurrently.
     */
    function Loader(baseUrl, concurrency) {
        _classCallCheck(this, Loader);

        var _this = _possibleConstructorReturn(this, _ResourceLoader.call(this, baseUrl, concurrency));

        _eventemitter2.default.call(_this);

        for (var i = 0; i < Loader._pixiMiddleware.length; ++i) {
            _this.use(Loader._pixiMiddleware[i]());
        }

        // Compat layer, translate the new v2 signals into old v1 events.
        _this.onStart.add(function (l) {
            return _this.emit('start', l);
        });
        _this.onProgress.add(function (l, r) {
            return _this.emit('progress', l, r);
        });
        _this.onError.add(function (e, l, r) {
            return _this.emit('error', e, l, r);
        });
        _this.onLoad.add(function (l, r) {
            return _this.emit('load', l, r);
        });
        _this.onComplete.add(function (l, r) {
            return _this.emit('complete', l, r);
        });
        return _this;
    }

    /**
     * Adds a default middleware to the PixiJS loader.
     *
     * @static
     * @param {Function} fn - The middleware to add.
     */


    Loader.addPixiMiddleware = function addPixiMiddleware(fn) {
        Loader._pixiMiddleware.push(fn);
    };

    /**
     * Destroy the loader, removes references.
     */


    Loader.prototype.destroy = function destroy() {
        this.removeAllListeners();
        this.reset();
    };

    return Loader;
}(_resourceLoader2.default);

// Copy EE3 prototype (mixin)


exports.default = Loader;
for (var k in _eventemitter2.default.prototype) {
    Loader.prototype[k] = _eventemitter2.default.prototype[k];
}

Loader._pixiMiddleware = [
// parse any blob into more usable objects (e.g. Image)
_blob.blobMiddlewareFactory,
// parse any Image objects into textures
_textureParser2.default,
// parse any spritesheet data into multiple textures
_spritesheetParser2.default,
// parse bitmap font data into multiple textures
_bitmapFontParser2.default];

// Add custom extentions
var Resource = _resourceLoader2.default.Resource;

Resource.setExtensionXhrType('fnt', Resource.XHR_RESPONSE_TYPE.DOCUMENT);

},{"./bitmapFontParser":169,"./spritesheetParser":172,"./textureParser":173,"eventemitter3":24,"resource-loader":202,"resource-loader/lib/middlewares/parsing/blob":203}],172:[function(require,module,exports){
'use strict';

exports.__esModule = true;

exports.default = function () {
    return function spritesheetParser(resource, next) {
        var imageResourceName = resource.name + '_image';

        // skip if no data, its not json, it isn't spritesheet data, or the image resource already exists
        if (!resource.data || resource.type !== _resourceLoader.Resource.TYPE.JSON || !resource.data.frames || this.resources[imageResourceName]) {
            next();

            return;
        }

        var loadOptions = {
            crossOrigin: resource.crossOrigin,
            metadata: resource.metadata.imageMetadata,
            parentResource: resource
        };

        var resourcePath = getResourcePath(resource, this.baseUrl);

        // load the image for this sheet
        this.add(imageResourceName, resourcePath, loadOptions, function onImageLoad(res) {
            if (res.error) {
                next(res.error);

                return;
            }

            var spritesheet = new _core.Spritesheet(res.texture.baseTexture, resource.data, resource.url);

            spritesheet.parse(function () {
                resource.spritesheet = spritesheet;
                resource.textures = spritesheet.textures;
                next();
            });
        });
    };
};

exports.getResourcePath = getResourcePath;

var _resourceLoader = require('resource-loader');

var _url = require('url');

var _url2 = _interopRequireDefault(_url);

var _core = require('../core');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getResourcePath(resource, baseUrl) {
    // Prepend url path unless the resource image is a data url
    if (resource.isDataUrl) {
        return resource.data.meta.image;
    }

    return _url2.default.resolve(resource.url.replace(baseUrl, ''), resource.data.meta.image);
}

},{"../core":72,"resource-loader":202,"url":7}],173:[function(require,module,exports){
'use strict';

exports.__esModule = true;

exports.default = function () {
    return function textureParser(resource, next) {
        // create a new texture if the data is an Image object
        if (resource.data && resource.type === _resourceLoader.Resource.TYPE.IMAGE) {
            resource.texture = _Texture2.default.fromLoader(resource.data, resource.url, resource.name);
        }
        next();
    };
};

var _resourceLoader = require('resource-loader');

var _Texture = require('../core/textures/Texture');

var _Texture2 = _interopRequireDefault(_Texture);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

},{"../core/textures/Texture":122,"resource-loader":202}],174:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _core = require('../core');

var core = _interopRequireWildcard(_core);

var _Texture = require('../core/textures/Texture');

var _Texture2 = _interopRequireDefault(_Texture);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var tempPoint = new core.Point();
var tempPolygon = new core.Polygon();

/**
 * Base mesh class
 * @class
 * @extends PIXI.Container
 * @memberof PIXI.mesh
 */

var Mesh = function (_core$Container) {
    _inherits(Mesh, _core$Container);

    /**
     * @param {PIXI.Texture} texture - The texture to use
     * @param {Float32Array} [vertices] - if you want to specify the vertices
     * @param {Float32Array} [uvs] - if you want to specify the uvs
     * @param {Uint16Array} [indices] - if you want to specify the indices
     * @param {number} [drawMode] - the drawMode, can be any of the Mesh.DRAW_MODES consts
     */
    function Mesh(texture, vertices, uvs, indices, drawMode) {
        _classCallCheck(this, Mesh);

        /**
         * The texture of the Mesh
         *
         * @member {PIXI.Texture}
         * @default PIXI.Texture.EMPTY
         * @private
         */
        var _this = _possibleConstructorReturn(this, _core$Container.call(this));

        _this._texture = texture || _Texture2.default.EMPTY;

        /**
         * The Uvs of the Mesh
         *
         * @member {Float32Array}
         */
        _this.uvs = uvs || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);

        /**
         * An array of vertices
         *
         * @member {Float32Array}
         */
        _this.vertices = vertices || new Float32Array([0, 0, 100, 0, 100, 100, 0, 100]);

        /**
         * An array containing the indices of the vertices
         *
         * @member {Uint16Array}
         */
        //  TODO auto generate this based on draw mode!
        _this.indices = indices || new Uint16Array([0, 1, 3, 2]);

        /**
         * Version of mesh uvs are dirty or not
         *
         * @member {number}
         */
        _this.dirty = 0;

        /**
         * Version of mesh indices
         *
         * @member {number}
         */
        _this.indexDirty = 0;

        /**
         * Version of mesh verticies array
         *
         * @member {number}
         */
        _this.vertexDirty = 0;

        /**
         * For backwards compatibility the default is to re-upload verticies each render call.
         * Set this to `false` and increase `vertexDirty` to manually re-upload the buffer.
         *
         * @member {boolean}
         */
        _this.autoUpdate = true;

        /**
         * The blend mode to be applied to the sprite. Set to `PIXI.BLEND_MODES.NORMAL` to remove
         * any blend mode.
         *
         * @member {number}
         * @default PIXI.BLEND_MODES.NORMAL
         * @see PIXI.BLEND_MODES
         */
        _this.blendMode = core.BLEND_MODES.NORMAL;

        /**
         * Triangles in canvas mode are automatically antialiased, use this value to force triangles
         * to overlap a bit with each other.
         *
         * @member {number}
         */
        _this.canvasPadding = core.settings.MESH_CANVAS_PADDING;

        /**
         * The way the Mesh should be drawn, can be any of the {@link PIXI.mesh.Mesh.DRAW_MODES} consts
         *
         * @member {number}
         * @see PIXI.mesh.Mesh.DRAW_MODES
         */
        _this.drawMode = drawMode || Mesh.DRAW_MODES.TRIANGLE_MESH;

        /**
         * The default shader that is used if a mesh doesn't have a more specific one.
         *
         * @member {PIXI.Shader}
         */
        _this.shader = null;

        /**
         * The tint applied to the mesh. This is a [r,g,b] value. A value of [1,1,1] will remove any
         * tint effect.
         *
         * @member {number}
         */
        _this.tintRgb = new Float32Array([1, 1, 1]);

        /**
         * A map of renderer IDs to webgl render data
         *
         * @private
         * @member {object<number, object>}
         */
        _this._glDatas = {};

        /**
         * transform that is applied to UV to get the texture coords
         * its updated independently from texture uvTransform
         * updates of uvs are tied to that thing
         *
         * @member {PIXI.TextureMatrix}
         * @private
         */
        _this._uvTransform = new core.TextureMatrix(_this._texture);

        /**
         * whether or not upload uvTransform to shader
         * if its false, then uvs should be pre-multiplied
         * if you change it for generated mesh, please call 'refresh(true)'
         * @member {boolean}
         * @default false
         */
        _this.uploadUvTransform = false;

        /**
         * Plugin that is responsible for rendering this element.
         * Allows to customize the rendering process without overriding '_renderWebGL' & '_renderCanvas' methods.
         * @member {string}
         * @default 'mesh'
         */
        _this.pluginName = 'mesh';
        return _this;
    }

    /**
     * Renders the object using the WebGL renderer
     *
     * @private
     * @param {PIXI.WebGLRenderer} renderer - a reference to the WebGL renderer
     */


    Mesh.prototype._renderWebGL = function _renderWebGL(renderer) {
        this.refresh();
        renderer.setObjectRenderer(renderer.plugins[this.pluginName]);
        renderer.plugins[this.pluginName].render(this);
    };

    /**
     * Renders the object using the Canvas renderer
     *
     * @private
     * @param {PIXI.CanvasRenderer} renderer - The canvas renderer.
     */


    Mesh.prototype._renderCanvas = function _renderCanvas(renderer) {
        this.refresh();
        renderer.plugins[this.pluginName].render(this);
    };

    /**
     * When the texture is updated, this event will fire to update the scale and frame
     *
     * @private
     */


    Mesh.prototype._onTextureUpdate = function _onTextureUpdate() {
        this._uvTransform.texture = this._texture;
        this.refresh();
    };

    /**
     * multiplies uvs only if uploadUvTransform is false
     * call it after you change uvs manually
     * make sure that texture is valid
     */


    Mesh.prototype.multiplyUvs = function multiplyUvs() {
        if (!this.uploadUvTransform) {
            this._uvTransform.multiplyUvs(this.uvs);
        }
    };

    /**
     * Refreshes uvs for generated meshes (rope, plane)
     * sometimes refreshes vertices too
     *
     * @param {boolean} [forceUpdate=false] if true, matrices will be updated any case
     */


    Mesh.prototype.refresh = function refresh(forceUpdate) {
        if (this.autoUpdate) {
            this.vertexDirty++;
        }
        if (this._uvTransform.update(forceUpdate)) {
            this._refresh();
        }
    };

    /**
     * re-calculates mesh coords
     * @protected
     */


    Mesh.prototype._refresh = function _refresh() {}
    /* empty */


    /**
     * Returns the bounds of the mesh as a rectangle. The bounds calculation takes the worldTransform into account.
     *
     */
    ;

    Mesh.prototype._calculateBounds = function _calculateBounds() {
        // TODO - we can cache local bounds and use them if they are dirty (like graphics)
        this._bounds.addVertices(this.transform, this.vertices, 0, this.vertices.length);
    };

    /**
     * Tests if a point is inside this mesh. Works only for TRIANGLE_MESH
     *
     * @param {PIXI.Point} point - the point to test
     * @return {boolean} the result of the test
     */


    Mesh.prototype.containsPoint = function containsPoint(point) {
        if (!this.getBounds().contains(point.x, point.y)) {
            return false;
        }

        this.worldTransform.applyInverse(point, tempPoint);

        var vertices = this.vertices;
        var points = tempPolygon.points;
        var indices = this.indices;
        var len = this.indices.length;
        var step = this.drawMode === Mesh.DRAW_MODES.TRIANGLES ? 3 : 1;

        for (var i = 0; i + 2 < len; i += step) {
            var ind0 = indices[i] * 2;
            var ind1 = indices[i + 1] * 2;
            var ind2 = indices[i + 2] * 2;

            points[0] = vertices[ind0];
            points[1] = vertices[ind0 + 1];
            points[2] = vertices[ind1];
            points[3] = vertices[ind1 + 1];
            points[4] = vertices[ind2];
            points[5] = vertices[ind2 + 1];

            if (tempPolygon.contains(tempPoint.x, tempPoint.y)) {
                return true;
            }
        }

        return false;
    };

    /**
     * The texture that the mesh uses.
     *
     * @member {PIXI.Texture}
     */


    /**
     * Destroys the Mesh object.
     *
     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all
     *  options have been set to that value
     * @param {boolean} [options.children=false] - if set to true, all the children will have
     *  their destroy method called as well. 'options' will be passed on to those calls.
     * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true
     *  Should it destroy the texture of the child sprite
     * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true
     *  Should it destroy the base texture of the child sprite
     */
    Mesh.prototype.destroy = function destroy(options) {
        // for each webgl data entry, destroy the WebGLGraphicsData
        for (var id in this._glDatas) {
            var data = this._glDatas[id];

            if (data.destroy) {
                data.destroy();
            } else {
                if (data.vertexBuffer) {
                    data.vertexBuffer.destroy();
                    data.vertexBuffer = null;
                }
                if (data.indexBuffer) {
                    data.indexBuffer.destroy();
                    data.indexBuffer = null;
                }
                if (data.uvBuffer) {
                    data.uvBuffer.destroy();
                    data.uvBuffer = null;
                }
                if (data.vao) {
                    data.vao.destroy();
                    data.vao = null;
                }
            }
        }

        this._glDatas = null;

        _core$Container.prototype.destroy.call(this, options);
    };

    _createClass(Mesh, [{
        key: 'texture',
        get: function get() {
            return this._texture;
        },
        set: function set(value) // eslint-disable-line require-jsdoc
        {
            if (this._texture === value) {
                return;
            }

            this._texture = value;

            if (value) {
                // wait for the texture to load
                if (value.baseTexture.hasLoaded) {
                    this._onTextureUpdate();
                } else {
                    value.once('update', this._onTextureUpdate, this);
                }
            }
        }

        /**
         * The tint applied to the mesh. This is a hex value. A value of 0xFFFFFF will remove any tint effect.
         *
         * @member {number}
         * @default 0xFFFFFF
         */

    }, {
        key: 'tint',
        get: function get() {
            return core.utils.rgb2hex(this.tintRgb);
        },
        set: function set(value) // eslint-disable-line require-jsdoc
        {
            this.tintRgb = core.utils.hex2rgb(value, this.tintRgb);
        }
    }]);

    return Mesh;
}(core.Container);

/**
 * Different drawing buffer modes supported
 *
 * @static
 * @constant
 * @type {object}
 * @property {number} TRIANGLE_MESH
 * @property {number} TRIANGLES
 */


exports.default = Mesh;
Mesh.DRAW_MODES = {
    TRIANGLE_MESH: 0,
    TRIANGLES: 1
};

},{"../core":72,"../core/textures/Texture":122}],175:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Plane2 = require('./Plane');

var _Plane3 = _interopRequireDefault(_Plane2);

var _CanvasTinter = require('../core/sprites/canvas/CanvasTinter');

var _CanvasTinter2 = _interopRequireDefault(_CanvasTinter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DEFAULT_BORDER_SIZE = 10;

/**
 * The NineSlicePlane allows you to stretch a texture using 9-slice scaling. The corners will remain unscaled (useful
 * for buttons with rounded corners for example) and the other areas will be scaled horizontally and or vertically
 *
 *```js
 * let Plane9 = new PIXI.NineSlicePlane(PIXI.Texture.fromImage('BoxWithRoundedCorners.png'), 15, 15, 15, 15);
 *  ```
 * <pre>
 *      A                          B
 *    +---+----------------------+---+
 *  C | 1 |          2           | 3 |
 *    +---+----------------------+---+
 *    |   |                      |   |
 *    | 4 |          5           | 6 |
 *    |   |                      |   |
 *    +---+----------------------+---+
 *  D | 7 |          8           | 9 |
 *    +---+----------------------+---+

 *  When changing this objects width and/or height:
 *     areas 1 3 7 and 9 will remain unscaled.
 *     areas 2 and 8 will be stretched horizontally
 *     areas 4 and 6 will be stretched vertically
 *     area 5 will be stretched both horizontally and vertically
 * </pre>
 *
 * @class
 * @extends PIXI.mesh.Plane
 * @memberof PIXI.mesh
 *
 */

var NineSlicePlane = function (_Plane) {
    _inherits(NineSlicePlane, _Plane);

    /**
     * @param {PIXI.Texture} texture - The texture to use on the NineSlicePlane.
     * @param {int} [leftWidth=10] size of the left vertical bar (A)
     * @param {int} [topHeight=10] size of the top horizontal bar (C)
     * @param {int} [rightWidth=10] size of the right vertical bar (B)
     * @param {int} [bottomHeight=10] size of the bottom horizontal bar (D)
     */
    function NineSlicePlane(texture, leftWidth, topHeight, rightWidth, bottomHeight) {
        _classCallCheck(this, NineSlicePlane);

        var _this = _possibleConstructorReturn(this, _Plane.call(this, texture, 4, 4));

        _this._origWidth = texture.orig.width;
        _this._origHeight = texture.orig.height;

        /**
         * The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane
         *
         * @member {number}
         * @memberof PIXI.NineSlicePlane#
         * @override
         */
        _this._width = _this._origWidth;

        /**
         * The height of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane
         *
         * @member {number}
         * @memberof PIXI.NineSlicePlane#
         * @override
         */
        _this._height = _this._origHeight;

        /**
         * The width of the left column (a)
         *
         * @member {number}
         * @memberof PIXI.NineSlicePlane#
         * @override
         */
        _this._leftWidth = typeof leftWidth !== 'undefined' ? leftWidth : DEFAULT_BORDER_SIZE;

        /**
         * The width of the right column (b)
         *
         * @member {number}
         * @memberof PIXI.NineSlicePlane#
         * @override
         */
        _this._rightWidth = typeof rightWidth !== 'undefined' ? rightWidth : DEFAULT_BORDER_SIZE;

        /**
         * The height of the top row (c)
         *
         * @member {number}
         * @memberof PIXI.NineSlicePlane#
         * @override
         */
        _this._topHeight = typeof topHeight !== 'undefined' ? topHeight : DEFAULT_BORDER_SIZE;

        /**
         * The height of the bottom row (d)
         *
         * @member {number}
         * @memberof PIXI.NineSlicePlane#
         * @override
         */
        _this._bottomHeight = typeof bottomHeight !== 'undefined' ? bottomHeight : DEFAULT_BORDER_SIZE;

        /**
         * Cached tint value so we can tell when the tint is changed.
         *
         * @member {number}
         * @protected
         */
        _this._cachedTint = 0xFFFFFF;

        /**
         * Cached tinted texture.
         *
         * @member {HTMLCanvasElement}
         * @protected
         */
        _this._tintedTexture = null;

        /**
         * Temporary storage for canvas source coords
         *
         * @member {number[]}
         * @private
         */
        _this._canvasUvs = null;

        _this.refresh(true);
        return _this;
    }

    /**
     * Updates the horizontal vertices.
     *
     */


    NineSlicePlane.prototype.updateHorizontalVertices = function updateHorizontalVertices() {
        var vertices = this.vertices;

        var h = this._topHeight + this._bottomHeight;
        var scale = this._height > h ? 1.0 : this._height / h;

        vertices[9] = vertices[11] = vertices[13] = vertices[15] = this._topHeight * scale;
        vertices[17] = vertices[19] = vertices[21] = vertices[23] = this._height - this._bottomHeight * scale;
        vertices[25] = vertices[27] = vertices[29] = vertices[31] = this._height;
    };

    /**
     * Updates the vertical vertices.
     *
     */


    NineSlicePlane.prototype.updateVerticalVertices = function updateVerticalVertices() {
        var vertices = this.vertices;

        var w = this._leftWidth + this._rightWidth;
        var scale = this._width > w ? 1.0 : this._width / w;

        vertices[2] = vertices[10] = vertices[18] = vertices[26] = this._leftWidth * scale;
        vertices[4] = vertices[12] = vertices[20] = vertices[28] = this._width - this._rightWidth * scale;
        vertices[6] = vertices[14] = vertices[22] = vertices[30] = this._width;
    };

    /**
     * Renders the object using the Canvas renderer
     *
     * @private
     * @param {PIXI.CanvasRenderer} renderer - The canvas renderer to render with.
     */


    NineSlicePlane.prototype._renderCanvas = function _renderCanvas(renderer) {
        var context = renderer.context;
        var transform = this.worldTransform;
        var res = renderer.resolution;
        var isTinted = this.tint !== 0xFFFFFF;
        var texture = this._texture;

        // Work out tinting
        if (isTinted) {
            if (this._cachedTint !== this.tint) {
                // Tint has changed, need to update the tinted texture and use that instead

                this._cachedTint = this.tint;

                this._tintedTexture = _CanvasTinter2.default.getTintedTexture(this, this.tint);
            }
        }

        var textureSource = !isTinted ? texture.baseTexture.source : this._tintedTexture;

        if (!this._canvasUvs) {
            this._canvasUvs = [0, 0, 0, 0, 0, 0, 0, 0];
        }

        var vertices = this.vertices;
        var uvs = this._canvasUvs;
        var u0 = isTinted ? 0 : texture.frame.x;
        var v0 = isTinted ? 0 : texture.frame.y;
        var u1 = u0 + texture.frame.width;
        var v1 = v0 + texture.frame.height;

        uvs[0] = u0;
        uvs[1] = u0 + this._leftWidth;
        uvs[2] = u1 - this._rightWidth;
        uvs[3] = u1;
        uvs[4] = v0;
        uvs[5] = v0 + this._topHeight;
        uvs[6] = v1 - this._bottomHeight;
        uvs[7] = v1;

        for (var i = 0; i < 8; i++) {
            uvs[i] *= texture.baseTexture.resolution;
        }

        context.globalAlpha = this.worldAlpha;
        renderer.setBlendMode(this.blendMode);

        if (renderer.roundPixels) {
            context.setTransform(transform.a * res, transform.b * res, transform.c * res, transform.d * res, transform.tx * res | 0, transform.ty * res | 0);
        } else {
            context.setTransform(transform.a * res, transform.b * res, transform.c * res, transform.d * res, transform.tx * res, transform.ty * res);
        }

        for (var row = 0; row < 3; row++) {
            for (var col = 0; col < 3; col++) {
                var ind = col * 2 + row * 8;
                var sw = Math.max(1, uvs[col + 1] - uvs[col]);
                var sh = Math.max(1, uvs[row + 5] - uvs[row + 4]);
                var dw = Math.max(1, vertices[ind + 10] - vertices[ind]);
                var dh = Math.max(1, vertices[ind + 11] - vertices[ind + 1]);

                context.drawImage(textureSource, uvs[col], uvs[row + 4], sw, sh, vertices[ind], vertices[ind + 1], dw, dh);
            }
        }
    };

    /**
     * The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane
     *
     * @member {number}
     */


    /**
     * Refreshes NineSlicePlane coords. All of them.
     */
    NineSlicePlane.prototype._refresh = function _refresh() {
        _Plane.prototype._refresh.call(this);

        var uvs = this.uvs;
        var texture = this._texture;

        this._origWidth = texture.orig.width;
        this._origHeight = texture.orig.height;

        var _uvw = 1.0 / this._origWidth;
        var _uvh = 1.0 / this._origHeight;

        uvs[0] = uvs[8] = uvs[16] = uvs[24] = 0;
        uvs[1] = uvs[3] = uvs[5] = uvs[7] = 0;
        uvs[6] = uvs[14] = uvs[22] = uvs[30] = 1;
        uvs[25] = uvs[27] = uvs[29] = uvs[31] = 1;

        uvs[2] = uvs[10] = uvs[18] = uvs[26] = _uvw * this._leftWidth;
        uvs[4] = uvs[12] = uvs[20] = uvs[28] = 1 - _uvw * this._rightWidth;
        uvs[9] = uvs[11] = uvs[13] = uvs[15] = _uvh * this._topHeight;
        uvs[17] = uvs[19] = uvs[21] = uvs[23] = 1 - _uvh * this._bottomHeight;

        this.updateHorizontalVertices();
        this.updateVerticalVertices();

        this.dirty++;

        this.multiplyUvs();
    };

    _createClass(NineSlicePlane, [{
        key: 'width',
        get: function get() {
            return this._width;
        },
        set: function set(value) // eslint-disable-line require-jsdoc
        {
            this._width = value;
            this._refresh();
        }

        /**
         * The height of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane
         *
         * @member {number}
         */

    }, {
        key: 'height',
        get: function get() {
            return this._height;
        },
        set: function set(value) // eslint-disable-line require-jsdoc
        {
            this._height = value;
            this._refresh();
        }

        /**
         * The width of the left column
         *
         * @member {number}
         */

    }, {
        key: 'leftWidth',
        get: function get() {
            return this._leftWidth;
        },
        set: function set(value) // eslint-disable-line require-jsdoc
        {
            this._leftWidth = value;
            this._refresh();
        }

        /**
         * The width of the right column
         *
         * @member {number}
         */

    }, {
        key: 'rightWidth',
        get: function get() {
            return this._rightWidth;
        },
        set: function set(value) // eslint-disable-line require-jsdoc
        {
            this._rightWidth = value;
            this._refresh();
        }

        /**
         * The height of the top row
         *
         * @member {number}
         */

    }, {
        key: 'topHeight',
        get: function get() {
            return this._topHeight;
        },
        set: function set(value) // eslint-disable-line require-jsdoc
        {
            this._topHeight = value;
            this._refresh();
        }

        /**
         * The height of the bottom row
         *
         * @member {number}
         */

    }, {
        key: 'bottomHeight',
        get: function get() {
            return this._bottomHeight;
        },
        set: function set(value) // eslint-disable-line require-jsdoc
        {
            this._bottomHeight = value;
            this._refresh();
        }
    }]);

    return NineSlicePlane;
}(_Plane3.default);

exports.default = NineSlicePlane;

},{"../core/sprites/canvas/CanvasTinter":111,"./Plane":176}],176:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _Mesh2 = require('./Mesh');

var _Mesh3 = _interopRequireDefault(_Mesh2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The Plane allows you to draw a texture across several points and them manipulate these points
 *
 *```js
 * for (let i = 0; i < 20; i++) {
 *     points.push(new PIXI.Point(i * 50, 0));
 * };
 * let Plane = new PIXI.Plane(PIXI.Texture.fromImage("snake.png"), points);
 *  ```
 *
 * @class
 * @extends PIXI.mesh.Mesh
 * @memberof PIXI.mesh
 *
 */
var Plane = function (_Mesh) {
    _inherits(Plane, _Mesh);

    /**
     * @param {PIXI.Texture} texture - The texture to use on the Plane.
     * @param {number} [verticesX=10] - The number of vertices in the x-axis
     * @param {number} [verticesY=10] - The number of vertices in the y-axis
     */
    function Plane(texture, verticesX, verticesY) {
        _classCallCheck(this, Plane);

        /**
         * Tracker for if the Plane is ready to be drawn. Needed because Mesh ctor can
         * call _onTextureUpdated which could call refresh too early.
         *
         * @member {boolean}
         * @private
         */
        var _this = _possibleConstructorReturn(this, _Mesh.call(this, texture));

        _this._ready = true;

        _this.verticesX = verticesX || 10;
        _this.verticesY = verticesY || 10;

        _this.drawMode = _Mesh3.default.DRAW_MODES.TRIANGLES;
        _this.refresh();
        return _this;
    }

    /**
     * Refreshes plane coordinates
     *
     */


    Plane.prototype._refresh = function _refresh() {
        var texture = this._texture;
        var total = this.verticesX * this.verticesY;
        var verts = [];
        var colors = [];
        var uvs = [];
        var indices = [];

        var segmentsX = this.verticesX - 1;
        var segmentsY = this.verticesY - 1;

        var sizeX = texture.width / segmentsX;
        var sizeY = texture.height / segmentsY;

        for (var i = 0; i < total; i++) {
            var x = i % this.verticesX;
            var y = i / this.verticesX | 0;

            verts.push(x * sizeX, y * sizeY);

            uvs.push(x / segmentsX, y / segmentsY);
        }

        //  cons

        var totalSub = segmentsX * segmentsY;

        for (var _i = 0; _i < totalSub; _i++) {
            var xpos = _i % segmentsX;
            var ypos = _i / segmentsX | 0;

            var value = ypos * this.verticesX + xpos;
            var value2 = ypos * this.verticesX + xpos + 1;
            var value3 = (ypos + 1) * this.verticesX + xpos;
            var value4 = (ypos + 1) * this.verticesX + xpos + 1;

            indices.push(value, value2, value3);
            indices.push(value2, value4, value3);
        }

        // console.log(indices)
        this.vertices = new Float32Array(verts);
        this.uvs = new Float32Array(uvs);
        this.colors = new Float32Array(colors);
        this.indices = new Uint16Array(indices);

        this.dirty++;
        this.indexDirty++;

        this.multiplyUvs();
    };

    /**
     * Clear texture UVs when new texture is set
     *
     * @private
     */


    Plane.prototype._onTextureUpdate = function _onTextureUpdate() {
        _Mesh3.default.prototype._onTextureUpdate.call(this);

        // wait for the Plane ctor to finish before calling refresh
        if (this._ready) {
            this.refresh();
        }
    };

    return Plane;
}(_Mesh3.default);

exports.default = Plane;

},{"./Mesh":174}],177:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _Mesh2 = require('./Mesh');

var _Mesh3 = _interopRequireDefault(_Mesh2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The rope allows you to draw a texture across several points and them manipulate these points
 *
 *```js
 * for (let i = 0; i < 20; i++) {
 *     points.push(new PIXI.Point(i * 50, 0));
 * };
 * let rope = new PIXI.Rope(PIXI.Texture.fromImage("snake.png"), points);
 *  ```
 *
 * @class
 * @extends PIXI.mesh.Mesh
 * @memberof PIXI.mesh
 *
 */
var Rope = function (_Mesh) {
    _inherits(Rope, _Mesh);

    /**
     * @param {PIXI.Texture} texture - The texture to use on the rope.
     * @param {PIXI.Point[]} points - An array of {@link PIXI.Point} objects to construct this rope.
     */
    function Rope(texture, points) {
        _classCallCheck(this, Rope);

        /**
         * An array of points that determine the rope
         *
         * @member {PIXI.Point[]}
         */
        var _this = _possibleConstructorReturn(this, _Mesh.call(this, texture));

        _this.points = points;

        /**
         * An array of vertices used to construct this rope.
         *
         * @member {Float32Array}
         */
        _this.vertices = new Float32Array(points.length * 4);

        /**
         * The WebGL Uvs of the rope.
         *
         * @member {Float32Array}
         */
        _this.uvs = new Float32Array(points.length * 4);

        /**
         * An array containing the color components
         *
         * @member {Float32Array}
         */
        _this.colors = new Float32Array(points.length * 2);

        /**
         * An array containing the indices of the vertices
         *
         * @member {Uint16Array}
         */
        _this.indices = new Uint16Array(points.length * 2);

        /**
         * refreshes vertices on every updateTransform
         * @member {boolean}
         * @default true
         */
        _this.autoUpdate = true;

        _this.refresh();
        return _this;
    }

    /**
     * Refreshes
     *
     */


    Rope.prototype._refresh = function _refresh() {
        var points = this.points;

        // if too little points, or texture hasn't got UVs set yet just move on.
        if (points.length < 1 || !this._texture._uvs) {
            return;
        }

        // if the number of points has changed we will need to recreate the arraybuffers
        if (this.vertices.length / 4 !== points.length) {
            this.vertices = new Float32Array(points.length * 4);
            this.uvs = new Float32Array(points.length * 4);
            this.colors = new Float32Array(points.length * 2);
            this.indices = new Uint16Array(points.length * 2);
        }

        var uvs = this.uvs;

        var indices = this.indices;
        var colors = this.colors;

        uvs[0] = 0;
        uvs[1] = 0;
        uvs[2] = 0;
        uvs[3] = 1;

        colors[0] = 1;
        colors[1] = 1;

        indices[0] = 0;
        indices[1] = 1;

        var total = points.length;

        for (var i = 1; i < total; i++) {
            // time to do some smart drawing!
            var index = i * 4;
            var amount = i / (total - 1);

            uvs[index] = amount;
            uvs[index + 1] = 0;

            uvs[index + 2] = amount;
            uvs[index + 3] = 1;

            index = i * 2;
            colors[index] = 1;
            colors[index + 1] = 1;

            index = i * 2;
            indices[index] = index;
            indices[index + 1] = index + 1;
        }

        // ensure that the changes are uploaded
        this.dirty++;
        this.indexDirty++;

        this.multiplyUvs();
        this.refreshVertices();
    };

    /**
     * refreshes vertices of Rope mesh
     */


    Rope.prototype.refreshVertices = function refreshVertices() {
        var points = this.points;

        if (points.length < 1) {
            return;
        }

        var lastPoint = points[0];
        var nextPoint = void 0;
        var perpX = 0;
        var perpY = 0;

        // this.count -= 0.2;

        var vertices = this.vertices;
        var total = points.length;

        for (var i = 0; i < total; i++) {
            var point = points[i];
            var index = i * 4;

            if (i < points.length - 1) {
                nextPoint = points[i + 1];
            } else {
                nextPoint = point;
            }

            perpY = -(nextPoint.x - lastPoint.x);
            perpX = nextPoint.y - lastPoint.y;

            var ratio = (1 - i / (total - 1)) * 10;

            if (ratio > 1) {
                ratio = 1;
            }

            var perpLength = Math.sqrt(perpX * perpX + perpY * perpY);
            var num = this._texture.height / 2; // (20 + Math.abs(Math.sin((i + this.count) * 0.3) * 50) )* ratio;

            perpX /= perpLength;
            perpY /= perpLength;

            perpX *= num;
            perpY *= num;

            vertices[index] = point.x + perpX;
            vertices[index + 1] = point.y + perpY;
            vertices[index + 2] = point.x - perpX;
            vertices[index + 3] = point.y - perpY;

            lastPoint = point;
        }
    };

    /**
     * Updates the object transform for rendering
     *
     * @private
     */


    Rope.prototype.updateTransform = function updateTransform() {
        if (this.autoUpdate) {
            this.refreshVertices();
        }
        this.containerUpdateTransform();
    };

    return Rope;
}(_Mesh3.default);

exports.default = Rope;

},{"./Mesh":174}],178:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _core = require('../../core');

var core = _interopRequireWildcard(_core);

var _Mesh = require('../Mesh');

var _Mesh2 = _interopRequireDefault(_Mesh);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Renderer dedicated to meshes.
 *
 * @class
 * @private
 * @memberof PIXI
 */
var MeshSpriteRenderer = function () {
    /**
     * @param {PIXI.CanvasRenderer} renderer - The renderer this downport works for
     */
    function MeshSpriteRenderer(renderer) {
        _classCallCheck(this, MeshSpriteRenderer);

        this.renderer = renderer;
    }

    /**
     * Renders the Mesh
     *
     * @param {PIXI.mesh.Mesh} mesh - the Mesh to render
     */


    MeshSpriteRenderer.prototype.render = function render(mesh) {
        var renderer = this.renderer;
        var context = renderer.context;

        var transform = mesh.worldTransform;
        var res = renderer.resolution;

        if (renderer.roundPixels) {
            context.setTransform(transform.a * res, transform.b * res, transform.c * res, transform.d * res, transform.tx * res | 0, transform.ty * res | 0);
        } else {
            context.setTransform(transform.a * res, transform.b * res, transform.c * res, transform.d * res, transform.tx * res, transform.ty * res);
        }

        renderer.context.globalAlpha = mesh.worldAlpha;
        renderer.setBlendMode(mesh.blendMode);

        if (mesh.drawMode === _Mesh2.default.DRAW_MODES.TRIANGLE_MESH) {
            this._renderTriangleMesh(mesh);
        } else {
            this._renderTriangles(mesh);
        }
    };

    /**
     * Draws the object in Triangle Mesh mode
     *
     * @private
     * @param {PIXI.mesh.Mesh} mesh - the Mesh to render
     */


    MeshSpriteRenderer.prototype._renderTriangleMesh = function _renderTriangleMesh(mesh) {
        // draw triangles!!
        var length = mesh.vertices.length / 2;

        for (var i = 0; i < length - 2; i++) {
            // draw some triangles!
            var index = i * 2;

            this._renderDrawTriangle(mesh, index, index + 2, index + 4);
        }
    };

    /**
     * Draws the object in triangle mode using canvas
     *
     * @private
     * @param {PIXI.mesh.Mesh} mesh - the current mesh
     */


    MeshSpriteRenderer.prototype._renderTriangles = function _renderTriangles(mesh) {
        // draw triangles!!
        var indices = mesh.indices;
        var length = indices.length;

        for (var i = 0; i < length; i += 3) {
            // draw some triangles!
            var index0 = indices[i] * 2;
            var index1 = indices[i + 1] * 2;
            var index2 = indices[i + 2] * 2;

            this._renderDrawTriangle(mesh, index0, index1, index2);
        }
    };

    /**
     * Draws one of the triangles that from the Mesh
     *
     * @private
     * @param {PIXI.mesh.Mesh} mesh - the current mesh
     * @param {number} index0 - the index of the first vertex
     * @param {number} index1 - the index of the second vertex
     * @param {number} index2 - the index of the third vertex
     */


    MeshSpriteRenderer.prototype._renderDrawTriangle = function _renderDrawTriangle(mesh, index0, index1, index2) {
        var context = this.renderer.context;
        var uvs = mesh.uvs;
        var vertices = mesh.vertices;
        var texture = mesh._texture;

        if (!texture.valid) {
            return;
        }

        var base = texture.baseTexture;
        var textureSource = base.source;
        var textureWidth = base.width;
        var textureHeight = base.height;

        var u0 = void 0;
        var u1 = void 0;
        var u2 = void 0;
        var v0 = void 0;
        var v1 = void 0;
        var v2 = void 0;

        if (mesh.uploadUvTransform) {
            var ut = mesh._uvTransform.mapCoord;

            u0 = (uvs[index0] * ut.a + uvs[index0 + 1] * ut.c + ut.tx) * base.width;
            u1 = (uvs[index1] * ut.a + uvs[index1 + 1] * ut.c + ut.tx) * base.width;
            u2 = (uvs[index2] * ut.a + uvs[index2 + 1] * ut.c + ut.tx) * base.width;
            v0 = (uvs[index0] * ut.b + uvs[index0 + 1] * ut.d + ut.ty) * base.height;
            v1 = (uvs[index1] * ut.b + uvs[index1 + 1] * ut.d + ut.ty) * base.height;
            v2 = (uvs[index2] * ut.b + uvs[index2 + 1] * ut.d + ut.ty) * base.height;
        } else {
            u0 = uvs[index0] * base.width;
            u1 = uvs[index1] * base.width;
            u2 = uvs[index2] * base.width;
            v0 = uvs[index0 + 1] * base.height;
            v1 = uvs[index1 + 1] * base.height;
            v2 = uvs[index2 + 1] * base.height;
        }

        var x0 = vertices[index0];
        var x1 = vertices[index1];
        var x2 = vertices[index2];
        var y0 = vertices[index0 + 1];
        var y1 = vertices[index1 + 1];
        var y2 = vertices[index2 + 1];

        var canvasPadding = mesh.canvasPadding / this.renderer.resolution;

        if (canvasPadding > 0) {
            var paddingX = canvasPadding / Math.abs(mesh.worldTransform.a);
            var paddingY = canvasPadding / Math.abs(mesh.worldTransform.d);
            var centerX = (x0 + x1 + x2) / 3;
            var centerY = (y0 + y1 + y2) / 3;

            var normX = x0 - centerX;
            var normY = y0 - centerY;

            var dist = Math.sqrt(normX * normX + normY * normY);

            x0 = centerX + normX / dist * (dist + paddingX);
            y0 = centerY + normY / dist * (dist + paddingY);

            //

            normX = x1 - centerX;
            normY = y1 - centerY;

            dist = Math.sqrt(normX * normX + normY * normY);
            x1 = centerX + normX / dist * (dist + paddingX);
            y1 = centerY + normY / dist * (dist + paddingY);

            normX = x2 - centerX;
            normY = y2 - centerY;

            dist = Math.sqrt(normX * normX + normY * normY);
            x2 = centerX + normX / dist * (dist + paddingX);
            y2 = centerY + normY / dist * (dist + paddingY);
        }

        context.save();
        context.beginPath();

        context.moveTo(x0, y0);
        context.lineTo(x1, y1);
        context.lineTo(x2, y2);

        context.closePath();

        context.clip();

        // Compute matrix transform
        var delta = u0 * v1 + v0 * u2 + u1 * v2 - v1 * u2 - v0 * u1 - u0 * v2;
        var deltaA = x0 * v1 + v0 * x2 + x1 * v2 - v1 * x2 - v0 * x1 - x0 * v2;
        var deltaB = u0 * x1 + x0 * u2 + u1 * x2 - x1 * u2 - x0 * u1 - u0 * x2;
        var deltaC = u0 * v1 * x2 + v0 * x1 * u2 + x0 * u1 * v2 - x0 * v1 * u2 - v0 * u1 * x2 - u0 * x1 * v2;
        var deltaD = y0 * v1 + v0 * y2 + y1 * v2 - v1 * y2 - v0 * y1 - y0 * v2;
        var deltaE = u0 * y1 + y0 * u2 + u1 * y2 - y1 * u2 - y0 * u1 - u0 * y2;
        var deltaF = u0 * v1 * y2 + v0 * y1 * u2 + y0 * u1 * v2 - y0 * v1 * u2 - v0 * u1 * y2 - u0 * y1 * v2;

        context.transform(deltaA / delta, deltaD / delta, deltaB / delta, deltaE / delta, deltaC / delta, deltaF / delta);

        context.drawImage(textureSource, 0, 0, textureWidth * base.resolution, textureHeight * base.resolution, 0, 0, textureWidth, textureHeight);

        context.restore();
        this.renderer.invalidateBlendMode();
    };

    /**
     * Renders a flat Mesh
     *
     * @private
     * @param {PIXI.mesh.Mesh} mesh - The Mesh to render
     */


    MeshSpriteRenderer.prototype.renderMeshFlat = function renderMeshFlat(mesh) {
        var context = this.renderer.context;
        var vertices = mesh.vertices;
        var length = vertices.length / 2;

        // this.count++;

        context.beginPath();

        for (var i = 1; i < length - 2; ++i) {
            // draw some triangles!
            var index = i * 2;

            var x0 = vertices[index];
            var y0 = vertices[index + 1];

            var x1 = vertices[index + 2];
            var y1 = vertices[index + 3];

            var x2 = vertices[index + 4];
            var y2 = vertices[index + 5];

            context.moveTo(x0, y0);
            context.lineTo(x1, y1);
            context.lineTo(x2, y2);
        }

        context.fillStyle = '#FF0000';
        context.fill();
        context.closePath();
    };

    /**
     * destroy the the renderer.
     *
     */


    MeshSpriteRenderer.prototype.destroy = function destroy() {
        this.renderer = null;
    };

    return MeshSpriteRenderer;
}();

exports.default = MeshSpriteRenderer;


core.CanvasRenderer.registerPlugin('mesh', MeshSpriteRenderer);

},{"../../core":72,"../Mesh":174}],179:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _Mesh = require('./Mesh');

Object.defineProperty(exports, 'Mesh', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Mesh).default;
  }
});

var _MeshRenderer = require('./webgl/MeshRenderer');

Object.defineProperty(exports, 'MeshRenderer', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_MeshRenderer).default;
  }
});

var _CanvasMeshRenderer = require('./canvas/CanvasMeshRenderer');

Object.defineProperty(exports, 'CanvasMeshRenderer', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_CanvasMeshRenderer).default;
  }
});

var _Plane = require('./Plane');

Object.defineProperty(exports, 'Plane', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Plane).default;
  }
});

var _NineSlicePlane = require('./NineSlicePlane');

Object.defineProperty(exports, 'NineSlicePlane', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_NineSlicePlane).default;
  }
});

var _Rope = require('./Rope');

Object.defineProperty(exports, 'Rope', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Rope).default;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

},{"./Mesh":174,"./NineSlicePlane":175,"./Plane":176,"./Rope":177,"./canvas/CanvasMeshRenderer":178,"./webgl/MeshRenderer":180}],180:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _core = require('../../core');

var core = _interopRequireWildcard(_core);

var _pixiGlCore = require('pixi-gl-core');

var _pixiGlCore2 = _interopRequireDefault(_pixiGlCore);

var _Mesh = require('../Mesh');

var _Mesh2 = _interopRequireDefault(_Mesh);

var _path = require('path');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var matrixIdentity = core.Matrix.IDENTITY;

/**
 * WebGL renderer plugin for tiling sprites
 *
 * @class
 * @memberof PIXI
 * @extends PIXI.ObjectRenderer
 */

var MeshRenderer = function (_core$ObjectRenderer) {
    _inherits(MeshRenderer, _core$ObjectRenderer);

    /**
     * constructor for renderer
     *
     * @param {WebGLRenderer} renderer The renderer this tiling awesomeness works for.
     */
    function MeshRenderer(renderer) {
        _classCallCheck(this, MeshRenderer);

        var _this = _possibleConstructorReturn(this, _core$ObjectRenderer.call(this, renderer));

        _this.shader = null;
        return _this;
    }

    /**
     * Sets up the renderer context and necessary buffers.
     *
     * @private
     */


    MeshRenderer.prototype.onContextChange = function onContextChange() {
        var gl = this.renderer.gl;

        this.shader = new core.Shader(gl, 'attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n', 'varying vec2 vTextureCoord;\nuniform vec4 uColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n    gl_FragColor = texture2D(uSampler, vTextureCoord) * uColor;\n}\n');
    };

    /**
     * renders mesh
     *
     * @param {PIXI.mesh.Mesh} mesh mesh instance
     */


    MeshRenderer.prototype.render = function render(mesh) {
        var renderer = this.renderer;
        var gl = renderer.gl;
        var texture = mesh._texture;

        if (!texture.valid) {
            return;
        }

        var glData = mesh._glDatas[renderer.CONTEXT_UID];

        if (!glData) {
            renderer.bindVao(null);

            glData = {
                shader: this.shader,
                vertexBuffer: _pixiGlCore2.default.GLBuffer.createVertexBuffer(gl, mesh.vertices, gl.STREAM_DRAW),
                uvBuffer: _pixiGlCore2.default.GLBuffer.createVertexBuffer(gl, mesh.uvs, gl.STREAM_DRAW),
                indexBuffer: _pixiGlCore2.default.GLBuffer.createIndexBuffer(gl, mesh.indices, gl.STATIC_DRAW),
                // build the vao object that will render..
                vao: null,
                dirty: mesh.dirty,
                indexDirty: mesh.indexDirty,
                vertexDirty: mesh.vertexDirty
            };

            // build the vao object that will render..
            glData.vao = new _pixiGlCore2.default.VertexArrayObject(gl).addIndex(glData.indexBuffer).addAttribute(glData.vertexBuffer, glData.shader.attributes.aVertexPosition, gl.FLOAT, false, 2 * 4, 0).addAttribute(glData.uvBuffer, glData.shader.attributes.aTextureCoord, gl.FLOAT, false, 2 * 4, 0);

            mesh._glDatas[renderer.CONTEXT_UID] = glData;
        }

        renderer.bindVao(glData.vao);

        if (mesh.dirty !== glData.dirty) {
            glData.dirty = mesh.dirty;
            glData.uvBuffer.upload(mesh.uvs);
        }

        if (mesh.indexDirty !== glData.indexDirty) {
            glData.indexDirty = mesh.indexDirty;
            glData.indexBuffer.upload(mesh.indices);
        }

        if (mesh.vertexDirty !== glData.vertexDirty) {
            glData.vertexDirty = mesh.vertexDirty;
            glData.vertexBuffer.upload(mesh.vertices);
        }

        renderer.bindShader(glData.shader);

        glData.shader.uniforms.uSampler = renderer.bindTexture(texture);

        renderer.state.setBlendMode(core.utils.correctBlendMode(mesh.blendMode, texture.baseTexture.premultipliedAlpha));

        if (glData.shader.uniforms.uTransform) {
            if (mesh.uploadUvTransform) {
                glData.shader.uniforms.uTransform = mesh._uvTransform.mapCoord.toArray(true);
            } else {
                glData.shader.uniforms.uTransform = matrixIdentity.toArray(true);
            }
        }
        glData.shader.uniforms.translationMatrix = mesh.worldTransform.toArray(true);

        glData.shader.uniforms.uColor = core.utils.premultiplyRgba(mesh.tintRgb, mesh.worldAlpha, glData.shader.uniforms.uColor, texture.baseTexture.premultipliedAlpha);

        var drawMode = mesh.drawMode === _Mesh2.default.DRAW_MODES.TRIANGLE_MESH ? gl.TRIANGLE_STRIP : gl.TRIANGLES;

        glData.vao.draw(drawMode, mesh.indices.length, 0);
    };

    return MeshRenderer;
}(core.ObjectRenderer);

exports.default = MeshRenderer;


core.WebGLRenderer.registerPlugin('mesh', MeshRenderer);

},{"../../core":72,"../Mesh":174,"path":1,"pixi-gl-core":36}],181:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _core = require('../core');

var core = _interopRequireWildcard(_core);

var _utils = require('../core/utils');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ParticleContainer class is a really fast version of the Container built solely for speed,
 * so use when you need a lot of sprites or particles. The tradeoff of the ParticleContainer is that most advanced
 * functionality will not work. ParticleContainer implements the basic object transform (position, scale, rotation)
 * and some advanced functionality like tint (as of v4.5.6).
 * Other more advanced functionality like masking, children, filters, etc will not work on sprites in this batch.
 *
 * It's extremely easy to use :
 *
 * ```js
 * let container = new ParticleContainer();
 *
 * for (let i = 0; i < 100; ++i)
 * {
 *     let sprite = new PIXI.Sprite.fromImage("myImage.png");
 *     container.addChild(sprite);
 * }
 * ```
 *
 * And here you have a hundred sprites that will be rendered at the speed of light.
 *
 * @class
 * @extends PIXI.Container
 * @memberof PIXI.particles
 */
var ParticleContainer = function (_core$Container) {
    _inherits(ParticleContainer, _core$Container);

    /**
     * @param {number} [maxSize=1500] - The maximum number of particles that can be rendered by the container.
     *  Affects size of allocated buffers.
     * @param {object} [properties] - The properties of children that should be uploaded to the gpu and applied.
     * @param {boolean} [properties.vertices=false] - When true, vertices be uploaded and applied.
     *                  if sprite's ` scale/anchor/trim/frame/orig` is dynamic, please set `true`.
     * @param {boolean} [properties.position=true] - When true, position be uploaded and applied.
     * @param {boolean} [properties.rotation=false] - When true, rotation be uploaded and applied.
     * @param {boolean} [properties.uvs=false] - When true, uvs be uploaded and applied.
     * @param {boolean} [properties.tint=false] - When true, alpha and tint be uploaded and applied.
     * @param {number} [batchSize=16384] - Number of particles per batch. If less than maxSize, it uses maxSize instead.
     * @param {boolean} [autoResize=false] If true, container allocates more batches in case
     *  there are more than `maxSize` particles.
     */
    function ParticleContainer() {
        var maxSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1500;
        var properties = arguments[1];
        var batchSize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 16384;
        var autoResize = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

        _classCallCheck(this, ParticleContainer);

        // Making sure the batch size is valid
        // 65535 is max vertex index in the index buffer (see ParticleRenderer)
        // so max number of particles is 65536 / 4 = 16384
        var _this = _possibleConstructorReturn(this, _core$Container.call(this));

        var maxBatchSize = 16384;

        if (batchSize > maxBatchSize) {
            batchSize = maxBatchSize;
        }

        if (batchSize > maxSize) {
            batchSize = maxSize;
        }

        /**
         * Set properties to be dynamic (true) / static (false)
         *
         * @member {boolean[]}
         * @private
         */
        _this._properties = [false, true, false, false, false];

        /**
         * @member {number}
         * @private
         */
        _this._maxSize = maxSize;

        /**
         * @member {number}
         * @private
         */
        _this._batchSize = batchSize;

        /**
         * @member {object<number, WebGLBuffer>}
         * @private
         */
        _this._glBuffers = {};

        /**
         * for every batch stores _updateID corresponding to the last change in that batch
         * @member {number[]}
         * @private
         */
        _this._bufferUpdateIDs = [];

        /**
         * when child inserted, removed or changes position this number goes up
         * @member {number[]}
         * @private
         */
        _this._updateID = 0;

        /**
         * @member {boolean}
         *
         */
        _this.interactiveChildren = false;

        /**
         * The blend mode to be applied to the sprite. Apply a value of `PIXI.BLEND_MODES.NORMAL`
         * to reset the blend mode.
         *
         * @member {number}
         * @default PIXI.BLEND_MODES.NORMAL
         * @see PIXI.BLEND_MODES
         */
        _this.blendMode = core.BLEND_MODES.NORMAL;

        /**
         * If true, container allocates more batches in case there are more than `maxSize` particles.
         * @member {boolean}
         * @default false
         */
        _this.autoResize = autoResize;

        /**
         * Used for canvas renderering. If true then the elements will be positioned at the
         * nearest pixel. This provides a nice speed boost.
         *
         * @member {boolean}
         * @default true;
         */
        _this.roundPixels = true;

        /**
         * The texture used to render the children.
         *
         * @readonly
         * @member {BaseTexture}
         */
        _this.baseTexture = null;

        _this.setProperties(properties);

        /**
         * The tint applied to the container.
         * This is a hex value. A value of 0xFFFFFF will remove any tint effect.
         *
         * @private
         * @member {number}
         * @default 0xFFFFFF
         */
        _this._tint = 0;
        _this.tintRgb = new Float32Array(4);
        _this.tint = 0xFFFFFF;
        return _this;
    }

    /**
     * Sets the private properties array to dynamic / static based on the passed properties object
     *
     * @param {object} properties - The properties to be uploaded
     */


    ParticleContainer.prototype.setProperties = function setProperties(properties) {
        if (properties) {
            this._properties[0] = 'vertices' in properties || 'scale' in properties ? !!properties.vertices || !!properties.scale : this._properties[0];
            this._properties[1] = 'position' in properties ? !!properties.position : this._properties[1];
            this._properties[2] = 'rotation' in properties ? !!properties.rotation : this._properties[2];
            this._properties[3] = 'uvs' in properties ? !!properties.uvs : this._properties[3];
            this._properties[4] = 'tint' in properties || 'alpha' in properties ? !!properties.tint || !!properties.alpha : this._properties[4];
        }
    };

    /**
     * Updates the object transform for rendering
     *
     * @private
     */


    ParticleContainer.prototype.updateTransform = function updateTransform() {
        // TODO don't need to!
        this.displayObjectUpdateTransform();
        //  PIXI.Container.prototype.updateTransform.call( this );
    };

    /**
     * The tint applied to the container. This is a hex value.
     * A value of 0xFFFFFF will remove any tint effect.
     ** IMPORTANT: This is a webGL only feature and will be ignored by the canvas renderer.
     * @member {number}
     * @default 0xFFFFFF
     */


    /**
     * Renders the container using the WebGL renderer
     *
     * @private
     * @param {PIXI.WebGLRenderer} renderer - The webgl renderer
     */
    ParticleContainer.prototype.renderWebGL = function renderWebGL(renderer) {
        var _this2 = this;

        if (!this.visible || this.worldAlpha <= 0 || !this.children.length || !this.renderable) {
            return;
        }

        if (!this.baseTexture) {
            this.baseTexture = this.children[0]._texture.baseTexture;
            if (!this.baseTexture.hasLoaded) {
                this.baseTexture.once('update', function () {
                    return _this2.onChildrenChange(0);
                });
            }
        }

        renderer.setObjectRenderer(renderer.plugins.particle);
        renderer.plugins.particle.render(this);
    };

    /**
     * Set the flag that static data should be updated to true
     *
     * @private
     * @param {number} smallestChildIndex - The smallest child index
     */


    ParticleContainer.prototype.onChildrenChange = function onChildrenChange(smallestChildIndex) {
        var bufferIndex = Math.floor(smallestChildIndex / this._batchSize);

        while (this._bufferUpdateIDs.length < bufferIndex) {
            this._bufferUpdateIDs.push(0);
        }
        this._bufferUpdateIDs[bufferIndex] = ++this._updateID;
    };

    /**
     * Renders the object using the Canvas renderer
     *
     * @private
     * @param {PIXI.CanvasRenderer} renderer - The canvas renderer
     */


    ParticleContainer.prototype.renderCanvas = function renderCanvas(renderer) {
        if (!this.visible || this.worldAlpha <= 0 || !this.children.length || !this.renderable) {
            return;
        }

        var context = renderer.context;
        var transform = this.worldTransform;
        var isRotated = true;

        var positionX = 0;
        var positionY = 0;

        var finalWidth = 0;
        var finalHeight = 0;

        renderer.setBlendMode(this.blendMode);

        context.globalAlpha = this.worldAlpha;

        this.displayObjectUpdateTransform();

        for (var i = 0; i < this.children.length; ++i) {
            var child = this.children[i];

            if (!child.visible) {
                continue;
            }

            var frame = child._texture.frame;

            context.globalAlpha = this.worldAlpha * child.alpha;

            if (child.rotation % (Math.PI * 2) === 0) {
                // this is the fastest  way to optimise! - if rotation is 0 then we can avoid any kind of setTransform call
                if (isRotated) {
                    context.setTransform(transform.a, transform.b, transform.c, transform.d, transform.tx * renderer.resolution, transform.ty * renderer.resolution);

                    isRotated = false;
                }

                positionX = child.anchor.x * (-frame.width * child.scale.x) + child.position.x + 0.5;
                positionY = child.anchor.y * (-frame.height * child.scale.y) + child.position.y + 0.5;

                finalWidth = frame.width * child.scale.x;
                finalHeight = frame.height * child.scale.y;
            } else {
                if (!isRotated) {
                    isRotated = true;
                }

                child.displayObjectUpdateTransform();

                var childTransform = child.worldTransform;

                if (renderer.roundPixels) {
                    context.setTransform(childTransform.a, childTransform.b, childTransform.c, childTransform.d, childTransform.tx * renderer.resolution | 0, childTransform.ty * renderer.resolution | 0);
                } else {
                    context.setTransform(childTransform.a, childTransform.b, childTransform.c, childTransform.d, childTransform.tx * renderer.resolution, childTransform.ty * renderer.resolution);
                }

                positionX = child.anchor.x * -frame.width + 0.5;
                positionY = child.anchor.y * -frame.height + 0.5;

                finalWidth = frame.width;
                finalHeight = frame.height;
            }

            var resolution = child._texture.baseTexture.resolution;

            context.drawImage(child._texture.baseTexture.source, frame.x * resolution, frame.y * resolution, frame.width * resolution, frame.height * resolution, positionX * renderer.resolution, positionY * renderer.resolution, finalWidth * renderer.resolution, finalHeight * renderer.resolution);
        }
    };

    /**
     * Destroys the container
     *
     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options
     *  have been set to that value
     * @param {boolean} [options.children=false] - if set to true, all the children will have their
     *  destroy method called as well. 'options' will be passed on to those calls.
     * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true
     *  Should it destroy the texture of the child sprite
     * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true
     *  Should it destroy the base texture of the child sprite
     */


    ParticleContainer.prototype.destroy = function destroy(options) {
        _core$Container.prototype.destroy.call(this, options);

        if (this._buffers) {
            for (var i = 0; i < this._buffers.length; ++i) {
                this._buffers[i].destroy();
            }
        }

        this._properties = null;
        this._buffers = null;
        this._bufferUpdateIDs = null;
    };

    _createClass(ParticleContainer, [{
        key: 'tint',
        get: function get() {
            return this._tint;
        },
        set: function set(value) // eslint-disable-line require-jsdoc
        {
            this._tint = value;
            (0, _utils.hex2rgb)(value, this.tintRgb);
        }
    }]);

    return ParticleContainer;
}(core.Container);

exports.default = ParticleContainer;

},{"../core":72,"../core/utils":132}],182:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _ParticleContainer = require('./ParticleContainer');

Object.defineProperty(exports, 'ParticleContainer', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_ParticleContainer).default;
  }
});

var _ParticleRenderer = require('./webgl/ParticleRenderer');

Object.defineProperty(exports, 'ParticleRenderer', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_ParticleRenderer).default;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

},{"./ParticleContainer":181,"./webgl/ParticleRenderer":184}],183:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _pixiGlCore = require('pixi-gl-core');

var _pixiGlCore2 = _interopRequireDefault(_pixiGlCore);

var _createIndicesForQuads = require('../../core/utils/createIndicesForQuads');

var _createIndicesForQuads2 = _interopRequireDefault(_createIndicesForQuads);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @author Mat Groves
 *
 * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/
 * for creating the original PixiJS version!
 * Also a thanks to https://github.com/bchevalier for tweaking the tint and alpha so that
 * they now share 4 bytes on the vertex buffer
 *
 * Heavily inspired by LibGDX's ParticleBuffer:
 * https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/ParticleBuffer.java
 */

/**
 * The particle buffer manages the static and dynamic buffers for a particle container.
 *
 * @class
 * @private
 * @memberof PIXI
 */
var ParticleBuffer = function () {
    /**
     * @param {WebGLRenderingContext} gl - The rendering context.
     * @param {object} properties - The properties to upload.
     * @param {boolean[]} dynamicPropertyFlags - Flags for which properties are dynamic.
     * @param {number} size - The size of the batch.
     */
    function ParticleBuffer(gl, properties, dynamicPropertyFlags, size) {
        _classCallCheck(this, ParticleBuffer);

        /**
         * The current WebGL drawing context.
         *
         * @member {WebGLRenderingContext}
         */
        this.gl = gl;

        /**
         * The number of particles the buffer can hold
         *
         * @member {number}
         */
        this.size = size;

        /**
         * A list of the properties that are dynamic.
         *
         * @member {object[]}
         */
        this.dynamicProperties = [];

        /**
         * A list of the properties that are static.
         *
         * @member {object[]}
         */
        this.staticProperties = [];

        for (var i = 0; i < properties.length; ++i) {
            var property = properties[i];

            // Make copy of properties object so that when we edit the offset it doesn't
            // change all other instances of the object literal
            property = {
                attribute: property.attribute,
                size: property.size,
                uploadFunction: property.uploadFunction,
                unsignedByte: property.unsignedByte,
                offset: property.offset
            };

            if (dynamicPropertyFlags[i]) {
                this.dynamicProperties.push(property);
            } else {
                this.staticProperties.push(property);
            }
        }

        this.staticStride = 0;
        this.staticBuffer = null;
        this.staticData = null;
        this.staticDataUint32 = null;

        this.dynamicStride = 0;
        this.dynamicBuffer = null;
        this.dynamicData = null;
        this.dynamicDataUint32 = null;

        this._updateID = 0;

        this.initBuffers();
    }

    /**
     * Sets up the renderer context and necessary buffers.
     *
     * @private
     */


    ParticleBuffer.prototype.initBuffers = function initBuffers() {
        var gl = this.gl;
        var dynamicOffset = 0;

        /**
         * Holds the indices of the geometry (quads) to draw
         *
         * @member {Uint16Array}
         */
        this.indices = (0, _createIndicesForQuads2.default)(this.size);
        this.indexBuffer = _pixiGlCore2.default.GLBuffer.createIndexBuffer(gl, this.indices, gl.STATIC_DRAW);

        this.dynamicStride = 0;

        for (var i = 0; i < this.dynamicProperties.length; ++i) {
            var property = this.dynamicProperties[i];

            property.offset = dynamicOffset;
            dynamicOffset += property.size;
            this.dynamicStride += property.size;
        }

        var dynBuffer = new ArrayBuffer(this.size * this.dynamicStride * 4 * 4);

        this.dynamicData = new Float32Array(dynBuffer);
        this.dynamicDataUint32 = new Uint32Array(dynBuffer);
        this.dynamicBuffer = _pixiGlCore2.default.GLBuffer.createVertexBuffer(gl, dynBuffer, gl.STREAM_DRAW);

        // static //
        var staticOffset = 0;

        this.staticStride = 0;

        for (var _i = 0; _i < this.staticProperties.length; ++_i) {
            var _property = this.staticProperties[_i];

            _property.offset = staticOffset;
            staticOffset += _property.size;
            this.staticStride += _property.size;
        }

        var statBuffer = new ArrayBuffer(this.size * this.staticStride * 4 * 4);

        this.staticData = new Float32Array(statBuffer);
        this.staticDataUint32 = new Uint32Array(statBuffer);
        this.staticBuffer = _pixiGlCore2.default.GLBuffer.createVertexBuffer(gl, statBuffer, gl.STATIC_DRAW);

        this.vao = new _pixiGlCore2.default.VertexArrayObject(gl).addIndex(this.indexBuffer);

        for (var _i2 = 0; _i2 < this.dynamicProperties.length; ++_i2) {
            var _property2 = this.dynamicProperties[_i2];

            if (_property2.unsignedByte) {
                this.vao.addAttribute(this.dynamicBuffer, _property2.attribute, gl.UNSIGNED_BYTE, true, this.dynamicStride * 4, _property2.offset * 4);
            } else {
                this.vao.addAttribute(this.dynamicBuffer, _property2.attribute, gl.FLOAT, false, this.dynamicStride * 4, _property2.offset * 4);
            }
        }

        for (var _i3 = 0; _i3 < this.staticProperties.length; ++_i3) {
            var _property3 = this.staticProperties[_i3];

            if (_property3.unsignedByte) {
                this.vao.addAttribute(this.staticBuffer, _property3.attribute, gl.UNSIGNED_BYTE, true, this.staticStride * 4, _property3.offset * 4);
            } else {
                this.vao.addAttribute(this.staticBuffer, _property3.attribute, gl.FLOAT, false, this.staticStride * 4, _property3.offset * 4);
            }
        }
    };

    /**
     * Uploads the dynamic properties.
     *
     * @param {PIXI.DisplayObject[]} children - The children to upload.
     * @param {number} startIndex - The index to start at.
     * @param {number} amount - The number to upload.
     */


    ParticleBuffer.prototype.uploadDynamic = function uploadDynamic(children, startIndex, amount) {
        for (var i = 0; i < this.dynamicProperties.length; i++) {
            var property = this.dynamicProperties[i];

            property.uploadFunction(children, startIndex, amount, property.unsignedByte ? this.dynamicDataUint32 : this.dynamicData, this.dynamicStride, property.offset);
        }

        this.dynamicBuffer.upload();
    };

    /**
     * Uploads the static properties.
     *
     * @param {PIXI.DisplayObject[]} children - The children to upload.
     * @param {number} startIndex - The index to start at.
     * @param {number} amount - The number to upload.
     */


    ParticleBuffer.prototype.uploadStatic = function uploadStatic(children, startIndex, amount) {
        for (var i = 0; i < this.staticProperties.length; i++) {
            var property = this.staticProperties[i];

            property.uploadFunction(children, startIndex, amount, property.unsignedByte ? this.staticDataUint32 : this.staticData, this.staticStride, property.offset);
        }

        this.staticBuffer.upload();
    };

    /**
     * Destroys the ParticleBuffer.
     *
     */


    ParticleBuffer.prototype.destroy = function destroy() {
        this.dynamicProperties = null;
        this.dynamicBuffer.destroy();
        this.dynamicBuffer = null;
        this.dynamicData = null;
        this.dynamicDataUint32 = null;

        this.staticProperties = null;
        this.staticBuffer.destroy();
        this.staticBuffer = null;
        this.staticData = null;
        this.staticDataUint32 = null;
    };

    return ParticleBuffer;
}();

exports.default = ParticleBuffer;

},{"../../core/utils/createIndicesForQuads":130,"pixi-gl-core":36}],184:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _core = require('../../core');

var core = _interopRequireWildcard(_core);

var _ParticleShader = require('./ParticleShader');

var _ParticleShader2 = _interopRequireDefault(_ParticleShader);

var _ParticleBuffer = require('./ParticleBuffer');

var _ParticleBuffer2 = _interopRequireDefault(_ParticleBuffer);

var _utils = require('../../core/utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @author Mat Groves
 *
 * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/
 * for creating the original PixiJS version!
 * Also a thanks to https://github.com/bchevalier for tweaking the tint and alpha so that they now
 * share 4 bytes on the vertex buffer
 *
 * Heavily inspired by LibGDX's ParticleRenderer:
 * https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/ParticleRenderer.java
 */

/**
 *
 * @class
 * @private
 * @memberof PIXI
 */
var ParticleRenderer = function (_core$ObjectRenderer) {
    _inherits(ParticleRenderer, _core$ObjectRenderer);

    /**
     * @param {PIXI.WebGLRenderer} renderer - The renderer this sprite batch works for.
     */
    function ParticleRenderer(renderer) {
        _classCallCheck(this, ParticleRenderer);

        // 65535 is max vertex index in the index buffer (see ParticleRenderer)
        // so max number of particles is 65536 / 4 = 16384
        // and max number of element in the index buffer is 16384 * 6 = 98304
        // Creating a full index buffer, overhead is 98304 * 2 = 196Ko
        // let numIndices = 98304;

        /**
         * The default shader that is used if a sprite doesn't have a more specific one.
         *
         * @member {PIXI.Shader}
         */
        var _this = _possibleConstructorReturn(this, _core$ObjectRenderer.call(this, renderer));

        _this.shader = null;

        _this.indexBuffer = null;

        _this.properties = null;

        _this.tempMatrix = new core.Matrix();

        _this.CONTEXT_UID = 0;
        return _this;
    }

    /**
     * When there is a WebGL context change
     *
     * @private
     */


    ParticleRenderer.prototype.onContextChange = function onContextChange() {
        var gl = this.renderer.gl;

        this.CONTEXT_UID = this.renderer.CONTEXT_UID;

        // setup default shader
        this.shader = new _ParticleShader2.default(gl);

        this.properties = [
        // verticesData
        {
            attribute: this.shader.attributes.aVertexPosition,
            size: 2,
            uploadFunction: this.uploadVertices,
            offset: 0
        },
        // positionData
        {
            attribute: this.shader.attributes.aPositionCoord,
            size: 2,
            uploadFunction: this.uploadPosition,
            offset: 0
        },
        // rotationData
        {
            attribute: this.shader.attributes.aRotation,
            size: 1,
            uploadFunction: this.uploadRotation,
            offset: 0
        },
        // uvsData
        {
            attribute: this.shader.attributes.aTextureCoord,
            size: 2,
            uploadFunction: this.uploadUvs,
            offset: 0
        },
        // tintData
        {
            attribute: this.shader.attributes.aColor,
            size: 1,
            unsignedByte: true,
            uploadFunction: this.uploadTint,
            offset: 0
        }];
    };

    /**
     * Starts a new particle batch.
     *
     */


    ParticleRenderer.prototype.start = function start() {
        this.renderer.bindShader(this.shader);
    };

    /**
     * Renders the particle container object.
     *
     * @param {PIXI.ParticleContainer} container - The container to render using this ParticleRenderer
     */


    ParticleRenderer.prototype.render = function render(container) {
        var children = container.children;
        var maxSize = container._maxSize;
        var batchSize = container._batchSize;
        var renderer = this.renderer;
        var totalChildren = children.length;

        if (totalChildren === 0) {
            return;
        } else if (totalChildren > maxSize) {
            totalChildren = maxSize;
        }

        var buffers = container._glBuffers[renderer.CONTEXT_UID];

        if (!buffers) {
            buffers = container._glBuffers[renderer.CONTEXT_UID] = this.generateBuffers(container);
        }

        var baseTexture = children[0]._texture.baseTexture;

        // if the uvs have not updated then no point rendering just yet!
        this.renderer.setBlendMode(core.utils.correctBlendMode(container.blendMode, baseTexture.premultipliedAlpha));

        var gl = renderer.gl;

        var m = container.worldTransform.copy(this.tempMatrix);

        m.prepend(renderer._activeRenderTarget.projectionMatrix);

        this.shader.uniforms.projectionMatrix = m.toArray(true);

        this.shader.uniforms.uColor = core.utils.premultiplyRgba(container.tintRgb, container.worldAlpha, this.shader.uniforms.uColor, baseTexture.premultipliedAlpha);

        // make sure the texture is bound..
        this.shader.uniforms.uSampler = renderer.bindTexture(baseTexture);

        var updateStatic = false;

        // now lets upload and render the buffers..
        for (var i = 0, j = 0; i < totalChildren; i += batchSize, j += 1) {
            var amount = totalChildren - i;

            if (amount > batchSize) {
                amount = batchSize;
            }

            if (j >= buffers.length) {
                if (!container.autoResize) {
                    break;
                }
                buffers.push(this._generateOneMoreBuffer(container));
            }

            var buffer = buffers[j];

            // we always upload the dynamic
            buffer.uploadDynamic(children, i, amount);

            var bid = container._bufferUpdateIDs[j] || 0;

            updateStatic = updateStatic || buffer._updateID < bid;
            // we only upload the static content when we have to!
            if (updateStatic) {
                buffer._updateID = container._updateID;
                buffer.uploadStatic(children, i, amount);
            }

            // bind the buffer
            renderer.bindVao(buffer.vao);
            buffer.vao.draw(gl.TRIANGLES, amount * 6);
        }
    };

    /**
     * Creates one particle buffer for each child in the container we want to render and updates internal properties
     *
     * @param {PIXI.ParticleContainer} container - The container to render using this ParticleRenderer
     * @return {PIXI.ParticleBuffer[]} The buffers
     */


    ParticleRenderer.prototype.generateBuffers = function generateBuffers(container) {
        var gl = this.renderer.gl;
        var buffers = [];
        var size = container._maxSize;
        var batchSize = container._batchSize;
        var dynamicPropertyFlags = container._properties;

        for (var i = 0; i < size; i += batchSize) {
            buffers.push(new _ParticleBuffer2.default(gl, this.properties, dynamicPropertyFlags, batchSize));
        }

        return buffers;
    };

    /**
     * Creates one more particle buffer, because container has autoResize feature
     *
     * @param {PIXI.ParticleContainer} container - The container to render using this ParticleRenderer
     * @return {PIXI.ParticleBuffer} generated buffer
     * @private
     */


    ParticleRenderer.prototype._generateOneMoreBuffer = function _generateOneMoreBuffer(container) {
        var gl = this.renderer.gl;
        var batchSize = container._batchSize;
        var dynamicPropertyFlags = container._properties;

        return new _ParticleBuffer2.default(gl, this.properties, dynamicPropertyFlags, batchSize);
    };

    /**
     * Uploads the verticies.
     *
     * @param {PIXI.DisplayObject[]} children - the array of display objects to render
     * @param {number} startIndex - the index to start from in the children array
     * @param {number} amount - the amount of children that will have their vertices uploaded
     * @param {number[]} array - The vertices to upload.
     * @param {number} stride - Stride to use for iteration.
     * @param {number} offset - Offset to start at.
     */


    ParticleRenderer.prototype.uploadVertices = function uploadVertices(children, startIndex, amount, array, stride, offset) {
        var w0 = 0;
        var w1 = 0;
        var h0 = 0;
        var h1 = 0;

        for (var i = 0; i < amount; ++i) {
            var sprite = children[startIndex + i];
            var texture = sprite._texture;
            var sx = sprite.scale.x;
            var sy = sprite.scale.y;
            var trim = texture.trim;
            var orig = texture.orig;

            if (trim) {
                // if the sprite is trimmed and is not a tilingsprite then we need to add the
                // extra space before transforming the sprite coords..
                w1 = trim.x - sprite.anchor.x * orig.width;
                w0 = w1 + trim.width;

                h1 = trim.y - sprite.anchor.y * orig.height;
                h0 = h1 + trim.height;
            } else {
                w0 = orig.width * (1 - sprite.anchor.x);
                w1 = orig.width * -sprite.anchor.x;

                h0 = orig.height * (1 - sprite.anchor.y);
                h1 = orig.height * -sprite.anchor.y;
            }

            array[offset] = w1 * sx;
            array[offset + 1] = h1 * sy;

            array[offset + stride] = w0 * sx;
            array[offset + stride + 1] = h1 * sy;

            array[offset + stride * 2] = w0 * sx;
            array[offset + stride * 2 + 1] = h0 * sy;

            array[offset + stride * 3] = w1 * sx;
            array[offset + stride * 3 + 1] = h0 * sy;

            offset += stride * 4;
        }
    };

    /**
     *
     * @param {PIXI.DisplayObject[]} children - the array of display objects to render
     * @param {number} startIndex - the index to start from in the children array
     * @param {number} amount - the amount of children that will have their positions uploaded
     * @param {number[]} array - The vertices to upload.
     * @param {number} stride - Stride to use for iteration.
     * @param {number} offset - Offset to start at.
     */


    ParticleRenderer.prototype.uploadPosition = function uploadPosition(children, startIndex, amount, array, stride, offset) {
        for (var i = 0; i < amount; i++) {
            var spritePosition = children[startIndex + i].position;

            array[offset] = spritePosition.x;
            array[offset + 1] = spritePosition.y;

            array[offset + stride] = spritePosition.x;
            array[offset + stride + 1] = spritePosition.y;

            array[offset + stride * 2] = spritePosition.x;
            array[offset + stride * 2 + 1] = spritePosition.y;

            array[offset + stride * 3] = spritePosition.x;
            array[offset + stride * 3 + 1] = spritePosition.y;

            offset += stride * 4;
        }
    };

    /**
     *
     * @param {PIXI.DisplayObject[]} children - the array of display objects to render
     * @param {number} startIndex - the index to start from in the children array
     * @param {number} amount - the amount of children that will have their rotation uploaded
     * @param {number[]} array - The vertices to upload.
     * @param {number} stride - Stride to use for iteration.
     * @param {number} offset - Offset to start at.
     */


    ParticleRenderer.prototype.uploadRotation = function uploadRotation(children, startIndex, amount, array, stride, offset) {
        for (var i = 0; i < amount; i++) {
            var spriteRotation = children[startIndex + i].rotation;

            array[offset] = spriteRotation;
            array[offset + stride] = spriteRotation;
            array[offset + stride * 2] = spriteRotation;
            array[offset + stride * 3] = spriteRotation;

            offset += stride * 4;
        }
    };

    /**
     *
     * @param {PIXI.DisplayObject[]} children - the array of display objects to render
     * @param {number} startIndex - the index to start from in the children array
     * @param {number} amount - the amount of children that will have their rotation uploaded
     * @param {number[]} array - The vertices to upload.
     * @param {number} stride - Stride to use for iteration.
     * @param {number} offset - Offset to start at.
     */


    ParticleRenderer.prototype.uploadUvs = function uploadUvs(children, startIndex, amount, array, stride, offset) {
        for (var i = 0; i < amount; ++i) {
            var textureUvs = children[startIndex + i]._texture._uvs;

            if (textureUvs) {
                array[offset] = textureUvs.x0;
                array[offset + 1] = textureUvs.y0;

                array[offset + stride] = textureUvs.x1;
                array[offset + stride + 1] = textureUvs.y1;

                array[offset + stride * 2] = textureUvs.x2;
                array[offset + stride * 2 + 1] = textureUvs.y2;

                array[offset + stride * 3] = textureUvs.x3;
                array[offset + stride * 3 + 1] = textureUvs.y3;

                offset += stride * 4;
            } else {
                // TODO you know this can be easier!
                array[offset] = 0;
                array[offset + 1] = 0;

                array[offset + stride] = 0;
                array[offset + stride + 1] = 0;

                array[offset + stride * 2] = 0;
                array[offset + stride * 2 + 1] = 0;

                array[offset + stride * 3] = 0;
                array[offset + stride * 3 + 1] = 0;

                offset += stride * 4;
            }
        }
    };

    /**
     *
     * @param {PIXI.DisplayObject[]} children - the array of display objects to render
     * @param {number} startIndex - the index to start from in the children array
     * @param {number} amount - the amount of children that will have their rotation uploaded
     * @param {number[]} array - The vertices to upload.
     * @param {number} stride - Stride to use for iteration.
     * @param {number} offset - Offset to start at.
     */


    ParticleRenderer.prototype.uploadTint = function uploadTint(children, startIndex, amount, array, stride, offset) {
        for (var i = 0; i < amount; ++i) {
            var sprite = children[startIndex + i];
            var premultiplied = sprite._texture.baseTexture.premultipliedAlpha;
            var alpha = sprite.alpha;
            // we dont call extra function if alpha is 1.0, that's faster
            var argb = alpha < 1.0 && premultiplied ? (0, _utils.premultiplyTint)(sprite._tintRGB, alpha) : sprite._tintRGB + (alpha * 255 << 24);

            array[offset] = argb;
            array[offset + stride] = argb;
            array[offset + stride * 2] = argb;
            array[offset + stride * 3] = argb;

            offset += stride * 4;
        }
    };

    /**
     * Destroys the ParticleRenderer.
     *
     */


    ParticleRenderer.prototype.destroy = function destroy() {
        if (this.renderer.gl) {
            this.renderer.gl.deleteBuffer(this.indexBuffer);
        }

        _core$ObjectRenderer.prototype.destroy.call(this);

        this.shader.destroy();

        this.indices = null;
        this.tempMatrix = null;
    };

    return ParticleRenderer;
}(core.ObjectRenderer);

exports.default = ParticleRenderer;


core.WebGLRenderer.registerPlugin('particle', ParticleRenderer);

},{"../../core":72,"../../core/utils":132,"./ParticleBuffer":183,"./ParticleShader":185}],185:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _Shader2 = require('../../core/Shader');

var _Shader3 = _interopRequireDefault(_Shader2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class
 * @extends PIXI.Shader
 * @memberof PIXI
 */
var ParticleShader = function (_Shader) {
    _inherits(ParticleShader, _Shader);

    /**
     * @param {PIXI.Shader} gl - The webgl shader manager this shader works for.
     */
    function ParticleShader(gl) {
        _classCallCheck(this, ParticleShader);

        return _possibleConstructorReturn(this, _Shader.call(this, gl,
        // vertex shader
        ['attribute vec2 aVertexPosition;', 'attribute vec2 aTextureCoord;', 'attribute vec4 aColor;', 'attribute vec2 aPositionCoord;', 'attribute float aRotation;', 'uniform mat3 projectionMatrix;', 'uniform vec4 uColor;', 'varying vec2 vTextureCoord;', 'varying vec4 vColor;', 'void main(void){', '   float x = (aVertexPosition.x) * cos(aRotation) - (aVertexPosition.y) * sin(aRotation);', '   float y = (aVertexPosition.x) * sin(aRotation) + (aVertexPosition.y) * cos(aRotation);', '   vec2 v = vec2(x, y);', '   v = v + aPositionCoord;', '   gl_Position = vec4((projectionMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);', '   vTextureCoord = aTextureCoord;', '   vColor = aColor * uColor;', '}'].join('\n'),
        // hello
        ['varying vec2 vTextureCoord;', 'varying vec4 vColor;', 'uniform sampler2D uSampler;', 'void main(void){', '  vec4 color = texture2D(uSampler, vTextureCoord) * vColor;', '  gl_FragColor = color;', '}'].join('\n')));
    }

    return ParticleShader;
}(_Shader3.default);

exports.default = ParticleShader;

},{"../../core/Shader":51}],186:[function(require,module,exports){
"use strict";

// References:
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign

if (!Math.sign) {
    Math.sign = function mathSign(x) {
        x = Number(x);

        if (x === 0 || isNaN(x)) {
            return x;
        }

        return x > 0 ? 1 : -1;
    };
}

},{}],187:[function(require,module,exports){
'use strict';

// References:
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger

if (!Number.isInteger) {
    Number.isInteger = function numberIsInteger(value) {
        return typeof value === 'number' && isFinite(value) && Math.floor(value) === value;
    };
}

},{}],188:[function(require,module,exports){
'use strict';

var _objectAssign = require('object-assign');

var _objectAssign2 = _interopRequireDefault(_objectAssign);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

if (!Object.assign) {
    Object.assign = _objectAssign2.default;
} // References:
// https://github.com/sindresorhus/object-assign
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign

},{"object-assign":28}],189:[function(require,module,exports){
'use strict';

require('./Object.assign');

require('./requestAnimationFrame');

require('./Math.sign');

require('./Number.isInteger');

if (!window.ArrayBuffer) {
    window.ArrayBuffer = Array;
}

if (!window.Float32Array) {
    window.Float32Array = Array;
}

if (!window.Uint32Array) {
    window.Uint32Array = Array;
}

if (!window.Uint16Array) {
    window.Uint16Array = Array;
}

},{"./Math.sign":186,"./Number.isInteger":187,"./Object.assign":188,"./requestAnimationFrame":190}],190:[function(require,module,exports){
(function (global){
'use strict';

// References:
// http://paulirish.com/2011/requestanimationframe-for-smart-animating/
// https://gist.github.com/1579671
// http://updates.html5rocks.com/2012/05/requestAnimationFrame-API-now-with-sub-millisecond-precision
// https://gist.github.com/timhall/4078614
// https://github.com/Financial-Times/polyfill-service/tree/master/polyfills/requestAnimationFrame

// Expected to be used with Browserfiy
// Browserify automatically detects the use of `global` and passes the
// correct reference of `global`, `self`, and finally `window`

var ONE_FRAME_TIME = 16;

// Date.now
if (!(Date.now && Date.prototype.getTime)) {
    Date.now = function now() {
        return new Date().getTime();
    };
}

// performance.now
if (!(global.performance && global.performance.now)) {
    var startTime = Date.now();

    if (!global.performance) {
        global.performance = {};
    }

    global.performance.now = function () {
        return Date.now() - startTime;
    };
}

// requestAnimationFrame
var lastTime = Date.now();
var vendors = ['ms', 'moz', 'webkit', 'o'];

for (var x = 0; x < vendors.length && !global.requestAnimationFrame; ++x) {
    var p = vendors[x];

    global.requestAnimationFrame = global[p + 'RequestAnimationFrame'];
    global.cancelAnimationFrame = global[p + 'CancelAnimationFrame'] || global[p + 'CancelRequestAnimationFrame'];
}

if (!global.requestAnimationFrame) {
    global.requestAnimationFrame = function (callback) {
        if (typeof callback !== 'function') {
            throw new TypeError(callback + 'is not a function');
        }

        var currentTime = Date.now();
        var delay = ONE_FRAME_TIME + lastTime - currentTime;

        if (delay < 0) {
            delay = 0;
        }

        lastTime = currentTime;

        return setTimeout(function () {
            lastTime = Date.now();
            callback(performance.now());
        }, delay);
    };
}

if (!global.cancelAnimationFrame) {
    global.cancelAnimationFrame = function (id) {
        return clearTimeout(id);
    };
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],191:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _core = require('../core');

var core = _interopRequireWildcard(_core);

var _CountLimiter = require('./limiters/CountLimiter');

var _CountLimiter2 = _interopRequireDefault(_CountLimiter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SharedTicker = core.ticker.shared;

/**
 * Default number of uploads per frame using prepare plugin.
 *
 * @static
 * @memberof PIXI.settings
 * @name UPLOADS_PER_FRAME
 * @type {number}
 * @default 4
 */
core.settings.UPLOADS_PER_FRAME = 4;

/**
 * The prepare manager provides functionality to upload content to the GPU. BasePrepare handles
 * basic queuing functionality and is extended by {@link PIXI.prepare.WebGLPrepare} and {@link PIXI.prepare.CanvasPrepare}
 * to provide preparation capabilities specific to their respective renderers.
 *
 * @example
 * // Create a sprite
 * const sprite = new PIXI.Sprite.fromImage('something.png');
 *
 * // Load object into GPU
 * app.renderer.plugins.prepare.upload(sprite, () => {
 *
 *     //Texture(s) has been uploaded to GPU
 *     app.stage.addChild(sprite);
 *
 * })
 *
 * @abstract
 * @class
 * @memberof PIXI.prepare
 */

var BasePrepare = function () {
    /**
     * @param {PIXI.SystemRenderer} renderer - A reference to the current renderer
     */
    function BasePrepare(renderer) {
        var _this = this;

        _classCallCheck(this, BasePrepare);

        /**
         * The limiter to be used to control how quickly items are prepared.
         * @type {PIXI.prepare.CountLimiter|PIXI.prepare.TimeLimiter}
         */
        this.limiter = new _CountLimiter2.default(core.settings.UPLOADS_PER_FRAME);

        /**
         * Reference to the renderer.
         * @type {PIXI.SystemRenderer}
         * @protected
         */
        this.renderer = renderer;

        /**
         * The only real difference between CanvasPrepare and WebGLPrepare is what they pass
         * to upload hooks. That different parameter is stored here.
         * @type {PIXI.prepare.CanvasPrepare|PIXI.WebGLRenderer}
         * @protected
         */
        this.uploadHookHelper = null;

        /**
         * Collection of items to uploads at once.
         * @type {Array<*>}
         * @private
         */
        this.queue = [];

        /**
         * Collection of additional hooks for finding assets.
         * @type {Array<Function>}
         * @private
         */
        this.addHooks = [];

        /**
         * Collection of additional hooks for processing assets.
         * @type {Array<Function>}
         * @private
         */
        this.uploadHooks = [];

        /**
         * Callback to call after completed.
         * @type {Array<Function>}
         * @private
         */
        this.completes = [];

        /**
         * If prepare is ticking (running).
         * @type {boolean}
         * @private
         */
        this.ticking = false;

        /**
         * 'bound' call for prepareItems().
         * @type {Function}
         * @private
         */
        this.delayedTick = function () {
            // unlikely, but in case we were destroyed between tick() and delayedTick()
            if (!_this.queue) {
                return;
            }
            _this.prepareItems();
        };

        // hooks to find the correct texture
        this.registerFindHook(findText);
        this.registerFindHook(findTextStyle);
        this.registerFindHook(findMultipleBaseTextures);
        this.registerFindHook(findBaseTexture);
        this.registerFindHook(findTexture);

        // upload hooks
        this.registerUploadHook(drawText);
        this.registerUploadHook(calculateTextStyle);
    }

    /**
     * Upload all the textures and graphics to the GPU.
     *
     * @param {Function|PIXI.DisplayObject|PIXI.Container|PIXI.BaseTexture|PIXI.Texture|PIXI.Graphics|PIXI.Text} item -
     *        Either the container or display object to search for items to upload, the items to upload themselves,
     *        or the callback function, if items have been added using `prepare.add`.
     * @param {Function} [done] - Optional callback when all queued uploads have completed
     */


    BasePrepare.prototype.upload = function upload(item, done) {
        if (typeof item === 'function') {
            done = item;
            item = null;
        }

        // If a display object, search for items
        // that we could upload
        if (item) {
            this.add(item);
        }

        // Get the items for upload from the display
        if (this.queue.length) {
            if (done) {
                this.completes.push(done);
            }

            if (!this.ticking) {
                this.ticking = true;
                SharedTicker.addOnce(this.tick, this, core.UPDATE_PRIORITY.UTILITY);
            }
        } else if (done) {
            done();
        }
    };

    /**
     * Handle tick update
     *
     * @private
     */


    BasePrepare.prototype.tick = function tick() {
        setTimeout(this.delayedTick, 0);
    };

    /**
     * Actually prepare items. This is handled outside of the tick because it will take a while
     * and we do NOT want to block the current animation frame from rendering.
     *
     * @private
     */


    BasePrepare.prototype.prepareItems = function prepareItems() {
        this.limiter.beginFrame();
        // Upload the graphics
        while (this.queue.length && this.limiter.allowedToUpload()) {
            var item = this.queue[0];
            var uploaded = false;

            if (item && !item._destroyed) {
                for (var i = 0, len = this.uploadHooks.length; i < len; i++) {
                    if (this.uploadHooks[i](this.uploadHookHelper, item)) {
                        this.queue.shift();
                        uploaded = true;
                        break;
                    }
                }
            }

            if (!uploaded) {
                this.queue.shift();
            }
        }

        // We're finished
        if (!this.queue.length) {
            this.ticking = false;

            var completes = this.completes.slice(0);

            this.completes.length = 0;

            for (var _i = 0, _len = completes.length; _i < _len; _i++) {
                completes[_i]();
            }
        } else {
            // if we are not finished, on the next rAF do this again
            SharedTicker.addOnce(this.tick, this, core.UPDATE_PRIORITY.UTILITY);
        }
    };

    /**
     * Adds hooks for finding items.
     *
     * @param {Function} addHook - Function call that takes two parameters: `item:*, queue:Array`
     *          function must return `true` if it was able to add item to the queue.
     * @return {PIXI.BasePrepare} Instance of plugin for chaining.
     */


    BasePrepare.prototype.registerFindHook = function registerFindHook(addHook) {
        if (addHook) {
            this.addHooks.push(addHook);
        }

        return this;
    };

    /**
     * Adds hooks for uploading items.
     *
     * @param {Function} uploadHook - Function call that takes two parameters: `prepare:CanvasPrepare, item:*` and
     *          function must return `true` if it was able to handle upload of item.
     * @return {PIXI.BasePrepare} Instance of plugin for chaining.
     */


    BasePrepare.prototype.registerUploadHook = function registerUploadHook(uploadHook) {
        if (uploadHook) {
            this.uploadHooks.push(uploadHook);
        }

        return this;
    };

    /**
     * Manually add an item to the uploading queue.
     *
     * @param {PIXI.DisplayObject|PIXI.Container|PIXI.BaseTexture|PIXI.Texture|PIXI.Graphics|PIXI.Text|*} item - Object to
     *        add to the queue
     * @return {PIXI.CanvasPrepare} Instance of plugin for chaining.
     */


    BasePrepare.prototype.add = function add(item) {
        // Add additional hooks for finding elements on special
        // types of objects that
        for (var i = 0, len = this.addHooks.length; i < len; i++) {
            if (this.addHooks[i](item, this.queue)) {
                break;
            }
        }

        // Get childen recursively
        if (item instanceof core.Container) {
            for (var _i2 = item.children.length - 1; _i2 >= 0; _i2--) {
                this.add(item.children[_i2]);
            }
        }

        return this;
    };

    /**
     * Destroys the plugin, don't use after this.
     *
     */


    BasePrepare.prototype.destroy = function destroy() {
        if (this.ticking) {
            SharedTicker.remove(this.tick, this);
        }
        this.ticking = false;
        this.addHooks = null;
        this.uploadHooks = null;
        this.renderer = null;
        this.completes = null;
        this.queue = null;
        this.limiter = null;
        this.uploadHookHelper = null;
    };

    return BasePrepare;
}();

/**
 * Built-in hook to find multiple textures from objects like AnimatedSprites.
 *
 * @private
 * @param {PIXI.DisplayObject} item - Display object to check
 * @param {Array<*>} queue - Collection of items to upload
 * @return {boolean} if a PIXI.Texture object was found.
 */


exports.default = BasePrepare;
function findMultipleBaseTextures(item, queue) {
    var result = false;

    // Objects with mutliple textures
    if (item && item._textures && item._textures.length) {
        for (var i = 0; i < item._textures.length; i++) {
            if (item._textures[i] instanceof core.Texture) {
                var baseTexture = item._textures[i].baseTexture;

                if (queue.indexOf(baseTexture) === -1) {
                    queue.push(baseTexture);
                    result = true;
                }
            }
        }
    }

    return result;
}

/**
 * Built-in hook to find BaseTextures from Sprites.
 *
 * @private
 * @param {PIXI.DisplayObject} item - Display object to check
 * @param {Array<*>} queue - Collection of items to upload
 * @return {boolean} if a PIXI.Texture object was found.
 */
function findBaseTexture(item, queue) {
    // Objects with textures, like Sprites/Text
    if (item instanceof core.BaseTexture) {
        if (queue.indexOf(item) === -1) {
            queue.push(item);
        }

        return true;
    }

    return false;
}

/**
 * Built-in hook to find textures from objects.
 *
 * @private
 * @param {PIXI.DisplayObject} item - Display object to check
 * @param {Array<*>} queue - Collection of items to upload
 * @return {boolean} if a PIXI.Texture object was found.
 */
function findTexture(item, queue) {
    if (item._texture && item._texture instanceof core.Texture) {
        var texture = item._texture.baseTexture;

        if (queue.indexOf(texture) === -1) {
            queue.push(texture);
        }

        return true;
    }

    return false;
}

/**
 * Built-in hook to draw PIXI.Text to its texture.
 *
 * @private
 * @param {PIXI.WebGLRenderer|PIXI.CanvasPrepare} helper - Not used by this upload handler
 * @param {PIXI.DisplayObject} item - Item to check
 * @return {boolean} If item was uploaded.
 */
function drawText(helper, item) {
    if (item instanceof core.Text) {
        // updating text will return early if it is not dirty
        item.updateText(true);

        return true;
    }

    return false;
}

/**
 * Built-in hook to calculate a text style for a PIXI.Text object.
 *
 * @private
 * @param {PIXI.WebGLRenderer|PIXI.CanvasPrepare} helper - Not used by this upload handler
 * @param {PIXI.DisplayObject} item - Item to check
 * @return {boolean} If item was uploaded.
 */
function calculateTextStyle(helper, item) {
    if (item instanceof core.TextStyle) {
        var font = item.toFontString();

        core.TextMetrics.measureFont(font);

        return true;
    }

    return false;
}

/**
 * Built-in hook to find Text objects.
 *
 * @private
 * @param {PIXI.DisplayObject} item - Display object to check
 * @param {Array<*>} queue - Collection of items to upload
 * @return {boolean} if a PIXI.Text object was found.
 */
function findText(item, queue) {
    if (item instanceof core.Text) {
        // push the text style to prepare it - this can be really expensive
        if (queue.indexOf(item.style) === -1) {
            queue.push(item.style);
        }
        // also push the text object so that we can render it (to canvas/texture) if needed
        if (queue.indexOf(item) === -1) {
            queue.push(item);
        }
        // also push the Text's texture for upload to GPU
        var texture = item._texture.baseTexture;

        if (queue.indexOf(texture) === -1) {
            queue.push(texture);
        }

        return true;
    }

    return false;
}

/**
 * Built-in hook to find TextStyle objects.
 *
 * @private
 * @param {PIXI.TextStyle} item - Display object to check
 * @param {Array<*>} queue - Collection of items to upload
 * @return {boolean} if a PIXI.TextStyle object was found.
 */
function findTextStyle(item, queue) {
    if (item instanceof core.TextStyle) {
        if (queue.indexOf(item) === -1) {
            queue.push(item);
        }

        return true;
    }

    return false;
}

},{"../core":72,"./limiters/CountLimiter":194}],192:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _core = require('../../core');

var core = _interopRequireWildcard(_core);

var _BasePrepare2 = require('../BasePrepare');

var _BasePrepare3 = _interopRequireDefault(_BasePrepare2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var CANVAS_START_SIZE = 16;

/**
 * The prepare manager provides functionality to upload content to the GPU
 * This cannot be done directly for Canvas like in WebGL, but the effect can be achieved by drawing
 * textures to an offline canvas.
 * This draw call will force the texture to be moved onto the GPU.
 *
 * An instance of this class is automatically created by default, and can be found at renderer.plugins.prepare
 *
 * @class
 * @extends PIXI.prepare.BasePrepare
 * @memberof PIXI.prepare
 */

var CanvasPrepare = function (_BasePrepare) {
    _inherits(CanvasPrepare, _BasePrepare);

    /**
     * @param {PIXI.CanvasRenderer} renderer - A reference to the current renderer
     */
    function CanvasPrepare(renderer) {
        _classCallCheck(this, CanvasPrepare);

        var _this = _possibleConstructorReturn(this, _BasePrepare.call(this, renderer));

        _this.uploadHookHelper = _this;

        /**
        * An offline canvas to render textures to
        * @type {HTMLCanvasElement}
        * @private
        */
        _this.canvas = document.createElement('canvas');
        _this.canvas.width = CANVAS_START_SIZE;
        _this.canvas.height = CANVAS_START_SIZE;

        /**
         * The context to the canvas
        * @type {CanvasRenderingContext2D}
        * @private
        */
        _this.ctx = _this.canvas.getContext('2d');

        // Add textures to upload
        _this.registerUploadHook(uploadBaseTextures);
        return _this;
    }

    /**
     * Destroys the plugin, don't use after this.
     *
     */


    CanvasPrepare.prototype.destroy = function destroy() {
        _BasePrepare.prototype.destroy.call(this);
        this.ctx = null;
        this.canvas = null;
    };

    return CanvasPrepare;
}(_BasePrepare3.default);

/**
 * Built-in hook to upload PIXI.Texture objects to the GPU.
 *
 * @private
 * @param {*} prepare - Instance of CanvasPrepare
 * @param {*} item - Item to check
 * @return {boolean} If item was uploaded.
 */


exports.default = CanvasPrepare;
function uploadBaseTextures(prepare, item) {
    if (item instanceof core.BaseTexture) {
        var image = item.source;

        // Sometimes images (like atlas images) report a size of zero, causing errors on windows phone.
        // So if the width or height is equal to zero then use the canvas size
        // Otherwise use whatever is smaller, the image dimensions or the canvas dimensions.
        var imageWidth = image.width === 0 ? prepare.canvas.width : Math.min(prepare.canvas.width, image.width);
        var imageHeight = image.height === 0 ? prepare.canvas.height : Math.min(prepare.canvas.height, image.height);

        // Only a small subsections is required to be drawn to have the whole texture uploaded to the GPU
        // A smaller draw can be faster.
        prepare.ctx.drawImage(image, 0, 0, imageWidth, imageHeight, 0, 0, prepare.canvas.width, prepare.canvas.height);

        return true;
    }

    return false;
}

core.CanvasRenderer.registerPlugin('prepare', CanvasPrepare);

},{"../../core":72,"../BasePrepare":191}],193:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _WebGLPrepare = require('./webgl/WebGLPrepare');

Object.defineProperty(exports, 'webgl', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_WebGLPrepare).default;
  }
});

var _CanvasPrepare = require('./canvas/CanvasPrepare');

Object.defineProperty(exports, 'canvas', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_CanvasPrepare).default;
  }
});

var _BasePrepare = require('./BasePrepare');

Object.defineProperty(exports, 'BasePrepare', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_BasePrepare).default;
  }
});

var _CountLimiter = require('./limiters/CountLimiter');

Object.defineProperty(exports, 'CountLimiter', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_CountLimiter).default;
  }
});

var _TimeLimiter = require('./limiters/TimeLimiter');

Object.defineProperty(exports, 'TimeLimiter', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_TimeLimiter).default;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

},{"./BasePrepare":191,"./canvas/CanvasPrepare":192,"./limiters/CountLimiter":194,"./limiters/TimeLimiter":195,"./webgl/WebGLPrepare":196}],194:[function(require,module,exports){
"use strict";

exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * CountLimiter limits the number of items handled by a {@link PIXI.prepare.BasePrepare} to a specified
 * number of items per frame.
 *
 * @class
 * @memberof PIXI
 */
var CountLimiter = function () {
  /**
   * @param {number} maxItemsPerFrame - The maximum number of items that can be prepared each frame.
   */
  function CountLimiter(maxItemsPerFrame) {
    _classCallCheck(this, CountLimiter);

    /**
     * The maximum number of items that can be prepared each frame.
     * @private
     */
    this.maxItemsPerFrame = maxItemsPerFrame;
    /**
     * The number of items that can be prepared in the current frame.
     * @type {number}
     * @private
     */
    this.itemsLeft = 0;
  }

  /**
   * Resets any counting properties to start fresh on a new frame.
   */


  CountLimiter.prototype.beginFrame = function beginFrame() {
    this.itemsLeft = this.maxItemsPerFrame;
  };

  /**
   * Checks to see if another item can be uploaded. This should only be called once per item.
   * @return {boolean} If the item is allowed to be uploaded.
   */


  CountLimiter.prototype.allowedToUpload = function allowedToUpload() {
    return this.itemsLeft-- > 0;
  };

  return CountLimiter;
}();

exports.default = CountLimiter;

},{}],195:[function(require,module,exports){
"use strict";

exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * TimeLimiter limits the number of items handled by a {@link PIXI.BasePrepare} to a specified
 * number of milliseconds per frame.
 *
 * @class
 * @memberof PIXI
 */
var TimeLimiter = function () {
  /**
   * @param {number} maxMilliseconds - The maximum milliseconds that can be spent preparing items each frame.
   */
  function TimeLimiter(maxMilliseconds) {
    _classCallCheck(this, TimeLimiter);

    /**
     * The maximum milliseconds that can be spent preparing items each frame.
     * @private
     */
    this.maxMilliseconds = maxMilliseconds;
    /**
     * The start time of the current frame.
     * @type {number}
     * @private
     */
    this.frameStart = 0;
  }

  /**
   * Resets any counting properties to start fresh on a new frame.
   */


  TimeLimiter.prototype.beginFrame = function beginFrame() {
    this.frameStart = Date.now();
  };

  /**
   * Checks to see if another item can be uploaded. This should only be called once per item.
   * @return {boolean} If the item is allowed to be uploaded.
   */


  TimeLimiter.prototype.allowedToUpload = function allowedToUpload() {
    return Date.now() - this.frameStart < this.maxMilliseconds;
  };

  return TimeLimiter;
}();

exports.default = TimeLimiter;

},{}],196:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _core = require('../../core');

var core = _interopRequireWildcard(_core);

var _BasePrepare2 = require('../BasePrepare');

var _BasePrepare3 = _interopRequireDefault(_BasePrepare2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The prepare manager provides functionality to upload content to the GPU.
 *
 * An instance of this class is automatically created by default, and can be found at renderer.plugins.prepare
 *
 * @class
 * @extends PIXI.prepare.BasePrepare
 * @memberof PIXI.prepare
 */
var WebGLPrepare = function (_BasePrepare) {
    _inherits(WebGLPrepare, _BasePrepare);

    /**
     * @param {PIXI.WebGLRenderer} renderer - A reference to the current renderer
     */
    function WebGLPrepare(renderer) {
        _classCallCheck(this, WebGLPrepare);

        var _this = _possibleConstructorReturn(this, _BasePrepare.call(this, renderer));

        _this.uploadHookHelper = _this.renderer;

        // Add textures and graphics to upload
        _this.registerFindHook(findGraphics);
        _this.registerUploadHook(uploadBaseTextures);
        _this.registerUploadHook(uploadGraphics);
        return _this;
    }

    return WebGLPrepare;
}(_BasePrepare3.default);
/**
 * Built-in hook to upload PIXI.Texture objects to the GPU.
 *
 * @private
 * @param {PIXI.WebGLRenderer} renderer - instance of the webgl renderer
 * @param {PIXI.DisplayObject} item - Item to check
 * @return {boolean} If item was uploaded.
 */


exports.default = WebGLPrepare;
function uploadBaseTextures(renderer, item) {
    if (item instanceof core.BaseTexture) {
        // if the texture already has a GL texture, then the texture has been prepared or rendered
        // before now. If the texture changed, then the changer should be calling texture.update() which
        // reuploads the texture without need for preparing it again
        if (!item._glTextures[renderer.CONTEXT_UID]) {
            renderer.textureManager.updateTexture(item);
        }

        return true;
    }

    return false;
}

/**
 * Built-in hook to upload PIXI.Graphics to the GPU.
 *
 * @private
 * @param {PIXI.WebGLRenderer} renderer - instance of the webgl renderer
 * @param {PIXI.DisplayObject} item - Item to check
 * @return {boolean} If item was uploaded.
 */
function uploadGraphics(renderer, item) {
    if (item instanceof core.Graphics) {
        // if the item is not dirty and already has webgl data, then it got prepared or rendered
        // before now and we shouldn't waste time updating it again
        if (item.dirty || item.clearDirty || !item._webGL[renderer.plugins.graphics.CONTEXT_UID]) {
            renderer.plugins.graphics.updateGraphics(item);
        }

        return true;
    }

    return false;
}

/**
 * Built-in hook to find graphics.
 *
 * @private
 * @param {PIXI.DisplayObject} item - Display object to check
 * @param {Array<*>} queue - Collection of items to upload
 * @return {boolean} if a PIXI.Graphics object was found.
 */
function findGraphics(item, queue) {
    if (item instanceof core.Graphics) {
        queue.push(item);

        return true;
    }

    return false;
}

core.WebGLRenderer.registerPlugin('prepare', WebGLPrepare);

},{"../../core":72,"../BasePrepare":191}],197:[function(require,module,exports){
'use strict'

/**
 * Remove a range of items from an array
 *
 * @function removeItems
 * @param {Array<*>} arr The target array
 * @param {number} startIdx The index to begin removing from (inclusive)
 * @param {number} removeCount How many items to remove
 */
module.exports = function removeItems (arr, startIdx, removeCount) {
  var i, length = arr.length

  if (startIdx >= length || removeCount === 0) {
    return
  }

  removeCount = (startIdx + removeCount > length ? length - startIdx : removeCount)

  var len = length - removeCount

  for (i = startIdx; i < len; ++i) {
    arr[i] = arr[i + removeCount]
  }

  arr.length = len
}

},{}],198:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.Loader = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _miniSignals = require('mini-signals');

var _miniSignals2 = _interopRequireDefault(_miniSignals);

var _parseUri = require('parse-uri');

var _parseUri2 = _interopRequireDefault(_parseUri);

var _async = require('./async');

var async = _interopRequireWildcard(_async);

var _Resource = require('./Resource');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// some constants
var MAX_PROGRESS = 100;
var rgxExtractUrlHash = /(#[\w-]+)?$/;

/**
 * Manages the state and loading of multiple resources to load.
 *
 * @class
 */

var Loader = exports.Loader = function () {
    /**
     * @param {string} [baseUrl=''] - The base url for all resources loaded by this loader.
     * @param {number} [concurrency=10] - The number of resources to load concurrently.
     */
    function Loader() {
        var _this = this;

        var baseUrl = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
        var concurrency = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;

        _classCallCheck(this, Loader);

        /**
         * The base url for all resources loaded by this loader.
         *
         * @member {string}
         */
        this.baseUrl = baseUrl;

        /**
         * The progress percent of the loader going through the queue.
         *
         * @member {number}
         */
        this.progress = 0;

        /**
         * Loading state of the loader, true if it is currently loading resources.
         *
         * @member {boolean}
         */
        this.loading = false;

        /**
         * A querystring to append to every URL added to the loader.
         *
         * This should be a valid query string *without* the question-mark (`?`). The loader will
         * also *not* escape values for you. Make sure to escape your parameters with
         * [`encodeURIComponent`](https://mdn.io/encodeURIComponent) before assigning this property.
         *
         * @example
         * const loader = new Loader();
         *
         * loader.defaultQueryString = 'user=me&password=secret';
         *
         * // This will request 'image.png?user=me&password=secret'
         * loader.add('image.png').load();
         *
         * loader.reset();
         *
         * // This will request 'image.png?v=1&user=me&password=secret'
         * loader.add('iamge.png?v=1').load();
         *
         * @member {string}
         */
        this.defaultQueryString = '';

        /**
         * The middleware to run before loading each resource.
         *
         * @private
         * @member {function[]}
         */
        this._beforeMiddleware = [];

        /**
         * The middleware to run after loading each resource.
         *
         * @private
         * @member {function[]}
         */
        this._afterMiddleware = [];

        /**
         * The tracks the resources we are currently completing parsing for.
         *
         * @private
         * @member {Resource[]}
         */
        this._resourcesParsing = [];

        /**
         * The `_loadResource` function bound with this object context.
         *
         * @private
         * @member {function}
         * @param {Resource} r - The resource to load
         * @param {Function} d - The dequeue function
         * @return {undefined}
         */
        this._boundLoadResource = function (r, d) {
            return _this._loadResource(r, d);
        };

        /**
         * The resources waiting to be loaded.
         *
         * @private
         * @member {Resource[]}
         */
        this._queue = async.queue(this._boundLoadResource, concurrency);

        this._queue.pause();

        /**
         * All the resources for this loader keyed by name.
         *
         * @member {object<string, Resource>}
         */
        this.resources = {};

        /**
         * Dispatched once per loaded or errored resource.
         *
         * The callback looks like {@link Loader.OnProgressSignal}.
         *
         * @member {Signal<Loader.OnProgressSignal>}
         */
        this.onProgress = new _miniSignals2.default();

        /**
         * Dispatched once per errored resource.
         *
         * The callback looks like {@link Loader.OnErrorSignal}.
         *
         * @member {Signal<Loader.OnErrorSignal>}
         */
        this.onError = new _miniSignals2.default();

        /**
         * Dispatched once per loaded resource.
         *
         * The callback looks like {@link Loader.OnLoadSignal}.
         *
         * @member {Signal<Loader.OnLoadSignal>}
         */
        this.onLoad = new _miniSignals2.default();

        /**
         * Dispatched when the loader begins to process the queue.
         *
         * The callback looks like {@link Loader.OnStartSignal}.
         *
         * @member {Signal<Loader.OnStartSignal>}
         */
        this.onStart = new _miniSignals2.default();

        /**
         * Dispatched when the queued resources all load.
         *
         * The callback looks like {@link Loader.OnCompleteSignal}.
         *
         * @member {Signal<Loader.OnCompleteSignal>}
         */
        this.onComplete = new _miniSignals2.default();

        // Add default before middleware
        for (var i = 0; i < Loader._defaultBeforeMiddleware.length; ++i) {
            this.pre(Loader._defaultBeforeMiddleware[i]);
        }

        // Add default after middleware
        for (var _i = 0; _i < Loader._defaultAfterMiddleware.length; ++_i) {
            this.use(Loader._defaultAfterMiddleware[_i]);
        }
    }

    /**
     * When the progress changes the loader and resource are disaptched.
     *
     * @memberof Loader
     * @callback OnProgressSignal
     * @param {Loader} loader - The loader the progress is advancing on.
     * @param {Resource} resource - The resource that has completed or failed to cause the progress to advance.
     */

    /**
     * When an error occurrs the loader and resource are disaptched.
     *
     * @memberof Loader
     * @callback OnErrorSignal
     * @param {Loader} loader - The loader the error happened in.
     * @param {Resource} resource - The resource that caused the error.
     */

    /**
     * When a load completes the loader and resource are disaptched.
     *
     * @memberof Loader
     * @callback OnLoadSignal
     * @param {Loader} loader - The loader that laoded the resource.
     * @param {Resource} resource - The resource that has completed loading.
     */

    /**
     * When the loader starts loading resources it dispatches this callback.
     *
     * @memberof Loader
     * @callback OnStartSignal
     * @param {Loader} loader - The loader that has started loading resources.
     */

    /**
     * When the loader completes loading resources it dispatches this callback.
     *
     * @memberof Loader
     * @callback OnCompleteSignal
     * @param {Loader} loader - The loader that has finished loading resources.
     */

    /**
     * Options for a call to `.add()`.
     *
     * @see Loader#add
     *
     * @typedef {object} IAddOptions
     * @property {string} [name] - The name of the resource to load, if not passed the url is used.
     * @property {string} [key] - Alias for `name`.
     * @property {string} [url] - The url for this resource, relative to the baseUrl of this loader.
     * @property {string|boolean} [crossOrigin] - Is this request cross-origin? Default is to
     *      determine automatically.
     * @property {number} [timeout=0] - A timeout in milliseconds for the load. If the load takes
     *      longer than this time it is cancelled and the load is considered a failure. If this value is
     *      set to `0` then there is no explicit timeout.
     * @property {Resource.LOAD_TYPE} [loadType=Resource.LOAD_TYPE.XHR] - How should this resource
     *      be loaded?
     * @property {Resource.XHR_RESPONSE_TYPE} [xhrType=Resource.XHR_RESPONSE_TYPE.DEFAULT] - How
     *      should the data being loaded be interpreted when using XHR?
     * @property {Resource.OnCompleteSignal} [onComplete] - Callback to add an an onComplete signal istener.
     * @property {Resource.OnCompleteSignal} [callback] - Alias for `onComplete`.
     * @property {Resource.IMetadata} [metadata] - Extra configuration for middleware and the Resource object.
     */

    /* eslint-disable require-jsdoc,valid-jsdoc */
    /**
     * Adds a resource (or multiple resources) to the loader queue.
     *
     * This function can take a wide variety of different parameters. The only thing that is always
     * required the url to load. All the following will work:
     *
     * ```js
     * loader
     *     // normal param syntax
     *     .add('key', 'http://...', function () {})
     *     .add('http://...', function () {})
     *     .add('http://...')
     *
     *     // object syntax
     *     .add({
     *         name: 'key2',
     *         url: 'http://...'
     *     }, function () {})
     *     .add({
     *         url: 'http://...'
     *     }, function () {})
     *     .add({
     *         name: 'key3',
     *         url: 'http://...'
     *         onComplete: function () {}
     *     })
     *     .add({
     *         url: 'https://...',
     *         onComplete: function () {},
     *         crossOrigin: true
     *     })
     *
     *     // you can also pass an array of objects or urls or both
     *     .add([
     *         { name: 'key4', url: 'http://...', onComplete: function () {} },
     *         { url: 'http://...', onComplete: function () {} },
     *         'http://...'
     *     ])
     *
     *     // and you can use both params and options
     *     .add('key', 'http://...', { crossOrigin: true }, function () {})
     *     .add('http://...', { crossOrigin: true }, function () {});
     * ```
     *
     * @function
     * @variation 1
     * @param {string} name - The name of the resource to load.
     * @param {string} url - The url for this resource, relative to the baseUrl of this loader.
     * @param {Resource.OnCompleteSignal} [callback] - Function to call when this specific resource completes loading.
     * @return {this} Returns itself.
     */ /**
        * @function
        * @variation 2
        * @param {string} name - The name of the resource to load.
        * @param {string} url - The url for this resource, relative to the baseUrl of this loader.
        * @param {IAddOptions} [options] - The options for the load.
        * @param {Resource.OnCompleteSignal} [callback] - Function to call when this specific resource completes loading.
        * @return {this} Returns itself.
        */ /**
           * @function
           * @variation 3
           * @param {string} url - The url for this resource, relative to the baseUrl of this loader.
           * @param {Resource.OnCompleteSignal} [callback] - Function to call when this specific resource completes loading.
           * @return {this} Returns itself.
           */ /**
              * @function
              * @variation 4
              * @param {string} url - The url for this resource, relative to the baseUrl of this loader.
              * @param {IAddOptions} [options] - The options for the load.
              * @param {Resource.OnCompleteSignal} [callback] - Function to call when this specific resource completes loading.
              * @return {this} Returns itself.
              */ /**
                 * @function
                 * @variation 5
                 * @param {IAddOptions} options - The options for the load. This object must contain a `url` property.
                 * @param {Resource.OnCompleteSignal} [callback] - Function to call when this specific resource completes loading.
                 * @return {this} Returns itself.
                 */ /**
                    * @function
                    * @variation 6
                    * @param {Array<IAddOptions|string>} resources - An array of resources to load, where each is
                    *      either an object with the options or a string url. If you pass an object, it must contain a `url` property.
                    * @param {Resource.OnCompleteSignal} [callback] - Function to call when this specific resource completes loading.
                    * @return {this} Returns itself.
                    */


    Loader.prototype.add = function add(name, url, options, cb) {
        // special case of an array of objects or urls
        if (Array.isArray(name)) {
            for (var i = 0; i < name.length; ++i) {
                this.add(name[i]);
            }

            return this;
        }

        // if an object is passed instead of params
        if ((typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {
            cb = url || name.callback || name.onComplete;
            options = name;
            url = name.url;
            name = name.name || name.key || name.url;
        }

        // case where no name is passed shift all args over by one.
        if (typeof url !== 'string') {
            cb = options;
            options = url;
            url = name;
        }

        // now that we shifted make sure we have a proper url.
        if (typeof url !== 'string') {
            throw new Error('No url passed to add resource to loader.');
        }

        // options are optional so people might pass a function and no options
        if (typeof options === 'function') {
            cb = options;
            options = null;
        }

        // if loading already you can only add resources that have a parent.
        if (this.loading && (!options || !options.parentResource)) {
            throw new Error('Cannot add resources while the loader is running.');
        }

        // check if resource already exists.
        if (this.resources[name]) {
            throw new Error('Resource named "' + name + '" already exists.');
        }

        // add base url if this isn't an absolute url
        url = this._prepareUrl(url);

        // create the store the resource
        this.resources[name] = new _Resource.Resource(name, url, options);

        if (typeof cb === 'function') {
            this.resources[name].onAfterMiddleware.once(cb);
        }

        // if actively loading, make sure to adjust progress chunks for that parent and its children
        if (this.loading) {
            var parent = options.parentResource;
            var incompleteChildren = [];

            for (var _i2 = 0; _i2 < parent.children.length; ++_i2) {
                if (!parent.children[_i2].isComplete) {
                    incompleteChildren.push(parent.children[_i2]);
                }
            }

            var fullChunk = parent.progressChunk * (incompleteChildren.length + 1); // +1 for parent
            var eachChunk = fullChunk / (incompleteChildren.length + 2); // +2 for parent & new child

            parent.children.push(this.resources[name]);
            parent.progressChunk = eachChunk;

            for (var _i3 = 0; _i3 < incompleteChildren.length; ++_i3) {
                incompleteChildren[_i3].progressChunk = eachChunk;
            }

            this.resources[name].progressChunk = eachChunk;
        }

        // add the resource to the queue
        this._queue.push(this.resources[name]);

        return this;
    };
    /* eslint-enable require-jsdoc,valid-jsdoc */

    /**
     * Sets up a middleware function that will run *before* the
     * resource is loaded.
     *
     * @param {function} fn - The middleware function to register.
     * @return {this} Returns itself.
     */


    Loader.prototype.pre = function pre(fn) {
        this._beforeMiddleware.push(fn);

        return this;
    };

    /**
     * Sets up a middleware function that will run *after* the
     * resource is loaded.
     *
     * @param {function} fn - The middleware function to register.
     * @return {this} Returns itself.
     */


    Loader.prototype.use = function use(fn) {
        this._afterMiddleware.push(fn);

        return this;
    };

    /**
     * Resets the queue of the loader to prepare for a new load.
     *
     * @return {this} Returns itself.
     */


    Loader.prototype.reset = function reset() {
        this.progress = 0;
        this.loading = false;

        this._queue.kill();
        this._queue.pause();

        // abort all resource loads
        for (var k in this.resources) {
            var res = this.resources[k];

            if (res._onLoadBinding) {
                res._onLoadBinding.detach();
            }

            if (res.isLoading) {
                res.abort();
            }
        }

        this.resources = {};

        return this;
    };

    /**
     * Starts loading the queued resources.
     *
     * @param {function} [cb] - Optional callback that will be bound to the `complete` event.
     * @return {this} Returns itself.
     */


    Loader.prototype.load = function load(cb) {
        // register complete callback if they pass one
        if (typeof cb === 'function') {
            this.onComplete.once(cb);
        }

        // if the queue has already started we are done here
        if (this.loading) {
            return this;
        }

        if (this._queue.idle()) {
            this._onStart();
            this._onComplete();
        } else {
            // distribute progress chunks
            var numTasks = this._queue._tasks.length;
            var chunk = MAX_PROGRESS / numTasks;

            for (var i = 0; i < this._queue._tasks.length; ++i) {
                this._queue._tasks[i].data.progressChunk = chunk;
            }

            // notify we are starting
            this._onStart();

            // start loading
            this._queue.resume();
        }

        return this;
    };

    /**
     * The number of resources to load concurrently.
     *
     * @member {number}
     * @default 10
     */


    /**
     * Prepares a url for usage based on the configuration of this object
     *
     * @private
     * @param {string} url - The url to prepare.
     * @return {string} The prepared url.
     */
    Loader.prototype._prepareUrl = function _prepareUrl(url) {
        var parsedUrl = (0, _parseUri2.default)(url, { strictMode: true });
        var result = void 0;

        // absolute url, just use it as is.
        if (parsedUrl.protocol || !parsedUrl.path || url.indexOf('//') === 0) {
            result = url;
        }
        // if baseUrl doesn't end in slash and url doesn't start with slash, then add a slash inbetween
        else if (this.baseUrl.length && this.baseUrl.lastIndexOf('/') !== this.baseUrl.length - 1 && url.charAt(0) !== '/') {
                result = this.baseUrl + '/' + url;
            } else {
                result = this.baseUrl + url;
            }

        // if we need to add a default querystring, there is a bit more work
        if (this.defaultQueryString) {
            var hash = rgxExtractUrlHash.exec(result)[0];

            result = result.substr(0, result.length - hash.length);

            if (result.indexOf('?') !== -1) {
                result += '&' + this.defaultQueryString;
            } else {
                result += '?' + this.defaultQueryString;
            }

            result += hash;
        }

        return result;
    };

    /**
     * Loads a single resource.
     *
     * @private
     * @param {Resource} resource - The resource to load.
     * @param {function} dequeue - The function to call when we need to dequeue this item.
     */


    Loader.prototype._loadResource = function _loadResource(resource, dequeue) {
        var _this2 = this;

        resource._dequeue = dequeue;

        // run before middleware
        async.eachSeries(this._beforeMiddleware, function (fn, next) {
            fn.call(_this2, resource, function () {
                // if the before middleware marks the resource as complete,
                // break and don't process any more before middleware
                next(resource.isComplete ? {} : null);
            });
        }, function () {
            if (resource.isComplete) {
                _this2._onLoad(resource);
            } else {
                resource._onLoadBinding = resource.onComplete.once(_this2._onLoad, _this2);
                resource.load();
            }
        }, true);
    };

    /**
     * Called once loading has started.
     *
     * @private
     */


    Loader.prototype._onStart = function _onStart() {
        this.progress = 0;
        this.loading = true;
        this.onStart.dispatch(this);
    };

    /**
     * Called once each resource has loaded.
     *
     * @private
     */


    Loader.prototype._onComplete = function _onComplete() {
        this.progress = MAX_PROGRESS;
        this.loading = false;
        this.onComplete.dispatch(this, this.resources);
    };

    /**
     * Called each time a resources is loaded.
     *
     * @private
     * @param {Resource} resource - The resource that was loaded
     */


    Loader.prototype._onLoad = function _onLoad(resource) {
        var _this3 = this;

        resource._onLoadBinding = null;

        // remove this resource from the async queue, and add it to our list of resources that are being parsed
        this._resourcesParsing.push(resource);
        resource._dequeue();

        // run all the after middleware for this resource
        async.eachSeries(this._afterMiddleware, function (fn, next) {
            fn.call(_this3, resource, next);
        }, function () {
            resource.onAfterMiddleware.dispatch(resource);

            _this3.progress = Math.min(MAX_PROGRESS, _this3.progress + resource.progressChunk);
            _this3.onProgress.dispatch(_this3, resource);

            if (resource.error) {
                _this3.onError.dispatch(resource.error, _this3, resource);
            } else {
                _this3.onLoad.dispatch(_this3, resource);
            }

            _this3._resourcesParsing.splice(_this3._resourcesParsing.indexOf(resource), 1);

            // do completion check
            if (_this3._queue.idle() && _this3._resourcesParsing.length === 0) {
                _this3._onComplete();
            }
        }, true);
    };

    _createClass(Loader, [{
        key: 'concurrency',
        get: function get() {
            return this._queue.concurrency;
        }
        // eslint-disable-next-line require-jsdoc
        ,
        set: function set(concurrency) {
            this._queue.concurrency = concurrency;
        }
    }]);

    return Loader;
}();

/**
 * A default array of middleware to run before loading each resource.
 * Each of these middlewares are added to any new Loader instances when they are created.
 *
 * @private
 * @member {function[]}
 */


Loader._defaultBeforeMiddleware = [];

/**
 * A default array of middleware to run after loading each resource.
 * Each of these middlewares are added to any new Loader instances when they are created.
 *
 * @private
 * @member {function[]}
 */
Loader._defaultAfterMiddleware = [];

/**
 * Sets up a middleware function that will run *before* the
 * resource is loaded.
 *
 * @static
 * @param {function} fn - The middleware function to register.
 * @return {Loader} Returns itself.
 */
Loader.pre = function LoaderPreStatic(fn) {
    Loader._defaultBeforeMiddleware.push(fn);

    return Loader;
};

/**
 * Sets up a middleware function that will run *after* the
 * resource is loaded.
 *
 * @static
 * @param {function} fn - The middleware function to register.
 * @return {Loader} Returns itself.
 */
Loader.use = function LoaderUseStatic(fn) {
    Loader._defaultAfterMiddleware.push(fn);

    return Loader;
};

},{"./Resource":199,"./async":200,"mini-signals":27,"parse-uri":29}],199:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.Resource = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _parseUri = require('parse-uri');

var _parseUri2 = _interopRequireDefault(_parseUri);

var _miniSignals = require('mini-signals');

var _miniSignals2 = _interopRequireDefault(_miniSignals);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// tests if CORS is supported in XHR, if not we need to use XDR
var useXdr = !!(window.XDomainRequest && !('withCredentials' in new XMLHttpRequest()));
var tempAnchor = null;

// some status constants
var STATUS_NONE = 0;
var STATUS_OK = 200;
var STATUS_EMPTY = 204;
var STATUS_IE_BUG_EMPTY = 1223;
var STATUS_TYPE_OK = 2;

// noop
function _noop() {} /* empty */

/**
 * Manages the state and loading of a resource and all child resources.
 *
 * @class
 */

var Resource = exports.Resource = function () {
    /**
     * Sets the load type to be used for a specific extension.
     *
     * @static
     * @param {string} extname - The extension to set the type for, e.g. "png" or "fnt"
     * @param {Resource.LOAD_TYPE} loadType - The load type to set it to.
     */
    Resource.setExtensionLoadType = function setExtensionLoadType(extname, loadType) {
        setExtMap(Resource._loadTypeMap, extname, loadType);
    };

    /**
     * Sets the load type to be used for a specific extension.
     *
     * @static
     * @param {string} extname - The extension to set the type for, e.g. "png" or "fnt"
     * @param {Resource.XHR_RESPONSE_TYPE} xhrType - The xhr type to set it to.
     */


    Resource.setExtensionXhrType = function setExtensionXhrType(extname, xhrType) {
        setExtMap(Resource._xhrTypeMap, extname, xhrType);
    };

    /**
     * @param {string} name - The name of the resource to load.
     * @param {string|string[]} url - The url for this resource, for audio/video loads you can pass
     *      an array of sources.
     * @param {object} [options] - The options for the load.
     * @param {string|boolean} [options.crossOrigin] - Is this request cross-origin? Default is to
     *      determine automatically.
     * @param {number} [options.timeout=0] - A timeout in milliseconds for the load. If the load takes
     *      longer than this time it is cancelled and the load is considered a failure. If this value is
     *      set to `0` then there is no explicit timeout.
     * @param {Resource.LOAD_TYPE} [options.loadType=Resource.LOAD_TYPE.XHR] - How should this resource
     *      be loaded?
     * @param {Resource.XHR_RESPONSE_TYPE} [options.xhrType=Resource.XHR_RESPONSE_TYPE.DEFAULT] - How
     *      should the data being loaded be interpreted when using XHR?
     * @param {Resource.IMetadata} [options.metadata] - Extra configuration for middleware and the Resource object.
     */


    function Resource(name, url, options) {
        _classCallCheck(this, Resource);

        if (typeof name !== 'string' || typeof url !== 'string') {
            throw new Error('Both name and url are required for constructing a resource.');
        }

        options = options || {};

        /**
         * The state flags of this resource.
         *
         * @private
         * @member {number}
         */
        this._flags = 0;

        // set data url flag, needs to be set early for some _determineX checks to work.
        this._setFlag(Resource.STATUS_FLAGS.DATA_URL, url.indexOf('data:') === 0);

        /**
         * The name of this resource.
         *
         * @readonly
         * @member {string}
         */
        this.name = name;

        /**
         * The url used to load this resource.
         *
         * @readonly
         * @member {string}
         */
        this.url = url;

        /**
         * The extension used to load this resource.
         *
         * @readonly
         * @member {string}
         */
        this.extension = this._getExtension();

        /**
         * The data that was loaded by the resource.
         *
         * @member {any}
         */
        this.data = null;

        /**
         * Is this request cross-origin? If unset, determined automatically.
         *
         * @member {string}
         */
        this.crossOrigin = options.crossOrigin === true ? 'anonymous' : options.crossOrigin;

        /**
         * A timeout in milliseconds for the load. If the load takes longer than this time
         * it is cancelled and the load is considered a failure. If this value is set to `0`
         * then there is no explicit timeout.
         *
         * @member {number}
         */
        this.timeout = options.timeout || 0;

        /**
         * The method of loading to use for this resource.
         *
         * @member {Resource.LOAD_TYPE}
         */
        this.loadType = options.loadType || this._determineLoadType();

        /**
         * The type used to load the resource via XHR. If unset, determined automatically.
         *
         * @member {string}
         */
        this.xhrType = options.xhrType;

        /**
         * Extra info for middleware, and controlling specifics about how the resource loads.
         *
         * Note that if you pass in a `loadElement`, the Resource class takes ownership of it.
         * Meaning it will modify it as it sees fit.
         *
         * @member {Resource.IMetadata}
         */
        this.metadata = options.metadata || {};

        /**
         * The error that occurred while loading (if any).
         *
         * @readonly
         * @member {Error}
         */
        this.error = null;

        /**
         * The XHR object that was used to load this resource. This is only set
         * when `loadType` is `Resource.LOAD_TYPE.XHR`.
         *
         * @readonly
         * @member {XMLHttpRequest}
         */
        this.xhr = null;

        /**
         * The child resources this resource owns.
         *
         * @readonly
         * @member {Resource[]}
         */
        this.children = [];

        /**
         * The resource type.
         *
         * @readonly
         * @member {Resource.TYPE}
         */
        this.type = Resource.TYPE.UNKNOWN;

        /**
         * The progress chunk owned by this resource.
         *
         * @readonly
         * @member {number}
         */
        this.progressChunk = 0;

        /**
         * The `dequeue` method that will be used a storage place for the async queue dequeue method
         * used privately by the loader.
         *
         * @private
         * @member {function}
         */
        this._dequeue = _noop;

        /**
         * Used a storage place for the on load binding used privately by the loader.
         *
         * @private
         * @member {function}
         */
        this._onLoadBinding = null;

        /**
         * The timer for element loads to check if they timeout.
         *
         * @private
         * @member {number}
         */
        this._elementTimer = 0;

        /**
         * The `complete` function bound to this resource's context.
         *
         * @private
         * @member {function}
         */
        this._boundComplete = this.complete.bind(this);

        /**
         * The `_onError` function bound to this resource's context.
         *
         * @private
         * @member {function}
         */
        this._boundOnError = this._onError.bind(this);

        /**
         * The `_onProgress` function bound to this resource's context.
         *
         * @private
         * @member {function}
         */
        this._boundOnProgress = this._onProgress.bind(this);

        /**
         * The `_onTimeout` function bound to this resource's context.
         *
         * @private
         * @member {function}
         */
        this._boundOnTimeout = this._onTimeout.bind(this);

        // xhr callbacks
        this._boundXhrOnError = this._xhrOnError.bind(this);
        this._boundXhrOnTimeout = this._xhrOnTimeout.bind(this);
        this._boundXhrOnAbort = this._xhrOnAbort.bind(this);
        this._boundXhrOnLoad = this._xhrOnLoad.bind(this);

        /**
         * Dispatched when the resource beings to load.
         *
         * The callback looks like {@link Resource.OnStartSignal}.
         *
         * @member {Signal<Resource.OnStartSignal>}
         */
        this.onStart = new _miniSignals2.default();

        /**
         * Dispatched each time progress of this resource load updates.
         * Not all resources types and loader systems can support this event
         * so sometimes it may not be available. If the resource
         * is being loaded on a modern browser, using XHR, and the remote server
         * properly sets Content-Length headers, then this will be available.
         *
         * The callback looks like {@link Resource.OnProgressSignal}.
         *
         * @member {Signal<Resource.OnProgressSignal>}
         */
        this.onProgress = new _miniSignals2.default();

        /**
         * Dispatched once this resource has loaded, if there was an error it will
         * be in the `error` property.
         *
         * The callback looks like {@link Resource.OnCompleteSignal}.
         *
         * @member {Signal<Resource.OnCompleteSignal>}
         */
        this.onComplete = new _miniSignals2.default();

        /**
         * Dispatched after this resource has had all the *after* middleware run on it.
         *
         * The callback looks like {@link Resource.OnCompleteSignal}.
         *
         * @member {Signal<Resource.OnCompleteSignal>}
         */
        this.onAfterMiddleware = new _miniSignals2.default();
    }

    /**
     * When the resource starts to load.
     *
     * @memberof Resource
     * @callback OnStartSignal
     * @param {Resource} resource - The resource that the event happened on.
     */

    /**
     * When the resource reports loading progress.
     *
     * @memberof Resource
     * @callback OnProgressSignal
     * @param {Resource} resource - The resource that the event happened on.
     * @param {number} percentage - The progress of the load in the range [0, 1].
     */

    /**
     * When the resource finishes loading.
     *
     * @memberof Resource
     * @callback OnCompleteSignal
     * @param {Resource} resource - The resource that the event happened on.
     */

    /**
     * @memberof Resource
     * @typedef {object} IMetadata
     * @property {HTMLImageElement|HTMLAudioElement|HTMLVideoElement} [loadElement=null] - The
     *      element to use for loading, instead of creating one.
     * @property {boolean} [skipSource=false] - Skips adding source(s) to the load element. This
     *      is useful if you want to pass in a `loadElement` that you already added load sources to.
     * @property {string|string[]} [mimeType] - The mime type to use for the source element
     *      of a video/audio elment. If the urls are an array, you can pass this as an array as well
     *      where each index is the mime type to use for the corresponding url index.
     */

    /**
     * Stores whether or not this url is a data url.
     *
     * @readonly
     * @member {boolean}
     */


    /**
     * Marks the resource as complete.
     *
     */
    Resource.prototype.complete = function complete() {
        this._clearEvents();
        this._finish();
    };

    /**
     * Aborts the loading of this resource, with an optional message.
     *
     * @param {string} message - The message to use for the error
     */


    Resource.prototype.abort = function abort(message) {
        // abort can be called multiple times, ignore subsequent calls.
        if (this.error) {
            return;
        }

        // store error
        this.error = new Error(message);

        // clear events before calling aborts
        this._clearEvents();

        // abort the actual loading
        if (this.xhr) {
            this.xhr.abort();
        } else if (this.xdr) {
            this.xdr.abort();
        } else if (this.data) {
            // single source
            if (this.data.src) {
                this.data.src = Resource.EMPTY_GIF;
            }
            // multi-source
            else {
                    while (this.data.firstChild) {
                        this.data.removeChild(this.data.firstChild);
                    }
                }
        }

        // done now.
        this._finish();
    };

    /**
     * Kicks off loading of this resource. This method is asynchronous.
     *
     * @param {Resource.OnCompleteSignal} [cb] - Optional callback to call once the resource is loaded.
     */


    Resource.prototype.load = function load(cb) {
        var _this = this;

        if (this.isLoading) {
            return;
        }

        if (this.isComplete) {
            if (cb) {
                setTimeout(function () {
                    return cb(_this);
                }, 1);
            }

            return;
        } else if (cb) {
            this.onComplete.once(cb);
        }

        this._setFlag(Resource.STATUS_FLAGS.LOADING, true);

        this.onStart.dispatch(this);

        // if unset, determine the value
        if (this.crossOrigin === false || typeof this.crossOrigin !== 'string') {
            this.crossOrigin = this._determineCrossOrigin(this.url);
        }

        switch (this.loadType) {
            case Resource.LOAD_TYPE.IMAGE:
                this.type = Resource.TYPE.IMAGE;
                this._loadElement('image');
                break;

            case Resource.LOAD_TYPE.AUDIO:
                this.type = Resource.TYPE.AUDIO;
                this._loadSourceElement('audio');
                break;

            case Resource.LOAD_TYPE.VIDEO:
                this.type = Resource.TYPE.VIDEO;
                this._loadSourceElement('video');
                break;

            case Resource.LOAD_TYPE.XHR:
            /* falls through */
            default:
                if (useXdr && this.crossOrigin) {
                    this._loadXdr();
                } else {
                    this._loadXhr();
                }
                break;
        }
    };

    /**
     * Checks if the flag is set.
     *
     * @private
     * @param {number} flag - The flag to check.
     * @return {boolean} True if the flag is set.
     */


    Resource.prototype._hasFlag = function _hasFlag(flag) {
        return (this._flags & flag) !== 0;
    };

    /**
     * (Un)Sets the flag.
     *
     * @private
     * @param {number} flag - The flag to (un)set.
     * @param {boolean} value - Whether to set or (un)set the flag.
     */


    Resource.prototype._setFlag = function _setFlag(flag, value) {
        this._flags = value ? this._flags | flag : this._flags & ~flag;
    };

    /**
     * Clears all the events from the underlying loading source.
     *
     * @private
     */


    Resource.prototype._clearEvents = function _clearEvents() {
        clearTimeout(this._elementTimer);

        if (this.data && this.data.removeEventListener) {
            this.data.removeEventListener('error', this._boundOnError, false);
            this.data.removeEventListener('load', this._boundComplete, false);
            this.data.removeEventListener('progress', this._boundOnProgress, false);
            this.data.removeEventListener('canplaythrough', this._boundComplete, false);
        }

        if (this.xhr) {
            if (this.xhr.removeEventListener) {
                this.xhr.removeEventListener('error', this._boundXhrOnError, false);
                this.xhr.removeEventListener('timeout', this._boundXhrOnTimeout, false);
                this.xhr.removeEventListener('abort', this._boundXhrOnAbort, false);
                this.xhr.removeEventListener('progress', this._boundOnProgress, false);
                this.xhr.removeEventListener('load', this._boundXhrOnLoad, false);
            } else {
                this.xhr.onerror = null;
                this.xhr.ontimeout = null;
                this.xhr.onprogress = null;
                this.xhr.onload = null;
            }
        }
    };

    /**
     * Finalizes the load.
     *
     * @private
     */


    Resource.prototype._finish = function _finish() {
        if (this.isComplete) {
            throw new Error('Complete called again for an already completed resource.');
        }

        this._setFlag(Resource.STATUS_FLAGS.COMPLETE, true);
        this._setFlag(Resource.STATUS_FLAGS.LOADING, false);

        this.onComplete.dispatch(this);
    };

    /**
     * Loads this resources using an element that has a single source,
     * like an HTMLImageElement.
     *
     * @private
     * @param {string} type - The type of element to use.
     */


    Resource.prototype._loadElement = function _loadElement(type) {
        if (this.metadata.loadElement) {
            this.data = this.metadata.loadElement;
        } else if (type === 'image' && typeof window.Image !== 'undefined') {
            this.data = new Image();
        } else {
            this.data = document.createElement(type);
        }

        if (this.crossOrigin) {
            this.data.crossOrigin = this.crossOrigin;
        }

        if (!this.metadata.skipSource) {
            this.data.src = this.url;
        }

        this.data.addEventListener('error', this._boundOnError, false);
        this.data.addEventListener('load', this._boundComplete, false);
        this.data.addEventListener('progress', this._boundOnProgress, false);

        if (this.timeout) {
            this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout);
        }
    };

    /**
     * Loads this resources using an element that has multiple sources,
     * like an HTMLAudioElement or HTMLVideoElement.
     *
     * @private
     * @param {string} type - The type of element to use.
     */


    Resource.prototype._loadSourceElement = function _loadSourceElement(type) {
        if (this.metadata.loadElement) {
            this.data = this.metadata.loadElement;
        } else if (type === 'audio' && typeof window.Audio !== 'undefined') {
            this.data = new Audio();
        } else {
            this.data = document.createElement(type);
        }

        if (this.data === null) {
            this.abort('Unsupported element: ' + type);

            return;
        }

        if (this.crossOrigin) {
            this.data.crossOrigin = this.crossOrigin;
        }

        if (!this.metadata.skipSource) {
            // support for CocoonJS Canvas+ runtime, lacks document.createElement('source')
            if (navigator.isCocoonJS) {
                this.data.src = Array.isArray(this.url) ? this.url[0] : this.url;
            } else if (Array.isArray(this.url)) {
                var mimeTypes = this.metadata.mimeType;

                for (var i = 0; i < this.url.length; ++i) {
                    this.data.appendChild(this._createSource(type, this.url[i], Array.isArray(mimeTypes) ? mimeTypes[i] : mimeTypes));
                }
            } else {
                var _mimeTypes = this.metadata.mimeType;

                this.data.appendChild(this._createSource(type, this.url, Array.isArray(_mimeTypes) ? _mimeTypes[0] : _mimeTypes));
            }
        }

        this.data.addEventListener('error', this._boundOnError, false);
        this.data.addEventListener('load', this._boundComplete, false);
        this.data.addEventListener('progress', this._boundOnProgress, false);
        this.data.addEventListener('canplaythrough', this._boundComplete, false);

        this.data.load();

        if (this.timeout) {
            this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout);
        }
    };

    /**
     * Loads this resources using an XMLHttpRequest.
     *
     * @private
     */


    Resource.prototype._loadXhr = function _loadXhr() {
        // if unset, determine the value
        if (typeof this.xhrType !== 'string') {
            this.xhrType = this._determineXhrType();
        }

        var xhr = this.xhr = new XMLHttpRequest();

        // set the request type and url
        xhr.open('GET', this.url, true);

        xhr.timeout = this.timeout;

        // load json as text and parse it ourselves. We do this because some browsers
        // *cough* safari *cough* can't deal with it.
        if (this.xhrType === Resource.XHR_RESPONSE_TYPE.JSON || this.xhrType === Resource.XHR_RESPONSE_TYPE.DOCUMENT) {
            xhr.responseType = Resource.XHR_RESPONSE_TYPE.TEXT;
        } else {
            xhr.responseType = this.xhrType;
        }

        xhr.addEventListener('error', this._boundXhrOnError, false);
        xhr.addEventListener('timeout', this._boundXhrOnTimeout, false);
        xhr.addEventListener('abort', this._boundXhrOnAbort, false);
        xhr.addEventListener('progress', this._boundOnProgress, false);
        xhr.addEventListener('load', this._boundXhrOnLoad, false);

        xhr.send();
    };

    /**
     * Loads this resources using an XDomainRequest. This is here because we need to support IE9 (gross).
     *
     * @private
     */


    Resource.prototype._loadXdr = function _loadXdr() {
        // if unset, determine the value
        if (typeof this.xhrType !== 'string') {
            this.xhrType = this._determineXhrType();
        }

        var xdr = this.xhr = new XDomainRequest(); // eslint-disable-line no-undef

        // XDomainRequest has a few quirks. Occasionally it will abort requests
        // A way to avoid this is to make sure ALL callbacks are set even if not used
        // More info here: http://stackoverflow.com/questions/15786966/xdomainrequest-aborts-post-on-ie-9
        xdr.timeout = this.timeout || 5000; // XDR needs a timeout value or it breaks in IE9

        xdr.onerror = this._boundXhrOnError;
        xdr.ontimeout = this._boundXhrOnTimeout;
        xdr.onprogress = this._boundOnProgress;
        xdr.onload = this._boundXhrOnLoad;

        xdr.open('GET', this.url, true);

        // Note: The xdr.send() call is wrapped in a timeout to prevent an
        // issue with the interface where some requests are lost if multiple
        // XDomainRequests are being sent at the same time.
        // Some info here: https://github.com/photonstorm/phaser/issues/1248
        setTimeout(function () {
            return xdr.send();
        }, 1);
    };

    /**
     * Creates a source used in loading via an element.
     *
     * @private
     * @param {string} type - The element type (video or audio).
     * @param {string} url - The source URL to load from.
     * @param {string} [mime] - The mime type of the video
     * @return {HTMLSourceElement} The source element.
     */


    Resource.prototype._createSource = function _createSource(type, url, mime) {
        if (!mime) {
            mime = type + '/' + this._getExtension(url);
        }

        var source = document.createElement('source');

        source.src = url;
        source.type = mime;

        return source;
    };

    /**
     * Called if a load errors out.
     *
     * @param {Event} event - The error event from the element that emits it.
     * @private
     */


    Resource.prototype._onError = function _onError(event) {
        this.abort('Failed to load element using: ' + event.target.nodeName);
    };

    /**
     * Called if a load progress event fires for an element or xhr/xdr.
     *
     * @private
     * @param {XMLHttpRequestProgressEvent|Event} event - Progress event.
     */


    Resource.prototype._onProgress = function _onProgress(event) {
        if (event && event.lengthComputable) {
            this.onProgress.dispatch(this, event.loaded / event.total);
        }
    };

    /**
     * Called if a timeout event fires for an element.
     *
     * @private
     */


    Resource.prototype._onTimeout = function _onTimeout() {
        this.abort('Load timed out.');
    };

    /**
     * Called if an error event fires for xhr/xdr.
     *
     * @private
     */


    Resource.prototype._xhrOnError = function _xhrOnError() {
        var xhr = this.xhr;

        this.abort(reqType(xhr) + ' Request failed. Status: ' + xhr.status + ', text: "' + xhr.statusText + '"');
    };

    /**
     * Called if an error event fires for xhr/xdr.
     *
     * @private
     */


    Resource.prototype._xhrOnTimeout = function _xhrOnTimeout() {
        var xhr = this.xhr;

        this.abort(reqType(xhr) + ' Request timed out.');
    };

    /**
     * Called if an abort event fires for xhr/xdr.
     *
     * @private
     */


    Resource.prototype._xhrOnAbort = function _xhrOnAbort() {
        var xhr = this.xhr;

        this.abort(reqType(xhr) + ' Request was aborted by the user.');
    };

    /**
     * Called when data successfully loads from an xhr/xdr request.
     *
     * @private
     * @param {XMLHttpRequestLoadEvent|Event} event - Load event
     */


    Resource.prototype._xhrOnLoad = function _xhrOnLoad() {
        var xhr = this.xhr;
        var text = '';
        var status = typeof xhr.status === 'undefined' ? STATUS_OK : xhr.status; // XDR has no `.status`, assume 200.

        // responseText is accessible only if responseType is '' or 'text' and on older browsers
        if (xhr.responseType === '' || xhr.responseType === 'text' || typeof xhr.responseType === 'undefined') {
            text = xhr.responseText;
        }

        // status can be 0 when using the `file://` protocol so we also check if a response is set.
        // If it has a response, we assume 200; otherwise a 0 status code with no contents is an aborted request.
        if (status === STATUS_NONE && (text.length > 0 || xhr.responseType === Resource.XHR_RESPONSE_TYPE.BUFFER)) {
            status = STATUS_OK;
        }
        // handle IE9 bug: http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request
        else if (status === STATUS_IE_BUG_EMPTY) {
                status = STATUS_EMPTY;
            }

        var statusType = status / 100 | 0;

        if (statusType === STATUS_TYPE_OK) {
            // if text, just return it
            if (this.xhrType === Resource.XHR_RESPONSE_TYPE.TEXT) {
                this.data = text;
                this.type = Resource.TYPE.TEXT;
            }
            // if json, parse into json object
            else if (this.xhrType === Resource.XHR_RESPONSE_TYPE.JSON) {
                    try {
                        this.data = JSON.parse(text);
                        this.type = Resource.TYPE.JSON;
                    } catch (e) {
                        this.abort('Error trying to parse loaded json: ' + e);

                        return;
                    }
                }
                // if xml, parse into an xml document or div element
                else if (this.xhrType === Resource.XHR_RESPONSE_TYPE.DOCUMENT) {
                        try {
                            if (window.DOMParser) {
                                var domparser = new DOMParser();

                                this.data = domparser.parseFromString(text, 'text/xml');
                            } else {
                                var div = document.createElement('div');

                                div.innerHTML = text;

                                this.data = div;
                            }

                            this.type = Resource.TYPE.XML;
                        } catch (e) {
                            this.abort('Error trying to parse loaded xml: ' + e);

                            return;
                        }
                    }
                    // other types just return the response
                    else {
                            this.data = xhr.response || text;
                        }
        } else {
            this.abort('[' + xhr.status + '] ' + xhr.statusText + ': ' + xhr.responseURL);

            return;
        }

        this.complete();
    };

    /**
     * Sets the `crossOrigin` property for this resource based on if the url
     * for this resource is cross-origin. If crossOrigin was manually set, this
     * function does nothing.
     *
     * @private
     * @param {string} url - The url to test.
     * @param {object} [loc=window.location] - The location object to test against.
     * @return {string} The crossOrigin value to use (or empty string for none).
     */


    Resource.prototype._determineCrossOrigin = function _determineCrossOrigin(url, loc) {
        // data: and javascript: urls are considered same-origin
        if (url.indexOf('data:') === 0) {
            return '';
        }

        // A sandboxed iframe without the 'allow-same-origin' attribute will have a special
        // origin designed not to match window.location.origin, and will always require
        // crossOrigin requests regardless of whether the location matches.
        if (window.origin !== window.location.origin) {
            return 'anonymous';
        }

        // default is window.location
        loc = loc || window.location;

        if (!tempAnchor) {
            tempAnchor = document.createElement('a');
        }

        // let the browser determine the full href for the url of this resource and then
        // parse with the node url lib, we can't use the properties of the anchor element
        // because they don't work in IE9 :(
        tempAnchor.href = url;
        url = (0, _parseUri2.default)(tempAnchor.href, { strictMode: true });

        var samePort = !url.port && loc.port === '' || url.port === loc.port;
        var protocol = url.protocol ? url.protocol + ':' : '';

        // if cross origin
        if (url.host !== loc.hostname || !samePort || protocol !== loc.protocol) {
            return 'anonymous';
        }

        return '';
    };

    /**
     * Determines the responseType of an XHR request based on the extension of the
     * resource being loaded.
     *
     * @private
     * @return {Resource.XHR_RESPONSE_TYPE} The responseType to use.
     */


    Resource.prototype._determineXhrType = function _determineXhrType() {
        return Resource._xhrTypeMap[this.extension] || Resource.XHR_RESPONSE_TYPE.TEXT;
    };

    /**
     * Determines the loadType of a resource based on the extension of the
     * resource being loaded.
     *
     * @private
     * @return {Resource.LOAD_TYPE} The loadType to use.
     */


    Resource.prototype._determineLoadType = function _determineLoadType() {
        return Resource._loadTypeMap[this.extension] || Resource.LOAD_TYPE.XHR;
    };

    /**
     * Extracts the extension (sans '.') of the file being loaded by the resource.
     *
     * @private
     * @return {string} The extension.
     */


    Resource.prototype._getExtension = function _getExtension() {
        var url = this.url;
        var ext = '';

        if (this.isDataUrl) {
            var slashIndex = url.indexOf('/');

            ext = url.substring(slashIndex + 1, url.indexOf(';', slashIndex));
        } else {
            var queryStart = url.indexOf('?');
            var hashStart = url.indexOf('#');
            var index = Math.min(queryStart > -1 ? queryStart : url.length, hashStart > -1 ? hashStart : url.length);

            url = url.substring(0, index);
            ext = url.substring(url.lastIndexOf('.') + 1);
        }

        return ext.toLowerCase();
    };

    /**
     * Determines the mime type of an XHR request based on the responseType of
     * resource being loaded.
     *
     * @private
     * @param {Resource.XHR_RESPONSE_TYPE} type - The type to get a mime type for.
     * @return {string} The mime type to use.
     */


    Resource.prototype._getMimeFromXhrType = function _getMimeFromXhrType(type) {
        switch (type) {
            case Resource.XHR_RESPONSE_TYPE.BUFFER:
                return 'application/octet-binary';

            case Resource.XHR_RESPONSE_TYPE.BLOB:
                return 'application/blob';

            case Resource.XHR_RESPONSE_TYPE.DOCUMENT:
                return 'application/xml';

            case Resource.XHR_RESPONSE_TYPE.JSON:
                return 'application/json';

            case Resource.XHR_RESPONSE_TYPE.DEFAULT:
            case Resource.XHR_RESPONSE_TYPE.TEXT:
            /* falls through */
            default:
                return 'text/plain';
        }
    };

    _createClass(Resource, [{
        key: 'isDataUrl',
        get: function get() {
            return this._hasFlag(Resource.STATUS_FLAGS.DATA_URL);
        }

        /**
         * Describes if this resource has finished loading. Is true when the resource has completely
         * loaded.
         *
         * @readonly
         * @member {boolean}
         */

    }, {
        key: 'isComplete',
        get: function get() {
            return this._hasFlag(Resource.STATUS_FLAGS.COMPLETE);
        }

        /**
         * Describes if this resource is currently loading. Is true when the resource starts loading,
         * and is false again when complete.
         *
         * @readonly
         * @member {boolean}
         */

    }, {
        key: 'isLoading',
        get: function get() {
            return this._hasFlag(Resource.STATUS_FLAGS.LOADING);
        }
    }]);

    return Resource;
}();

/**
 * The types of resources a resource could represent.
 *
 * @static
 * @readonly
 * @enum {number}
 */


Resource.STATUS_FLAGS = {
    NONE: 0,
    DATA_URL: 1 << 0,
    COMPLETE: 1 << 1,
    LOADING: 1 << 2
};

/**
 * The types of resources a resource could represent.
 *
 * @static
 * @readonly
 * @enum {number}
 */
Resource.TYPE = {
    UNKNOWN: 0,
    JSON: 1,
    XML: 2,
    IMAGE: 3,
    AUDIO: 4,
    VIDEO: 5,
    TEXT: 6
};

/**
 * The types of loading a resource can use.
 *
 * @static
 * @readonly
 * @enum {number}
 */
Resource.LOAD_TYPE = {
    /** Uses XMLHttpRequest to load the resource. */
    XHR: 1,
    /** Uses an `Image` object to load the resource. */
    IMAGE: 2,
    /** Uses an `Audio` object to load the resource. */
    AUDIO: 3,
    /** Uses a `Video` object to load the resource. */
    VIDEO: 4
};

/**
 * The XHR ready states, used internally.
 *
 * @static
 * @readonly
 * @enum {string}
 */
Resource.XHR_RESPONSE_TYPE = {
    /** string */
    DEFAULT: 'text',
    /** ArrayBuffer */
    BUFFER: 'arraybuffer',
    /** Blob */
    BLOB: 'blob',
    /** Document */
    DOCUMENT: 'document',
    /** Object */
    JSON: 'json',
    /** String */
    TEXT: 'text'
};

Resource._loadTypeMap = {
    // images
    gif: Resource.LOAD_TYPE.IMAGE,
    png: Resource.LOAD_TYPE.IMAGE,
    bmp: Resource.LOAD_TYPE.IMAGE,
    jpg: Resource.LOAD_TYPE.IMAGE,
    jpeg: Resource.LOAD_TYPE.IMAGE,
    tif: Resource.LOAD_TYPE.IMAGE,
    tiff: Resource.LOAD_TYPE.IMAGE,
    webp: Resource.LOAD_TYPE.IMAGE,
    tga: Resource.LOAD_TYPE.IMAGE,
    svg: Resource.LOAD_TYPE.IMAGE,
    'svg+xml': Resource.LOAD_TYPE.IMAGE, // for SVG data urls

    // audio
    mp3: Resource.LOAD_TYPE.AUDIO,
    ogg: Resource.LOAD_TYPE.AUDIO,
    wav: Resource.LOAD_TYPE.AUDIO,

    // videos
    mp4: Resource.LOAD_TYPE.VIDEO,
    webm: Resource.LOAD_TYPE.VIDEO
};

Resource._xhrTypeMap = {
    // xml
    xhtml: Resource.XHR_RESPONSE_TYPE.DOCUMENT,
    html: Resource.XHR_RESPONSE_TYPE.DOCUMENT,
    htm: Resource.XHR_RESPONSE_TYPE.DOCUMENT,
    xml: Resource.XHR_RESPONSE_TYPE.DOCUMENT,
    tmx: Resource.XHR_RESPONSE_TYPE.DOCUMENT,
    svg: Resource.XHR_RESPONSE_TYPE.DOCUMENT,

    // This was added to handle Tiled Tileset XML, but .tsx is also a TypeScript React Component.
    // Since it is way less likely for people to be loading TypeScript files instead of Tiled files,
    // this should probably be fine.
    tsx: Resource.XHR_RESPONSE_TYPE.DOCUMENT,

    // images
    gif: Resource.XHR_RESPONSE_TYPE.BLOB,
    png: Resource.XHR_RESPONSE_TYPE.BLOB,
    bmp: Resource.XHR_RESPONSE_TYPE.BLOB,
    jpg: Resource.XHR_RESPONSE_TYPE.BLOB,
    jpeg: Resource.XHR_RESPONSE_TYPE.BLOB,
    tif: Resource.XHR_RESPONSE_TYPE.BLOB,
    tiff: Resource.XHR_RESPONSE_TYPE.BLOB,
    webp: Resource.XHR_RESPONSE_TYPE.BLOB,
    tga: Resource.XHR_RESPONSE_TYPE.BLOB,

    // json
    json: Resource.XHR_RESPONSE_TYPE.JSON,

    // text
    text: Resource.XHR_RESPONSE_TYPE.TEXT,
    txt: Resource.XHR_RESPONSE_TYPE.TEXT,

    // fonts
    ttf: Resource.XHR_RESPONSE_TYPE.BUFFER,
    otf: Resource.XHR_RESPONSE_TYPE.BUFFER
};

// We can't set the `src` attribute to empty string, so on abort we set it to this 1px transparent gif
Resource.EMPTY_GIF = 'data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==';

/**
 * Quick helper to set a value on one of the extension maps. Ensures there is no
 * dot at the start of the extension.
 *
 * @ignore
 * @param {object} map - The map to set on.
 * @param {string} extname - The extension (or key) to set.
 * @param {number} val - The value to set.
 */
function setExtMap(map, extname, val) {
    if (extname && extname.indexOf('.') === 0) {
        extname = extname.substring(1);
    }

    if (!extname) {
        return;
    }

    map[extname] = val;
}

/**
 * Quick helper to get string xhr type.
 *
 * @ignore
 * @param {XMLHttpRequest|XDomainRequest} xhr - The request to check.
 * @return {string} The type.
 */
function reqType(xhr) {
    return xhr.toString().replace('object ', '');
}

// Backwards compat
if (typeof module !== 'undefined') {
    module.exports.default = Resource; // eslint-disable-line no-undef
}

},{"mini-signals":27,"parse-uri":29}],200:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.eachSeries = eachSeries;
exports.queue = queue;
/**
 * Smaller version of the async library constructs.
 *
 * @namespace async
 */

/**
 * Noop function
 *
 * @ignore
 * @function
 * @memberof async
 */
function _noop() {} /* empty */

/**
 * Iterates an array in series.
 *
 * @memberof async
 * @param {Array.<*>} array - Array to iterate.
 * @param {function} iterator - Function to call for each element.
 * @param {function} callback - Function to call when done, or on error.
 * @param {boolean} [deferNext=false] - Break synchronous each loop by calling next with a setTimeout of 1.
 */
function eachSeries(array, iterator, callback, deferNext) {
    var i = 0;
    var len = array.length;

    (function next(err) {
        if (err || i === len) {
            if (callback) {
                callback(err);
            }

            return;
        }

        if (deferNext) {
            setTimeout(function () {
                iterator(array[i++], next);
            }, 1);
        } else {
            iterator(array[i++], next);
        }
    })();
}

/**
 * Ensures a function is only called once.
 *
 * @ignore
 * @memberof async
 * @param {function} fn - The function to wrap.
 * @return {function} The wrapping function.
 */
function onlyOnce(fn) {
    return function onceWrapper() {
        if (fn === null) {
            throw new Error('Callback was already called.');
        }

        var callFn = fn;

        fn = null;
        callFn.apply(this, arguments);
    };
}

/**
 * Async queue implementation,
 *
 * @memberof async
 * @param {function} worker - The worker function to call for each task.
 * @param {number} concurrency - How many workers to run in parrallel.
 * @return {*} The async queue object.
 */
function queue(worker, concurrency) {
    if (concurrency == null) {
        // eslint-disable-line no-eq-null,eqeqeq
        concurrency = 1;
    } else if (concurrency === 0) {
        throw new Error('Concurrency must not be zero');
    }

    var workers = 0;
    var q = {
        _tasks: [],
        concurrency: concurrency,
        saturated: _noop,
        unsaturated: _noop,
        buffer: concurrency / 4,
        empty: _noop,
        drain: _noop,
        error: _noop,
        started: false,
        paused: false,
        push: function push(data, callback) {
            _insert(data, false, callback);
        },
        kill: function kill() {
            workers = 0;
            q.drain = _noop;
            q.started = false;
            q._tasks = [];
        },
        unshift: function unshift(data, callback) {
            _insert(data, true, callback);
        },
        process: function process() {
            while (!q.paused && workers < q.concurrency && q._tasks.length) {
                var task = q._tasks.shift();

                if (q._tasks.length === 0) {
                    q.empty();
                }

                workers += 1;

                if (workers === q.concurrency) {
                    q.saturated();
                }

                worker(task.data, onlyOnce(_next(task)));
            }
        },
        length: function length() {
            return q._tasks.length;
        },
        running: function running() {
            return workers;
        },
        idle: function idle() {
            return q._tasks.length + workers === 0;
        },
        pause: function pause() {
            if (q.paused === true) {
                return;
            }

            q.paused = true;
        },
        resume: function resume() {
            if (q.paused === false) {
                return;
            }

            q.paused = false;

            // Need to call q.process once per concurrent
            // worker to preserve full concurrency after pause
            for (var w = 1; w <= q.concurrency; w++) {
                q.process();
            }
        }
    };

    function _insert(data, insertAtFront, callback) {
        if (callback != null && typeof callback !== 'function') {
            // eslint-disable-line no-eq-null,eqeqeq
            throw new Error('task callback must be a function');
        }

        q.started = true;

        if (data == null && q.idle()) {
            // eslint-disable-line no-eq-null,eqeqeq
            // call drain immediately if there are no tasks
            setTimeout(function () {
                return q.drain();
            }, 1);

            return;
        }

        var item = {
            data: data,
            callback: typeof callback === 'function' ? callback : _noop
        };

        if (insertAtFront) {
            q._tasks.unshift(item);
        } else {
            q._tasks.push(item);
        }

        setTimeout(function () {
            return q.process();
        }, 1);
    }

    function _next(task) {
        return function next() {
            workers -= 1;

            task.callback.apply(task, arguments);

            if (arguments[0] != null) {
                // eslint-disable-line no-eq-null,eqeqeq
                q.error(arguments[0], task.data);
            }

            if (workers <= q.concurrency - q.buffer) {
                q.unsaturated();
            }

            if (q.idle()) {
                q.drain();
            }

            q.process();
        };
    }

    return q;
}

},{}],201:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.encodeBinary = encodeBinary;
var _keyStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

/**
 * Encodes binary into base64.
 *
 * @param {string} input The input data to encode.
 * @returns {string} The encoded base64 string
 */
function encodeBinary(input) {
    var output = '';
    var inx = 0;

    while (inx < input.length) {
        // Fill byte buffer array
        var bytebuffer = [0, 0, 0];
        var encodedCharIndexes = [0, 0, 0, 0];

        for (var jnx = 0; jnx < bytebuffer.length; ++jnx) {
            if (inx < input.length) {
                // throw away high-order byte, as documented at:
                // https://developer.mozilla.org/En/Using_XMLHttpRequest#Handling_binary_data
                bytebuffer[jnx] = input.charCodeAt(inx++) & 0xff;
            } else {
                bytebuffer[jnx] = 0;
            }
        }

        // Get each encoded character, 6 bits at a time
        // index 1: first 6 bits
        encodedCharIndexes[0] = bytebuffer[0] >> 2;

        // index 2: second 6 bits (2 least significant bits from input byte 1 + 4 most significant bits from byte 2)
        encodedCharIndexes[1] = (bytebuffer[0] & 0x3) << 4 | bytebuffer[1] >> 4;

        // index 3: third 6 bits (4 least significant bits from input byte 2 + 2 most significant bits from byte 3)
        encodedCharIndexes[2] = (bytebuffer[1] & 0x0f) << 2 | bytebuffer[2] >> 6;

        // index 3: forth 6 bits (6 least significant bits from input byte 3)
        encodedCharIndexes[3] = bytebuffer[2] & 0x3f;

        // Determine whether padding happened, and adjust accordingly
        var paddingBytes = inx - (input.length - 1);

        switch (paddingBytes) {
            case 2:
                // Set last 2 characters to padding char
                encodedCharIndexes[3] = 64;
                encodedCharIndexes[2] = 64;
                break;

            case 1:
                // Set last character to padding char
                encodedCharIndexes[3] = 64;
                break;

            default:
                break; // No padding - proceed
        }

        // Now we will grab each appropriate character out of our keystring
        // based on our index array and append it to the output string
        for (var _jnx = 0; _jnx < encodedCharIndexes.length; ++_jnx) {
            output += _keyStr.charAt(encodedCharIndexes[_jnx]);
        }
    }

    return output;
}

// Backwards compat
if (typeof module !== 'undefined') {
    module.exports.default = encodeBinary; // eslint-disable-line no-undef
}

},{}],202:[function(require,module,exports){
'use strict';

// import Loader from './Loader';
// import Resource from './Resource';
// import * as async from './async';
// import * as b64 from './b64';

/* eslint-disable no-undef */

var Loader = require('./Loader').Loader;
var Resource = require('./Resource').Resource;
var async = require('./async');
var b64 = require('./b64');

/**
 *
 * @static
 * @memberof Loader
 * @member {Class<Resource>}
 */
Loader.Resource = Resource;

/**
 *
 * @static
 * @memberof Loader
 * @member {Class<async>}
 */
Loader.async = async;

/**
 *
 * @static
 * @memberof Loader
 * @member {Class<encodeBinary>}
 */
Loader.encodeBinary = b64;

/**
 *
 * @deprecated
 * @see Loader.encodeBinary
 *
 * @static
 * @memberof Loader
 * @member {Class<encodeBinary>}
 */
Loader.base64 = b64;

// export manually, and also as default
module.exports = Loader;

// default & named export
module.exports.Loader = Loader;
module.exports.default = Loader;

},{"./Loader":198,"./Resource":199,"./async":200,"./b64":201}],203:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.blobMiddlewareFactory = blobMiddlewareFactory;

var _Resource = require('../../Resource');

var _b = require('../../b64');

var Url = window.URL || window.webkitURL;

// a middleware for transforming XHR loaded Blobs into more useful objects
function blobMiddlewareFactory() {
    return function blobMiddleware(resource, next) {
        if (!resource.data) {
            next();

            return;
        }

        // if this was an XHR load of a blob
        if (resource.xhr && resource.xhrType === _Resource.Resource.XHR_RESPONSE_TYPE.BLOB) {
            // if there is no blob support we probably got a binary string back
            if (!window.Blob || typeof resource.data === 'string') {
                var type = resource.xhr.getResponseHeader('content-type');

                // this is an image, convert the binary string into a data url
                if (type && type.indexOf('image') === 0) {
                    resource.data = new Image();
                    resource.data.src = 'data:' + type + ';base64,' + (0, _b.encodeBinary)(resource.xhr.responseText);

                    resource.type = _Resource.Resource.TYPE.IMAGE;

                    // wait until the image loads and then callback
                    resource.data.onload = function () {
                        resource.data.onload = null;

                        next();
                    };

                    // next will be called on load
                    return;
                }
            }
            // if content type says this is an image, then we should transform the blob into an Image object
            else if (resource.data.type.indexOf('image') === 0) {
                    var src = Url.createObjectURL(resource.data);

                    resource.blob = resource.data;
                    resource.data = new Image();
                    resource.data.src = src;

                    resource.type = _Resource.Resource.TYPE.IMAGE;

                    // cleanup the no longer used blob after the image loads
                    // TODO: Is this correct? Will the image be invalid after revoking?
                    resource.data.onload = function () {
                        Url.revokeObjectURL(src);
                        resource.data.onload = null;

                        next();
                    };

                    // next will be called on load.
                    return;
                }
        }

        next();
    };
}

},{"../../Resource":199,"../../b64":201}],204:[function(require,module,exports){
'use strict';

var typeID = "UIDOFTYPEOFTYPESJS";
var crTypeID = "UIDOFCONSTRUCTOROFTYPEOFTYPESJS";

var isTest = true;

var Types = {
	newType: function (name, CrType, outJSON){
		if(typeof name != "string")
			throw new Error("name isn't String!")

		if(typeof CrType != "function")
			throw new Error("CrType isn't Function!")

		if(typeof outJSON != "function")
			throw new Error("outJSON isn't Function!")

		if(this[name]){
			console.warn("Type " + name + "already created!");
			return;
		}

		var newType = {
			name: name,
			Def: newCreator(CrType),
			outJSON: crOutJSON(outJSON),
		};

		newType[crTypeID] = crTypeID;

		this[name] = newType;

		return this[name];

	},
	isType: isType,
	isCrType: isCrType,
	get isTest(){return isTest},
	set isTest(val){isTest = !!val},
	argError: function argError(wrong_arg, mess){
		if(mess === undefined) mess = '';
		var ER = new TypeError('Argument type is wrong! Arguments(' + forArg(wrong_arg) + ');' + mess);
		ER.wrong_arg = wrong_arg;

		if (Error.captureStackTrace) {
			Error.captureStackTrace(ER, argError);
		}

		return ER;

		function forArg(args){
			var str_args = '';
			for(var i = 0; i < args.length; i++){
				str_args += typeof(args[i]) + ': ' + args[i] + '; ';
			}
			return str_args;
		}
	}
};

function newCreator(CrType){	
	return function(){

		var type = CrType.apply(CrType, arguments);
		mixType(type);
		
		return type;
	};
}



function crOutJSON(outJSON){
	return function(json){

		if(typeof json == "string"){
			var type = outJSON(JSON.parse(json));
			mixType(type);
		}
		else{
			var type = outJSON(json);
			mixType(type);
		}
		return type;
	}
}

function mixType(type){
	type[typeID] = typeID;
	type.toJSON = crToJSON(type.preJSON);
	type.test = wrapTest(type.test);
}

function wrapTest(test){
	return function(val){
		if(isTest)
			return test(val);
		return false;
	}
}

function crToJSON(preJSON){
	return function(tabs){
		var preJson = Object.assign({}, preJSON());
		delete preJson.toJSON;
		return JSON.stringify(preJson, "", tabs);
	}
}

function isType(type) {
	return typeof type == "object" && type[typeID] == typeID 
			&& typeof type.rand == "function" 
			&& typeof type.test == "function"
			&& typeof type.preJSON == "function"
			&& typeof type.toJSON == "function";
}

function isCrType(crType){
	return typeof crType == "object" && crType[crTypeID] == crTypeID
			&& typeof crType.Def == "function" 
			&& typeof crType.outJSON == "function";
}

module.exports = Types;
},{}],205:[function(require,module,exports){
const Types = require('./core.js');

require('./types/template/type.js')(Types);
require('./types/const/type.js')(Types);
require('./types/bool/type.js')(Types);
require('./types/number/type.js')(Types);
require('./types/index/type.js')(Types);
require('./types/key/type.js')(Types);
require('./types/object/type.js')(Types);
require('./types/array/type.js')(Types);
require('./types/any/type.js')(Types);
require('./types/string/type.js')(Types);
require('./types/switch/type.js')(Types);

module.exports = Types;
},{"./core.js":204,"./types/any/type.js":206,"./types/array/type.js":207,"./types/bool/type.js":208,"./types/const/type.js":209,"./types/index/type.js":210,"./types/key/type.js":211,"./types/number/type.js":212,"./types/object/type.js":213,"./types/string/type.js":214,"./types/switch/type.js":215,"./types/template/type.js":216}],206:[function(require,module,exports){
'use strict';

const CrIndexType  =  require('../index/type.js');
const CrConstType  =  require('../index/type.js');

const typeName = "Any";

var argError = null;

var Types = null;

function ExtendTypes(Core){
	Types = Core;
	argError = Core.argError;

	if(!Core.Index)
		CrIndexType(Core);

	if(!Core.Const)
		CrConstType(Core);

	Core.newType(typeName, ConstructorType, outJSON);
}

ExtendTypes.typeName = typeName;

function ConstructorType(types){

	if(!Array.isArray(types))
		types = Array.from(arguments);

	if(!Types.isType(types[0]))
		throw argError(arguments, 'Wait args Array[Type(surelly), Type||null||undefined, ... Type||null||undefined]');

	if(types.length > 1)
		var typeIndex = Types.Index.Def(types.length)
	else{
		var typeIndex = Types.Index.Def(2)
		types[1] = Types.Const.Def();
	}

	var type = {
		rand: rand,
		test: test,
		preJSON: preJSON
	}

	function rand(){
		return types[typeIndex.rand()].rand();
	}

	function test(value){
		var result = types.every(typeItem => typeItem.test(value));
		if(result)
			return { value: value, type: preJSON()};
	}

	function preJSON(){
		var type = {};
		type.name = typeName;
		type.struct = types.map(typeItem => typeItem.preJSON());
		return type;
	}

	return type;

}

function outJSON(preType){
	if(typeof preType == "object" && preType.name == typeName)
		return ConstructorType(preType.struct.map(itemOutJSON))
	else
		throw new Error("This isn't type " + typeName + "!");
}

module.exports = ExtendTypes;

function itemOutJSON(preType){
	if(!Types.isCrType(Types[preType.name]))
		throw new Error("Parsing Error! Type with name" + nameType + "is unknowed!");
	return Types[preType.name].outJSON(preType);
}
},{"../index/type.js":210}],207:[function(require,module,exports){
'use strict';

const typeName = "Array";

const CrIndexType  =  require('../index/type.js');

var argError = null;

var Types = null;

function ExtendTypes(Core){
	Types = Core;
	argError = Core.argError;
	if(!Core.Index)
		CrIndexType(Core);

	Core.newType(typeName, ConstructorType, outJSON);
}

ExtendTypes.typeName = typeName;

function ConstructorType(itemType, maxLength, is_empty){

	var maxLengthType = Types.Index.Def(1024*1024);	

	if(!Types.isType(itemType)
		|| maxLengthType.test(maxLength))
		throw argError(arguments, 'Wait args (Type, maxLength<1024*1024 [, isEmptyArray])');

	var lengthType = Types.Index.Def(maxLength + 1);

	var type = {
		rand: rand,
		test: test,
		preJSON: preJSON
	}

	function rand(){
		var length = lengthType.rand();
		var arr = [];

		if(!is_empty)
			arr.push(itemType.rand());

		while(arr.length < length)
			arr.push(itemType.rand());

		return arr;
	}

	function test(arr){
		if((arr.length > maxLength) || (!is_empty && arr.length == 0))
			return { length: arr.length, type: preJSON()};

		var err_arr = arr.map(itemType.test).filter(item => item);

		if(err_arr.length)
			return { wrong_values: err_arr, type: preJSON()};
	}

	function preJSON(){
		var type = {};
		type.name = typeName;
		type.struct = {type: itemType.preJSON(), maxLength: maxLength, is_empty: is_empty};
		return type;
	}

	return type;

}

function outJSON(preType){
	var struct = preType.struct;
	var nameType = struct.type.name;

	if(!Types.isCrType(Types[nameType]))
		throw new Error("Parsing Error! Type with name" + nameType + "is unknowed!");

	var type = Types[nameType].outJSON(struct.type);

	if(typeof preType == "object" && preType.name == typeName)
		return ConstructorType(type, struct.maxLength, struct.is_empty);
	else
		throw new Error("This isn't type " + typeName + "!");
}

module.exports = ExtendTypes;
},{"../index/type.js":210}],208:[function(require,module,exports){
'use strict';

const typeName = "Bool";

function ExtendTypes(Core){
	Core.newType(typeName, ConstructorType, outJSON);
}

ExtendTypes.typeName = typeName;

function ConstructorType(){

	var type = {
		rand: rand,
		test: test,
		preJSON: preJSON
	}

	function rand(){
		return Math.random() > 0.5;
	}

	function test(value){
		if(value !== false && value !== true)
			return { value: value, type: preJSON()};
	}

	function preJSON(){
		var type = {};
		type.name = typeName;
		return type;
	}

	return type;

}

function outJSON(preType){
	if(typeof preType == "object" && preType.name == typeName)
		return ConstructorType()
	else
		throw new Error("This isn't boolean type!");
}

module.exports = ExtendTypes;
},{}],209:[function(require,module,exports){
'use strict';

const typeName = "Const";

var argError = null;

function ExtendTypes(Core){
	argError = Core.argError;
	Core.newType(typeName, ConstructorType, outJSON);
}

ExtendTypes.typeName = typeName;

function ConstructorType(constVal){

	if(typeof constVal !== "string"
		&& typeof constVal !== "number"
		&& typeof constVal !== "boolean"
		&& typeof constVal !== "function"
		&& constVal)
		throw argError(arguments, 'Wait argument is string || number || boolean || null || undefined || function');

	var type = {
		rand: rand,
		test: test,
		preJSON: preJSON
	}

	function rand(){
		return constVal;
	}

	function test(value){
		if(value !== constVal)
			return { value: value, type: preJSON()};
	}

	function preJSON(){
		var type = {};
		type.name = typeName;
		type.struct = constVal;
		return type;
	}

	return type;

}

function outJSON(preType){
	if(typeof preType == "object" && preType.name == typeName)
		return ConstructorType(preType.struct)
	else
		throw new Error("This isn't type " + typeName + "!");
}

module.exports = ExtendTypes;
},{}],210:[function(require,module,exports){
'use strict';

const typeName = "Index";
var argError

function ExtendTypes(Core){
	argError = Core.argError;
	Core.newType(typeName, ConstructorType, outJSON);
}

ExtendTypes.typeName = typeName;

function ConstructorType(max){

	if(typeof max !== 'number' || !isFinite(max)
		||(max <= 0)
		||(max % 1 !== 0))
		throw argError(arguments, 'Wait arguments: max(int>0)');
	

	var type = {
		rand: rand,
		test: test,
		preJSON: preJSON
	}

	function rand(){
		return Math.floor(max * Math.abs(Math.random() - 0.01));
	}

	function test(n){
		if(typeof n !== 'number' || !isFinite(n))
			return { value: n, type: preJSON()};
		

		if(n >= max || n < 0 || n % 1 !== 0)
			return { value: n, type: preJSON()};

		return false;
	}

	function preJSON(){
		var type = {};
		type.name = typeName;
		type.struct = {
			max: max
		};
		return type;
	}

	return type;

}

function outJSON(preType){
	var arg = preType.struct;

	if(typeof preType == "object" && preType.name == typeName)
		return ConstructorType(arg.max);
	else
		throw new Error("This isn't type " + typeName + "!");
}

module.exports = ExtendTypes;
},{}],211:[function(require,module,exports){
'use strict';

const typeName = "Key";

var argError = null;

const CrIndexType  =  require('../index/type.js');

var Types = null;

function ExtendTypes(Core){
	Types = Core;
	argError = Core.argError;
	if(!Core.Index)
		CrIndexType(Core);

	Core.newType(typeName, ConstructorType, outJSON);
}

ExtendTypes.typeName = typeName;

function ConstructorType(){

	var chars = crChars();
	var sizeType = Types.Index.Def(256);
	var indexType = Types.Index.Def(chars.length);
	var regEx =  /^[a-zA-Z0-9_]*$/;

	var type = {
		rand: rand,
		test: test,
		preJSON: preJSON
	}

	function rand(){
		var size = sizeType.rand();

		var str = '';
		while(size){
			var randIndex = indexType.rand()
			var charNum = chars[randIndex];
			str += String.fromCharCode(charNum);
			size--;
		}

		return str;
	}

	function test(str){
		if(typeof(str) !== 'string'
		||str.length > 256
		||!regEx.test(str)){
			return { value: str, type: preJSON()};
		}
	}

	function preJSON(){
		var type = {};
		type.name = typeName;
		return type;
	}

	return type;

}

function outJSON(preType){
	if(typeof preType == "object" && preType.name == typeName)
		return ConstructorType(preType.struct)
	else
		throw new Error("This isn't type " + typeName + "!");
}


function crChars(){
	var arr_chars = rangeInArr(("a").charCodeAt(0), ("z").charCodeAt(0));

	arr_chars = arr_chars.concat(rangeInArr(("A").charCodeAt(0), ("Z").charCodeAt(0)));

	arr_chars = arr_chars.concat(rangeInArr(("0").charCodeAt(0), ("9").charCodeAt(0)));

	arr_chars.push(("_").charCodeAt(0));

	return arr_chars;
}


function rangeInArr(beg, end){
	if(beg > end){
		var tmp = beg;
		beg = end;
		end = tmp;
	}

	var arr = [];
	for(var i = beg; i <= end; i++){
		arr.push(i);
	}

	return arr;
}

module.exports = ExtendTypes;
},{"../index/type.js":210}],212:[function(require,module,exports){
'use strict';

const typeName = "Number";
var argError

function ExtendTypes(Core){
	argError = Core.argError;
	Core.newType(typeName, ConstructorType, outJSON);
}

ExtendTypes.typeName = typeName;

function ConstructorType(max, min, precis){

	if(typeof min !== 'number' || !isFinite(min)
		||typeof max !== 'number' || !isFinite(max)
		||typeof precis !== 'number' || !isFinite(precis)
		||(max <= min)
		||(precis < 0)
		||(precis > 9)
		||(precis % 1 !== 0))
		throw argError(arguments, 'Wait arguments: max(number), > min(number), precis(0<=number<9)');
	

	var type = {
		rand: rand,
		test: test,
		preJSON: preJSON
	}

	function rand(){
		return +(((max - min)*Math.random() +  min).toFixed(precis));
	}

	function test(n){
		if(typeof n !== 'number' || !isFinite(n))
			return new Error(JSON.stringify({ value: n, type: preJSON()}, "", 2));
		

		if((n > max)
		||(n < min)
		|| (n.toFixed(precis) != n && n !== 0) )
			return new Error(JSON.stringify({ value: n, type: preJSON()}, "", 2));

		return false;
	}

	function preJSON(){
		var type = {};
		type.name = typeName;
		type.struct = {
			min: min,
			max: max,
			precis: precis
		};
		return type;
	}

	return type;

}

function outJSON(preType){
	var arg = preType.struct;

	if(typeof preType == "object" && preType.name == typeName)
		return ConstructorType(arg.max, arg.min, arg.precis);
	else
		throw new Error("This isn't type " + typeName + "!");
}

module.exports = ExtendTypes;
},{}],213:[function(require,module,exports){
  

const typeName = "Object";

var argError = null;

var Types = null;

function ExtendTypes(Core){
	Types = Core;
	argError = Core.argError;
	if(!Core.Const)
		CrIndexType(Const);

	Core.newType(typeName, ConstructorType, outJSON);
}

ExtendTypes.typeName = typeName;

function ConstructorType(sourceObj){

	if(!sourceObj || typeof sourceObj !== "object")
		throw argError(arguments, "Argument isn't Object!" );
	

	var typeObj = reCostructObj(sourceObj);

	var type = {
		name: typeName,
		rand: rand,
		test: test,
		preJSON: preJSON
	}

	function rand(){
		return genObj(typeObj);
	}

	function test(testingObj, objsStack){
		return testObj(typeObj, testingObj, objsStack);
	}

	function preJSON(){
		var type = {name: typeName};
		type.struct = objPreJson(typeObj);
		return type;
	}

	return type;

}

function outJSON(preType){

	if(typeof preType == "object" && preType.name == typeName)
		return ConstructorType(objOutJson(preType.struct));
	else
		throw new Error("This isn't type " + typeName + "!");
}

module.exports = ExtendTypes;

function reCostructObj(sourceObj, objsStack){

	if(!objsStack)
		objsStack = [];
	
	var funcObj = {};
	objsStack.push(sourceObj);

	for(var key in sourceObj){

		if(Types.isType(sourceObj[key])){
			funcObj[key] = sourceObj[key];
			continue;
		}

		if(!sourceObj || (typeof sourceObj[key] !== "object" && !Array.isArray(sourceObj[key]))){
			funcObj[key] = Types.Const.Def(sourceObj[key]);
		}
		else if(objsStack.indexOf(sourceObj[key]) !== -1)
			delete funcObj[key];
		else
			funcObj[key] = reCostructObj(sourceObj[key], objsStack);
	}

	objsStack.pop();

	return funcObj;
}

function testObj(typeObj, testingObj, objsStack){
	if(!objsStack)
		objsStack = [];

	objsStack.push(testingObj);

	var result = false;

	for(let key in typeObj){

		if(Types.isType(typeObj[key]))
			result = typeObj[key].test(testingObj[key]);
		else
			result = testObj(typeObj[key], testingObj[key], objsStack)

		if(result)
			return result;
		
	}

	for(let key in testingObj){
		if(objsStack.indexOf(testingObj[key]) !== -1)
			continue;

		if(!Types.isType(typeObj[key]))
			return { messege: "Here cannot value!", key: key, value: testingObj[key], type: {name: typeName, struct: objPreJson(typeObj[key])}};
	}

	return result;

}

function genObj(typeObj){
	var resultObj = {};

	for(var key in typeObj){
		if(Types.isType(typeObj[key]))
			resultObj[key] = typeObj[key].rand();
		else 
			resultObj[key] = genObj(typeObj[key]);
	}

	return resultObj;
}

function objPreJson(typeObj){
	var struct = {};

	for(var key in typeObj){
		if(Types.isType(typeObj[key]))
			struct[key] = typeObj[key].preJSON();
		else{
			struct[key] = objPreJson(typeObj[key]);
		}
	}

	return struct;
}

function objOutJson(jsonObj){
	var obj = {};

	for(var key in jsonObj){
		var propJsonObj = jsonObj[key];

		if(typeof propJsonObj != "object")
				throw new Error("Invalid scheme JSON, wrong value: " + propJsonObj + " with key: " + key);

		if(propJsonObj.name && Types[propJsonObj.name] && Types.isCrType(Types[propJsonObj.name])){
			obj[key] = Types[propJsonObj.name].outJSON(propJsonObj);
		}
		else{
			obj[key] = objOutJson(propJsonObj);
		}
	}

	return obj;
}
},{}],214:[function(require,module,exports){
'use strict';

const typeName = "String";

let argError = null;

let Types = null;

function ExtendTypes(Core){
	Types = Core;
	argError = Core.argError;
	if(!Core.Index)
		CrIndexType(Core);

	Core.newType(typeName, ConstructorType, outJSON);
}

ExtendTypes.typeName = typeName;

function ConstructorType(symbolClass, maxLength){

	let maxLengthType = Types.Index.Def(1024 * 1024);

	if(typeof symbolClass !== "string" || maxLengthType.test(maxLength))
		throw argError(arguments, 'Wait args ( SymbolClass(String), maxLength(Index>0) )');
	
	if(symbolClass[0] == "^")
		symbolClass = "\\" + symbolClass;

	let rangeSimbol = parseRange(symbolClass);
	let indexRangeType = Types.Index.Def(rangeSimbol.length);

	let checkedRegExp = new RegExp('^[' + symbolClass + ']+$');
	let lengthType = Types.Index.Def(maxLength);


	let type = {
		rand: rand,
		test: test,
		preJSON: preJSON
	}

	function rand(){
		let length = lengthType.rand();

		if(length < 1)
			length++;

		var str = '';

		while(length--){
			var der = rangeSimbol[indexRangeType.rand()];
			str +=String.fromCharCode(der);
		}

		return str;
	}

	function test(str){
		if((typeof(str) !== 'string')
			|| lengthType.test(str.length)
			|| !checkedRegExp.test(str)
		)
			return { value: str, type: preJSON()};
		

		return  false;
	}

	function preJSON(){
		var type = {};
		type.name = typeName;
		type.struct = {
			symbolClass, 
			maxLength,
		};
		return type;
	}

	return type;

}

function outJSON(preType){
	if(typeof preType == "object" && preType.name == typeName)
		return ConstructorType(preType.struct.symbolClass, preType.struct.maxLength);
	else
		throw new Error("This isn't type " + typeName + "!");
}

function replaceSpecChar(c){
	switch(c){
		case 'w': return 'a-zA-Z0-9_';
		case 'd': return '0-9';
		case 's': return '\\t\\n\\v\\f\\r ';

		default: return c;
	}
}

function rangeInArr(beg, end){
	if(beg > end){
		var tmp = beg;
		beg = end;
		end = tmp;
	}

	var arr = [];
	for(var i = beg; i <= end; i++){
		arr.push(i);
	}

	return arr;
}

function parseRange(parse_str){
	if(/\\./.test(parse_str)){
			parse_str = parse_str.replace(/\\(.)/g, function(str, char){ return replaceSpecChar(char);});
	}

	let result = [];

	let beg_char = parse_str[0];
	for(let i = 1; i <= parse_str.length; i++){

		if(parse_str[i-1] !== '\\'
			&&parse_str[i] === '-'
			&&parse_str[i+1]){
			i++;
			let end_char = parse_str[i];

			let arr_chars = rangeInArr(beg_char.charCodeAt(0), end_char.charCodeAt(0));
			result = result.concat(arr_chars);

			i++;
		}else{
			result.push(beg_char.charCodeAt(0));
		}

		beg_char = parse_str[i];
	}
	return result;
}

module.exports = ExtendTypes;
},{}],215:[function(require,module,exports){
'use strict';

const typeName = "Switch";

let argError = null;

let Types = null;

const CrIndexType  =  require('../index/type.js');
const CrKeyType  =  require('../key/type.js');

function ExtendTypes(Core){
	Types = Core;
	argError = Core.argError;
	if(!Core.Index)
		CrIndexType(Core);
	if(!Core.Key)
		CrKeyType(Core);
	Core.newType(typeName, ConstructorType, outJSON);
}

ExtendTypes.typeName = typeName;

function ConstructorType(keyProps, typeObjs){

	let keyType = Types.Key.Def();

	if(!Array.isArray(keyProps))
		keyProps = [keyProps];

	if(keyProps.some(keyType.test))
		throw argError(arguments, 'Wait the first argument Key || Array(Key)');

	if(!Array.isArray(typeObjs))
		throw argError(arguments, 'Wait second argument Array!');

	let keyArr = [];

	let err = msg => argError(arguments, 'Wait second argument Array( Object{ [Key]: Key, prop: Type, ... }), ...); ' + msg);

	let typeObjArr = typeObjs.map((sructObj, objIndex) => {
		if(typeof sructObj != "object")
			throw err("Item " + objIndex + " in Array isn't Object");

		let obj = {};

		keyArr[objIndex] = {};
		keyProps.forEach(keyProp =>{
			if(keyType.test(sructObj[keyProp]))
				throw err("Item " + objIndex + "." + keyProp + " isn't Key");
			else
				keyArr[objIndex][keyProp] = sructObj[keyProp];
		});
		
		for (let key in sructObj){
			if(keyProps.indexOf(key) == -1){

				if(Types.isType(sructObj[key]))
					obj[key] = sructObj[key];
				else
					throw err("Item " + objIndex + "." + key + " isn't Type");
			}
		}

		return obj;
	});

	let indexType = Types.Index.Def(keyArr.length);
		

	let type = {
		rand: rand,
		test: test,
		preJSON: preJSON
	}

	function rand(){
		let index = indexType.rand();

		let obj = {};

		let keyObj = keyArr[index];
		for(let keyProp in keyObj)
				obj[keyProp] = keyObj[keyProp];
		
		let sructObj = typeObjArr[index];
		for (let key in sructObj){
			obj[key] = sructObj[key].rand();
		}

		return obj;
	}

	function test(obj){
		
		if(typeof obj != "object" || obj === null)
			return { value: obj, type: preJSON()};

		if(keyProps.some(keyProp => keyType.test(obj[keyProp])))
			return { value: obj, type: preJSON()};

		let err = { value: obj, type: preJSON()};
		let is_right = false;

		keyArr.forEach((keyObj, index) =>{
			if(is_right)
				return;
			
			let is_right_keys = true;
			for(let keyProp in keyObj)
				is_right_keys = is_right_keys && (keyObj[keyProp] == obj[keyProp]);

			if(is_right_keys){

				let is_right_values = true;
				for(let key in typeObjArr[index]){
					if(typeObjArr[index][key].test(obj[key])){
						err = { value: obj[key], type: typeObjArr[index][key].preJSON()};
						is_right_values = false;
					}
				}

				if(is_right_values)
					is_right = true;
			} 

		});

		if(!is_right)
			return err;

		return;
	}

	function preJSON(){
		var type = {};
		type.name = typeName;

		let tempObjArr = typeObjs.map(sructObj => {
			let obj = {};
			for (let key in sructObj){
				if(Types.isType(sructObj[key]))
					obj[key] = sructObj[key].preJSON();
				else
					obj[key] = sructObj[key];
			}

			return obj;
		});

		type.struct = { keyProps, tempObjArr };
		return type;
	}

	return type;

}

function outJSON(preType){
	if(typeof preType == "object" && preType.name == typeName){

		let ObjsArr = preType.struct.tempObjArr.map(jsonObj => {
			let obj = {};

			for(var key in jsonObj){
				var propJsonObj = jsonObj[key];

				if(propJsonObj.name && Types[propJsonObj.name] && Types.isCrType(Types[propJsonObj.name])){
					obj[key] = Types[propJsonObj.name].outJSON(propJsonObj);
				}
				else
					obj[key] = propJsonObj;
			}

			return obj;
		});
		
		return ConstructorType(preType.struct.keyProps, ObjsArr);
	}
	else
		throw new Error("This isn't type " + typeName + "!");
}

module.exports = ExtendTypes;
},{"../index/type.js":210,"../key/type.js":211}],216:[function(require,module,exports){
'use strict';

const typeName = "Core";

let argError = null;

let Types = null;

function ExtendTypes(Core){
	Types = Core;
	argError = Core.argError;
	Core.newType(typeName, ConstructorType, outJSON);
}

ExtendTypes.typeName = typeName;

function ConstructorType(hello){

	if(typeof hello !== "string")
		throw argError(arguments, 'Wait args (String)');

	let type = {
		rand: rand,
		test: test,
		preJSON: preJSON
	}

	function rand(){
		return hello;
	}

	function test(value){
		if(value !== hello)
			return { value: value, type: preJSON()};
	}

	function preJSON(){
		var type = {};
		type.name = typeName;
		type.struct = hello;
		return type;
	}

	return type;

}

function outJSON(preType){
	if(typeof preType == "object" && preType.name == typeName)
		return ConstructorType(preType.struct)
	else
		throw new Error("This isn't type " + typeName + "!");
}

module.exports = ExtendTypes;
},{}],217:[function(require,module,exports){
/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 0x100).toString(16).substr(1);
}

function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex;
  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4
  return ([bth[buf[i++]], bth[buf[i++]], 
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]],
	bth[buf[i++]], bth[buf[i++]],
	bth[buf[i++]], bth[buf[i++]]]).join('');
}

module.exports = bytesToUuid;

},{}],218:[function(require,module,exports){
// Unique ID creation requires a high quality random # generator.  In the
// browser this is a little complicated due to unknown quality of Math.random()
// and inconsistent support for the `crypto` API.  We do the best we can via
// feature-detection

// getRandomValues needs to be invoked in a context where "this" is a Crypto
// implementation. Also, find the complete implementation of crypto on IE11.
var getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||
                      (typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));

if (getRandomValues) {
  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto
  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef

  module.exports = function whatwgRNG() {
    getRandomValues(rnds8);
    return rnds8;
  };
} else {
  // Math.random()-based (RNG)
  //
  // If all else fails, use Math.random().  It's fast, but is of unspecified
  // quality.
  var rnds = new Array(16);

  module.exports = function mathRNG() {
    for (var i = 0, r; i < 16; i++) {
      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return rnds;
  };
}

},{}],219:[function(require,module,exports){
// Adapted from Chris Veness' SHA1 code at
// http://www.movable-type.co.uk/scripts/sha1.html
'use strict';

function f(s, x, y, z) {
  switch (s) {
    case 0: return (x & y) ^ (~x & z);
    case 1: return x ^ y ^ z;
    case 2: return (x & y) ^ (x & z) ^ (y & z);
    case 3: return x ^ y ^ z;
  }
}

function ROTL(x, n) {
  return (x << n) | (x>>> (32 - n));
}

function sha1(bytes) {
  var K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];
  var H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];

  if (typeof(bytes) == 'string') {
    var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape
    bytes = new Array(msg.length);
    for (var i = 0; i < msg.length; i++) bytes[i] = msg.charCodeAt(i);
  }

  bytes.push(0x80);

  var l = bytes.length/4 + 2;
  var N = Math.ceil(l/16);
  var M = new Array(N);

  for (var i=0; i<N; i++) {
    M[i] = new Array(16);
    for (var j=0; j<16; j++) {
      M[i][j] =
        bytes[i * 64 + j * 4] << 24 |
        bytes[i * 64 + j * 4 + 1] << 16 |
        bytes[i * 64 + j * 4 + 2] << 8 |
        bytes[i * 64 + j * 4 + 3];
    }
  }

  M[N - 1][14] = ((bytes.length - 1) * 8) /
    Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = ((bytes.length - 1) * 8) & 0xffffffff;

  for (var i=0; i<N; i++) {
    var W = new Array(80);

    for (var t=0; t<16; t++) W[t] = M[i][t];
    for (var t=16; t<80; t++) {
      W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);
    }

    var a = H[0];
    var b = H[1];
    var c = H[2];
    var d = H[3];
    var e = H[4];

    for (var t=0; t<80; t++) {
      var s = Math.floor(t/20);
      var T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t] >>> 0;
      e = d;
      d = c;
      c = ROTL(b, 30) >>> 0;
      b = a;
      a = T;
    }

    H[0] = (H[0] + a) >>> 0;
    H[1] = (H[1] + b) >>> 0;
    H[2] = (H[2] + c) >>> 0;
    H[3] = (H[3] + d) >>> 0;
    H[4] = (H[4] + e) >>> 0;
  }

  return [
    H[0] >> 24 & 0xff, H[0] >> 16 & 0xff, H[0] >> 8 & 0xff, H[0] & 0xff,
    H[1] >> 24 & 0xff, H[1] >> 16 & 0xff, H[1] >> 8 & 0xff, H[1] & 0xff,
    H[2] >> 24 & 0xff, H[2] >> 16 & 0xff, H[2] >> 8 & 0xff, H[2] & 0xff,
    H[3] >> 24 & 0xff, H[3] >> 16 & 0xff, H[3] >> 8 & 0xff, H[3] & 0xff,
    H[4] >> 24 & 0xff, H[4] >> 16 & 0xff, H[4] >> 8 & 0xff, H[4] & 0xff
  ];
}

module.exports = sha1;

},{}],220:[function(require,module,exports){
var bytesToUuid = require('./bytesToUuid');

function uuidToBytes(uuid) {
  // Note: We assume we're being passed a valid uuid string
  var bytes = [];
  uuid.replace(/[a-fA-F0-9]{2}/g, function(hex) {
    bytes.push(parseInt(hex, 16));
  });

  return bytes;
}

function stringToBytes(str) {
  str = unescape(encodeURIComponent(str)); // UTF8 escape
  var bytes = new Array(str.length);
  for (var i = 0; i < str.length; i++) {
    bytes[i] = str.charCodeAt(i);
  }
  return bytes;
}

module.exports = function(name, version, hashfunc) {
  var generateUUID = function(value, namespace, buf, offset) {
    var off = buf && offset || 0;

    if (typeof(value) == 'string') value = stringToBytes(value);
    if (typeof(namespace) == 'string') namespace = uuidToBytes(namespace);

    if (!Array.isArray(value)) throw TypeError('value must be an array of bytes');
    if (!Array.isArray(namespace) || namespace.length !== 16) throw TypeError('namespace must be uuid string or an Array of 16 byte values');

    // Per 4.3
    var bytes = hashfunc(namespace.concat(value));
    bytes[6] = (bytes[6] & 0x0f) | version;
    bytes[8] = (bytes[8] & 0x3f) | 0x80;

    if (buf) {
      for (var idx = 0; idx < 16; ++idx) {
        buf[off+idx] = bytes[idx];
      }
    }

    return buf || bytesToUuid(bytes);
  };

  // Function#name is not settable on some platforms (#270)
  try {
    generateUUID.name = name;
  } catch (err) {
  }

  // Pre-defined namespaces, per Appendix C
  generateUUID.DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
  generateUUID.URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';

  return generateUUID;
};

},{"./bytesToUuid":217}],221:[function(require,module,exports){
var rng = require('./lib/rng');
var bytesToUuid = require('./lib/bytesToUuid');

// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html

var _nodeId;
var _clockseq;

// Previous uuid creation time
var _lastMSecs = 0;
var _lastNSecs = 0;

// See https://github.com/broofa/node-uuid for API details
function v1(options, buf, offset) {
  var i = buf && offset || 0;
  var b = buf || [];

  options = options || {};
  var node = options.node || _nodeId;
  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;

  // node and clockseq need to be initialized to random values if they're not
  // specified.  We do this lazily to minimize issues related to insufficient
  // system entropy.  See #189
  if (node == null || clockseq == null) {
    var seedBytes = rng();
    if (node == null) {
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      node = _nodeId = [
        seedBytes[0] | 0x01,
        seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]
      ];
    }
    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    }
  }

  // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();

  // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock
  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;

  // Time since last uuid creation (in msecs)
  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;

  // Per 4.2.1.2, Bump clockseq on clock regression
  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  }

  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  }

  // Per 4.2.1.2 Throw error if too many uuids are requested
  if (nsecs >= 10000) {
    throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;

  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
  msecs += 12219292800000;

  // `time_low`
  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff;

  // `time_mid`
  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff;

  // `time_high_and_version`
  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
  b[i++] = tmh >>> 16 & 0xff;

  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
  b[i++] = clockseq >>> 8 | 0x80;

  // `clock_seq_low`
  b[i++] = clockseq & 0xff;

  // `node`
  for (var n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf ? buf : bytesToUuid(b);
}

module.exports = v1;

},{"./lib/bytesToUuid":217,"./lib/rng":218}],222:[function(require,module,exports){
var v35 = require('./lib/v35.js');
var sha1 = require('./lib/sha1');
module.exports = v35('v5', 0x50, sha1);

},{"./lib/sha1":219,"./lib/v35.js":220}],223:[function(require,module,exports){
require("../lib/mof.js");

function CrBlocks(Rout, json_data_bloks){
	var Data = JSON.parse(json_data_bloks);
	var sizes = Data.map.sizes;
	var Tiles = Data.tiles;

	var Blocks = Array.create();

	/*var crLine = Array.create.bind(null, null, sizes.width);
	var crPline = Array.create.bind(null, crLine, sizes.width, true);
	var map = Array.create(crPline, sizes.layers);*/

	var Send = {map: Rout.connect(Input)};

	/*Send.map({
		action: "Create",
		type: "BlockTiles",
		data: Tiles.map((tile)=> {image: tile.images[0], size: tile.size})
	});*/
	
	function Input(mess){
		switch(mess.action){
			
		}
	}

	//loadMap(Data.map.layers);

	function loadMap(layers){
		var background = layers[0];

		background.forEach(CrGroundBlocks);

		function CrGroundBlocks(block){
			block.images = Tiles[block.tile_id].images;
			Send.map({
				action: "Create",
				type: "Block",
				block: block,
				collis: 0
			});
		}
	}



	function fillBox(tile, coords, size){
		var box = {coords: coords, size: tile.size, tile_id: tile.id};
		var size = tile.size;

		for(var i = size - 1; i >= 0; i--){
			for(var j = size - 1; j >= 0; j--){
				map[coords.z][coords.y + j][coords.x + i] = box;
			}
		}

		return coords;
	}

	function clearBox(box){
		var coords = box.coords;
		var size = box.size;

		for(var i = size - 1; i >= 0; i--){
			for(var j = size - 1; j >= 0; j--){
				map[coords.z][coords.y + j][coords.x + i] = null;
			}
		}
		return coords;
	}

	function is_coords(coords, size=1){
		return coords 
		&& map[coords.z] 
		&& map[coords.z][coords.y] 
		&& map[coords.z][coords.y + size - 1]
		&& map[coords.z][coords.y][coords.x] !== undefined
		&& map[coords.z][coords.y + size - 1][coords.x + size - 1] !== undefined;
	}

	function is_empty(coords, size=1){
		for(var i = size - 1; i >= 0; i--){
			for(var j = size - 1; j >= 0; j--){
				if(map[coords.z][coords.y + j][coords.x + i] !== null)
					return false;
			}
		}
		return true;
	}
}

module.exports = CrBlocks;
},{"../lib/mof.js":13}],224:[function(require,module,exports){
var types = require("./Types.js");

var bullets_data = require("./bullet.json");

function CrBullets(Commun){
	var Actor = {
		bullets: Array.create(),
		adress: "Bullets"
	};
	
	var Output = Commun.connect(Input);

	Output({
		action: "Add",
		type: "Tiles",
		tile_type: "Bullet",
		tile: bullets_data.Bullet.tile,
		source: Actor.adress
	});
	
	function CrBullet(mess){	
		
		var bull = {
			source: mess.source,
			box: {w: 0.3, h: 0.3},
			dir: mess.dir,
			speed: 17
		};

		var axis = 'x';
		var add_axis = 'w';
		var dir = 1;
		switch(bull.dir){
			case -0.5: dir = -1;
			case 0.5: axis = "y"; add_axis = 'h'; break;
			case 1:
			case -1: dir = -1; break;
		}
		
		mess.pos[axis] += dir * bull.box[add_axis];
		
		bull.pos = {x: +mess.pos.x.toFixed(2), y: +mess.pos.y.toFixed(2)};
		
		if(types.position.test(bull.pos))
			return;

		bull.id = Actor.bullets.add(bull);
		
		var new_mess = {
			action: "Create",
			type: "Bullet",
			bull: {
				id: bull.id,
				source: Actor.adress,
				sprite: Actor.tile_id,
				dir: bull.dir,
				box: Object.assign({}, bull.box),
				pos: {x: +bull.pos.x.toFixed(2), y: +bull.pos.y.toFixed(2)},
				speed: bull.speed
			}
		}
		
		Output(new_mess);
	}
	
	function DellBull(mess){
		Output({action: "Dell", type: "Bullet", id: mess.id});
		Actor.bullets.dell(mess.id);
	}
	
	function Collision(mess){
		var bullet = Actor.bullets[mess.id];
		DellBull({id: mess.id});
		
		Output({
			action: "Damage",
			type: mess.list[0].type,
			id: mess.list[0].id,
			adr: mess.list[0].source,
			killer: bullet.source
		});
	}


	
	function Input(mess){
		switch(mess.type){
			case "Tiles": 
				switch(mess.action){
					case "Add": Actor.tile_id = mess.tile_id; break;
				} break;
		}
		switch(mess.action){
			case "Fire": CrBullet(mess); break;
			case "Collision": Collision(mess); break;
			case "OverMap":
			case "Damage": DellBull(mess); break;
		}
	}
	
	
}

module.exports = CrBullets;

},{"./Types.js":227,"./bullet.json":229}],225:[function(require,module,exports){
function CrGameMode(Router, Param){
	var Output = Router.connect(Input);
	
	var List_Adr = [];
	
	
	function Input(mess){
		switch(mess.action){
			case "Reg": AddAdr(mess); break;
			case "Kill": Kill(mess); break;
		}
	}
	
	function AddAdr(mess){
		List_Adr[mess.source] = {
			login: mess.login,
			kills: 0,
			deaths: 0 
		};
	}
	
	function Kill(mess){
		List_Adr[mess.killer].kills++;
		List_Adr[mess.casualty].deaths++;
		Output({
			action: "Kill",
			type: "Gamer",
			adr: mess.killer
		});
		
		if(List_Adr[mess.killer].kills >= Param.max_kills) Win(mess.killer);
	}
	
	function Win(winner){
		var win_login = List_Adr[winner].login;
		
		List_Adr.forEach(function(gamer, i){
			if(gamer){
				Output({
					action: (i == winner)? "Win" : "Lose",
					type: "Gamer",
					winner:  win_login,
					adr: i
				});
			}
		});
	}

}

module.exports = CrGameMode;

},{}],226:[function(require,module,exports){
function CrMap(Commun, map){
	var Tiles = Array.create();

	var List = {
		Gamer: Array.create(),
		Bullet: Array.create(),
		Block: Array.create()
	};

	CrMovingLoop(List.Gamer, Move);
	CrMovingLoop(List.Bullet, MoveBullet);
	
	var Output = Commun.connect(Input);
	
	function Input(mess){
		if(mess.action == 'Connect') return;

		switch(mess.type){
			case "Tiles":
				switch(mess.action){
					case "Create": LoadTiles(mess); break;
					case "Add": AddTile(mess); break;
				} 
				break;
			case "Map":
				switch(mess.action){
					case "Create": loadMap(mess); break;
				} 
				break;
			case "Bullet": 
				switch(mess.action){
					case "Create": CrBullet(mess); break;
				} 
				break;
			case "Gamer": 
				switch(mess.action){
					case "Create": CrObj(mess); break;
					case "Move": MoveElem(mess); break;
				} 
				break;
			default: console.log("Unknown message: ", mess);
		}

		switch(mess.action){
			case "Dell": DellObj(mess); break;
		}
	}
	
	
	
	

//==============TILES=================
	function AddTile(mess){
		var tile = mess.tile;
		var id = Tiles.add(tile);
		tile.id = id;

		Output({
			action: "Add",
			type: "Tiles",
			tile_type: mess.tile_type,
			tile_id: tile.id,
			adr: mess.source
		});

		sendAllGamers({
			action: "Add",
			type: "Tiles",
			tile: tile
		});
	}
	
	function LoadTiles(mess){

		Output({
			action: "Create",
			type: "Tiles",
			tiles: Tiles.concat(),
			adr: mess.source
		});
	}

//==============GAMERS================
	
	function sendAllGamers(new_mess){
		new_mess.adr = "PlayersManager";
		Output(new_mess);
	}

	function CrObj(mess){
		
		var obj = {
			type: mess.type,
			source: mess.source,
			sprite: mess.sprite,
			box: mess.box
		};

		if(mess.speed){
			obj.speed = mess.speed;
			obj.date = Date.now();
		}


		if(!List[mess.type]) List[mess.type] = Array.create();
		var id = List[mess.type].add(obj);
		obj.id = id;
		
		var new_mess = {
			action: "Create",
			type: "Actor",
			actor_type: mess.type,
			id: obj.id,
			sprite: obj.sprite,
			box: mess.box,
		};
		
		if(mess.type == "Gamer"){
			new_mess = CrGamer(new_mess, obj);
		}
		
		sendAllGamers(new_mess);
	}

	function DellObj(mess){

		var new_mess = {
			action: "Dell",
			type: "Actor", 
			actor_type: mess.type, 
			id: mess.id
		}
		
		sendAllGamers(new_mess);

		if(mess.type == "Gamer") DellGamer(mess);
		List[mess.type].dell(mess.id);
	}
	
	function CrGamer(mess, gamer){
		
		var resp = map.resp[gamer.id][0];
		
		gamer.pos = {x: +resp.x.toFixed(2), y: +resp.y.toFixed(2)};
		gamer.dir = 0; //=====================================Resp
		
		
		mess.pos = gamer.pos;
		mess.dir = gamer.dir;
		mess.sprite = gamer.sprite;
		mess.source = gamer.source;

		SendGamer(mess);
		
		return mess;
	}

	function SendGamer(mess){
		var new_mess = Object.assign({}, mess);
		new_mess.type = "Gamer";
		new_mess.adr = new_mess.source;
		Output(new_mess);
	}
	
	function DellGamer(mess){

	}
	
	function loadMap(mess){
		var Gamers = List["Gamer"].concat();
		var Blocks = List["Block"].concat();
		
		Output({
			action: "Create", 
			type: "Map", 
			size: map.size, 
			adr: mess.source
		});

		loadBlocks(Blocks, mess.source);

		loadGamers(Gamers, mess.source);
	}
	
	function loadGamers(Objs, adr){
		Objs.forEach(function(obj){
			if(obj) Output({
				action: "Create",
				type: "Actor",
				actor_type: obj.type,
				id: obj.id,
				box: obj.box,
				pos: {x: +obj.pos.x.toFixed(2), y: +obj.pos.y.toFixed(2)},
				dir: obj.dir,
				sprite: obj.sprite,
				adr: adr
			});
		});
	}

	function loadBlocks(Blocks, adr){
		Blocks.forEach(function(obj){
			if(obj) Output({
				action: "Create",
				type: obj.type,
				id: obj.id,
				box: obj.box,
				pos: {x: +obj.pos.x.toFixed(2), y: +obj.pos.y.toFixed(2)},
				dir: obj.dir,
				sprite: obj.sprite,
				adr: adr
			});
		});
	}
	

	function MoveElem(mess){
		
		if(mess.type == "Bullet"){
			throw new Error();
		}
		
		var obj = List[mess.type][mess.id];
		
		obj.dir = mess.dir;
		obj.speed = mess.speed;
		
		var new_mess = {
			action: "Update",
			type: "Actor",
			actor_type: obj.type,
			id: obj.id,
			pos: {x: +obj.pos.x.toFixed(2), y: +obj.pos.y.toFixed(2)},
			dir: obj.dir,
			source: obj.source
		};
		
		if(obj.type == "Gamer")
			SendGamer(new_mess);
		
		sendAllGamers(new_mess);
	}

	function Move(obj){
		if(obj.speed){

			var axis = 'x';
			var dir = 1;
			switch(obj.dir){
				case -0.5: dir = -1;
				case 0.5: axis = "y"; break;
				case 1:
				case -1: dir = -1; break;
			}
			
			
			var new_pos = {x: obj.pos.x, y: obj.pos.y};
			var new_date = Date.now();

			new_pos[axis] += dir * obj.speed * (new_date - obj.date) * 0.0005;
			
			
			if(isMove(obj, new_pos)){
				obj.pos = new_pos;
				
				var new_mess = {
					action: "Update",
					type: "Actor",
					actor_type: obj.type,
					id: obj.id,
					pos: {x: +obj.pos.x.toFixed(2), y: +obj.pos.y.toFixed(2)},
					dir: obj.dir
				};

				if(obj.type == "Gamer")
					SendGamer(new_mess);
				
				sendAllGamers(new_mess);
			}
		}
		obj.date = Date.now();
	}
	
	function isMove(obj, new_pos){
		
		return isIntoMap(obj, new_pos)
		&& !List["Gamer"].some(function(wall, id){
			if(wall && (wall.type !== obj.type || wall.id !== obj.id)) return isCollis(obj, new_pos, wall);
		});
	}
	
//===============Bullets================
	
	function CrBullet(mess){
		if(!List["Bullet"]) List["Bullet"] = Array.create();
		var bull = mess.bull;
		bull.date = Date.now();
		List["Bullet"][bull.id] = bull;

		var new_mess = {
			action: "Create",
			type: "Actor",
			actor_type: "Bullet",
			id: bull.id,
			sprite: bull.sprite,
			box: {w: bull.box.w, h: bull.box.h},
			pos: {x: +bull.pos.x.toFixed(2), y: +bull.pos.y.toFixed(2)},
			dir: bull.dir
		};

		sendAllGamers(new_mess);
	}
	
	function MoveBullet(bull){

		var axis = 'x';
		var dir = 1;
		switch(bull.dir){
			case -0.5: dir = -1;
			case 0.5: axis = "y"; break;
			case 1:
			case -1: dir = -1; break;
		}
		

		bull.pos[axis] += dir * bull.speed * (Date.now() - bull.date) * 0.0005;

		if(!collisBullet(bull, bull.pos))
			sendAllGamers({
				action: "Update",
				type: "Actor",
				actor_type: "Bullet",
				id: bull.id,
				box: {w: bull.box.w, h: bull.box.h},
				pos: {x: +bull.pos.x.toFixed(2), y: +bull.pos.y.toFixed(2)},
				dir: bull.dir
			});

		bull.date = Date.now();
	}

	function collisBullet(bull, new_pos){
		
		if(isIntoMap(bull, new_pos)){
			
			var objs = collisBulletObst(bull, "Gamer");
			var bulls = collisBulletObst(bull, "Bullet");
			if(objs.length || bulls.length){

				var list = objs;
				if(!objs.length)
					list = bulls;

				Output({
					action: "Collision",
					id: bull.id,
					list: list,
					adr: bull.source
				});

				List["Bullet"].dell(bull.id);
				return true;
			}
			return false;
		}else{
			Output({
				action: "OverMap",
				id: bull.id,
				adr: bull.source
			});
			List["Bullet"].dell(bull.id);
			return true;
		}
	}
	
	function collisBulletObst(bullet, obst_type){
		return List[obst_type].filter(function(obst){
			 if(obst && !(obst.id == bullet.id && obst_type == "Bullet")) 
			 	return isCollis(bullet, bullet.pos, obst);
		}).map(function(obj){
			return {
				id: obj.id, 
				type: obst_type, 
				source: obj.source, 
				pos: Object.assign({}, obj.pos)
			};
		});
	}

//===============Blocks==================

	function CrBlock(mess){
		var block = mess.block;
		var obj = {
			type: mess.type,
			pos: {x: block.coords.x, y: block.coords.y},
			box: {w: block.coords.x + block.size, h: block.coords.x + block.size},
			dir: block.rotate,
			sprite: block.images[0],
		};

		obj.id = List.Block.add(obj);

	}
	
//================================
	
	function isIntoMap(obj, new_pos){
		var w = 'w';
		var h = 'h';
		
		if(obj.dir % 2){
			w = 'h';
			h = 'w';
		}
		
		return (new_pos.x - obj.box[w]) > 0 
		&& (new_pos.x + obj.box[w]) < map.size
		&& (new_pos.y - obj.box[h]) > 0 
		&& (new_pos.y + obj.box[h]) < map.size;
	}
	
	function isCollis(obj, new_pos, wall){
		var o_w = 'w';
		var o_h = 'h';
		var w_w = 'w';
		var w_h = 'h';
		
		if(obj.dir % 2){
			o_w = 'h';
			o_h = 'w';
		}
		
		if(wall.dir % 2){
			w_w = 'h';
			w_h = 'w';
		}
		
		if((new_pos.x - obj.box[o_w]) > (wall.pos.x + wall.box[w_w])) return false;
		if((new_pos.x + obj.box[o_w]) < (wall.pos.x - wall.box[w_w])) return false;
		
		if((new_pos.y - obj.box[o_h]) > (wall.pos.y + wall.box[w_h])) return false;
		if((new_pos.y + obj.box[o_h]) < (wall.pos.y - wall.box[w_h])) return false;
		
		return true;
	}
}

module.exports = CrMap;

function CrMovingLoop(Objects, Move){
	setInterval(Objects.forEach.bind(Objects, function(obj){
		if(obj) Move(obj);
	}), 40);
}

},{}],227:[function(require,module,exports){

var T = require("typesjs");

var map_size = 25;
exports.map_size = map_size;
exports.obj_id = T.Index.Def(map_size*map_size*2);

exports.box = T.Object.Def({
	w: T.Number.Def(map_size, 0, 2), 
	h: T.Number.Def(map_size, 0, 2)
});

exports.position = T.Object.Def({
	x: T.Number.Def(map_size, 0, 2), 
	y: T.Number.Def(map_size, 0, 2)
});

exports.direction = T.Number.Def(1, -1, 1);

exports.path = T.Array.Def(T.String.Def('\\w\\d_.', 256), 256);

},{"typesjs":205}],228:[function(require,module,exports){
"use strict";

require("../lib/mof.js");

module.exports = CrClient;

function CrClient(Commun){
	var bul_adr = "Bullets";
	var game_mod_adr = "GameMode";
	var manager_adr = "PlayersManager";

	var GamerData = null;

	var IsReadyTiles = false;
	var IsMap = false;
	var IsPlay = false; 
	
	
	var Send = {
		client: null,
		def: Commun.connect(Input),
		map: function(mess){
			this.def(mess);
		},
		bullet: function(mess){
			mess.adr = bul_adr;
			this.def(mess);
		},
		mode: function(mess){
			mess.adr = game_mod_adr;
			this.def(mess);
		},
		manager: function(mess){
			mess.adr = manager_adr;
			this.def(mess);
		}
	};


	var Gamer = new CrGamer(Send, Death);
	
	this.Input = Input;
	this.Connect = function(Client){
		Send.client = Client.connect(InputClient);
		
		GamerData = Client.data;

		Gamer.login = Client.login;
		Send.client({
			action: "Update", 
			type: "GUI", 
			data: {
				Status: "Watch other gamers", 
				login: Gamer.login
			}
		});

		Send.map({
			action: "Reg", 
			login: Gamer.login, 
			source: Gamer.adress, 
			adr: game_mod_adr
		});

		Send.map({
			action: "Create", 
			type: "Tiles", 
			source: Gamer.adress
		});

		Send.map({
			action: "Add", 
			type: "Tiles",
			tile_type: "Gamer",
			tile: GamerData.tile,
			source: Gamer.adress,
		});  
		
		return this;
	};

	this.Ready = function(){
		Resp();
		console.info("Gamer N" + Gamer.adress + " is playing.");
	}

	this.Destroy = function(){
		Off();
	}

	return this;


	

	function Resp(){

		Send.map({
			action: "Create",
			type: "Gamer",
			source: Gamer.adress,
			box: {w: Gamer.box.w, h: Gamer.box.h},
			sprite: GamerData.tile.id
		});

		IsPlay = true;
	}
	
	function Off(){
		Gamer.destroy();
		 
		Send.map({
			action: "Dell",
			type: "Gamer",
			id: Gamer.id,
			source: Gamer.adress,
		});

		IsPlay = false;
	}

	function Death(killer){
		Off();
		Gamer.deaths++;
		Resp();

		Send.mode({
			action: "Kill",
			killer: killer,
			casualty: Gamer.adress
		});
	}
	
	
	function InputClient(mess){
		switch(mess.action){
			case "ReadyLoad": ReadyLoad(mess); break;
			case "Move": if(IsPlay) Gamer.new_dir = mess.dir; break;
			case "Fire": if(IsPlay) Gamer.press_fire = true; break;
		}
	}

	function ReadyLoad(mess){
		switch(mess.type){
			case "Tiles": ReadyTiles(mess); break;
			case "Map": ReadyMap(mess); break;
		}
	}

	function ReadyTiles(mess){
		Send.map({
			action: "Create", 
			type: "Map", 
			source: Gamer.adress
		});
	}

	function ReadyMap(mess){
		ReadyGamer();
	}

	function ReadyGamer(){
		Send.manager({
			action: "Ready",
			type: "Gamer",
			id: Gamer.adress,
		});
	}
	
	
	function Input(mess){

		if(mess.action == 'Connect'){
			Gamer.adress = mess.adress;
			return;
		}

		switch(mess.type){
			case "Tiles": TilesInput(mess); break;
			case "Map": MapInput(mess); break;
			case "Gamer": GamerInput(mess); break;
			case "Actor": ActorInput(mess); break;
			default: console.error("Unknown message: ", mess);
		}
		
	}

	function TilesInput(mess){
		switch(mess.action){
			case "Create": 
				Send.client({
					action: mess.action,
					type: mess.type,
					tiles: mess.tiles
				});

				IsReadyTiles = true;
				break;
			case "Add": AddTile(mess); break;
			default: console.error("Unknown message: ", mess);
		}

	}

	function MapInput(mess){
		switch(mess.action){
			case "Create": IsMap = true; break;
			case "Dell": IsMap = false; break;
		}

		if(IsReadyTiles) 
			Send.client(mess);
		else throw new Error();
	}

	function GamerInput(mess){
		
		switch(mess.action){
			case "Create": Gamer.init(mess); break;
			case "Update": Gamer.update(mess); break;
			case "Damage": Gamer.damage(mess); break;
			case "Kill": Gamer.kills++; break;
			case "Win":
			case "Lose": EndGame(mess); break;
		}
	}

	function EndGame(mess){
		Send.client({
			action: "Update",
			type: "GUI", 
			data: {
				Status: mess.action,
				Winner: mess.winner,
				life: Gamer.life,
				deaths: Gamer.deaths,
				kills: Gamer.kills
			}
		});
		
		Gamer.destroy();
		IsPlay = false;
	}

	function ActorInput(mess){
		
		if(IsMap){
			var new_mess = Object.assign({}, mess);
			delete new_mess.source;
			Send.client(new_mess);
		}
	}
	
	function AddTile(mess){
		if(mess.tile_type == "Gamer"){
			GamerData.tile.id = mess.tile_id;
			return;
		}

		if(IsReadyTiles){
			var new_mess = Object.assign({}, mess);
			delete new_mess.source;
			Send.client(new_mess);
		}
	}
}

function CrGamer(Send, Death){
	var Gamer = {
		dir: 0,
		speed: 7,
		box: {w: 0.9, h: 0.9},
		beg_life: 3,
		kills: 0,
		deaths: 0
	};

	var Gun = new CrGun("Bullet", 7);

	CrDir(Gamer);

	Gamer.init = function(mess){

		this.pos = {x: mess.pos.x, y: mess.pos.y};
		this.id = mess.id;
		this.dir = mess.dir;
		this.life = this.beg_life;
		
		this.scan_timer = setInterval(Gamer.scan.bind(Gamer), 40);
		this.stat_timer = setInterval(Gamer.upStat.bind(Gamer), 140);
	}

	Gamer.destroy = function(){
		clearInterval(this.scan_timer);
		clearInterval(this.stat_timer);
	}

	Gamer.update = function(mess){
		this.pos = {x: mess.pos.x, y: mess.pos.y};
		this.dir = mess.dir;
	}

	Gamer.upStat = function(){
		Send.client({
			action: "Update",
			type: "GUI", 
			data: {
				Status: "Play",
				life: this.life,
				deaths: this.deaths,
				kills: this.kills
			}
		});
	}	
	
	
	Gamer.scan = function(){
		if(this.is_changed || this.move){
			this.updateDir();

			var speed = 0;
			if(this.move)
				speed = this.speed;
			
			var mess = {
				action: "Move",
				type: "Gamer",
				id: this.id,
				dir: this.dir,
				speed: speed
			};
			
			Send.map(mess);
		}
		
		if(this.press_fire) Gamer.fire();
	}

	Gamer.fire = function(){
		this.press_fire = false;

		if(Gun.is_recharge)
			return;
		
		var axis = 'x';
		var dir = 1;
		switch(this.dir){
			case -0.5: dir = -1;
			case 0.5: axis = "y"; break;
			case 1:
			case -1: dir = -1; break;
		}
		
		var b_pos = {x: this.pos.x, y: this.pos.y};
		b_pos[axis] += dir * (this.box.h + 0.05);
		
		var mess = {
			action: "Fire",
			source: this.adress,
			pos: {x: +b_pos.x.toFixed(2), y: +b_pos.y.toFixed(2)},
			dir: this.dir
		};
		
		Send.bullet(mess);

		Gun.is_recharge = true;
	}

	Gamer.damage = function(mess){
		Gamer.life--;
		
		if(Gamer.life <= 0){
			Death(mess.killer);
		}
	}

	return Gamer;
}

function CrGun(bull_type, recharge){
	var is_recharge = false;

	this.addGetSet("is_recharge", 
		function(){
			return is_recharge;
		}, 
		function(val){
			is_recharge = val;
			if(is_recharge)
				setTimeout((
					() => is_recharge = false
				), 100*recharge);
		}
	);
}

function CrDir(obj){
	var dir = null;
	obj.is_move = false;

	obj.addGetSet('new_dir', 
		function(){return dir},
		function(new_dir){
			if(dir === null){
				dir = new_dir;
				obj.is_changed = true;
			}
		}
	);
	obj.updateDir = function(){
		obj.move = false;

		if(obj.dir == dir)
			obj.move = true;

		if(dir != null){
			obj.dir = dir; 
		}

		obj.is_changed = false;
		dir = null;
	};
}

},{"../lib/mof.js":13}],229:[function(require,module,exports){
module.exports={
	"Bullet": 
	{
		"tile": 
		{
      		"images": 
      		[
      			"<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 135.467 135.467\" height=\"512\" width=\"512\"><path d=\"M135.697 70.449a32.788 43.374 0 0 1-32.788 43.374 32.788 43.374 0 0 1-6.788-.992H.375V26.09H103.61v1.02a32.788 43.374 0 0 1 32.087 43.34z\" stroke=\"#000\" stroke-width=\".399\" fill=\"red\"/></svg>"
			],
			"type": "steel",
      		"size": 2
		}
	}
}
},{}],230:[function(require,module,exports){
module.exports={
  "name": "perekrestok",
  "tiles": [
    {
      "images": [
        "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n<svg\n   xmlns:dc=\"http://purl.org/dc/elements/1.1/\"\n   xmlns:cc=\"http://creativecommons.org/ns#\"\n   xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\"\n   xmlns:svg=\"http://www.w3.org/2000/svg\"\n   xmlns=\"http://www.w3.org/2000/svg\"\n   id=\"svg8\"\n   version=\"1.1\"\n   viewBox=\"0 0 400 400\"\n   height=\"400mm\"\n   width=\"400mm\">\n  <defs\n     id=\"defs2\" />\n  <metadata\n     id=\"metadata5\">\n    <rdf:RDF>\n      <cc:Work\n         rdf:about=\"\">\n        <dc:format>image/svg+xml</dc:format>\n        <dc:type\n           rdf:resource=\"http://purl.org/dc/dcmitype/StillImage\" />\n        <dc:title></dc:title>\n      </cc:Work>\n    </rdf:RDF>\n  </metadata>\n  <g\n     transform=\"translate(-3.2678801e-6,103)\"\n     id=\"layer1\">\n    <g\n       transform=\"matrix(-0.26432859,0,0,0.26458271,400,74.250526)\"\n       id=\"g2711\">\n      <path\n         id=\"path1094\"\n         style=\"fill:#8ec953;fill-rule:evenodd;stroke-width:1.33354986\"\n         d=\"m 0,-669.92084 h 1511.744 l 0.07,1511.8106 H 0.069 Z\" />\n      <path\n         id=\"path1096\"\n         style=\"fill:#a2a2a2;fill-rule:evenodd;stroke-width:1.32262826\"\n         d=\"m 1166.03,-669.92484 v 1511.8112 h 340.157 v -1511.8112 z\" />\n      <path\n         id=\"path1100\"\n         style=\"fill:#717271;fill-rule:evenodd;stroke-width:1.19238436\"\n         d=\"m 1232.17,-669.92184 h -74.51 v 1511.8115 h 75.591 z\" />\n      <path\n         id=\"path1100-2\"\n         style=\"fill:#717271;fill-rule:evenodd;stroke-width:1.19238436\"\n         d=\"m 1512.187,-669.92484 h -74.51 V 841.88661 h 75.591 z\" />\n    </g>\n  </g>\n</svg>\n"
      ],
      "type": "wood",
      "size": 1,
      "id": 0
    },
    {
      "images": [
        "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n<svg\n   xmlns:dc=\"http://purl.org/dc/elements/1.1/\"\n   xmlns:cc=\"http://creativecommons.org/ns#\"\n   xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\"\n   xmlns:svg=\"http://www.w3.org/2000/svg\"\n   xmlns=\"http://www.w3.org/2000/svg\"\n   id=\"svg2777\"\n   version=\"1.1\"\n   viewBox=\"0 0 400 400\"\n   height=\"400mm\"\n   width=\"400mm\">\n  <defs\n     id=\"defs2771\" />\n  <metadata\n     id=\"metadata2774\">\n    <rdf:RDF>\n      <cc:Work\n         rdf:about=\"\">\n        <dc:format>image/svg+xml</dc:format>\n        <dc:type\n           rdf:resource=\"http://purl.org/dc/dcmitype/StillImage\" />\n        <dc:title></dc:title>\n      </cc:Work>\n    </rdf:RDF>\n  </metadata>\n  <g\n     transform=\"translate(47.297668,60.238129)\"\n     id=\"layer1\">\n    <g\n       transform=\"matrix(0.35277756,0,0,0.3527778,-5116.7486,2132.5765)\"\n       id=\"Layer1063\">\n      <path\n         id=\"path1235\"\n         style=\"fill:#525252;fill-rule:evenodd\"\n         d=\"m 14370.106,-6215.8521 v 1133.8582 h 1133.859 v -1133.8582 z\" />\n      <path\n         id=\"path1237\"\n         style=\"fill:#d2d1d2;fill-rule:evenodd\"\n         d=\"m 14567.699,-5081.9939 v -1133.8582 h -197.593 v 1133.8582 z\" />\n      <path\n         id=\"path1239\"\n         style=\"fill:#525252;fill-rule:evenodd\"\n         d=\"m 14618.734,-5819.9139 h -248.628 v 396.8509 h 248.628 z\" />\n    </g>\n  </g>\n</svg>\n"
      ],
      "type": "wood",
      "size": 1,
      "id": 1
    },
    {
      "images": [
        "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n<svg\n   xmlns:dc=\"http://purl.org/dc/elements/1.1/\"\n   xmlns:cc=\"http://creativecommons.org/ns#\"\n   xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\"\n   xmlns:svg=\"http://www.w3.org/2000/svg\"\n   xmlns=\"http://www.w3.org/2000/svg\"\n   id=\"svg821\"\n   version=\"1.1\"\n   viewBox=\"0 0 400 399.59998\"\n   height=\"399.59998mm\"\n   width=\"400mm\">\n  <defs\n     id=\"defs815\" />\n  <metadata\n     id=\"metadata818\">\n    <rdf:RDF>\n      <cc:Work\n         rdf:about=\"\">\n        <dc:format>image/svg+xml</dc:format>\n        <dc:type\n           rdf:resource=\"http://purl.org/dc/dcmitype/StillImage\" />\n        <dc:title></dc:title>\n      </cc:Work>\n    </rdf:RDF>\n  </metadata>\n  <g\n     transform=\"translate(0,102.59999)\"\n     id=\"layer1\">\n    <path\n       id=\"path1390\"\n       style=\"fill:#915b26;fill-rule:evenodd;stroke-width:0.35277784\"\n       d=\"M 0,-102.99999 V 297 h 399.99999 v -399.99999 z\" />\n  </g>\n</svg>\n"
      ],
      "type": "wood",
      "size": 1,
      "id": 2
    },
    {
      "images": [
        "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n<svg\n   xmlns:dc=\"http://purl.org/dc/elements/1.1/\"\n   xmlns:cc=\"http://creativecommons.org/ns#\"\n   xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\"\n   xmlns:svg=\"http://www.w3.org/2000/svg\"\n   xmlns=\"http://www.w3.org/2000/svg\"\n   id=\"svg4037\"\n   version=\"1.1\"\n   viewBox=\"0 0 400 400\"\n   height=\"400mm\"\n   width=\"400mm\">\n  <defs\n     id=\"defs4031\" />\n  <metadata\n     id=\"metadata4034\">\n    <rdf:RDF>\n      <cc:Work\n         rdf:about=\"\">\n        <dc:format>image/svg+xml</dc:format>\n        <dc:type\n           rdf:resource=\"http://purl.org/dc/dcmitype/StillImage\" />\n        <dc:title></dc:title>\n      </cc:Work>\n    </rdf:RDF>\n  </metadata>\n  <g\n     transform=\"translate(1.4752746e-6,103)\"\n     id=\"layer1\">\n    <g\n       transform=\"rotate(-90,116.03869,95.86607)\"\n       id=\"g5243\">\n      <g\n         id=\"g5058\"\n         transform=\"matrix(0.99981771,0,0,0.99963581,-33.954254,433.70668)\">\n        <path\n           id=\"path1380-4\"\n           style=\"fill:#808080;fill-rule:evenodd;stroke-width:0.35277766\"\n           d=\"M -51.077382,-454.04466 V -54.044668 H 348.92262 V -454.04466 Z\" />\n        <rect\n           y=\"-453.89868\"\n           x=\"-11.091877\"\n           height=\"399.85391\"\n           width=\"39.98539\"\n           id=\"rect3909-2-45\"\n           style=\"opacity:1;fill:#4d4d4d;fill-opacity:1;stroke:#1a1a1a;stroke-width:0.14611426;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\" />\n        <rect\n           y=\"-453.89874\"\n           x=\"68.878883\"\n           height=\"399.85391\"\n           width=\"39.98539\"\n           id=\"rect3909-2-0-7\"\n           style=\"opacity:1;fill:#4d4d4d;fill-opacity:1;stroke:#1a1a1a;stroke-width:0.14611426;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\" />\n        <rect\n           y=\"-453.8988\"\n           x=\"148.84967\"\n           height=\"399.85391\"\n           width=\"39.98539\"\n           id=\"rect3909-2-4-4\"\n           style=\"opacity:1;fill:#4d4d4d;fill-opacity:1;stroke:#1a1a1a;stroke-width:0.14611426;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\" />\n        <rect\n           y=\"-453.89886\"\n           x=\"228.82045\"\n           height=\"399.85391\"\n           width=\"39.98539\"\n           id=\"rect3909-2-0-5-6\"\n           style=\"opacity:1;fill:#4d4d4d;fill-opacity:1;stroke:#1a1a1a;stroke-width:0.14611426;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\" />\n        <rect\n           y=\"-453.89893\"\n           x=\"308.79123\"\n           height=\"399.85391\"\n           width=\"39.98539\"\n           id=\"rect3909-2-0-5-5-7\"\n           style=\"opacity:1;fill:#4d4d4d;fill-opacity:1;stroke:#1a1a1a;stroke-width:0.14611426;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\" />\n      </g>\n      <g\n         id=\"g5050\"\n         transform=\"matrix(0,-0.99963581,-0.99981771,0,-138.11961,796.85429)\">\n        <path\n           id=\"path1380-6\"\n           style=\"fill:#b3b3b3;fill-rule:evenodd;stroke-width:0.24945147\"\n           d=\"m 417.17884,-252.97558 h 399.99999 v -200 H 417.17884 Z\" />\n        <path\n           id=\"path1380-0\"\n           style=\"fill:#808080;fill-rule:evenodd;stroke-width:0.11155809\"\n           d=\"m 417.17884,-252.97558 h 399.99999 v -40 H 417.17884 Z\" />\n        <path\n           id=\"path1380-0-7\"\n           style=\"fill:#808080;fill-rule:evenodd;stroke-width:0.05577904\"\n           d=\"m 437.17884,-252.97558 v -200 h -20 v 200 z\" />\n        <path\n           id=\"path1380-0-7-6\"\n           style=\"fill:#808080;fill-rule:evenodd;stroke-width:0.05577904\"\n           d=\"m 817.17883,-252.97558 v -200 h -20 v 200 z\" />\n        <path\n           id=\"path1380-0-6\"\n           style=\"fill:#4d4d4d;fill-rule:evenodd;stroke-width:0.07888348\"\n           d=\"m 417.17884,-252.97558 h 399.99999 v -20 H 417.17884 Z\" />\n        <g\n           style=\"fill:#4d4d4d;fill-opacity:1\"\n           id=\"g4731-5-1\"\n           transform=\"translate(-47.118712,77.86203)\">\n          <circle\n             style=\"opacity:1;fill:#4d4d4d;fill-opacity:1;stroke:#1a1a1a;stroke-width:0.15875;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n             id=\"path4702-4-6\"\n             cx=\"497.12134\"\n             cy=\"-495.18689\"\n             r=\"11.22532\" />\n          <circle\n             style=\"opacity:1;fill:#4d4d4d;fill-opacity:1;stroke:#1a1a1a;stroke-width:0.1103158;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n             id=\"path4702-8-6-0\"\n             cx=\"497.06393\"\n             cy=\"-495.13406\"\n             r=\"7.8005037\" />\n        </g>\n        <g\n           style=\"fill:#4d4d4d;fill-opacity:1\"\n           id=\"g4731-5-1-2\"\n           transform=\"translate(-47.004788,114.42073)\">\n          <circle\n             style=\"opacity:1;fill:#4d4d4d;fill-opacity:1;stroke:#1a1a1a;stroke-width:0.15875;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n             id=\"path4702-4-6-3\"\n             cx=\"497.12134\"\n             cy=\"-495.18689\"\n             r=\"11.22532\" />\n          <circle\n             style=\"opacity:1;fill:#4d4d4d;fill-opacity:1;stroke:#1a1a1a;stroke-width:0.1103158;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n             id=\"path4702-8-6-0-2\"\n             cx=\"497.06393\"\n             cy=\"-495.13406\"\n             r=\"7.8005037\" />\n        </g>\n        <g\n           style=\"fill:#4d4d4d;fill-opacity:1\"\n           id=\"g4731-5-8\"\n           transform=\"translate(-47.197684,152.56031)\">\n          <circle\n             style=\"opacity:1;fill:#4d4d4d;fill-opacity:1;stroke:#1a1a1a;stroke-width:0.15875;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n             id=\"path4702-4-8\"\n             cx=\"497.12134\"\n             cy=\"-495.18689\"\n             r=\"11.22532\" />\n          <circle\n             style=\"opacity:1;fill:#4d4d4d;fill-opacity:1;stroke:#1a1a1a;stroke-width:0.1103158;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n             id=\"path4702-8-6-56\"\n             cx=\"497.06393\"\n             cy=\"-495.13406\"\n             r=\"7.8005037\" />\n        </g>\n        <g\n           style=\"fill:#4d4d4d;fill-opacity:1\"\n           id=\"g4731-5-7-8\"\n           transform=\"translate(-47.386158,186.9267)\">\n          <circle\n             style=\"opacity:1;fill:#4d4d4d;fill-opacity:1;stroke:#1a1a1a;stroke-width:0.15875;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n             id=\"path4702-4-4-5\"\n             cx=\"497.12134\"\n             cy=\"-495.18689\"\n             r=\"11.22532\" />\n          <circle\n             style=\"opacity:1;fill:#4d4d4d;fill-opacity:1;stroke:#1a1a1a;stroke-width:0.1103158;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n             id=\"path4702-8-6-5-9\"\n             cx=\"497.06393\"\n             cy=\"-495.13406\"\n             r=\"7.8005037\" />\n        </g>\n        <path\n           id=\"path1380-0-9\"\n           style=\"fill:#808080;fill-rule:evenodd;stroke-width:0.07888348\"\n           d=\"m 417.17884,-432.97558 h 399.99999 v -20 H 417.17884 Z\" />\n        <g\n           style=\"fill:#4d4d4d;fill-opacity:1\"\n           id=\"g4731-5-1-8\"\n           transform=\"translate(287.10274,77.498822)\">\n          <circle\n             style=\"opacity:1;fill:#4d4d4d;fill-opacity:1;stroke:#1a1a1a;stroke-width:0.15875;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n             id=\"path4702-4-6-7\"\n             cx=\"497.12134\"\n             cy=\"-495.18689\"\n             r=\"11.22532\" />\n          <circle\n             style=\"opacity:1;fill:#4d4d4d;fill-opacity:1;stroke:#1a1a1a;stroke-width:0.1103158;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n             id=\"path4702-8-6-0-3\"\n             cx=\"497.06393\"\n             cy=\"-495.13406\"\n             r=\"7.8005037\" />\n        </g>\n        <g\n           style=\"fill:#4d4d4d;fill-opacity:1\"\n           id=\"g4731-5-1-2-5\"\n           transform=\"translate(287.21667,114.05752)\">\n          <circle\n             style=\"opacity:1;fill:#4d4d4d;fill-opacity:1;stroke:#1a1a1a;stroke-width:0.15875;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n             id=\"path4702-4-6-3-8\"\n             cx=\"497.12134\"\n             cy=\"-495.18689\"\n             r=\"11.22532\" />\n          <circle\n             style=\"opacity:1;fill:#4d4d4d;fill-opacity:1;stroke:#1a1a1a;stroke-width:0.1103158;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n             id=\"path4702-8-6-0-2-2\"\n             cx=\"497.06393\"\n             cy=\"-495.13406\"\n             r=\"7.8005037\" />\n        </g>\n        <g\n           style=\"fill:#4d4d4d;fill-opacity:1\"\n           id=\"g4731-5-8-1\"\n           transform=\"translate(287.02376,152.1971)\">\n          <circle\n             style=\"opacity:1;fill:#4d4d4d;fill-opacity:1;stroke:#1a1a1a;stroke-width:0.15875;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n             id=\"path4702-4-8-9\"\n             cx=\"497.12134\"\n             cy=\"-495.18689\"\n             r=\"11.22532\" />\n          <circle\n             style=\"opacity:1;fill:#4d4d4d;fill-opacity:1;stroke:#1a1a1a;stroke-width:0.1103158;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n             id=\"path4702-8-6-56-4\"\n             cx=\"497.06393\"\n             cy=\"-495.13406\"\n             r=\"7.8005037\" />\n        </g>\n        <g\n           style=\"fill:#4d4d4d;fill-opacity:1\"\n           id=\"g4731-5-7-8-6\"\n           transform=\"translate(286.83529,186.56349)\">\n          <circle\n             style=\"opacity:1;fill:#4d4d4d;fill-opacity:1;stroke:#1a1a1a;stroke-width:0.15875;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n             id=\"path4702-4-4-5-9\"\n             cx=\"497.12134\"\n             cy=\"-495.18689\"\n             r=\"11.22532\" />\n          <circle\n             style=\"opacity:1;fill:#4d4d4d;fill-opacity:1;stroke:#1a1a1a;stroke-width:0.1103158;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n             id=\"path4702-8-6-5-9-7\"\n             cx=\"497.06393\"\n             cy=\"-495.13406\"\n             r=\"7.8005037\" />\n        </g>\n      </g>\n      <rect\n         style=\"opacity:1;fill:#4d4d4d;fill-opacity:1;stroke:#1a1a1a;stroke-width:0.103048;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n         id=\"rect3909-2\"\n         width=\"19.893295\"\n         height=\"399.75128\"\n         x=\"-85.043716\"\n         y=\"-20.047852\" />\n    </g>\n  </g>\n</svg>\n"
      ],
      "type": "wood",
      "size": 2,
      "id": 3
    },
    {
      "images": [
        "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n<svg\n   xmlns:dc=\"http://purl.org/dc/elements/1.1/\"\n   xmlns:cc=\"http://creativecommons.org/ns#\"\n   xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\"\n   xmlns:svg=\"http://www.w3.org/2000/svg\"\n   xmlns=\"http://www.w3.org/2000/svg\"\n   width=\"444.44531mm\"\n   height=\"444.44443mm\"\n   viewBox=\"0 0 400.00079 399.99997\"\n   version=\"1.1\"\n   id=\"svg1372\">\n  <defs\n     id=\"defs1366\" />\n  <metadata\n     id=\"metadata1369\">\n    <rdf:RDF>\n      <cc:Work\n         rdf:about=\"\">\n        <dc:format>image/svg+xml</dc:format>\n        <dc:type\n           rdf:resource=\"http://purl.org/dc/dcmitype/StillImage\" />\n        <dc:title></dc:title>\n      </cc:Work>\n    </rdf:RDF>\n  </metadata>\n  <g\n     id=\"layer1\"\n     transform=\"translate(0,102.99999)\">\n    <path\n       d=\"m 0,297 h 399.98227 l 0.0185,-399.99999 H 0.017991 Z\"\n       style=\"fill:#8ec953;fill-rule:evenodd;stroke-width:0.35277742\"\n       id=\"path1051\" />\n  </g>\n</svg>\n"
      ],
      "type": "wood",
      "size": 1,
      "id": 4
    },
    {
      "images": [
        "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n<svg\n   xmlns:dc=\"http://purl.org/dc/elements/1.1/\"\n   xmlns:cc=\"http://creativecommons.org/ns#\"\n   xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\"\n   xmlns:svg=\"http://www.w3.org/2000/svg\"\n   xmlns=\"http://www.w3.org/2000/svg\"\n   id=\"svg8\"\n   version=\"1.1\"\n   viewBox=\"0 0 400 399.99997\"\n   height=\"399.99997mm\"\n   width=\"400mm\">\n  <defs\n     id=\"defs2\" />\n  <metadata\n     id=\"metadata5\">\n    <rdf:RDF>\n      <cc:Work\n         rdf:about=\"\">\n        <dc:format>image/svg+xml</dc:format>\n        <dc:type\n           rdf:resource=\"http://purl.org/dc/dcmitype/StillImage\" />\n        <dc:title></dc:title>\n      </cc:Work>\n    </rdf:RDF>\n  </metadata>\n  <g\n     transform=\"translate(113.82138,55.702394)\"\n     id=\"layer1\">\n    <g\n       transform=\"matrix(0.34396788,0,0,0.34422088,-4377.5068,4298.044)\"\n       id=\"Layer1002\">\n      <path\n         id=\"path144\"\n         style=\"fill:#cb3200;fill-rule:evenodd\"\n         d=\"m 12395.724,-12067.478 v 283.465 h 297.421 v -283.465 z\" />\n      <path\n         id=\"path146\"\n         style=\"fill:#cb3200;fill-rule:evenodd\"\n         d=\"m 13261.047,-12067.478 v 283.465 h 297.444 v -283.465 z\" />\n      <path\n         id=\"path148\"\n         style=\"fill:#cb3200;fill-rule:evenodd\"\n         d=\"m 12395.726,-12647.941 v 297.528 h 297.419 v -297.528 z\" />\n      <path\n         id=\"path150\"\n         style=\"fill:#cb3200;fill-rule:evenodd\"\n         d=\"m 13261.331,-12647.907 v 296.927 h 297 v -296.927 z\" />\n      <path\n         id=\"path152\"\n         style=\"fill:#cb3200;fill-rule:evenodd;stroke:#1b1918;stroke-width:28.3465004;stroke-linecap:butt;stroke-linejoin:miter;stroke-dasharray:none\"\n         d=\"m 12409.765,-11783.711 v 283.464 h 566.929 v -283.464 z\" />\n      <path\n         id=\"path154\"\n         style=\"fill:#cb3200;fill-rule:evenodd;stroke:#1b1918;stroke-width:28.3465004;stroke-linecap:butt;stroke-linejoin:miter;stroke-dasharray:none\"\n         d=\"m 12977.299,-11783.711 v 283.464 h 566.929 v -283.464 z\" />\n      <path\n         id=\"path156\"\n         style=\"fill:#cb3200;fill-rule:evenodd;stroke:#1b1918;stroke-width:28.3465004;stroke-linecap:butt;stroke-linejoin:miter;stroke-dasharray:none\"\n         d=\"m 12693.466,-12067.544 v 283.464 h 566.929 v -283.464 z\" />\n      <path\n         id=\"path158\"\n         style=\"fill:#cb3200;fill-rule:evenodd;stroke:#1b1918;stroke-width:28.3465004;stroke-linecap:butt;stroke-linejoin:miter;stroke-dasharray:none\"\n         d=\"m 12409.765,-12350.112 v 283.465 h 566.929 v -283.465 z\" />\n      <path\n         id=\"path160\"\n         style=\"fill:#cb3200;fill-rule:evenodd;stroke:#1b1918;stroke-width:28.3465004;stroke-linecap:butt;stroke-linejoin:miter;stroke-dasharray:none\"\n         d=\"m 12977.299,-12350.112 v 283.465 h 566.929 v -283.465 z\" />\n      <path\n         id=\"path162\"\n         style=\"fill:#cb3200;fill-rule:evenodd;stroke:#1b1918;stroke-width:28.3465004;stroke-linecap:butt;stroke-linejoin:miter;stroke-dasharray:none\"\n         d=\"m 12693.466,-12633.945 v 283.465 h 566.929 v -283.465 z\" />\n    </g>\n  </g>\n</svg>\n"
      ],
      "type": "stone",
      "size": 1,
      "id": 5
    },
    {
      "images": [
        "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n<svg\n   xmlns:dc=\"http://purl.org/dc/elements/1.1/\"\n   xmlns:cc=\"http://creativecommons.org/ns#\"\n   xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\"\n   xmlns:svg=\"http://www.w3.org/2000/svg\"\n   xmlns=\"http://www.w3.org/2000/svg\"\n   id=\"svg4037\"\n   version=\"1.1\"\n   viewBox=\"0 0 400 400\"\n   height=\"400mm\"\n   width=\"400mm\">\n  <defs\n     id=\"defs4031\" />\n  <metadata\n     id=\"metadata4034\">\n    <rdf:RDF>\n      <cc:Work\n         rdf:about=\"\">\n        <dc:format>image/svg+xml</dc:format>\n        <dc:type\n           rdf:resource=\"http://purl.org/dc/dcmitype/StillImage\" />\n        <dc:title></dc:title>\n      </cc:Work>\n    </rdf:RDF>\n  </metadata>\n  <g\n     transform=\"translate(1.4752746e-6,103)\"\n     id=\"layer1\">\n    <g\n       transform=\"rotate(-90,116.03869,95.86607)\"\n       id=\"g5243\">\n      <g\n         id=\"g5058\"\n         transform=\"matrix(0.99981771,0,0,0.99963581,-33.954254,433.70668)\">\n        <path\n           id=\"path1380-4\"\n           style=\"fill:#808080;fill-rule:evenodd;stroke-width:0.35277766\"\n           d=\"M -51.077382,-454.04466 V -54.044668 H 348.92262 V -454.04466 Z\" />\n        <rect\n           y=\"-453.89868\"\n           x=\"-11.091877\"\n           height=\"399.85391\"\n           width=\"39.98539\"\n           id=\"rect3909-2-45\"\n           style=\"opacity:1;fill:#4d4d4d;fill-opacity:1;stroke:#1a1a1a;stroke-width:0.14611426;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\" />\n        <rect\n           y=\"-453.89874\"\n           x=\"68.878883\"\n           height=\"399.85391\"\n           width=\"39.98539\"\n           id=\"rect3909-2-0-7\"\n           style=\"opacity:1;fill:#4d4d4d;fill-opacity:1;stroke:#1a1a1a;stroke-width:0.14611426;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\" />\n        <rect\n           y=\"-453.8988\"\n           x=\"148.84967\"\n           height=\"399.85391\"\n           width=\"39.98539\"\n           id=\"rect3909-2-4-4\"\n           style=\"opacity:1;fill:#4d4d4d;fill-opacity:1;stroke:#1a1a1a;stroke-width:0.14611426;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\" />\n        <rect\n           y=\"-453.89886\"\n           x=\"228.82045\"\n           height=\"399.85391\"\n           width=\"39.98539\"\n           id=\"rect3909-2-0-5-6\"\n           style=\"opacity:1;fill:#4d4d4d;fill-opacity:1;stroke:#1a1a1a;stroke-width:0.14611426;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\" />\n        <rect\n           y=\"-453.89893\"\n           x=\"308.79123\"\n           height=\"399.85391\"\n           width=\"39.98539\"\n           id=\"rect3909-2-0-5-5-7\"\n           style=\"opacity:1;fill:#4d4d4d;fill-opacity:1;stroke:#1a1a1a;stroke-width:0.14611426;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\" />\n      </g>\n      <g\n         id=\"g5050\"\n         transform=\"matrix(0,-0.99963581,-0.99981771,0,-138.11961,796.85429)\">\n        <path\n           id=\"path1380-6\"\n           style=\"fill:#b3b3b3;fill-rule:evenodd;stroke-width:0.24945147\"\n           d=\"m 417.17884,-252.97558 h 399.99999 v -200 H 417.17884 Z\" />\n        <path\n           id=\"path1380-0\"\n           style=\"fill:#808080;fill-rule:evenodd;stroke-width:0.11155809\"\n           d=\"m 417.17884,-252.97558 h 399.99999 v -40 H 417.17884 Z\" />\n        <path\n           id=\"path1380-0-7\"\n           style=\"fill:#808080;fill-rule:evenodd;stroke-width:0.05577904\"\n           d=\"m 437.17884,-252.97558 v -200 h -20 v 200 z\" />\n        <path\n           id=\"path1380-0-7-6\"\n           style=\"fill:#808080;fill-rule:evenodd;stroke-width:0.05577904\"\n           d=\"m 817.17883,-252.97558 v -200 h -20 v 200 z\" />\n        <path\n           id=\"path1380-0-6\"\n           style=\"fill:#4d4d4d;fill-rule:evenodd;stroke-width:0.07888348\"\n           d=\"m 417.17884,-252.97558 h 399.99999 v -20 H 417.17884 Z\" />\n        <g\n           style=\"fill:#4d4d4d;fill-opacity:1\"\n           id=\"g4731-5-1\"\n           transform=\"translate(-47.118712,77.86203)\">\n          <circle\n             style=\"opacity:1;fill:#4d4d4d;fill-opacity:1;stroke:#1a1a1a;stroke-width:0.15875;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n             id=\"path4702-4-6\"\n             cx=\"497.12134\"\n             cy=\"-495.18689\"\n             r=\"11.22532\" />\n          <circle\n             style=\"opacity:1;fill:#4d4d4d;fill-opacity:1;stroke:#1a1a1a;stroke-width:0.1103158;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n             id=\"path4702-8-6-0\"\n             cx=\"497.06393\"\n             cy=\"-495.13406\"\n             r=\"7.8005037\" />\n        </g>\n        <g\n           style=\"fill:#4d4d4d;fill-opacity:1\"\n           id=\"g4731-5-1-2\"\n           transform=\"translate(-47.004788,114.42073)\">\n          <circle\n             style=\"opacity:1;fill:#4d4d4d;fill-opacity:1;stroke:#1a1a1a;stroke-width:0.15875;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n             id=\"path4702-4-6-3\"\n             cx=\"497.12134\"\n             cy=\"-495.18689\"\n             r=\"11.22532\" />\n          <circle\n             style=\"opacity:1;fill:#4d4d4d;fill-opacity:1;stroke:#1a1a1a;stroke-width:0.1103158;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n             id=\"path4702-8-6-0-2\"\n             cx=\"497.06393\"\n             cy=\"-495.13406\"\n             r=\"7.8005037\" />\n        </g>\n        <g\n           style=\"fill:#4d4d4d;fill-opacity:1\"\n           id=\"g4731-5-8\"\n           transform=\"translate(-47.197684,152.56031)\">\n          <circle\n             style=\"opacity:1;fill:#4d4d4d;fill-opacity:1;stroke:#1a1a1a;stroke-width:0.15875;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n             id=\"path4702-4-8\"\n             cx=\"497.12134\"\n             cy=\"-495.18689\"\n             r=\"11.22532\" />\n          <circle\n             style=\"opacity:1;fill:#4d4d4d;fill-opacity:1;stroke:#1a1a1a;stroke-width:0.1103158;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n             id=\"path4702-8-6-56\"\n             cx=\"497.06393\"\n             cy=\"-495.13406\"\n             r=\"7.8005037\" />\n        </g>\n        <g\n           style=\"fill:#4d4d4d;fill-opacity:1\"\n           id=\"g4731-5-7-8\"\n           transform=\"translate(-47.386158,186.9267)\">\n          <circle\n             style=\"opacity:1;fill:#4d4d4d;fill-opacity:1;stroke:#1a1a1a;stroke-width:0.15875;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n             id=\"path4702-4-4-5\"\n             cx=\"497.12134\"\n             cy=\"-495.18689\"\n             r=\"11.22532\" />\n          <circle\n             style=\"opacity:1;fill:#4d4d4d;fill-opacity:1;stroke:#1a1a1a;stroke-width:0.1103158;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n             id=\"path4702-8-6-5-9\"\n             cx=\"497.06393\"\n             cy=\"-495.13406\"\n             r=\"7.8005037\" />\n        </g>\n        <path\n           id=\"path1380-0-9\"\n           style=\"fill:#808080;fill-rule:evenodd;stroke-width:0.07888348\"\n           d=\"m 417.17884,-432.97558 h 399.99999 v -20 H 417.17884 Z\" />\n        <g\n           style=\"fill:#4d4d4d;fill-opacity:1\"\n           id=\"g4731-5-1-8\"\n           transform=\"translate(287.10274,77.498822)\">\n          <circle\n             style=\"opacity:1;fill:#4d4d4d;fill-opacity:1;stroke:#1a1a1a;stroke-width:0.15875;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n             id=\"path4702-4-6-7\"\n             cx=\"497.12134\"\n             cy=\"-495.18689\"\n             r=\"11.22532\" />\n          <circle\n             style=\"opacity:1;fill:#4d4d4d;fill-opacity:1;stroke:#1a1a1a;stroke-width:0.1103158;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n             id=\"path4702-8-6-0-3\"\n             cx=\"497.06393\"\n             cy=\"-495.13406\"\n             r=\"7.8005037\" />\n        </g>\n        <g\n           style=\"fill:#4d4d4d;fill-opacity:1\"\n           id=\"g4731-5-1-2-5\"\n           transform=\"translate(287.21667,114.05752)\">\n          <circle\n             style=\"opacity:1;fill:#4d4d4d;fill-opacity:1;stroke:#1a1a1a;stroke-width:0.15875;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n             id=\"path4702-4-6-3-8\"\n             cx=\"497.12134\"\n             cy=\"-495.18689\"\n             r=\"11.22532\" />\n          <circle\n             style=\"opacity:1;fill:#4d4d4d;fill-opacity:1;stroke:#1a1a1a;stroke-width:0.1103158;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n             id=\"path4702-8-6-0-2-2\"\n             cx=\"497.06393\"\n             cy=\"-495.13406\"\n             r=\"7.8005037\" />\n        </g>\n        <g\n           style=\"fill:#4d4d4d;fill-opacity:1\"\n           id=\"g4731-5-8-1\"\n           transform=\"translate(287.02376,152.1971)\">\n          <circle\n             style=\"opacity:1;fill:#4d4d4d;fill-opacity:1;stroke:#1a1a1a;stroke-width:0.15875;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n             id=\"path4702-4-8-9\"\n             cx=\"497.12134\"\n             cy=\"-495.18689\"\n             r=\"11.22532\" />\n          <circle\n             style=\"opacity:1;fill:#4d4d4d;fill-opacity:1;stroke:#1a1a1a;stroke-width:0.1103158;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n             id=\"path4702-8-6-56-4\"\n             cx=\"497.06393\"\n             cy=\"-495.13406\"\n             r=\"7.8005037\" />\n        </g>\n        <g\n           style=\"fill:#4d4d4d;fill-opacity:1\"\n           id=\"g4731-5-7-8-6\"\n           transform=\"translate(286.83529,186.56349)\">\n          <circle\n             style=\"opacity:1;fill:#4d4d4d;fill-opacity:1;stroke:#1a1a1a;stroke-width:0.15875;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n             id=\"path4702-4-4-5-9\"\n             cx=\"497.12134\"\n             cy=\"-495.18689\"\n             r=\"11.22532\" />\n          <circle\n             style=\"opacity:1;fill:#4d4d4d;fill-opacity:1;stroke:#1a1a1a;stroke-width:0.1103158;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n             id=\"path4702-8-6-5-9-7\"\n             cx=\"497.06393\"\n             cy=\"-495.13406\"\n             r=\"7.8005037\" />\n        </g>\n      </g>\n      <rect\n         style=\"opacity:1;fill:#4d4d4d;fill-opacity:1;stroke:#1a1a1a;stroke-width:0.103048;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n         id=\"rect3909-2\"\n         width=\"19.893295\"\n         height=\"399.75128\"\n         x=\"-85.043716\"\n         y=\"-20.047852\" />\n    </g>\n  </g>\n</svg>\n"
      ],
      "type": "spawner",
      "size": 2,
      "id": 6
    },
    {
      "images": [
        "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n<svg\n   xmlns:dc=\"http://purl.org/dc/elements/1.1/\"\n   xmlns:cc=\"http://creativecommons.org/ns#\"\n   xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\"\n   xmlns:svg=\"http://www.w3.org/2000/svg\"\n   xmlns=\"http://www.w3.org/2000/svg\"\n   id=\"svg1923\"\n   version=\"1.1\"\n   viewBox=\"0 0 400.00088 399.9989\"\n   height=\"399.9989mm\"\n   width=\"400.00089mm\">\n  <defs\n     id=\"defs1917\" />\n  <metadata\n     id=\"metadata1920\">\n    <rdf:RDF>\n      <cc:Work\n         rdf:about=\"\">\n        <dc:format>image/svg+xml</dc:format>\n        <dc:type\n           rdf:resource=\"http://purl.org/dc/dcmitype/StillImage\" />\n        <dc:title></dc:title>\n      </cc:Work>\n    </rdf:RDF>\n  </metadata>\n  <g\n     transform=\"translate(103.08524,38.60877)\"\n     id=\"layer1\">\n    <g\n       id=\"_1806279396304\"\n       style=\"clip-rule:evenodd;fill-rule:evenodd;image-rendering:optimizeQuality;shape-rendering:geometricPrecision;text-rendering:geometricPrecision\"\n       transform=\"matrix(0.00978592,0,0,0.00975581,-548.73776,385.1086)\">\n      <rect\n         class=\"fil2 str1\"\n         transform=\"matrix(0,-1.00093,1.09456,0,77707,-3637.99)\"\n         width=\"38439\"\n         height=\"7556\"\n         rx=\"1482\"\n         ry=\"1482\"\n         id=\"rect4139\"\n         x=\"0\"\n         y=\"0\"\n         style=\"fill:#7d8ea5;stroke:#2c2a29;stroke-width:800\" />\n      <rect\n         class=\"fil3 str1\"\n         transform=\"matrix(0,-0.81854,0.960114,0,77737.8,-4866.8)\"\n         width=\"1228\"\n         height=\"8551\"\n         rx=\"553\"\n         ry=\"553\"\n         id=\"rect4141\"\n         x=\"0\"\n         y=\"0\"\n         style=\"fill:#494848;stroke:#2c2a29;stroke-width:800\" />\n      <rect\n         class=\"fil3 str1\"\n         transform=\"matrix(0,-0.81854,0.960114,0,77737.8,-8716.71)\"\n         width=\"1228\"\n         height=\"8551\"\n         id=\"rect4143\"\n         x=\"0\"\n         y=\"0\"\n         style=\"fill:#494848;stroke:#2c2a29;stroke-width:800\" />\n      <rect\n         class=\"fil3 str1\"\n         transform=\"matrix(0,-0.81854,0.960114,0,77737.8,-12593.8)\"\n         width=\"1228\"\n         height=\"8551\"\n         id=\"rect4145\"\n         x=\"0\"\n         y=\"0\"\n         style=\"fill:#494848;stroke:#2c2a29;stroke-width:800\" />\n      <rect\n         class=\"fil3 str1\"\n         transform=\"matrix(0,-0.81854,0.960114,0,77737.8,-16519.4)\"\n         width=\"1228\"\n         height=\"8551\"\n         id=\"rect4147\"\n         x=\"0\"\n         y=\"0\"\n         style=\"fill:#494848;stroke:#2c2a29;stroke-width:800\" />\n      <rect\n         class=\"fil3 str1\"\n         transform=\"matrix(0,-0.81854,0.960114,0,77737.8,-20369.3)\"\n         width=\"1228\"\n         height=\"8551\"\n         id=\"rect4149\"\n         x=\"0\"\n         y=\"0\"\n         style=\"fill:#494848;stroke:#2c2a29;stroke-width:800\" />\n      <rect\n         class=\"fil3 str1\"\n         transform=\"matrix(0,-0.81854,0.960114,0,77737.8,-24246.4)\"\n         width=\"1228\"\n         height=\"8551\"\n         id=\"rect4151\"\n         x=\"0\"\n         y=\"0\"\n         style=\"fill:#494848;stroke:#2c2a29;stroke-width:800\" />\n      <rect\n         class=\"fil3 str1\"\n         transform=\"matrix(0,-0.81854,0.960114,0,77737.8,-28235.5)\"\n         width=\"1228\"\n         height=\"8551\"\n         id=\"rect4153\"\n         x=\"0\"\n         y=\"0\"\n         style=\"fill:#494848;stroke:#2c2a29;stroke-width:800\" />\n      <rect\n         class=\"fil3 str1\"\n         transform=\"matrix(0,-0.81854,0.960114,0,77737.8,-32085.4)\"\n         width=\"1228\"\n         height=\"8551\"\n         id=\"rect4155\"\n         x=\"0\"\n         y=\"0\"\n         style=\"fill:#494848;stroke:#2c2a29;stroke-width:800\" />\n      <rect\n         class=\"fil3 str1\"\n         transform=\"matrix(0,-0.81854,0.960114,0,77737.8,-35962.5)\"\n         width=\"1228\"\n         height=\"8551\"\n         id=\"rect4157\"\n         x=\"0\"\n         y=\"0\"\n         style=\"fill:#494848;stroke:#2c2a29;stroke-width:800\" />\n      <rect\n         class=\"fil3 str1\"\n         transform=\"matrix(0,-0.81854,0.960114,0,77737.8,-39903.1)\"\n         width=\"1228\"\n         height=\"8551\"\n         rx=\"509\"\n         ry=\"509\"\n         id=\"rect4159\"\n         x=\"0\"\n         y=\"0\"\n         style=\"fill:#494848;stroke:#2c2a29;stroke-width:800\" />\n      <rect\n         class=\"fil2 str1\"\n         transform=\"matrix(0,-1.00093,1.09456,0,45978,-3637.99)\"\n         width=\"38439\"\n         height=\"7556\"\n         rx=\"1482\"\n         ry=\"1482\"\n         id=\"rect4161\"\n         x=\"0\"\n         y=\"0\"\n         style=\"fill:#7d8ea5;stroke:#2c2a29;stroke-width:800\" />\n      <rect\n         class=\"fil3 str1\"\n         transform=\"matrix(0,-0.81854,0.960114,0,46008.8,-4866.8)\"\n         width=\"1228\"\n         height=\"8551\"\n         rx=\"553\"\n         ry=\"553\"\n         id=\"rect4163\"\n         x=\"0\"\n         y=\"0\"\n         style=\"fill:#494848;stroke:#2c2a29;stroke-width:800\" />\n      <rect\n         class=\"fil3 str1\"\n         transform=\"matrix(0,-0.81854,0.960114,0,46008.8,-8716.71)\"\n         width=\"1228\"\n         height=\"8551\"\n         id=\"rect4165\"\n         x=\"0\"\n         y=\"0\"\n         style=\"fill:#494848;stroke:#2c2a29;stroke-width:800\" />\n      <rect\n         class=\"fil3 str1\"\n         transform=\"matrix(0,-0.81854,0.960114,0,46008.8,-12593.8)\"\n         width=\"1228\"\n         height=\"8551\"\n         id=\"rect4167\"\n         x=\"0\"\n         y=\"0\"\n         style=\"fill:#494848;stroke:#2c2a29;stroke-width:800\" />\n      <rect\n         class=\"fil3 str1\"\n         transform=\"matrix(0,-0.81854,0.960114,0,46008.8,-16519.4)\"\n         width=\"1228\"\n         height=\"8551\"\n         id=\"rect4169\"\n         x=\"0\"\n         y=\"0\"\n         style=\"fill:#494848;stroke:#2c2a29;stroke-width:800\" />\n      <rect\n         class=\"fil3 str1\"\n         transform=\"matrix(0,-0.81854,0.960114,0,46008.8,-20369.3)\"\n         width=\"1228\"\n         height=\"8551\"\n         id=\"rect4171\"\n         x=\"0\"\n         y=\"0\"\n         style=\"fill:#494848;stroke:#2c2a29;stroke-width:800\" />\n      <rect\n         class=\"fil3 str1\"\n         transform=\"matrix(0,-0.81854,0.960114,0,46008.8,-24246.4)\"\n         width=\"1228\"\n         height=\"8551\"\n         id=\"rect4173\"\n         x=\"0\"\n         y=\"0\"\n         style=\"fill:#494848;stroke:#2c2a29;stroke-width:800\" />\n      <rect\n         class=\"fil3 str1\"\n         transform=\"matrix(0,-0.81854,0.960114,0,46008.8,-28235.5)\"\n         width=\"1228\"\n         height=\"8551\"\n         id=\"rect4175\"\n         x=\"0\"\n         y=\"0\"\n         style=\"fill:#494848;stroke:#2c2a29;stroke-width:800\" />\n      <rect\n         class=\"fil3 str1\"\n         transform=\"matrix(0,-0.81854,0.960114,0,46008.8,-32085.4)\"\n         width=\"1228\"\n         height=\"8551\"\n         id=\"rect4177\"\n         x=\"0\"\n         y=\"0\"\n         style=\"fill:#494848;stroke:#2c2a29;stroke-width:800\" />\n      <rect\n         class=\"fil3 str1\"\n         transform=\"matrix(0,-0.81854,0.960114,0,46008.8,-35962.5)\"\n         width=\"1228\"\n         height=\"8551\"\n         id=\"rect4179\"\n         x=\"0\"\n         y=\"0\"\n         style=\"fill:#494848;stroke:#2c2a29;stroke-width:800\" />\n      <rect\n         class=\"fil3 str1\"\n         transform=\"matrix(0,-0.81854,0.960114,0,46008.8,-39903.1)\"\n         width=\"1228\"\n         height=\"8551\"\n         rx=\"509\"\n         ry=\"509\"\n         id=\"rect4181\"\n         x=\"0\"\n         y=\"0\"\n         style=\"fill:#494848;stroke:#2c2a29;stroke-width:800\" />\n      <polygon\n         class=\"fil10 str8\"\n         points=\"59716,-42932 59716,-2932 50253,-2932 50253,-42932 \"\n         id=\"polygon4183\"\n         style=\"fill:#c99806;stroke:#2b2a29;stroke-width:1000\" />\n      <rect\n         class=\"fil10 str8\"\n         transform=\"matrix(0,-1.00093,1.461,0,72379.5,-2931.68)\"\n         width=\"39963\"\n         height=\"6477\"\n         id=\"rect4185\"\n         x=\"0\"\n         y=\"0\"\n         style=\"fill:#c99806;stroke:#2b2a29;stroke-width:1000\" />\n      <polygon\n         class=\"fil11 str8\"\n         points=\"78409,-41604 78409,-8804 53499,-8804 53499,-41604 \"\n         id=\"polygon4187\"\n         style=\"fill:#cc9a00;stroke:#2b2a29;stroke-width:1000\" />\n      <rect\n         class=\"fil7\"\n         x=\"58164\"\n         y=\"-40653\"\n         width=\"1120\"\n         height=\"4892\"\n         rx=\"438\"\n         ry=\"275\"\n         id=\"rect4189\"\n         style=\"fill:#2b2a29\" />\n      <rect\n         class=\"fil7\"\n         x=\"59905\"\n         y=\"-40653\"\n         width=\"1120\"\n         height=\"4892\"\n         rx=\"438\"\n         ry=\"275\"\n         id=\"rect4191\"\n         style=\"fill:#2b2a29\" />\n      <rect\n         class=\"fil7\"\n         x=\"61587\"\n         y=\"-40653\"\n         width=\"1120\"\n         height=\"4892\"\n         rx=\"438\"\n         ry=\"275\"\n         id=\"rect4193\"\n         style=\"fill:#2b2a29\" />\n      <rect\n         class=\"fil7\"\n         x=\"63092\"\n         y=\"-40653\"\n         width=\"1120\"\n         height=\"4892\"\n         rx=\"438\"\n         ry=\"275\"\n         id=\"rect4195\"\n         style=\"fill:#2b2a29\" />\n      <rect\n         class=\"fil7\"\n         x=\"64744\"\n         y=\"-40653\"\n         width=\"1120\"\n         height=\"4892\"\n         rx=\"438\"\n         ry=\"275\"\n         id=\"rect4197\"\n         style=\"fill:#2b2a29\" />\n      <rect\n         class=\"fil7\"\n         x=\"66331\"\n         y=\"-40653\"\n         width=\"1120\"\n         height=\"4892\"\n         rx=\"438\"\n         ry=\"275\"\n         id=\"rect4199\"\n         style=\"fill:#2b2a29\" />\n      <rect\n         class=\"fil7\"\n         x=\"68072\"\n         y=\"-40653\"\n         width=\"1120\"\n         height=\"4892\"\n         rx=\"438\"\n         ry=\"275\"\n         id=\"rect4201\"\n         style=\"fill:#2b2a29\" />\n      <rect\n         class=\"fil7\"\n         x=\"69754\"\n         y=\"-40653\"\n         width=\"1120\"\n         height=\"4892\"\n         rx=\"438\"\n         ry=\"275\"\n         id=\"rect4203\"\n         style=\"fill:#2b2a29\" />\n      <rect\n         class=\"fil7\"\n         x=\"71259\"\n         y=\"-40653\"\n         width=\"1120\"\n         height=\"4892\"\n         rx=\"438\"\n         ry=\"275\"\n         id=\"rect4205\"\n         style=\"fill:#2b2a29\" />\n      <rect\n         class=\"fil7\"\n         x=\"72911\"\n         y=\"-40653\"\n         width=\"1120\"\n         height=\"4892\"\n         rx=\"438\"\n         ry=\"275\"\n         id=\"rect4207\"\n         style=\"fill:#2b2a29\" />\n      <polygon\n         class=\"fil12\"\n         points=\"77865,-9284 75351,-14119 56527,-14119 54013,-9284 \"\n         id=\"polygon4209\"\n         style=\"fill:#fec000;fill-opacity:0.18823499\" />\n      <polygon\n         class=\"fil13\"\n         points=\"56521,-41132 56521,-14092 54048,-9348 54048,-41134 \"\n         id=\"polygon4211\"\n         style=\"fill:#a17900\" />\n      <polygon\n         class=\"fil13\"\n         points=\"75340,-41132 75340,-14092 77813,-9348 77813,-41134 \"\n         id=\"polygon4213\"\n         style=\"fill:#a17900\" />\n      <rect\n         class=\"fil11 str8\"\n         transform=\"matrix(0,-1.00093,1.09456,0,56159,-14360.4)\"\n         width=\"20659\"\n         height=\"17653\"\n         rx=\"3175\"\n         ry=\"3175\"\n         id=\"rect4215\"\n         x=\"0\"\n         y=\"0\"\n         style=\"fill:#cc9a00;stroke:#2b2a29;stroke-width:1000\" />\n      <ellipse\n         class=\"fil11 str8\"\n         transform=\"matrix(0,-1.20296,1.31549,0,65820.1,-24699.3)\"\n         rx=\"4657\"\n         ry=\"4445\"\n         id=\"ellipse4217\"\n         cx=\"0\"\n         cy=\"0\"\n         style=\"fill:#cc9a00;stroke:#2b2a29;stroke-width:1000\" />\n      <ellipse\n         class=\"fil11 str8\"\n         transform=\"matrix(0,-0.773333,0.845669,0,65820.1,-24699.3)\"\n         rx=\"4657\"\n         ry=\"4445\"\n         id=\"ellipse4219\"\n         cx=\"0\"\n         cy=\"0\"\n         style=\"fill:#cc9a00;stroke:#2b2a29;stroke-width:1000\" />\n      <rect\n         class=\"fil11 str8\"\n         transform=\"matrix(0,-1.00093,1.09456,0,64303.3,-5432.02)\"\n         width=\"10742\"\n         height=\"3016\"\n         rx=\"1111\"\n         ry=\"1111\"\n         id=\"rect4221\"\n         x=\"0\"\n         y=\"0\"\n         style=\"fill:#cc9a00;stroke:#2b2a29;stroke-width:1000\" />\n      <rect\n         class=\"fil11 str8\"\n         transform=\"matrix(0,-0.557719,1.67064,0,63434.5,-3254.46)\"\n         width=\"10742\"\n         height=\"3016\"\n         rx=\"1111\"\n         ry=\"1111\"\n         id=\"rect4223\"\n         x=\"0\"\n         y=\"0\"\n         style=\"fill:#cc9a00;stroke:#2b2a29;stroke-width:1000\" />\n      <rect\n         class=\"fil7\"\n         transform=\"matrix(0,-1.00297,0.970959,0,69128.1,-11714.4)\"\n         width=\"529\"\n         height=\"5292\"\n         id=\"rect4225\"\n         x=\"0\"\n         y=\"0\"\n         style=\"fill:#2b2a29\" />\n      <rect\n         class=\"fil7\"\n         transform=\"matrix(0,-1.00297,0.970959,0,57619,-11714.4)\"\n         width=\"529\"\n         height=\"5292\"\n         id=\"rect4227\"\n         x=\"0\"\n         y=\"0\"\n         style=\"fill:#2b2a29\" />\n    </g>\n  </g>\n</svg>\n"
      ],
      "type": "spawner",
      "size": 2,
      "id": 7
    }
  ],
  "map": {
    "name": "perekrestok",
    "sizes": {
      "layers": 2,
      "height": 20,
      "width": 20
    },
    "layers": [
      [
        {
          "coords": {
            "x": 0,
            "y": 0,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 1,
            "y": 0,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 2,
            "y": 0,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 3,
            "y": 0,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 4,
            "y": 0,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 5,
            "y": 0,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 6,
            "y": 0,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 7,
            "y": 0,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 8,
            "y": 0,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 9,
            "y": 0,
            "z": 0
          },
          "size": 1,
          "tile_id": 1,
          "rotate": 2
        },
        {
          "coords": {
            "x": 10,
            "y": 0,
            "z": 0
          },
          "size": 1,
          "tile_id": 1,
          "rotate": 0
        },
        {
          "coords": {
            "x": 11,
            "y": 0,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 12,
            "y": 0,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 13,
            "y": 0,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 14,
            "y": 0,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 15,
            "y": 0,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 16,
            "y": 0,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 17,
            "y": 0,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 18,
            "y": 0,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 19,
            "y": 0,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 0,
            "y": 1,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 1,
            "y": 1,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 2,
            "y": 1,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 3,
            "y": 1,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 4,
            "y": 1,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 5,
            "y": 1,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 6,
            "y": 1,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 7,
            "y": 1,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 8,
            "y": 1,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 9,
            "y": 1,
            "z": 0
          },
          "size": 1,
          "tile_id": 1,
          "rotate": 2
        },
        {
          "coords": {
            "x": 10,
            "y": 1,
            "z": 0
          },
          "size": 1,
          "tile_id": 1,
          "rotate": 0
        },
        {
          "coords": {
            "x": 11,
            "y": 1,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 12,
            "y": 1,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 13,
            "y": 1,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 14,
            "y": 1,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 15,
            "y": 1,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 16,
            "y": 1,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 17,
            "y": 1,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 18,
            "y": 1,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 19,
            "y": 1,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 0,
            "y": 2,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 1,
            "y": 2,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 2,
            "y": 2,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 3,
            "y": 2,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 4,
            "y": 2,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 5,
            "y": 2,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 6,
            "y": 2,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 7,
            "y": 2,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 8,
            "y": 2,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 9,
            "y": 2,
            "z": 0
          },
          "size": 1,
          "tile_id": 1,
          "rotate": 2
        },
        {
          "coords": {
            "x": 10,
            "y": 2,
            "z": 0
          },
          "size": 1,
          "tile_id": 1,
          "rotate": 0
        },
        {
          "coords": {
            "x": 11,
            "y": 2,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 12,
            "y": 2,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 13,
            "y": 2,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 14,
            "y": 2,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 15,
            "y": 2,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 16,
            "y": 2,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 17,
            "y": 2,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 18,
            "y": 2,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 19,
            "y": 2,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 0,
            "y": 3,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 1,
            "y": 3,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 2,
            "y": 3,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 3,
            "y": 3,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 4,
            "y": 3,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 5,
            "y": 3,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 6,
            "y": 3,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 7,
            "y": 3,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 8,
            "y": 3,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 9,
            "y": 3,
            "z": 0
          },
          "size": 1,
          "tile_id": 1,
          "rotate": 2
        },
        {
          "coords": {
            "x": 10,
            "y": 3,
            "z": 0
          },
          "size": 1,
          "tile_id": 1,
          "rotate": 0
        },
        {
          "coords": {
            "x": 11,
            "y": 3,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 12,
            "y": 3,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 13,
            "y": 3,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 14,
            "y": 3,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 15,
            "y": 3,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 16,
            "y": 3,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 17,
            "y": 3,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 18,
            "y": 3,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 19,
            "y": 3,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 0,
            "y": 4,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 1,
            "y": 4,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 2,
            "y": 4,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 3,
            "y": 4,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 4,
            "y": 4,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 5,
            "y": 4,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 6,
            "y": 4,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 7,
            "y": 4,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 8,
            "y": 4,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 9,
            "y": 4,
            "z": 0
          },
          "size": 1,
          "tile_id": 1,
          "rotate": 2
        },
        {
          "coords": {
            "x": 10,
            "y": 4,
            "z": 0
          },
          "size": 1,
          "tile_id": 1,
          "rotate": 0
        },
        {
          "coords": {
            "x": 11,
            "y": 4,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 12,
            "y": 4,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 13,
            "y": 4,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 14,
            "y": 4,
            "z": 0
          },
          "size": 2,
          "tile_id": 3,
          "rotate": 2
        },
        {
          "coords": {
            "x": 16,
            "y": 4,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 17,
            "y": 4,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 18,
            "y": 4,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 19,
            "y": 4,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 0,
            "y": 5,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 1,
            "y": 5,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 2,
            "y": 5,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 3,
            "y": 5,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 4,
            "y": 5,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 5,
            "y": 5,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 6,
            "y": 5,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 7,
            "y": 5,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 8,
            "y": 5,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 9,
            "y": 5,
            "z": 0
          },
          "size": 1,
          "tile_id": 1,
          "rotate": 2
        },
        {
          "coords": {
            "x": 10,
            "y": 5,
            "z": 0
          },
          "size": 1,
          "tile_id": 1,
          "rotate": 0
        },
        {
          "coords": {
            "x": 11,
            "y": 5,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 12,
            "y": 5,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 13,
            "y": 5,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 16,
            "y": 5,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 17,
            "y": 5,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 18,
            "y": 5,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 19,
            "y": 5,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 0,
            "y": 6,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 1,
            "y": 6,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 2,
            "y": 6,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 3,
            "y": 6,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 4,
            "y": 6,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 5,
            "y": 6,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 6,
            "y": 6,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 7,
            "y": 6,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 8,
            "y": 6,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 9,
            "y": 6,
            "z": 0
          },
          "size": 1,
          "tile_id": 1,
          "rotate": 2
        },
        {
          "coords": {
            "x": 10,
            "y": 6,
            "z": 0
          },
          "size": 1,
          "tile_id": 1,
          "rotate": 0
        },
        {
          "coords": {
            "x": 11,
            "y": 6,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 12,
            "y": 6,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 13,
            "y": 6,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 14,
            "y": 6,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 15,
            "y": 6,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 16,
            "y": 6,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 17,
            "y": 6,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 18,
            "y": 6,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 19,
            "y": 6,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 0,
            "y": 7,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 1,
            "y": 7,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 2,
            "y": 7,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 3,
            "y": 7,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 4,
            "y": 7,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 5,
            "y": 7,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 6,
            "y": 7,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 7,
            "y": 7,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 8,
            "y": 7,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 9,
            "y": 7,
            "z": 0
          },
          "size": 1,
          "tile_id": 1,
          "rotate": 2
        },
        {
          "coords": {
            "x": 10,
            "y": 7,
            "z": 0
          },
          "size": 1,
          "tile_id": 1,
          "rotate": 0
        },
        {
          "coords": {
            "x": 11,
            "y": 7,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 12,
            "y": 7,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 13,
            "y": 7,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 14,
            "y": 7,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 15,
            "y": 7,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 16,
            "y": 7,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 17,
            "y": 7,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 18,
            "y": 7,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 19,
            "y": 7,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 0,
            "y": 8,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 1,
            "y": 8,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 2,
            "y": 8,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 3,
            "y": 8,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 4,
            "y": 8,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 5,
            "y": 8,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 6,
            "y": 8,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 7,
            "y": 8,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 8,
            "y": 8,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 9,
            "y": 8,
            "z": 0
          },
          "size": 1,
          "tile_id": 1,
          "rotate": 2
        },
        {
          "coords": {
            "x": 10,
            "y": 8,
            "z": 0
          },
          "size": 1,
          "tile_id": 1,
          "rotate": 0
        },
        {
          "coords": {
            "x": 11,
            "y": 8,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 12,
            "y": 8,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 13,
            "y": 8,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 14,
            "y": 8,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 15,
            "y": 8,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 16,
            "y": 8,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 17,
            "y": 8,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 18,
            "y": 8,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 19,
            "y": 8,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 0,
            "y": 9,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 1,
            "y": 9,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 2,
            "y": 9,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 3,
            "y": 9,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 4,
            "y": 9,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 5,
            "y": 9,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 6,
            "y": 9,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 7,
            "y": 9,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 8,
            "y": 9,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 9,
            "y": 9,
            "z": 0
          },
          "size": 1,
          "tile_id": 1,
          "rotate": 2
        },
        {
          "coords": {
            "x": 10,
            "y": 9,
            "z": 0
          },
          "size": 1,
          "tile_id": 1,
          "rotate": 0
        },
        {
          "coords": {
            "x": 11,
            "y": 9,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 12,
            "y": 9,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 13,
            "y": 9,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 14,
            "y": 9,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 15,
            "y": 9,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 16,
            "y": 9,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 17,
            "y": 9,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 18,
            "y": 9,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 19,
            "y": 9,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 0,
            "y": 10,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 1,
            "y": 10,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 2,
            "y": 10,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 3,
            "y": 10,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 4,
            "y": 10,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 5,
            "y": 10,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 6,
            "y": 10,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 7,
            "y": 10,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 8,
            "y": 10,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 9,
            "y": 10,
            "z": 0
          },
          "size": 1,
          "tile_id": 1,
          "rotate": 2
        },
        {
          "coords": {
            "x": 10,
            "y": 10,
            "z": 0
          },
          "size": 1,
          "tile_id": 1,
          "rotate": 0
        },
        {
          "coords": {
            "x": 11,
            "y": 10,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 12,
            "y": 10,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 13,
            "y": 10,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 14,
            "y": 10,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 15,
            "y": 10,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 16,
            "y": 10,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 17,
            "y": 10,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 18,
            "y": 10,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 19,
            "y": 10,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 0,
            "y": 11,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 1,
            "y": 11,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 2,
            "y": 11,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 3,
            "y": 11,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 4,
            "y": 11,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 5,
            "y": 11,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 6,
            "y": 11,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 7,
            "y": 11,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 8,
            "y": 11,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 9,
            "y": 11,
            "z": 0
          },
          "size": 1,
          "tile_id": 1,
          "rotate": 2
        },
        {
          "coords": {
            "x": 10,
            "y": 11,
            "z": 0
          },
          "size": 1,
          "tile_id": 1,
          "rotate": 0
        },
        {
          "coords": {
            "x": 11,
            "y": 11,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 12,
            "y": 11,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 13,
            "y": 11,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 14,
            "y": 11,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 15,
            "y": 11,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 16,
            "y": 11,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 17,
            "y": 11,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 18,
            "y": 11,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 19,
            "y": 11,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 0,
            "y": 12,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 1,
            "y": 12,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 2,
            "y": 12,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 3,
            "y": 12,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 4,
            "y": 12,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 5,
            "y": 12,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 6,
            "y": 12,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 7,
            "y": 12,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 8,
            "y": 12,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 9,
            "y": 12,
            "z": 0
          },
          "size": 1,
          "tile_id": 1,
          "rotate": 2
        },
        {
          "coords": {
            "x": 10,
            "y": 12,
            "z": 0
          },
          "size": 1,
          "tile_id": 1,
          "rotate": 0
        },
        {
          "coords": {
            "x": 11,
            "y": 12,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 12,
            "y": 12,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 13,
            "y": 12,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 14,
            "y": 12,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 15,
            "y": 12,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 16,
            "y": 12,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 17,
            "y": 12,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 18,
            "y": 12,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 19,
            "y": 12,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 0,
            "y": 13,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 1,
            "y": 13,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 2,
            "y": 13,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 3,
            "y": 13,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 4,
            "y": 13,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 5,
            "y": 13,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 6,
            "y": 13,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 7,
            "y": 13,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 8,
            "y": 13,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 9,
            "y": 13,
            "z": 0
          },
          "size": 1,
          "tile_id": 1,
          "rotate": 2
        },
        {
          "coords": {
            "x": 10,
            "y": 13,
            "z": 0
          },
          "size": 1,
          "tile_id": 1,
          "rotate": 0
        },
        {
          "coords": {
            "x": 11,
            "y": 13,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 12,
            "y": 13,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 13,
            "y": 13,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 14,
            "y": 13,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 15,
            "y": 13,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 16,
            "y": 13,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 17,
            "y": 13,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 18,
            "y": 13,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 19,
            "y": 13,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 0,
            "y": 14,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 1,
            "y": 14,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 2,
            "y": 14,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 3,
            "y": 14,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 4,
            "y": 14,
            "z": 0
          },
          "size": 2,
          "tile_id": 3,
          "rotate": 0
        },
        {
          "coords": {
            "x": 6,
            "y": 14,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 7,
            "y": 14,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 8,
            "y": 14,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 9,
            "y": 14,
            "z": 0
          },
          "size": 1,
          "tile_id": 1,
          "rotate": 2
        },
        {
          "coords": {
            "x": 10,
            "y": 14,
            "z": 0
          },
          "size": 1,
          "tile_id": 1,
          "rotate": 0
        },
        {
          "coords": {
            "x": 11,
            "y": 14,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 12,
            "y": 14,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 13,
            "y": 14,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 14,
            "y": 14,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 15,
            "y": 14,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 16,
            "y": 14,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 17,
            "y": 14,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 18,
            "y": 14,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 19,
            "y": 14,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 0,
            "y": 15,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 1,
            "y": 15,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 2,
            "y": 15,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 3,
            "y": 15,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 6,
            "y": 15,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 7,
            "y": 15,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 8,
            "y": 15,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 9,
            "y": 15,
            "z": 0
          },
          "size": 1,
          "tile_id": 1,
          "rotate": 2
        },
        {
          "coords": {
            "x": 10,
            "y": 15,
            "z": 0
          },
          "size": 1,
          "tile_id": 1,
          "rotate": 0
        },
        {
          "coords": {
            "x": 11,
            "y": 15,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 12,
            "y": 15,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 13,
            "y": 15,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 14,
            "y": 15,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 15,
            "y": 15,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 16,
            "y": 15,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 17,
            "y": 15,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 18,
            "y": 15,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 19,
            "y": 15,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 0,
            "y": 16,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 1,
            "y": 16,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 2,
            "y": 16,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 3,
            "y": 16,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 4,
            "y": 16,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 5,
            "y": 16,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 6,
            "y": 16,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 7,
            "y": 16,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 8,
            "y": 16,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 9,
            "y": 16,
            "z": 0
          },
          "size": 1,
          "tile_id": 1,
          "rotate": 2
        },
        {
          "coords": {
            "x": 10,
            "y": 16,
            "z": 0
          },
          "size": 1,
          "tile_id": 1,
          "rotate": 0
        },
        {
          "coords": {
            "x": 11,
            "y": 16,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 12,
            "y": 16,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 13,
            "y": 16,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 14,
            "y": 16,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 15,
            "y": 16,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 16,
            "y": 16,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 17,
            "y": 16,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 18,
            "y": 16,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 19,
            "y": 16,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 0,
            "y": 17,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 1,
            "y": 17,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 2,
            "y": 17,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 3,
            "y": 17,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 4,
            "y": 17,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 5,
            "y": 17,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 6,
            "y": 17,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 7,
            "y": 17,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 8,
            "y": 17,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 9,
            "y": 17,
            "z": 0
          },
          "size": 1,
          "tile_id": 1,
          "rotate": 2
        },
        {
          "coords": {
            "x": 10,
            "y": 17,
            "z": 0
          },
          "size": 1,
          "tile_id": 1,
          "rotate": 0
        },
        {
          "coords": {
            "x": 11,
            "y": 17,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 12,
            "y": 17,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 13,
            "y": 17,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 14,
            "y": 17,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 15,
            "y": 17,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 16,
            "y": 17,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 17,
            "y": 17,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 18,
            "y": 17,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 19,
            "y": 17,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 0,
            "y": 18,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 1,
            "y": 18,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 2,
            "y": 18,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 3,
            "y": 18,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 4,
            "y": 18,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 5,
            "y": 18,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 6,
            "y": 18,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 7,
            "y": 18,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 8,
            "y": 18,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 9,
            "y": 18,
            "z": 0
          },
          "size": 1,
          "tile_id": 1,
          "rotate": 2
        },
        {
          "coords": {
            "x": 10,
            "y": 18,
            "z": 0
          },
          "size": 1,
          "tile_id": 1,
          "rotate": 0
        },
        {
          "coords": {
            "x": 11,
            "y": 18,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 12,
            "y": 18,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 13,
            "y": 18,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 14,
            "y": 18,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 15,
            "y": 18,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 16,
            "y": 18,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 17,
            "y": 18,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 18,
            "y": 18,
            "z": 0
          },
          "size": 1,
          "tile_id": 4,
          "rotate": 0
        },
        {
          "coords": {
            "x": 19,
            "y": 18,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 0,
            "y": 19,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 1,
            "y": 19,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 2,
            "y": 19,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 3,
            "y": 19,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 4,
            "y": 19,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 5,
            "y": 19,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 6,
            "y": 19,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 7,
            "y": 19,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 8,
            "y": 19,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 9,
            "y": 19,
            "z": 0
          },
          "size": 1,
          "tile_id": 1,
          "rotate": 2
        },
        {
          "coords": {
            "x": 10,
            "y": 19,
            "z": 0
          },
          "size": 1,
          "tile_id": 1,
          "rotate": 0
        },
        {
          "coords": {
            "x": 11,
            "y": 19,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 12,
            "y": 19,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 13,
            "y": 19,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 14,
            "y": 19,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 15,
            "y": 19,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 16,
            "y": 19,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 17,
            "y": 19,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 18,
            "y": 19,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        },
        {
          "coords": {
            "x": 19,
            "y": 19,
            "z": 0
          },
          "size": 1,
          "tile_id": 2,
          "rotate": 0
        }
      ],
      [
        {
          "coords": {
            "x": 0,
            "y": 0,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 1,
            "y": 0,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 2,
            "y": 0,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 3,
            "y": 0,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 4,
            "y": 0,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 5,
            "y": 0,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 6,
            "y": 0,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 7,
            "y": 0,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 8,
            "y": 0,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 11,
            "y": 0,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 12,
            "y": 0,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 13,
            "y": 0,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 14,
            "y": 0,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 15,
            "y": 0,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 16,
            "y": 0,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 17,
            "y": 0,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 18,
            "y": 0,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 19,
            "y": 0,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 0,
            "y": 1,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 19,
            "y": 1,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 0,
            "y": 2,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 19,
            "y": 2,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 0,
            "y": 3,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 3,
            "y": 3,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 4,
            "y": 3,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 5,
            "y": 3,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 6,
            "y": 3,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 13,
            "y": 3,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 14,
            "y": 3,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 15,
            "y": 3,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 16,
            "y": 3,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 19,
            "y": 3,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 0,
            "y": 4,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 3,
            "y": 4,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 4,
            "y": 4,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 5,
            "y": 4,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 6,
            "y": 4,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 13,
            "y": 4,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 14,
            "y": 4,
            "z": 1
          },
          "size": 2,
          "tile_id": 6,
          "rotate": 0
        },
        {
          "coords": {
            "x": 16,
            "y": 4,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 19,
            "y": 4,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 0,
            "y": 5,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 3,
            "y": 5,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 4,
            "y": 5,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 5,
            "y": 5,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 6,
            "y": 5,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 13,
            "y": 5,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 16,
            "y": 5,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 19,
            "y": 5,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 0,
            "y": 6,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 3,
            "y": 6,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 4,
            "y": 6,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 5,
            "y": 6,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 6,
            "y": 6,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 13,
            "y": 6,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 14,
            "y": 6,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 15,
            "y": 6,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 16,
            "y": 6,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 19,
            "y": 6,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 0,
            "y": 7,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 19,
            "y": 7,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 0,
            "y": 8,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 7,
            "y": 8,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 8,
            "y": 8,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 11,
            "y": 8,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 12,
            "y": 8,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 19,
            "y": 8,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 0,
            "y": 9,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 1,
            "y": 9,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 2,
            "y": 9,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 3,
            "y": 9,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 4,
            "y": 9,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 7,
            "y": 9,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 8,
            "y": 9,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 11,
            "y": 9,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 12,
            "y": 9,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 15,
            "y": 9,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 16,
            "y": 9,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 17,
            "y": 9,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 18,
            "y": 9,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 19,
            "y": 9,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 0,
            "y": 10,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 1,
            "y": 10,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 2,
            "y": 10,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 3,
            "y": 10,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 4,
            "y": 10,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 7,
            "y": 10,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 8,
            "y": 10,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 11,
            "y": 10,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 12,
            "y": 10,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 15,
            "y": 10,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 16,
            "y": 10,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 17,
            "y": 10,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 18,
            "y": 10,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 19,
            "y": 10,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 0,
            "y": 11,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 7,
            "y": 11,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 8,
            "y": 11,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 11,
            "y": 11,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 12,
            "y": 11,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 19,
            "y": 11,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 0,
            "y": 12,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 19,
            "y": 12,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 0,
            "y": 13,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 3,
            "y": 13,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 4,
            "y": 13,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 5,
            "y": 13,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 6,
            "y": 13,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 13,
            "y": 13,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 14,
            "y": 13,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 15,
            "y": 13,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 16,
            "y": 13,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 19,
            "y": 13,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 0,
            "y": 14,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 3,
            "y": 14,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 4,
            "y": 14,
            "z": 1
          },
          "size": 2,
          "tile_id": 7,
          "rotate": 2
        },
        {
          "coords": {
            "x": 6,
            "y": 14,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 13,
            "y": 14,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 14,
            "y": 14,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 15,
            "y": 14,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 16,
            "y": 14,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 19,
            "y": 14,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 0,
            "y": 15,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 3,
            "y": 15,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 6,
            "y": 15,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 13,
            "y": 15,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 14,
            "y": 15,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 15,
            "y": 15,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 16,
            "y": 15,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 19,
            "y": 15,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 0,
            "y": 16,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 3,
            "y": 16,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 4,
            "y": 16,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 5,
            "y": 16,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 6,
            "y": 16,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 13,
            "y": 16,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 14,
            "y": 16,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 15,
            "y": 16,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 16,
            "y": 16,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 19,
            "y": 16,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 0,
            "y": 17,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 19,
            "y": 17,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 0,
            "y": 18,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 19,
            "y": 18,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 0,
            "y": 19,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 1,
            "y": 19,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 2,
            "y": 19,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 3,
            "y": 19,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 4,
            "y": 19,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 5,
            "y": 19,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 6,
            "y": 19,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 7,
            "y": 19,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 8,
            "y": 19,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 11,
            "y": 19,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 12,
            "y": 19,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 13,
            "y": 19,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 14,
            "y": 19,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 15,
            "y": 19,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 16,
            "y": 19,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 17,
            "y": 19,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 18,
            "y": 19,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        },
        {
          "coords": {
            "x": 19,
            "y": 19,
            "z": 1
          },
          "size": 1,
          "tile_id": 5,
          "rotate": 0
        }
      ]
    ]
  }
}
},{}],231:[function(require,module,exports){
const CrRouting = require("AsynCommun").CrRouter;
const CrCommun = require("AsynCommun").CrCommunicator;

const CrResources = require("ResCat.js");
const CrMap = require("./Map.js");
const CrBullets = require("./Bullets.js");
const CrBlocks = require("./Blocks.js");
const CrGamer = require("./actor_gamer.js");
const CrGameMode = require("./GameMode.js");

function CrSession(GamersData, Map_data, Destroy){
	var Param = {
		max_kills: 5
	}

//====================InitSession========================

	Map_data.resp = RespMap(Map_data);
	Map_data.size = Map_data.map.sizes.width;

	var ready = false;
	
	var Router = new CrRouting();
	var MapCommun = new CrCommun();
	var GameModeCommun = new CrCommun();
	var BulletsCommun = new CrCommun();
	var BlocksCommun = new CrCommun();
	var ResourcesCommun = new CrCommun();
	var PlayersManagerCommun = new CrCommun();

	Router(MapCommun, "Default");
	Router(GameModeCommun, "GameMode");
	Router(BulletsCommun, "Bullets");
	Router(BlocksCommun, "Blocks");
	Router(ResourcesCommun, "Resources");
	Router(PlayersManagerCommun, "PlayersManager");

	const resources = new CrResources();

	CrMap(MapCommun, Map_data);
	CrGameMode(GameModeCommun, Param);
	CrBullets(BulletsCommun);
	CrBlocks(BlocksCommun, JSON.stringify(Map_data));
	resources.connect(ResourcesCommun);
	
//====================PlayersManager===============================

	var Send = PlayersManagerCommun.connect(Input);

	var Gamers = Map_data.resp.map(function(resp, i){
		var GamerCommun = new CrCommun();
		Router(GamerCommun, i);
		return new CrGamer(GamerCommun);
	});
	
	var Len_Gamers = Gamers.length;
	var Ready_Gamers = 0;
	var Play_Gamers = 0;

	this.Connect = function(Client){
		console.info("Connecting gamer...");

		Client.data = GamersData[Client.login];
		
		if(Len_Gamers !== Ready_Gamers){
			Gamers[Ready_Gamers].Connect(Client);
			Ready_Gamers++;

			console.info("Connected " + Client.login);
		}
		else 
			Client.disconnect({action: "Stat", data: {Status: "Max gamers on map!"}});
	}

	function Input(mess){
		if(mess.action == "Connect")
			return;

		switch(mess.type){
			case "Tiles":  TilesInput(mess); break;
			case "Gamer": GamersInput(mess); break;
			case "Actor": SendPlayers(mess); break;
			default: throw new Error(JSON.stringify(mess), "", 4);
		}
	}

	function GamersInput(mess){
		switch(mess.action){
			case "Ready":  Ready(mess); break;
			default: throw new Error(JSON.stringify(mess), "", 4);
		}
	}

	function TilesInput(mess){
		SendPlayers(mess);
	}

	function Ready(mess){
		Play_Gamers++;
		console.info("Gamer N" + mess.id + " is ready.");

		if(Play_Gamers === Len_Gamers)
			Gamers.forEach(function(Gamer){Gamer.Ready()});
	}
	
	function DestroyGamer(index){
		Ready_Gamers[index].Destroy();
		delete Ready_Gamers[index];
		if(ready && Ready_Gamers.every(function(gamer){return !gamer;})) Destroy();
	}

	function SendPlayers(mess){
		Object.freeze(mess);
		Gamers.forEach(SendPlayer.bind(null, mess));
	}

	function SendPlayer(mess, player, i){
		player.Input(mess);
	}
	
}

function RespMap(map_data){
	return map_data.tiles.filter(
		(tile)=> (tile.type == "spawner")
	).map(GetTileCoords).filter((resp)=> resp.length)


	function GetTileCoords(tile){
		var layers = map_data.map.layers;
		var blocks = [];

		layers.forEach((layer)=>
			layer.forEach(function(block){
				if(tile.id == block.tile_id)
					blocks.push(block.coords)
			})
		);

		return blocks;
	}
}



module.exports = CrSession;

},{"./Blocks.js":223,"./Bullets.js":224,"./GameMode.js":225,"./Map.js":226,"./actor_gamer.js":228,"AsynCommun":20,"ResCat.js":21}]},{},[9])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL1BvcnRQcm9nL1dpbjY0L25vZGVfdjExL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIuLi8uLi8uLi9Qb3J0UHJvZy9XaW42NC9ub2RlX3YxMS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcGF0aC1icm93c2VyaWZ5L2luZGV4LmpzIiwiLi4vLi4vLi4vUG9ydFByb2cvV2luNjQvbm9kZV92MTEvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIi4uLy4uLy4uL1BvcnRQcm9nL1dpbjY0L25vZGVfdjExL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9wdW55Y29kZS9wdW55Y29kZS5qcyIsIi4uLy4uLy4uL1BvcnRQcm9nL1dpbjY0L25vZGVfdjExL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvZGVjb2RlLmpzIiwiLi4vLi4vLi4vUG9ydFByb2cvV2luNjQvbm9kZV92MTEvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9lbmNvZGUuanMiLCIuLi8uLi8uLi9Qb3J0UHJvZy9XaW42NC9ub2RlX3YxMS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2luZGV4LmpzIiwiLi4vLi4vLi4vUG9ydFByb2cvV2luNjQvbm9kZV92MTEvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3VybC91cmwuanMiLCIuLi8uLi8uLi9Qb3J0UHJvZy9XaW42NC9ub2RlX3YxMS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvdXJsL3V0aWwuanMiLCJicm9tYWluLmpzIiwiZGlzcGxheS5qcyIsImd1aS5qcyIsImtleWJvYXJkLmpzIiwiLi4vbGliL21vZi5qcyIsIi4uL2xpYi93c19jbGllbnQuanMiLCIuLi9ub2RlX21vZHVsZXMvQXN5bkNvbW11bi9Db21tdW4uanMiLCIuLi9ub2RlX21vZHVsZXMvQXN5bkNvbW11bi9Db25uZWN0b3IuanMiLCIuLi9ub2RlX21vZHVsZXMvQXN5bkNvbW11bi9Ib2FyZGVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0FzeW5Db21tdW4vTXVsdGlDb21tdW4uanMiLCIuLi9ub2RlX21vZHVsZXMvQXN5bkNvbW11bi9Sb3V0ZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvQXN5bkNvbW11bi9tYWluLmpzIiwiLi4vbm9kZV9tb2R1bGVzL1Jlc0NhdC5qcy9tYWluLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2JpdC10d2lkZGxlL3R3aWRkbGUuanMiLCIuLi9ub2RlX21vZHVsZXMvZWFyY3V0L3NyYy9lYXJjdXQuanMiLCIuLi9ub2RlX21vZHVsZXMvZXZlbnRlbWl0dGVyMy9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9pc21vYmlsZWpzL2Rpc3QvaXNNb2JpbGUubWluLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2pzLWJhc2U2NC9iYXNlNjQuanMiLCIuLi9ub2RlX21vZHVsZXMvbWluaS1zaWduYWxzL2xpYi9taW5pLXNpZ25hbHMuanMiLCIuLi9ub2RlX21vZHVsZXMvb2JqZWN0LWFzc2lnbi9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9wYXJzZS11cmkvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvcGl4aS1nbC1jb3JlL3NyYy9HTEJ1ZmZlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9waXhpLWdsLWNvcmUvc3JjL0dMRnJhbWVidWZmZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvcGl4aS1nbC1jb3JlL3NyYy9HTFNoYWRlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9waXhpLWdsLWNvcmUvc3JjL0dMVGV4dHVyZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9waXhpLWdsLWNvcmUvc3JjL1ZlcnRleEFycmF5T2JqZWN0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3BpeGktZ2wtY29yZS9zcmMvY3JlYXRlQ29udGV4dC5qcyIsIi4uL25vZGVfbW9kdWxlcy9waXhpLWdsLWNvcmUvc3JjL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3BpeGktZ2wtY29yZS9zcmMvc2V0VmVydGV4QXR0cmliQXJyYXlzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3BpeGktZ2wtY29yZS9zcmMvc2hhZGVyL2NvbXBpbGVQcm9ncmFtLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3BpeGktZ2wtY29yZS9zcmMvc2hhZGVyL2RlZmF1bHRWYWx1ZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9waXhpLWdsLWNvcmUvc3JjL3NoYWRlci9leHRyYWN0QXR0cmlidXRlcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9waXhpLWdsLWNvcmUvc3JjL3NoYWRlci9leHRyYWN0VW5pZm9ybXMuanMiLCIuLi9ub2RlX21vZHVsZXMvcGl4aS1nbC1jb3JlL3NyYy9zaGFkZXIvZ2VuZXJhdGVVbmlmb3JtQWNjZXNzT2JqZWN0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3BpeGktZ2wtY29yZS9zcmMvc2hhZGVyL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3BpeGktZ2wtY29yZS9zcmMvc2hhZGVyL21hcFNpemUuanMiLCIuLi9ub2RlX21vZHVsZXMvcGl4aS1nbC1jb3JlL3NyYy9zaGFkZXIvbWFwVHlwZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9waXhpLWdsLWNvcmUvc3JjL3NoYWRlci9zZXRQcmVjaXNpb24uanMiLCIuLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvYWNjZXNzaWJpbGl0eS9BY2Nlc3NpYmlsaXR5TWFuYWdlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9hY2Nlc3NpYmlsaXR5L2FjY2Vzc2libGVUYXJnZXQuanMiLCIuLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvYWNjZXNzaWJpbGl0eS9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9jb3JlL0FwcGxpY2F0aW9uLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2NvcmUvU2hhZGVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2NvcmUvYXV0b0RldGVjdFJlbmRlcmVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2NvcmUvY29uc3QuanMiLCIuLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvY29yZS9kaXNwbGF5L0JvdW5kcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9jb3JlL2Rpc3BsYXkvQ29udGFpbmVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2NvcmUvZGlzcGxheS9EaXNwbGF5T2JqZWN0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2NvcmUvZGlzcGxheS9UcmFuc2Zvcm0uanMiLCIuLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvY29yZS9kaXNwbGF5L1RyYW5zZm9ybUJhc2UuanMiLCIuLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvY29yZS9kaXNwbGF5L1RyYW5zZm9ybVN0YXRpYy5qcyIsIi4uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9jb3JlL2dyYXBoaWNzL0dyYXBoaWNzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2NvcmUvZ3JhcGhpY3MvR3JhcGhpY3NEYXRhLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2NvcmUvZ3JhcGhpY3MvY2FudmFzL0NhbnZhc0dyYXBoaWNzUmVuZGVyZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvY29yZS9ncmFwaGljcy91dGlscy9iZXppZXJDdXJ2ZVRvLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2NvcmUvZ3JhcGhpY3Mvd2ViZ2wvR3JhcGhpY3NSZW5kZXJlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9jb3JlL2dyYXBoaWNzL3dlYmdsL1dlYkdMR3JhcGhpY3NEYXRhLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2NvcmUvZ3JhcGhpY3Mvd2ViZ2wvc2hhZGVycy9QcmltaXRpdmVTaGFkZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvY29yZS9ncmFwaGljcy93ZWJnbC91dGlscy9idWlsZENpcmNsZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9jb3JlL2dyYXBoaWNzL3dlYmdsL3V0aWxzL2J1aWxkTGluZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9jb3JlL2dyYXBoaWNzL3dlYmdsL3V0aWxzL2J1aWxkUG9seS5qcyIsIi4uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9jb3JlL2dyYXBoaWNzL3dlYmdsL3V0aWxzL2J1aWxkUmVjdGFuZ2xlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2NvcmUvZ3JhcGhpY3Mvd2ViZ2wvdXRpbHMvYnVpbGRSb3VuZGVkUmVjdGFuZ2xlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2NvcmUvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvY29yZS9tYXRoL0dyb3VwRDguanMiLCIuLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvY29yZS9tYXRoL01hdHJpeC5qcyIsIi4uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9jb3JlL21hdGgvT2JzZXJ2YWJsZVBvaW50LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2NvcmUvbWF0aC9Qb2ludC5qcyIsIi4uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9jb3JlL21hdGgvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvY29yZS9tYXRoL3NoYXBlcy9DaXJjbGUuanMiLCIuLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvY29yZS9tYXRoL3NoYXBlcy9FbGxpcHNlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2NvcmUvbWF0aC9zaGFwZXMvUG9seWdvbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9jb3JlL21hdGgvc2hhcGVzL1JlY3RhbmdsZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9jb3JlL21hdGgvc2hhcGVzL1JvdW5kZWRSZWN0YW5nbGUuanMiLCIuLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvY29yZS9yZW5kZXJlcnMvU3lzdGVtUmVuZGVyZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvY29yZS9yZW5kZXJlcnMvY2FudmFzL0NhbnZhc1JlbmRlcmVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2NvcmUvcmVuZGVyZXJzL2NhbnZhcy91dGlscy9DYW52YXNNYXNrTWFuYWdlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9jb3JlL3JlbmRlcmVycy9jYW52YXMvdXRpbHMvQ2FudmFzUmVuZGVyVGFyZ2V0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2NvcmUvcmVuZGVyZXJzL2NhbnZhcy91dGlscy9jYW5Vc2VOZXdDYW52YXNCbGVuZE1vZGVzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2NvcmUvcmVuZGVyZXJzL2NhbnZhcy91dGlscy9tYXBDYW52YXNCbGVuZE1vZGVzVG9QaXhpLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2NvcmUvcmVuZGVyZXJzL3dlYmdsL1RleHR1cmVHYXJiYWdlQ29sbGVjdG9yLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2NvcmUvcmVuZGVyZXJzL3dlYmdsL1RleHR1cmVNYW5hZ2VyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2NvcmUvcmVuZGVyZXJzL3dlYmdsL1dlYkdMUmVuZGVyZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvY29yZS9yZW5kZXJlcnMvd2ViZ2wvV2ViR0xTdGF0ZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9jb3JlL3JlbmRlcmVycy93ZWJnbC9maWx0ZXJzL0ZpbHRlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9jb3JlL3JlbmRlcmVycy93ZWJnbC9maWx0ZXJzL2V4dHJhY3RVbmlmb3Jtc0Zyb21TcmMuanMiLCIuLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvY29yZS9yZW5kZXJlcnMvd2ViZ2wvZmlsdGVycy9maWx0ZXJUcmFuc2Zvcm1zLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2NvcmUvcmVuZGVyZXJzL3dlYmdsL2ZpbHRlcnMvc3ByaXRlTWFzay9TcHJpdGVNYXNrRmlsdGVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2NvcmUvcmVuZGVyZXJzL3dlYmdsL21hbmFnZXJzL0ZpbHRlck1hbmFnZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvY29yZS9yZW5kZXJlcnMvd2ViZ2wvbWFuYWdlcnMvTWFza01hbmFnZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvY29yZS9yZW5kZXJlcnMvd2ViZ2wvbWFuYWdlcnMvU3RlbmNpbE1hbmFnZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvY29yZS9yZW5kZXJlcnMvd2ViZ2wvbWFuYWdlcnMvV2ViR0xNYW5hZ2VyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2NvcmUvcmVuZGVyZXJzL3dlYmdsL3V0aWxzL09iamVjdFJlbmRlcmVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2NvcmUvcmVuZGVyZXJzL3dlYmdsL3V0aWxzL1F1YWQuanMiLCIuLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvY29yZS9yZW5kZXJlcnMvd2ViZ2wvdXRpbHMvUmVuZGVyVGFyZ2V0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2NvcmUvcmVuZGVyZXJzL3dlYmdsL3V0aWxzL2NoZWNrTWF4SWZTdGF0bWVudHNJblNoYWRlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9jb3JlL3JlbmRlcmVycy93ZWJnbC91dGlscy9tYXBXZWJHTEJsZW5kTW9kZXNUb1BpeGkuanMiLCIuLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvY29yZS9yZW5kZXJlcnMvd2ViZ2wvdXRpbHMvbWFwV2ViR0xEcmF3TW9kZXNUb1BpeGkuanMiLCIuLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvY29yZS9yZW5kZXJlcnMvd2ViZ2wvdXRpbHMvdmFsaWRhdGVDb250ZXh0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2NvcmUvc2V0dGluZ3MuanMiLCIuLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvY29yZS9zcHJpdGVzL1Nwcml0ZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9jb3JlL3Nwcml0ZXMvY2FudmFzL0NhbnZhc1Nwcml0ZVJlbmRlcmVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2NvcmUvc3ByaXRlcy9jYW52YXMvQ2FudmFzVGludGVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2NvcmUvc3ByaXRlcy93ZWJnbC9CYXRjaEJ1ZmZlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9jb3JlL3Nwcml0ZXMvd2ViZ2wvU3ByaXRlUmVuZGVyZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvY29yZS9zcHJpdGVzL3dlYmdsL2dlbmVyYXRlTXVsdGlUZXh0dXJlU2hhZGVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2NvcmUvdGV4dC9UZXh0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2NvcmUvdGV4dC9UZXh0TWV0cmljcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9jb3JlL3RleHQvVGV4dFN0eWxlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2NvcmUvdGV4dHVyZXMvQmFzZVJlbmRlclRleHR1cmUuanMiLCIuLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvY29yZS90ZXh0dXJlcy9CYXNlVGV4dHVyZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9jb3JlL3RleHR1cmVzL1JlbmRlclRleHR1cmUuanMiLCIuLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvY29yZS90ZXh0dXJlcy9TcHJpdGVzaGVldC5qcyIsIi4uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9jb3JlL3RleHR1cmVzL1RleHR1cmUuanMiLCIuLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvY29yZS90ZXh0dXJlcy9UZXh0dXJlTWF0cml4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2NvcmUvdGV4dHVyZXMvVGV4dHVyZVV2cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9jb3JlL3RleHR1cmVzL1ZpZGVvQmFzZVRleHR1cmUuanMiLCIuLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvY29yZS90aWNrZXIvVGlja2VyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2NvcmUvdGlja2VyL1RpY2tlckxpc3RlbmVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2NvcmUvdGlja2VyL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2NvcmUvdXRpbHMvY2FuVXBsb2FkU2FtZUJ1ZmZlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9jb3JlL3V0aWxzL2NyZWF0ZUluZGljZXNGb3JRdWFkcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9jb3JlL3V0aWxzL2RldGVybWluZUNyb3NzT3JpZ2luLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2NvcmUvdXRpbHMvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvY29yZS91dGlscy9tYXBQcmVtdWx0aXBsaWVkQmxlbmRNb2Rlcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9jb3JlL3V0aWxzL21heFJlY29tbWVuZGVkVGV4dHVyZXMuanMiLCIuLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvY29yZS91dGlscy9taXhpbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9jb3JlL3V0aWxzL3BsdWdpblRhcmdldC5qcyIsIi4uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9jb3JlL3V0aWxzL3RyaW1DYW52YXMuanMiLCIuLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvZGVwcmVjYXRpb24uanMiLCIuLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvZXh0cmFjdC9jYW52YXMvQ2FudmFzRXh0cmFjdC5qcyIsIi4uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9leHRyYWN0L2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2V4dHJhY3Qvd2ViZ2wvV2ViR0xFeHRyYWN0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2V4dHJhcy9BbmltYXRlZFNwcml0ZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9leHRyYXMvQml0bWFwVGV4dC5qcyIsIi4uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9leHRyYXMvVGlsaW5nU3ByaXRlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2V4dHJhcy9jYWNoZUFzQml0bWFwLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2V4dHJhcy9nZXRDaGlsZEJ5TmFtZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9leHRyYXMvZ2V0R2xvYmFsUG9zaXRpb24uanMiLCIuLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvZXh0cmFzL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2V4dHJhcy93ZWJnbC9UaWxpbmdTcHJpdGVSZW5kZXJlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9maWx0ZXJzL2FscGhhL0FscGhhRmlsdGVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2ZpbHRlcnMvYmx1ci9CbHVyRmlsdGVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2ZpbHRlcnMvYmx1ci9CbHVyWEZpbHRlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9maWx0ZXJzL2JsdXIvQmx1cllGaWx0ZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvZmlsdGVycy9ibHVyL2dlbmVyYXRlQmx1ckZyYWdTb3VyY2UuanMiLCIuLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvZmlsdGVycy9ibHVyL2dlbmVyYXRlQmx1clZlcnRTb3VyY2UuanMiLCIuLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvZmlsdGVycy9ibHVyL2dldE1heEJsdXJLZXJuZWxTaXplLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2ZpbHRlcnMvY29sb3JtYXRyaXgvQ29sb3JNYXRyaXhGaWx0ZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvZmlsdGVycy9kaXNwbGFjZW1lbnQvRGlzcGxhY2VtZW50RmlsdGVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2ZpbHRlcnMvZnhhYS9GWEFBRmlsdGVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2ZpbHRlcnMvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvZmlsdGVycy9ub2lzZS9Ob2lzZUZpbHRlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9pbnRlcmFjdGlvbi9JbnRlcmFjdGlvbkRhdGEuanMiLCIuLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvaW50ZXJhY3Rpb24vSW50ZXJhY3Rpb25FdmVudC5qcyIsIi4uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9pbnRlcmFjdGlvbi9JbnRlcmFjdGlvbk1hbmFnZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvaW50ZXJhY3Rpb24vSW50ZXJhY3Rpb25UcmFja2luZ0RhdGEuanMiLCIuLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvaW50ZXJhY3Rpb24vaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvaW50ZXJhY3Rpb24vaW50ZXJhY3RpdmVUYXJnZXQuanMiLCIuLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvbG9hZGVycy9iaXRtYXBGb250UGFyc2VyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2xvYWRlcnMvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvbG9hZGVycy9sb2FkZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvbG9hZGVycy9zcHJpdGVzaGVldFBhcnNlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9sb2FkZXJzL3RleHR1cmVQYXJzZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvbWVzaC9NZXNoLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL21lc2gvTmluZVNsaWNlUGxhbmUuanMiLCIuLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvbWVzaC9QbGFuZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9tZXNoL1JvcGUuanMiLCIuLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvbWVzaC9jYW52YXMvQ2FudmFzTWVzaFJlbmRlcmVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL21lc2gvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvbWVzaC93ZWJnbC9NZXNoUmVuZGVyZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcGFydGljbGVzL1BhcnRpY2xlQ29udGFpbmVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3BhcnRpY2xlcy9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9wYXJ0aWNsZXMvd2ViZ2wvUGFydGljbGVCdWZmZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcGFydGljbGVzL3dlYmdsL1BhcnRpY2xlUmVuZGVyZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcGFydGljbGVzL3dlYmdsL1BhcnRpY2xlU2hhZGVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3BvbHlmaWxsL01hdGguc2lnbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9wb2x5ZmlsbC9OdW1iZXIuaXNJbnRlZ2VyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3BvbHlmaWxsL09iamVjdC5hc3NpZ24uanMiLCIuLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcG9seWZpbGwvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcG9seWZpbGwvcmVxdWVzdEFuaW1hdGlvbkZyYW1lLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3ByZXBhcmUvQmFzZVByZXBhcmUuanMiLCIuLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcHJlcGFyZS9jYW52YXMvQ2FudmFzUHJlcGFyZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9wcmVwYXJlL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3ByZXBhcmUvbGltaXRlcnMvQ291bnRMaW1pdGVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3ByZXBhcmUvbGltaXRlcnMvVGltZUxpbWl0ZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcHJlcGFyZS93ZWJnbC9XZWJHTFByZXBhcmUuanMiLCIuLi9ub2RlX21vZHVsZXMvcmVtb3ZlLWFycmF5LWl0ZW1zL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3Jlc291cmNlLWxvYWRlci9saWIvTG9hZGVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3Jlc291cmNlLWxvYWRlci9saWIvUmVzb3VyY2UuanMiLCIuLi9ub2RlX21vZHVsZXMvcmVzb3VyY2UtbG9hZGVyL2xpYi9hc3luYy5qcyIsIi4uL25vZGVfbW9kdWxlcy9yZXNvdXJjZS1sb2FkZXIvbGliL2I2NC5qcyIsIi4uL25vZGVfbW9kdWxlcy9yZXNvdXJjZS1sb2FkZXIvbGliL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3Jlc291cmNlLWxvYWRlci9saWIvbWlkZGxld2FyZXMvcGFyc2luZy9ibG9iLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3R5cGVzanMvY29yZS5qcyIsIi4uL25vZGVfbW9kdWxlcy90eXBlc2pzL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3R5cGVzanMvdHlwZXMvYW55L3R5cGUuanMiLCIuLi9ub2RlX21vZHVsZXMvdHlwZXNqcy90eXBlcy9hcnJheS90eXBlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3R5cGVzanMvdHlwZXMvYm9vbC90eXBlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3R5cGVzanMvdHlwZXMvY29uc3QvdHlwZS5qcyIsIi4uL25vZGVfbW9kdWxlcy90eXBlc2pzL3R5cGVzL2luZGV4L3R5cGUuanMiLCIuLi9ub2RlX21vZHVsZXMvdHlwZXNqcy90eXBlcy9rZXkvdHlwZS5qcyIsIi4uL25vZGVfbW9kdWxlcy90eXBlc2pzL3R5cGVzL251bWJlci90eXBlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3R5cGVzanMvdHlwZXMvb2JqZWN0L3R5cGUuanMiLCIuLi9ub2RlX21vZHVsZXMvdHlwZXNqcy90eXBlcy9zdHJpbmcvdHlwZS5qcyIsIi4uL25vZGVfbW9kdWxlcy90eXBlc2pzL3R5cGVzL3N3aXRjaC90eXBlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3R5cGVzanMvdHlwZXMvdGVtcGxhdGUvdHlwZS5qcyIsIi4uL25vZGVfbW9kdWxlcy91dWlkL2xpYi9ieXRlc1RvVXVpZC5qcyIsIi4uL25vZGVfbW9kdWxlcy91dWlkL2xpYi9ybmctYnJvd3Nlci5qcyIsIi4uL25vZGVfbW9kdWxlcy91dWlkL2xpYi9zaGExLWJyb3dzZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvdXVpZC9saWIvdjM1LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3V1aWQvdjEuanMiLCIuLi9ub2RlX21vZHVsZXMvdXVpZC92NS5qcyIsIi4uL3NyYy9CbG9ja3MuanMiLCIuLi9zcmMvQnVsbGV0cy5qcyIsIi4uL3NyYy9HYW1lTW9kZS5qcyIsIi4uL3NyYy9NYXAuanMiLCIuLi9zcmMvVHlwZXMuanMiLCIuLi9zcmMvYWN0b3JfZ2FtZXIuanMiLCIuLi9zcmMvYnVsbGV0Lmpzb24iLCIuLi9zcmMvbWFwLmpzb24iLCIuLi9zcmMvc2Vzc2lvbi5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM5U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDeExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3JoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNXRCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZUQTs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzNPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9nQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDclZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4bUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbDJDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3VEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2UUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaFJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0UUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25JQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM1dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeFFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3IwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1b0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDblBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9uQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDelBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdmlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaHBCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMXJCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2gwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzUwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2VUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbG9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdGJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbm9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5Y0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25LQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyaUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMvRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDOUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcHZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN2FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdlBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN6RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdGVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdnZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3R0E7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4Y0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2YUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMWdMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIHIoZSxuLHQpe2Z1bmN0aW9uIG8oaSxmKXtpZighbltpXSl7aWYoIWVbaV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGMoaSwhMCk7aWYodSlyZXR1cm4gdShpLCEwKTt2YXIgYT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2krXCInXCIpO3Rocm93IGEuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixhfXZhciBwPW5baV09e2V4cG9ydHM6e319O2VbaV1bMF0uY2FsbChwLmV4cG9ydHMsZnVuY3Rpb24ocil7dmFyIG49ZVtpXVsxXVtyXTtyZXR1cm4gbyhufHxyKX0scCxwLmV4cG9ydHMscixlLG4sdCl9cmV0dXJuIG5baV0uZXhwb3J0c31mb3IodmFyIHU9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxpPTA7aTx0Lmxlbmd0aDtpKyspbyh0W2ldKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkiLCIvLyAuZGlybmFtZSwgLmJhc2VuYW1lLCBhbmQgLmV4dG5hbWUgbWV0aG9kcyBhcmUgZXh0cmFjdGVkIGZyb20gTm9kZS5qcyB2OC4xMS4xLFxuLy8gYmFja3BvcnRlZCBhbmQgdHJhbnNwbGl0ZWQgd2l0aCBCYWJlbCwgd2l0aCBiYWNrd2FyZHMtY29tcGF0IGZpeGVzXG5cbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyByZXNvbHZlcyAuIGFuZCAuLiBlbGVtZW50cyBpbiBhIHBhdGggYXJyYXkgd2l0aCBkaXJlY3RvcnkgbmFtZXMgdGhlcmVcbi8vIG11c3QgYmUgbm8gc2xhc2hlcywgZW1wdHkgZWxlbWVudHMsIG9yIGRldmljZSBuYW1lcyAoYzpcXCkgaW4gdGhlIGFycmF5XG4vLyAoc28gYWxzbyBubyBsZWFkaW5nIGFuZCB0cmFpbGluZyBzbGFzaGVzIC0gaXQgZG9lcyBub3QgZGlzdGluZ3Vpc2hcbi8vIHJlbGF0aXZlIGFuZCBhYnNvbHV0ZSBwYXRocylcbmZ1bmN0aW9uIG5vcm1hbGl6ZUFycmF5KHBhcnRzLCBhbGxvd0Fib3ZlUm9vdCkge1xuICAvLyBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxuICB2YXIgdXAgPSAwO1xuICBmb3IgKHZhciBpID0gcGFydHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgbGFzdCA9IHBhcnRzW2ldO1xuICAgIGlmIChsYXN0ID09PSAnLicpIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgdXAtLTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgcGF0aCBpcyBhbGxvd2VkIHRvIGdvIGFib3ZlIHRoZSByb290LCByZXN0b3JlIGxlYWRpbmcgLi5zXG4gIGlmIChhbGxvd0Fib3ZlUm9vdCkge1xuICAgIGZvciAoOyB1cC0tOyB1cCkge1xuICAgICAgcGFydHMudW5zaGlmdCgnLi4nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGFydHM7XG59XG5cbi8vIHBhdGgucmVzb2x2ZShbZnJvbSAuLi5dLCB0bylcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMucmVzb2x2ZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcmVzb2x2ZWRQYXRoID0gJycsXG4gICAgICByZXNvbHZlZEFic29sdXRlID0gZmFsc2U7XG5cbiAgZm9yICh2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGggLSAxOyBpID49IC0xICYmICFyZXNvbHZlZEFic29sdXRlOyBpLS0pIHtcbiAgICB2YXIgcGF0aCA9IChpID49IDApID8gYXJndW1lbnRzW2ldIDogcHJvY2Vzcy5jd2QoKTtcblxuICAgIC8vIFNraXAgZW1wdHkgYW5kIGludmFsaWQgZW50cmllc1xuICAgIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyB0byBwYXRoLnJlc29sdmUgbXVzdCBiZSBzdHJpbmdzJyk7XG4gICAgfSBlbHNlIGlmICghcGF0aCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcmVzb2x2ZWRQYXRoID0gcGF0aCArICcvJyArIHJlc29sdmVkUGF0aDtcbiAgICByZXNvbHZlZEFic29sdXRlID0gcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbiAgfVxuXG4gIC8vIEF0IHRoaXMgcG9pbnQgdGhlIHBhdGggc2hvdWxkIGJlIHJlc29sdmVkIHRvIGEgZnVsbCBhYnNvbHV0ZSBwYXRoLCBidXRcbiAgLy8gaGFuZGxlIHJlbGF0aXZlIHBhdGhzIHRvIGJlIHNhZmUgKG1pZ2h0IGhhcHBlbiB3aGVuIHByb2Nlc3MuY3dkKCkgZmFpbHMpXG5cbiAgLy8gTm9ybWFsaXplIHRoZSBwYXRoXG4gIHJlc29sdmVkUGF0aCA9IG5vcm1hbGl6ZUFycmF5KGZpbHRlcihyZXNvbHZlZFBhdGguc3BsaXQoJy8nKSwgZnVuY3Rpb24ocCkge1xuICAgIHJldHVybiAhIXA7XG4gIH0pLCAhcmVzb2x2ZWRBYnNvbHV0ZSkuam9pbignLycpO1xuXG4gIHJldHVybiAoKHJlc29sdmVkQWJzb2x1dGUgPyAnLycgOiAnJykgKyByZXNvbHZlZFBhdGgpIHx8ICcuJztcbn07XG5cbi8vIHBhdGgubm9ybWFsaXplKHBhdGgpXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgdmFyIGlzQWJzb2x1dGUgPSBleHBvcnRzLmlzQWJzb2x1dGUocGF0aCksXG4gICAgICB0cmFpbGluZ1NsYXNoID0gc3Vic3RyKHBhdGgsIC0xKSA9PT0gJy8nO1xuXG4gIC8vIE5vcm1hbGl6ZSB0aGUgcGF0aFxuICBwYXRoID0gbm9ybWFsaXplQXJyYXkoZmlsdGVyKHBhdGguc3BsaXQoJy8nKSwgZnVuY3Rpb24ocCkge1xuICAgIHJldHVybiAhIXA7XG4gIH0pLCAhaXNBYnNvbHV0ZSkuam9pbignLycpO1xuXG4gIGlmICghcGF0aCAmJiAhaXNBYnNvbHV0ZSkge1xuICAgIHBhdGggPSAnLic7XG4gIH1cbiAgaWYgKHBhdGggJiYgdHJhaWxpbmdTbGFzaCkge1xuICAgIHBhdGggKz0gJy8nO1xuICB9XG5cbiAgcmV0dXJuIChpc0Fic29sdXRlID8gJy8nIDogJycpICsgcGF0aDtcbn07XG5cbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMuaXNBYnNvbHV0ZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGguY2hhckF0KDApID09PSAnLyc7XG59O1xuXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLmpvaW4gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHBhdGhzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgcmV0dXJuIGV4cG9ydHMubm9ybWFsaXplKGZpbHRlcihwYXRocywgZnVuY3Rpb24ocCwgaW5kZXgpIHtcbiAgICBpZiAodHlwZW9mIHAgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgdG8gcGF0aC5qb2luIG11c3QgYmUgc3RyaW5ncycpO1xuICAgIH1cbiAgICByZXR1cm4gcDtcbiAgfSkuam9pbignLycpKTtcbn07XG5cblxuLy8gcGF0aC5yZWxhdGl2ZShmcm9tLCB0bylcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMucmVsYXRpdmUgPSBmdW5jdGlvbihmcm9tLCB0bykge1xuICBmcm9tID0gZXhwb3J0cy5yZXNvbHZlKGZyb20pLnN1YnN0cigxKTtcbiAgdG8gPSBleHBvcnRzLnJlc29sdmUodG8pLnN1YnN0cigxKTtcblxuICBmdW5jdGlvbiB0cmltKGFycikge1xuICAgIHZhciBzdGFydCA9IDA7XG4gICAgZm9yICg7IHN0YXJ0IDwgYXJyLmxlbmd0aDsgc3RhcnQrKykge1xuICAgICAgaWYgKGFycltzdGFydF0gIT09ICcnKSBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgZW5kID0gYXJyLmxlbmd0aCAtIDE7XG4gICAgZm9yICg7IGVuZCA+PSAwOyBlbmQtLSkge1xuICAgICAgaWYgKGFycltlbmRdICE9PSAnJykgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0ID4gZW5kKSByZXR1cm4gW107XG4gICAgcmV0dXJuIGFyci5zbGljZShzdGFydCwgZW5kIC0gc3RhcnQgKyAxKTtcbiAgfVxuXG4gIHZhciBmcm9tUGFydHMgPSB0cmltKGZyb20uc3BsaXQoJy8nKSk7XG4gIHZhciB0b1BhcnRzID0gdHJpbSh0by5zcGxpdCgnLycpKTtcblxuICB2YXIgbGVuZ3RoID0gTWF0aC5taW4oZnJvbVBhcnRzLmxlbmd0aCwgdG9QYXJ0cy5sZW5ndGgpO1xuICB2YXIgc2FtZVBhcnRzTGVuZ3RoID0gbGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGZyb21QYXJ0c1tpXSAhPT0gdG9QYXJ0c1tpXSkge1xuICAgICAgc2FtZVBhcnRzTGVuZ3RoID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHZhciBvdXRwdXRQYXJ0cyA9IFtdO1xuICBmb3IgKHZhciBpID0gc2FtZVBhcnRzTGVuZ3RoOyBpIDwgZnJvbVBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgb3V0cHV0UGFydHMucHVzaCgnLi4nKTtcbiAgfVxuXG4gIG91dHB1dFBhcnRzID0gb3V0cHV0UGFydHMuY29uY2F0KHRvUGFydHMuc2xpY2Uoc2FtZVBhcnRzTGVuZ3RoKSk7XG5cbiAgcmV0dXJuIG91dHB1dFBhcnRzLmpvaW4oJy8nKTtcbn07XG5cbmV4cG9ydHMuc2VwID0gJy8nO1xuZXhwb3J0cy5kZWxpbWl0ZXIgPSAnOic7XG5cbmV4cG9ydHMuZGlybmFtZSA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHBhdGggPSBwYXRoICsgJyc7XG4gIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcuJztcbiAgdmFyIGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoMCk7XG4gIHZhciBoYXNSb290ID0gY29kZSA9PT0gNDcgLyovKi87XG4gIHZhciBlbmQgPSAtMTtcbiAgdmFyIG1hdGNoZWRTbGFzaCA9IHRydWU7XG4gIGZvciAodmFyIGkgPSBwYXRoLmxlbmd0aCAtIDE7IGkgPj0gMTsgLS1pKSB7XG4gICAgY29kZSA9IHBhdGguY2hhckNvZGVBdChpKTtcbiAgICBpZiAoY29kZSA9PT0gNDcgLyovKi8pIHtcbiAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcbiAgICAgICAgICBlbmQgPSBpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgLy8gV2Ugc2F3IHRoZSBmaXJzdCBub24tcGF0aCBzZXBhcmF0b3JcbiAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChlbmQgPT09IC0xKSByZXR1cm4gaGFzUm9vdCA/ICcvJyA6ICcuJztcbiAgaWYgKGhhc1Jvb3QgJiYgZW5kID09PSAxKSB7XG4gICAgLy8gcmV0dXJuICcvLyc7XG4gICAgLy8gQmFja3dhcmRzLWNvbXBhdCBmaXg6XG4gICAgcmV0dXJuICcvJztcbiAgfVxuICByZXR1cm4gcGF0aC5zbGljZSgwLCBlbmQpO1xufTtcblxuZnVuY3Rpb24gYmFzZW5hbWUocGF0aCkge1xuICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSBwYXRoID0gcGF0aCArICcnO1xuXG4gIHZhciBzdGFydCA9IDA7XG4gIHZhciBlbmQgPSAtMTtcbiAgdmFyIG1hdGNoZWRTbGFzaCA9IHRydWU7XG4gIHZhciBpO1xuXG4gIGZvciAoaSA9IHBhdGgubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICBpZiAocGF0aC5jaGFyQ29kZUF0KGkpID09PSA0NyAvKi8qLykge1xuICAgICAgICAvLyBJZiB3ZSByZWFjaGVkIGEgcGF0aCBzZXBhcmF0b3IgdGhhdCB3YXMgbm90IHBhcnQgb2YgYSBzZXQgb2YgcGF0aFxuICAgICAgICAvLyBzZXBhcmF0b3JzIGF0IHRoZSBlbmQgb2YgdGhlIHN0cmluZywgc3RvcCBub3dcbiAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcbiAgICAgICAgICBzdGFydCA9IGkgKyAxO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGVuZCA9PT0gLTEpIHtcbiAgICAgIC8vIFdlIHNhdyB0aGUgZmlyc3Qgbm9uLXBhdGggc2VwYXJhdG9yLCBtYXJrIHRoaXMgYXMgdGhlIGVuZCBvZiBvdXJcbiAgICAgIC8vIHBhdGggY29tcG9uZW50XG4gICAgICBtYXRjaGVkU2xhc2ggPSBmYWxzZTtcbiAgICAgIGVuZCA9IGkgKyAxO1xuICAgIH1cbiAgfVxuXG4gIGlmIChlbmQgPT09IC0xKSByZXR1cm4gJyc7XG4gIHJldHVybiBwYXRoLnNsaWNlKHN0YXJ0LCBlbmQpO1xufVxuXG4vLyBVc2VzIGEgbWl4ZWQgYXBwcm9hY2ggZm9yIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5LCBhcyBleHQgYmVoYXZpb3IgY2hhbmdlZFxuLy8gaW4gbmV3IE5vZGUuanMgdmVyc2lvbnMsIHNvIG9ubHkgYmFzZW5hbWUoKSBhYm92ZSBpcyBiYWNrcG9ydGVkIGhlcmVcbmV4cG9ydHMuYmFzZW5hbWUgPSBmdW5jdGlvbiAocGF0aCwgZXh0KSB7XG4gIHZhciBmID0gYmFzZW5hbWUocGF0aCk7XG4gIGlmIChleHQgJiYgZi5zdWJzdHIoLTEgKiBleHQubGVuZ3RoKSA9PT0gZXh0KSB7XG4gICAgZiA9IGYuc3Vic3RyKDAsIGYubGVuZ3RoIC0gZXh0Lmxlbmd0aCk7XG4gIH1cbiAgcmV0dXJuIGY7XG59O1xuXG5leHBvcnRzLmV4dG5hbWUgPSBmdW5jdGlvbiAocGF0aCkge1xuICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSBwYXRoID0gcGF0aCArICcnO1xuICB2YXIgc3RhcnREb3QgPSAtMTtcbiAgdmFyIHN0YXJ0UGFydCA9IDA7XG4gIHZhciBlbmQgPSAtMTtcbiAgdmFyIG1hdGNoZWRTbGFzaCA9IHRydWU7XG4gIC8vIFRyYWNrIHRoZSBzdGF0ZSBvZiBjaGFyYWN0ZXJzIChpZiBhbnkpIHdlIHNlZSBiZWZvcmUgb3VyIGZpcnN0IGRvdCBhbmRcbiAgLy8gYWZ0ZXIgYW55IHBhdGggc2VwYXJhdG9yIHdlIGZpbmRcbiAgdmFyIHByZURvdFN0YXRlID0gMDtcbiAgZm9yICh2YXIgaSA9IHBhdGgubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICB2YXIgY29kZSA9IHBhdGguY2hhckNvZGVBdChpKTtcbiAgICBpZiAoY29kZSA9PT0gNDcgLyovKi8pIHtcbiAgICAgICAgLy8gSWYgd2UgcmVhY2hlZCBhIHBhdGggc2VwYXJhdG9yIHRoYXQgd2FzIG5vdCBwYXJ0IG9mIGEgc2V0IG9mIHBhdGhcbiAgICAgICAgLy8gc2VwYXJhdG9ycyBhdCB0aGUgZW5kIG9mIHRoZSBzdHJpbmcsIHN0b3Agbm93XG4gICAgICAgIGlmICghbWF0Y2hlZFNsYXNoKSB7XG4gICAgICAgICAgc3RhcnRQYXJ0ID0gaSArIDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgaWYgKGVuZCA9PT0gLTEpIHtcbiAgICAgIC8vIFdlIHNhdyB0aGUgZmlyc3Qgbm9uLXBhdGggc2VwYXJhdG9yLCBtYXJrIHRoaXMgYXMgdGhlIGVuZCBvZiBvdXJcbiAgICAgIC8vIGV4dGVuc2lvblxuICAgICAgbWF0Y2hlZFNsYXNoID0gZmFsc2U7XG4gICAgICBlbmQgPSBpICsgMTtcbiAgICB9XG4gICAgaWYgKGNvZGUgPT09IDQ2IC8qLiovKSB7XG4gICAgICAgIC8vIElmIHRoaXMgaXMgb3VyIGZpcnN0IGRvdCwgbWFyayBpdCBhcyB0aGUgc3RhcnQgb2Ygb3VyIGV4dGVuc2lvblxuICAgICAgICBpZiAoc3RhcnREb3QgPT09IC0xKVxuICAgICAgICAgIHN0YXJ0RG90ID0gaTtcbiAgICAgICAgZWxzZSBpZiAocHJlRG90U3RhdGUgIT09IDEpXG4gICAgICAgICAgcHJlRG90U3RhdGUgPSAxO1xuICAgIH0gZWxzZSBpZiAoc3RhcnREb3QgIT09IC0xKSB7XG4gICAgICAvLyBXZSBzYXcgYSBub24tZG90IGFuZCBub24tcGF0aCBzZXBhcmF0b3IgYmVmb3JlIG91ciBkb3QsIHNvIHdlIHNob3VsZFxuICAgICAgLy8gaGF2ZSBhIGdvb2QgY2hhbmNlIGF0IGhhdmluZyBhIG5vbi1lbXB0eSBleHRlbnNpb25cbiAgICAgIHByZURvdFN0YXRlID0gLTE7XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0YXJ0RG90ID09PSAtMSB8fCBlbmQgPT09IC0xIHx8XG4gICAgICAvLyBXZSBzYXcgYSBub24tZG90IGNoYXJhY3RlciBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIGRvdFxuICAgICAgcHJlRG90U3RhdGUgPT09IDAgfHxcbiAgICAgIC8vIFRoZSAocmlnaHQtbW9zdCkgdHJpbW1lZCBwYXRoIGNvbXBvbmVudCBpcyBleGFjdGx5ICcuLidcbiAgICAgIHByZURvdFN0YXRlID09PSAxICYmIHN0YXJ0RG90ID09PSBlbmQgLSAxICYmIHN0YXJ0RG90ID09PSBzdGFydFBhcnQgKyAxKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIHJldHVybiBwYXRoLnNsaWNlKHN0YXJ0RG90LCBlbmQpO1xufTtcblxuZnVuY3Rpb24gZmlsdGVyICh4cywgZikge1xuICAgIGlmICh4cy5maWx0ZXIpIHJldHVybiB4cy5maWx0ZXIoZik7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGYoeHNbaV0sIGksIHhzKSkgcmVzLnB1c2goeHNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG4vLyBTdHJpbmcucHJvdG90eXBlLnN1YnN0ciAtIG5lZ2F0aXZlIGluZGV4IGRvbid0IHdvcmsgaW4gSUU4XG52YXIgc3Vic3RyID0gJ2FiJy5zdWJzdHIoLTEpID09PSAnYidcbiAgICA/IGZ1bmN0aW9uIChzdHIsIHN0YXJ0LCBsZW4pIHsgcmV0dXJuIHN0ci5zdWJzdHIoc3RhcnQsIGxlbikgfVxuICAgIDogZnVuY3Rpb24gKHN0ciwgc3RhcnQsIGxlbikge1xuICAgICAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IHN0ci5sZW5ndGggKyBzdGFydDtcbiAgICAgICAgcmV0dXJuIHN0ci5zdWJzdHIoc3RhcnQsIGxlbik7XG4gICAgfVxuO1xuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIi8qISBodHRwczovL210aHMuYmUvcHVueWNvZGUgdjEuNC4xIGJ5IEBtYXRoaWFzICovXG47KGZ1bmN0aW9uKHJvb3QpIHtcblxuXHQvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGVzICovXG5cdHZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiZcblx0XHQhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXHR2YXIgZnJlZU1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmXG5cdFx0IW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cdHZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWw7XG5cdGlmIChcblx0XHRmcmVlR2xvYmFsLmdsb2JhbCA9PT0gZnJlZUdsb2JhbCB8fFxuXHRcdGZyZWVHbG9iYWwud2luZG93ID09PSBmcmVlR2xvYmFsIHx8XG5cdFx0ZnJlZUdsb2JhbC5zZWxmID09PSBmcmVlR2xvYmFsXG5cdCkge1xuXHRcdHJvb3QgPSBmcmVlR2xvYmFsO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRoZSBgcHVueWNvZGVgIG9iamVjdC5cblx0ICogQG5hbWUgcHVueWNvZGVcblx0ICogQHR5cGUgT2JqZWN0XG5cdCAqL1xuXHR2YXIgcHVueWNvZGUsXG5cblx0LyoqIEhpZ2hlc3QgcG9zaXRpdmUgc2lnbmVkIDMyLWJpdCBmbG9hdCB2YWx1ZSAqL1xuXHRtYXhJbnQgPSAyMTQ3NDgzNjQ3LCAvLyBha2EuIDB4N0ZGRkZGRkYgb3IgMl4zMS0xXG5cblx0LyoqIEJvb3RzdHJpbmcgcGFyYW1ldGVycyAqL1xuXHRiYXNlID0gMzYsXG5cdHRNaW4gPSAxLFxuXHR0TWF4ID0gMjYsXG5cdHNrZXcgPSAzOCxcblx0ZGFtcCA9IDcwMCxcblx0aW5pdGlhbEJpYXMgPSA3Mixcblx0aW5pdGlhbE4gPSAxMjgsIC8vIDB4ODBcblx0ZGVsaW1pdGVyID0gJy0nLCAvLyAnXFx4MkQnXG5cblx0LyoqIFJlZ3VsYXIgZXhwcmVzc2lvbnMgKi9cblx0cmVnZXhQdW55Y29kZSA9IC9eeG4tLS8sXG5cdHJlZ2V4Tm9uQVNDSUkgPSAvW15cXHgyMC1cXHg3RV0vLCAvLyB1bnByaW50YWJsZSBBU0NJSSBjaGFycyArIG5vbi1BU0NJSSBjaGFyc1xuXHRyZWdleFNlcGFyYXRvcnMgPSAvW1xceDJFXFx1MzAwMlxcdUZGMEVcXHVGRjYxXS9nLCAvLyBSRkMgMzQ5MCBzZXBhcmF0b3JzXG5cblx0LyoqIEVycm9yIG1lc3NhZ2VzICovXG5cdGVycm9ycyA9IHtcblx0XHQnb3ZlcmZsb3cnOiAnT3ZlcmZsb3c6IGlucHV0IG5lZWRzIHdpZGVyIGludGVnZXJzIHRvIHByb2Nlc3MnLFxuXHRcdCdub3QtYmFzaWMnOiAnSWxsZWdhbCBpbnB1dCA+PSAweDgwIChub3QgYSBiYXNpYyBjb2RlIHBvaW50KScsXG5cdFx0J2ludmFsaWQtaW5wdXQnOiAnSW52YWxpZCBpbnB1dCdcblx0fSxcblxuXHQvKiogQ29udmVuaWVuY2Ugc2hvcnRjdXRzICovXG5cdGJhc2VNaW51c1RNaW4gPSBiYXNlIC0gdE1pbixcblx0Zmxvb3IgPSBNYXRoLmZsb29yLFxuXHRzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLFxuXG5cdC8qKiBUZW1wb3JhcnkgdmFyaWFibGUgKi9cblx0a2V5O1xuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8qKlxuXHQgKiBBIGdlbmVyaWMgZXJyb3IgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGVycm9yIHR5cGUuXG5cdCAqIEByZXR1cm5zIHtFcnJvcn0gVGhyb3dzIGEgYFJhbmdlRXJyb3JgIHdpdGggdGhlIGFwcGxpY2FibGUgZXJyb3IgbWVzc2FnZS5cblx0ICovXG5cdGZ1bmN0aW9uIGVycm9yKHR5cGUpIHtcblx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvcihlcnJvcnNbdHlwZV0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBgQXJyYXkjbWFwYCB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnkgYXJyYXlcblx0ICogaXRlbS5cblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBhcnJheSBvZiB2YWx1ZXMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwKGFycmF5LCBmbikge1xuXHRcdHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cdFx0dmFyIHJlc3VsdCA9IFtdO1xuXHRcdHdoaWxlIChsZW5ndGgtLSkge1xuXHRcdFx0cmVzdWx0W2xlbmd0aF0gPSBmbihhcnJheVtsZW5ndGhdKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIHNpbXBsZSBgQXJyYXkjbWFwYC1saWtlIHdyYXBwZXIgdG8gd29yayB3aXRoIGRvbWFpbiBuYW1lIHN0cmluZ3Mgb3IgZW1haWxcblx0ICogYWRkcmVzc2VzLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZG9tYWluIFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnlcblx0ICogY2hhcmFjdGVyLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IHN0cmluZyBvZiBjaGFyYWN0ZXJzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFja1xuXHQgKiBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcERvbWFpbihzdHJpbmcsIGZuKSB7XG5cdFx0dmFyIHBhcnRzID0gc3RyaW5nLnNwbGl0KCdAJyk7XG5cdFx0dmFyIHJlc3VsdCA9ICcnO1xuXHRcdGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG5cdFx0XHQvLyBJbiBlbWFpbCBhZGRyZXNzZXMsIG9ubHkgdGhlIGRvbWFpbiBuYW1lIHNob3VsZCBiZSBwdW55Y29kZWQuIExlYXZlXG5cdFx0XHQvLyB0aGUgbG9jYWwgcGFydCAoaS5lLiBldmVyeXRoaW5nIHVwIHRvIGBAYCkgaW50YWN0LlxuXHRcdFx0cmVzdWx0ID0gcGFydHNbMF0gKyAnQCc7XG5cdFx0XHRzdHJpbmcgPSBwYXJ0c1sxXTtcblx0XHR9XG5cdFx0Ly8gQXZvaWQgYHNwbGl0KHJlZ2V4KWAgZm9yIElFOCBjb21wYXRpYmlsaXR5LiBTZWUgIzE3LlxuXHRcdHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHJlZ2V4U2VwYXJhdG9ycywgJ1xceDJFJyk7XG5cdFx0dmFyIGxhYmVscyA9IHN0cmluZy5zcGxpdCgnLicpO1xuXHRcdHZhciBlbmNvZGVkID0gbWFwKGxhYmVscywgZm4pLmpvaW4oJy4nKTtcblx0XHRyZXR1cm4gcmVzdWx0ICsgZW5jb2RlZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIG51bWVyaWMgY29kZSBwb2ludHMgb2YgZWFjaCBVbmljb2RlXG5cdCAqIGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nLiBXaGlsZSBKYXZhU2NyaXB0IHVzZXMgVUNTLTIgaW50ZXJuYWxseSxcblx0ICogdGhpcyBmdW5jdGlvbiB3aWxsIGNvbnZlcnQgYSBwYWlyIG9mIHN1cnJvZ2F0ZSBoYWx2ZXMgKGVhY2ggb2Ygd2hpY2hcblx0ICogVUNTLTIgZXhwb3NlcyBhcyBzZXBhcmF0ZSBjaGFyYWN0ZXJzKSBpbnRvIGEgc2luZ2xlIGNvZGUgcG9pbnQsXG5cdCAqIG1hdGNoaW5nIFVURi0xNi5cblx0ICogQHNlZSBgcHVueWNvZGUudWNzMi5lbmNvZGVgXG5cdCAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuXHQgKiBAbmFtZSBkZWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBUaGUgVW5pY29kZSBpbnB1dCBzdHJpbmcgKFVDUy0yKS5cblx0ICogQHJldHVybnMge0FycmF5fSBUaGUgbmV3IGFycmF5IG9mIGNvZGUgcG9pbnRzLlxuXHQgKi9cblx0ZnVuY3Rpb24gdWNzMmRlY29kZShzdHJpbmcpIHtcblx0XHR2YXIgb3V0cHV0ID0gW10sXG5cdFx0ICAgIGNvdW50ZXIgPSAwLFxuXHRcdCAgICBsZW5ndGggPSBzdHJpbmcubGVuZ3RoLFxuXHRcdCAgICB2YWx1ZSxcblx0XHQgICAgZXh0cmE7XG5cdFx0d2hpbGUgKGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdHZhbHVlID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdGlmICh2YWx1ZSA+PSAweEQ4MDAgJiYgdmFsdWUgPD0gMHhEQkZGICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdFx0Ly8gaGlnaCBzdXJyb2dhdGUsIGFuZCB0aGVyZSBpcyBhIG5leHQgY2hhcmFjdGVyXG5cdFx0XHRcdGV4dHJhID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdFx0aWYgKChleHRyYSAmIDB4RkMwMCkgPT0gMHhEQzAwKSB7IC8vIGxvdyBzdXJyb2dhdGVcblx0XHRcdFx0XHRvdXRwdXQucHVzaCgoKHZhbHVlICYgMHgzRkYpIDw8IDEwKSArIChleHRyYSAmIDB4M0ZGKSArIDB4MTAwMDApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIHVubWF0Y2hlZCBzdXJyb2dhdGU7IG9ubHkgYXBwZW5kIHRoaXMgY29kZSB1bml0LCBpbiBjYXNlIHRoZSBuZXh0XG5cdFx0XHRcdFx0Ly8gY29kZSB1bml0IGlzIHRoZSBoaWdoIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0XHRcdGNvdW50ZXItLTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0O1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBzdHJpbmcgYmFzZWQgb24gYW4gYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cblx0ICogQHNlZSBgcHVueWNvZGUudWNzMi5kZWNvZGVgXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGVuY29kZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBjb2RlUG9pbnRzIFRoZSBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgbmV3IFVuaWNvZGUgc3RyaW5nIChVQ1MtMikuXG5cdCAqL1xuXHRmdW5jdGlvbiB1Y3MyZW5jb2RlKGFycmF5KSB7XG5cdFx0cmV0dXJuIG1hcChhcnJheSwgZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHZhciBvdXRwdXQgPSAnJztcblx0XHRcdGlmICh2YWx1ZSA+IDB4RkZGRikge1xuXHRcdFx0XHR2YWx1ZSAtPSAweDEwMDAwO1xuXHRcdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKTtcblx0XHRcdFx0dmFsdWUgPSAweERDMDAgfCB2YWx1ZSAmIDB4M0ZGO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSk7XG5cdFx0XHRyZXR1cm4gb3V0cHV0O1xuXHRcdH0pLmpvaW4oJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgYmFzaWMgY29kZSBwb2ludCBpbnRvIGEgZGlnaXQvaW50ZWdlci5cblx0ICogQHNlZSBgZGlnaXRUb0Jhc2ljKClgXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlUG9pbnQgVGhlIGJhc2ljIG51bWVyaWMgY29kZSBwb2ludCB2YWx1ZS5cblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50IChmb3IgdXNlIGluXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaW4gdGhlIHJhbmdlIGAwYCB0byBgYmFzZSAtIDFgLCBvciBgYmFzZWAgaWZcblx0ICogdGhlIGNvZGUgcG9pbnQgZG9lcyBub3QgcmVwcmVzZW50IGEgdmFsdWUuXG5cdCAqL1xuXHRmdW5jdGlvbiBiYXNpY1RvRGlnaXQoY29kZVBvaW50KSB7XG5cdFx0aWYgKGNvZGVQb2ludCAtIDQ4IDwgMTApIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSAyMjtcblx0XHR9XG5cdFx0aWYgKGNvZGVQb2ludCAtIDY1IDwgMjYpIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSA2NTtcblx0XHR9XG5cdFx0aWYgKGNvZGVQb2ludCAtIDk3IDwgMjYpIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSA5Nztcblx0XHR9XG5cdFx0cmV0dXJuIGJhc2U7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBkaWdpdC9pbnRlZ2VyIGludG8gYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAc2VlIGBiYXNpY1RvRGlnaXQoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGRpZ2l0IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludC5cblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIGJhc2ljIGNvZGUgcG9pbnQgd2hvc2UgdmFsdWUgKHdoZW4gdXNlZCBmb3Jcblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpcyBgZGlnaXRgLCB3aGljaCBuZWVkcyB0byBiZSBpbiB0aGUgcmFuZ2Vcblx0ICogYDBgIHRvIGBiYXNlIC0gMWAuIElmIGBmbGFnYCBpcyBub24temVybywgdGhlIHVwcGVyY2FzZSBmb3JtIGlzXG5cdCAqIHVzZWQ7IGVsc2UsIHRoZSBsb3dlcmNhc2UgZm9ybSBpcyB1c2VkLiBUaGUgYmVoYXZpb3IgaXMgdW5kZWZpbmVkXG5cdCAqIGlmIGBmbGFnYCBpcyBub24temVybyBhbmQgYGRpZ2l0YCBoYXMgbm8gdXBwZXJjYXNlIGZvcm0uXG5cdCAqL1xuXHRmdW5jdGlvbiBkaWdpdFRvQmFzaWMoZGlnaXQsIGZsYWcpIHtcblx0XHQvLyAgMC4uMjUgbWFwIHRvIEFTQ0lJIGEuLnogb3IgQS4uWlxuXHRcdC8vIDI2Li4zNSBtYXAgdG8gQVNDSUkgMC4uOVxuXHRcdHJldHVybiBkaWdpdCArIDIyICsgNzUgKiAoZGlnaXQgPCAyNikgLSAoKGZsYWcgIT0gMCkgPDwgNSk7XG5cdH1cblxuXHQvKipcblx0ICogQmlhcyBhZGFwdGF0aW9uIGZ1bmN0aW9uIGFzIHBlciBzZWN0aW9uIDMuNCBvZiBSRkMgMzQ5Mi5cblx0ICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM0OTIjc2VjdGlvbi0zLjRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGZ1bmN0aW9uIGFkYXB0KGRlbHRhLCBudW1Qb2ludHMsIGZpcnN0VGltZSkge1xuXHRcdHZhciBrID0gMDtcblx0XHRkZWx0YSA9IGZpcnN0VGltZSA/IGZsb29yKGRlbHRhIC8gZGFtcCkgOiBkZWx0YSA+PiAxO1xuXHRcdGRlbHRhICs9IGZsb29yKGRlbHRhIC8gbnVtUG9pbnRzKTtcblx0XHRmb3IgKC8qIG5vIGluaXRpYWxpemF0aW9uICovOyBkZWx0YSA+IGJhc2VNaW51c1RNaW4gKiB0TWF4ID4+IDE7IGsgKz0gYmFzZSkge1xuXHRcdFx0ZGVsdGEgPSBmbG9vcihkZWx0YSAvIGJhc2VNaW51c1RNaW4pO1xuXHRcdH1cblx0XHRyZXR1cm4gZmxvb3IoayArIChiYXNlTWludXNUTWluICsgMSkgKiBkZWx0YSAvIChkZWx0YSArIHNrZXcpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMgdG8gYSBzdHJpbmcgb2YgVW5pY29kZVxuXHQgKiBzeW1ib2xzLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBkZWNvZGUoaW5wdXQpIHtcblx0XHQvLyBEb24ndCB1c2UgVUNTLTJcblx0XHR2YXIgb3V0cHV0ID0gW10sXG5cdFx0ICAgIGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoLFxuXHRcdCAgICBvdXQsXG5cdFx0ICAgIGkgPSAwLFxuXHRcdCAgICBuID0gaW5pdGlhbE4sXG5cdFx0ICAgIGJpYXMgPSBpbml0aWFsQmlhcyxcblx0XHQgICAgYmFzaWMsXG5cdFx0ICAgIGosXG5cdFx0ICAgIGluZGV4LFxuXHRcdCAgICBvbGRpLFxuXHRcdCAgICB3LFxuXHRcdCAgICBrLFxuXHRcdCAgICBkaWdpdCxcblx0XHQgICAgdCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGJhc2VNaW51c1Q7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzOiBsZXQgYGJhc2ljYCBiZSB0aGUgbnVtYmVyIG9mIGlucHV0IGNvZGVcblx0XHQvLyBwb2ludHMgYmVmb3JlIHRoZSBsYXN0IGRlbGltaXRlciwgb3IgYDBgIGlmIHRoZXJlIGlzIG5vbmUsIHRoZW4gY29weVxuXHRcdC8vIHRoZSBmaXJzdCBiYXNpYyBjb2RlIHBvaW50cyB0byB0aGUgb3V0cHV0LlxuXG5cdFx0YmFzaWMgPSBpbnB1dC5sYXN0SW5kZXhPZihkZWxpbWl0ZXIpO1xuXHRcdGlmIChiYXNpYyA8IDApIHtcblx0XHRcdGJhc2ljID0gMDtcblx0XHR9XG5cblx0XHRmb3IgKGogPSAwOyBqIDwgYmFzaWM7ICsraikge1xuXHRcdFx0Ly8gaWYgaXQncyBub3QgYSBiYXNpYyBjb2RlIHBvaW50XG5cdFx0XHRpZiAoaW5wdXQuY2hhckNvZGVBdChqKSA+PSAweDgwKSB7XG5cdFx0XHRcdGVycm9yKCdub3QtYmFzaWMnKTtcblx0XHRcdH1cblx0XHRcdG91dHB1dC5wdXNoKGlucHV0LmNoYXJDb2RlQXQoaikpO1xuXHRcdH1cblxuXHRcdC8vIE1haW4gZGVjb2RpbmcgbG9vcDogc3RhcnQganVzdCBhZnRlciB0aGUgbGFzdCBkZWxpbWl0ZXIgaWYgYW55IGJhc2ljIGNvZGVcblx0XHQvLyBwb2ludHMgd2VyZSBjb3BpZWQ7IHN0YXJ0IGF0IHRoZSBiZWdpbm5pbmcgb3RoZXJ3aXNlLlxuXG5cdFx0Zm9yIChpbmRleCA9IGJhc2ljID4gMCA/IGJhc2ljICsgMSA6IDA7IGluZGV4IDwgaW5wdXRMZW5ndGg7IC8qIG5vIGZpbmFsIGV4cHJlc3Npb24gKi8pIHtcblxuXHRcdFx0Ly8gYGluZGV4YCBpcyB0aGUgaW5kZXggb2YgdGhlIG5leHQgY2hhcmFjdGVyIHRvIGJlIGNvbnN1bWVkLlxuXHRcdFx0Ly8gRGVjb2RlIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXIgaW50byBgZGVsdGFgLFxuXHRcdFx0Ly8gd2hpY2ggZ2V0cyBhZGRlZCB0byBgaWAuIFRoZSBvdmVyZmxvdyBjaGVja2luZyBpcyBlYXNpZXJcblx0XHRcdC8vIGlmIHdlIGluY3JlYXNlIGBpYCBhcyB3ZSBnbywgdGhlbiBzdWJ0cmFjdCBvZmYgaXRzIHN0YXJ0aW5nXG5cdFx0XHQvLyB2YWx1ZSBhdCB0aGUgZW5kIHRvIG9idGFpbiBgZGVsdGFgLlxuXHRcdFx0Zm9yIChvbGRpID0gaSwgdyA9IDEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXG5cdFx0XHRcdGlmIChpbmRleCA+PSBpbnB1dExlbmd0aCkge1xuXHRcdFx0XHRcdGVycm9yKCdpbnZhbGlkLWlucHV0Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkaWdpdCA9IGJhc2ljVG9EaWdpdChpbnB1dC5jaGFyQ29kZUF0KGluZGV4KyspKTtcblxuXHRcdFx0XHRpZiAoZGlnaXQgPj0gYmFzZSB8fCBkaWdpdCA+IGZsb29yKChtYXhJbnQgLSBpKSAvIHcpKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpICs9IGRpZ2l0ICogdztcblx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0IDwgdCkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRpZiAodyA+IGZsb29yKG1heEludCAvIGJhc2VNaW51c1QpKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR3ICo9IGJhc2VNaW51c1Q7XG5cblx0XHRcdH1cblxuXHRcdFx0b3V0ID0gb3V0cHV0Lmxlbmd0aCArIDE7XG5cdFx0XHRiaWFzID0gYWRhcHQoaSAtIG9sZGksIG91dCwgb2xkaSA9PSAwKTtcblxuXHRcdFx0Ly8gYGlgIHdhcyBzdXBwb3NlZCB0byB3cmFwIGFyb3VuZCBmcm9tIGBvdXRgIHRvIGAwYCxcblx0XHRcdC8vIGluY3JlbWVudGluZyBgbmAgZWFjaCB0aW1lLCBzbyB3ZSdsbCBmaXggdGhhdCBub3c6XG5cdFx0XHRpZiAoZmxvb3IoaSAvIG91dCkgPiBtYXhJbnQgLSBuKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRuICs9IGZsb29yKGkgLyBvdXQpO1xuXHRcdFx0aSAlPSBvdXQ7XG5cblx0XHRcdC8vIEluc2VydCBgbmAgYXQgcG9zaXRpb24gYGlgIG9mIHRoZSBvdXRwdXRcblx0XHRcdG91dHB1dC5zcGxpY2UoaSsrLCAwLCBuKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB1Y3MyZW5jb2RlKG91dHB1dCk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzIChlLmcuIGEgZG9tYWluIG5hbWUgbGFiZWwpIHRvIGFcblx0ICogUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZW5jb2RlKGlucHV0KSB7XG5cdFx0dmFyIG4sXG5cdFx0ICAgIGRlbHRhLFxuXHRcdCAgICBoYW5kbGVkQ1BDb3VudCxcblx0XHQgICAgYmFzaWNMZW5ndGgsXG5cdFx0ICAgIGJpYXMsXG5cdFx0ICAgIGosXG5cdFx0ICAgIG0sXG5cdFx0ICAgIHEsXG5cdFx0ICAgIGssXG5cdFx0ICAgIHQsXG5cdFx0ICAgIGN1cnJlbnRWYWx1ZSxcblx0XHQgICAgb3V0cHV0ID0gW10sXG5cdFx0ICAgIC8qKiBgaW5wdXRMZW5ndGhgIHdpbGwgaG9sZCB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIGluIGBpbnB1dGAuICovXG5cdFx0ICAgIGlucHV0TGVuZ3RoLFxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cblx0XHQgICAgaGFuZGxlZENQQ291bnRQbHVzT25lLFxuXHRcdCAgICBiYXNlTWludXNULFxuXHRcdCAgICBxTWludXNUO1xuXG5cdFx0Ly8gQ29udmVydCB0aGUgaW5wdXQgaW4gVUNTLTIgdG8gVW5pY29kZVxuXHRcdGlucHV0ID0gdWNzMmRlY29kZShpbnB1dCk7XG5cblx0XHQvLyBDYWNoZSB0aGUgbGVuZ3RoXG5cdFx0aW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG5cblx0XHQvLyBJbml0aWFsaXplIHRoZSBzdGF0ZVxuXHRcdG4gPSBpbml0aWFsTjtcblx0XHRkZWx0YSA9IDA7XG5cdFx0YmlhcyA9IGluaXRpYWxCaWFzO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50c1xuXHRcdGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCAweDgwKSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShjdXJyZW50VmFsdWUpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRoYW5kbGVkQ1BDb3VudCA9IGJhc2ljTGVuZ3RoID0gb3V0cHV0Lmxlbmd0aDtcblxuXHRcdC8vIGBoYW5kbGVkQ1BDb3VudGAgaXMgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyB0aGF0IGhhdmUgYmVlbiBoYW5kbGVkO1xuXHRcdC8vIGBiYXNpY0xlbmd0aGAgaXMgdGhlIG51bWJlciBvZiBiYXNpYyBjb2RlIHBvaW50cy5cblxuXHRcdC8vIEZpbmlzaCB0aGUgYmFzaWMgc3RyaW5nIC0gaWYgaXQgaXMgbm90IGVtcHR5IC0gd2l0aCBhIGRlbGltaXRlclxuXHRcdGlmIChiYXNpY0xlbmd0aCkge1xuXHRcdFx0b3V0cHV0LnB1c2goZGVsaW1pdGVyKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGVuY29kaW5nIGxvb3A6XG5cdFx0d2hpbGUgKGhhbmRsZWRDUENvdW50IDwgaW5wdXRMZW5ndGgpIHtcblxuXHRcdFx0Ly8gQWxsIG5vbi1iYXNpYyBjb2RlIHBvaW50cyA8IG4gaGF2ZSBiZWVuIGhhbmRsZWQgYWxyZWFkeS4gRmluZCB0aGUgbmV4dFxuXHRcdFx0Ly8gbGFyZ2VyIG9uZTpcblx0XHRcdGZvciAobSA9IG1heEludCwgaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID49IG4gJiYgY3VycmVudFZhbHVlIDwgbSkge1xuXHRcdFx0XHRcdG0gPSBjdXJyZW50VmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gSW5jcmVhc2UgYGRlbHRhYCBlbm91Z2ggdG8gYWR2YW5jZSB0aGUgZGVjb2RlcidzIDxuLGk+IHN0YXRlIHRvIDxtLDA+LFxuXHRcdFx0Ly8gYnV0IGd1YXJkIGFnYWluc3Qgb3ZlcmZsb3dcblx0XHRcdGhhbmRsZWRDUENvdW50UGx1c09uZSA9IGhhbmRsZWRDUENvdW50ICsgMTtcblx0XHRcdGlmIChtIC0gbiA+IGZsb29yKChtYXhJbnQgLSBkZWx0YSkgLyBoYW5kbGVkQ1BDb3VudFBsdXNPbmUpKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWx0YSArPSAobSAtIG4pICogaGFuZGxlZENQQ291bnRQbHVzT25lO1xuXHRcdFx0biA9IG07XG5cblx0XHRcdGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCBuICYmICsrZGVsdGEgPiBtYXhJbnQpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPT0gbikge1xuXHRcdFx0XHRcdC8vIFJlcHJlc2VudCBkZWx0YSBhcyBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyXG5cdFx0XHRcdFx0Zm9yIChxID0gZGVsdGEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXHRcdFx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cdFx0XHRcdFx0XHRpZiAocSA8IHQpIHtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRxTWludXNUID0gcSAtIHQ7XG5cdFx0XHRcdFx0XHRiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdFx0XHRvdXRwdXQucHVzaChcblx0XHRcdFx0XHRcdFx0c3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyh0ICsgcU1pbnVzVCAlIGJhc2VNaW51c1QsIDApKVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdHEgPSBmbG9vcihxTWludXNUIC8gYmFzZU1pbnVzVCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyhxLCAwKSkpO1xuXHRcdFx0XHRcdGJpYXMgPSBhZGFwdChkZWx0YSwgaGFuZGxlZENQQ291bnRQbHVzT25lLCBoYW5kbGVkQ1BDb3VudCA9PSBiYXNpY0xlbmd0aCk7XG5cdFx0XHRcdFx0ZGVsdGEgPSAwO1xuXHRcdFx0XHRcdCsraGFuZGxlZENQQ291bnQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0KytkZWx0YTtcblx0XHRcdCsrbjtcblxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0LmpvaW4oJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3Ncblx0ICogdG8gVW5pY29kZS4gT25seSB0aGUgUHVueWNvZGVkIHBhcnRzIG9mIHRoZSBpbnB1dCB3aWxsIGJlIGNvbnZlcnRlZCwgaS5lLlxuXHQgKiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCBvbiBhIHN0cmluZyB0aGF0IGhhcyBhbHJlYWR5IGJlZW5cblx0ICogY29udmVydGVkIHRvIFVuaWNvZGUuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlZCBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvXG5cdCAqIGNvbnZlcnQgdG8gVW5pY29kZS5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFVuaWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIFB1bnljb2RlXG5cdCAqIHN0cmluZy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvVW5pY29kZShpbnB1dCkge1xuXHRcdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHJlZ2V4UHVueWNvZGUudGVzdChzdHJpbmcpXG5cdFx0XHRcdD8gZGVjb2RlKHN0cmluZy5zbGljZSg0KS50b0xvd2VyQ2FzZSgpKVxuXHRcdFx0XHQ6IHN0cmluZztcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFVuaWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3MgdG9cblx0ICogUHVueWNvZGUuIE9ubHkgdGhlIG5vbi1BU0NJSSBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgd2lsbCBiZSBjb252ZXJ0ZWQsXG5cdCAqIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0J3MgYWxyZWFkeSBpblxuXHQgKiBBU0NJSS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0byBjb252ZXJ0LCBhcyBhXG5cdCAqIFVuaWNvZGUgc3RyaW5nLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgUHVueWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIGRvbWFpbiBuYW1lIG9yXG5cdCAqIGVtYWlsIGFkZHJlc3MuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b0FTQ0lJKGlucHV0KSB7XG5cdFx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhOb25BU0NJSS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyAneG4tLScgKyBlbmNvZGUoc3RyaW5nKVxuXHRcdFx0XHQ6IHN0cmluZztcblx0XHR9KTtcblx0fVxuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8qKiBEZWZpbmUgdGhlIHB1YmxpYyBBUEkgKi9cblx0cHVueWNvZGUgPSB7XG5cdFx0LyoqXG5cdFx0ICogQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IFB1bnljb2RlLmpzIHZlcnNpb24gbnVtYmVyLlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIFN0cmluZ1xuXHRcdCAqL1xuXHRcdCd2ZXJzaW9uJzogJzEuNC4xJyxcblx0XHQvKipcblx0XHQgKiBBbiBvYmplY3Qgb2YgbWV0aG9kcyB0byBjb252ZXJ0IGZyb20gSmF2YVNjcmlwdCdzIGludGVybmFsIGNoYXJhY3RlclxuXHRcdCAqIHJlcHJlc2VudGF0aW9uIChVQ1MtMikgdG8gVW5pY29kZSBjb2RlIHBvaW50cywgYW5kIGJhY2suXG5cdFx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgT2JqZWN0XG5cdFx0ICovXG5cdFx0J3VjczInOiB7XG5cdFx0XHQnZGVjb2RlJzogdWNzMmRlY29kZSxcblx0XHRcdCdlbmNvZGUnOiB1Y3MyZW5jb2RlXG5cdFx0fSxcblx0XHQnZGVjb2RlJzogZGVjb2RlLFxuXHRcdCdlbmNvZGUnOiBlbmNvZGUsXG5cdFx0J3RvQVNDSUknOiB0b0FTQ0lJLFxuXHRcdCd0b1VuaWNvZGUnOiB0b1VuaWNvZGVcblx0fTtcblxuXHQvKiogRXhwb3NlIGBwdW55Y29kZWAgKi9cblx0Ly8gU29tZSBBTUQgYnVpbGQgb3B0aW1pemVycywgbGlrZSByLmpzLCBjaGVjayBmb3Igc3BlY2lmaWMgY29uZGl0aW9uIHBhdHRlcm5zXG5cdC8vIGxpa2UgdGhlIGZvbGxvd2luZzpcblx0aWYgKFxuXHRcdHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdHR5cGVvZiBkZWZpbmUuYW1kID09ICdvYmplY3QnICYmXG5cdFx0ZGVmaW5lLmFtZFxuXHQpIHtcblx0XHRkZWZpbmUoJ3B1bnljb2RlJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gcHVueWNvZGU7XG5cdFx0fSk7XG5cdH0gZWxzZSBpZiAoZnJlZUV4cG9ydHMgJiYgZnJlZU1vZHVsZSkge1xuXHRcdGlmIChtb2R1bGUuZXhwb3J0cyA9PSBmcmVlRXhwb3J0cykge1xuXHRcdFx0Ly8gaW4gTm9kZS5qcywgaW8uanMsIG9yIFJpbmdvSlMgdjAuOC4wK1xuXHRcdFx0ZnJlZU1vZHVsZS5leHBvcnRzID0gcHVueWNvZGU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGluIE5hcndoYWwgb3IgUmluZ29KUyB2MC43LjAtXG5cdFx0XHRmb3IgKGtleSBpbiBwdW55Y29kZSkge1xuXHRcdFx0XHRwdW55Y29kZS5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIChmcmVlRXhwb3J0c1trZXldID0gcHVueWNvZGVba2V5XSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdC8vIGluIFJoaW5vIG9yIGEgd2ViIGJyb3dzZXJcblx0XHRyb290LnB1bnljb2RlID0gcHVueWNvZGU7XG5cdH1cblxufSh0aGlzKSk7XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBJZiBvYmouaGFzT3duUHJvcGVydHkgaGFzIGJlZW4gb3ZlcnJpZGRlbiwgdGhlbiBjYWxsaW5nXG4vLyBvYmouaGFzT3duUHJvcGVydHkocHJvcCkgd2lsbCBicmVhay5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2pveWVudC9ub2RlL2lzc3Vlcy8xNzA3XG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHFzLCBzZXAsIGVxLCBvcHRpb25zKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICB2YXIgb2JqID0ge307XG5cbiAgaWYgKHR5cGVvZiBxcyAhPT0gJ3N0cmluZycgfHwgcXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIHZhciByZWdleHAgPSAvXFwrL2c7XG4gIHFzID0gcXMuc3BsaXQoc2VwKTtcblxuICB2YXIgbWF4S2V5cyA9IDEwMDA7XG4gIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLm1heEtleXMgPT09ICdudW1iZXInKSB7XG4gICAgbWF4S2V5cyA9IG9wdGlvbnMubWF4S2V5cztcbiAgfVxuXG4gIHZhciBsZW4gPSBxcy5sZW5ndGg7XG4gIC8vIG1heEtleXMgPD0gMCBtZWFucyB0aGF0IHdlIHNob3VsZCBub3QgbGltaXQga2V5cyBjb3VudFxuICBpZiAobWF4S2V5cyA+IDAgJiYgbGVuID4gbWF4S2V5cykge1xuICAgIGxlbiA9IG1heEtleXM7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgdmFyIHggPSBxc1tpXS5yZXBsYWNlKHJlZ2V4cCwgJyUyMCcpLFxuICAgICAgICBpZHggPSB4LmluZGV4T2YoZXEpLFxuICAgICAgICBrc3RyLCB2c3RyLCBrLCB2O1xuXG4gICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICBrc3RyID0geC5zdWJzdHIoMCwgaWR4KTtcbiAgICAgIHZzdHIgPSB4LnN1YnN0cihpZHggKyAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAga3N0ciA9IHg7XG4gICAgICB2c3RyID0gJyc7XG4gICAgfVxuXG4gICAgayA9IGRlY29kZVVSSUNvbXBvbmVudChrc3RyKTtcbiAgICB2ID0gZGVjb2RlVVJJQ29tcG9uZW50KHZzdHIpO1xuXG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eShvYmosIGspKSB7XG4gICAgICBvYmpba10gPSB2O1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheShvYmpba10pKSB7XG4gICAgICBvYmpba10ucHVzaCh2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqW2tdID0gW29ialtrXSwgdl07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHN0cmluZ2lmeVByaW1pdGl2ZSA9IGZ1bmN0aW9uKHYpIHtcbiAgc3dpdGNoICh0eXBlb2Ygdikge1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICByZXR1cm4gdjtcblxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgcmV0dXJuIHYgPyAndHJ1ZScgOiAnZmFsc2UnO1xuXG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIHJldHVybiBpc0Zpbml0ZSh2KSA/IHYgOiAnJztcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gJyc7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqLCBzZXAsIGVxLCBuYW1lKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICBpZiAob2JqID09PSBudWxsKSB7XG4gICAgb2JqID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG1hcChvYmplY3RLZXlzKG9iaiksIGZ1bmN0aW9uKGspIHtcbiAgICAgIHZhciBrcyA9IGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUoaykpICsgZXE7XG4gICAgICBpZiAoaXNBcnJheShvYmpba10pKSB7XG4gICAgICAgIHJldHVybiBtYXAob2JqW2tdLCBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZSh2KSk7XG4gICAgICAgIH0pLmpvaW4oc2VwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqW2tdKSk7XG4gICAgICB9XG4gICAgfSkuam9pbihzZXApO1xuXG4gIH1cblxuICBpZiAoIW5hbWUpIHJldHVybiAnJztcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUobmFtZSkpICsgZXEgK1xuICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmopKTtcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG5mdW5jdGlvbiBtYXAgKHhzLCBmKSB7XG4gIGlmICh4cy5tYXApIHJldHVybiB4cy5tYXAoZik7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgIHJlcy5wdXNoKGYoeHNbaV0sIGkpKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHJlcy5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuZGVjb2RlID0gZXhwb3J0cy5wYXJzZSA9IHJlcXVpcmUoJy4vZGVjb2RlJyk7XG5leHBvcnRzLmVuY29kZSA9IGV4cG9ydHMuc3RyaW5naWZ5ID0gcmVxdWlyZSgnLi9lbmNvZGUnKTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBwdW55Y29kZSA9IHJlcXVpcmUoJ3B1bnljb2RlJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG5leHBvcnRzLnBhcnNlID0gdXJsUGFyc2U7XG5leHBvcnRzLnJlc29sdmUgPSB1cmxSZXNvbHZlO1xuZXhwb3J0cy5yZXNvbHZlT2JqZWN0ID0gdXJsUmVzb2x2ZU9iamVjdDtcbmV4cG9ydHMuZm9ybWF0ID0gdXJsRm9ybWF0O1xuXG5leHBvcnRzLlVybCA9IFVybDtcblxuZnVuY3Rpb24gVXJsKCkge1xuICB0aGlzLnByb3RvY29sID0gbnVsbDtcbiAgdGhpcy5zbGFzaGVzID0gbnVsbDtcbiAgdGhpcy5hdXRoID0gbnVsbDtcbiAgdGhpcy5ob3N0ID0gbnVsbDtcbiAgdGhpcy5wb3J0ID0gbnVsbDtcbiAgdGhpcy5ob3N0bmFtZSA9IG51bGw7XG4gIHRoaXMuaGFzaCA9IG51bGw7XG4gIHRoaXMuc2VhcmNoID0gbnVsbDtcbiAgdGhpcy5xdWVyeSA9IG51bGw7XG4gIHRoaXMucGF0aG5hbWUgPSBudWxsO1xuICB0aGlzLnBhdGggPSBudWxsO1xuICB0aGlzLmhyZWYgPSBudWxsO1xufVxuXG4vLyBSZWZlcmVuY2U6IFJGQyAzOTg2LCBSRkMgMTgwOCwgUkZDIDIzOTZcblxuLy8gZGVmaW5lIHRoZXNlIGhlcmUgc28gYXQgbGVhc3QgdGhleSBvbmx5IGhhdmUgdG8gYmVcbi8vIGNvbXBpbGVkIG9uY2Ugb24gdGhlIGZpcnN0IG1vZHVsZSBsb2FkLlxudmFyIHByb3RvY29sUGF0dGVybiA9IC9eKFthLXowLTkuKy1dKzopL2ksXG4gICAgcG9ydFBhdHRlcm4gPSAvOlswLTldKiQvLFxuXG4gICAgLy8gU3BlY2lhbCBjYXNlIGZvciBhIHNpbXBsZSBwYXRoIFVSTFxuICAgIHNpbXBsZVBhdGhQYXR0ZXJuID0gL14oXFwvXFwvPyg/IVxcLylbXlxcP1xcc10qKShcXD9bXlxcc10qKT8kLyxcblxuICAgIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIHJlc2VydmVkIGZvciBkZWxpbWl0aW5nIFVSTHMuXG4gICAgLy8gV2UgYWN0dWFsbHkganVzdCBhdXRvLWVzY2FwZSB0aGVzZS5cbiAgICBkZWxpbXMgPSBbJzwnLCAnPicsICdcIicsICdgJywgJyAnLCAnXFxyJywgJ1xcbicsICdcXHQnXSxcblxuICAgIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIG5vdCBhbGxvd2VkIGZvciB2YXJpb3VzIHJlYXNvbnMuXG4gICAgdW53aXNlID0gWyd7JywgJ30nLCAnfCcsICdcXFxcJywgJ14nLCAnYCddLmNvbmNhdChkZWxpbXMpLFxuXG4gICAgLy8gQWxsb3dlZCBieSBSRkNzLCBidXQgY2F1c2Ugb2YgWFNTIGF0dGFja3MuICBBbHdheXMgZXNjYXBlIHRoZXNlLlxuICAgIGF1dG9Fc2NhcGUgPSBbJ1xcJyddLmNvbmNhdCh1bndpc2UpLFxuICAgIC8vIENoYXJhY3RlcnMgdGhhdCBhcmUgbmV2ZXIgZXZlciBhbGxvd2VkIGluIGEgaG9zdG5hbWUuXG4gICAgLy8gTm90ZSB0aGF0IGFueSBpbnZhbGlkIGNoYXJzIGFyZSBhbHNvIGhhbmRsZWQsIGJ1dCB0aGVzZVxuICAgIC8vIGFyZSB0aGUgb25lcyB0aGF0IGFyZSAqZXhwZWN0ZWQqIHRvIGJlIHNlZW4sIHNvIHdlIGZhc3QtcGF0aFxuICAgIC8vIHRoZW0uXG4gICAgbm9uSG9zdENoYXJzID0gWyclJywgJy8nLCAnPycsICc7JywgJyMnXS5jb25jYXQoYXV0b0VzY2FwZSksXG4gICAgaG9zdEVuZGluZ0NoYXJzID0gWycvJywgJz8nLCAnIyddLFxuICAgIGhvc3RuYW1lTWF4TGVuID0gMjU1LFxuICAgIGhvc3RuYW1lUGFydFBhdHRlcm4gPSAvXlsrYS16MC05QS1aXy1dezAsNjN9JC8sXG4gICAgaG9zdG5hbWVQYXJ0U3RhcnQgPSAvXihbK2EtejAtOUEtWl8tXXswLDYzfSkoLiopJC8sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgY2FuIGFsbG93IFwidW5zYWZlXCIgYW5kIFwidW53aXNlXCIgY2hhcnMuXG4gICAgdW5zYWZlUHJvdG9jb2wgPSB7XG4gICAgICAnamF2YXNjcmlwdCc6IHRydWUsXG4gICAgICAnamF2YXNjcmlwdDonOiB0cnVlXG4gICAgfSxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBuZXZlciBoYXZlIGEgaG9zdG5hbWUuXG4gICAgaG9zdGxlc3NQcm90b2NvbCA9IHtcbiAgICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IGFsd2F5cyBjb250YWluIGEgLy8gYml0LlxuICAgIHNsYXNoZWRQcm90b2NvbCA9IHtcbiAgICAgICdodHRwJzogdHJ1ZSxcbiAgICAgICdodHRwcyc6IHRydWUsXG4gICAgICAnZnRwJzogdHJ1ZSxcbiAgICAgICdnb3BoZXInOiB0cnVlLFxuICAgICAgJ2ZpbGUnOiB0cnVlLFxuICAgICAgJ2h0dHA6JzogdHJ1ZSxcbiAgICAgICdodHRwczonOiB0cnVlLFxuICAgICAgJ2Z0cDonOiB0cnVlLFxuICAgICAgJ2dvcGhlcjonOiB0cnVlLFxuICAgICAgJ2ZpbGU6JzogdHJ1ZVxuICAgIH0sXG4gICAgcXVlcnlzdHJpbmcgPSByZXF1aXJlKCdxdWVyeXN0cmluZycpO1xuXG5mdW5jdGlvbiB1cmxQYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIGlmICh1cmwgJiYgdXRpbC5pc09iamVjdCh1cmwpICYmIHVybCBpbnN0YW5jZW9mIFVybCkgcmV0dXJuIHVybDtcblxuICB2YXIgdSA9IG5ldyBVcmw7XG4gIHUucGFyc2UodXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCk7XG4gIHJldHVybiB1O1xufVxuXG5VcmwucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24odXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICBpZiAoIXV0aWwuaXNTdHJpbmcodXJsKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQYXJhbWV0ZXIgJ3VybCcgbXVzdCBiZSBhIHN0cmluZywgbm90IFwiICsgdHlwZW9mIHVybCk7XG4gIH1cblxuICAvLyBDb3B5IGNocm9tZSwgSUUsIG9wZXJhIGJhY2tzbGFzaC1oYW5kbGluZyBiZWhhdmlvci5cbiAgLy8gQmFjayBzbGFzaGVzIGJlZm9yZSB0aGUgcXVlcnkgc3RyaW5nIGdldCBjb252ZXJ0ZWQgdG8gZm9yd2FyZCBzbGFzaGVzXG4gIC8vIFNlZTogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTI1OTE2XG4gIHZhciBxdWVyeUluZGV4ID0gdXJsLmluZGV4T2YoJz8nKSxcbiAgICAgIHNwbGl0dGVyID1cbiAgICAgICAgICAocXVlcnlJbmRleCAhPT0gLTEgJiYgcXVlcnlJbmRleCA8IHVybC5pbmRleE9mKCcjJykpID8gJz8nIDogJyMnLFxuICAgICAgdVNwbGl0ID0gdXJsLnNwbGl0KHNwbGl0dGVyKSxcbiAgICAgIHNsYXNoUmVnZXggPSAvXFxcXC9nO1xuICB1U3BsaXRbMF0gPSB1U3BsaXRbMF0ucmVwbGFjZShzbGFzaFJlZ2V4LCAnLycpO1xuICB1cmwgPSB1U3BsaXQuam9pbihzcGxpdHRlcik7XG5cbiAgdmFyIHJlc3QgPSB1cmw7XG5cbiAgLy8gdHJpbSBiZWZvcmUgcHJvY2VlZGluZy5cbiAgLy8gVGhpcyBpcyB0byBzdXBwb3J0IHBhcnNlIHN0dWZmIGxpa2UgXCIgIGh0dHA6Ly9mb28uY29tICBcXG5cIlxuICByZXN0ID0gcmVzdC50cmltKCk7XG5cbiAgaWYgKCFzbGFzaGVzRGVub3RlSG9zdCAmJiB1cmwuc3BsaXQoJyMnKS5sZW5ndGggPT09IDEpIHtcbiAgICAvLyBUcnkgZmFzdCBwYXRoIHJlZ2V4cFxuICAgIHZhciBzaW1wbGVQYXRoID0gc2ltcGxlUGF0aFBhdHRlcm4uZXhlYyhyZXN0KTtcbiAgICBpZiAoc2ltcGxlUGF0aCkge1xuICAgICAgdGhpcy5wYXRoID0gcmVzdDtcbiAgICAgIHRoaXMuaHJlZiA9IHJlc3Q7XG4gICAgICB0aGlzLnBhdGhuYW1lID0gc2ltcGxlUGF0aFsxXTtcbiAgICAgIGlmIChzaW1wbGVQYXRoWzJdKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoID0gc2ltcGxlUGF0aFsyXTtcbiAgICAgICAgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnlzdHJpbmcucGFyc2UodGhpcy5zZWFyY2guc3Vic3RyKDEpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnF1ZXJ5ID0gdGhpcy5zZWFyY2guc3Vic3RyKDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgICAgdGhpcy5zZWFyY2ggPSAnJztcbiAgICAgICAgdGhpcy5xdWVyeSA9IHt9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XG5cbiAgdmFyIHByb3RvID0gcHJvdG9jb2xQYXR0ZXJuLmV4ZWMocmVzdCk7XG4gIGlmIChwcm90bykge1xuICAgIHByb3RvID0gcHJvdG9bMF07XG4gICAgdmFyIGxvd2VyUHJvdG8gPSBwcm90by50b0xvd2VyQ2FzZSgpO1xuICAgIHRoaXMucHJvdG9jb2wgPSBsb3dlclByb3RvO1xuICAgIHJlc3QgPSByZXN0LnN1YnN0cihwcm90by5sZW5ndGgpO1xuICB9XG5cbiAgLy8gZmlndXJlIG91dCBpZiBpdCdzIGdvdCBhIGhvc3RcbiAgLy8gdXNlckBzZXJ2ZXIgaXMgKmFsd2F5cyogaW50ZXJwcmV0ZWQgYXMgYSBob3N0bmFtZSwgYW5kIHVybFxuICAvLyByZXNvbHV0aW9uIHdpbGwgdHJlYXQgLy9mb28vYmFyIGFzIGhvc3Q9Zm9vLHBhdGg9YmFyIGJlY2F1c2UgdGhhdCdzXG4gIC8vIGhvdyB0aGUgYnJvd3NlciByZXNvbHZlcyByZWxhdGl2ZSBVUkxzLlxuICBpZiAoc2xhc2hlc0Rlbm90ZUhvc3QgfHwgcHJvdG8gfHwgcmVzdC5tYXRjaCgvXlxcL1xcL1teQFxcL10rQFteQFxcL10rLykpIHtcbiAgICB2YXIgc2xhc2hlcyA9IHJlc3Quc3Vic3RyKDAsIDIpID09PSAnLy8nO1xuICAgIGlmIChzbGFzaGVzICYmICEocHJvdG8gJiYgaG9zdGxlc3NQcm90b2NvbFtwcm90b10pKSB7XG4gICAgICByZXN0ID0gcmVzdC5zdWJzdHIoMik7XG4gICAgICB0aGlzLnNsYXNoZXMgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICghaG9zdGxlc3NQcm90b2NvbFtwcm90b10gJiZcbiAgICAgIChzbGFzaGVzIHx8IChwcm90byAmJiAhc2xhc2hlZFByb3RvY29sW3Byb3RvXSkpKSB7XG5cbiAgICAvLyB0aGVyZSdzIGEgaG9zdG5hbWUuXG4gICAgLy8gdGhlIGZpcnN0IGluc3RhbmNlIG9mIC8sID8sIDssIG9yICMgZW5kcyB0aGUgaG9zdC5cbiAgICAvL1xuICAgIC8vIElmIHRoZXJlIGlzIGFuIEAgaW4gdGhlIGhvc3RuYW1lLCB0aGVuIG5vbi1ob3N0IGNoYXJzICphcmUqIGFsbG93ZWRcbiAgICAvLyB0byB0aGUgbGVmdCBvZiB0aGUgbGFzdCBAIHNpZ24sIHVubGVzcyBzb21lIGhvc3QtZW5kaW5nIGNoYXJhY3RlclxuICAgIC8vIGNvbWVzICpiZWZvcmUqIHRoZSBALXNpZ24uXG4gICAgLy8gVVJMcyBhcmUgb2Jub3hpb3VzLlxuICAgIC8vXG4gICAgLy8gZXg6XG4gICAgLy8gaHR0cDovL2FAYkBjLyA9PiB1c2VyOmFAYiBob3N0OmNcbiAgICAvLyBodHRwOi8vYUBiP0BjID0+IHVzZXI6YSBob3N0OmMgcGF0aDovP0BjXG5cbiAgICAvLyB2MC4xMiBUT0RPKGlzYWFjcyk6IFRoaXMgaXMgbm90IHF1aXRlIGhvdyBDaHJvbWUgZG9lcyB0aGluZ3MuXG4gICAgLy8gUmV2aWV3IG91ciB0ZXN0IGNhc2UgYWdhaW5zdCBicm93c2VycyBtb3JlIGNvbXByZWhlbnNpdmVseS5cblxuICAgIC8vIGZpbmQgdGhlIGZpcnN0IGluc3RhbmNlIG9mIGFueSBob3N0RW5kaW5nQ2hhcnNcbiAgICB2YXIgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9zdEVuZGluZ0NoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGVjID0gcmVzdC5pbmRleE9mKGhvc3RFbmRpbmdDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpXG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgfVxuXG4gICAgLy8gYXQgdGhpcyBwb2ludCwgZWl0aGVyIHdlIGhhdmUgYW4gZXhwbGljaXQgcG9pbnQgd2hlcmUgdGhlXG4gICAgLy8gYXV0aCBwb3J0aW9uIGNhbm5vdCBnbyBwYXN0LCBvciB0aGUgbGFzdCBAIGNoYXIgaXMgdGhlIGRlY2lkZXIuXG4gICAgdmFyIGF1dGgsIGF0U2lnbjtcbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpIHtcbiAgICAgIC8vIGF0U2lnbiBjYW4gYmUgYW55d2hlcmUuXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGF0U2lnbiBtdXN0IGJlIGluIGF1dGggcG9ydGlvbi5cbiAgICAgIC8vIGh0dHA6Ly9hQGIvY0BkID0+IGhvc3Q6YiBhdXRoOmEgcGF0aDovY0BkXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJywgaG9zdEVuZCk7XG4gICAgfVxuXG4gICAgLy8gTm93IHdlIGhhdmUgYSBwb3J0aW9uIHdoaWNoIGlzIGRlZmluaXRlbHkgdGhlIGF1dGguXG4gICAgLy8gUHVsbCB0aGF0IG9mZi5cbiAgICBpZiAoYXRTaWduICE9PSAtMSkge1xuICAgICAgYXV0aCA9IHJlc3Quc2xpY2UoMCwgYXRTaWduKTtcbiAgICAgIHJlc3QgPSByZXN0LnNsaWNlKGF0U2lnbiArIDEpO1xuICAgICAgdGhpcy5hdXRoID0gZGVjb2RlVVJJQ29tcG9uZW50KGF1dGgpO1xuICAgIH1cblxuICAgIC8vIHRoZSBob3N0IGlzIHRoZSByZW1haW5pbmcgdG8gdGhlIGxlZnQgb2YgdGhlIGZpcnN0IG5vbi1ob3N0IGNoYXJcbiAgICBob3N0RW5kID0gLTE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub25Ib3N0Q2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoZWMgPSByZXN0LmluZGV4T2Yobm9uSG9zdENoYXJzW2ldKTtcbiAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSlcbiAgICAgICAgaG9zdEVuZCA9IGhlYztcbiAgICB9XG4gICAgLy8gaWYgd2Ugc3RpbGwgaGF2ZSBub3QgaGl0IGl0LCB0aGVuIHRoZSBlbnRpcmUgdGhpbmcgaXMgYSBob3N0LlxuICAgIGlmIChob3N0RW5kID09PSAtMSlcbiAgICAgIGhvc3RFbmQgPSByZXN0Lmxlbmd0aDtcblxuICAgIHRoaXMuaG9zdCA9IHJlc3Quc2xpY2UoMCwgaG9zdEVuZCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoaG9zdEVuZCk7XG5cbiAgICAvLyBwdWxsIG91dCBwb3J0LlxuICAgIHRoaXMucGFyc2VIb3N0KCk7XG5cbiAgICAvLyB3ZSd2ZSBpbmRpY2F0ZWQgdGhhdCB0aGVyZSBpcyBhIGhvc3RuYW1lLFxuICAgIC8vIHNvIGV2ZW4gaWYgaXQncyBlbXB0eSwgaXQgaGFzIHRvIGJlIHByZXNlbnQuXG4gICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUgfHwgJyc7XG5cbiAgICAvLyBpZiBob3N0bmFtZSBiZWdpbnMgd2l0aCBbIGFuZCBlbmRzIHdpdGggXVxuICAgIC8vIGFzc3VtZSB0aGF0IGl0J3MgYW4gSVB2NiBhZGRyZXNzLlxuICAgIHZhciBpcHY2SG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lWzBdID09PSAnWycgJiZcbiAgICAgICAgdGhpcy5ob3N0bmFtZVt0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDFdID09PSAnXSc7XG5cbiAgICAvLyB2YWxpZGF0ZSBhIGxpdHRsZS5cbiAgICBpZiAoIWlwdjZIb3N0bmFtZSkge1xuICAgICAgdmFyIGhvc3RwYXJ0cyA9IHRoaXMuaG9zdG5hbWUuc3BsaXQoL1xcLi8pO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBob3N0cGFydHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gaG9zdHBhcnRzW2ldO1xuICAgICAgICBpZiAoIXBhcnQpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIXBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICB2YXIgbmV3cGFydCA9ICcnO1xuICAgICAgICAgIGZvciAodmFyIGogPSAwLCBrID0gcGFydC5sZW5ndGg7IGogPCBrOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChwYXJ0LmNoYXJDb2RlQXQoaikgPiAxMjcpIHtcbiAgICAgICAgICAgICAgLy8gd2UgcmVwbGFjZSBub24tQVNDSUkgY2hhciB3aXRoIGEgdGVtcG9yYXJ5IHBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgIC8vIHdlIG5lZWQgdGhpcyB0byBtYWtlIHN1cmUgc2l6ZSBvZiBob3N0bmFtZSBpcyBub3RcbiAgICAgICAgICAgICAgLy8gYnJva2VuIGJ5IHJlcGxhY2luZyBub24tQVNDSUkgYnkgbm90aGluZ1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9ICd4JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gcGFydFtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gd2UgdGVzdCBhZ2FpbiB3aXRoIEFTQ0lJIGNoYXIgb25seVxuICAgICAgICAgIGlmICghbmV3cGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgICAgdmFyIHZhbGlkUGFydHMgPSBob3N0cGFydHMuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICB2YXIgbm90SG9zdCA9IGhvc3RwYXJ0cy5zbGljZShpICsgMSk7XG4gICAgICAgICAgICB2YXIgYml0ID0gcGFydC5tYXRjaChob3N0bmFtZVBhcnRTdGFydCk7XG4gICAgICAgICAgICBpZiAoYml0KSB7XG4gICAgICAgICAgICAgIHZhbGlkUGFydHMucHVzaChiaXRbMV0pO1xuICAgICAgICAgICAgICBub3RIb3N0LnVuc2hpZnQoYml0WzJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub3RIb3N0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXN0ID0gJy8nICsgbm90SG9zdC5qb2luKCcuJykgKyByZXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ob3N0bmFtZSA9IHZhbGlkUGFydHMuam9pbignLicpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaG9zdG5hbWUubGVuZ3RoID4gaG9zdG5hbWVNYXhMZW4pIHtcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaG9zdG5hbWVzIGFyZSBhbHdheXMgbG93ZXIgY2FzZS5cbiAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIC8vIElETkEgU3VwcG9ydDogUmV0dXJucyBhIHB1bnljb2RlZCByZXByZXNlbnRhdGlvbiBvZiBcImRvbWFpblwiLlxuICAgICAgLy8gSXQgb25seSBjb252ZXJ0cyBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgdGhhdFxuICAgICAgLy8gaGF2ZSBub24tQVNDSUkgY2hhcmFjdGVycywgaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZlxuICAgICAgLy8geW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0IGFscmVhZHkgaXMgQVNDSUktb25seS5cbiAgICAgIHRoaXMuaG9zdG5hbWUgPSBwdW55Y29kZS50b0FTQ0lJKHRoaXMuaG9zdG5hbWUpO1xuICAgIH1cblxuICAgIHZhciBwID0gdGhpcy5wb3J0ID8gJzonICsgdGhpcy5wb3J0IDogJyc7XG4gICAgdmFyIGggPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuICAgIHRoaXMuaG9zdCA9IGggKyBwO1xuICAgIHRoaXMuaHJlZiArPSB0aGlzLmhvc3Q7XG5cbiAgICAvLyBzdHJpcCBbIGFuZCBdIGZyb20gdGhlIGhvc3RuYW1lXG4gICAgLy8gdGhlIGhvc3QgZmllbGQgc3RpbGwgcmV0YWlucyB0aGVtLCB0aG91Z2hcbiAgICBpZiAoaXB2Nkhvc3RuYW1lKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS5zdWJzdHIoMSwgdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIGlmIChyZXN0WzBdICE9PSAnLycpIHtcbiAgICAgICAgcmVzdCA9ICcvJyArIHJlc3Q7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gbm93IHJlc3QgaXMgc2V0IHRvIHRoZSBwb3N0LWhvc3Qgc3R1ZmYuXG4gIC8vIGNob3Agb2ZmIGFueSBkZWxpbSBjaGFycy5cbiAgaWYgKCF1bnNhZmVQcm90b2NvbFtsb3dlclByb3RvXSkge1xuXG4gICAgLy8gRmlyc3QsIG1ha2UgMTAwJSBzdXJlIHRoYXQgYW55IFwiYXV0b0VzY2FwZVwiIGNoYXJzIGdldFxuICAgIC8vIGVzY2FwZWQsIGV2ZW4gaWYgZW5jb2RlVVJJQ29tcG9uZW50IGRvZXNuJ3QgdGhpbmsgdGhleVxuICAgIC8vIG5lZWQgdG8gYmUuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhdXRvRXNjYXBlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGFlID0gYXV0b0VzY2FwZVtpXTtcbiAgICAgIGlmIChyZXN0LmluZGV4T2YoYWUpID09PSAtMSlcbiAgICAgICAgY29udGludWU7XG4gICAgICB2YXIgZXNjID0gZW5jb2RlVVJJQ29tcG9uZW50KGFlKTtcbiAgICAgIGlmIChlc2MgPT09IGFlKSB7XG4gICAgICAgIGVzYyA9IGVzY2FwZShhZSk7XG4gICAgICB9XG4gICAgICByZXN0ID0gcmVzdC5zcGxpdChhZSkuam9pbihlc2MpO1xuICAgIH1cbiAgfVxuXG5cbiAgLy8gY2hvcCBvZmYgZnJvbSB0aGUgdGFpbCBmaXJzdC5cbiAgdmFyIGhhc2ggPSByZXN0LmluZGV4T2YoJyMnKTtcbiAgaWYgKGhhc2ggIT09IC0xKSB7XG4gICAgLy8gZ290IGEgZnJhZ21lbnQgc3RyaW5nLlxuICAgIHRoaXMuaGFzaCA9IHJlc3Quc3Vic3RyKGhhc2gpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIGhhc2gpO1xuICB9XG4gIHZhciBxbSA9IHJlc3QuaW5kZXhPZignPycpO1xuICBpZiAocW0gIT09IC0xKSB7XG4gICAgdGhpcy5zZWFyY2ggPSByZXN0LnN1YnN0cihxbSk7XG4gICAgdGhpcy5xdWVyeSA9IHJlc3Quc3Vic3RyKHFtICsgMSk7XG4gICAgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgIHRoaXMucXVlcnkgPSBxdWVyeXN0cmluZy5wYXJzZSh0aGlzLnF1ZXJ5KTtcbiAgICB9XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgcW0pO1xuICB9IGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAvLyBubyBxdWVyeSBzdHJpbmcsIGJ1dCBwYXJzZVF1ZXJ5U3RyaW5nIHN0aWxsIHJlcXVlc3RlZFxuICAgIHRoaXMuc2VhcmNoID0gJyc7XG4gICAgdGhpcy5xdWVyeSA9IHt9O1xuICB9XG4gIGlmIChyZXN0KSB0aGlzLnBhdGhuYW1lID0gcmVzdDtcbiAgaWYgKHNsYXNoZWRQcm90b2NvbFtsb3dlclByb3RvXSAmJlxuICAgICAgdGhpcy5ob3N0bmFtZSAmJiAhdGhpcy5wYXRobmFtZSkge1xuICAgIHRoaXMucGF0aG5hbWUgPSAnLyc7XG4gIH1cblxuICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gIGlmICh0aGlzLnBhdGhuYW1lIHx8IHRoaXMuc2VhcmNoKSB7XG4gICAgdmFyIHAgPSB0aGlzLnBhdGhuYW1lIHx8ICcnO1xuICAgIHZhciBzID0gdGhpcy5zZWFyY2ggfHwgJyc7XG4gICAgdGhpcy5wYXRoID0gcCArIHM7XG4gIH1cblxuICAvLyBmaW5hbGx5LCByZWNvbnN0cnVjdCB0aGUgaHJlZiBiYXNlZCBvbiB3aGF0IGhhcyBiZWVuIHZhbGlkYXRlZC5cbiAgdGhpcy5ocmVmID0gdGhpcy5mb3JtYXQoKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBmb3JtYXQgYSBwYXJzZWQgb2JqZWN0IGludG8gYSB1cmwgc3RyaW5nXG5mdW5jdGlvbiB1cmxGb3JtYXQob2JqKSB7XG4gIC8vIGVuc3VyZSBpdCdzIGFuIG9iamVjdCwgYW5kIG5vdCBhIHN0cmluZyB1cmwuXG4gIC8vIElmIGl0J3MgYW4gb2JqLCB0aGlzIGlzIGEgbm8tb3AuXG4gIC8vIHRoaXMgd2F5LCB5b3UgY2FuIGNhbGwgdXJsX2Zvcm1hdCgpIG9uIHN0cmluZ3NcbiAgLy8gdG8gY2xlYW4gdXAgcG90ZW50aWFsbHkgd29ua3kgdXJscy5cbiAgaWYgKHV0aWwuaXNTdHJpbmcob2JqKSkgb2JqID0gdXJsUGFyc2Uob2JqKTtcbiAgaWYgKCEob2JqIGluc3RhbmNlb2YgVXJsKSkgcmV0dXJuIFVybC5wcm90b3R5cGUuZm9ybWF0LmNhbGwob2JqKTtcbiAgcmV0dXJuIG9iai5mb3JtYXQoKTtcbn1cblxuVXJsLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGF1dGggPSB0aGlzLmF1dGggfHwgJyc7XG4gIGlmIChhdXRoKSB7XG4gICAgYXV0aCA9IGVuY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICBhdXRoID0gYXV0aC5yZXBsYWNlKC8lM0EvaSwgJzonKTtcbiAgICBhdXRoICs9ICdAJztcbiAgfVxuXG4gIHZhciBwcm90b2NvbCA9IHRoaXMucHJvdG9jb2wgfHwgJycsXG4gICAgICBwYXRobmFtZSA9IHRoaXMucGF0aG5hbWUgfHwgJycsXG4gICAgICBoYXNoID0gdGhpcy5oYXNoIHx8ICcnLFxuICAgICAgaG9zdCA9IGZhbHNlLFxuICAgICAgcXVlcnkgPSAnJztcblxuICBpZiAodGhpcy5ob3N0KSB7XG4gICAgaG9zdCA9IGF1dGggKyB0aGlzLmhvc3Q7XG4gIH0gZWxzZSBpZiAodGhpcy5ob3N0bmFtZSkge1xuICAgIGhvc3QgPSBhdXRoICsgKHRoaXMuaG9zdG5hbWUuaW5kZXhPZignOicpID09PSAtMSA/XG4gICAgICAgIHRoaXMuaG9zdG5hbWUgOlxuICAgICAgICAnWycgKyB0aGlzLmhvc3RuYW1lICsgJ10nKTtcbiAgICBpZiAodGhpcy5wb3J0KSB7XG4gICAgICBob3N0ICs9ICc6JyArIHRoaXMucG9ydDtcbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5xdWVyeSAmJlxuICAgICAgdXRpbC5pc09iamVjdCh0aGlzLnF1ZXJ5KSAmJlxuICAgICAgT2JqZWN0LmtleXModGhpcy5xdWVyeSkubGVuZ3RoKSB7XG4gICAgcXVlcnkgPSBxdWVyeXN0cmluZy5zdHJpbmdpZnkodGhpcy5xdWVyeSk7XG4gIH1cblxuICB2YXIgc2VhcmNoID0gdGhpcy5zZWFyY2ggfHwgKHF1ZXJ5ICYmICgnPycgKyBxdWVyeSkpIHx8ICcnO1xuXG4gIGlmIChwcm90b2NvbCAmJiBwcm90b2NvbC5zdWJzdHIoLTEpICE9PSAnOicpIHByb3RvY29sICs9ICc6JztcblxuICAvLyBvbmx5IHRoZSBzbGFzaGVkUHJvdG9jb2xzIGdldCB0aGUgLy8uICBOb3QgbWFpbHRvOiwgeG1wcDosIGV0Yy5cbiAgLy8gdW5sZXNzIHRoZXkgaGFkIHRoZW0gdG8gYmVnaW4gd2l0aC5cbiAgaWYgKHRoaXMuc2xhc2hlcyB8fFxuICAgICAgKCFwcm90b2NvbCB8fCBzbGFzaGVkUHJvdG9jb2xbcHJvdG9jb2xdKSAmJiBob3N0ICE9PSBmYWxzZSkge1xuICAgIGhvc3QgPSAnLy8nICsgKGhvc3QgfHwgJycpO1xuICAgIGlmIChwYXRobmFtZSAmJiBwYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJykgcGF0aG5hbWUgPSAnLycgKyBwYXRobmFtZTtcbiAgfSBlbHNlIGlmICghaG9zdCkge1xuICAgIGhvc3QgPSAnJztcbiAgfVxuXG4gIGlmIChoYXNoICYmIGhhc2guY2hhckF0KDApICE9PSAnIycpIGhhc2ggPSAnIycgKyBoYXNoO1xuICBpZiAoc2VhcmNoICYmIHNlYXJjaC5jaGFyQXQoMCkgIT09ICc/Jykgc2VhcmNoID0gJz8nICsgc2VhcmNoO1xuXG4gIHBhdGhuYW1lID0gcGF0aG5hbWUucmVwbGFjZSgvWz8jXS9nLCBmdW5jdGlvbihtYXRjaCkge1xuICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQobWF0Y2gpO1xuICB9KTtcbiAgc2VhcmNoID0gc2VhcmNoLnJlcGxhY2UoJyMnLCAnJTIzJyk7XG5cbiAgcmV0dXJuIHByb3RvY29sICsgaG9zdCArIHBhdGhuYW1lICsgc2VhcmNoICsgaGFzaDtcbn07XG5cbmZ1bmN0aW9uIHVybFJlc29sdmUoc291cmNlLCByZWxhdGl2ZSkge1xuICByZXR1cm4gdXJsUGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZShyZWxhdGl2ZSk7XG59XG5cblVybC5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uKHJlbGF0aXZlKSB7XG4gIHJldHVybiB0aGlzLnJlc29sdmVPYmplY3QodXJsUGFyc2UocmVsYXRpdmUsIGZhbHNlLCB0cnVlKSkuZm9ybWF0KCk7XG59O1xuXG5mdW5jdGlvbiB1cmxSZXNvbHZlT2JqZWN0KHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgaWYgKCFzb3VyY2UpIHJldHVybiByZWxhdGl2ZTtcbiAgcmV0dXJuIHVybFBhcnNlKHNvdXJjZSwgZmFsc2UsIHRydWUpLnJlc29sdmVPYmplY3QocmVsYXRpdmUpO1xufVxuXG5VcmwucHJvdG90eXBlLnJlc29sdmVPYmplY3QgPSBmdW5jdGlvbihyZWxhdGl2ZSkge1xuICBpZiAodXRpbC5pc1N0cmluZyhyZWxhdGl2ZSkpIHtcbiAgICB2YXIgcmVsID0gbmV3IFVybCgpO1xuICAgIHJlbC5wYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpO1xuICAgIHJlbGF0aXZlID0gcmVsO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IG5ldyBVcmwoKTtcbiAgdmFyIHRrZXlzID0gT2JqZWN0LmtleXModGhpcyk7XG4gIGZvciAodmFyIHRrID0gMDsgdGsgPCB0a2V5cy5sZW5ndGg7IHRrKyspIHtcbiAgICB2YXIgdGtleSA9IHRrZXlzW3RrXTtcbiAgICByZXN1bHRbdGtleV0gPSB0aGlzW3RrZXldO1xuICB9XG5cbiAgLy8gaGFzaCBpcyBhbHdheXMgb3ZlcnJpZGRlbiwgbm8gbWF0dGVyIHdoYXQuXG4gIC8vIGV2ZW4gaHJlZj1cIlwiIHdpbGwgcmVtb3ZlIGl0LlxuICByZXN1bHQuaGFzaCA9IHJlbGF0aXZlLmhhc2g7XG5cbiAgLy8gaWYgdGhlIHJlbGF0aXZlIHVybCBpcyBlbXB0eSwgdGhlbiB0aGVyZSdzIG5vdGhpbmcgbGVmdCB0byBkbyBoZXJlLlxuICBpZiAocmVsYXRpdmUuaHJlZiA9PT0gJycpIHtcbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gaHJlZnMgbGlrZSAvL2Zvby9iYXIgYWx3YXlzIGN1dCB0byB0aGUgcHJvdG9jb2wuXG4gIGlmIChyZWxhdGl2ZS5zbGFzaGVzICYmICFyZWxhdGl2ZS5wcm90b2NvbCkge1xuICAgIC8vIHRha2UgZXZlcnl0aGluZyBleGNlcHQgdGhlIHByb3RvY29sIGZyb20gcmVsYXRpdmVcbiAgICB2YXIgcmtleXMgPSBPYmplY3Qua2V5cyhyZWxhdGl2ZSk7XG4gICAgZm9yICh2YXIgcmsgPSAwOyByayA8IHJrZXlzLmxlbmd0aDsgcmsrKykge1xuICAgICAgdmFyIHJrZXkgPSBya2V5c1tya107XG4gICAgICBpZiAocmtleSAhPT0gJ3Byb3RvY29sJylcbiAgICAgICAgcmVzdWx0W3JrZXldID0gcmVsYXRpdmVbcmtleV07XG4gICAgfVxuXG4gICAgLy91cmxQYXJzZSBhcHBlbmRzIHRyYWlsaW5nIC8gdG8gdXJscyBsaWtlIGh0dHA6Ly93d3cuZXhhbXBsZS5jb21cbiAgICBpZiAoc2xhc2hlZFByb3RvY29sW3Jlc3VsdC5wcm90b2NvbF0gJiZcbiAgICAgICAgcmVzdWx0Lmhvc3RuYW1lICYmICFyZXN1bHQucGF0aG5hbWUpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gcmVzdWx0LnBhdGhuYW1lID0gJy8nO1xuICAgIH1cblxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAocmVsYXRpdmUucHJvdG9jb2wgJiYgcmVsYXRpdmUucHJvdG9jb2wgIT09IHJlc3VsdC5wcm90b2NvbCkge1xuICAgIC8vIGlmIGl0J3MgYSBrbm93biB1cmwgcHJvdG9jb2wsIHRoZW4gY2hhbmdpbmdcbiAgICAvLyB0aGUgcHJvdG9jb2wgZG9lcyB3ZWlyZCB0aGluZ3NcbiAgICAvLyBmaXJzdCwgaWYgaXQncyBub3QgZmlsZTosIHRoZW4gd2UgTVVTVCBoYXZlIGEgaG9zdCxcbiAgICAvLyBhbmQgaWYgdGhlcmUgd2FzIGEgcGF0aFxuICAgIC8vIHRvIGJlZ2luIHdpdGgsIHRoZW4gd2UgTVVTVCBoYXZlIGEgcGF0aC5cbiAgICAvLyBpZiBpdCBpcyBmaWxlOiwgdGhlbiB0aGUgaG9zdCBpcyBkcm9wcGVkLFxuICAgIC8vIGJlY2F1c2UgdGhhdCdzIGtub3duIHRvIGJlIGhvc3RsZXNzLlxuICAgIC8vIGFueXRoaW5nIGVsc2UgaXMgYXNzdW1lZCB0byBiZSBhYnNvbHV0ZS5cbiAgICBpZiAoIXNsYXNoZWRQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMocmVsYXRpdmUpO1xuICAgICAgZm9yICh2YXIgdiA9IDA7IHYgPCBrZXlzLmxlbmd0aDsgdisrKSB7XG4gICAgICAgIHZhciBrID0ga2V5c1t2XTtcbiAgICAgICAgcmVzdWx0W2tdID0gcmVsYXRpdmVba107XG4gICAgICB9XG4gICAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcmVzdWx0LnByb3RvY29sID0gcmVsYXRpdmUucHJvdG9jb2w7XG4gICAgaWYgKCFyZWxhdGl2ZS5ob3N0ICYmICFob3N0bGVzc1Byb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xuICAgICAgdmFyIHJlbFBhdGggPSAocmVsYXRpdmUucGF0aG5hbWUgfHwgJycpLnNwbGl0KCcvJyk7XG4gICAgICB3aGlsZSAocmVsUGF0aC5sZW5ndGggJiYgIShyZWxhdGl2ZS5ob3N0ID0gcmVsUGF0aC5zaGlmdCgpKSk7XG4gICAgICBpZiAoIXJlbGF0aXZlLmhvc3QpIHJlbGF0aXZlLmhvc3QgPSAnJztcbiAgICAgIGlmICghcmVsYXRpdmUuaG9zdG5hbWUpIHJlbGF0aXZlLmhvc3RuYW1lID0gJyc7XG4gICAgICBpZiAocmVsUGF0aFswXSAhPT0gJycpIHJlbFBhdGgudW5zaGlmdCgnJyk7XG4gICAgICBpZiAocmVsUGF0aC5sZW5ndGggPCAyKSByZWxQYXRoLnVuc2hpZnQoJycpO1xuICAgICAgcmVzdWx0LnBhdGhuYW1lID0gcmVsUGF0aC5qb2luKCcvJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbGF0aXZlLnBhdGhuYW1lO1xuICAgIH1cbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIHJlc3VsdC5ob3N0ID0gcmVsYXRpdmUuaG9zdCB8fCAnJztcbiAgICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGg7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdDtcbiAgICByZXN1bHQucG9ydCA9IHJlbGF0aXZlLnBvcnQ7XG4gICAgLy8gdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAocmVzdWx0LnBhdGhuYW1lIHx8IHJlc3VsdC5zZWFyY2gpIHtcbiAgICAgIHZhciBwID0gcmVzdWx0LnBhdGhuYW1lIHx8ICcnO1xuICAgICAgdmFyIHMgPSByZXN1bHQuc2VhcmNoIHx8ICcnO1xuICAgICAgcmVzdWx0LnBhdGggPSBwICsgcztcbiAgICB9XG4gICAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB2YXIgaXNTb3VyY2VBYnMgPSAocmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJyksXG4gICAgICBpc1JlbEFicyA9IChcbiAgICAgICAgICByZWxhdGl2ZS5ob3N0IHx8XG4gICAgICAgICAgcmVsYXRpdmUucGF0aG5hbWUgJiYgcmVsYXRpdmUucGF0aG5hbWUuY2hhckF0KDApID09PSAnLydcbiAgICAgICksXG4gICAgICBtdXN0RW5kQWJzID0gKGlzUmVsQWJzIHx8IGlzU291cmNlQWJzIHx8XG4gICAgICAgICAgICAgICAgICAgIChyZXN1bHQuaG9zdCAmJiByZWxhdGl2ZS5wYXRobmFtZSkpLFxuICAgICAgcmVtb3ZlQWxsRG90cyA9IG11c3RFbmRBYnMsXG4gICAgICBzcmNQYXRoID0gcmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgICAgcmVsUGF0aCA9IHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLnNwbGl0KCcvJykgfHwgW10sXG4gICAgICBwc3ljaG90aWMgPSByZXN1bHQucHJvdG9jb2wgJiYgIXNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdO1xuXG4gIC8vIGlmIHRoZSB1cmwgaXMgYSBub24tc2xhc2hlZCB1cmwsIHRoZW4gcmVsYXRpdmVcbiAgLy8gbGlua3MgbGlrZSAuLi8uLiBzaG91bGQgYmUgYWJsZVxuICAvLyB0byBjcmF3bCB1cCB0byB0aGUgaG9zdG5hbWUsIGFzIHdlbGwuICBUaGlzIGlzIHN0cmFuZ2UuXG4gIC8vIHJlc3VsdC5wcm90b2NvbCBoYXMgYWxyZWFkeSBiZWVuIHNldCBieSBub3cuXG4gIC8vIExhdGVyIG9uLCBwdXQgdGhlIGZpcnN0IHBhdGggcGFydCBpbnRvIHRoZSBob3N0IGZpZWxkLlxuICBpZiAocHN5Y2hvdGljKSB7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gJyc7XG4gICAgcmVzdWx0LnBvcnQgPSBudWxsO1xuICAgIGlmIChyZXN1bHQuaG9zdCkge1xuICAgICAgaWYgKHNyY1BhdGhbMF0gPT09ICcnKSBzcmNQYXRoWzBdID0gcmVzdWx0Lmhvc3Q7XG4gICAgICBlbHNlIHNyY1BhdGgudW5zaGlmdChyZXN1bHQuaG9zdCk7XG4gICAgfVxuICAgIHJlc3VsdC5ob3N0ID0gJyc7XG4gICAgaWYgKHJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgICByZWxhdGl2ZS5ob3N0bmFtZSA9IG51bGw7XG4gICAgICByZWxhdGl2ZS5wb3J0ID0gbnVsbDtcbiAgICAgIGlmIChyZWxhdGl2ZS5ob3N0KSB7XG4gICAgICAgIGlmIChyZWxQYXRoWzBdID09PSAnJykgcmVsUGF0aFswXSA9IHJlbGF0aXZlLmhvc3Q7XG4gICAgICAgIGVsc2UgcmVsUGF0aC51bnNoaWZ0KHJlbGF0aXZlLmhvc3QpO1xuICAgICAgfVxuICAgICAgcmVsYXRpdmUuaG9zdCA9IG51bGw7XG4gICAgfVxuICAgIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzICYmIChyZWxQYXRoWzBdID09PSAnJyB8fCBzcmNQYXRoWzBdID09PSAnJyk7XG4gIH1cblxuICBpZiAoaXNSZWxBYnMpIHtcbiAgICAvLyBpdCdzIGFic29sdXRlLlxuICAgIHJlc3VsdC5ob3N0ID0gKHJlbGF0aXZlLmhvc3QgfHwgcmVsYXRpdmUuaG9zdCA9PT0gJycpID9cbiAgICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3QgOiByZXN1bHQuaG9zdDtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSAocmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdG5hbWUgPT09ICcnKSA/XG4gICAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgOiByZXN1bHQuaG9zdG5hbWU7XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICBzcmNQYXRoID0gcmVsUGF0aDtcbiAgICAvLyBmYWxsIHRocm91Z2ggdG8gdGhlIGRvdC1oYW5kbGluZyBiZWxvdy5cbiAgfSBlbHNlIGlmIChyZWxQYXRoLmxlbmd0aCkge1xuICAgIC8vIGl0J3MgcmVsYXRpdmVcbiAgICAvLyB0aHJvdyBhd2F5IHRoZSBleGlzdGluZyBmaWxlLCBhbmQgdGFrZSB0aGUgbmV3IHBhdGggaW5zdGVhZC5cbiAgICBpZiAoIXNyY1BhdGgpIHNyY1BhdGggPSBbXTtcbiAgICBzcmNQYXRoLnBvcCgpO1xuICAgIHNyY1BhdGggPSBzcmNQYXRoLmNvbmNhdChyZWxQYXRoKTtcbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICB9IGVsc2UgaWYgKCF1dGlsLmlzTnVsbE9yVW5kZWZpbmVkKHJlbGF0aXZlLnNlYXJjaCkpIHtcbiAgICAvLyBqdXN0IHB1bGwgb3V0IHRoZSBzZWFyY2guXG4gICAgLy8gbGlrZSBocmVmPSc/Zm9vJy5cbiAgICAvLyBQdXQgdGhpcyBhZnRlciB0aGUgb3RoZXIgdHdvIGNhc2VzIGJlY2F1c2UgaXQgc2ltcGxpZmllcyB0aGUgYm9vbGVhbnNcbiAgICBpZiAocHN5Y2hvdGljKSB7XG4gICAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IHNyY1BhdGguc2hpZnQoKTtcbiAgICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAgIC8vdGhpcyBlc3BlY2lhbGx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgICAgLy91cmwucmVzb2x2ZU9iamVjdCgnbWFpbHRvOmxvY2FsMUBkb21haW4xJywgJ2xvY2FsMkBkb21haW4yJylcbiAgICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpID4gMCA/XG4gICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICAgIGlmIChhdXRoSW5Ib3N0KSB7XG4gICAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKCF1dGlsLmlzTnVsbChyZXN1bHQucGF0aG5hbWUpIHx8ICF1dGlsLmlzTnVsbChyZXN1bHQuc2VhcmNoKSkge1xuICAgICAgcmVzdWx0LnBhdGggPSAocmVzdWx0LnBhdGhuYW1lID8gcmVzdWx0LnBhdGhuYW1lIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VsdC5zZWFyY2ggPyByZXN1bHQuc2VhcmNoIDogJycpO1xuICAgIH1cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKCFzcmNQYXRoLmxlbmd0aCkge1xuICAgIC8vIG5vIHBhdGggYXQgYWxsLiAgZWFzeS5cbiAgICAvLyB3ZSd2ZSBhbHJlYWR5IGhhbmRsZWQgdGhlIG90aGVyIHN0dWZmIGFib3ZlLlxuICAgIHJlc3VsdC5wYXRobmFtZSA9IG51bGw7XG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmIChyZXN1bHQuc2VhcmNoKSB7XG4gICAgICByZXN1bHQucGF0aCA9ICcvJyArIHJlc3VsdC5zZWFyY2g7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gbnVsbDtcbiAgICB9XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIGlmIGEgdXJsIEVORHMgaW4gLiBvciAuLiwgdGhlbiBpdCBtdXN0IGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICAvLyBob3dldmVyLCBpZiBpdCBlbmRzIGluIGFueXRoaW5nIGVsc2Ugbm9uLXNsYXNoeSxcbiAgLy8gdGhlbiBpdCBtdXN0IE5PVCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbiAgdmFyIGxhc3QgPSBzcmNQYXRoLnNsaWNlKC0xKVswXTtcbiAgdmFyIGhhc1RyYWlsaW5nU2xhc2ggPSAoXG4gICAgICAocmVzdWx0Lmhvc3QgfHwgcmVsYXRpdmUuaG9zdCB8fCBzcmNQYXRoLmxlbmd0aCA+IDEpICYmXG4gICAgICAobGFzdCA9PT0gJy4nIHx8IGxhc3QgPT09ICcuLicpIHx8IGxhc3QgPT09ICcnKTtcblxuICAvLyBzdHJpcCBzaW5nbGUgZG90cywgcmVzb2x2ZSBkb3VibGUgZG90cyB0byBwYXJlbnQgZGlyXG4gIC8vIGlmIHRoZSBwYXRoIHRyaWVzIHRvIGdvIGFib3ZlIHRoZSByb290LCBgdXBgIGVuZHMgdXAgPiAwXG4gIHZhciB1cCA9IDA7XG4gIGZvciAodmFyIGkgPSBzcmNQYXRoLmxlbmd0aDsgaSA+PSAwOyBpLS0pIHtcbiAgICBsYXN0ID0gc3JjUGF0aFtpXTtcbiAgICBpZiAobGFzdCA9PT0gJy4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICBpZiAoIW11c3RFbmRBYnMgJiYgIXJlbW92ZUFsbERvdHMpIHtcbiAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgIHNyY1BhdGgudW5zaGlmdCgnLi4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAobXVzdEVuZEFicyAmJiBzcmNQYXRoWzBdICE9PSAnJyAmJlxuICAgICAgKCFzcmNQYXRoWzBdIHx8IHNyY1BhdGhbMF0uY2hhckF0KDApICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIGlmIChoYXNUcmFpbGluZ1NsYXNoICYmIChzcmNQYXRoLmpvaW4oJy8nKS5zdWJzdHIoLTEpICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC5wdXNoKCcnKTtcbiAgfVxuXG4gIHZhciBpc0Fic29sdXRlID0gc3JjUGF0aFswXSA9PT0gJycgfHxcbiAgICAgIChzcmNQYXRoWzBdICYmIHNyY1BhdGhbMF0uY2hhckF0KDApID09PSAnLycpO1xuXG4gIC8vIHB1dCB0aGUgaG9zdCBiYWNrXG4gIGlmIChwc3ljaG90aWMpIHtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IGlzQWJzb2x1dGUgPyAnJyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmNQYXRoLmxlbmd0aCA/IHNyY1BhdGguc2hpZnQoKSA6ICcnO1xuICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAvL3RoaXMgZXNwZWNpYWxseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAvL3VybC5yZXNvbHZlT2JqZWN0KCdtYWlsdG86bG9jYWwxQGRvbWFpbjEnLCAnbG9jYWwyQGRvbWFpbjInKVxuICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpID4gMCA/XG4gICAgICAgICAgICAgICAgICAgICByZXN1bHQuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XG4gICAgaWYgKGF1dGhJbkhvc3QpIHtcbiAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgfVxuICB9XG5cbiAgbXVzdEVuZEFicyA9IG11c3RFbmRBYnMgfHwgKHJlc3VsdC5ob3N0ICYmIHNyY1BhdGgubGVuZ3RoKTtcblxuICBpZiAobXVzdEVuZEFicyAmJiAhaXNBYnNvbHV0ZSkge1xuICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7XG4gIH1cblxuICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XG4gICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcbiAgICByZXN1bHQucGF0aCA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0LnBhdGhuYW1lID0gc3JjUGF0aC5qb2luKCcvJyk7XG4gIH1cblxuICAvL3RvIHN1cHBvcnQgcmVxdWVzdC5odHRwXG4gIGlmICghdXRpbC5pc051bGwocmVzdWx0LnBhdGhuYW1lKSB8fCAhdXRpbC5pc051bGwocmVzdWx0LnNlYXJjaCkpIHtcbiAgICByZXN1bHQucGF0aCA9IChyZXN1bHQucGF0aG5hbWUgPyByZXN1bHQucGF0aG5hbWUgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHJlc3VsdC5zZWFyY2ggPyByZXN1bHQuc2VhcmNoIDogJycpO1xuICB9XG4gIHJlc3VsdC5hdXRoID0gcmVsYXRpdmUuYXV0aCB8fCByZXN1bHQuYXV0aDtcbiAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblVybC5wcm90b3R5cGUucGFyc2VIb3N0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBob3N0ID0gdGhpcy5ob3N0O1xuICB2YXIgcG9ydCA9IHBvcnRQYXR0ZXJuLmV4ZWMoaG9zdCk7XG4gIGlmIChwb3J0KSB7XG4gICAgcG9ydCA9IHBvcnRbMF07XG4gICAgaWYgKHBvcnQgIT09ICc6Jykge1xuICAgICAgdGhpcy5wb3J0ID0gcG9ydC5zdWJzdHIoMSk7XG4gICAgfVxuICAgIGhvc3QgPSBob3N0LnN1YnN0cigwLCBob3N0Lmxlbmd0aCAtIHBvcnQubGVuZ3RoKTtcbiAgfVxuICBpZiAoaG9zdCkgdGhpcy5ob3N0bmFtZSA9IGhvc3Q7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNTdHJpbmc6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB0eXBlb2YoYXJnKSA9PT0gJ3N0cmluZyc7XG4gIH0sXG4gIGlzT2JqZWN0OiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gdHlwZW9mKGFyZykgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbiAgfSxcbiAgaXNOdWxsOiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gYXJnID09PSBudWxsO1xuICB9LFxuICBpc051bGxPclVuZGVmaW5lZDogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGFyZyA9PSBudWxsO1xuICB9XG59O1xuIiwicmVxdWlyZShcIi4uL2xpYi9tb2YuanNcIik7XHJcblxyXG5jb25zdCBCYXNlNjQgPSByZXF1aXJlKFwianMtYmFzZTY0XCIpLkJhc2U2NDtcclxuXHJcbmNvbnN0IFBJWEkgPSByZXF1aXJlKFwicGl4aS5qc1wiKTtcclxuXHJcbmNvbnN0IENySW50ZXJmaWNlID0gcmVxdWlyZShcIkFzeW5Db21tdW5cIikuQ3JDb21tdW5pY2F0b3I7XHJcbmNvbnN0IENySW50ZXJXcyA9IHJlcXVpcmUoXCIuLi9saWIvd3NfY2xpZW50LmpzXCIpO1xyXG5cclxuY29uc3QgQ3JTZXNzaW9uID0gcmVxdWlyZShcIi4uL3NyYy9zZXNzaW9uLmpzXCIpO1xyXG5jb25zdCBDcktleWJvYXJkID0gcmVxdWlyZShcIi4va2V5Ym9hcmQuanNcIik7XHJcbmNvbnN0IENyRGlzcGxheSA9IHJlcXVpcmUoXCIuL2Rpc3BsYXkuanNcIik7XHJcblxyXG5jb25zdCBNYXBfZGF0YSA9IHJlcXVpcmUoXCIuLi9zcmMvbWFwLmpzb25cIik7XHJcblxyXG52YXIgb25seUNsaWVudCA9IGZhbHNlO1xyXG5cclxudmFyIHVybCA9ICd3czovLzE5Mi4xNjguMS43Nzo4MDgxJztcclxuXHJcblxyXG5DckdhbWUob25seUNsaWVudCwgdXJsLCBNYXBfZGF0YSk7XHJcblxyXG5cclxuZnVuY3Rpb24gQ3JHYW1lKG9ubHlDbGllbnQsIGdhbWVfdXJsLCBNYXBfZGF0YSl7XHJcblxyXG5cdC8qaWYob25seUNsaWVudClcclxuXHRcdFxyXG5cdFx0dmFyIFNlc3Npb24gPSBuZXcgQ3JTZXNzaW9uKE1hcF9kYXRhKTtcclxuXHRcdFxyXG5cdFx0dmFyIEludGVyRGlzcCA9IG5ldyBDckludGVyZmljZSgpO1xyXG5cdFx0XHJcblx0XHRDcktleWJvYXJkKEludGVyRGlzcC5jb25uZWN0KENyRGlzcGxheSgpKSwgWzY1LCA2OCwgODMsIDg3LCAzMl0pO1xyXG5cdFx0SW50ZXJEaXNwLmxvZ2luID0gXCJHYW1lcjFcIjtcclxuXHRcdFxyXG5cdFx0U2Vzc2lvbi5Db25uZWN0KEludGVyRGlzcCk7XHJcblx0XHRcclxuXHJcblx0XHRJbnRlckRpc3AgPSBuZXcgQ3JJbnRlcmZpY2UoKTtcclxuXHRcdFxyXG5cdFx0Q3JLZXlib2FyZChJbnRlckRpc3AuY29ubmVjdChmdW5jdGlvbigpe30pLCBbMzcsIDM4LCAzOSwgNDAsIDQ1XSk7XHJcblx0XHRJbnRlckRpc3AubG9naW4gPSBcIkdhbWVyMlwiO1xyXG5cdFx0XHJcblx0XHRTZXNzaW9uLkNvbm5lY3QoSW50ZXJEaXNwKTtcclxuXHRcdFxyXG5cdCovXHJcblx0dmFyIEludGVyV3MgPSBDckludGVyV3MoZ2FtZV91cmwpO1xyXG5cdHZhciBEaXNwbGF5ID0gIENyRGlzcGxheSgpO1xyXG5cdHZhciBPdXRwdXQgPSBJbnRlcldzLmNvbm5lY3QoRGlzcGxheS5pbnB1dCk7XHJcblx0RGlzcGxheS5vdXRwdXQgPSBPdXRwdXQ7XHJcblx0Q3JLZXlib2FyZChPdXRwdXQsIFs2NSwgNjgsIDgzLCA4NywgMzcsIDM4LCAzOSwgNDAsIDMyLCA0NV0pO1xyXG5cclxuXHRcclxufVxyXG5cclxuZnVuY3Rpb24gQ3Jsb2coaGVhZCl7XHJcblx0cmV0dXJuIGZ1bmN0aW9uKHN0ciwgdmFsKXtcclxuXHRcdGlmKHZhbC5hY3Rpb24gIT0gXCJTdGF0XCIpIGNvbnNvbGUubG9nKGhlYWQsIHN0ciwgdmFsKTtcclxuXHR9XHJcbn1cclxuIiwiY29uc3QgQ3JHdWkgPSByZXF1aXJlKFwiLi9ndWkuanNcIik7XHJcblxyXG5mdW5jdGlvbiBDckRpc3BsYXkoKXtcclxuXHR2YXIgSW5wdXQgPSBDckhvYXJkZXIoKTtcclxuXHRcclxuXHR2YXIgU3RhdCA9IHtkYXRhOiB7fX07XHJcblx0dmFyIFdvcmxkID0gbnVsbDtcclxuXHR2YXIgTGlzdCA9IHt9O1xyXG5cdFxyXG5cdGxldCBhcHAgPSBuZXcgUElYSS5BcHBsaWNhdGlvbih3aW5kb3cuaW5uZXJIZWlnaHQsIHdpbmRvdy5pbm5lckhlaWdodCwge2JhY2tncm91bmRDb2xvciA6IDB4MDAwMDAwfSk7XHJcblx0Y29uc3QgZ3VpID0gQ3JHdWkoYXBwLnZpZXcpO1xyXG5cclxuLy89PT09PT09PT09PT09PT1QcmVMb2FkVGlsZXM9PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcblx0dmFyIFRpbGVzID0gW107XHJcblxyXG5cdGZ1bmN0aW9uIGRyYXdTdmcoc3ZnX3N0cil7XHJcblx0XHR2YXIgaW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XHJcblx0XHRpbWcuc3JjID0gXCJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFwiKyBCYXNlNjQuZW5jb2RlKHN2Z19zdHIpO1xyXG5cdFx0cmV0dXJuIFBJWEkuU3ByaXRlLmZyb20oaW1nKTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIEFkZFRpbGUodGlsZSl7XHJcblx0XHR0aWxlLmltYWdlcyA9IHRpbGUuaW1hZ2VzLm1hcChkcmF3U3ZnKTtcclxuXHRcdFRpbGVzW3RpbGUuaWRdID0gdGlsZTtcclxuXHR9XHJcblx0XHJcblx0ZnVuY3Rpb24gTG9hZFRpbGVzKG1lc3Mpe1xyXG5cdFx0bWVzcy50aWxlcy5mb3JFYWNoKEFkZFRpbGUpO1xyXG5cdFx0UmVhZHlUaWxlcygpO1xyXG5cdH1cclxuXHRcclxuXHJcbi8vPT09PT09PT09PT09PT09PT09SU5QVVQ9PT09PT09PT09PT09PT1cdFxyXG5cdFxyXG5cdHRoaXMuaW5wdXQgPSAgZnVuY3Rpb24odmFsKXtcclxuXHRcdElucHV0TWVzcyh2YWwpO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdGZ1bmN0aW9uIElucHV0TWVzcyhtZXNzKXtcclxuXHRcdHN3aXRjaChtZXNzLnR5cGUpe1xyXG5cdFx0XHRjYXNlIFwiQWN0b3JcIjogSW5wdXRBY3RvcnMobWVzcyk7IGJyZWFrO1xyXG5cdFx0XHRjYXNlIFwiR1VJXCI6IGd1aS51cGRhdGUobWVzcyk7IGJyZWFrO1xyXG5cdFx0XHRjYXNlIFwiVGlsZXNcIjogIElucHV0VGlsZXMobWVzcyk7IGJyZWFrO1xyXG5cdFx0XHRjYXNlIFwiTWFwXCI6ICBJbnB1dE1hcChtZXNzKTsgYnJlYWs7XHJcblx0XHRcdGRlZmF1bHQ6IGNvbnNvbGUuZXJyb3IoXCJNZXNzIG9mIFVua25vd2VkIHR5cGVcIiwgbWVzcyk7IFxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gSW5wdXRUaWxlcyhtZXNzKXtcclxuXHRcdHN3aXRjaChtZXNzLmFjdGlvbil7XHJcblx0XHRcdGNhc2UgXCJDcmVhdGVcIjogIExvYWRUaWxlcyhtZXNzKTsgYnJlYWs7XHJcblx0XHRcdGNhc2UgXCJBZGRcIjogQWRkVGlsZShtZXNzLnRpbGUpOyBicmVhaztcclxuXHRcdFx0ZGVmYXVsdDogY29uc29sZS5lcnJvcihcIk1lc3Mgb2YgVW5rbm93ZWQgYWN0aW9uXCIsIG1lc3MpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gSW5wdXRNYXAobWVzcyl7XHJcblx0XHRzd2l0Y2gobWVzcy5hY3Rpb24pe1xyXG5cdFx0XHRjYXNlIFwiQ3JlYXRlXCI6ICBDck1hcChtZXNzKTsgYnJlYWs7XHJcblx0XHRcdGRlZmF1bHQ6IGNvbnNvbGUuZXJyb3IoXCJNZXNzIG9mIFVua25vd2VkIGFjdGlvblwiLCBtZXNzKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIElucHV0QWN0b3JzKG1lc3Mpe1xyXG5cdFx0c3dpdGNoKG1lc3MuYWN0aW9uKXtcclxuXHRcdFx0Y2FzZSBcIkNyZWF0ZVwiOiBDck9iaihtZXNzKTsgYnJlYWs7XHJcblx0XHRcdGNhc2UgXCJVcGRhdGVcIjogVXBPYmoobWVzcyk7IGJyZWFrO1xyXG5cdFx0XHRjYXNlIFwiRGVsbFwiOiBEZWxsT2JqKG1lc3MpOyBicmVhaztcclxuXHRcdFx0ZGVmYXVsdDogY29uc29sZS5lcnJvcihcIk1lc3Mgb2YgVW5rbm93ZWQgYWN0aW9uXCIsIG1lc3MpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gUmVhZHlUaWxlcygpe1xyXG5cdFx0dGhpcy5vdXRwdXQoe1xyXG5cdFx0XHRhY3Rpb246IFwiUmVhZHlMb2FkXCIsXHJcblx0XHRcdHR5cGU6IFwiVGlsZXNcIlxyXG5cdFx0fSk7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBSZWFkeU1hcCgpe1xyXG5cdFx0dGhpcy5vdXRwdXQoe1xyXG5cdFx0XHRhY3Rpb246IFwiUmVhZHlMb2FkXCIsXHJcblx0XHRcdHR5cGU6IFwiTWFwXCJcclxuXHRcdH0pO1xyXG5cdH1cclxuXHJcbi8vPT09PT09PT09PT09PT09T2JqZWN0cz09PT09PT09PT09PT09PT09PVxyXG5cdFxyXG5cdGZ1bmN0aW9uIENyT2JqKG1lc3Mpe1xyXG5cdFx0c3dpdGNoKG1lc3MudHlwZSl7XHJcblx0XHRcdGNhc2UgXCJUaWxlc1wiOiBMb2FkVGlsZXMobWVzcyk7IGJyZWFrO1xyXG5cdFx0XHRjYXNlIFwiTWFwXCI6IENyTWFwKG1lc3MpOyBicmVhaztcclxuXHRcdFx0ZGVmYXVsdCA6IENyRWxlbShtZXNzKTsgYnJlYWs7XHJcblx0XHR9XHJcblx0fVxyXG5cdFxyXG5cdGZ1bmN0aW9uIFVwT2JqKG1lc3Mpe1xyXG5cdFx0c3dpdGNoKG1lc3MudHlwZSl7XHJcblx0XHRcdGNhc2UgXCJNYXBcIjogOyBicmVhaztcclxuXHRcdFx0ZGVmYXVsdCA6IFVwZGF0ZUVsZW0obWVzcyk7IGJyZWFrO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRcclxuXHRmdW5jdGlvbiBEZWxsT2JqKG1lc3Mpe1xyXG5cdFx0c3dpdGNoKG1lc3MudHlwZSl7XHJcblx0XHRcdGNhc2UgXCJNYXBcIjogV29ybGQuZGVsbCgpOyBicmVhaztcclxuXHRcdFx0ZGVmYXVsdCA6IERlbGxFbGVtKG1lc3MpOyBicmVhaztcclxuXHRcdH1cclxuXHR9XHJcblx0XHJcblx0ZnVuY3Rpb24gQ3JFbGVtKG1lc3Mpe1xyXG5cdFx0c2l6ZV9jb2YgPSBXb3JsZC5zaXplX2NvZjtcclxuXHRcdFxyXG5cdFx0dmFyIGVsZW0gPSBuZXcgUElYSS5TcHJpdGUoVGlsZXNbbWVzcy5zcHJpdGVdLmltYWdlc1swXS50ZXh0dXJlKTtcclxuXHRcdGVsZW0uYW5jaG9yLnNldCgwLjUpO1xyXG5cdFx0XHJcblx0XHRlbGVtLnggPSBtZXNzLnBvcy54ICogc2l6ZV9jb2Y7XHJcblx0XHRlbGVtLnkgPSBtZXNzLnBvcy55ICogc2l6ZV9jb2Y7XHJcblx0XHRcclxuXHRcdGVsZW0ud2lkdGggPSBzaXplX2NvZiAqIG1lc3MuYm94LncgKiAyO1xyXG5cdFx0ZWxlbS5oZWlnaHQgPSBzaXplX2NvZiAqIG1lc3MuYm94LmggKiAyO1xyXG5cdFx0XHJcblx0XHRpZihtZXNzLmRpciAhPT0gdW5kZWZpbmVkKSBlbGVtLnJvdGF0aW9uID0gbWVzcy5kaXIgKiBNYXRoLlBJO1xyXG5cdFx0XHJcblx0XHRXb3JsZC5hZGQoZWxlbSk7XHJcblx0XHRcclxuXHRcdGlmKCFMaXN0W21lc3MuYWN0b3JfdHlwZV0pIExpc3RbbWVzcy5hY3Rvcl90eXBlXSA9IFtdO1xyXG5cdFx0TGlzdFttZXNzLmFjdG9yX3R5cGVdW21lc3MuaWRdID0gZWxlbTtcclxuXHR9XHJcblx0XHJcblx0ZnVuY3Rpb24gRGVsbEVsZW0obWVzcyl7XHJcblx0XHRMaXN0W21lc3MuYWN0b3JfdHlwZV1bbWVzcy5pZF0uZGVzdHJveSgpO1xyXG5cdFx0TGlzdFttZXNzLmFjdG9yX3R5cGVdW21lc3MuaWRdID0gdW5kZWZpbmVkO1xyXG5cdH1cclxuXHRcclxuXHRmdW5jdGlvbiBVcGRhdGVFbGVtKG1lc3Mpe1xyXG5cdFx0dmFyIGVsZW0gPSBMaXN0W21lc3MuYWN0b3JfdHlwZV1bbWVzcy5pZF07XHJcblx0XHRcclxuXHRcdGlmKG1lc3MucG9zKXtcclxuXHRcdFx0ZWxlbS54ID0gbWVzcy5wb3MueCAqIFdvcmxkLnNpemVfY29mO1xyXG5cdFx0XHRlbGVtLnkgPSBtZXNzLnBvcy55ICogV29ybGQuc2l6ZV9jb2Y7XHJcblx0XHR9XHJcblx0XHRpZihtZXNzLmRpciAhPT0gdW5kZWZpbmVkKSBlbGVtLnJvdGF0aW9uID0gbWVzcy5kaXIgKiBNYXRoLlBJO1xyXG5cdH1cclxuXHJcbi8vPT09PT09PT09PT09TUFQPT09PT09PT09PT09PT09XHJcblxyXG5cdGZ1bmN0aW9uIENyTWFwKG1lc3Mpe1xyXG5cdFx0dmFyIHdvcmxkID0gbmV3IFBJWEkuQ29udGFpbmVyKCk7XHJcblx0XHR3b3JsZC54ID0gKHdpbmRvdy5pbm5lcldpZHRoIC0gd2luZG93LmlubmVySGVpZ2h0KSAvIDIgO1xyXG5cdFx0YXBwLnN0YWdlLmFkZENoaWxkKHdvcmxkKTtcclxuXHRcdFxyXG5cdFx0V29ybGQgPSB7fTtcclxuXHRcdFdvcmxkLnNpemVfY29mID0gd2luZG93LmlubmVySGVpZ2h0IC8gbWVzcy5zaXplOyAvL9Ca0L7RhNGELiDQtNC70Y8g0L/QtdGA0LXQstC+0LTQsCDQutC+0L7RgNC0LiDQuNC3INGB0LXRgNCy0LXRgNC90YvRhSDQsiDQtNC40YHQv9C70LXQudC90YvQtS5cclxuXHRcdFdvcmxkLmFkZCA9IGZ1bmN0aW9uKG9iail7XHJcblx0XHRcdHdvcmxkLmFkZENoaWxkKG9iaik7XHJcblx0XHR9XHJcblx0XHRXb3JsZC5kZWxsID0gZnVuY3Rpb24oKXtcclxuXHRcdFx0d29ybGQuZGVzdHJveSgpO1xyXG5cdFx0XHRXb3JsZCA9IG51bGw7XHJcblx0XHR9XHJcblx0XHRcclxuXHRcdFJlYWR5TWFwKCk7XHJcblx0fVxyXG5cdFxyXG5cdFxyXG5cdFxyXG59XHJcblxyXG5mdW5jdGlvbiBDckhvYXJkZXIoKXtcclxuXHR2YXIgaG9hcmRlciA9IFtdO1xyXG5cdFxyXG5cdHZhciBwdXNoID0gZnVuY3Rpb24odmFsKXtcclxuXHRcdGhvYXJkZXIucHVzaCh2YWwpO1xyXG5cdH07XHJcblx0XHJcblx0cHVzaC50YWtlID0gZnVuY3Rpb24oZnVuYyl7XHJcblx0XHRpZih0eXBlb2YgZnVuYyAhPSBcImZ1bmN0aW9uXCIpIHJldHVybiBob2FyZGVyO1xyXG5cdFx0XHJcblx0XHRob2FyZGVyLmZvckVhY2goZnVuY3Rpb24odmFsKXtcclxuXHRcdFx0XHRmdW5jKHZhbCk7XHJcblx0XHR9KTtcclxuXHR9XHJcblx0XHJcblx0cmV0dXJuIHB1c2g7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ3JEaXNwbGF5O1xyXG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIENyR3VpKHZpZXcpe1xyXG5cclxuXHRkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHZpZXcpO1xyXG5cclxuXHRyZXR1cm4ge1xyXG5cdFx0dXBkYXRlLFxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gdXBkYXRlKG1zZyl7XHJcblx0XHRcclxuXHRcdGlmKG1zZy5zZXRCYWNrZ3JvdW5kKVxyXG5cdFx0XHRkb2N1bWVudC5ib2R5LnN0eWxlLmJhY2tncm91bmQgPSBcInVybChcIisgbXNnLnNldEJhY2tncm91bmQuam9pbihcIi9cIikgK1wiKVwiO1xyXG5cdH1cclxufTsiLCJmdW5jdGlvbiBDcktleWJvYXJkKHNlbmRGdW5jLCBrZXlzX2NvZGVzKXtcclxuXHRcclxuXHR2YXIga2V5c19pc19kb3duID0gbmV3IEFycmF5KDEyOCk7XHJcblx0dmFyIGtleV90aW1lcl9pZHMgPSBuZXcgQXJyYXkoMTI4KTtcclxuXHRcclxuXHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBldmVudEtleURvdXduKTtcclxuXHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5dXBcIiAsIGV2ZW50S2V5VXApO1xyXG5cdFxyXG5cdHZhciB0aW1lciA9IHNldEludGVydmFsKFVwZGF0ZUtleXMsIDYwKVxyXG5cdFxyXG5cdGZ1bmN0aW9uIFVwZGF0ZUtleXMoKXtcclxuXHRcdGtleXNfaXNfZG93bi5mb3JFYWNoKGZ1bmN0aW9uKGlzLCBpKXtcclxuXHRcdFx0aWYoaXMpe1xyXG5cdFx0XHRcdHNlbmRLZXkoaSk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdH1cclxuXHRcclxuXHRmdW5jdGlvbiBldmVudEtleURvdXduKGV2ZW50KXtcclxuXHRcdGlmKGtleXNfY29kZXMuaW5kZXhPZihldmVudC5rZXlDb2RlKSAhPSAtMSl7XHJcblx0XHRcdHZhciBrZXlfY29kZSA9IGV2ZW50LmtleUNvZGU7XHJcblx0XHRcdGtleXNfaXNfZG93bltrZXlfY29kZV0gPSB0cnVlO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gZXZlbnRLZXlVcChldmVudCl7XHJcblx0XHRpZihrZXlzX2NvZGVzLmluZGV4T2YoZXZlbnQua2V5Q29kZSkgPT0gLTEpIHJldHVybjtcclxuXHRcdFxyXG5cdFx0a2V5c19pc19kb3duW2V2ZW50LmtleUNvZGVdID0gZmFsc2U7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBzZW5kS2V5KGtleV9jb2RlKXtcclxuXHRcdHZhciBtZXNzID0ge2FjdGlvbjogXCJNb3ZlXCJ9O1xyXG5cdFx0c3dpdGNoKGtleV9jb2RlKXtcclxuXHRcdFx0Y2FzZSAzOTpcclxuXHRcdFx0Y2FzZSA2ODogbWVzcy5kaXIgPSAwOyBicmVhaztcclxuXHRcdFx0Y2FzZSA0MDpcclxuXHRcdFx0Y2FzZSA4MzogbWVzcy5kaXIgPSAwLjU7IGJyZWFrO1xyXG5cdFx0XHRjYXNlIDM3OiBcclxuXHRcdFx0Y2FzZSA2NTogbWVzcy5kaXIgPSAxOyBicmVhaztcclxuXHRcdFx0Y2FzZSAzODpcclxuXHRcdFx0Y2FzZSA4NzogbWVzcy5kaXIgPSAtMC41OyBicmVhaztcclxuXHRcdFx0Y2FzZSAzMjpcclxuXHRcdFx0Y2FzZSA0NTogbWVzcy5hY3Rpb24gPSBcIkZpcmVcIjsgYnJlYWs7XHJcblx0XHR9XHJcblx0XHRzZW5kRnVuYyhtZXNzKTtcclxuXHR9XHJcblx0XHJcblx0ZnVuY3Rpb24gc2VuZFBpbmcoKXtcclxuXHRcdHNlbmRGdW5jKHthY3Rpb246IFwiUGluZ1wifSk7XHJcblx0fVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDcktleWJvYXJkO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcbi8vVmVyc2lvbiAgMS4xXG4vL0NyYWZ0IG9iamVjdC5wcm90eXBlXG4oZnVuY3Rpb24oKXtcblx0aWYoIHR5cGVvZihPYmplY3QuY3JQcm9wKSA9PSBcImZ1bmN0aW9uXCIpe1xuXHRcdHJldHVybjtcblx0fVxuXHRcblx0XG5cdGZ1bmN0aW9uIGNvbnN0UHJvcChuYW1lX3Byb3AsIHZhbHVlLCB2aXMsIHJld3JpdGUpe1xuXHRcdFxuXHRcdGlmKHZhbHVlID09PSB1bmRlZmluZWQpIHZhbHVlID0gdHJ1ZTtcblx0XHRpZih2aXMgPT09IHVuZGVmaW5lZCkgdmlzID0gdHJ1ZTtcblxuXHRcdGlmKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIikgT2JqZWN0LmZyZWV6ZSh2YWx1ZSk7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIG5hbWVfcHJvcCwge1xuXHRcdFx0XHR2YWx1ZTogdmFsdWUsXG5cdFx0XHRcdGVudW1lcmFibGU6IHZpcyxcblx0XHRcdFx0Y29uZmlndXJhYmxlOiByZXdyaXRlLFxuXHRcdFx0XHR3cml0YWJsZTogcmV3cml0ZSxcblx0XHRcdH0pO1xuXHR9XG5cdGZ1bmN0aW9uIGdldFNldChuYW1lLCBnZXR0ZXIsIHNldHRlcil7XG5cdFx0aWYodHlwZW9mIHNldHRlciA9PSBcImZ1bmN0aW9uXCIpe1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIG5hbWUsIHtcblx0XHRcdFx0Z2V0OiBnZXR0ZXIsXG5cdFx0XHRcdHNldDogc2V0dGVyLFxuXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRjb25maWd1cmFibGU6IHRydWVcblx0XHRcdH0pO1xuXHRcdH1lbHNle1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIG5hbWUsIHtcblx0XHRcdFx0Z2V0OiBnZXR0ZXIsXG5cdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG5cdFxuXHRjb25zdFByb3AuY2FsbChPYmplY3QucHJvdG90eXBlLCAnY3JQcm9wJywgY29uc3RQcm9wLCBmYWxzZSk7XG5cdE9iamVjdC5wcm90b3R5cGUuY3JQcm9wKCdhZGRHZXRTZXQnLCBnZXRTZXQsIGZhbHNlKTtcblx0XG5cdFxuXHRmdW5jdGlvbiByYW5kSW5kZXgoKXtcblx0XHR2YXIgcmFuZCA9IE1hdGgucm91bmQoKHRoaXMubGVuZ3RoIC0gMSkgKiBNYXRoLnJhbmRvbSgpKTtcblx0XHRyZXR1cm4gdGhpc1tyYW5kXTtcblx0fVxuXHRcblx0ZnVuY3Rpb24gQWRkSXRlbSh2YWwpe1xuXHRcdGlmKCF0aGlzLl9udWxscykgdGhpcy5fbnVsbHMgPSBbXTtcblx0XHRcblx0XHRpZih0aGlzLl9udWxscy5sZW5ndGgpe1xuXHRcdFx0dmFyIGluZCA9IHRoaXMuX251bGxzLnBvcCgpO1xuXHRcdFx0dGhpc1tpbmRdID0gdmFsO1xuXHRcdFx0cmV0dXJuIGluZDtcblx0XHR9ZWxzZXtcblx0XHRcdHJldHVybiB0aGlzLnB1c2godmFsKSAtIDE7XG5cdFx0fVxuXHR9XG5cdFxuXHRmdW5jdGlvbiBEZWxsSXRlbShpbmQpe1xuXHRcdGlmKGluZCA+IHRoaXMubGVuZ3RoIC0xKSByZXR1cm4gZmFsc2U7XG5cdFx0XG5cdFx0aWYoaW5kID09IHRoaXMubGVuZ3RoIC0xKXtcblx0XHRcdHRoaXMucG9wKCk7XG5cdFx0fWVsc2V7XG5cdFx0XHRpZighdGhpcy5fbnVsbHMpIHRoaXMuX251bGxzID0gW107XG5cdFx0XHRcblx0XHRcdHRoaXNbaW5kXSA9IHVuZGVmaW5lZDtcblx0XHRcdHRoaXMuX251bGxzLnB1c2goaW5kKTtcblx0XHR9XG5cdFx0XG5cdFx0cmV0dXJuIHRydWU7XHRcblx0fVxuXHRcblx0ZnVuY3Rpb24gY3JlYXRlQXJyKHZhbCwgbGVuZ3RoLCBpc19jYWxsKXtcblx0XHR2YXIgYXJyID0gW107XG5cdFx0XG5cdFx0aWYoIWxlbmd0aCkgbGVuZ3RoID0gMTtcblx0XHRpZihpc19jYWxsID09PSB1bmRlZmluZWQpIGlzX2NhbGwgPSB0cnVlO1xuXHRcdFxuXHRcdGlmKHR5cGVvZiB2YWwgPT0gJ2Z1bmN0aW9uJyAmJiBpc19jYWxsKXtcblx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKyl7XG5cdFx0XHRcdGFyci5wdXNoKHZhbChpLCBhcnIpKTtcblx0XHRcdH1cblx0XHR9ZWxzZSBpZih2YWwgIT09IHVuZGVmaW5lZCl7XG5cdFx0XHRcblx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKyl7XG5cdFx0XHRcdGFyci5wdXNoKHZhbCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0YXJyLmNyUHJvcCgncmFuZF9pJywgcmFuZEluZGV4KTtcblx0XHRhcnIuY3JQcm9wKCdhZGQnLCBBZGRJdGVtKTtcblx0XHRhcnIuY3JQcm9wKCdkZWxsJywgRGVsbEl0ZW0pO1xuXHRcdFxuXHRcdHJldHVybiBhcnI7XG5cdH1cblx0XG5cdFxuXHRcblx0QXJyYXkuY3JQcm9wKCdjcmVhdGUnLCBjcmVhdGVBcnIpO1xuXHRcblx0XG5cdGlmKFJlZ0V4cC5wcm90b3R5cGUudG9KU09OICE9PSBcImZ1bmN0aW9uXCIpe1xuXHRcdFJlZ0V4cC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuc291cmNlOyB9O1xuXHR9XG5cbn0pKCk7XG5cblxuXG5cbiIsImNvbnN0IENySW50ZXJmaWNlID0gcmVxdWlyZShcIkFzeW5Db21tdW5cIikuQ3JDb21tdW5pY2F0b3I7XHJcblxyXG5mdW5jdGlvbiBDckludGVyV3ModXJsLCBvbmVWYWxpZEZ1bmMsIHR3b1ZhbGlkRnVuYyl7XHJcblxyXG5cdHZhciBzb2NrZXQgPSBuZXcgV2ViU29ja2V0KHVybCk7XHJcblx0dmFyIEludGVyV3MgPSBuZXcgQ3JJbnRlcmZpY2Uob25lVmFsaWRGdW5jLCB0d29WYWxpZEZ1bmMpO1xyXG5cclxuXHRzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignb3BlbicsIGZ1bmN0aW9uIChldmVudCkge1xyXG5cdFx0dmFyIEluRnVuYyA9IEludGVyV3MuY29ubmVjdChmdW5jdGlvbihtZXNzKXtcclxuXHRcdFx0c29ja2V0LnNlbmQoSlNPTi5zdHJpbmdpZnkobWVzcykpO1xyXG5cdFx0fSk7XHJcblx0XHRcclxuXHRcdHNvY2tldC5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24gKGV2ZW50KSB7XHJcblx0XHRcdEluRnVuYyhKU09OLnBhcnNlKGV2ZW50LmRhdGEpKTtcclxuXHRcdH0pO1xyXG5cdH0pO1xyXG5cdFxyXG5cdHJldHVybiBJbnRlcldzO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENySW50ZXJXcztcclxuIiwiY29uc3QgQ3JIb2FyZGVyID0gcmVxdWlyZShcIi4vSG9hcmRlci5qc1wiKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gQ3JJbnRlcmZpY2UoZmlyc3RfdHJhbnNmb3JtX2Z1bmMsIHNlY29uZF90cmFuc2Zvcm1fZnVuYyl7XHJcblx0XHJcblx0dmFyIElucHV0T25lID0gbnVsbDtcclxuXHR2YXIgT3V0cHV0T25lID0gbnVsbDtcclxuXHRcclxuXHR0aGlzLmNvbm5lY3QgPSBmdW5jdGlvbihvdXRwdXRGdW5jKXtcclxuXHRcdGlmKE91dHB1dE9uZSl7XHJcblx0XHRcdGlmKHNlY29uZF90cmFuc2Zvcm1fZnVuYyl7XHJcblx0XHRcdFx0dmFyIGJlZ0Z1bmMgPSBvdXRwdXRGdW5jO1xyXG5cdFx0XHRcdG91dHB1dEZ1bmMgPSBmdW5jdGlvbih2YWwpe1xyXG5cdFx0XHRcdFx0YmVnRnVuYyhzZWNvbmRfdHJhbnNmb3JtX2Z1bmModmFsKSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBUd29Db25uZWN0KG91dHB1dEZ1bmMpO1xyXG5cdFx0fVxyXG5cdFx0ZWxzZXtcclxuXHRcdFx0aWYoZmlyc3RfdHJhbnNmb3JtX2Z1bmMpe1xyXG5cdFx0XHRcdHZhciBiZWdGdW5jID0gb3V0cHV0RnVuYztcclxuXHRcdFx0XHRvdXRwdXRGdW5jID0gZnVuY3Rpb24odmFsKXtcclxuXHRcdFx0XHRcdGJlZ0Z1bmMoZmlyc3RfdHJhbnNmb3JtX2Z1bmModmFsKSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBPbmVDb25uZWN0KG91dHB1dEZ1bmMpO1xyXG5cdFx0fVxyXG5cdH07XHJcblx0XHJcblx0ZnVuY3Rpb24gT25lQ29ubmVjdChvdXRwdXRGdW5jKXtcclxuXHRcdE91dHB1dE9uZSA9IG91dHB1dEZ1bmM7XHJcblx0XHRJbnB1dE9uZSA9IENySG9hcmRlcigpO1xyXG5cdFx0XHJcblx0XHRyZXR1cm4gZnVuY3Rpb24odmFsKXtcclxuXHRcdFx0SW5wdXRPbmUodmFsKTtcclxuXHRcdH1cclxuXHR9XHJcblx0XHJcblx0ZnVuY3Rpb24gVHdvQ29ubmVjdChvdXRwdXRGdW5jKXtcclxuXHRcdGlmKElucHV0T25lLnRha2UpIHNldFRpbWVvdXQoSW5wdXRPbmUudGFrZS5iaW5kKG51bGwsIG91dHB1dEZ1bmMpLCAwKTtcclxuXHRcdElucHV0T25lID0gb3V0cHV0RnVuYztcclxuXHRcdFxyXG5cdFx0cmV0dXJuIE91dHB1dE9uZTtcclxuXHR9XHJcbn1cclxuXHJcblxyXG4iLCJjb25zdCBDckhvYXJkZXIgPSByZXF1aXJlKFwiLi9Ib2FyZGVyLmpzXCIpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBDckNvbm5lY3Rvcihjb21tLCBjb21tVHdvKXtcclxuXHRsZXQgSG9hciA9IENySG9hcmRlcigpO1xyXG5cdGxldCBpbnB1dCA9IG1zZyA9PiBIb2FyKG1zZyk7XHJcblxyXG5cdGlucHV0ID0gY29tbVR3by5jb25uZWN0KCBjb21tLmNvbm5lY3QobXNnID0+IGlucHV0KG1zZykpICk7XHJcblx0SG9hci50YWtlKGlucHV0KTtcclxufSIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gQ3JIb2FyZGVyKCl7XHJcblx0dmFyIGhvYXJkZXIgPSBbXTtcclxuXHRcclxuXHR2YXIgcHVzaCA9IGZ1bmN0aW9uKHZhbCl7XHJcblx0XHRob2FyZGVyLnB1c2godmFsKTtcclxuXHR9O1xyXG5cdFxyXG5cdHB1c2gudGFrZSA9IGZ1bmN0aW9uKGZ1bmMpe1xyXG5cdFx0c2V0VGltZW91dChmdW5jdGlvbigpe1xyXG5cdFx0XHR3aGlsZShob2FyZGVyLmxlbmd0aClcclxuXHRcdFx0XHRmdW5jKGhvYXJkZXIuc2hpZnQoKSk7XHJcblx0XHR9LCAwKTtcclxuXHR9XHJcblx0XHJcblx0cmV0dXJuIHB1c2g7XHJcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIENySW50ZXJmaWNlKGNvbW0pe1xyXG5cdGxldCBwdWxsID0gW107XHJcblxyXG5cdGxldCBzdGF0aWNJbnB1dCA9IGNvbW0uY29ubmVjdChkeW5hbWljSW5wdXQpO1xyXG5cdFxyXG5cdHRoaXMuY29ubmVjdCA9IGZ1bmN0aW9uKG91dHB1dEZ1bmMpe1xyXG5cdFx0XHJcblx0XHRwdWxsLnB1c2gob3V0cHV0RnVuYyk7XHJcblxyXG5cdFx0cmV0dXJuIHN0YXRpY0lucHV0O1xyXG5cdH07XHJcblx0XHJcblx0ZnVuY3Rpb24gZHluYW1pY0lucHV0KHZhbHVlKXtcclxuXHRcdHB1bGwuZm9yRWFjaChmdW5jID0+IGZ1bmModmFsdWUpKTtcclxuXHR9XHJcbn1cclxuXHJcblxyXG4iLCJmdW5jdGlvbiBDclJvdXRpbmdJbnRlcnMobG9nKXtcclxuXHRsZXQgYWRyX2FyciA9IFtdO1xyXG5cclxuXHRcclxuXHRsZXQgY29ubmVjdCA9IGZ1bmN0aW9uKEludGVyLCBhZHJlc3Mpe1xyXG5cclxuXHRcdGFkcl9hcnJbYWRyZXNzXSA9IEludGVyLmNvbm5lY3QoSW5wdXQpO1xyXG5cdFx0c2V0VGltZW91dCgoKSA9PiBhZHJfYXJyW2FkcmVzc10oe2FjdGlvbjogXCJDb25uZWN0ZWRcIiwgYWRyZXNzOiBhZHJlc3N9KSwgMCk7XHJcblx0fTtcclxuXHJcblxyXG5cdGNvbm5lY3QubG9nID0gbG9nO1xyXG5cdGZ1bmN0aW9uIElucHV0KG1lc3Mpe1xyXG5cdFx0aWYodHlwZW9mKGNvbm5lY3QubG9nKSA9PSBcImZ1bmN0aW9uXCIpIFxyXG5cdFx0XHRjb25uZWN0LmxvZyhtZXNzKTtcclxuXHJcblx0XHRsZXQgYWRyID0gbWVzcy5hZHI7XHJcblx0XHRkZWxldGUgbWVzcy5hZHI7XHJcblxyXG5cdFx0aWYoY29ubmVjdC5pc19mcmVlemUpIFxyXG5cdFx0XHRPYmplY3QuZnJlZXplKG1lc3MpO1xyXG5cclxuXHRcdGlmKGFkcl9hcnJbYWRyXSkgXHJcblx0XHRcdGFkcl9hcnJbYWRyXShtZXNzKTsgXHJcblx0XHRlbHNlIFxyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJGdW5jIG9uIGFkcmVzcyhcIiArIGFkciArICBcIikgaXMgbm90IGZpbmQhXCIpO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIGNvbm5lY3Q7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ3JSb3V0aW5nSW50ZXJzO1xyXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcclxuXHRDckhvYXJkZXI6IHJlcXVpcmUoXCIuL0hvYXJkZXIuanNcIiksXHJcblx0Q3JDb21tdW5pY2F0b3I6IHJlcXVpcmUoXCIuL0NvbW11bi5qc1wiKSxcclxuXHRDckNvbm5lY3RvcjogcmVxdWlyZShcIi4vQ29ubmVjdG9yLmpzXCIpLFxyXG5cdENyTXVsdGlDb21tOiByZXF1aXJlKFwiLi9NdWx0aUNvbW11bi5qc1wiKSxcclxuXHRDclJvdXRlcjogcmVxdWlyZShcIi4vUm91dGVyLmpzXCIpLFxyXG59O1xyXG4iLCJjb25zdCBVVUlEID0gcmVxdWlyZShcInV1aWQvdjVcIik7XHJcbmxldCBuYW1lc3BhY2UgPSByZXF1aXJlKFwidXVpZC92MVwiKSgpO1xyXG5cclxuZnVuY3Rpb24gQ3JDYXRhbG9nKGNvbW11bil7XHJcblx0bGV0IHR5cGVzID0gbmV3IE1hcCgpO1xyXG5cdGxldCByZXNvdXJjZXMgPSBuZXcgTWFwKCk7XHJcblxyXG5cdGxldCBzZW5kID0gY29tbXVuLmNvbm5lY3QoaW5wdXQpO1xyXG5cclxuXHJcblx0ZnVuY3Rpb24gaW5wdXQobWVzcyl7XHJcblx0XHRcclxuXHRcdHN3aXRjaChtZXNzLmFjdGlvbil7XHJcblx0XHRcdGNhc2UgXCJBZGRUeXBlXCI6IHNlbmQoYWRkVHlwZShtZXNzKSk7IGJyZWFrO1xyXG5cdFx0XHRjYXNlIFwiQWRkUmVzXCI6IHNlbmQoYWRkUmVzb3JjZShtZXNzKSk7IGJyZWFrO1xyXG5cdFx0XHRjYXNlIFwiQWRkUmVzQXJyXCI6IHNlbmQoYWRkUmVzQXJyKG1lc3MpKTsgYnJlYWs7XHJcblx0XHRcdGNhc2UgXCJGaW5kUmVzXCI6IHNlbmQoZmluZFJlc29yY2UobWVzcykpOyBicmVhaztcclxuXHRcdFx0Y2FzZSBcIkZpbmRUeXBlQWxsUmVzXCI6IHNlbmQoZmluZFJlc0Zyb21UeXBlKG1lc3MpKTsgYnJlYWs7XHJcblx0XHRcdGNhc2UgXCJSZW1vdmVSZXNcIjogc2VuZChyZW1vdmVSZXNvcmNlKG1lc3MpKTsgYnJlYWs7XHJcblx0XHRcdGRlZmF1bHQ6IGNvbnNvbGUubG9nKG1lc3MpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gYWRkVHlwZShtZXNzKXtcclxuXHRcdHR5cGVzLnNldChtZXNzLnR5cGUsIG1lc3MucGF0aCk7XHJcblxyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0YWN0aW9uOiBcIkFkZGVkVHlwZVwiLFxyXG5cdFx0XHRzdWNjZXNzOiB0cnVlLFxyXG5cdFx0XHR0eXBlOiBtZXNzLnR5cGUsXHJcblx0XHRcdGFkcjogbWVzcy5zb3VyY2VcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGFkZFJlc29yY2UobWVzcyl7XHJcblx0XHRcclxuXHRcdFxyXG5cdFx0bGV0IGlzX3R5cGUgPSBtZXNzLnJlc291cmNlICYmIHR5cGVzLmhhcyhtZXNzLnJlc291cmNlLnR5cGUpO1xyXG5cclxuXHRcdGlmKCFpc190eXBlKVxyXG5cdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdGFjdGlvbjogXCJBZGRlZFJlc1wiLFxyXG5cdFx0XHRcdHN1Y2Nlc3M6IGZhbHNlLFxyXG5cdFx0XHRcdG9sZElkOiBtZXNzLnJlc291cmNlID8gbWVzcy5yZXNvdXJjZS5pZCA6IFwiTm9uZVwiLFxyXG5cdFx0XHRcdG5ld0lkOiBcIk5vbmVcIixcclxuXHRcdFx0XHRhZHI6IG1lc3Muc291cmNlXHJcblx0XHRcdH1cclxuXHJcblx0XHRsZXQgdWlkID0gVVVJRChtZXNzLnJlc291cmNlLnR5cGUgKyBtZXNzLnJlc291cmNlLmlkLCBuYW1lc3BhY2UpO1xyXG5cdFx0XHJcblx0XHRsZXQgcmVzb3VyY2UgPSB7XHJcblx0XHRcdGlkOiB1aWQsXHJcblx0XHRcdHR5cGU6IG1lc3MucmVzb3VyY2UudHlwZSxcclxuXHRcdFx0cGF0aDogbWVzcy5yZXNvdXJjZS5wYXRoXHJcblx0XHR9O1xyXG5cclxuXHRcdHJlc291cmNlcy5zZXQodWlkLCByZXNvdXJjZSk7XHJcblxyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0YWN0aW9uOiBcIkFkZGVkUmVzXCIsXHJcblx0XHRcdHN1Y2Nlc3M6IHRydWUsXHJcblx0XHRcdG9sZElkOiBtZXNzLnJlc291cmNlLmlkLFxyXG5cdFx0XHRuZXdJZDogdWlkLFxyXG5cdFx0XHRhZHI6IG1lc3Muc291cmNlXHJcblx0XHR9XHJcblx0XHRcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGFkZFJlc0FycihtZXNzKXtcclxuXHRcdFxyXG5cdFx0dmFyIGlzX3R5cGUgPSB0eXBlcy5oYXMobWVzcy50eXBlKTtcclxuXHJcblx0XHRpZighaXNfdHlwZSlcclxuXHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHRhY3Rpb246IFwiQWRkZWRSZXNcIixcclxuXHRcdFx0XHRzdWNjZXNzOiBmYWxzZSxcclxuXHRcdFx0XHRhZGRlZElkczogW10sXHJcblx0XHRcdFx0YWRyOiBtZXNzLnNvdXJjZSxcclxuXHRcdFx0fVxyXG5cclxuXHRcdGxldCBhZGRlZElkcyA9IFtdO1xyXG5cdFx0XHJcblx0XHRtZXNzLnJlc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uKHJlc291cmNlLCBpKXtcclxuXHJcblx0XHRcdGxldCB1aWQgPSBVVUlEKHJlc291cmNlLnR5cGUgKyByZXNvdXJjZS5pZCwgbmFtZXNwYWNlKTtcclxuXHRcdFx0XHJcblx0XHRcdGFkZGVkSWRzLnB1c2goe1xyXG5cdFx0XHRcdG9sZElkOiByZXNvdXJjZS5pZCxcclxuXHRcdFx0XHRuZXdJZDogdWlkLFxyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdHJlc291cmNlcy5zZXQodWlkLCB7XHJcblx0XHRcdFx0aWQ6IHVpZCxcclxuXHRcdFx0XHR0eXBlOiByZXNvdXJjZS50eXBlLFxyXG5cdFx0XHRcdHBhdGg6IHJlc291cmNlLnBhdGgsXHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdH0pO1xyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0YWN0aW9uOiBcIkFkZGVkUmVzQXJyXCIsXHJcblx0XHRcdHN1Y2Nlc3M6ICEhYWRkZWRJZHMubGVuZ3RoLFxyXG5cdFx0XHRhZGRlZElkcyxcclxuXHRcdFx0YWRyOiBtZXNzLnNvdXJjZVxyXG5cdFx0fVxyXG5cdFx0XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBmaW5kUmVzb3JjZShtZXNzKXtcclxuXHJcblx0XHR2YXIgaXNfdWlkID0gcmVzb3VyY2VzLmhhcyhtZXNzLmlkKTtcclxuXHJcblx0XHRpZighaXNfdWlkKVxyXG5cdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdGFjdGlvbjogXCJGb3VuZFJlc1wiLFxyXG5cdFx0XHRcdHN1Y2Nlc3M6IGZhbHNlLFxyXG5cdFx0XHRcdGlkOiBtZXNzLmlkLFxyXG5cdFx0XHRcdHJlc291cmNlOiBudWxsLFxyXG5cdFx0XHRcdGZ1bGxQYXRoOiBudWxsLFxyXG5cdFx0XHRcdGFkcjogbWVzcy5zb3VyY2VcclxuXHRcdFx0fVxyXG5cclxuXHRcdGxldCByZXNvdXJjZSA9IHJlc291cmNlcy5nZXQobWVzcy5pZCk7XHJcblx0XHRsZXQgZnVsbFBhdGggPSB0eXBlcy5nZXQocmVzb3VyY2UudHlwZSkuY29uY2F0KHJlc291cmNlLnBhdGgpO1xyXG5cclxuXHRcdHJldHVybiB7XHJcblx0XHRcdGFjdGlvbjogXCJGb3VuZFJlc1wiLFxyXG5cdFx0XHRzdWNjZXNzOiB0cnVlLFxyXG5cdFx0XHRpZDogbWVzcy5pZCxcclxuXHRcdFx0cmVzb3VyY2UsXHJcblx0XHRcdGZ1bGxQYXRoLFxyXG5cdFx0XHRhZHI6IG1lc3Muc291cmNlLFxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGZpbmRSZXNGcm9tVHlwZShtZXNzKXtcclxuXHJcblx0XHRsZXQgaXNfdHlwZSA9IHR5cGVzLmhhcyhtZXNzLnR5cGUpO1xyXG5cclxuXHRcdGlmKCFpc190eXBlKVxyXG5cdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdGFjdGlvbjogXCJGb3VuZFJlc0FyclwiLFxyXG5cdFx0XHRcdHN1Y2Nlc3M6IGZhbHNlLFxyXG5cdFx0XHRcdHJlc291cmNlczogW10sXHJcblx0XHRcdFx0YWRyOiBtZXNzLnNvdXJjZVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0bGV0IHR5cGVQYXRoID0gdHlwZXMuZ2V0KG1lc3MudHlwZSk7XHJcblx0XHRsZXQgZm91bmRSZXNvdXJjZXMgPSBbXTtcclxuXHJcblx0XHRyZXNvdXJjZXMuZm9yRWFjaCgoe2lkLCB0eXBlLCBwYXRofSkgPT4ge1xyXG5cdFx0XHRpZih0eXBlID09IG1lc3MudHlwZSlcclxuXHRcdFx0XHRmb3VuZFJlc291cmNlcy5wdXNoKHtcclxuXHRcdFx0XHRcdGlkLFxyXG5cdFx0XHRcdFx0ZnVsbFBhdGg6IHR5cGVQYXRoLmNvbmNhdChwYXRoKSxcclxuXHRcdFx0XHR9KTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdHJldHVybiB7XHJcblx0XHRcdGFjdGlvbjogXCJGb3VuZFJlc0FyclwiLFxyXG5cdFx0XHRzdWNjZXNzOiAhIWZvdW5kUmVzb3VyY2VzLmxlbmd0aCxcclxuXHRcdFx0cmVzb3VyY2VzOiBmb3VuZFJlc291cmNlcyxcclxuXHRcdFx0YWRyOiBtZXNzLnNvdXJjZSxcclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiByZW1vdmVSZXNvcmNlKG1lc3Mpe1xyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0YWN0aW9uOiBcIlJlbW92ZWRSZXNcIixcclxuXHRcdFx0c3VjY2VzczogcmVzb3VyY2VzLmRlbGV0ZShtZXNzLmlkKSxcclxuXHRcdFx0aWQ6IG1lc3MuaWQsXHJcblx0XHRcdGFkcjogbWVzcy5zb3VyY2VcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ3JDYXRhbG9nOyIsIi8qKlxuICogQml0IHR3aWRkbGluZyBoYWNrcyBmb3IgSmF2YVNjcmlwdC5cbiAqXG4gKiBBdXRob3I6IE1pa29sYSBMeXNlbmtvXG4gKlxuICogUG9ydGVkIGZyb20gU3RhbmZvcmQgYml0IHR3aWRkbGluZyBoYWNrIGxpYnJhcnk6XG4gKiAgICBodHRwOi8vZ3JhcGhpY3Muc3RhbmZvcmQuZWR1L35zZWFuZGVyL2JpdGhhY2tzLmh0bWxcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjsgXCJ1c2UgcmVzdHJpY3RcIjtcblxuLy9OdW1iZXIgb2YgYml0cyBpbiBhbiBpbnRlZ2VyXG52YXIgSU5UX0JJVFMgPSAzMjtcblxuLy9Db25zdGFudHNcbmV4cG9ydHMuSU5UX0JJVFMgID0gSU5UX0JJVFM7XG5leHBvcnRzLklOVF9NQVggICA9ICAweDdmZmZmZmZmO1xuZXhwb3J0cy5JTlRfTUlOICAgPSAtMTw8KElOVF9CSVRTLTEpO1xuXG4vL1JldHVybnMgLTEsIDAsICsxIGRlcGVuZGluZyBvbiBzaWduIG9mIHhcbmV4cG9ydHMuc2lnbiA9IGZ1bmN0aW9uKHYpIHtcbiAgcmV0dXJuICh2ID4gMCkgLSAodiA8IDApO1xufVxuXG4vL0NvbXB1dGVzIGFic29sdXRlIHZhbHVlIG9mIGludGVnZXJcbmV4cG9ydHMuYWJzID0gZnVuY3Rpb24odikge1xuICB2YXIgbWFzayA9IHYgPj4gKElOVF9CSVRTLTEpO1xuICByZXR1cm4gKHYgXiBtYXNrKSAtIG1hc2s7XG59XG5cbi8vQ29tcHV0ZXMgbWluaW11bSBvZiBpbnRlZ2VycyB4IGFuZCB5XG5leHBvcnRzLm1pbiA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgcmV0dXJuIHkgXiAoKHggXiB5KSAmIC0oeCA8IHkpKTtcbn1cblxuLy9Db21wdXRlcyBtYXhpbXVtIG9mIGludGVnZXJzIHggYW5kIHlcbmV4cG9ydHMubWF4ID0gZnVuY3Rpb24oeCwgeSkge1xuICByZXR1cm4geCBeICgoeCBeIHkpICYgLSh4IDwgeSkpO1xufVxuXG4vL0NoZWNrcyBpZiBhIG51bWJlciBpcyBhIHBvd2VyIG9mIHR3b1xuZXhwb3J0cy5pc1BvdzIgPSBmdW5jdGlvbih2KSB7XG4gIHJldHVybiAhKHYgJiAodi0xKSkgJiYgKCEhdik7XG59XG5cbi8vQ29tcHV0ZXMgbG9nIGJhc2UgMiBvZiB2XG5leHBvcnRzLmxvZzIgPSBmdW5jdGlvbih2KSB7XG4gIHZhciByLCBzaGlmdDtcbiAgciA9ICAgICAodiA+IDB4RkZGRikgPDwgNDsgdiA+Pj49IHI7XG4gIHNoaWZ0ID0gKHYgPiAweEZGICApIDw8IDM7IHYgPj4+PSBzaGlmdDsgciB8PSBzaGlmdDtcbiAgc2hpZnQgPSAodiA+IDB4RiAgICkgPDwgMjsgdiA+Pj49IHNoaWZ0OyByIHw9IHNoaWZ0O1xuICBzaGlmdCA9ICh2ID4gMHgzICAgKSA8PCAxOyB2ID4+Pj0gc2hpZnQ7IHIgfD0gc2hpZnQ7XG4gIHJldHVybiByIHwgKHYgPj4gMSk7XG59XG5cbi8vQ29tcHV0ZXMgbG9nIGJhc2UgMTAgb2YgdlxuZXhwb3J0cy5sb2cxMCA9IGZ1bmN0aW9uKHYpIHtcbiAgcmV0dXJuICAodiA+PSAxMDAwMDAwMDAwKSA/IDkgOiAodiA+PSAxMDAwMDAwMDApID8gOCA6ICh2ID49IDEwMDAwMDAwKSA/IDcgOlxuICAgICAgICAgICh2ID49IDEwMDAwMDApID8gNiA6ICh2ID49IDEwMDAwMCkgPyA1IDogKHYgPj0gMTAwMDApID8gNCA6XG4gICAgICAgICAgKHYgPj0gMTAwMCkgPyAzIDogKHYgPj0gMTAwKSA/IDIgOiAodiA+PSAxMCkgPyAxIDogMDtcbn1cblxuLy9Db3VudHMgbnVtYmVyIG9mIGJpdHNcbmV4cG9ydHMucG9wQ291bnQgPSBmdW5jdGlvbih2KSB7XG4gIHYgPSB2IC0gKCh2ID4+PiAxKSAmIDB4NTU1NTU1NTUpO1xuICB2ID0gKHYgJiAweDMzMzMzMzMzKSArICgodiA+Pj4gMikgJiAweDMzMzMzMzMzKTtcbiAgcmV0dXJuICgodiArICh2ID4+PiA0KSAmIDB4RjBGMEYwRikgKiAweDEwMTAxMDEpID4+PiAyNDtcbn1cblxuLy9Db3VudHMgbnVtYmVyIG9mIHRyYWlsaW5nIHplcm9zXG5mdW5jdGlvbiBjb3VudFRyYWlsaW5nWmVyb3Modikge1xuICB2YXIgYyA9IDMyO1xuICB2ICY9IC12O1xuICBpZiAodikgYy0tO1xuICBpZiAodiAmIDB4MDAwMEZGRkYpIGMgLT0gMTY7XG4gIGlmICh2ICYgMHgwMEZGMDBGRikgYyAtPSA4O1xuICBpZiAodiAmIDB4MEYwRjBGMEYpIGMgLT0gNDtcbiAgaWYgKHYgJiAweDMzMzMzMzMzKSBjIC09IDI7XG4gIGlmICh2ICYgMHg1NTU1NTU1NSkgYyAtPSAxO1xuICByZXR1cm4gYztcbn1cbmV4cG9ydHMuY291bnRUcmFpbGluZ1plcm9zID0gY291bnRUcmFpbGluZ1plcm9zO1xuXG4vL1JvdW5kcyB0byBuZXh0IHBvd2VyIG9mIDJcbmV4cG9ydHMubmV4dFBvdzIgPSBmdW5jdGlvbih2KSB7XG4gIHYgKz0gdiA9PT0gMDtcbiAgLS12O1xuICB2IHw9IHYgPj4+IDE7XG4gIHYgfD0gdiA+Pj4gMjtcbiAgdiB8PSB2ID4+PiA0O1xuICB2IHw9IHYgPj4+IDg7XG4gIHYgfD0gdiA+Pj4gMTY7XG4gIHJldHVybiB2ICsgMTtcbn1cblxuLy9Sb3VuZHMgZG93biB0byBwcmV2aW91cyBwb3dlciBvZiAyXG5leHBvcnRzLnByZXZQb3cyID0gZnVuY3Rpb24odikge1xuICB2IHw9IHYgPj4+IDE7XG4gIHYgfD0gdiA+Pj4gMjtcbiAgdiB8PSB2ID4+PiA0O1xuICB2IHw9IHYgPj4+IDg7XG4gIHYgfD0gdiA+Pj4gMTY7XG4gIHJldHVybiB2IC0gKHY+Pj4xKTtcbn1cblxuLy9Db21wdXRlcyBwYXJpdHkgb2Ygd29yZFxuZXhwb3J0cy5wYXJpdHkgPSBmdW5jdGlvbih2KSB7XG4gIHYgXj0gdiA+Pj4gMTY7XG4gIHYgXj0gdiA+Pj4gODtcbiAgdiBePSB2ID4+PiA0O1xuICB2ICY9IDB4ZjtcbiAgcmV0dXJuICgweDY5OTYgPj4+IHYpICYgMTtcbn1cblxudmFyIFJFVkVSU0VfVEFCTEUgPSBuZXcgQXJyYXkoMjU2KTtcblxuKGZ1bmN0aW9uKHRhYikge1xuICBmb3IodmFyIGk9MDsgaTwyNTY7ICsraSkge1xuICAgIHZhciB2ID0gaSwgciA9IGksIHMgPSA3O1xuICAgIGZvciAodiA+Pj49IDE7IHY7IHYgPj4+PSAxKSB7XG4gICAgICByIDw8PSAxO1xuICAgICAgciB8PSB2ICYgMTtcbiAgICAgIC0tcztcbiAgICB9XG4gICAgdGFiW2ldID0gKHIgPDwgcykgJiAweGZmO1xuICB9XG59KShSRVZFUlNFX1RBQkxFKTtcblxuLy9SZXZlcnNlIGJpdHMgaW4gYSAzMiBiaXQgd29yZFxuZXhwb3J0cy5yZXZlcnNlID0gZnVuY3Rpb24odikge1xuICByZXR1cm4gIChSRVZFUlNFX1RBQkxFWyB2ICAgICAgICAgJiAweGZmXSA8PCAyNCkgfFxuICAgICAgICAgIChSRVZFUlNFX1RBQkxFWyh2ID4+PiA4KSAgJiAweGZmXSA8PCAxNikgfFxuICAgICAgICAgIChSRVZFUlNFX1RBQkxFWyh2ID4+PiAxNikgJiAweGZmXSA8PCA4KSAgfFxuICAgICAgICAgICBSRVZFUlNFX1RBQkxFWyh2ID4+PiAyNCkgJiAweGZmXTtcbn1cblxuLy9JbnRlcmxlYXZlIGJpdHMgb2YgMiBjb29yZGluYXRlcyB3aXRoIDE2IGJpdHMuICBVc2VmdWwgZm9yIGZhc3QgcXVhZHRyZWUgY29kZXNcbmV4cG9ydHMuaW50ZXJsZWF2ZTIgPSBmdW5jdGlvbih4LCB5KSB7XG4gIHggJj0gMHhGRkZGO1xuICB4ID0gKHggfCAoeCA8PCA4KSkgJiAweDAwRkYwMEZGO1xuICB4ID0gKHggfCAoeCA8PCA0KSkgJiAweDBGMEYwRjBGO1xuICB4ID0gKHggfCAoeCA8PCAyKSkgJiAweDMzMzMzMzMzO1xuICB4ID0gKHggfCAoeCA8PCAxKSkgJiAweDU1NTU1NTU1O1xuXG4gIHkgJj0gMHhGRkZGO1xuICB5ID0gKHkgfCAoeSA8PCA4KSkgJiAweDAwRkYwMEZGO1xuICB5ID0gKHkgfCAoeSA8PCA0KSkgJiAweDBGMEYwRjBGO1xuICB5ID0gKHkgfCAoeSA8PCAyKSkgJiAweDMzMzMzMzMzO1xuICB5ID0gKHkgfCAoeSA8PCAxKSkgJiAweDU1NTU1NTU1O1xuXG4gIHJldHVybiB4IHwgKHkgPDwgMSk7XG59XG5cbi8vRXh0cmFjdHMgdGhlIG50aCBpbnRlcmxlYXZlZCBjb21wb25lbnRcbmV4cG9ydHMuZGVpbnRlcmxlYXZlMiA9IGZ1bmN0aW9uKHYsIG4pIHtcbiAgdiA9ICh2ID4+PiBuKSAmIDB4NTU1NTU1NTU7XG4gIHYgPSAodiB8ICh2ID4+PiAxKSkgICYgMHgzMzMzMzMzMztcbiAgdiA9ICh2IHwgKHYgPj4+IDIpKSAgJiAweDBGMEYwRjBGO1xuICB2ID0gKHYgfCAodiA+Pj4gNCkpICAmIDB4MDBGRjAwRkY7XG4gIHYgPSAodiB8ICh2ID4+PiAxNikpICYgMHgwMDBGRkZGO1xuICByZXR1cm4gKHYgPDwgMTYpID4+IDE2O1xufVxuXG5cbi8vSW50ZXJsZWF2ZSBiaXRzIG9mIDMgY29vcmRpbmF0ZXMsIGVhY2ggd2l0aCAxMCBiaXRzLiAgVXNlZnVsIGZvciBmYXN0IG9jdHJlZSBjb2Rlc1xuZXhwb3J0cy5pbnRlcmxlYXZlMyA9IGZ1bmN0aW9uKHgsIHksIHopIHtcbiAgeCAmPSAweDNGRjtcbiAgeCAgPSAoeCB8ICh4PDwxNikpICYgNDI3ODE5MDMzNTtcbiAgeCAgPSAoeCB8ICh4PDw4KSkgICYgMjUxNzE5Njk1O1xuICB4ICA9ICh4IHwgKHg8PDQpKSAgJiAzMjcyMzU2MDM1O1xuICB4ICA9ICh4IHwgKHg8PDIpKSAgJiAxMjI3MTMzNTEzO1xuXG4gIHkgJj0gMHgzRkY7XG4gIHkgID0gKHkgfCAoeTw8MTYpKSAmIDQyNzgxOTAzMzU7XG4gIHkgID0gKHkgfCAoeTw8OCkpICAmIDI1MTcxOTY5NTtcbiAgeSAgPSAoeSB8ICh5PDw0KSkgICYgMzI3MjM1NjAzNTtcbiAgeSAgPSAoeSB8ICh5PDwyKSkgICYgMTIyNzEzMzUxMztcbiAgeCB8PSAoeSA8PCAxKTtcbiAgXG4gIHogJj0gMHgzRkY7XG4gIHogID0gKHogfCAoejw8MTYpKSAmIDQyNzgxOTAzMzU7XG4gIHogID0gKHogfCAoejw8OCkpICAmIDI1MTcxOTY5NTtcbiAgeiAgPSAoeiB8ICh6PDw0KSkgICYgMzI3MjM1NjAzNTtcbiAgeiAgPSAoeiB8ICh6PDwyKSkgICYgMTIyNzEzMzUxMztcbiAgXG4gIHJldHVybiB4IHwgKHogPDwgMik7XG59XG5cbi8vRXh0cmFjdHMgbnRoIGludGVybGVhdmVkIGNvbXBvbmVudCBvZiBhIDMtdHVwbGVcbmV4cG9ydHMuZGVpbnRlcmxlYXZlMyA9IGZ1bmN0aW9uKHYsIG4pIHtcbiAgdiA9ICh2ID4+PiBuKSAgICAgICAmIDEyMjcxMzM1MTM7XG4gIHYgPSAodiB8ICh2Pj4+MikpICAgJiAzMjcyMzU2MDM1O1xuICB2ID0gKHYgfCAodj4+PjQpKSAgICYgMjUxNzE5Njk1O1xuICB2ID0gKHYgfCAodj4+PjgpKSAgICYgNDI3ODE5MDMzNTtcbiAgdiA9ICh2IHwgKHY+Pj4xNikpICAmIDB4M0ZGO1xuICByZXR1cm4gKHY8PDIyKT4+MjI7XG59XG5cbi8vQ29tcHV0ZXMgbmV4dCBjb21iaW5hdGlvbiBpbiBjb2xleGljb2dyYXBoaWMgb3JkZXIgKHRoaXMgaXMgbWlzdGFrZW5seSBjYWxsZWQgbmV4dFBlcm11dGF0aW9uIG9uIHRoZSBiaXQgdHdpZGRsaW5nIGhhY2tzIHBhZ2UpXG5leHBvcnRzLm5leHRDb21iaW5hdGlvbiA9IGZ1bmN0aW9uKHYpIHtcbiAgdmFyIHQgPSB2IHwgKHYgLSAxKTtcbiAgcmV0dXJuICh0ICsgMSkgfCAoKCh+dCAmIC1+dCkgLSAxKSA+Pj4gKGNvdW50VHJhaWxpbmdaZXJvcyh2KSArIDEpKTtcbn1cblxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVhcmN1dDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBlYXJjdXQ7XG5cbmZ1bmN0aW9uIGVhcmN1dChkYXRhLCBob2xlSW5kaWNlcywgZGltKSB7XG5cbiAgICBkaW0gPSBkaW0gfHwgMjtcblxuICAgIHZhciBoYXNIb2xlcyA9IGhvbGVJbmRpY2VzICYmIGhvbGVJbmRpY2VzLmxlbmd0aCxcbiAgICAgICAgb3V0ZXJMZW4gPSBoYXNIb2xlcyA/IGhvbGVJbmRpY2VzWzBdICogZGltIDogZGF0YS5sZW5ndGgsXG4gICAgICAgIG91dGVyTm9kZSA9IGxpbmtlZExpc3QoZGF0YSwgMCwgb3V0ZXJMZW4sIGRpbSwgdHJ1ZSksXG4gICAgICAgIHRyaWFuZ2xlcyA9IFtdO1xuXG4gICAgaWYgKCFvdXRlck5vZGUgfHwgb3V0ZXJOb2RlLm5leHQgPT09IG91dGVyTm9kZS5wcmV2KSByZXR1cm4gdHJpYW5nbGVzO1xuXG4gICAgdmFyIG1pblgsIG1pblksIG1heFgsIG1heFksIHgsIHksIGludlNpemU7XG5cbiAgICBpZiAoaGFzSG9sZXMpIG91dGVyTm9kZSA9IGVsaW1pbmF0ZUhvbGVzKGRhdGEsIGhvbGVJbmRpY2VzLCBvdXRlck5vZGUsIGRpbSk7XG5cbiAgICAvLyBpZiB0aGUgc2hhcGUgaXMgbm90IHRvbyBzaW1wbGUsIHdlJ2xsIHVzZSB6LW9yZGVyIGN1cnZlIGhhc2ggbGF0ZXI7IGNhbGN1bGF0ZSBwb2x5Z29uIGJib3hcbiAgICBpZiAoZGF0YS5sZW5ndGggPiA4MCAqIGRpbSkge1xuICAgICAgICBtaW5YID0gbWF4WCA9IGRhdGFbMF07XG4gICAgICAgIG1pblkgPSBtYXhZID0gZGF0YVsxXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gZGltOyBpIDwgb3V0ZXJMZW47IGkgKz0gZGltKSB7XG4gICAgICAgICAgICB4ID0gZGF0YVtpXTtcbiAgICAgICAgICAgIHkgPSBkYXRhW2kgKyAxXTtcbiAgICAgICAgICAgIGlmICh4IDwgbWluWCkgbWluWCA9IHg7XG4gICAgICAgICAgICBpZiAoeSA8IG1pblkpIG1pblkgPSB5O1xuICAgICAgICAgICAgaWYgKHggPiBtYXhYKSBtYXhYID0geDtcbiAgICAgICAgICAgIGlmICh5ID4gbWF4WSkgbWF4WSA9IHk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtaW5YLCBtaW5ZIGFuZCBpbnZTaXplIGFyZSBsYXRlciB1c2VkIHRvIHRyYW5zZm9ybSBjb29yZHMgaW50byBpbnRlZ2VycyBmb3Igei1vcmRlciBjYWxjdWxhdGlvblxuICAgICAgICBpbnZTaXplID0gTWF0aC5tYXgobWF4WCAtIG1pblgsIG1heFkgLSBtaW5ZKTtcbiAgICAgICAgaW52U2l6ZSA9IGludlNpemUgIT09IDAgPyAxIC8gaW52U2l6ZSA6IDA7XG4gICAgfVxuXG4gICAgZWFyY3V0TGlua2VkKG91dGVyTm9kZSwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUpO1xuXG4gICAgcmV0dXJuIHRyaWFuZ2xlcztcbn1cblxuLy8gY3JlYXRlIGEgY2lyY3VsYXIgZG91Ymx5IGxpbmtlZCBsaXN0IGZyb20gcG9seWdvbiBwb2ludHMgaW4gdGhlIHNwZWNpZmllZCB3aW5kaW5nIG9yZGVyXG5mdW5jdGlvbiBsaW5rZWRMaXN0KGRhdGEsIHN0YXJ0LCBlbmQsIGRpbSwgY2xvY2t3aXNlKSB7XG4gICAgdmFyIGksIGxhc3Q7XG5cbiAgICBpZiAoY2xvY2t3aXNlID09PSAoc2lnbmVkQXJlYShkYXRhLCBzdGFydCwgZW5kLCBkaW0pID4gMCkpIHtcbiAgICAgICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gZGltKSBsYXN0ID0gaW5zZXJ0Tm9kZShpLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSwgbGFzdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChpID0gZW5kIC0gZGltOyBpID49IHN0YXJ0OyBpIC09IGRpbSkgbGFzdCA9IGluc2VydE5vZGUoaSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sIGxhc3QpO1xuICAgIH1cblxuICAgIGlmIChsYXN0ICYmIGVxdWFscyhsYXN0LCBsYXN0Lm5leHQpKSB7XG4gICAgICAgIHJlbW92ZU5vZGUobGFzdCk7XG4gICAgICAgIGxhc3QgPSBsYXN0Lm5leHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxhc3Q7XG59XG5cbi8vIGVsaW1pbmF0ZSBjb2xpbmVhciBvciBkdXBsaWNhdGUgcG9pbnRzXG5mdW5jdGlvbiBmaWx0ZXJQb2ludHMoc3RhcnQsIGVuZCkge1xuICAgIGlmICghc3RhcnQpIHJldHVybiBzdGFydDtcbiAgICBpZiAoIWVuZCkgZW5kID0gc3RhcnQ7XG5cbiAgICB2YXIgcCA9IHN0YXJ0LFxuICAgICAgICBhZ2FpbjtcbiAgICBkbyB7XG4gICAgICAgIGFnYWluID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKCFwLnN0ZWluZXIgJiYgKGVxdWFscyhwLCBwLm5leHQpIHx8IGFyZWEocC5wcmV2LCBwLCBwLm5leHQpID09PSAwKSkge1xuICAgICAgICAgICAgcmVtb3ZlTm9kZShwKTtcbiAgICAgICAgICAgIHAgPSBlbmQgPSBwLnByZXY7XG4gICAgICAgICAgICBpZiAocCA9PT0gcC5uZXh0KSBicmVhaztcbiAgICAgICAgICAgIGFnYWluID0gdHJ1ZTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcCA9IHAubmV4dDtcbiAgICAgICAgfVxuICAgIH0gd2hpbGUgKGFnYWluIHx8IHAgIT09IGVuZCk7XG5cbiAgICByZXR1cm4gZW5kO1xufVxuXG4vLyBtYWluIGVhciBzbGljaW5nIGxvb3Agd2hpY2ggdHJpYW5ndWxhdGVzIGEgcG9seWdvbiAoZ2l2ZW4gYXMgYSBsaW5rZWQgbGlzdClcbmZ1bmN0aW9uIGVhcmN1dExpbmtlZChlYXIsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplLCBwYXNzKSB7XG4gICAgaWYgKCFlYXIpIHJldHVybjtcblxuICAgIC8vIGludGVybGluayBwb2x5Z29uIG5vZGVzIGluIHotb3JkZXJcbiAgICBpZiAoIXBhc3MgJiYgaW52U2l6ZSkgaW5kZXhDdXJ2ZShlYXIsIG1pblgsIG1pblksIGludlNpemUpO1xuXG4gICAgdmFyIHN0b3AgPSBlYXIsXG4gICAgICAgIHByZXYsIG5leHQ7XG5cbiAgICAvLyBpdGVyYXRlIHRocm91Z2ggZWFycywgc2xpY2luZyB0aGVtIG9uZSBieSBvbmVcbiAgICB3aGlsZSAoZWFyLnByZXYgIT09IGVhci5uZXh0KSB7XG4gICAgICAgIHByZXYgPSBlYXIucHJldjtcbiAgICAgICAgbmV4dCA9IGVhci5uZXh0O1xuXG4gICAgICAgIGlmIChpbnZTaXplID8gaXNFYXJIYXNoZWQoZWFyLCBtaW5YLCBtaW5ZLCBpbnZTaXplKSA6IGlzRWFyKGVhcikpIHtcbiAgICAgICAgICAgIC8vIGN1dCBvZmYgdGhlIHRyaWFuZ2xlXG4gICAgICAgICAgICB0cmlhbmdsZXMucHVzaChwcmV2LmkgLyBkaW0pO1xuICAgICAgICAgICAgdHJpYW5nbGVzLnB1c2goZWFyLmkgLyBkaW0pO1xuICAgICAgICAgICAgdHJpYW5nbGVzLnB1c2gobmV4dC5pIC8gZGltKTtcblxuICAgICAgICAgICAgcmVtb3ZlTm9kZShlYXIpO1xuXG4gICAgICAgICAgICAvLyBza2lwcGluZyB0aGUgbmV4dCB2ZXJ0ZXggbGVhZHMgdG8gbGVzcyBzbGl2ZXIgdHJpYW5nbGVzXG4gICAgICAgICAgICBlYXIgPSBuZXh0Lm5leHQ7XG4gICAgICAgICAgICBzdG9wID0gbmV4dC5uZXh0O1xuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVhciA9IG5leHQ7XG5cbiAgICAgICAgLy8gaWYgd2UgbG9vcGVkIHRocm91Z2ggdGhlIHdob2xlIHJlbWFpbmluZyBwb2x5Z29uIGFuZCBjYW4ndCBmaW5kIGFueSBtb3JlIGVhcnNcbiAgICAgICAgaWYgKGVhciA9PT0gc3RvcCkge1xuICAgICAgICAgICAgLy8gdHJ5IGZpbHRlcmluZyBwb2ludHMgYW5kIHNsaWNpbmcgYWdhaW5cbiAgICAgICAgICAgIGlmICghcGFzcykge1xuICAgICAgICAgICAgICAgIGVhcmN1dExpbmtlZChmaWx0ZXJQb2ludHMoZWFyKSwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUsIDEpO1xuXG4gICAgICAgICAgICAvLyBpZiB0aGlzIGRpZG4ndCB3b3JrLCB0cnkgY3VyaW5nIGFsbCBzbWFsbCBzZWxmLWludGVyc2VjdGlvbnMgbG9jYWxseVxuICAgICAgICAgICAgfSBlbHNlIGlmIChwYXNzID09PSAxKSB7XG4gICAgICAgICAgICAgICAgZWFyID0gY3VyZUxvY2FsSW50ZXJzZWN0aW9ucyhmaWx0ZXJQb2ludHMoZWFyKSwgdHJpYW5nbGVzLCBkaW0pO1xuICAgICAgICAgICAgICAgIGVhcmN1dExpbmtlZChlYXIsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplLCAyKTtcblxuICAgICAgICAgICAgLy8gYXMgYSBsYXN0IHJlc29ydCwgdHJ5IHNwbGl0dGluZyB0aGUgcmVtYWluaW5nIHBvbHlnb24gaW50byB0d29cbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGFzcyA9PT0gMikge1xuICAgICAgICAgICAgICAgIHNwbGl0RWFyY3V0KGVhciwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gY2hlY2sgd2hldGhlciBhIHBvbHlnb24gbm9kZSBmb3JtcyBhIHZhbGlkIGVhciB3aXRoIGFkamFjZW50IG5vZGVzXG5mdW5jdGlvbiBpc0VhcihlYXIpIHtcbiAgICB2YXIgYSA9IGVhci5wcmV2LFxuICAgICAgICBiID0gZWFyLFxuICAgICAgICBjID0gZWFyLm5leHQ7XG5cbiAgICBpZiAoYXJlYShhLCBiLCBjKSA+PSAwKSByZXR1cm4gZmFsc2U7IC8vIHJlZmxleCwgY2FuJ3QgYmUgYW4gZWFyXG5cbiAgICAvLyBub3cgbWFrZSBzdXJlIHdlIGRvbid0IGhhdmUgb3RoZXIgcG9pbnRzIGluc2lkZSB0aGUgcG90ZW50aWFsIGVhclxuICAgIHZhciBwID0gZWFyLm5leHQubmV4dDtcblxuICAgIHdoaWxlIChwICE9PSBlYXIucHJldikge1xuICAgICAgICBpZiAocG9pbnRJblRyaWFuZ2xlKGEueCwgYS55LCBiLngsIGIueSwgYy54LCBjLnksIHAueCwgcC55KSAmJlxuICAgICAgICAgICAgYXJlYShwLnByZXYsIHAsIHAubmV4dCkgPj0gMCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBwID0gcC5uZXh0O1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBpc0Vhckhhc2hlZChlYXIsIG1pblgsIG1pblksIGludlNpemUpIHtcbiAgICB2YXIgYSA9IGVhci5wcmV2LFxuICAgICAgICBiID0gZWFyLFxuICAgICAgICBjID0gZWFyLm5leHQ7XG5cbiAgICBpZiAoYXJlYShhLCBiLCBjKSA+PSAwKSByZXR1cm4gZmFsc2U7IC8vIHJlZmxleCwgY2FuJ3QgYmUgYW4gZWFyXG5cbiAgICAvLyB0cmlhbmdsZSBiYm94OyBtaW4gJiBtYXggYXJlIGNhbGN1bGF0ZWQgbGlrZSB0aGlzIGZvciBzcGVlZFxuICAgIHZhciBtaW5UWCA9IGEueCA8IGIueCA/IChhLnggPCBjLnggPyBhLnggOiBjLngpIDogKGIueCA8IGMueCA/IGIueCA6IGMueCksXG4gICAgICAgIG1pblRZID0gYS55IDwgYi55ID8gKGEueSA8IGMueSA/IGEueSA6IGMueSkgOiAoYi55IDwgYy55ID8gYi55IDogYy55KSxcbiAgICAgICAgbWF4VFggPSBhLnggPiBiLnggPyAoYS54ID4gYy54ID8gYS54IDogYy54KSA6IChiLnggPiBjLnggPyBiLnggOiBjLngpLFxuICAgICAgICBtYXhUWSA9IGEueSA+IGIueSA/IChhLnkgPiBjLnkgPyBhLnkgOiBjLnkpIDogKGIueSA+IGMueSA/IGIueSA6IGMueSk7XG5cbiAgICAvLyB6LW9yZGVyIHJhbmdlIGZvciB0aGUgY3VycmVudCB0cmlhbmdsZSBiYm94O1xuICAgIHZhciBtaW5aID0gek9yZGVyKG1pblRYLCBtaW5UWSwgbWluWCwgbWluWSwgaW52U2l6ZSksXG4gICAgICAgIG1heFogPSB6T3JkZXIobWF4VFgsIG1heFRZLCBtaW5YLCBtaW5ZLCBpbnZTaXplKTtcblxuICAgIHZhciBwID0gZWFyLnByZXZaLFxuICAgICAgICBuID0gZWFyLm5leHRaO1xuXG4gICAgLy8gbG9vayBmb3IgcG9pbnRzIGluc2lkZSB0aGUgdHJpYW5nbGUgaW4gYm90aCBkaXJlY3Rpb25zXG4gICAgd2hpbGUgKHAgJiYgcC56ID49IG1pblogJiYgbiAmJiBuLnogPD0gbWF4Wikge1xuICAgICAgICBpZiAocCAhPT0gZWFyLnByZXYgJiYgcCAhPT0gZWFyLm5leHQgJiZcbiAgICAgICAgICAgIHBvaW50SW5UcmlhbmdsZShhLngsIGEueSwgYi54LCBiLnksIGMueCwgYy55LCBwLngsIHAueSkgJiZcbiAgICAgICAgICAgIGFyZWEocC5wcmV2LCBwLCBwLm5leHQpID49IDApIHJldHVybiBmYWxzZTtcbiAgICAgICAgcCA9IHAucHJldlo7XG5cbiAgICAgICAgaWYgKG4gIT09IGVhci5wcmV2ICYmIG4gIT09IGVhci5uZXh0ICYmXG4gICAgICAgICAgICBwb2ludEluVHJpYW5nbGUoYS54LCBhLnksIGIueCwgYi55LCBjLngsIGMueSwgbi54LCBuLnkpICYmXG4gICAgICAgICAgICBhcmVhKG4ucHJldiwgbiwgbi5uZXh0KSA+PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIG4gPSBuLm5leHRaO1xuICAgIH1cblxuICAgIC8vIGxvb2sgZm9yIHJlbWFpbmluZyBwb2ludHMgaW4gZGVjcmVhc2luZyB6LW9yZGVyXG4gICAgd2hpbGUgKHAgJiYgcC56ID49IG1pblopIHtcbiAgICAgICAgaWYgKHAgIT09IGVhci5wcmV2ICYmIHAgIT09IGVhci5uZXh0ICYmXG4gICAgICAgICAgICBwb2ludEluVHJpYW5nbGUoYS54LCBhLnksIGIueCwgYi55LCBjLngsIGMueSwgcC54LCBwLnkpICYmXG4gICAgICAgICAgICBhcmVhKHAucHJldiwgcCwgcC5uZXh0KSA+PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHAgPSBwLnByZXZaO1xuICAgIH1cblxuICAgIC8vIGxvb2sgZm9yIHJlbWFpbmluZyBwb2ludHMgaW4gaW5jcmVhc2luZyB6LW9yZGVyXG4gICAgd2hpbGUgKG4gJiYgbi56IDw9IG1heFopIHtcbiAgICAgICAgaWYgKG4gIT09IGVhci5wcmV2ICYmIG4gIT09IGVhci5uZXh0ICYmXG4gICAgICAgICAgICBwb2ludEluVHJpYW5nbGUoYS54LCBhLnksIGIueCwgYi55LCBjLngsIGMueSwgbi54LCBuLnkpICYmXG4gICAgICAgICAgICBhcmVhKG4ucHJldiwgbiwgbi5uZXh0KSA+PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIG4gPSBuLm5leHRaO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufVxuXG4vLyBnbyB0aHJvdWdoIGFsbCBwb2x5Z29uIG5vZGVzIGFuZCBjdXJlIHNtYWxsIGxvY2FsIHNlbGYtaW50ZXJzZWN0aW9uc1xuZnVuY3Rpb24gY3VyZUxvY2FsSW50ZXJzZWN0aW9ucyhzdGFydCwgdHJpYW5nbGVzLCBkaW0pIHtcbiAgICB2YXIgcCA9IHN0YXJ0O1xuICAgIGRvIHtcbiAgICAgICAgdmFyIGEgPSBwLnByZXYsXG4gICAgICAgICAgICBiID0gcC5uZXh0Lm5leHQ7XG5cbiAgICAgICAgaWYgKCFlcXVhbHMoYSwgYikgJiYgaW50ZXJzZWN0cyhhLCBwLCBwLm5leHQsIGIpICYmIGxvY2FsbHlJbnNpZGUoYSwgYikgJiYgbG9jYWxseUluc2lkZShiLCBhKSkge1xuXG4gICAgICAgICAgICB0cmlhbmdsZXMucHVzaChhLmkgLyBkaW0pO1xuICAgICAgICAgICAgdHJpYW5nbGVzLnB1c2gocC5pIC8gZGltKTtcbiAgICAgICAgICAgIHRyaWFuZ2xlcy5wdXNoKGIuaSAvIGRpbSk7XG5cbiAgICAgICAgICAgIC8vIHJlbW92ZSB0d28gbm9kZXMgaW52b2x2ZWRcbiAgICAgICAgICAgIHJlbW92ZU5vZGUocCk7XG4gICAgICAgICAgICByZW1vdmVOb2RlKHAubmV4dCk7XG5cbiAgICAgICAgICAgIHAgPSBzdGFydCA9IGI7XG4gICAgICAgIH1cbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICB9IHdoaWxlIChwICE9PSBzdGFydCk7XG5cbiAgICByZXR1cm4gZmlsdGVyUG9pbnRzKHApO1xufVxuXG4vLyB0cnkgc3BsaXR0aW5nIHBvbHlnb24gaW50byB0d28gYW5kIHRyaWFuZ3VsYXRlIHRoZW0gaW5kZXBlbmRlbnRseVxuZnVuY3Rpb24gc3BsaXRFYXJjdXQoc3RhcnQsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplKSB7XG4gICAgLy8gbG9vayBmb3IgYSB2YWxpZCBkaWFnb25hbCB0aGF0IGRpdmlkZXMgdGhlIHBvbHlnb24gaW50byB0d29cbiAgICB2YXIgYSA9IHN0YXJ0O1xuICAgIGRvIHtcbiAgICAgICAgdmFyIGIgPSBhLm5leHQubmV4dDtcbiAgICAgICAgd2hpbGUgKGIgIT09IGEucHJldikge1xuICAgICAgICAgICAgaWYgKGEuaSAhPT0gYi5pICYmIGlzVmFsaWREaWFnb25hbChhLCBiKSkge1xuICAgICAgICAgICAgICAgIC8vIHNwbGl0IHRoZSBwb2x5Z29uIGluIHR3byBieSB0aGUgZGlhZ29uYWxcbiAgICAgICAgICAgICAgICB2YXIgYyA9IHNwbGl0UG9seWdvbihhLCBiKTtcblxuICAgICAgICAgICAgICAgIC8vIGZpbHRlciBjb2xpbmVhciBwb2ludHMgYXJvdW5kIHRoZSBjdXRzXG4gICAgICAgICAgICAgICAgYSA9IGZpbHRlclBvaW50cyhhLCBhLm5leHQpO1xuICAgICAgICAgICAgICAgIGMgPSBmaWx0ZXJQb2ludHMoYywgYy5uZXh0KTtcblxuICAgICAgICAgICAgICAgIC8vIHJ1biBlYXJjdXQgb24gZWFjaCBoYWxmXG4gICAgICAgICAgICAgICAgZWFyY3V0TGlua2VkKGEsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplKTtcbiAgICAgICAgICAgICAgICBlYXJjdXRMaW5rZWQoYywgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGIgPSBiLm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgYSA9IGEubmV4dDtcbiAgICB9IHdoaWxlIChhICE9PSBzdGFydCk7XG59XG5cbi8vIGxpbmsgZXZlcnkgaG9sZSBpbnRvIHRoZSBvdXRlciBsb29wLCBwcm9kdWNpbmcgYSBzaW5nbGUtcmluZyBwb2x5Z29uIHdpdGhvdXQgaG9sZXNcbmZ1bmN0aW9uIGVsaW1pbmF0ZUhvbGVzKGRhdGEsIGhvbGVJbmRpY2VzLCBvdXRlck5vZGUsIGRpbSkge1xuICAgIHZhciBxdWV1ZSA9IFtdLFxuICAgICAgICBpLCBsZW4sIHN0YXJ0LCBlbmQsIGxpc3Q7XG5cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBob2xlSW5kaWNlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBzdGFydCA9IGhvbGVJbmRpY2VzW2ldICogZGltO1xuICAgICAgICBlbmQgPSBpIDwgbGVuIC0gMSA/IGhvbGVJbmRpY2VzW2kgKyAxXSAqIGRpbSA6IGRhdGEubGVuZ3RoO1xuICAgICAgICBsaXN0ID0gbGlua2VkTGlzdChkYXRhLCBzdGFydCwgZW5kLCBkaW0sIGZhbHNlKTtcbiAgICAgICAgaWYgKGxpc3QgPT09IGxpc3QubmV4dCkgbGlzdC5zdGVpbmVyID0gdHJ1ZTtcbiAgICAgICAgcXVldWUucHVzaChnZXRMZWZ0bW9zdChsaXN0KSk7XG4gICAgfVxuXG4gICAgcXVldWUuc29ydChjb21wYXJlWCk7XG5cbiAgICAvLyBwcm9jZXNzIGhvbGVzIGZyb20gbGVmdCB0byByaWdodFxuICAgIGZvciAoaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBlbGltaW5hdGVIb2xlKHF1ZXVlW2ldLCBvdXRlck5vZGUpO1xuICAgICAgICBvdXRlck5vZGUgPSBmaWx0ZXJQb2ludHMob3V0ZXJOb2RlLCBvdXRlck5vZGUubmV4dCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dGVyTm9kZTtcbn1cblxuZnVuY3Rpb24gY29tcGFyZVgoYSwgYikge1xuICAgIHJldHVybiBhLnggLSBiLng7XG59XG5cbi8vIGZpbmQgYSBicmlkZ2UgYmV0d2VlbiB2ZXJ0aWNlcyB0aGF0IGNvbm5lY3RzIGhvbGUgd2l0aCBhbiBvdXRlciByaW5nIGFuZCBhbmQgbGluayBpdFxuZnVuY3Rpb24gZWxpbWluYXRlSG9sZShob2xlLCBvdXRlck5vZGUpIHtcbiAgICBvdXRlck5vZGUgPSBmaW5kSG9sZUJyaWRnZShob2xlLCBvdXRlck5vZGUpO1xuICAgIGlmIChvdXRlck5vZGUpIHtcbiAgICAgICAgdmFyIGIgPSBzcGxpdFBvbHlnb24ob3V0ZXJOb2RlLCBob2xlKTtcbiAgICAgICAgZmlsdGVyUG9pbnRzKGIsIGIubmV4dCk7XG4gICAgfVxufVxuXG4vLyBEYXZpZCBFYmVybHkncyBhbGdvcml0aG0gZm9yIGZpbmRpbmcgYSBicmlkZ2UgYmV0d2VlbiBob2xlIGFuZCBvdXRlciBwb2x5Z29uXG5mdW5jdGlvbiBmaW5kSG9sZUJyaWRnZShob2xlLCBvdXRlck5vZGUpIHtcbiAgICB2YXIgcCA9IG91dGVyTm9kZSxcbiAgICAgICAgaHggPSBob2xlLngsXG4gICAgICAgIGh5ID0gaG9sZS55LFxuICAgICAgICBxeCA9IC1JbmZpbml0eSxcbiAgICAgICAgbTtcblxuICAgIC8vIGZpbmQgYSBzZWdtZW50IGludGVyc2VjdGVkIGJ5IGEgcmF5IGZyb20gdGhlIGhvbGUncyBsZWZ0bW9zdCBwb2ludCB0byB0aGUgbGVmdDtcbiAgICAvLyBzZWdtZW50J3MgZW5kcG9pbnQgd2l0aCBsZXNzZXIgeCB3aWxsIGJlIHBvdGVudGlhbCBjb25uZWN0aW9uIHBvaW50XG4gICAgZG8ge1xuICAgICAgICBpZiAoaHkgPD0gcC55ICYmIGh5ID49IHAubmV4dC55ICYmIHAubmV4dC55ICE9PSBwLnkpIHtcbiAgICAgICAgICAgIHZhciB4ID0gcC54ICsgKGh5IC0gcC55KSAqIChwLm5leHQueCAtIHAueCkgLyAocC5uZXh0LnkgLSBwLnkpO1xuICAgICAgICAgICAgaWYgKHggPD0gaHggJiYgeCA+IHF4KSB7XG4gICAgICAgICAgICAgICAgcXggPSB4O1xuICAgICAgICAgICAgICAgIGlmICh4ID09PSBoeCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaHkgPT09IHAueSkgcmV0dXJuIHA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoeSA9PT0gcC5uZXh0LnkpIHJldHVybiBwLm5leHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG0gPSBwLnggPCBwLm5leHQueCA/IHAgOiBwLm5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICB9IHdoaWxlIChwICE9PSBvdXRlck5vZGUpO1xuXG4gICAgaWYgKCFtKSByZXR1cm4gbnVsbDtcblxuICAgIGlmIChoeCA9PT0gcXgpIHJldHVybiBtOyAvLyBob2xlIHRvdWNoZXMgb3V0ZXIgc2VnbWVudDsgcGljayBsZWZ0bW9zdCBlbmRwb2ludFxuXG4gICAgLy8gbG9vayBmb3IgcG9pbnRzIGluc2lkZSB0aGUgdHJpYW5nbGUgb2YgaG9sZSBwb2ludCwgc2VnbWVudCBpbnRlcnNlY3Rpb24gYW5kIGVuZHBvaW50O1xuICAgIC8vIGlmIHRoZXJlIGFyZSBubyBwb2ludHMgZm91bmQsIHdlIGhhdmUgYSB2YWxpZCBjb25uZWN0aW9uO1xuICAgIC8vIG90aGVyd2lzZSBjaG9vc2UgdGhlIHBvaW50IG9mIHRoZSBtaW5pbXVtIGFuZ2xlIHdpdGggdGhlIHJheSBhcyBjb25uZWN0aW9uIHBvaW50XG5cbiAgICB2YXIgc3RvcCA9IG0sXG4gICAgICAgIG14ID0gbS54LFxuICAgICAgICBteSA9IG0ueSxcbiAgICAgICAgdGFuTWluID0gSW5maW5pdHksXG4gICAgICAgIHRhbjtcblxuICAgIHAgPSBtO1xuXG4gICAgZG8ge1xuICAgICAgICBpZiAoaHggPj0gcC54ICYmIHAueCA+PSBteCAmJiBoeCAhPT0gcC54ICYmXG4gICAgICAgICAgICAgICAgcG9pbnRJblRyaWFuZ2xlKGh5IDwgbXkgPyBoeCA6IHF4LCBoeSwgbXgsIG15LCBoeSA8IG15ID8gcXggOiBoeCwgaHksIHAueCwgcC55KSkge1xuXG4gICAgICAgICAgICB0YW4gPSBNYXRoLmFicyhoeSAtIHAueSkgLyAoaHggLSBwLngpOyAvLyB0YW5nZW50aWFsXG5cbiAgICAgICAgICAgIGlmIChsb2NhbGx5SW5zaWRlKHAsIGhvbGUpICYmXG4gICAgICAgICAgICAgICAgKHRhbiA8IHRhbk1pbiB8fCAodGFuID09PSB0YW5NaW4gJiYgKHAueCA+IG0ueCB8fCAocC54ID09PSBtLnggJiYgc2VjdG9yQ29udGFpbnNTZWN0b3IobSwgcCkpKSkpKSB7XG4gICAgICAgICAgICAgICAgbSA9IHA7XG4gICAgICAgICAgICAgICAgdGFuTWluID0gdGFuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICB9IHdoaWxlIChwICE9PSBzdG9wKTtcblxuICAgIHJldHVybiBtO1xufVxuXG4vLyB3aGV0aGVyIHNlY3RvciBpbiB2ZXJ0ZXggbSBjb250YWlucyBzZWN0b3IgaW4gdmVydGV4IHAgaW4gdGhlIHNhbWUgY29vcmRpbmF0ZXNcbmZ1bmN0aW9uIHNlY3RvckNvbnRhaW5zU2VjdG9yKG0sIHApIHtcbiAgICByZXR1cm4gYXJlYShtLnByZXYsIG0sIHAucHJldikgPCAwICYmIGFyZWEocC5uZXh0LCBtLCBtLm5leHQpIDwgMDtcbn1cblxuLy8gaW50ZXJsaW5rIHBvbHlnb24gbm9kZXMgaW4gei1vcmRlclxuZnVuY3Rpb24gaW5kZXhDdXJ2ZShzdGFydCwgbWluWCwgbWluWSwgaW52U2l6ZSkge1xuICAgIHZhciBwID0gc3RhcnQ7XG4gICAgZG8ge1xuICAgICAgICBpZiAocC56ID09PSBudWxsKSBwLnogPSB6T3JkZXIocC54LCBwLnksIG1pblgsIG1pblksIGludlNpemUpO1xuICAgICAgICBwLnByZXZaID0gcC5wcmV2O1xuICAgICAgICBwLm5leHRaID0gcC5uZXh0O1xuICAgICAgICBwID0gcC5uZXh0O1xuICAgIH0gd2hpbGUgKHAgIT09IHN0YXJ0KTtcblxuICAgIHAucHJldloubmV4dFogPSBudWxsO1xuICAgIHAucHJldlogPSBudWxsO1xuXG4gICAgc29ydExpbmtlZChwKTtcbn1cblxuLy8gU2ltb24gVGF0aGFtJ3MgbGlua2VkIGxpc3QgbWVyZ2Ugc29ydCBhbGdvcml0aG1cbi8vIGh0dHA6Ly93d3cuY2hpYXJrLmdyZWVuZW5kLm9yZy51ay9+c2d0YXRoYW0vYWxnb3JpdGhtcy9saXN0c29ydC5odG1sXG5mdW5jdGlvbiBzb3J0TGlua2VkKGxpc3QpIHtcbiAgICB2YXIgaSwgcCwgcSwgZSwgdGFpbCwgbnVtTWVyZ2VzLCBwU2l6ZSwgcVNpemUsXG4gICAgICAgIGluU2l6ZSA9IDE7XG5cbiAgICBkbyB7XG4gICAgICAgIHAgPSBsaXN0O1xuICAgICAgICBsaXN0ID0gbnVsbDtcbiAgICAgICAgdGFpbCA9IG51bGw7XG4gICAgICAgIG51bU1lcmdlcyA9IDA7XG5cbiAgICAgICAgd2hpbGUgKHApIHtcbiAgICAgICAgICAgIG51bU1lcmdlcysrO1xuICAgICAgICAgICAgcSA9IHA7XG4gICAgICAgICAgICBwU2l6ZSA9IDA7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaW5TaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICBwU2l6ZSsrO1xuICAgICAgICAgICAgICAgIHEgPSBxLm5leHRaO1xuICAgICAgICAgICAgICAgIGlmICghcSkgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBxU2l6ZSA9IGluU2l6ZTtcblxuICAgICAgICAgICAgd2hpbGUgKHBTaXplID4gMCB8fCAocVNpemUgPiAwICYmIHEpKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAocFNpemUgIT09IDAgJiYgKHFTaXplID09PSAwIHx8ICFxIHx8IHAueiA8PSBxLnopKSB7XG4gICAgICAgICAgICAgICAgICAgIGUgPSBwO1xuICAgICAgICAgICAgICAgICAgICBwID0gcC5uZXh0WjtcbiAgICAgICAgICAgICAgICAgICAgcFNpemUtLTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlID0gcTtcbiAgICAgICAgICAgICAgICAgICAgcSA9IHEubmV4dFo7XG4gICAgICAgICAgICAgICAgICAgIHFTaXplLS07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRhaWwpIHRhaWwubmV4dFogPSBlO1xuICAgICAgICAgICAgICAgIGVsc2UgbGlzdCA9IGU7XG5cbiAgICAgICAgICAgICAgICBlLnByZXZaID0gdGFpbDtcbiAgICAgICAgICAgICAgICB0YWlsID0gZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcCA9IHE7XG4gICAgICAgIH1cblxuICAgICAgICB0YWlsLm5leHRaID0gbnVsbDtcbiAgICAgICAgaW5TaXplICo9IDI7XG5cbiAgICB9IHdoaWxlIChudW1NZXJnZXMgPiAxKTtcblxuICAgIHJldHVybiBsaXN0O1xufVxuXG4vLyB6LW9yZGVyIG9mIGEgcG9pbnQgZ2l2ZW4gY29vcmRzIGFuZCBpbnZlcnNlIG9mIHRoZSBsb25nZXIgc2lkZSBvZiBkYXRhIGJib3hcbmZ1bmN0aW9uIHpPcmRlcih4LCB5LCBtaW5YLCBtaW5ZLCBpbnZTaXplKSB7XG4gICAgLy8gY29vcmRzIGFyZSB0cmFuc2Zvcm1lZCBpbnRvIG5vbi1uZWdhdGl2ZSAxNS1iaXQgaW50ZWdlciByYW5nZVxuICAgIHggPSAzMjc2NyAqICh4IC0gbWluWCkgKiBpbnZTaXplO1xuICAgIHkgPSAzMjc2NyAqICh5IC0gbWluWSkgKiBpbnZTaXplO1xuXG4gICAgeCA9ICh4IHwgKHggPDwgOCkpICYgMHgwMEZGMDBGRjtcbiAgICB4ID0gKHggfCAoeCA8PCA0KSkgJiAweDBGMEYwRjBGO1xuICAgIHggPSAoeCB8ICh4IDw8IDIpKSAmIDB4MzMzMzMzMzM7XG4gICAgeCA9ICh4IHwgKHggPDwgMSkpICYgMHg1NTU1NTU1NTtcblxuICAgIHkgPSAoeSB8ICh5IDw8IDgpKSAmIDB4MDBGRjAwRkY7XG4gICAgeSA9ICh5IHwgKHkgPDwgNCkpICYgMHgwRjBGMEYwRjtcbiAgICB5ID0gKHkgfCAoeSA8PCAyKSkgJiAweDMzMzMzMzMzO1xuICAgIHkgPSAoeSB8ICh5IDw8IDEpKSAmIDB4NTU1NTU1NTU7XG5cbiAgICByZXR1cm4geCB8ICh5IDw8IDEpO1xufVxuXG4vLyBmaW5kIHRoZSBsZWZ0bW9zdCBub2RlIG9mIGEgcG9seWdvbiByaW5nXG5mdW5jdGlvbiBnZXRMZWZ0bW9zdChzdGFydCkge1xuICAgIHZhciBwID0gc3RhcnQsXG4gICAgICAgIGxlZnRtb3N0ID0gc3RhcnQ7XG4gICAgZG8ge1xuICAgICAgICBpZiAocC54IDwgbGVmdG1vc3QueCB8fCAocC54ID09PSBsZWZ0bW9zdC54ICYmIHAueSA8IGxlZnRtb3N0LnkpKSBsZWZ0bW9zdCA9IHA7XG4gICAgICAgIHAgPSBwLm5leHQ7XG4gICAgfSB3aGlsZSAocCAhPT0gc3RhcnQpO1xuXG4gICAgcmV0dXJuIGxlZnRtb3N0O1xufVxuXG4vLyBjaGVjayBpZiBhIHBvaW50IGxpZXMgd2l0aGluIGEgY29udmV4IHRyaWFuZ2xlXG5mdW5jdGlvbiBwb2ludEluVHJpYW5nbGUoYXgsIGF5LCBieCwgYnksIGN4LCBjeSwgcHgsIHB5KSB7XG4gICAgcmV0dXJuIChjeCAtIHB4KSAqIChheSAtIHB5KSAtIChheCAtIHB4KSAqIChjeSAtIHB5KSA+PSAwICYmXG4gICAgICAgICAgIChheCAtIHB4KSAqIChieSAtIHB5KSAtIChieCAtIHB4KSAqIChheSAtIHB5KSA+PSAwICYmXG4gICAgICAgICAgIChieCAtIHB4KSAqIChjeSAtIHB5KSAtIChjeCAtIHB4KSAqIChieSAtIHB5KSA+PSAwO1xufVxuXG4vLyBjaGVjayBpZiBhIGRpYWdvbmFsIGJldHdlZW4gdHdvIHBvbHlnb24gbm9kZXMgaXMgdmFsaWQgKGxpZXMgaW4gcG9seWdvbiBpbnRlcmlvcilcbmZ1bmN0aW9uIGlzVmFsaWREaWFnb25hbChhLCBiKSB7XG4gICAgcmV0dXJuIGEubmV4dC5pICE9PSBiLmkgJiYgYS5wcmV2LmkgIT09IGIuaSAmJiAhaW50ZXJzZWN0c1BvbHlnb24oYSwgYikgJiYgLy8gZG9uZXMndCBpbnRlcnNlY3Qgb3RoZXIgZWRnZXNcbiAgICAgICAgICAgKGxvY2FsbHlJbnNpZGUoYSwgYikgJiYgbG9jYWxseUluc2lkZShiLCBhKSAmJiBtaWRkbGVJbnNpZGUoYSwgYikgJiYgLy8gbG9jYWxseSB2aXNpYmxlXG4gICAgICAgICAgICAoYXJlYShhLnByZXYsIGEsIGIucHJldikgfHwgYXJlYShhLCBiLnByZXYsIGIpKSB8fCAvLyBkb2VzIG5vdCBjcmVhdGUgb3Bwb3NpdGUtZmFjaW5nIHNlY3RvcnNcbiAgICAgICAgICAgIGVxdWFscyhhLCBiKSAmJiBhcmVhKGEucHJldiwgYSwgYS5uZXh0KSA+IDAgJiYgYXJlYShiLnByZXYsIGIsIGIubmV4dCkgPiAwKTsgLy8gc3BlY2lhbCB6ZXJvLWxlbmd0aCBjYXNlXG59XG5cbi8vIHNpZ25lZCBhcmVhIG9mIGEgdHJpYW5nbGVcbmZ1bmN0aW9uIGFyZWEocCwgcSwgcikge1xuICAgIHJldHVybiAocS55IC0gcC55KSAqIChyLnggLSBxLngpIC0gKHEueCAtIHAueCkgKiAoci55IC0gcS55KTtcbn1cblxuLy8gY2hlY2sgaWYgdHdvIHBvaW50cyBhcmUgZXF1YWxcbmZ1bmN0aW9uIGVxdWFscyhwMSwgcDIpIHtcbiAgICByZXR1cm4gcDEueCA9PT0gcDIueCAmJiBwMS55ID09PSBwMi55O1xufVxuXG4vLyBjaGVjayBpZiB0d28gc2VnbWVudHMgaW50ZXJzZWN0XG5mdW5jdGlvbiBpbnRlcnNlY3RzKHAxLCBxMSwgcDIsIHEyKSB7XG4gICAgdmFyIG8xID0gc2lnbihhcmVhKHAxLCBxMSwgcDIpKTtcbiAgICB2YXIgbzIgPSBzaWduKGFyZWEocDEsIHExLCBxMikpO1xuICAgIHZhciBvMyA9IHNpZ24oYXJlYShwMiwgcTIsIHAxKSk7XG4gICAgdmFyIG80ID0gc2lnbihhcmVhKHAyLCBxMiwgcTEpKTtcblxuICAgIGlmIChvMSAhPT0gbzIgJiYgbzMgIT09IG80KSByZXR1cm4gdHJ1ZTsgLy8gZ2VuZXJhbCBjYXNlXG5cbiAgICBpZiAobzEgPT09IDAgJiYgb25TZWdtZW50KHAxLCBwMiwgcTEpKSByZXR1cm4gdHJ1ZTsgLy8gcDEsIHExIGFuZCBwMiBhcmUgY29sbGluZWFyIGFuZCBwMiBsaWVzIG9uIHAxcTFcbiAgICBpZiAobzIgPT09IDAgJiYgb25TZWdtZW50KHAxLCBxMiwgcTEpKSByZXR1cm4gdHJ1ZTsgLy8gcDEsIHExIGFuZCBxMiBhcmUgY29sbGluZWFyIGFuZCBxMiBsaWVzIG9uIHAxcTFcbiAgICBpZiAobzMgPT09IDAgJiYgb25TZWdtZW50KHAyLCBwMSwgcTIpKSByZXR1cm4gdHJ1ZTsgLy8gcDIsIHEyIGFuZCBwMSBhcmUgY29sbGluZWFyIGFuZCBwMSBsaWVzIG9uIHAycTJcbiAgICBpZiAobzQgPT09IDAgJiYgb25TZWdtZW50KHAyLCBxMSwgcTIpKSByZXR1cm4gdHJ1ZTsgLy8gcDIsIHEyIGFuZCBxMSBhcmUgY29sbGluZWFyIGFuZCBxMSBsaWVzIG9uIHAycTJcblxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLy8gZm9yIGNvbGxpbmVhciBwb2ludHMgcCwgcSwgciwgY2hlY2sgaWYgcG9pbnQgcSBsaWVzIG9uIHNlZ21lbnQgcHJcbmZ1bmN0aW9uIG9uU2VnbWVudChwLCBxLCByKSB7XG4gICAgcmV0dXJuIHEueCA8PSBNYXRoLm1heChwLngsIHIueCkgJiYgcS54ID49IE1hdGgubWluKHAueCwgci54KSAmJiBxLnkgPD0gTWF0aC5tYXgocC55LCByLnkpICYmIHEueSA+PSBNYXRoLm1pbihwLnksIHIueSk7XG59XG5cbmZ1bmN0aW9uIHNpZ24obnVtKSB7XG4gICAgcmV0dXJuIG51bSA+IDAgPyAxIDogbnVtIDwgMCA/IC0xIDogMDtcbn1cblxuLy8gY2hlY2sgaWYgYSBwb2x5Z29uIGRpYWdvbmFsIGludGVyc2VjdHMgYW55IHBvbHlnb24gc2VnbWVudHNcbmZ1bmN0aW9uIGludGVyc2VjdHNQb2x5Z29uKGEsIGIpIHtcbiAgICB2YXIgcCA9IGE7XG4gICAgZG8ge1xuICAgICAgICBpZiAocC5pICE9PSBhLmkgJiYgcC5uZXh0LmkgIT09IGEuaSAmJiBwLmkgIT09IGIuaSAmJiBwLm5leHQuaSAhPT0gYi5pICYmXG4gICAgICAgICAgICAgICAgaW50ZXJzZWN0cyhwLCBwLm5leHQsIGEsIGIpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICB9IHdoaWxlIChwICE9PSBhKTtcblxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLy8gY2hlY2sgaWYgYSBwb2x5Z29uIGRpYWdvbmFsIGlzIGxvY2FsbHkgaW5zaWRlIHRoZSBwb2x5Z29uXG5mdW5jdGlvbiBsb2NhbGx5SW5zaWRlKGEsIGIpIHtcbiAgICByZXR1cm4gYXJlYShhLnByZXYsIGEsIGEubmV4dCkgPCAwID9cbiAgICAgICAgYXJlYShhLCBiLCBhLm5leHQpID49IDAgJiYgYXJlYShhLCBhLnByZXYsIGIpID49IDAgOlxuICAgICAgICBhcmVhKGEsIGIsIGEucHJldikgPCAwIHx8IGFyZWEoYSwgYS5uZXh0LCBiKSA8IDA7XG59XG5cbi8vIGNoZWNrIGlmIHRoZSBtaWRkbGUgcG9pbnQgb2YgYSBwb2x5Z29uIGRpYWdvbmFsIGlzIGluc2lkZSB0aGUgcG9seWdvblxuZnVuY3Rpb24gbWlkZGxlSW5zaWRlKGEsIGIpIHtcbiAgICB2YXIgcCA9IGEsXG4gICAgICAgIGluc2lkZSA9IGZhbHNlLFxuICAgICAgICBweCA9IChhLnggKyBiLngpIC8gMixcbiAgICAgICAgcHkgPSAoYS55ICsgYi55KSAvIDI7XG4gICAgZG8ge1xuICAgICAgICBpZiAoKChwLnkgPiBweSkgIT09IChwLm5leHQueSA+IHB5KSkgJiYgcC5uZXh0LnkgIT09IHAueSAmJlxuICAgICAgICAgICAgICAgIChweCA8IChwLm5leHQueCAtIHAueCkgKiAocHkgLSBwLnkpIC8gKHAubmV4dC55IC0gcC55KSArIHAueCkpXG4gICAgICAgICAgICBpbnNpZGUgPSAhaW5zaWRlO1xuICAgICAgICBwID0gcC5uZXh0O1xuICAgIH0gd2hpbGUgKHAgIT09IGEpO1xuXG4gICAgcmV0dXJuIGluc2lkZTtcbn1cblxuLy8gbGluayB0d28gcG9seWdvbiB2ZXJ0aWNlcyB3aXRoIGEgYnJpZGdlOyBpZiB0aGUgdmVydGljZXMgYmVsb25nIHRvIHRoZSBzYW1lIHJpbmcsIGl0IHNwbGl0cyBwb2x5Z29uIGludG8gdHdvO1xuLy8gaWYgb25lIGJlbG9uZ3MgdG8gdGhlIG91dGVyIHJpbmcgYW5kIGFub3RoZXIgdG8gYSBob2xlLCBpdCBtZXJnZXMgaXQgaW50byBhIHNpbmdsZSByaW5nXG5mdW5jdGlvbiBzcGxpdFBvbHlnb24oYSwgYikge1xuICAgIHZhciBhMiA9IG5ldyBOb2RlKGEuaSwgYS54LCBhLnkpLFxuICAgICAgICBiMiA9IG5ldyBOb2RlKGIuaSwgYi54LCBiLnkpLFxuICAgICAgICBhbiA9IGEubmV4dCxcbiAgICAgICAgYnAgPSBiLnByZXY7XG5cbiAgICBhLm5leHQgPSBiO1xuICAgIGIucHJldiA9IGE7XG5cbiAgICBhMi5uZXh0ID0gYW47XG4gICAgYW4ucHJldiA9IGEyO1xuXG4gICAgYjIubmV4dCA9IGEyO1xuICAgIGEyLnByZXYgPSBiMjtcblxuICAgIGJwLm5leHQgPSBiMjtcbiAgICBiMi5wcmV2ID0gYnA7XG5cbiAgICByZXR1cm4gYjI7XG59XG5cbi8vIGNyZWF0ZSBhIG5vZGUgYW5kIG9wdGlvbmFsbHkgbGluayBpdCB3aXRoIHByZXZpb3VzIG9uZSAoaW4gYSBjaXJjdWxhciBkb3VibHkgbGlua2VkIGxpc3QpXG5mdW5jdGlvbiBpbnNlcnROb2RlKGksIHgsIHksIGxhc3QpIHtcbiAgICB2YXIgcCA9IG5ldyBOb2RlKGksIHgsIHkpO1xuXG4gICAgaWYgKCFsYXN0KSB7XG4gICAgICAgIHAucHJldiA9IHA7XG4gICAgICAgIHAubmV4dCA9IHA7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICBwLm5leHQgPSBsYXN0Lm5leHQ7XG4gICAgICAgIHAucHJldiA9IGxhc3Q7XG4gICAgICAgIGxhc3QubmV4dC5wcmV2ID0gcDtcbiAgICAgICAgbGFzdC5uZXh0ID0gcDtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZU5vZGUocCkge1xuICAgIHAubmV4dC5wcmV2ID0gcC5wcmV2O1xuICAgIHAucHJldi5uZXh0ID0gcC5uZXh0O1xuXG4gICAgaWYgKHAucHJldlopIHAucHJldloubmV4dFogPSBwLm5leHRaO1xuICAgIGlmIChwLm5leHRaKSBwLm5leHRaLnByZXZaID0gcC5wcmV2Wjtcbn1cblxuZnVuY3Rpb24gTm9kZShpLCB4LCB5KSB7XG4gICAgLy8gdmVydGV4IGluZGV4IGluIGNvb3JkaW5hdGVzIGFycmF5XG4gICAgdGhpcy5pID0gaTtcblxuICAgIC8vIHZlcnRleCBjb29yZGluYXRlc1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcblxuICAgIC8vIHByZXZpb3VzIGFuZCBuZXh0IHZlcnRleCBub2RlcyBpbiBhIHBvbHlnb24gcmluZ1xuICAgIHRoaXMucHJldiA9IG51bGw7XG4gICAgdGhpcy5uZXh0ID0gbnVsbDtcblxuICAgIC8vIHotb3JkZXIgY3VydmUgdmFsdWVcbiAgICB0aGlzLnogPSBudWxsO1xuXG4gICAgLy8gcHJldmlvdXMgYW5kIG5leHQgbm9kZXMgaW4gei1vcmRlclxuICAgIHRoaXMucHJldlogPSBudWxsO1xuICAgIHRoaXMubmV4dFogPSBudWxsO1xuXG4gICAgLy8gaW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBpcyBhIHN0ZWluZXIgcG9pbnRcbiAgICB0aGlzLnN0ZWluZXIgPSBmYWxzZTtcbn1cblxuLy8gcmV0dXJuIGEgcGVyY2VudGFnZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIHBvbHlnb24gYXJlYSBhbmQgaXRzIHRyaWFuZ3VsYXRpb24gYXJlYTtcbi8vIHVzZWQgdG8gdmVyaWZ5IGNvcnJlY3RuZXNzIG9mIHRyaWFuZ3VsYXRpb25cbmVhcmN1dC5kZXZpYXRpb24gPSBmdW5jdGlvbiAoZGF0YSwgaG9sZUluZGljZXMsIGRpbSwgdHJpYW5nbGVzKSB7XG4gICAgdmFyIGhhc0hvbGVzID0gaG9sZUluZGljZXMgJiYgaG9sZUluZGljZXMubGVuZ3RoO1xuICAgIHZhciBvdXRlckxlbiA9IGhhc0hvbGVzID8gaG9sZUluZGljZXNbMF0gKiBkaW0gOiBkYXRhLmxlbmd0aDtcblxuICAgIHZhciBwb2x5Z29uQXJlYSA9IE1hdGguYWJzKHNpZ25lZEFyZWEoZGF0YSwgMCwgb3V0ZXJMZW4sIGRpbSkpO1xuICAgIGlmIChoYXNIb2xlcykge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gaG9sZUluZGljZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IGhvbGVJbmRpY2VzW2ldICogZGltO1xuICAgICAgICAgICAgdmFyIGVuZCA9IGkgPCBsZW4gLSAxID8gaG9sZUluZGljZXNbaSArIDFdICogZGltIDogZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICBwb2x5Z29uQXJlYSAtPSBNYXRoLmFicyhzaWduZWRBcmVhKGRhdGEsIHN0YXJ0LCBlbmQsIGRpbSkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHRyaWFuZ2xlc0FyZWEgPSAwO1xuICAgIGZvciAoaSA9IDA7IGkgPCB0cmlhbmdsZXMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgdmFyIGEgPSB0cmlhbmdsZXNbaV0gKiBkaW07XG4gICAgICAgIHZhciBiID0gdHJpYW5nbGVzW2kgKyAxXSAqIGRpbTtcbiAgICAgICAgdmFyIGMgPSB0cmlhbmdsZXNbaSArIDJdICogZGltO1xuICAgICAgICB0cmlhbmdsZXNBcmVhICs9IE1hdGguYWJzKFxuICAgICAgICAgICAgKGRhdGFbYV0gLSBkYXRhW2NdKSAqIChkYXRhW2IgKyAxXSAtIGRhdGFbYSArIDFdKSAtXG4gICAgICAgICAgICAoZGF0YVthXSAtIGRhdGFbYl0pICogKGRhdGFbYyArIDFdIC0gZGF0YVthICsgMV0pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcG9seWdvbkFyZWEgPT09IDAgJiYgdHJpYW5nbGVzQXJlYSA9PT0gMCA/IDAgOlxuICAgICAgICBNYXRoLmFicygodHJpYW5nbGVzQXJlYSAtIHBvbHlnb25BcmVhKSAvIHBvbHlnb25BcmVhKTtcbn07XG5cbmZ1bmN0aW9uIHNpZ25lZEFyZWEoZGF0YSwgc3RhcnQsIGVuZCwgZGltKSB7XG4gICAgdmFyIHN1bSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0LCBqID0gZW5kIC0gZGltOyBpIDwgZW5kOyBpICs9IGRpbSkge1xuICAgICAgICBzdW0gKz0gKGRhdGFbal0gLSBkYXRhW2ldKSAqIChkYXRhW2kgKyAxXSArIGRhdGFbaiArIDFdKTtcbiAgICAgICAgaiA9IGk7XG4gICAgfVxuICAgIHJldHVybiBzdW07XG59XG5cbi8vIHR1cm4gYSBwb2x5Z29uIGluIGEgbXVsdGktZGltZW5zaW9uYWwgYXJyYXkgZm9ybSAoZS5nLiBhcyBpbiBHZW9KU09OKSBpbnRvIGEgZm9ybSBFYXJjdXQgYWNjZXB0c1xuZWFyY3V0LmZsYXR0ZW4gPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBkaW0gPSBkYXRhWzBdWzBdLmxlbmd0aCxcbiAgICAgICAgcmVzdWx0ID0ge3ZlcnRpY2VzOiBbXSwgaG9sZXM6IFtdLCBkaW1lbnNpb25zOiBkaW19LFxuICAgICAgICBob2xlSW5kZXggPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZGF0YVtpXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgZm9yICh2YXIgZCA9IDA7IGQgPCBkaW07IGQrKykgcmVzdWx0LnZlcnRpY2VzLnB1c2goZGF0YVtpXVtqXVtkXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICBob2xlSW5kZXggKz0gZGF0YVtpIC0gMV0ubGVuZ3RoO1xuICAgICAgICAgICAgcmVzdWx0LmhvbGVzLnB1c2goaG9sZUluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHlcbiAgLCBwcmVmaXggPSAnfic7XG5cbi8qKlxuICogQ29uc3RydWN0b3IgdG8gY3JlYXRlIGEgc3RvcmFnZSBmb3Igb3VyIGBFRWAgb2JqZWN0cy5cbiAqIEFuIGBFdmVudHNgIGluc3RhbmNlIGlzIGEgcGxhaW4gb2JqZWN0IHdob3NlIHByb3BlcnRpZXMgYXJlIGV2ZW50IG5hbWVzLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIEV2ZW50cygpIHt9XG5cbi8vXG4vLyBXZSB0cnkgdG8gbm90IGluaGVyaXQgZnJvbSBgT2JqZWN0LnByb3RvdHlwZWAuIEluIHNvbWUgZW5naW5lcyBjcmVhdGluZyBhblxuLy8gaW5zdGFuY2UgaW4gdGhpcyB3YXkgaXMgZmFzdGVyIHRoYW4gY2FsbGluZyBgT2JqZWN0LmNyZWF0ZShudWxsKWAgZGlyZWN0bHkuXG4vLyBJZiBgT2JqZWN0LmNyZWF0ZShudWxsKWAgaXMgbm90IHN1cHBvcnRlZCB3ZSBwcmVmaXggdGhlIGV2ZW50IG5hbWVzIHdpdGggYVxuLy8gY2hhcmFjdGVyIHRvIG1ha2Ugc3VyZSB0aGF0IHRoZSBidWlsdC1pbiBvYmplY3QgcHJvcGVydGllcyBhcmUgbm90XG4vLyBvdmVycmlkZGVuIG9yIHVzZWQgYXMgYW4gYXR0YWNrIHZlY3Rvci5cbi8vXG5pZiAoT2JqZWN0LmNyZWF0ZSkge1xuICBFdmVudHMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAvL1xuICAvLyBUaGlzIGhhY2sgaXMgbmVlZGVkIGJlY2F1c2UgdGhlIGBfX3Byb3RvX19gIHByb3BlcnR5IGlzIHN0aWxsIGluaGVyaXRlZCBpblxuICAvLyBzb21lIG9sZCBicm93c2VycyBsaWtlIEFuZHJvaWQgNCwgaVBob25lIDUuMSwgT3BlcmEgMTEgYW5kIFNhZmFyaSA1LlxuICAvL1xuICBpZiAoIW5ldyBFdmVudHMoKS5fX3Byb3RvX18pIHByZWZpeCA9IGZhbHNlO1xufVxuXG4vKipcbiAqIFJlcHJlc2VudGF0aW9uIG9mIGEgc2luZ2xlIGV2ZW50IGxpc3RlbmVyLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7TWl4ZWR9IGNvbnRleHQgVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHBhcmFtIHtCb29sZWFufSBbb25jZT1mYWxzZV0gU3BlY2lmeSBpZiB0aGUgbGlzdGVuZXIgaXMgYSBvbmUtdGltZSBsaXN0ZW5lci5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIEVFKGZuLCBjb250ZXh0LCBvbmNlKSB7XG4gIHRoaXMuZm4gPSBmbjtcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5vbmNlID0gb25jZSB8fCBmYWxzZTtcbn1cblxuLyoqXG4gKiBNaW5pbWFsIGBFdmVudEVtaXR0ZXJgIGludGVyZmFjZSB0aGF0IGlzIG1vbGRlZCBhZ2FpbnN0IHRoZSBOb2RlLmpzXG4gKiBgRXZlbnRFbWl0dGVyYCBpbnRlcmZhY2UuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcbiAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xufVxuXG4vKipcbiAqIFJldHVybiBhbiBhcnJheSBsaXN0aW5nIHRoZSBldmVudHMgZm9yIHdoaWNoIHRoZSBlbWl0dGVyIGhhcyByZWdpc3RlcmVkXG4gKiBsaXN0ZW5lcnMuXG4gKlxuICogQHJldHVybnMge0FycmF5fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcbiAgdmFyIG5hbWVzID0gW11cbiAgICAsIGV2ZW50c1xuICAgICwgbmFtZTtcblxuICBpZiAodGhpcy5fZXZlbnRzQ291bnQgPT09IDApIHJldHVybiBuYW1lcztcblxuICBmb3IgKG5hbWUgaW4gKGV2ZW50cyA9IHRoaXMuX2V2ZW50cykpIHtcbiAgICBpZiAoaGFzLmNhbGwoZXZlbnRzLCBuYW1lKSkgbmFtZXMucHVzaChwcmVmaXggPyBuYW1lLnNsaWNlKDEpIDogbmFtZSk7XG4gIH1cblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHJldHVybiBuYW1lcy5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhldmVudHMpKTtcbiAgfVxuXG4gIHJldHVybiBuYW1lcztcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBsaXN0ZW5lcnMgcmVnaXN0ZXJlZCBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xTeW1ib2x9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtCb29sZWFufSBleGlzdHMgT25seSBjaGVjayBpZiB0aGVyZSBhcmUgbGlzdGVuZXJzLlxuICogQHJldHVybnMge0FycmF5fEJvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyhldmVudCwgZXhpc3RzKSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50XG4gICAgLCBhdmFpbGFibGUgPSB0aGlzLl9ldmVudHNbZXZ0XTtcblxuICBpZiAoZXhpc3RzKSByZXR1cm4gISFhdmFpbGFibGU7XG4gIGlmICghYXZhaWxhYmxlKSByZXR1cm4gW107XG4gIGlmIChhdmFpbGFibGUuZm4pIHJldHVybiBbYXZhaWxhYmxlLmZuXTtcblxuICBmb3IgKHZhciBpID0gMCwgbCA9IGF2YWlsYWJsZS5sZW5ndGgsIGVlID0gbmV3IEFycmF5KGwpOyBpIDwgbDsgaSsrKSB7XG4gICAgZWVbaV0gPSBhdmFpbGFibGVbaV0uZm47XG4gIH1cblxuICByZXR1cm4gZWU7XG59O1xuXG4vKipcbiAqIENhbGxzIGVhY2ggb2YgdGhlIGxpc3RlbmVycyByZWdpc3RlcmVkIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfFN5bWJvbH0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSBldmVudCBoYWQgbGlzdGVuZXJzLCBlbHNlIGBmYWxzZWAuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KGV2ZW50LCBhMSwgYTIsIGEzLCBhNCwgYTUpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbZXZ0XSkgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZ0XVxuICAgICwgbGVuID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICwgYXJnc1xuICAgICwgaTtcblxuICBpZiAobGlzdGVuZXJzLmZuKSB7XG4gICAgaWYgKGxpc3RlbmVycy5vbmNlKSB0aGlzLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcnMuZm4sIHVuZGVmaW5lZCwgdHJ1ZSk7XG5cbiAgICBzd2l0Y2ggKGxlbikge1xuICAgICAgY2FzZSAxOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQpLCB0cnVlO1xuICAgICAgY2FzZSAyOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExKSwgdHJ1ZTtcbiAgICAgIGNhc2UgMzogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIpLCB0cnVlO1xuICAgICAgY2FzZSA0OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMpLCB0cnVlO1xuICAgICAgY2FzZSA1OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMsIGE0KSwgdHJ1ZTtcbiAgICAgIGNhc2UgNjogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIsIGEzLCBhNCwgYTUpLCB0cnVlO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDEsIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0xKTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG5cbiAgICBsaXN0ZW5lcnMuZm4uYXBwbHkobGlzdGVuZXJzLmNvbnRleHQsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHZhciBsZW5ndGggPSBsaXN0ZW5lcnMubGVuZ3RoXG4gICAgICAsIGo7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChsaXN0ZW5lcnNbaV0ub25jZSkgdGhpcy5yZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXJzW2ldLmZuLCB1bmRlZmluZWQsIHRydWUpO1xuXG4gICAgICBzd2l0Y2ggKGxlbikge1xuICAgICAgICBjYXNlIDE6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0KTsgYnJlYWs7XG4gICAgICAgIGNhc2UgMjogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExKTsgYnJlYWs7XG4gICAgICAgIGNhc2UgMzogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExLCBhMik7IGJyZWFrO1xuICAgICAgICBjYXNlIDQ6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSwgYTIsIGEzKTsgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKCFhcmdzKSBmb3IgKGogPSAxLCBhcmdzID0gbmV3IEFycmF5KGxlbiAtMSk7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgYXJnc1tqIC0gMV0gPSBhcmd1bWVudHNbal07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGlzdGVuZXJzW2ldLmZuLmFwcGx5KGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhcmdzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQWRkIGEgbGlzdGVuZXIgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8U3ltYm9sfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7TWl4ZWR9IFtjb250ZXh0PXRoaXNdIFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBhcGkgcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBmdW5jdGlvbiBvbihldmVudCwgZm4sIGNvbnRleHQpIHtcbiAgdmFyIGxpc3RlbmVyID0gbmV3IEVFKGZuLCBjb250ZXh0IHx8IHRoaXMpXG4gICAgLCBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW2V2dF0pIHRoaXMuX2V2ZW50c1tldnRdID0gbGlzdGVuZXIsIHRoaXMuX2V2ZW50c0NvdW50Kys7XG4gIGVsc2UgaWYgKCF0aGlzLl9ldmVudHNbZXZ0XS5mbikgdGhpcy5fZXZlbnRzW2V2dF0ucHVzaChsaXN0ZW5lcik7XG4gIGVsc2UgdGhpcy5fZXZlbnRzW2V2dF0gPSBbdGhpcy5fZXZlbnRzW2V2dF0sIGxpc3RlbmVyXTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQWRkIGEgb25lLXRpbWUgbGlzdGVuZXIgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8U3ltYm9sfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7TWl4ZWR9IFtjb250ZXh0PXRoaXNdIFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBhcGkgcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UoZXZlbnQsIGZuLCBjb250ZXh0KSB7XG4gIHZhciBsaXN0ZW5lciA9IG5ldyBFRShmbiwgY29udGV4dCB8fCB0aGlzLCB0cnVlKVxuICAgICwgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1tldnRdKSB0aGlzLl9ldmVudHNbZXZ0XSA9IGxpc3RlbmVyLCB0aGlzLl9ldmVudHNDb3VudCsrO1xuICBlbHNlIGlmICghdGhpcy5fZXZlbnRzW2V2dF0uZm4pIHRoaXMuX2V2ZW50c1tldnRdLnB1c2gobGlzdGVuZXIpO1xuICBlbHNlIHRoaXMuX2V2ZW50c1tldnRdID0gW3RoaXMuX2V2ZW50c1tldnRdLCBsaXN0ZW5lcl07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZSB0aGUgbGlzdGVuZXJzIG9mIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8U3ltYm9sfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIE9ubHkgcmVtb3ZlIHRoZSBsaXN0ZW5lcnMgdGhhdCBtYXRjaCB0aGlzIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtNaXhlZH0gY29udGV4dCBPbmx5IHJlbW92ZSB0aGUgbGlzdGVuZXJzIHRoYXQgaGF2ZSB0aGlzIGNvbnRleHQuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9uY2UgT25seSByZW1vdmUgb25lLXRpbWUgbGlzdGVuZXJzLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKGV2ZW50LCBmbiwgY29udGV4dCwgb25jZSkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1tldnRdKSByZXR1cm4gdGhpcztcbiAgaWYgKCFmbikge1xuICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKSB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRzKCk7XG4gICAgZWxzZSBkZWxldGUgdGhpcy5fZXZlbnRzW2V2dF07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW2V2dF07XG5cbiAgaWYgKGxpc3RlbmVycy5mbikge1xuICAgIGlmIChcbiAgICAgICAgIGxpc3RlbmVycy5mbiA9PT0gZm5cbiAgICAgICYmICghb25jZSB8fCBsaXN0ZW5lcnMub25jZSlcbiAgICAgICYmICghY29udGV4dCB8fCBsaXN0ZW5lcnMuY29udGV4dCA9PT0gY29udGV4dClcbiAgICApIHtcbiAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKSB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRzKCk7XG4gICAgICBlbHNlIGRlbGV0ZSB0aGlzLl9ldmVudHNbZXZ0XTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGV2ZW50cyA9IFtdLCBsZW5ndGggPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChcbiAgICAgICAgICAgbGlzdGVuZXJzW2ldLmZuICE9PSBmblxuICAgICAgICB8fCAob25jZSAmJiAhbGlzdGVuZXJzW2ldLm9uY2UpXG4gICAgICAgIHx8IChjb250ZXh0ICYmIGxpc3RlbmVyc1tpXS5jb250ZXh0ICE9PSBjb250ZXh0KVxuICAgICAgKSB7XG4gICAgICAgIGV2ZW50cy5wdXNoKGxpc3RlbmVyc1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyBSZXNldCB0aGUgYXJyYXksIG9yIHJlbW92ZSBpdCBjb21wbGV0ZWx5IGlmIHdlIGhhdmUgbm8gbW9yZSBsaXN0ZW5lcnMuXG4gICAgLy9cbiAgICBpZiAoZXZlbnRzLmxlbmd0aCkgdGhpcy5fZXZlbnRzW2V2dF0gPSBldmVudHMubGVuZ3RoID09PSAxID8gZXZlbnRzWzBdIDogZXZlbnRzO1xuICAgIGVsc2UgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcbiAgICBlbHNlIGRlbGV0ZSB0aGlzLl9ldmVudHNbZXZ0XTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYWxsIGxpc3RlbmVycywgb3IgdGhvc2Ugb2YgdGhlIHNwZWNpZmllZCBldmVudC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xTeW1ib2x9IFtldmVudF0gVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyhldmVudCkge1xuICB2YXIgZXZ0O1xuXG4gIGlmIChldmVudCkge1xuICAgIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG4gICAgaWYgKHRoaXMuX2V2ZW50c1tldnRdKSB7XG4gICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMCkgdGhpcy5fZXZlbnRzID0gbmV3IEV2ZW50cygpO1xuICAgICAgZWxzZSBkZWxldGUgdGhpcy5fZXZlbnRzW2V2dF07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vXG4vLyBBbGlhcyBtZXRob2RzIG5hbWVzIGJlY2F1c2UgcGVvcGxlIHJvbGwgbGlrZSB0aGF0LlxuLy9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcjtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uO1xuXG4vL1xuLy8gVGhpcyBmdW5jdGlvbiBkb2Vzbid0IGFwcGx5IGFueW1vcmUuXG4vL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBzZXRNYXhMaXN0ZW5lcnMoKSB7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy9cbi8vIEV4cG9zZSB0aGUgcHJlZml4LlxuLy9cbkV2ZW50RW1pdHRlci5wcmVmaXhlZCA9IHByZWZpeDtcblxuLy9cbi8vIEFsbG93IGBFdmVudEVtaXR0ZXJgIHRvIGJlIGltcG9ydGVkIGFzIG1vZHVsZSBuYW1lc3BhY2UuXG4vL1xuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuLy9cbi8vIEV4cG9zZSB0aGUgbW9kdWxlLlxuLy9cbmlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIG1vZHVsZSkge1xuICBtb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcbn1cbiIsIiFmdW5jdGlvbihlKXt2YXIgbj0vaVBob25lL2ksdD0vaVBvZC9pLHI9L2lQYWQvaSxhPS9cXGJBbmRyb2lkKD86LispTW9iaWxlXFxiL2kscD0vQW5kcm9pZC9pLGI9L1xcYkFuZHJvaWQoPzouKylTRDQ5MzBVUlxcYi9pLGw9L1xcYkFuZHJvaWQoPzouKykoPzpLRltBLVpdezIsNH0pXFxiL2ksZj0vV2luZG93cyBQaG9uZS9pLHM9L1xcYldpbmRvd3MoPzouKylBUk1cXGIvaSx1PS9CbGFja0JlcnJ5L2ksYz0vQkIxMC9pLGg9L09wZXJhIE1pbmkvaSx2PS9cXGIoQ3JpT1N8Q2hyb21lKSg/Oi4rKU1vYmlsZS9pLHc9L01vYmlsZSg/Oi4rKUZpcmVmb3hcXGIvaTtmdW5jdGlvbiBtKGUsaSl7cmV0dXJuIGUudGVzdChpKX1mdW5jdGlvbiBpKGUpe3ZhciBpPWV8fChcInVuZGVmaW5lZFwiIT10eXBlb2YgbmF2aWdhdG9yP25hdmlnYXRvci51c2VyQWdlbnQ6XCJcIiksbz1pLnNwbGl0KFwiW0ZCQU5cIik7dm9pZCAwIT09b1sxXSYmKGk9b1swXSksdm9pZCAwIT09KG89aS5zcGxpdChcIlR3aXR0ZXJcIikpWzFdJiYoaT1vWzBdKTt2YXIgZD17YXBwbGU6e3Bob25lOm0obixpKSYmIW0oZixpKSxpcG9kOm0odCxpKSx0YWJsZXQ6IW0obixpKSYmbShyLGkpJiYhbShmLGkpLGRldmljZToobShuLGkpfHxtKHQsaSl8fG0ocixpKSkmJiFtKGYsaSl9LGFtYXpvbjp7cGhvbmU6bShiLGkpLHRhYmxldDohbShiLGkpJiZtKGwsaSksZGV2aWNlOm0oYixpKXx8bShsLGkpfSxhbmRyb2lkOntwaG9uZTohbShmLGkpJiZtKGIsaSl8fCFtKGYsaSkmJm0oYSxpKSx0YWJsZXQ6IW0oZixpKSYmIW0oYixpKSYmIW0oYSxpKSYmKG0obCxpKXx8bShwLGkpKSxkZXZpY2U6IW0oZixpKSYmKG0oYixpKXx8bShsLGkpfHxtKGEsaSl8fG0ocCxpKSl8fG0oL1xcYm9raHR0cFxcYi9pLGkpfSx3aW5kb3dzOntwaG9uZTptKGYsaSksdGFibGV0Om0ocyxpKSxkZXZpY2U6bShmLGkpfHxtKHMsaSl9LG90aGVyOntibGFja2JlcnJ5Om0odSxpKSxibGFja2JlcnJ5MTA6bShjLGkpLG9wZXJhOm0oaCxpKSxmaXJlZm94Om0odyxpKSxjaHJvbWU6bSh2LGkpLGRldmljZTptKHUsaSl8fG0oYyxpKXx8bShoLGkpfHxtKHcsaSl8fG0odixpKX19O3JldHVybiBkLmFueT1kLmFwcGxlLmRldmljZXx8ZC5hbmRyb2lkLmRldmljZXx8ZC53aW5kb3dzLmRldmljZXx8ZC5vdGhlci5kZXZpY2UsZC5waG9uZT1kLmFwcGxlLnBob25lfHxkLmFuZHJvaWQucGhvbmV8fGQud2luZG93cy5waG9uZSxkLnRhYmxldD1kLmFwcGxlLnRhYmxldHx8ZC5hbmRyb2lkLnRhYmxldHx8ZC53aW5kb3dzLnRhYmxldCxkfVwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGUmJm1vZHVsZS5leHBvcnRzJiZcInVuZGVmaW5lZFwiPT10eXBlb2Ygd2luZG93P21vZHVsZS5leHBvcnRzPWk6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIG1vZHVsZSYmbW9kdWxlLmV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3c/KG1vZHVsZS5leHBvcnRzPWkoKSxtb2R1bGUuZXhwb3J0cy5pc01vYmlsZT1pKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtdLGUuaXNNb2JpbGU9aSgpKTplLmlzTW9iaWxlPWkoKX0odGhpcyk7IiwiLypcbiAqICBiYXNlNjQuanNcbiAqXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIEJTRCAzLUNsYXVzZSBMaWNlbnNlLlxuICogICAgaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICpcbiAqICBSZWZlcmVuY2VzOlxuICogICAgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CYXNlNjRcbiAqL1xuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXG4gICAgICAgID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KGdsb2JhbClcbiAgICAgICAgOiB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWRcbiAgICAgICAgPyBkZWZpbmUoZmFjdG9yeSkgOiBmYWN0b3J5KGdsb2JhbClcbn0oKFxuICAgIHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGZcbiAgICAgICAgOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvd1xuICAgICAgICA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsXG46IHRoaXNcbiksIGZ1bmN0aW9uKGdsb2JhbCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICAvLyBleGlzdGluZyB2ZXJzaW9uIGZvciBub0NvbmZsaWN0KClcbiAgICBnbG9iYWwgPSBnbG9iYWwgfHwge307XG4gICAgdmFyIF9CYXNlNjQgPSBnbG9iYWwuQmFzZTY0O1xuICAgIHZhciB2ZXJzaW9uID0gXCIyLjUuMVwiO1xuICAgIC8vIGlmIG5vZGUuanMgYW5kIE5PVCBSZWFjdCBOYXRpdmUsIHdlIHVzZSBCdWZmZXJcbiAgICB2YXIgYnVmZmVyO1xuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYnVmZmVyID0gZXZhbChcInJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlclwiKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBidWZmZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gY29uc3RhbnRzXG4gICAgdmFyIGI2NGNoYXJzXG4gICAgICAgID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nO1xuICAgIHZhciBiNjR0YWIgPSBmdW5jdGlvbihiaW4pIHtcbiAgICAgICAgdmFyIHQgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBiaW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB0W2Jpbi5jaGFyQXQoaSldID0gaTtcbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfShiNjRjaGFycyk7XG4gICAgdmFyIGZyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG4gICAgLy8gZW5jb2RlciBzdHVmZlxuICAgIHZhciBjYl91dG9iID0gZnVuY3Rpb24oYykge1xuICAgICAgICBpZiAoYy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICB2YXIgY2MgPSBjLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICByZXR1cm4gY2MgPCAweDgwID8gY1xuICAgICAgICAgICAgICAgIDogY2MgPCAweDgwMCA/IChmcm9tQ2hhckNvZGUoMHhjMCB8IChjYyA+Pj4gNikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgZnJvbUNoYXJDb2RlKDB4ODAgfCAoY2MgJiAweDNmKSkpXG4gICAgICAgICAgICAgICAgOiAoZnJvbUNoYXJDb2RlKDB4ZTAgfCAoKGNjID4+PiAxMikgJiAweDBmKSlcbiAgICAgICAgICAgICAgICAgICArIGZyb21DaGFyQ29kZSgweDgwIHwgKChjYyA+Pj4gIDYpICYgMHgzZikpXG4gICAgICAgICAgICAgICAgICAgKyBmcm9tQ2hhckNvZGUoMHg4MCB8ICggY2MgICAgICAgICAmIDB4M2YpKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgY2MgPSAweDEwMDAwXG4gICAgICAgICAgICAgICAgKyAoYy5jaGFyQ29kZUF0KDApIC0gMHhEODAwKSAqIDB4NDAwXG4gICAgICAgICAgICAgICAgKyAoYy5jaGFyQ29kZUF0KDEpIC0gMHhEQzAwKTtcbiAgICAgICAgICAgIHJldHVybiAoZnJvbUNoYXJDb2RlKDB4ZjAgfCAoKGNjID4+PiAxOCkgJiAweDA3KSlcbiAgICAgICAgICAgICAgICAgICAgKyBmcm9tQ2hhckNvZGUoMHg4MCB8ICgoY2MgPj4+IDEyKSAmIDB4M2YpKVxuICAgICAgICAgICAgICAgICAgICArIGZyb21DaGFyQ29kZSgweDgwIHwgKChjYyA+Pj4gIDYpICYgMHgzZikpXG4gICAgICAgICAgICAgICAgICAgICsgZnJvbUNoYXJDb2RlKDB4ODAgfCAoIGNjICAgICAgICAgJiAweDNmKSkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgcmVfdXRvYiA9IC9bXFx1RDgwMC1cXHVEQkZGXVtcXHVEQzAwLVxcdURGRkZGXXxbXlxceDAwLVxceDdGXS9nO1xuICAgIHZhciB1dG9iID0gZnVuY3Rpb24odSkge1xuICAgICAgICByZXR1cm4gdS5yZXBsYWNlKHJlX3V0b2IsIGNiX3V0b2IpO1xuICAgIH07XG4gICAgdmFyIGNiX2VuY29kZSA9IGZ1bmN0aW9uKGNjYykge1xuICAgICAgICB2YXIgcGFkbGVuID0gWzAsIDIsIDFdW2NjYy5sZW5ndGggJSAzXSxcbiAgICAgICAgb3JkID0gY2NjLmNoYXJDb2RlQXQoMCkgPDwgMTZcbiAgICAgICAgICAgIHwgKChjY2MubGVuZ3RoID4gMSA/IGNjYy5jaGFyQ29kZUF0KDEpIDogMCkgPDwgOClcbiAgICAgICAgICAgIHwgKChjY2MubGVuZ3RoID4gMiA/IGNjYy5jaGFyQ29kZUF0KDIpIDogMCkpLFxuICAgICAgICBjaGFycyA9IFtcbiAgICAgICAgICAgIGI2NGNoYXJzLmNoYXJBdCggb3JkID4+PiAxOCksXG4gICAgICAgICAgICBiNjRjaGFycy5jaGFyQXQoKG9yZCA+Pj4gMTIpICYgNjMpLFxuICAgICAgICAgICAgcGFkbGVuID49IDIgPyAnPScgOiBiNjRjaGFycy5jaGFyQXQoKG9yZCA+Pj4gNikgJiA2MyksXG4gICAgICAgICAgICBwYWRsZW4gPj0gMSA/ICc9JyA6IGI2NGNoYXJzLmNoYXJBdChvcmQgJiA2MylcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIGNoYXJzLmpvaW4oJycpO1xuICAgIH07XG4gICAgdmFyIGJ0b2EgPSBnbG9iYWwuYnRvYSA/IGZ1bmN0aW9uKGIpIHtcbiAgICAgICAgcmV0dXJuIGdsb2JhbC5idG9hKGIpO1xuICAgIH0gOiBmdW5jdGlvbihiKSB7XG4gICAgICAgIHJldHVybiBiLnJlcGxhY2UoL1tcXHNcXFNdezEsM30vZywgY2JfZW5jb2RlKTtcbiAgICB9O1xuICAgIHZhciBfZW5jb2RlID0gYnVmZmVyID9cbiAgICAgICAgYnVmZmVyLmZyb20gJiYgVWludDhBcnJheSAmJiBidWZmZXIuZnJvbSAhPT0gVWludDhBcnJheS5mcm9tXG4gICAgICAgID8gZnVuY3Rpb24gKHUpIHtcbiAgICAgICAgICAgIHJldHVybiAodS5jb25zdHJ1Y3RvciA9PT0gYnVmZmVyLmNvbnN0cnVjdG9yID8gdSA6IGJ1ZmZlci5mcm9tKHUpKVxuICAgICAgICAgICAgICAgIC50b1N0cmluZygnYmFzZTY0JylcbiAgICAgICAgfVxuICAgICAgICA6ICBmdW5jdGlvbiAodSkge1xuICAgICAgICAgICAgcmV0dXJuICh1LmNvbnN0cnVjdG9yID09PSBidWZmZXIuY29uc3RydWN0b3IgPyB1IDogbmV3ICBidWZmZXIodSkpXG4gICAgICAgICAgICAgICAgLnRvU3RyaW5nKCdiYXNlNjQnKVxuICAgICAgICB9XG4gICAgICAgIDogZnVuY3Rpb24gKHUpIHsgcmV0dXJuIGJ0b2EodXRvYih1KSkgfVxuICAgIDtcbiAgICB2YXIgZW5jb2RlID0gZnVuY3Rpb24odSwgdXJpc2FmZSkge1xuICAgICAgICByZXR1cm4gIXVyaXNhZmVcbiAgICAgICAgICAgID8gX2VuY29kZShTdHJpbmcodSkpXG4gICAgICAgICAgICA6IF9lbmNvZGUoU3RyaW5nKHUpKS5yZXBsYWNlKC9bK1xcL10vZywgZnVuY3Rpb24obTApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbTAgPT0gJysnID8gJy0nIDogJ18nO1xuICAgICAgICAgICAgfSkucmVwbGFjZSgvPS9nLCAnJyk7XG4gICAgfTtcbiAgICB2YXIgZW5jb2RlVVJJID0gZnVuY3Rpb24odSkgeyByZXR1cm4gZW5jb2RlKHUsIHRydWUpIH07XG4gICAgLy8gZGVjb2RlciBzdHVmZlxuICAgIHZhciByZV9idG91ID0gbmV3IFJlZ0V4cChbXG4gICAgICAgICdbXFx4QzAtXFx4REZdW1xceDgwLVxceEJGXScsXG4gICAgICAgICdbXFx4RTAtXFx4RUZdW1xceDgwLVxceEJGXXsyfScsXG4gICAgICAgICdbXFx4RjAtXFx4RjddW1xceDgwLVxceEJGXXszfSdcbiAgICBdLmpvaW4oJ3wnKSwgJ2cnKTtcbiAgICB2YXIgY2JfYnRvdSA9IGZ1bmN0aW9uKGNjY2MpIHtcbiAgICAgICAgc3dpdGNoKGNjY2MubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHZhciBjcCA9ICgoMHgwNyAmIGNjY2MuY2hhckNvZGVBdCgwKSkgPDwgMTgpXG4gICAgICAgICAgICAgICAgfCAgICAoKDB4M2YgJiBjY2NjLmNoYXJDb2RlQXQoMSkpIDw8IDEyKVxuICAgICAgICAgICAgICAgIHwgICAgKCgweDNmICYgY2NjYy5jaGFyQ29kZUF0KDIpKSA8PCAgNilcbiAgICAgICAgICAgICAgICB8ICAgICAoMHgzZiAmIGNjY2MuY2hhckNvZGVBdCgzKSksXG4gICAgICAgICAgICBvZmZzZXQgPSBjcCAtIDB4MTAwMDA7XG4gICAgICAgICAgICByZXR1cm4gKGZyb21DaGFyQ29kZSgob2Zmc2V0ICA+Pj4gMTApICsgMHhEODAwKVxuICAgICAgICAgICAgICAgICAgICArIGZyb21DaGFyQ29kZSgob2Zmc2V0ICYgMHgzRkYpICsgMHhEQzAwKSk7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJldHVybiBmcm9tQ2hhckNvZGUoXG4gICAgICAgICAgICAgICAgKCgweDBmICYgY2NjYy5jaGFyQ29kZUF0KDApKSA8PCAxMilcbiAgICAgICAgICAgICAgICAgICAgfCAoKDB4M2YgJiBjY2NjLmNoYXJDb2RlQXQoMSkpIDw8IDYpXG4gICAgICAgICAgICAgICAgICAgIHwgICgweDNmICYgY2NjYy5jaGFyQ29kZUF0KDIpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiAgZnJvbUNoYXJDb2RlKFxuICAgICAgICAgICAgICAgICgoMHgxZiAmIGNjY2MuY2hhckNvZGVBdCgwKSkgPDwgNilcbiAgICAgICAgICAgICAgICAgICAgfCAgKDB4M2YgJiBjY2NjLmNoYXJDb2RlQXQoMSkpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgYnRvdSA9IGZ1bmN0aW9uKGIpIHtcbiAgICAgICAgcmV0dXJuIGIucmVwbGFjZShyZV9idG91LCBjYl9idG91KTtcbiAgICB9O1xuICAgIHZhciBjYl9kZWNvZGUgPSBmdW5jdGlvbihjY2NjKSB7XG4gICAgICAgIHZhciBsZW4gPSBjY2NjLmxlbmd0aCxcbiAgICAgICAgcGFkbGVuID0gbGVuICUgNCxcbiAgICAgICAgbiA9IChsZW4gPiAwID8gYjY0dGFiW2NjY2MuY2hhckF0KDApXSA8PCAxOCA6IDApXG4gICAgICAgICAgICB8IChsZW4gPiAxID8gYjY0dGFiW2NjY2MuY2hhckF0KDEpXSA8PCAxMiA6IDApXG4gICAgICAgICAgICB8IChsZW4gPiAyID8gYjY0dGFiW2NjY2MuY2hhckF0KDIpXSA8PCAgNiA6IDApXG4gICAgICAgICAgICB8IChsZW4gPiAzID8gYjY0dGFiW2NjY2MuY2hhckF0KDMpXSAgICAgICA6IDApLFxuICAgICAgICBjaGFycyA9IFtcbiAgICAgICAgICAgIGZyb21DaGFyQ29kZSggbiA+Pj4gMTYpLFxuICAgICAgICAgICAgZnJvbUNoYXJDb2RlKChuID4+PiAgOCkgJiAweGZmKSxcbiAgICAgICAgICAgIGZyb21DaGFyQ29kZSggbiAgICAgICAgICYgMHhmZilcbiAgICAgICAgXTtcbiAgICAgICAgY2hhcnMubGVuZ3RoIC09IFswLCAwLCAyLCAxXVtwYWRsZW5dO1xuICAgICAgICByZXR1cm4gY2hhcnMuam9pbignJyk7XG4gICAgfTtcbiAgICB2YXIgX2F0b2IgPSBnbG9iYWwuYXRvYiA/IGZ1bmN0aW9uKGEpIHtcbiAgICAgICAgcmV0dXJuIGdsb2JhbC5hdG9iKGEpO1xuICAgIH0gOiBmdW5jdGlvbihhKXtcbiAgICAgICAgcmV0dXJuIGEucmVwbGFjZSgvXFxTezEsNH0vZywgY2JfZGVjb2RlKTtcbiAgICB9O1xuICAgIHZhciBhdG9iID0gZnVuY3Rpb24oYSkge1xuICAgICAgICByZXR1cm4gX2F0b2IoU3RyaW5nKGEpLnJlcGxhY2UoL1teQS1aYS16MC05XFwrXFwvXS9nLCAnJykpO1xuICAgIH07XG4gICAgdmFyIF9kZWNvZGUgPSBidWZmZXIgP1xuICAgICAgICBidWZmZXIuZnJvbSAmJiBVaW50OEFycmF5ICYmIGJ1ZmZlci5mcm9tICE9PSBVaW50OEFycmF5LmZyb21cbiAgICAgICAgPyBmdW5jdGlvbihhKSB7XG4gICAgICAgICAgICByZXR1cm4gKGEuY29uc3RydWN0b3IgPT09IGJ1ZmZlci5jb25zdHJ1Y3RvclxuICAgICAgICAgICAgICAgICAgICA/IGEgOiBidWZmZXIuZnJvbShhLCAnYmFzZTY0JykpLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgOiBmdW5jdGlvbihhKSB7XG4gICAgICAgICAgICByZXR1cm4gKGEuY29uc3RydWN0b3IgPT09IGJ1ZmZlci5jb25zdHJ1Y3RvclxuICAgICAgICAgICAgICAgICAgICA/IGEgOiBuZXcgYnVmZmVyKGEsICdiYXNlNjQnKSkudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICA6IGZ1bmN0aW9uKGEpIHsgcmV0dXJuIGJ0b3UoX2F0b2IoYSkpIH07XG4gICAgdmFyIGRlY29kZSA9IGZ1bmN0aW9uKGEpe1xuICAgICAgICByZXR1cm4gX2RlY29kZShcbiAgICAgICAgICAgIFN0cmluZyhhKS5yZXBsYWNlKC9bLV9dL2csIGZ1bmN0aW9uKG0wKSB7IHJldHVybiBtMCA9PSAnLScgPyAnKycgOiAnLycgfSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvW15BLVphLXowLTlcXCtcXC9dL2csICcnKVxuICAgICAgICApO1xuICAgIH07XG4gICAgdmFyIG5vQ29uZmxpY3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIEJhc2U2NCA9IGdsb2JhbC5CYXNlNjQ7XG4gICAgICAgIGdsb2JhbC5CYXNlNjQgPSBfQmFzZTY0O1xuICAgICAgICByZXR1cm4gQmFzZTY0O1xuICAgIH07XG4gICAgLy8gZXhwb3J0IEJhc2U2NFxuICAgIGdsb2JhbC5CYXNlNjQgPSB7XG4gICAgICAgIFZFUlNJT046IHZlcnNpb24sXG4gICAgICAgIGF0b2I6IGF0b2IsXG4gICAgICAgIGJ0b2E6IGJ0b2EsXG4gICAgICAgIGZyb21CYXNlNjQ6IGRlY29kZSxcbiAgICAgICAgdG9CYXNlNjQ6IGVuY29kZSxcbiAgICAgICAgdXRvYjogdXRvYixcbiAgICAgICAgZW5jb2RlOiBlbmNvZGUsXG4gICAgICAgIGVuY29kZVVSSTogZW5jb2RlVVJJLFxuICAgICAgICBidG91OiBidG91LFxuICAgICAgICBkZWNvZGU6IGRlY29kZSxcbiAgICAgICAgbm9Db25mbGljdDogbm9Db25mbGljdCxcbiAgICAgICAgX19idWZmZXJfXzogYnVmZmVyXG4gICAgfTtcbiAgICAvLyBpZiBFUzUgaXMgYXZhaWxhYmxlLCBtYWtlIEJhc2U2NC5leHRlbmRTdHJpbmcoKSBhdmFpbGFibGVcbiAgICBpZiAodHlwZW9mIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgbm9FbnVtID0gZnVuY3Rpb24odil7XG4gICAgICAgICAgICByZXR1cm4ge3ZhbHVlOnYsZW51bWVyYWJsZTpmYWxzZSx3cml0YWJsZTp0cnVlLGNvbmZpZ3VyYWJsZTp0cnVlfTtcbiAgICAgICAgfTtcbiAgICAgICAgZ2xvYmFsLkJhc2U2NC5leHRlbmRTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoXG4gICAgICAgICAgICAgICAgU3RyaW5nLnByb3RvdHlwZSwgJ2Zyb21CYXNlNjQnLCBub0VudW0oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVjb2RlKHRoaXMpXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFxuICAgICAgICAgICAgICAgIFN0cmluZy5wcm90b3R5cGUsICd0b0Jhc2U2NCcsIG5vRW51bShmdW5jdGlvbiAodXJpc2FmZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZW5jb2RlKHRoaXMsIHVyaXNhZmUpXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFxuICAgICAgICAgICAgICAgIFN0cmluZy5wcm90b3R5cGUsICd0b0Jhc2U2NFVSSScsIG5vRW51bShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbmNvZGUodGhpcywgdHJ1ZSlcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vXG4gICAgLy8gZXhwb3J0IEJhc2U2NCB0byB0aGUgbmFtZXNwYWNlXG4gICAgLy9cbiAgICBpZiAoZ2xvYmFsWydNZXRlb3InXSkgeyAvLyBNZXRlb3IuanNcbiAgICAgICAgQmFzZTY0ID0gZ2xvYmFsLkJhc2U2NDtcbiAgICB9XG4gICAgLy8gbW9kdWxlLmV4cG9ydHMgYW5kIEFNRCBhcmUgbXV0dWFsbHkgZXhjbHVzaXZlLlxuICAgIC8vIG1vZHVsZS5leHBvcnRzIGhhcyBwcmVjZWRlbmNlLlxuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cy5CYXNlNjQgPSBnbG9iYWwuQmFzZTY0O1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgLy8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuICAgICAgICBkZWZpbmUoW10sIGZ1bmN0aW9uKCl7IHJldHVybiBnbG9iYWwuQmFzZTY0IH0pO1xuICAgIH1cbiAgICAvLyB0aGF0J3MgaXQhXG4gICAgcmV0dXJuIHtCYXNlNjQ6IGdsb2JhbC5CYXNlNjR9XG59KSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gKGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmICgndmFsdWUnIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxudmFyIE1pbmlTaWduYWxCaW5kaW5nID0gKGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTWluaVNpZ25hbEJpbmRpbmcoZm4sIG9uY2UsIHRoaXNBcmcpIHtcbiAgICBpZiAob25jZSA9PT0gdW5kZWZpbmVkKSBvbmNlID0gZmFsc2U7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTWluaVNpZ25hbEJpbmRpbmcpO1xuXG4gICAgdGhpcy5fZm4gPSBmbjtcbiAgICB0aGlzLl9vbmNlID0gb25jZTtcbiAgICB0aGlzLl90aGlzQXJnID0gdGhpc0FyZztcbiAgICB0aGlzLl9uZXh0ID0gdGhpcy5fcHJldiA9IHRoaXMuX293bmVyID0gbnVsbDtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhNaW5pU2lnbmFsQmluZGluZywgW3tcbiAgICBrZXk6ICdkZXRhY2gnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXRhY2goKSB7XG4gICAgICBpZiAodGhpcy5fb3duZXIgPT09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgICAgIHRoaXMuX293bmVyLmRldGFjaCh0aGlzKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBNaW5pU2lnbmFsQmluZGluZztcbn0pKCk7XG5cbmZ1bmN0aW9uIF9hZGRNaW5pU2lnbmFsQmluZGluZyhzZWxmLCBub2RlKSB7XG4gIGlmICghc2VsZi5faGVhZCkge1xuICAgIHNlbGYuX2hlYWQgPSBub2RlO1xuICAgIHNlbGYuX3RhaWwgPSBub2RlO1xuICB9IGVsc2Uge1xuICAgIHNlbGYuX3RhaWwuX25leHQgPSBub2RlO1xuICAgIG5vZGUuX3ByZXYgPSBzZWxmLl90YWlsO1xuICAgIHNlbGYuX3RhaWwgPSBub2RlO1xuICB9XG5cbiAgbm9kZS5fb3duZXIgPSBzZWxmO1xuXG4gIHJldHVybiBub2RlO1xufVxuXG52YXIgTWluaVNpZ25hbCA9IChmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE1pbmlTaWduYWwoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1pbmlTaWduYWwpO1xuXG4gICAgdGhpcy5faGVhZCA9IHRoaXMuX3RhaWwgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoTWluaVNpZ25hbCwgW3tcbiAgICBrZXk6ICdoYW5kbGVycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZXJzKCkge1xuICAgICAgdmFyIGV4aXN0cyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogYXJndW1lbnRzWzBdO1xuXG4gICAgICB2YXIgbm9kZSA9IHRoaXMuX2hlYWQ7XG5cbiAgICAgIGlmIChleGlzdHMpIHJldHVybiAhIW5vZGU7XG5cbiAgICAgIHZhciBlZSA9IFtdO1xuXG4gICAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICBlZS5wdXNoKG5vZGUpO1xuICAgICAgICBub2RlID0gbm9kZS5fbmV4dDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2hhcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhcyhub2RlKSB7XG4gICAgICBpZiAoIShub2RlIGluc3RhbmNlb2YgTWluaVNpZ25hbEJpbmRpbmcpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWluaVNpZ25hbCNoYXMoKTogRmlyc3QgYXJnIG11c3QgYmUgYSBNaW5pU2lnbmFsQmluZGluZyBvYmplY3QuJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBub2RlLl9vd25lciA9PT0gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkaXNwYXRjaCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3BhdGNoKCkge1xuICAgICAgdmFyIG5vZGUgPSB0aGlzLl9oZWFkO1xuXG4gICAgICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcblxuICAgICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUuX29uY2UpIHRoaXMuZGV0YWNoKG5vZGUpO1xuICAgICAgICBub2RlLl9mbi5hcHBseShub2RlLl90aGlzQXJnLCBhcmd1bWVudHMpO1xuICAgICAgICBub2RlID0gbm9kZS5fbmV4dDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYWRkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkKGZuKSB7XG4gICAgICB2YXIgdGhpc0FyZyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IG51bGwgOiBhcmd1bWVudHNbMV07XG5cbiAgICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaW5pU2lnbmFsI2FkZCgpOiBGaXJzdCBhcmcgbXVzdCBiZSBhIEZ1bmN0aW9uLicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9hZGRNaW5pU2lnbmFsQmluZGluZyh0aGlzLCBuZXcgTWluaVNpZ25hbEJpbmRpbmcoZm4sIGZhbHNlLCB0aGlzQXJnKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25jZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uY2UoZm4pIHtcbiAgICAgIHZhciB0aGlzQXJnID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGFyZ3VtZW50c1sxXTtcblxuICAgICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pbmlTaWduYWwjb25jZSgpOiBGaXJzdCBhcmcgbXVzdCBiZSBhIEZ1bmN0aW9uLicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9hZGRNaW5pU2lnbmFsQmluZGluZyh0aGlzLCBuZXcgTWluaVNpZ25hbEJpbmRpbmcoZm4sIHRydWUsIHRoaXNBcmcpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkZXRhY2gnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXRhY2gobm9kZSkge1xuICAgICAgaWYgKCEobm9kZSBpbnN0YW5jZW9mIE1pbmlTaWduYWxCaW5kaW5nKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pbmlTaWduYWwjZGV0YWNoKCk6IEZpcnN0IGFyZyBtdXN0IGJlIGEgTWluaVNpZ25hbEJpbmRpbmcgb2JqZWN0LicpO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUuX293bmVyICE9PSB0aGlzKSByZXR1cm4gdGhpcztcblxuICAgICAgaWYgKG5vZGUuX3ByZXYpIG5vZGUuX3ByZXYuX25leHQgPSBub2RlLl9uZXh0O1xuICAgICAgaWYgKG5vZGUuX25leHQpIG5vZGUuX25leHQuX3ByZXYgPSBub2RlLl9wcmV2O1xuXG4gICAgICBpZiAobm9kZSA9PT0gdGhpcy5faGVhZCkge1xuICAgICAgICB0aGlzLl9oZWFkID0gbm9kZS5fbmV4dDtcbiAgICAgICAgaWYgKG5vZGUuX25leHQgPT09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLl90YWlsID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChub2RlID09PSB0aGlzLl90YWlsKSB7XG4gICAgICAgIHRoaXMuX3RhaWwgPSBub2RlLl9wcmV2O1xuICAgICAgICB0aGlzLl90YWlsLl9uZXh0ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgbm9kZS5fb3duZXIgPSBudWxsO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZGV0YWNoQWxsJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGV0YWNoQWxsKCkge1xuICAgICAgdmFyIG5vZGUgPSB0aGlzLl9oZWFkO1xuICAgICAgaWYgKCFub2RlKSByZXR1cm4gdGhpcztcblxuICAgICAgdGhpcy5faGVhZCA9IHRoaXMuX3RhaWwgPSBudWxsO1xuXG4gICAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICBub2RlLl9vd25lciA9IG51bGw7XG4gICAgICAgIG5vZGUgPSBub2RlLl9uZXh0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE1pbmlTaWduYWw7XG59KSgpO1xuXG5NaW5pU2lnbmFsLk1pbmlTaWduYWxCaW5kaW5nID0gTWluaVNpZ25hbEJpbmRpbmc7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IE1pbmlTaWduYWw7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbiIsIi8qXG5vYmplY3QtYXNzaWduXG4oYykgU2luZHJlIFNvcmh1c1xuQGxpY2Vuc2UgTUlUXG4qL1xuXG4ndXNlIHN0cmljdCc7XG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xudmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHByb3BJc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5mdW5jdGlvbiB0b09iamVjdCh2YWwpIHtcblx0aWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5hc3NpZ24gY2Fubm90IGJlIGNhbGxlZCB3aXRoIG51bGwgb3IgdW5kZWZpbmVkJyk7XG5cdH1cblxuXHRyZXR1cm4gT2JqZWN0KHZhbCk7XG59XG5cbmZ1bmN0aW9uIHNob3VsZFVzZU5hdGl2ZSgpIHtcblx0dHJ5IHtcblx0XHRpZiAoIU9iamVjdC5hc3NpZ24pIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBEZXRlY3QgYnVnZ3kgcHJvcGVydHkgZW51bWVyYXRpb24gb3JkZXIgaW4gb2xkZXIgVjggdmVyc2lvbnMuXG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD00MTE4XG5cdFx0dmFyIHRlc3QxID0gbmV3IFN0cmluZygnYWJjJyk7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ldy13cmFwcGVyc1xuXHRcdHRlc3QxWzVdID0gJ2RlJztcblx0XHRpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDEpWzBdID09PSAnNScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QyID0ge307XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG5cdFx0XHR0ZXN0MlsnXycgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpXSA9IGk7XG5cdFx0fVxuXHRcdHZhciBvcmRlcjIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MikubWFwKGZ1bmN0aW9uIChuKSB7XG5cdFx0XHRyZXR1cm4gdGVzdDJbbl07XG5cdFx0fSk7XG5cdFx0aWYgKG9yZGVyMi5qb2luKCcnKSAhPT0gJzAxMjM0NTY3ODknKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MyA9IHt9O1xuXHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGxldHRlcikge1xuXHRcdFx0dGVzdDNbbGV0dGVyXSA9IGxldHRlcjtcblx0XHR9KTtcblx0XHRpZiAoT2JqZWN0LmtleXMoT2JqZWN0LmFzc2lnbih7fSwgdGVzdDMpKS5qb2luKCcnKSAhPT1cblx0XHRcdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9IGNhdGNoIChlcnIpIHtcblx0XHQvLyBXZSBkb24ndCBleHBlY3QgYW55IG9mIHRoZSBhYm92ZSB0byB0aHJvdywgYnV0IGJldHRlciB0byBiZSBzYWZlLlxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNob3VsZFVzZU5hdGl2ZSgpID8gT2JqZWN0LmFzc2lnbiA6IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuXHR2YXIgZnJvbTtcblx0dmFyIHRvID0gdG9PYmplY3QodGFyZ2V0KTtcblx0dmFyIHN5bWJvbHM7XG5cblx0Zm9yICh2YXIgcyA9IDE7IHMgPCBhcmd1bWVudHMubGVuZ3RoOyBzKyspIHtcblx0XHRmcm9tID0gT2JqZWN0KGFyZ3VtZW50c1tzXSk7XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuXHRcdFx0aWYgKGhhc093blByb3BlcnR5LmNhbGwoZnJvbSwga2V5KSkge1xuXHRcdFx0XHR0b1trZXldID0gZnJvbVtrZXldO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcblx0XHRcdHN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZnJvbSk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN5bWJvbHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKHByb3BJc0VudW1lcmFibGUuY2FsbChmcm9tLCBzeW1ib2xzW2ldKSkge1xuXHRcdFx0XHRcdHRvW3N5bWJvbHNbaV1dID0gZnJvbVtzeW1ib2xzW2ldXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0bztcbn07XG4iLCIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZVVSSSAoc3RyLCBvcHRzKSB7XG4gIG9wdHMgPSBvcHRzIHx8IHt9XG5cbiAgdmFyIG8gPSB7XG4gICAga2V5OiBbJ3NvdXJjZScsICdwcm90b2NvbCcsICdhdXRob3JpdHknLCAndXNlckluZm8nLCAndXNlcicsICdwYXNzd29yZCcsICdob3N0JywgJ3BvcnQnLCAncmVsYXRpdmUnLCAncGF0aCcsICdkaXJlY3RvcnknLCAnZmlsZScsICdxdWVyeScsICdhbmNob3InXSxcbiAgICBxOiB7XG4gICAgICBuYW1lOiAncXVlcnlLZXknLFxuICAgICAgcGFyc2VyOiAvKD86XnwmKShbXiY9XSopPT8oW14mXSopL2dcbiAgICB9LFxuICAgIHBhcnNlcjoge1xuICAgICAgc3RyaWN0OiAvXig/OihbXjpcXC8/I10rKTopPyg/OlxcL1xcLygoPzooKFteOkBdKikoPzo6KFteOkBdKikpPyk/QCk/KFteOlxcLz8jXSopKD86OihcXGQqKSk/KSk/KCgoKD86W14/I1xcL10qXFwvKSopKFtePyNdKikpKD86XFw/KFteI10qKSk/KD86IyguKikpPykvLFxuICAgICAgbG9vc2U6IC9eKD86KD8hW146QF0rOlteOkBcXC9dKkApKFteOlxcLz8jLl0rKTopPyg/OlxcL1xcLyk/KCg/OigoW146QF0qKSg/OjooW146QF0qKSk/KT9AKT8oW146XFwvPyNdKikoPzo6KFxcZCopKT8pKCgoXFwvKD86W14/I10oPyFbXj8jXFwvXSpcXC5bXj8jXFwvLl0rKD86Wz8jXXwkKSkpKlxcLz8pPyhbXj8jXFwvXSopKSg/OlxcPyhbXiNdKikpPyg/OiMoLiopKT8pL1xuICAgIH1cbiAgfVxuXG4gIHZhciBtID0gby5wYXJzZXJbb3B0cy5zdHJpY3RNb2RlID8gJ3N0cmljdCcgOiAnbG9vc2UnXS5leGVjKHN0cilcbiAgdmFyIHVyaSA9IHt9XG4gIHZhciBpID0gMTRcblxuICB3aGlsZSAoaS0tKSB1cmlbby5rZXlbaV1dID0gbVtpXSB8fCAnJ1xuXG4gIHVyaVtvLnEubmFtZV0gPSB7fVxuICB1cmlbby5rZXlbMTJdXS5yZXBsYWNlKG8ucS5wYXJzZXIsIGZ1bmN0aW9uICgkMCwgJDEsICQyKSB7XG4gICAgaWYgKCQxKSB1cmlbby5xLm5hbWVdWyQxXSA9ICQyXG4gIH0pXG5cbiAgcmV0dXJuIHVyaVxufVxuIiwidmFyIEVNUFRZX0FSUkFZX0JVRkZFUiA9IG5ldyBBcnJheUJ1ZmZlcigwKTtcblxuLyoqXG4gKiBIZWxwZXIgY2xhc3MgdG8gY3JlYXRlIGEgd2ViR0wgYnVmZmVyXG4gKlxuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgUElYSS5nbENvcmVcbiAqIEBwYXJhbSBnbCB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBUaGUgY3VycmVudCBXZWJHTCByZW5kZXJpbmcgY29udGV4dFxuICogQHBhcmFtIHR5cGUge2dsLkFSUkFZX0JVRkZFUiB8IGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSfSBAbWF0XG4gKiBAcGFyYW0gZGF0YSB7QXJyYXlCdWZmZXJ8IFNoYXJlZEFycmF5QnVmZmVyfEFycmF5QnVmZmVyVmlld30gYW4gYXJyYXkgb2YgZGF0YVxuICogQHBhcmFtIGRyYXdUeXBlIHtnbC5TVEFUSUNfRFJBV3xnbC5EWU5BTUlDX0RSQVd8Z2wuU1RSRUFNX0RSQVd9XG4gKi9cbnZhciBCdWZmZXIgPSBmdW5jdGlvbihnbCwgdHlwZSwgZGF0YSwgZHJhd1R5cGUpXG57XG5cblx0LyoqXG4gICAgICogVGhlIGN1cnJlbnQgV2ViR0wgcmVuZGVyaW5nIGNvbnRleHRcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge1dlYkdMUmVuZGVyaW5nQ29udGV4dH1cbiAgICAgKi9cblx0dGhpcy5nbCA9IGdsO1xuXG5cdC8qKlxuICAgICAqIFRoZSBXZWJHTCBidWZmZXIsIGNyZWF0ZWQgdXBvbiBpbnN0YW50aWF0aW9uXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtXZWJHTEJ1ZmZlcn1cbiAgICAgKi9cblx0dGhpcy5idWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcblxuXHQvKipcbiAgICAgKiBUaGUgdHlwZSBvZiB0aGUgYnVmZmVyXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtnbC5BUlJBWV9CVUZGRVJ8Z2wuRUxFTUVOVF9BUlJBWV9CVUZGRVJ9XG4gICAgICovXG5cdHRoaXMudHlwZSA9IHR5cGUgfHwgZ2wuQVJSQVlfQlVGRkVSO1xuXG5cdC8qKlxuICAgICAqIFRoZSBkcmF3IHR5cGUgb2YgdGhlIGJ1ZmZlclxuICAgICAqXG4gICAgICogQG1lbWJlciB7Z2wuU1RBVElDX0RSQVd8Z2wuRFlOQU1JQ19EUkFXfGdsLlNUUkVBTV9EUkFXfVxuICAgICAqL1xuXHR0aGlzLmRyYXdUeXBlID0gZHJhd1R5cGUgfHwgZ2wuU1RBVElDX0RSQVc7XG5cblx0LyoqXG4gICAgICogVGhlIGRhdGEgaW4gdGhlIGJ1ZmZlciwgYXMgYSB0eXBlZCBhcnJheVxuICAgICAqXG4gICAgICogQG1lbWJlciB7QXJyYXlCdWZmZXJ8IFNoYXJlZEFycmF5QnVmZmVyfEFycmF5QnVmZmVyVmlld31cbiAgICAgKi9cblx0dGhpcy5kYXRhID0gRU1QVFlfQVJSQVlfQlVGRkVSO1xuXG5cdGlmKGRhdGEpXG5cdHtcblx0XHR0aGlzLnVwbG9hZChkYXRhKTtcblx0fVxuXG5cdHRoaXMuX3VwZGF0ZUlEID0gMDtcbn07XG5cbi8qKlxuICogVXBsb2FkcyB0aGUgYnVmZmVyIHRvIHRoZSBHUFVcbiAqIEBwYXJhbSBkYXRhIHtBcnJheUJ1ZmZlcnwgU2hhcmVkQXJyYXlCdWZmZXJ8QXJyYXlCdWZmZXJWaWV3fSBhbiBhcnJheSBvZiBkYXRhIHRvIHVwbG9hZFxuICogQHBhcmFtIG9mZnNldCB7TnVtYmVyfSBpZiBvbmx5IGEgc3Vic2V0IG9mIHRoZSBkYXRhIHNob3VsZCBiZSB1cGxvYWRlZCwgdGhpcyBpcyB0aGUgYW1vdW50IG9mIGRhdGEgdG8gc3VidHJhY3RcbiAqIEBwYXJhbSBkb250QmluZCB7Qm9vbGVhbn0gd2hldGhlciB0byBiaW5kIHRoZSBidWZmZXIgYmVmb3JlIHVwbG9hZGluZyBpdFxuICovXG5CdWZmZXIucHJvdG90eXBlLnVwbG9hZCA9IGZ1bmN0aW9uKGRhdGEsIG9mZnNldCwgZG9udEJpbmQpXG57XG5cdC8vIHRvZG8gLSBuZWVkZWQ/XG5cdGlmKCFkb250QmluZCkgdGhpcy5iaW5kKCk7XG5cblx0dmFyIGdsID0gdGhpcy5nbDtcblxuXHRkYXRhID0gZGF0YSB8fCB0aGlzLmRhdGE7XG5cdG9mZnNldCA9IG9mZnNldCB8fCAwO1xuXG5cdGlmKHRoaXMuZGF0YS5ieXRlTGVuZ3RoID49IGRhdGEuYnl0ZUxlbmd0aClcblx0e1xuXHRcdGdsLmJ1ZmZlclN1YkRhdGEodGhpcy50eXBlLCBvZmZzZXQsIGRhdGEpO1xuXHR9XG5cdGVsc2Vcblx0e1xuXHRcdGdsLmJ1ZmZlckRhdGEodGhpcy50eXBlLCBkYXRhLCB0aGlzLmRyYXdUeXBlKTtcblx0fVxuXG5cdHRoaXMuZGF0YSA9IGRhdGE7XG59O1xuLyoqXG4gKiBCaW5kcyB0aGUgYnVmZmVyXG4gKlxuICovXG5CdWZmZXIucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbigpXG57XG5cdHZhciBnbCA9IHRoaXMuZ2w7XG5cdGdsLmJpbmRCdWZmZXIodGhpcy50eXBlLCB0aGlzLmJ1ZmZlcik7XG59O1xuXG5CdWZmZXIuY3JlYXRlVmVydGV4QnVmZmVyID0gZnVuY3Rpb24oZ2wsIGRhdGEsIGRyYXdUeXBlKVxue1xuXHRyZXR1cm4gbmV3IEJ1ZmZlcihnbCwgZ2wuQVJSQVlfQlVGRkVSLCBkYXRhLCBkcmF3VHlwZSk7XG59O1xuXG5CdWZmZXIuY3JlYXRlSW5kZXhCdWZmZXIgPSBmdW5jdGlvbihnbCwgZGF0YSwgZHJhd1R5cGUpXG57XG5cdHJldHVybiBuZXcgQnVmZmVyKGdsLCBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgZGF0YSwgZHJhd1R5cGUpO1xufTtcblxuQnVmZmVyLmNyZWF0ZSA9IGZ1bmN0aW9uKGdsLCB0eXBlLCBkYXRhLCBkcmF3VHlwZSlcbntcblx0cmV0dXJuIG5ldyBCdWZmZXIoZ2wsIHR5cGUsIGRhdGEsIGRyYXdUeXBlKTtcbn07XG5cbi8qKlxuICogRGVzdHJveXMgdGhlIGJ1ZmZlclxuICpcbiAqL1xuQnVmZmVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKXtcblx0dGhpcy5nbC5kZWxldGVCdWZmZXIodGhpcy5idWZmZXIpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCdWZmZXI7XG4iLCJcbnZhciBUZXh0dXJlID0gcmVxdWlyZSgnLi9HTFRleHR1cmUnKTtcblxuLyoqXG4gKiBIZWxwZXIgY2xhc3MgdG8gY3JlYXRlIGEgd2ViR0wgRnJhbWVidWZmZXJcbiAqXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQSVhJLmdsQ29yZVxuICogQHBhcmFtIGdsIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IFRoZSBjdXJyZW50IFdlYkdMIHJlbmRlcmluZyBjb250ZXh0XG4gKiBAcGFyYW0gd2lkdGgge051bWJlcn0gdGhlIHdpZHRoIG9mIHRoZSBkcmF3aW5nIGFyZWEgb2YgdGhlIGZyYW1lIGJ1ZmZlclxuICogQHBhcmFtIGhlaWdodCB7TnVtYmVyfSB0aGUgaGVpZ2h0IG9mIHRoZSBkcmF3aW5nIGFyZWEgb2YgdGhlIGZyYW1lIGJ1ZmZlclxuICovXG52YXIgRnJhbWVidWZmZXIgPSBmdW5jdGlvbihnbCwgd2lkdGgsIGhlaWdodClcbntcbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudCBXZWJHTCByZW5kZXJpbmcgY29udGV4dFxuICAgICAqXG4gICAgICogQG1lbWJlciB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fVxuICAgICAqL1xuICAgIHRoaXMuZ2wgPSBnbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBmcmFtZSBidWZmZXJcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge1dlYkdMRnJhbWVidWZmZXJ9XG4gICAgICovXG4gICAgdGhpcy5mcmFtZWJ1ZmZlciA9IGdsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3RlbmNpbCBidWZmZXJcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge1dlYkdMUmVuZGVyYnVmZmVyfVxuICAgICAqL1xuICAgIHRoaXMuc3RlbmNpbCA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3RlbmNpbCBidWZmZXJcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge1BJWEkuZ2xDb3JlLkdMVGV4dHVyZX1cbiAgICAgKi9cbiAgICB0aGlzLnRleHR1cmUgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHdpZHRoIG9mIHRoZSBkcmF3aW5nIGFyZWEgb2YgdGhlIGJ1ZmZlclxuICAgICAqXG4gICAgICogQG1lbWJlciB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMud2lkdGggPSB3aWR0aCB8fCAxMDA7XG4gICAgLyoqXG4gICAgICogVGhlIGhlaWdodCBvZiB0aGUgZHJhd2luZyBhcmVhIG9mIHRoZSBidWZmZXJcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodCB8fCAxMDA7XG59O1xuXG4vKipcbiAqIEFkZHMgYSB0ZXh0dXJlIHRvIHRoZSBmcmFtZSBidWZmZXJcbiAqIEBwYXJhbSB0ZXh0dXJlIHtQSVhJLmdsQ29yZS5HTFRleHR1cmV9XG4gKi9cbkZyYW1lYnVmZmVyLnByb3RvdHlwZS5lbmFibGVUZXh0dXJlID0gZnVuY3Rpb24odGV4dHVyZSlcbntcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuXG4gICAgdGhpcy50ZXh0dXJlID0gdGV4dHVyZSB8fCBuZXcgVGV4dHVyZShnbCk7XG5cbiAgICB0aGlzLnRleHR1cmUuYmluZCgpO1xuXG4gICAgLy9nbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsICB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgbnVsbCk7XG5cbiAgICB0aGlzLmJpbmQoKTtcblxuICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCwgZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlLnRleHR1cmUsIDApO1xufTtcblxuLyoqXG4gKiBJbml0aWFsaXNlcyB0aGUgc3RlbmNpbCBidWZmZXJcbiAqL1xuRnJhbWVidWZmZXIucHJvdG90eXBlLmVuYWJsZVN0ZW5jaWwgPSBmdW5jdGlvbigpXG57XG4gICAgaWYodGhpcy5zdGVuY2lsKXJldHVybjtcblxuICAgIHZhciBnbCA9IHRoaXMuZ2w7XG5cbiAgICB0aGlzLnN0ZW5jaWwgPSBnbC5jcmVhdGVSZW5kZXJidWZmZXIoKTtcblxuICAgIGdsLmJpbmRSZW5kZXJidWZmZXIoZ2wuUkVOREVSQlVGRkVSLCB0aGlzLnN0ZW5jaWwpO1xuXG4gICAgLy8gVE9ETy4uIHRoaXMgaXMgZGVwdGggQU5EIHN0ZW5jaWw/XG4gICAgZ2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGdsLkRFUFRIX1NURU5DSUxfQVRUQUNITUVOVCwgZ2wuUkVOREVSQlVGRkVSLCB0aGlzLnN0ZW5jaWwpO1xuICAgIGdsLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoZ2wuUkVOREVSQlVGRkVSLCBnbC5ERVBUSF9TVEVOQ0lMLCAgdGhpcy53aWR0aCAgLCB0aGlzLmhlaWdodCApO1xuXG5cbn07XG5cbi8qKlxuICogRXJhc2VzIHRoZSBkcmF3aW5nIGFyZWEgYW5kIGZpbGxzIGl0IHdpdGggYSBjb2xvdXJcbiAqIEBwYXJhbSAgciB7TnVtYmVyfSB0aGUgcmVkIHZhbHVlIG9mIHRoZSBjbGVhcmluZyBjb2xvdXJcbiAqIEBwYXJhbSAgZyB7TnVtYmVyfSB0aGUgZ3JlZW4gdmFsdWUgb2YgdGhlIGNsZWFyaW5nIGNvbG91clxuICogQHBhcmFtICBiIHtOdW1iZXJ9IHRoZSBibHVlIHZhbHVlIG9mIHRoZSBjbGVhcmluZyBjb2xvdXJcbiAqIEBwYXJhbSAgYSB7TnVtYmVyfSB0aGUgYWxwaGEgdmFsdWUgb2YgdGhlIGNsZWFyaW5nIGNvbG91clxuICovXG5GcmFtZWJ1ZmZlci5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiggciwgZywgYiwgYSApXG57XG4gICAgdGhpcy5iaW5kKCk7XG5cbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuXG4gICAgZ2wuY2xlYXJDb2xvcihyLCBnLCBiLCBhKTtcbiAgICBnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUIHwgZ2wuREVQVEhfQlVGRkVSX0JJVCk7XG59O1xuXG4vKipcbiAqIEJpbmRzIHRoZSBmcmFtZSBidWZmZXIgdG8gdGhlIFdlYkdMIGNvbnRleHRcbiAqL1xuRnJhbWVidWZmZXIucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbigpXG57XG4gICAgdmFyIGdsID0gdGhpcy5nbDtcbiAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHRoaXMuZnJhbWVidWZmZXIgKTtcbn07XG5cbi8qKlxuICogVW5iaW5kcyB0aGUgZnJhbWUgYnVmZmVyIHRvIHRoZSBXZWJHTCBjb250ZXh0XG4gKi9cbkZyYW1lYnVmZmVyLnByb3RvdHlwZS51bmJpbmQgPSBmdW5jdGlvbigpXG57XG4gICAgdmFyIGdsID0gdGhpcy5nbDtcbiAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwgKTtcbn07XG4vKipcbiAqIFJlc2l6ZXMgdGhlIGRyYXdpbmcgYXJlYSBvZiB0aGUgYnVmZmVyIHRvIHRoZSBnaXZlbiB3aWR0aCBhbmQgaGVpZ2h0XG4gKiBAcGFyYW0gIHdpZHRoICB7TnVtYmVyfSB0aGUgbmV3IHdpZHRoXG4gKiBAcGFyYW0gIGhlaWdodCB7TnVtYmVyfSB0aGUgbmV3IGhlaWdodFxuICovXG5GcmFtZWJ1ZmZlci5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodClcbntcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuXG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgaWYgKCB0aGlzLnRleHR1cmUgKVxuICAgIHtcbiAgICAgICAgdGhpcy50ZXh0dXJlLnVwbG9hZERhdGEobnVsbCwgd2lkdGgsIGhlaWdodCk7XG4gICAgfVxuXG4gICAgaWYgKCB0aGlzLnN0ZW5jaWwgKVxuICAgIHtcbiAgICAgICAgLy8gdXBkYXRlIHRoZSBzdGVuY2lsIGJ1ZmZlciB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgICAgIGdsLmJpbmRSZW5kZXJidWZmZXIoZ2wuUkVOREVSQlVGRkVSLCB0aGlzLnN0ZW5jaWwpO1xuICAgICAgICBnbC5yZW5kZXJidWZmZXJTdG9yYWdlKGdsLlJFTkRFUkJVRkZFUiwgZ2wuREVQVEhfU1RFTkNJTCwgd2lkdGgsIGhlaWdodCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBEZXN0cm95cyB0aGlzIGJ1ZmZlclxuICovXG5GcmFtZWJ1ZmZlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKClcbntcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuXG4gICAgLy9UT0RPXG4gICAgaWYodGhpcy50ZXh0dXJlKVxuICAgIHtcbiAgICAgICAgdGhpcy50ZXh0dXJlLmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICBnbC5kZWxldGVGcmFtZWJ1ZmZlcih0aGlzLmZyYW1lYnVmZmVyKTtcblxuICAgIHRoaXMuZ2wgPSBudWxsO1xuXG4gICAgdGhpcy5zdGVuY2lsID0gbnVsbDtcbiAgICB0aGlzLnRleHR1cmUgPSBudWxsO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnJhbWUgYnVmZmVyIHdpdGggYSB0ZXh0dXJlIGNvbnRhaW5pbmcgdGhlIGdpdmVuIGRhdGFcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSBnbCB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBUaGUgY3VycmVudCBXZWJHTCByZW5kZXJpbmcgY29udGV4dFxuICogQHBhcmFtIHdpZHRoIHtOdW1iZXJ9IHRoZSB3aWR0aCBvZiB0aGUgZHJhd2luZyBhcmVhIG9mIHRoZSBmcmFtZSBidWZmZXJcbiAqIEBwYXJhbSBoZWlnaHQge051bWJlcn0gdGhlIGhlaWdodCBvZiB0aGUgZHJhd2luZyBhcmVhIG9mIHRoZSBmcmFtZSBidWZmZXJcbiAqIEBwYXJhbSBkYXRhIHtBcnJheUJ1ZmZlcnwgU2hhcmVkQXJyYXlCdWZmZXJ8QXJyYXlCdWZmZXJWaWV3fSBhbiBhcnJheSBvZiBkYXRhXG4gKi9cbkZyYW1lYnVmZmVyLmNyZWF0ZVJHQkEgPSBmdW5jdGlvbihnbCwgd2lkdGgsIGhlaWdodCwgZGF0YSlcbntcbiAgICB2YXIgdGV4dHVyZSA9IFRleHR1cmUuZnJvbURhdGEoZ2wsIG51bGwsIHdpZHRoLCBoZWlnaHQpO1xuICAgIHRleHR1cmUuZW5hYmxlTmVhcmVzdFNjYWxpbmcoKTtcbiAgICB0ZXh0dXJlLmVuYWJsZVdyYXBDbGFtcCgpO1xuXG4gICAgLy9ub3cgY3JlYXRlIHRoZSBmcmFtZWJ1ZmZlciBvYmplY3QgYW5kIGF0dGFjaCB0aGUgdGV4dHVyZSB0byBpdC5cbiAgICB2YXIgZmJvID0gbmV3IEZyYW1lYnVmZmVyKGdsLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICBmYm8uZW5hYmxlVGV4dHVyZSh0ZXh0dXJlKTtcbiAgICAvL2Ziby5lbmFibGVTdGVuY2lsKCk7IC8vIGdldCB0aGlzIGJhY2sgb24gc29vbiFcblxuICAgIC8vZmJvLmVuYWJsZVN0ZW5jaWwoKTsgLy8gZ2V0IHRoaXMgYmFjayBvbiBzb29uIVxuXG4gICAgZmJvLnVuYmluZCgpO1xuXG4gICAgcmV0dXJuIGZibztcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZyYW1lIGJ1ZmZlciB3aXRoIGEgdGV4dHVyZSBjb250YWluaW5nIHRoZSBnaXZlbiBkYXRhXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0gZ2wge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gVGhlIGN1cnJlbnQgV2ViR0wgcmVuZGVyaW5nIGNvbnRleHRcbiAqIEBwYXJhbSB3aWR0aCB7TnVtYmVyfSB0aGUgd2lkdGggb2YgdGhlIGRyYXdpbmcgYXJlYSBvZiB0aGUgZnJhbWUgYnVmZmVyXG4gKiBAcGFyYW0gaGVpZ2h0IHtOdW1iZXJ9IHRoZSBoZWlnaHQgb2YgdGhlIGRyYXdpbmcgYXJlYSBvZiB0aGUgZnJhbWUgYnVmZmVyXG4gKiBAcGFyYW0gZGF0YSB7QXJyYXlCdWZmZXJ8IFNoYXJlZEFycmF5QnVmZmVyfEFycmF5QnVmZmVyVmlld30gYW4gYXJyYXkgb2YgZGF0YVxuICovXG5GcmFtZWJ1ZmZlci5jcmVhdGVGbG9hdDMyID0gZnVuY3Rpb24oZ2wsIHdpZHRoLCBoZWlnaHQsIGRhdGEpXG57XG4gICAgLy8gY3JlYXRlIGEgbmV3IHRleHR1cmUuLlxuICAgIHZhciB0ZXh0dXJlID0gbmV3IFRleHR1cmUuZnJvbURhdGEoZ2wsIGRhdGEsIHdpZHRoLCBoZWlnaHQpO1xuICAgIHRleHR1cmUuZW5hYmxlTmVhcmVzdFNjYWxpbmcoKTtcbiAgICB0ZXh0dXJlLmVuYWJsZVdyYXBDbGFtcCgpO1xuXG4gICAgLy9ub3cgY3JlYXRlIHRoZSBmcmFtZWJ1ZmZlciBvYmplY3QgYW5kIGF0dGFjaCB0aGUgdGV4dHVyZSB0byBpdC5cbiAgICB2YXIgZmJvID0gbmV3IEZyYW1lYnVmZmVyKGdsLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICBmYm8uZW5hYmxlVGV4dHVyZSh0ZXh0dXJlKTtcblxuICAgIGZiby51bmJpbmQoKTtcblxuICAgIHJldHVybiBmYm87XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZyYW1lYnVmZmVyO1xuIiwiXG52YXIgY29tcGlsZVByb2dyYW0gPSByZXF1aXJlKCcuL3NoYWRlci9jb21waWxlUHJvZ3JhbScpLFxuXHRleHRyYWN0QXR0cmlidXRlcyA9IHJlcXVpcmUoJy4vc2hhZGVyL2V4dHJhY3RBdHRyaWJ1dGVzJyksXG5cdGV4dHJhY3RVbmlmb3JtcyA9IHJlcXVpcmUoJy4vc2hhZGVyL2V4dHJhY3RVbmlmb3JtcycpLFxuXHRzZXRQcmVjaXNpb24gPSByZXF1aXJlKCcuL3NoYWRlci9zZXRQcmVjaXNpb24nKSxcblx0Z2VuZXJhdGVVbmlmb3JtQWNjZXNzT2JqZWN0ID0gcmVxdWlyZSgnLi9zaGFkZXIvZ2VuZXJhdGVVbmlmb3JtQWNjZXNzT2JqZWN0Jyk7XG5cbi8qKlxuICogSGVscGVyIGNsYXNzIHRvIGNyZWF0ZSBhIHdlYkdMIFNoYWRlclxuICpcbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIFBJWEkuZ2xDb3JlXG4gKiBAcGFyYW0gZ2wge1dlYkdMUmVuZGVyaW5nQ29udGV4dH1cbiAqIEBwYXJhbSB2ZXJ0ZXhTcmMge3N0cmluZ3xzdHJpbmdbXX0gVGhlIHZlcnRleCBzaGFkZXIgc291cmNlIGFzIGFuIGFycmF5IG9mIHN0cmluZ3MuXG4gKiBAcGFyYW0gZnJhZ21lbnRTcmMge3N0cmluZ3xzdHJpbmdbXX0gVGhlIGZyYWdtZW50IHNoYWRlciBzb3VyY2UgYXMgYW4gYXJyYXkgb2Ygc3RyaW5ncy5cbiAqIEBwYXJhbSBwcmVjaXNpb24ge3N0cmluZ30gVGhlIGZsb2F0IHByZWNpc2lvbiBvZiB0aGUgc2hhZGVyLiBPcHRpb25zIGFyZSAnbG93cCcsICdtZWRpdW1wJyBvciAnaGlnaHAnLlxuICogQHBhcmFtIGF0dHJpYnV0ZUxvY2F0aW9ucyB7b2JqZWN0fSBBIGtleSB2YWx1ZSBwYWlyIHNob3dpbmcgd2hpY2ggbG9jYXRpb24gZWFjdCBhdHRyaWJ1dGUgc2hvdWxkIHNpdCBlZyB7cG9zaXRpb246MCwgdXZzOjF9XG4gKi9cbnZhciBTaGFkZXIgPSBmdW5jdGlvbihnbCwgdmVydGV4U3JjLCBmcmFnbWVudFNyYywgcHJlY2lzaW9uLCBhdHRyaWJ1dGVMb2NhdGlvbnMpXG57XG5cdC8qKlxuXHQgKiBUaGUgY3VycmVudCBXZWJHTCByZW5kZXJpbmcgY29udGV4dFxuXHQgKlxuXHQgKiBAbWVtYmVyIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9XG5cdCAqL1xuXHR0aGlzLmdsID0gZ2w7XG5cblx0aWYocHJlY2lzaW9uKVxuXHR7XG5cdFx0dmVydGV4U3JjID0gc2V0UHJlY2lzaW9uKHZlcnRleFNyYywgcHJlY2lzaW9uKTtcblx0XHRmcmFnbWVudFNyYyA9IHNldFByZWNpc2lvbihmcmFnbWVudFNyYywgcHJlY2lzaW9uKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgc2hhZGVyIHByb2dyYW1cblx0ICpcblx0ICogQG1lbWJlciB7V2ViR0xQcm9ncmFtfVxuXHQgKi9cblx0Ly8gRmlyc3QgY29tcGlsZSB0aGUgcHJvZ3JhbS4uXG5cdHRoaXMucHJvZ3JhbSA9IGNvbXBpbGVQcm9ncmFtKGdsLCB2ZXJ0ZXhTcmMsIGZyYWdtZW50U3JjLCBhdHRyaWJ1dGVMb2NhdGlvbnMpO1xuXG5cdC8qKlxuXHQgKiBUaGUgYXR0cmlidXRlcyBvZiB0aGUgc2hhZGVyIGFzIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllc1xuXHQgKiB7XG5cdCAqIFx0dHlwZSxcblx0ICogXHRzaXplLFxuXHQgKiBcdGxvY2F0aW9uLFxuXHQgKiBcdHBvaW50ZXJcblx0ICogfVxuXHQgKiBAbWVtYmVyIHtPYmplY3R9XG5cdCAqL1xuXHQvLyBuZXh0IGV4dHJhY3QgdGhlIGF0dHJpYnV0ZXNcblx0dGhpcy5hdHRyaWJ1dGVzID0gZXh0cmFjdEF0dHJpYnV0ZXMoZ2wsIHRoaXMucHJvZ3JhbSk7XG5cbiAgICB0aGlzLnVuaWZvcm1EYXRhID0gZXh0cmFjdFVuaWZvcm1zKGdsLCB0aGlzLnByb2dyYW0pO1xuXG5cdC8qKlxuXHQgKiBUaGUgdW5pZm9ybXMgb2YgdGhlIHNoYWRlciBhcyBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXNcblx0ICoge1xuXHQgKiBcdGdsLFxuXHQgKiBcdGRhdGFcblx0ICogfVxuXHQgKiBAbWVtYmVyIHtPYmplY3R9XG5cdCAqL1xuXHR0aGlzLnVuaWZvcm1zID0gZ2VuZXJhdGVVbmlmb3JtQWNjZXNzT2JqZWN0KCBnbCwgdGhpcy51bmlmb3JtRGF0YSApO1xuXG59O1xuLyoqXG4gKiBVc2VzIHRoaXMgc2hhZGVyXG4gKiBcbiAqIEByZXR1cm4ge1BJWEkuZ2xDb3JlLkdMU2hhZGVyfSBSZXR1cm5zIGl0c2VsZi5cbiAqL1xuU2hhZGVyLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24oKVxue1xuXHR0aGlzLmdsLnVzZVByb2dyYW0odGhpcy5wcm9ncmFtKTtcblx0cmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIERlc3Ryb3lzIHRoaXMgc2hhZGVyXG4gKiBUT0RPXG4gKi9cblNoYWRlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKClcbntcblx0dGhpcy5hdHRyaWJ1dGVzID0gbnVsbDtcblx0dGhpcy51bmlmb3JtRGF0YSA9IG51bGw7XG5cdHRoaXMudW5pZm9ybXMgPSBudWxsO1xuXG5cdHZhciBnbCA9IHRoaXMuZ2w7XG5cdGdsLmRlbGV0ZVByb2dyYW0odGhpcy5wcm9ncmFtKTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBTaGFkZXI7XG4iLCJcbi8qKlxuICogSGVscGVyIGNsYXNzIHRvIGNyZWF0ZSBhIFdlYkdMIFRleHR1cmVcbiAqXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQSVhJLmdsQ29yZVxuICogQHBhcmFtIGdsIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IFRoZSBjdXJyZW50IFdlYkdMIGNvbnRleHRcbiAqIEBwYXJhbSB3aWR0aCB7bnVtYmVyfSB0aGUgd2lkdGggb2YgdGhlIHRleHR1cmVcbiAqIEBwYXJhbSBoZWlnaHQge251bWJlcn0gdGhlIGhlaWdodCBvZiB0aGUgdGV4dHVyZVxuICogQHBhcmFtIGZvcm1hdCB7bnVtYmVyfSB0aGUgcGl4ZWwgZm9ybWF0IG9mIHRoZSB0ZXh0dXJlLiBkZWZhdWx0cyB0byBnbC5SR0JBXG4gKiBAcGFyYW0gdHlwZSB7bnVtYmVyfSB0aGUgZ2wgdHlwZSBvZiB0aGUgdGV4dHVyZS4gZGVmYXVsdHMgdG8gZ2wuVU5TSUdORURfQllURVxuICovXG52YXIgVGV4dHVyZSA9IGZ1bmN0aW9uKGdsLCB3aWR0aCwgaGVpZ2h0LCBmb3JtYXQsIHR5cGUpXG57XG5cdC8qKlxuXHQgKiBUaGUgY3VycmVudCBXZWJHTCByZW5kZXJpbmcgY29udGV4dFxuXHQgKlxuXHQgKiBAbWVtYmVyIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9XG5cdCAqL1xuXHR0aGlzLmdsID0gZ2w7XG5cblxuXHQvKipcblx0ICogVGhlIFdlYkdMIHRleHR1cmVcblx0ICpcblx0ICogQG1lbWJlciB7V2ViR0xUZXh0dXJlfVxuXHQgKi9cblx0dGhpcy50ZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuXG5cdC8qKlxuXHQgKiBJZiBtaXBtYXBwaW5nIHdhcyB1c2VkIGZvciB0aGlzIHRleHR1cmUsIGVuYWJsZSBhbmQgZGlzYWJsZSB3aXRoIGVuYWJsZU1pcG1hcCgpXG5cdCAqXG5cdCAqIEBtZW1iZXIge0Jvb2xlYW59XG5cdCAqL1xuXHQvLyBzb21lIHNldHRpbmdzLi5cblx0dGhpcy5taXBtYXAgPSBmYWxzZTtcblxuXG5cdC8qKlxuXHQgKiBTZXQgdG8gdHJ1ZSB0byBlbmFibGUgcHJlLW11bHRpcGxpZWQgYWxwaGFcblx0ICpcblx0ICogQG1lbWJlciB7Qm9vbGVhbn1cblx0ICovXG5cdHRoaXMucHJlbXVsdGlwbHlBbHBoYSA9IGZhbHNlO1xuXG5cdC8qKlxuXHQgKiBUaGUgd2lkdGggb2YgdGV4dHVyZVxuXHQgKlxuXHQgKiBAbWVtYmVyIHtOdW1iZXJ9XG5cdCAqL1xuXHR0aGlzLndpZHRoID0gd2lkdGggfHwgLTE7XG5cdC8qKlxuXHQgKiBUaGUgaGVpZ2h0IG9mIHRleHR1cmVcblx0ICpcblx0ICogQG1lbWJlciB7TnVtYmVyfVxuXHQgKi9cblx0dGhpcy5oZWlnaHQgPSBoZWlnaHQgfHwgLTE7XG5cblx0LyoqXG5cdCAqIFRoZSBwaXhlbCBmb3JtYXQgb2YgdGhlIHRleHR1cmUuIGRlZmF1bHRzIHRvIGdsLlJHQkFcblx0ICpcblx0ICogQG1lbWJlciB7TnVtYmVyfVxuXHQgKi9cblx0dGhpcy5mb3JtYXQgPSBmb3JtYXQgfHwgZ2wuUkdCQTtcblxuXHQvKipcblx0ICogVGhlIGdsIHR5cGUgb2YgdGhlIHRleHR1cmUuIGRlZmF1bHRzIHRvIGdsLlVOU0lHTkVEX0JZVEVcblx0ICpcblx0ICogQG1lbWJlciB7TnVtYmVyfVxuXHQgKi9cblx0dGhpcy50eXBlID0gdHlwZSB8fCBnbC5VTlNJR05FRF9CWVRFO1xuXG5cbn07XG5cbi8qKlxuICogVXBsb2FkcyB0aGlzIHRleHR1cmUgdG8gdGhlIEdQVVxuICogQHBhcmFtIHNvdXJjZSB7SFRNTEltYWdlRWxlbWVudHxJbWFnZURhdGF8SFRNTFZpZGVvRWxlbWVudH0gdGhlIHNvdXJjZSBpbWFnZSBvZiB0aGUgdGV4dHVyZVxuICovXG5UZXh0dXJlLnByb3RvdHlwZS51cGxvYWQgPSBmdW5jdGlvbihzb3VyY2UpXG57XG5cdHRoaXMuYmluZCgpO1xuXG5cdHZhciBnbCA9IHRoaXMuZ2w7XG5cblxuXHRnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wsIHRoaXMucHJlbXVsdGlwbHlBbHBoYSk7XG5cblx0dmFyIG5ld1dpZHRoID0gc291cmNlLnZpZGVvV2lkdGggfHwgc291cmNlLndpZHRoO1xuXHR2YXIgbmV3SGVpZ2h0ID0gc291cmNlLnZpZGVvSGVpZ2h0IHx8IHNvdXJjZS5oZWlnaHQ7XG5cblx0aWYobmV3SGVpZ2h0ICE9PSB0aGlzLmhlaWdodCB8fCBuZXdXaWR0aCAhPT0gdGhpcy53aWR0aClcblx0e1xuXHRcdGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgdGhpcy5mb3JtYXQsIHRoaXMuZm9ybWF0LCB0aGlzLnR5cGUsIHNvdXJjZSk7XG5cdH1cblx0ZWxzZVxuXHR7XG4gICAgXHRnbC50ZXhTdWJJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIDAsIDAsIHRoaXMuZm9ybWF0LCB0aGlzLnR5cGUsIHNvdXJjZSk7XG5cdH1cblxuXHQvLyBpZiB0aGUgc291cmNlIGlzIGEgdmlkZW8sIHdlIG5lZWQgdG8gdXNlIHRoZSB2aWRlb1dpZHRoIC8gdmlkZW9IZWlnaHQgcHJvcGVydGllcyBhcyB3aWR0aCAvIGhlaWdodCB3aWxsIGJlIGluY29ycmVjdC5cblx0dGhpcy53aWR0aCA9IG5ld1dpZHRoO1xuXHR0aGlzLmhlaWdodCA9IG5ld0hlaWdodDtcblxufTtcblxudmFyIEZMT0FUSU5HX1BPSU5UX0FWQUlMQUJMRSA9IGZhbHNlO1xuXG4vKipcbiAqIFVzZSBhIGRhdGEgc291cmNlIGFuZCB1cGxvYWRzIHRoaXMgdGV4dHVyZSB0byB0aGUgR1BVXG4gKiBAcGFyYW0gZGF0YSB7VHlwZWRBcnJheX0gdGhlIGRhdGEgdG8gdXBsb2FkIHRvIHRoZSB0ZXh0dXJlXG4gKiBAcGFyYW0gd2lkdGgge251bWJlcn0gdGhlIG5ldyB3aWR0aCBvZiB0aGUgdGV4dHVyZVxuICogQHBhcmFtIGhlaWdodCB7bnVtYmVyfSB0aGUgbmV3IGhlaWdodCBvZiB0aGUgdGV4dHVyZVxuICovXG5UZXh0dXJlLnByb3RvdHlwZS51cGxvYWREYXRhID0gZnVuY3Rpb24oZGF0YSwgd2lkdGgsIGhlaWdodClcbntcblx0dGhpcy5iaW5kKCk7XG5cblx0dmFyIGdsID0gdGhpcy5nbDtcblxuXG5cdGlmKGRhdGEgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpXG5cdHtcblx0XHRpZighRkxPQVRJTkdfUE9JTlRfQVZBSUxBQkxFKVxuXHRcdHtcblx0XHRcdHZhciBleHQgPSBnbC5nZXRFeHRlbnNpb24oXCJPRVNfdGV4dHVyZV9mbG9hdFwiKTtcblxuXHRcdFx0aWYoZXh0KVxuXHRcdFx0e1xuXHRcdFx0XHRGTE9BVElOR19QT0lOVF9BVkFJTEFCTEUgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZVxuXHRcdFx0e1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ2Zsb2F0aW5nIHBvaW50IHRleHR1cmVzIG5vdCBhdmFpbGFibGUnKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLnR5cGUgPSBnbC5GTE9BVDtcblx0fVxuXHRlbHNlXG5cdHtcblx0XHQvLyBUT0RPIHN1cHBvcnQgZm9yIG90aGVyIHR5cGVzXG5cdFx0dGhpcy50eXBlID0gdGhpcy50eXBlIHx8IGdsLlVOU0lHTkVEX0JZVEU7XG5cdH1cblxuXHQvLyB3aGF0IHR5cGUgb2YgZGF0YT9cblx0Z2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMLCB0aGlzLnByZW11bHRpcGx5QWxwaGEpO1xuXG5cblx0aWYod2lkdGggIT09IHRoaXMud2lkdGggfHwgaGVpZ2h0ICE9PSB0aGlzLmhlaWdodClcblx0e1xuXHRcdGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgdGhpcy5mb3JtYXQsICB3aWR0aCwgaGVpZ2h0LCAwLCB0aGlzLmZvcm1hdCwgdGhpcy50eXBlLCBkYXRhIHx8IG51bGwpO1xuXHR9XG5cdGVsc2Vcblx0e1xuXHRcdGdsLnRleFN1YkltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgMCwgMCwgd2lkdGgsIGhlaWdodCwgdGhpcy5mb3JtYXQsIHRoaXMudHlwZSwgZGF0YSB8fCBudWxsKTtcblx0fVxuXG5cdHRoaXMud2lkdGggPSB3aWR0aDtcblx0dGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG5cblxuLy9cdHRleFN1YkltYWdlMkRcbn07XG5cbi8qKlxuICogQmluZHMgdGhlIHRleHR1cmVcbiAqIEBwYXJhbSAgbG9jYXRpb25cbiAqL1xuVGV4dHVyZS5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uKGxvY2F0aW9uKVxue1xuXHR2YXIgZ2wgPSB0aGlzLmdsO1xuXG5cdGlmKGxvY2F0aW9uICE9PSB1bmRlZmluZWQpXG5cdHtcblx0XHRnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwICsgbG9jYXRpb24pO1xuXHR9XG5cblx0Z2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlKTtcbn07XG5cbi8qKlxuICogVW5iaW5kcyB0aGUgdGV4dHVyZVxuICovXG5UZXh0dXJlLnByb3RvdHlwZS51bmJpbmQgPSBmdW5jdGlvbigpXG57XG5cdHZhciBnbCA9IHRoaXMuZ2w7XG5cdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIG51bGwpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0gbGluZWFyIHtCb29sZWFufSBpZiB3ZSB3YW50IHRvIHVzZSBsaW5lYXIgZmlsdGVyaW5nIG9yIG5lYXJlc3QgbmVpZ2hib3VyIGludGVycG9sYXRpb25cbiAqL1xuVGV4dHVyZS5wcm90b3R5cGUubWluRmlsdGVyID0gZnVuY3Rpb24oIGxpbmVhciApXG57XG5cdHZhciBnbCA9IHRoaXMuZ2w7XG5cblx0dGhpcy5iaW5kKCk7XG5cblx0aWYodGhpcy5taXBtYXApXG5cdHtcblx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgbGluZWFyID8gZ2wuTElORUFSX01JUE1BUF9MSU5FQVIgOiBnbC5ORUFSRVNUX01JUE1BUF9ORUFSRVNUKTtcblx0fVxuXHRlbHNlXG5cdHtcblx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgbGluZWFyID8gZ2wuTElORUFSIDogZ2wuTkVBUkVTVCk7XG5cdH1cbn07XG5cbi8qKlxuICogQHBhcmFtIGxpbmVhciB7Qm9vbGVhbn0gaWYgd2Ugd2FudCB0byB1c2UgbGluZWFyIGZpbHRlcmluZyBvciBuZWFyZXN0IG5laWdoYm91ciBpbnRlcnBvbGF0aW9uXG4gKi9cblRleHR1cmUucHJvdG90eXBlLm1hZ0ZpbHRlciA9IGZ1bmN0aW9uKCBsaW5lYXIgKVxue1xuXHR2YXIgZ2wgPSB0aGlzLmdsO1xuXG5cdHRoaXMuYmluZCgpO1xuXG5cdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBsaW5lYXIgPyBnbC5MSU5FQVIgOiBnbC5ORUFSRVNUKTtcbn07XG5cbi8qKlxuICogRW5hYmxlcyBtaXBtYXBwaW5nXG4gKi9cblRleHR1cmUucHJvdG90eXBlLmVuYWJsZU1pcG1hcCA9IGZ1bmN0aW9uKClcbntcblx0dmFyIGdsID0gdGhpcy5nbDtcblxuXHR0aGlzLmJpbmQoKTtcblxuXHR0aGlzLm1pcG1hcCA9IHRydWU7XG5cblx0Z2wuZ2VuZXJhdGVNaXBtYXAoZ2wuVEVYVFVSRV8yRCk7XG59O1xuXG4vKipcbiAqIEVuYWJsZXMgbGluZWFyIGZpbHRlcmluZ1xuICovXG5UZXh0dXJlLnByb3RvdHlwZS5lbmFibGVMaW5lYXJTY2FsaW5nID0gZnVuY3Rpb24oKVxue1xuXHR0aGlzLm1pbkZpbHRlcih0cnVlKTtcblx0dGhpcy5tYWdGaWx0ZXIodHJ1ZSk7XG59O1xuXG4vKipcbiAqIEVuYWJsZXMgbmVhcmVzdCBuZWlnaGJvdXIgaW50ZXJwb2xhdGlvblxuICovXG5UZXh0dXJlLnByb3RvdHlwZS5lbmFibGVOZWFyZXN0U2NhbGluZyA9IGZ1bmN0aW9uKClcbntcblx0dGhpcy5taW5GaWx0ZXIoZmFsc2UpO1xuXHR0aGlzLm1hZ0ZpbHRlcihmYWxzZSk7XG59O1xuXG4vKipcbiAqIEVuYWJsZXMgY2xhbXBpbmcgb24gdGhlIHRleHR1cmUgc28gV2ViR0wgd2lsbCBub3QgcmVwZWF0IGl0XG4gKi9cblRleHR1cmUucHJvdG90eXBlLmVuYWJsZVdyYXBDbGFtcCA9IGZ1bmN0aW9uKClcbntcblx0dmFyIGdsID0gdGhpcy5nbDtcblxuXHR0aGlzLmJpbmQoKTtcblxuXHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcbn07XG5cbi8qKlxuICogRW5hYmxlIHRpbGluZyBvbiB0aGUgdGV4dHVyZVxuICovXG5UZXh0dXJlLnByb3RvdHlwZS5lbmFibGVXcmFwUmVwZWF0ID0gZnVuY3Rpb24oKVxue1xuXHR2YXIgZ2wgPSB0aGlzLmdsO1xuXG5cdHRoaXMuYmluZCgpO1xuXG5cdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLlJFUEVBVCk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuUkVQRUFUKTtcbn07XG5cblRleHR1cmUucHJvdG90eXBlLmVuYWJsZVdyYXBNaXJyb3JSZXBlYXQgPSBmdW5jdGlvbigpXG57XG5cdHZhciBnbCA9IHRoaXMuZ2w7XG5cblx0dGhpcy5iaW5kKCk7XG5cblx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuTUlSUk9SRURfUkVQRUFUKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5NSVJST1JFRF9SRVBFQVQpO1xufTtcblxuXG4vKipcbiAqIERlc3Ryb3lzIHRoaXMgdGV4dHVyZVxuICovXG5UZXh0dXJlLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKVxue1xuXHR2YXIgZ2wgPSB0aGlzLmdsO1xuXHQvL1RPRE9cblx0Z2wuZGVsZXRlVGV4dHVyZSh0aGlzLnRleHR1cmUpO1xufTtcblxuLyoqXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0gZ2wge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gVGhlIGN1cnJlbnQgV2ViR0wgY29udGV4dFxuICogQHBhcmFtIHNvdXJjZSB7SFRNTEltYWdlRWxlbWVudHxJbWFnZURhdGF9IHRoZSBzb3VyY2UgaW1hZ2Ugb2YgdGhlIHRleHR1cmVcbiAqIEBwYXJhbSBwcmVtdWx0aXBseUFscGhhIHtCb29sZWFufSBJZiB3ZSB3YW50IHRvIHVzZSBwcmUtbXVsdGlwbGllZCBhbHBoYVxuICovXG5UZXh0dXJlLmZyb21Tb3VyY2UgPSBmdW5jdGlvbihnbCwgc291cmNlLCBwcmVtdWx0aXBseUFscGhhKVxue1xuXHR2YXIgdGV4dHVyZSA9IG5ldyBUZXh0dXJlKGdsKTtcblx0dGV4dHVyZS5wcmVtdWx0aXBseUFscGhhID0gcHJlbXVsdGlwbHlBbHBoYSB8fCBmYWxzZTtcblx0dGV4dHVyZS51cGxvYWQoc291cmNlKTtcblxuXHRyZXR1cm4gdGV4dHVyZTtcbn07XG5cbi8qKlxuICogQHN0YXRpY1xuICogQHBhcmFtIGdsIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IFRoZSBjdXJyZW50IFdlYkdMIGNvbnRleHRcbiAqIEBwYXJhbSBkYXRhIHtUeXBlZEFycmF5fSB0aGUgZGF0YSB0byB1cGxvYWQgdG8gdGhlIHRleHR1cmVcbiAqIEBwYXJhbSB3aWR0aCB7bnVtYmVyfSB0aGUgbmV3IHdpZHRoIG9mIHRoZSB0ZXh0dXJlXG4gKiBAcGFyYW0gaGVpZ2h0IHtudW1iZXJ9IHRoZSBuZXcgaGVpZ2h0IG9mIHRoZSB0ZXh0dXJlXG4gKi9cblRleHR1cmUuZnJvbURhdGEgPSBmdW5jdGlvbihnbCwgZGF0YSwgd2lkdGgsIGhlaWdodClcbntcblx0Ly9jb25zb2xlLmxvZyhkYXRhLCB3aWR0aCwgaGVpZ2h0KTtcblx0dmFyIHRleHR1cmUgPSBuZXcgVGV4dHVyZShnbCk7XG5cdHRleHR1cmUudXBsb2FkRGF0YShkYXRhLCB3aWR0aCwgaGVpZ2h0KTtcblxuXHRyZXR1cm4gdGV4dHVyZTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBUZXh0dXJlO1xuIiwiXG4vLyBzdGF0ZSBvYmplY3QvL1xudmFyIHNldFZlcnRleEF0dHJpYkFycmF5cyA9IHJlcXVpcmUoICcuL3NldFZlcnRleEF0dHJpYkFycmF5cycgKTtcblxuLyoqXG4gKiBIZWxwZXIgY2xhc3MgdG8gd29yayB3aXRoIFdlYkdMIFZlcnRleEFycmF5T2JqZWN0cyAodmFvcylcbiAqIE9ubHkgd29ya3MgaWYgV2ViR0wgZXh0ZW5zaW9ucyBhcmUgZW5hYmxlZCAodGhleSB1c3VhbGx5IGFyZSlcbiAqXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQSVhJLmdsQ29yZVxuICogQHBhcmFtIGdsIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IFRoZSBjdXJyZW50IFdlYkdMIHJlbmRlcmluZyBjb250ZXh0XG4gKi9cbmZ1bmN0aW9uIFZlcnRleEFycmF5T2JqZWN0KGdsLCBzdGF0ZSlcbntcbiAgICB0aGlzLm5hdGl2ZVZhb0V4dGVuc2lvbiA9IG51bGw7XG5cbiAgICBpZighVmVydGV4QXJyYXlPYmplY3QuRk9SQ0VfTkFUSVZFKVxuICAgIHtcbiAgICAgICAgdGhpcy5uYXRpdmVWYW9FeHRlbnNpb24gPSBnbC5nZXRFeHRlbnNpb24oJ09FU192ZXJ0ZXhfYXJyYXlfb2JqZWN0JykgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnbC5nZXRFeHRlbnNpb24oJ01PWl9PRVNfdmVydGV4X2FycmF5X29iamVjdCcpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2wuZ2V0RXh0ZW5zaW9uKCdXRUJLSVRfT0VTX3ZlcnRleF9hcnJheV9vYmplY3QnKTtcbiAgICB9XG5cbiAgICB0aGlzLm5hdGl2ZVN0YXRlID0gc3RhdGU7XG5cbiAgICBpZih0aGlzLm5hdGl2ZVZhb0V4dGVuc2lvbilcbiAgICB7XG4gICAgICAgIHRoaXMubmF0aXZlVmFvID0gdGhpcy5uYXRpdmVWYW9FeHRlbnNpb24uY3JlYXRlVmVydGV4QXJyYXlPRVMoKTtcblxuICAgICAgICB2YXIgbWF4QXR0cmlicyA9IGdsLmdldFBhcmFtZXRlcihnbC5NQVhfVkVSVEVYX0FUVFJJQlMpO1xuXG4gICAgICAgIC8vIFZBTyAtIG92ZXJ3cml0ZSB0aGUgc3RhdGUuLlxuICAgICAgICB0aGlzLm5hdGl2ZVN0YXRlID0ge1xuICAgICAgICAgICAgdGVtcEF0dHJpYlN0YXRlOiBuZXcgQXJyYXkobWF4QXR0cmlicyksXG4gICAgICAgICAgICBhdHRyaWJTdGF0ZTogbmV3IEFycmF5KG1heEF0dHJpYnMpXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgV2ViR0wgcmVuZGVyaW5nIGNvbnRleHRcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge1dlYkdMUmVuZGVyaW5nQ29udGV4dH1cbiAgICAgKi9cbiAgICB0aGlzLmdsID0gZ2w7XG5cbiAgICAvKipcbiAgICAgKiBBbiBhcnJheSBvZiBhdHRyaWJ1dGVzXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmF0dHJpYnV0ZXMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge1BJWEkuZ2xDb3JlLkdMQnVmZmVyfVxuICAgICAqL1xuICAgIHRoaXMuaW5kZXhCdWZmZXIgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQSBib29sZWFuIGZsYWdcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge0Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xufVxuXG5WZXJ0ZXhBcnJheU9iamVjdC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBWZXJ0ZXhBcnJheU9iamVjdDtcbm1vZHVsZS5leHBvcnRzID0gVmVydGV4QXJyYXlPYmplY3Q7XG5cbi8qKlxuKiBTb21lIGRldmljZXMgYmVoYXZlIGEgYml0IGZ1bm55IHdoZW4gdXNpbmcgdGhlIG5ld2VyIGV4dGVuc2lvbnMgKGltIGxvb2tpbmcgYXQgeW91IGlwYWQgMiEpXG4qIElmIHlvdSBmaW5kIG9uIG9sZGVyIGRldmljZXMgdGhhdCB0aGluZ3MgaGF2ZSBnb25lIGEgYml0IHdlaXJkIHRoZW4gc2V0IHRoaXMgdG8gdHJ1ZS5cbiovXG4vKipcbiAqIExldHMgdGhlIFZBTyBrbm93IGlmIHlvdSBzaG91bGQgdXNlIHRoZSBXZWJHTCBleHRlbnNpb24gb3IgdGhlIG5hdGl2ZSBtZXRob2RzLlxuICogU29tZSBkZXZpY2VzIGJlaGF2ZSBhIGJpdCBmdW5ueSB3aGVuIHVzaW5nIHRoZSBuZXdlciBleHRlbnNpb25zIChpbSBsb29raW5nIGF0IHlvdSBpcGFkIDIhKVxuICogSWYgeW91IGZpbmQgb24gb2xkZXIgZGV2aWNlcyB0aGF0IHRoaW5ncyBoYXZlIGdvbmUgYSBiaXQgd2VpcmQgdGhlbiBzZXQgdGhpcyB0byB0cnVlLlxuICogQHN0YXRpY1xuICogQHByb3BlcnR5IHtCb29sZWFufSBGT1JDRV9OQVRJVkVcbiAqL1xuVmVydGV4QXJyYXlPYmplY3QuRk9SQ0VfTkFUSVZFID0gZmFsc2U7XG5cbi8qKlxuICogQmluZHMgdGhlIGJ1ZmZlclxuICovXG5WZXJ0ZXhBcnJheU9iamVjdC5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uKClcbntcbiAgICBpZih0aGlzLm5hdGl2ZVZhbylcbiAgICB7XG4gICAgICAgIHRoaXMubmF0aXZlVmFvRXh0ZW5zaW9uLmJpbmRWZXJ0ZXhBcnJheU9FUyh0aGlzLm5hdGl2ZVZhbyk7XG5cbiAgICAgICAgaWYodGhpcy5kaXJ0eSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5hY3RpdmF0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaW5kZXhCdWZmZXIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuaW5kZXhCdWZmZXIuYmluZCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHRoaXMuYWN0aXZhdGUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogVW5iaW5kcyB0aGUgYnVmZmVyXG4gKi9cblZlcnRleEFycmF5T2JqZWN0LnByb3RvdHlwZS51bmJpbmQgPSBmdW5jdGlvbigpXG57XG4gICAgaWYodGhpcy5uYXRpdmVWYW8pXG4gICAge1xuICAgICAgICB0aGlzLm5hdGl2ZVZhb0V4dGVuc2lvbi5iaW5kVmVydGV4QXJyYXlPRVMobnVsbCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFVzZXMgdGhpcyB2YW9cbiAqL1xuVmVydGV4QXJyYXlPYmplY3QucHJvdG90eXBlLmFjdGl2YXRlID0gZnVuY3Rpb24oKVxue1xuXG4gICAgdmFyIGdsID0gdGhpcy5nbDtcbiAgICB2YXIgbGFzdEJ1ZmZlciA9IG51bGw7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYXR0cmlidXRlcy5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIHZhciBhdHRyaWIgPSB0aGlzLmF0dHJpYnV0ZXNbaV07XG5cbiAgICAgICAgaWYobGFzdEJ1ZmZlciAhPT0gYXR0cmliLmJ1ZmZlcilcbiAgICAgICAge1xuICAgICAgICAgICAgYXR0cmliLmJ1ZmZlci5iaW5kKCk7XG4gICAgICAgICAgICBsYXN0QnVmZmVyID0gYXR0cmliLmJ1ZmZlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoYXR0cmliLmF0dHJpYnV0ZS5sb2NhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWIuYXR0cmlidXRlLnNpemUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmliLnR5cGUgfHwgZ2wuRkxPQVQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmliLm5vcm1hbGl6ZWQgfHwgZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmliLnN0cmlkZSB8fCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYi5zdGFydCB8fCAwKTtcbiAgICB9XG5cbiAgICBzZXRWZXJ0ZXhBdHRyaWJBcnJheXMoZ2wsIHRoaXMuYXR0cmlidXRlcywgdGhpcy5uYXRpdmVTdGF0ZSk7XG5cbiAgICBpZih0aGlzLmluZGV4QnVmZmVyKVxuICAgIHtcbiAgICAgICAgdGhpcy5pbmRleEJ1ZmZlci5iaW5kKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqXG4gKiBAcGFyYW0gYnVmZmVyICAgICB7UElYSS5nbC5HTEJ1ZmZlcn1cbiAqIEBwYXJhbSBhdHRyaWJ1dGUgIHsqfVxuICogQHBhcmFtIHR5cGUgICAgICAge1N0cmluZ31cbiAqIEBwYXJhbSBub3JtYWxpemVkIHtCb29sZWFufVxuICogQHBhcmFtIHN0cmlkZSAgICAge051bWJlcn1cbiAqIEBwYXJhbSBzdGFydCAgICAgIHtOdW1iZXJ9XG4gKi9cblZlcnRleEFycmF5T2JqZWN0LnByb3RvdHlwZS5hZGRBdHRyaWJ1dGUgPSBmdW5jdGlvbihidWZmZXIsIGF0dHJpYnV0ZSwgdHlwZSwgbm9ybWFsaXplZCwgc3RyaWRlLCBzdGFydClcbntcbiAgICB0aGlzLmF0dHJpYnV0ZXMucHVzaCh7XG4gICAgICAgIGJ1ZmZlcjogICAgIGJ1ZmZlcixcbiAgICAgICAgYXR0cmlidXRlOiAgYXR0cmlidXRlLFxuXG4gICAgICAgIGxvY2F0aW9uOiAgIGF0dHJpYnV0ZS5sb2NhdGlvbixcbiAgICAgICAgdHlwZTogICAgICAgdHlwZSB8fCB0aGlzLmdsLkZMT0FULFxuICAgICAgICBub3JtYWxpemVkOiBub3JtYWxpemVkIHx8IGZhbHNlLFxuICAgICAgICBzdHJpZGU6ICAgICBzdHJpZGUgfHwgMCxcbiAgICAgICAgc3RhcnQ6ICAgICAgc3RhcnQgfHwgMFxuICAgIH0pO1xuXG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICpcbiAqIEBwYXJhbSBidWZmZXIgICB7UElYSS5nbC5HTEJ1ZmZlcn1cbiAqL1xuVmVydGV4QXJyYXlPYmplY3QucHJvdG90eXBlLmFkZEluZGV4ID0gZnVuY3Rpb24oYnVmZmVyLyosIG9wdGlvbnMqLylcbntcbiAgICB0aGlzLmluZGV4QnVmZmVyID0gYnVmZmVyO1xuXG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogVW5iaW5kcyB0aGlzIHZhbyBhbmQgZGlzYWJsZXMgaXRcbiAqL1xuVmVydGV4QXJyYXlPYmplY3QucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKVxue1xuICAgIC8vIHZhciBnbCA9IHRoaXMuZ2w7XG5cbiAgICAvLyBUT0RPIC0gc2hvdWxkIHRoaXMgZnVuY3Rpb24gdW5iaW5kIGFmdGVyIGNsZWFyP1xuICAgIC8vIGZvciBub3csIG5vIGJ1dCBsZXRzIHNlZSB3aGF0IGhhcHBlbnMgaW4gdGhlIHJlYWwgd29ybGQhXG4gICAgaWYodGhpcy5uYXRpdmVWYW8pXG4gICAge1xuICAgICAgICB0aGlzLm5hdGl2ZVZhb0V4dGVuc2lvbi5iaW5kVmVydGV4QXJyYXlPRVModGhpcy5uYXRpdmVWYW8pO1xuICAgIH1cblxuICAgIHRoaXMuYXR0cmlidXRlcy5sZW5ndGggPSAwO1xuICAgIHRoaXMuaW5kZXhCdWZmZXIgPSBudWxsO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB0eXBlICB7TnVtYmVyfVxuICogQHBhcmFtIHNpemUgIHtOdW1iZXJ9XG4gKiBAcGFyYW0gc3RhcnQge051bWJlcn1cbiAqL1xuVmVydGV4QXJyYXlPYmplY3QucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbih0eXBlLCBzaXplLCBzdGFydClcbntcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuXG4gICAgaWYodGhpcy5pbmRleEJ1ZmZlcilcbiAgICB7XG4gICAgICAgIGdsLmRyYXdFbGVtZW50cyh0eXBlLCBzaXplIHx8IHRoaXMuaW5kZXhCdWZmZXIuZGF0YS5sZW5ndGgsIGdsLlVOU0lHTkVEX1NIT1JULCAoc3RhcnQgfHwgMCkgKiAyICk7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIC8vIFRPRE8gbmVlZCBhIGJldHRlciB3YXkgdG8gY2FsY3VsYXRlIHNpemUuLlxuICAgICAgICBnbC5kcmF3QXJyYXlzKHR5cGUsIHN0YXJ0LCBzaXplIHx8IHRoaXMuZ2V0U2l6ZSgpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRGVzdHJveSB0aGlzIHZhb1xuICovXG5WZXJ0ZXhBcnJheU9iamVjdC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKClcbntcbiAgICAvLyBsb3NlIHJlZmVyZW5jZXNcbiAgICB0aGlzLmdsID0gbnVsbDtcbiAgICB0aGlzLmluZGV4QnVmZmVyID0gbnVsbDtcbiAgICB0aGlzLmF0dHJpYnV0ZXMgPSBudWxsO1xuICAgIHRoaXMubmF0aXZlU3RhdGUgPSBudWxsO1xuXG4gICAgaWYodGhpcy5uYXRpdmVWYW8pXG4gICAge1xuICAgICAgICB0aGlzLm5hdGl2ZVZhb0V4dGVuc2lvbi5kZWxldGVWZXJ0ZXhBcnJheU9FUyh0aGlzLm5hdGl2ZVZhbyk7XG4gICAgfVxuXG4gICAgdGhpcy5uYXRpdmVWYW9FeHRlbnNpb24gPSBudWxsO1xuICAgIHRoaXMubmF0aXZlVmFvID0gbnVsbDtcbn07XG5cblZlcnRleEFycmF5T2JqZWN0LnByb3RvdHlwZS5nZXRTaXplID0gZnVuY3Rpb24oKVxue1xuICAgIHZhciBhdHRyaWIgPSB0aGlzLmF0dHJpYnV0ZXNbMF07XG4gICAgcmV0dXJuIGF0dHJpYi5idWZmZXIuZGF0YS5sZW5ndGggLyAoKCBhdHRyaWIuc3RyaWRlLzQgKSB8fCBhdHRyaWIuYXR0cmlidXRlLnNpemUpO1xufTtcbiIsIlxuLyoqXG4gKiBIZWxwZXIgY2xhc3MgdG8gY3JlYXRlIGEgd2ViR0wgQ29udGV4dFxuICpcbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIFBJWEkuZ2xDb3JlXG4gKiBAcGFyYW0gY2FudmFzIHtIVE1MQ2FudmFzRWxlbWVudH0gdGhlIGNhbnZhcyBlbGVtZW50IHRoYXQgd2Ugd2lsbCBnZXQgdGhlIGNvbnRleHQgZnJvbVxuICogQHBhcmFtIG9wdGlvbnMge09iamVjdH0gQW4gb3B0aW9ucyBvYmplY3QgdGhhdCBnZXRzIHBhc3NlZCBpbiB0byB0aGUgY2FudmFzIGVsZW1lbnQgY29udGFpbmluZyB0aGUgY29udGV4dCBhdHRyaWJ1dGVzLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9IVE1MQ2FudmFzRWxlbWVudC9nZXRDb250ZXh0IGZvciB0aGUgb3B0aW9ucyBhdmFpbGFibGVcbiAqIEByZXR1cm4ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gdGhlIFdlYkdMIGNvbnRleHRcbiAqL1xudmFyIGNyZWF0ZUNvbnRleHQgPSBmdW5jdGlvbihjYW52YXMsIG9wdGlvbnMpXG57XG4gICAgdmFyIGdsID0gY2FudmFzLmdldENvbnRleHQoJ3dlYmdsJywgb3B0aW9ucykgfHwgXG4gICAgICAgICBjYW52YXMuZ2V0Q29udGV4dCgnZXhwZXJpbWVudGFsLXdlYmdsJywgb3B0aW9ucyk7XG5cbiAgICBpZiAoIWdsKVxuICAgIHtcbiAgICAgICAgLy8gZmFpbCwgbm90IGFibGUgdG8gZ2V0IGEgY29udGV4dFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHdlYkdMLiBUcnkgdXNpbmcgdGhlIGNhbnZhcyByZW5kZXJlcicpO1xuICAgIH1cblxuICAgIHJldHVybiBnbDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlQ29udGV4dDtcbiIsInZhciBnbCA9IHtcbiAgICBjcmVhdGVDb250ZXh0OiAgICAgICAgICByZXF1aXJlKCcuL2NyZWF0ZUNvbnRleHQnKSxcbiAgICBzZXRWZXJ0ZXhBdHRyaWJBcnJheXM6ICByZXF1aXJlKCcuL3NldFZlcnRleEF0dHJpYkFycmF5cycpLFxuICAgIEdMQnVmZmVyOiAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vR0xCdWZmZXInKSxcbiAgICBHTEZyYW1lYnVmZmVyOiAgICAgICAgICByZXF1aXJlKCcuL0dMRnJhbWVidWZmZXInKSxcbiAgICBHTFNoYWRlcjogICAgICAgICAgICAgICByZXF1aXJlKCcuL0dMU2hhZGVyJyksXG4gICAgR0xUZXh0dXJlOiAgICAgICAgICAgICAgcmVxdWlyZSgnLi9HTFRleHR1cmUnKSxcbiAgICBWZXJ0ZXhBcnJheU9iamVjdDogICAgICByZXF1aXJlKCcuL1ZlcnRleEFycmF5T2JqZWN0JyksXG4gICAgc2hhZGVyOiAgICAgICAgICAgICAgICAgcmVxdWlyZSgnLi9zaGFkZXInKVxufTtcblxuLy8gRXhwb3J0IGZvciBOb2RlLWNvbXBhdGlibGUgZW52aXJvbm1lbnRzXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpXG57XG4gICAgLy8gRXhwb3J0IHRoZSBtb2R1bGVcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGdsO1xufVxuXG4vLyBBZGQgdG8gdGhlIGJyb3dzZXIgd2luZG93IHBpeGkuZ2xcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJylcbntcbiAgICAvLyBhZGQgdGhlIHdpbmRvdyBvYmplY3RcbiAgICB3aW5kb3cuUElYSSA9IHdpbmRvdy5QSVhJIHx8IHt9O1xuICAgIHdpbmRvdy5QSVhJLmdsQ29yZSA9IGdsO1xufVxuIiwiLy8gdmFyIEdMX01BUCA9IHt9O1xuXG4vKipcbiAqIEBwYXJhbSBnbCB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBUaGUgY3VycmVudCBXZWJHTCBjb250ZXh0XG4gKiBAcGFyYW0gYXR0cmlicyB7Kn1cbiAqIEBwYXJhbSBzdGF0ZSB7Kn1cbiAqL1xudmFyIHNldFZlcnRleEF0dHJpYkFycmF5cyA9IGZ1bmN0aW9uIChnbCwgYXR0cmlicywgc3RhdGUpXG57XG4gICAgdmFyIGk7XG4gICAgaWYoc3RhdGUpXG4gICAge1xuICAgICAgICB2YXIgdGVtcEF0dHJpYlN0YXRlID0gc3RhdGUudGVtcEF0dHJpYlN0YXRlLFxuICAgICAgICAgICAgYXR0cmliU3RhdGUgPSBzdGF0ZS5hdHRyaWJTdGF0ZTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGVtcEF0dHJpYlN0YXRlLmxlbmd0aDsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICB0ZW1wQXR0cmliU3RhdGVbaV0gPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNldCB0aGUgbmV3IGF0dHJpYnNcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGF0dHJpYnMubGVuZ3RoOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRlbXBBdHRyaWJTdGF0ZVthdHRyaWJzW2ldLmF0dHJpYnV0ZS5sb2NhdGlvbl0gPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGF0dHJpYlN0YXRlLmxlbmd0aDsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoYXR0cmliU3RhdGVbaV0gIT09IHRlbXBBdHRyaWJTdGF0ZVtpXSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBhdHRyaWJTdGF0ZVtpXSA9IHRlbXBBdHRyaWJTdGF0ZVtpXTtcblxuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5hdHRyaWJTdGF0ZVtpXSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBnbC5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkoaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGF0dHJpYnMubGVuZ3RoOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBhdHRyaWIgPSBhdHRyaWJzW2ldO1xuICAgICAgICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoYXR0cmliLmF0dHJpYnV0ZS5sb2NhdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHNldFZlcnRleEF0dHJpYkFycmF5cztcbiIsIlxuLyoqXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQSVhJLmdsQ29yZS5zaGFkZXJcbiAqIEBwYXJhbSBnbCB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBUaGUgY3VycmVudCBXZWJHTCBjb250ZXh0IHtXZWJHTFByb2dyYW19XG4gKiBAcGFyYW0gdmVydGV4U3JjIHtzdHJpbmd8c3RyaW5nW119IFRoZSB2ZXJ0ZXggc2hhZGVyIHNvdXJjZSBhcyBhbiBhcnJheSBvZiBzdHJpbmdzLlxuICogQHBhcmFtIGZyYWdtZW50U3JjIHtzdHJpbmd8c3RyaW5nW119IFRoZSBmcmFnbWVudCBzaGFkZXIgc291cmNlIGFzIGFuIGFycmF5IG9mIHN0cmluZ3MuXG4gKiBAcGFyYW0gYXR0cmlidXRlTG9jYXRpb25zIHtPYmplY3R9IEFuIGF0dHJpYnV0ZSBsb2NhdGlvbiBtYXAgdGhhdCBsZXRzIHlvdSBtYW51YWxseSBzZXQgdGhlIGF0dHJpYnV0ZSBsb2NhdGlvbnNcbiAqIEByZXR1cm4ge1dlYkdMUHJvZ3JhbX0gdGhlIHNoYWRlciBwcm9ncmFtXG4gKi9cbnZhciBjb21waWxlUHJvZ3JhbSA9IGZ1bmN0aW9uKGdsLCB2ZXJ0ZXhTcmMsIGZyYWdtZW50U3JjLCBhdHRyaWJ1dGVMb2NhdGlvbnMpXG57XG4gICAgdmFyIGdsVmVydFNoYWRlciA9IGNvbXBpbGVTaGFkZXIoZ2wsIGdsLlZFUlRFWF9TSEFERVIsIHZlcnRleFNyYyk7XG4gICAgdmFyIGdsRnJhZ1NoYWRlciA9IGNvbXBpbGVTaGFkZXIoZ2wsIGdsLkZSQUdNRU5UX1NIQURFUiwgZnJhZ21lbnRTcmMpO1xuXG4gICAgdmFyIHByb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKCk7XG5cbiAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgZ2xWZXJ0U2hhZGVyKTtcbiAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgZ2xGcmFnU2hhZGVyKTtcblxuICAgIC8vIG9wdGlvbmFsbHksIHNldCB0aGUgYXR0cmlidXRlcyBtYW51YWxseSBmb3IgdGhlIHByb2dyYW0gcmF0aGVyIHRoYW4gbGV0dGluZyBXZWJHTCBkZWNpZGUuLlxuICAgIGlmKGF0dHJpYnV0ZUxvY2F0aW9ucylcbiAgICB7XG4gICAgICAgIGZvcih2YXIgaSBpbiBhdHRyaWJ1dGVMb2NhdGlvbnMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGdsLmJpbmRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCBhdHRyaWJ1dGVMb2NhdGlvbnNbaV0sIGkpO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICBnbC5saW5rUHJvZ3JhbShwcm9ncmFtKTtcblxuICAgIC8vIGlmIGxpbmtpbmcgZmFpbHMsIHRoZW4gbG9nIGFuZCBjbGVhbnVwXG4gICAgaWYgKCFnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIGdsLkxJTktfU1RBVFVTKSlcbiAgICB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1BpeGkuanMgRXJyb3I6IENvdWxkIG5vdCBpbml0aWFsaXplIHNoYWRlci4nKTtcbiAgICAgICAgY29uc29sZS5lcnJvcignZ2wuVkFMSURBVEVfU1RBVFVTJywgZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBnbC5WQUxJREFURV9TVEFUVVMpKTtcbiAgICAgICAgY29uc29sZS5lcnJvcignZ2wuZ2V0RXJyb3IoKScsIGdsLmdldEVycm9yKCkpO1xuXG4gICAgICAgIC8vIGlmIHRoZXJlIGlzIGEgcHJvZ3JhbSBpbmZvIGxvZywgbG9nIGl0XG4gICAgICAgIGlmIChnbC5nZXRQcm9ncmFtSW5mb0xvZyhwcm9ncmFtKSAhPT0gJycpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignUGl4aS5qcyBXYXJuaW5nOiBnbC5nZXRQcm9ncmFtSW5mb0xvZygpJywgZ2wuZ2V0UHJvZ3JhbUluZm9Mb2cocHJvZ3JhbSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2wuZGVsZXRlUHJvZ3JhbShwcm9ncmFtKTtcbiAgICAgICAgcHJvZ3JhbSA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gY2xlYW4gdXAgc29tZSBzaGFkZXJzXG4gICAgZ2wuZGVsZXRlU2hhZGVyKGdsVmVydFNoYWRlcik7XG4gICAgZ2wuZGVsZXRlU2hhZGVyKGdsRnJhZ1NoYWRlcik7XG5cbiAgICByZXR1cm4gcHJvZ3JhbTtcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSBnbCB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBUaGUgY3VycmVudCBXZWJHTCBjb250ZXh0IHtXZWJHTFByb2dyYW19XG4gKiBAcGFyYW0gdHlwZSB7TnVtYmVyfSB0aGUgdHlwZSwgY2FuIGJlIGVpdGhlciBWRVJURVhfU0hBREVSIG9yIEZSQUdNRU5UX1NIQURFUlxuICogQHBhcmFtIHZlcnRleFNyYyB7c3RyaW5nfHN0cmluZ1tdfSBUaGUgdmVydGV4IHNoYWRlciBzb3VyY2UgYXMgYW4gYXJyYXkgb2Ygc3RyaW5ncy5cbiAqIEByZXR1cm4ge1dlYkdMU2hhZGVyfSB0aGUgc2hhZGVyXG4gKi9cbnZhciBjb21waWxlU2hhZGVyID0gZnVuY3Rpb24gKGdsLCB0eXBlLCBzcmMpXG57XG4gICAgdmFyIHNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlcih0eXBlKTtcblxuICAgIGdsLnNoYWRlclNvdXJjZShzaGFkZXIsIHNyYyk7XG4gICAgZ2wuY29tcGlsZVNoYWRlcihzaGFkZXIpO1xuXG4gICAgaWYgKCFnbC5nZXRTaGFkZXJQYXJhbWV0ZXIoc2hhZGVyLCBnbC5DT01QSUxFX1NUQVRVUykpXG4gICAge1xuICAgICAgICBjb25zb2xlLmxvZyhnbC5nZXRTaGFkZXJJbmZvTG9nKHNoYWRlcikpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gc2hhZGVyO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBjb21waWxlUHJvZ3JhbTtcbiIsIi8qKlxuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgUElYSS5nbENvcmUuc2hhZGVyXG4gKiBAcGFyYW0gdHlwZSB7U3RyaW5nfSBUeXBlIG9mIHZhbHVlXG4gKiBAcGFyYW0gc2l6ZSB7TnVtYmVyfVxuICovXG52YXIgZGVmYXVsdFZhbHVlID0gZnVuY3Rpb24odHlwZSwgc2l6ZSkgXG57XG4gICAgc3dpdGNoICh0eXBlKVxuICAgIHtcbiAgICAgICAgY2FzZSAnZmxvYXQnOlxuICAgICAgICAgICAgcmV0dXJuIDA7XG5cbiAgICAgICAgY2FzZSAndmVjMic6IFxuICAgICAgICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoMiAqIHNpemUpO1xuXG4gICAgICAgIGNhc2UgJ3ZlYzMnOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoMyAqIHNpemUpO1xuXG4gICAgICAgIGNhc2UgJ3ZlYzQnOiAgICAgXG4gICAgICAgICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheSg0ICogc2l6ZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgY2FzZSAnaW50JzpcbiAgICAgICAgY2FzZSAnc2FtcGxlcjJEJzpcbiAgICAgICAgICAgIHJldHVybiAwO1xuXG4gICAgICAgIGNhc2UgJ2l2ZWMyJzogICBcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW50MzJBcnJheSgyICogc2l6ZSk7XG5cbiAgICAgICAgY2FzZSAnaXZlYzMnOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnQzMkFycmF5KDMgKiBzaXplKTtcblxuICAgICAgICBjYXNlICdpdmVjNCc6IFxuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnQzMkFycmF5KDQgKiBzaXplKTtcblxuICAgICAgICBjYXNlICdib29sJzogICAgIFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIGNhc2UgJ2J2ZWMyJzpcblxuICAgICAgICAgICAgcmV0dXJuIGJvb2xlYW5BcnJheSggMiAqIHNpemUpO1xuXG4gICAgICAgIGNhc2UgJ2J2ZWMzJzpcbiAgICAgICAgICAgIHJldHVybiBib29sZWFuQXJyYXkoMyAqIHNpemUpO1xuXG4gICAgICAgIGNhc2UgJ2J2ZWM0JzpcbiAgICAgICAgICAgIHJldHVybiBib29sZWFuQXJyYXkoNCAqIHNpemUpO1xuXG4gICAgICAgIGNhc2UgJ21hdDInOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoWzEsIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMCwgMV0pO1xuXG4gICAgICAgIGNhc2UgJ21hdDMnOiBcbiAgICAgICAgICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KFsxLCAwLCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAsIDEsIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMCwgMCwgMV0pO1xuXG4gICAgICAgIGNhc2UgJ21hdDQnOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoWzEsIDAsIDAsIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMCwgMSwgMCwgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLCAwLCAxLCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAsIDAsIDAsIDFdKTtcbiAgICB9XG59O1xuXG52YXIgYm9vbGVhbkFycmF5ID0gZnVuY3Rpb24oc2l6ZSlcbntcbiAgICB2YXIgYXJyYXkgPSBuZXcgQXJyYXkoc2l6ZSk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSBcbiAgICB7XG4gICAgICAgIGFycmF5W2ldID0gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycmF5O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBkZWZhdWx0VmFsdWU7XG4iLCJcbnZhciBtYXBUeXBlID0gcmVxdWlyZSgnLi9tYXBUeXBlJyk7XG52YXIgbWFwU2l6ZSA9IHJlcXVpcmUoJy4vbWFwU2l6ZScpO1xuXG4vKipcbiAqIEV4dHJhY3RzIHRoZSBhdHRyaWJ1dGVzXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQSVhJLmdsQ29yZS5zaGFkZXJcbiAqIEBwYXJhbSBnbCB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBUaGUgY3VycmVudCBXZWJHTCByZW5kZXJpbmcgY29udGV4dFxuICogQHBhcmFtIHByb2dyYW0ge1dlYkdMUHJvZ3JhbX0gVGhlIHNoYWRlciBwcm9ncmFtIHRvIGdldCB0aGUgYXR0cmlidXRlcyBmcm9tXG4gKiBAcmV0dXJuIGF0dHJpYnV0ZXMge09iamVjdH1cbiAqL1xudmFyIGV4dHJhY3RBdHRyaWJ1dGVzID0gZnVuY3Rpb24oZ2wsIHByb2dyYW0pXG57XG4gICAgdmFyIGF0dHJpYnV0ZXMgPSB7fTtcblxuICAgIHZhciB0b3RhbEF0dHJpYnV0ZXMgPSBnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIGdsLkFDVElWRV9BVFRSSUJVVEVTKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG90YWxBdHRyaWJ1dGVzOyBpKyspXG4gICAge1xuICAgICAgICB2YXIgYXR0cmliRGF0YSA9IGdsLmdldEFjdGl2ZUF0dHJpYihwcm9ncmFtLCBpKTtcbiAgICAgICAgdmFyIHR5cGUgPSBtYXBUeXBlKGdsLCBhdHRyaWJEYXRhLnR5cGUpO1xuXG4gICAgICAgIGF0dHJpYnV0ZXNbYXR0cmliRGF0YS5uYW1lXSA9IHtcbiAgICAgICAgICAgIHR5cGU6dHlwZSxcbiAgICAgICAgICAgIHNpemU6bWFwU2l6ZSh0eXBlKSxcbiAgICAgICAgICAgIGxvY2F0aW9uOmdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sIGF0dHJpYkRhdGEubmFtZSksXG4gICAgICAgICAgICAvL1RPRE8gLSBtYWtlIGFuIGF0dHJpYnV0ZSBvYmplY3RcbiAgICAgICAgICAgIHBvaW50ZXI6IHBvaW50ZXJcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXR0cmlidXRlcztcbn07XG5cbnZhciBwb2ludGVyID0gZnVuY3Rpb24odHlwZSwgbm9ybWFsaXplZCwgc3RyaWRlLCBzdGFydCl7XG4gICAgLy8gY29uc29sZS5sb2codGhpcy5sb2NhdGlvbilcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRoaXMubG9jYXRpb24sdGhpcy5zaXplLCB0eXBlIHx8IGdsLkZMT0FULCBub3JtYWxpemVkIHx8IGZhbHNlLCBzdHJpZGUgfHwgMCwgc3RhcnQgfHwgMCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4dHJhY3RBdHRyaWJ1dGVzO1xuIiwidmFyIG1hcFR5cGUgPSByZXF1aXJlKCcuL21hcFR5cGUnKTtcbnZhciBkZWZhdWx0VmFsdWUgPSByZXF1aXJlKCcuL2RlZmF1bHRWYWx1ZScpO1xuXG4vKipcbiAqIEV4dHJhY3RzIHRoZSB1bmlmb3Jtc1xuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgUElYSS5nbENvcmUuc2hhZGVyXG4gKiBAcGFyYW0gZ2wge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gVGhlIGN1cnJlbnQgV2ViR0wgcmVuZGVyaW5nIGNvbnRleHRcbiAqIEBwYXJhbSBwcm9ncmFtIHtXZWJHTFByb2dyYW19IFRoZSBzaGFkZXIgcHJvZ3JhbSB0byBnZXQgdGhlIHVuaWZvcm1zIGZyb21cbiAqIEByZXR1cm4gdW5pZm9ybXMge09iamVjdH1cbiAqL1xudmFyIGV4dHJhY3RVbmlmb3JtcyA9IGZ1bmN0aW9uKGdsLCBwcm9ncmFtKVxue1xuXHR2YXIgdW5pZm9ybXMgPSB7fTtcblxuICAgIHZhciB0b3RhbFVuaWZvcm1zID0gZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBnbC5BQ1RJVkVfVU5JRk9STVMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b3RhbFVuaWZvcm1zOyBpKyspXG4gICAge1xuICAgIFx0dmFyIHVuaWZvcm1EYXRhID0gZ2wuZ2V0QWN0aXZlVW5pZm9ybShwcm9ncmFtLCBpKTtcbiAgICBcdHZhciBuYW1lID0gdW5pZm9ybURhdGEubmFtZS5yZXBsYWNlKC9cXFsuKj9cXF0vLCBcIlwiKTtcbiAgICAgICAgdmFyIHR5cGUgPSBtYXBUeXBlKGdsLCB1bmlmb3JtRGF0YS50eXBlICk7XG5cbiAgICBcdHVuaWZvcm1zW25hbWVdID0ge1xuICAgIFx0XHR0eXBlOnR5cGUsXG4gICAgXHRcdHNpemU6dW5pZm9ybURhdGEuc2l6ZSxcbiAgICBcdFx0bG9jYXRpb246Z2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIG5hbWUpLFxuICAgIFx0XHR2YWx1ZTpkZWZhdWx0VmFsdWUodHlwZSwgdW5pZm9ybURhdGEuc2l6ZSlcbiAgICBcdH07XG4gICAgfVxuXG5cdHJldHVybiB1bmlmb3Jtcztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZXh0cmFjdFVuaWZvcm1zO1xuIiwiLyoqXG4gKiBFeHRyYWN0cyB0aGUgYXR0cmlidXRlc1xuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgUElYSS5nbENvcmUuc2hhZGVyXG4gKiBAcGFyYW0gZ2wge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gVGhlIGN1cnJlbnQgV2ViR0wgcmVuZGVyaW5nIGNvbnRleHRcbiAqIEBwYXJhbSB1bmlmb3JtcyB7QXJyYXl9IEBtYXQgP1xuICogQHJldHVybiBhdHRyaWJ1dGVzIHtPYmplY3R9XG4gKi9cbnZhciBnZW5lcmF0ZVVuaWZvcm1BY2Nlc3NPYmplY3QgPSBmdW5jdGlvbihnbCwgdW5pZm9ybURhdGEpXG57XG4gICAgLy8gdGhpcyBpcyB0aGUgb2JqZWN0IHdlIHdpbGwgYmUgc2VuZGluZyBiYWNrLlxuICAgIC8vIGFuIG9iamVjdCBoaWVyYWNoeSB3aWxsIGJlIGNyZWF0ZWQgZm9yIHN0cnVjdHNcbiAgICB2YXIgdW5pZm9ybXMgPSB7ZGF0YTp7fX07XG5cbiAgICB1bmlmb3Jtcy5nbCA9IGdsO1xuXG4gICAgdmFyIHVuaWZvcm1LZXlzPSBPYmplY3Qua2V5cyh1bmlmb3JtRGF0YSk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHVuaWZvcm1LZXlzLmxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgdmFyIGZ1bGxOYW1lID0gdW5pZm9ybUtleXNbaV07XG5cbiAgICAgICAgdmFyIG5hbWVUb2tlbnMgPSBmdWxsTmFtZS5zcGxpdCgnLicpO1xuICAgICAgICB2YXIgbmFtZSA9IG5hbWVUb2tlbnNbbmFtZVRva2Vucy5sZW5ndGggLSAxXTtcblxuXG4gICAgICAgIHZhciB1bmlmb3JtR3JvdXAgPSBnZXRVbmlmb3JtR3JvdXAobmFtZVRva2VucywgdW5pZm9ybXMpO1xuXG4gICAgICAgIHZhciB1bmlmb3JtID0gIHVuaWZvcm1EYXRhW2Z1bGxOYW1lXTtcbiAgICAgICAgdW5pZm9ybUdyb3VwLmRhdGFbbmFtZV0gPSB1bmlmb3JtO1xuXG4gICAgICAgIHVuaWZvcm1Hcm91cC5nbCA9IGdsO1xuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh1bmlmb3JtR3JvdXAsIG5hbWUsIHtcbiAgICAgICAgICAgIGdldDogZ2VuZXJhdGVHZXR0ZXIobmFtZSksXG4gICAgICAgICAgICBzZXQ6IGdlbmVyYXRlU2V0dGVyKG5hbWUsIHVuaWZvcm0pXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB1bmlmb3Jtcztcbn07XG5cbnZhciBnZW5lcmF0ZUdldHRlciA9IGZ1bmN0aW9uKG5hbWUpXG57XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhW25hbWVdLnZhbHVlO1xuICAgIH07XG59O1xuXG52YXIgR0xTTF9TSU5HTEVfU0VUVEVSUyA9IHtcbiAgICBmbG9hdDogZnVuY3Rpb24gc2V0U2luZ2xlRmxvYXQoZ2wsIGxvY2F0aW9uLCB2YWx1ZSkgeyBnbC51bmlmb3JtMWYobG9jYXRpb24sIHZhbHVlKTsgfSxcbiAgICB2ZWMyOiBmdW5jdGlvbiBzZXRTaW5nbGVWZWMyKGdsLCBsb2NhdGlvbiwgdmFsdWUpIHsgZ2wudW5pZm9ybTJmKGxvY2F0aW9uLCB2YWx1ZVswXSwgdmFsdWVbMV0pOyB9LFxuICAgIHZlYzM6IGZ1bmN0aW9uIHNldFNpbmdsZVZlYzMoZ2wsIGxvY2F0aW9uLCB2YWx1ZSkgeyBnbC51bmlmb3JtM2YobG9jYXRpb24sIHZhbHVlWzBdLCB2YWx1ZVsxXSwgdmFsdWVbMl0pOyB9LFxuICAgIHZlYzQ6IGZ1bmN0aW9uIHNldFNpbmdsZVZlYzQoZ2wsIGxvY2F0aW9uLCB2YWx1ZSkgeyBnbC51bmlmb3JtNGYobG9jYXRpb24sIHZhbHVlWzBdLCB2YWx1ZVsxXSwgdmFsdWVbMl0sIHZhbHVlWzNdKTsgfSxcblxuICAgIGludDogZnVuY3Rpb24gc2V0U2luZ2xlSW50KGdsLCBsb2NhdGlvbiwgdmFsdWUpIHsgZ2wudW5pZm9ybTFpKGxvY2F0aW9uLCB2YWx1ZSk7IH0sXG4gICAgaXZlYzI6IGZ1bmN0aW9uIHNldFNpbmdsZUl2ZWMyKGdsLCBsb2NhdGlvbiwgdmFsdWUpIHsgZ2wudW5pZm9ybTJpKGxvY2F0aW9uLCB2YWx1ZVswXSwgdmFsdWVbMV0pOyB9LFxuICAgIGl2ZWMzOiBmdW5jdGlvbiBzZXRTaW5nbGVJdmVjMyhnbCwgbG9jYXRpb24sIHZhbHVlKSB7IGdsLnVuaWZvcm0zaShsb2NhdGlvbiwgdmFsdWVbMF0sIHZhbHVlWzFdLCB2YWx1ZVsyXSk7IH0sXG4gICAgaXZlYzQ6IGZ1bmN0aW9uIHNldFNpbmdsZUl2ZWM0KGdsLCBsb2NhdGlvbiwgdmFsdWUpIHsgZ2wudW5pZm9ybTRpKGxvY2F0aW9uLCB2YWx1ZVswXSwgdmFsdWVbMV0sIHZhbHVlWzJdLCB2YWx1ZVszXSk7IH0sXG5cbiAgICBib29sOiBmdW5jdGlvbiBzZXRTaW5nbGVCb29sKGdsLCBsb2NhdGlvbiwgdmFsdWUpIHsgZ2wudW5pZm9ybTFpKGxvY2F0aW9uLCB2YWx1ZSk7IH0sXG4gICAgYnZlYzI6IGZ1bmN0aW9uIHNldFNpbmdsZUJ2ZWMyKGdsLCBsb2NhdGlvbiwgdmFsdWUpIHsgZ2wudW5pZm9ybTJpKGxvY2F0aW9uLCB2YWx1ZVswXSwgdmFsdWVbMV0pOyB9LFxuICAgIGJ2ZWMzOiBmdW5jdGlvbiBzZXRTaW5nbGVCdmVjMyhnbCwgbG9jYXRpb24sIHZhbHVlKSB7IGdsLnVuaWZvcm0zaShsb2NhdGlvbiwgdmFsdWVbMF0sIHZhbHVlWzFdLCB2YWx1ZVsyXSk7IH0sXG4gICAgYnZlYzQ6IGZ1bmN0aW9uIHNldFNpbmdsZUJ2ZWM0KGdsLCBsb2NhdGlvbiwgdmFsdWUpIHsgZ2wudW5pZm9ybTRpKGxvY2F0aW9uLCB2YWx1ZVswXSwgdmFsdWVbMV0sIHZhbHVlWzJdLCB2YWx1ZVszXSk7IH0sXG5cbiAgICBtYXQyOiBmdW5jdGlvbiBzZXRTaW5nbGVNYXQyKGdsLCBsb2NhdGlvbiwgdmFsdWUpIHsgZ2wudW5pZm9ybU1hdHJpeDJmdihsb2NhdGlvbiwgZmFsc2UsIHZhbHVlKTsgfSxcbiAgICBtYXQzOiBmdW5jdGlvbiBzZXRTaW5nbGVNYXQzKGdsLCBsb2NhdGlvbiwgdmFsdWUpIHsgZ2wudW5pZm9ybU1hdHJpeDNmdihsb2NhdGlvbiwgZmFsc2UsIHZhbHVlKTsgfSxcbiAgICBtYXQ0OiBmdW5jdGlvbiBzZXRTaW5nbGVNYXQ0KGdsLCBsb2NhdGlvbiwgdmFsdWUpIHsgZ2wudW5pZm9ybU1hdHJpeDRmdihsb2NhdGlvbiwgZmFsc2UsIHZhbHVlKTsgfSxcblxuICAgIHNhbXBsZXIyRDogZnVuY3Rpb24gc2V0U2luZ2xlU2FtcGxlcjJEKGdsLCBsb2NhdGlvbiwgdmFsdWUpIHsgZ2wudW5pZm9ybTFpKGxvY2F0aW9uLCB2YWx1ZSk7IH0sXG59O1xuXG52YXIgR0xTTF9BUlJBWV9TRVRURVJTID0ge1xuICAgIGZsb2F0OiBmdW5jdGlvbiBzZXRGbG9hdEFycmF5KGdsLCBsb2NhdGlvbiwgdmFsdWUpIHsgZ2wudW5pZm9ybTFmdihsb2NhdGlvbiwgdmFsdWUpOyB9LFxuICAgIHZlYzI6IGZ1bmN0aW9uIHNldFZlYzJBcnJheShnbCwgbG9jYXRpb24sIHZhbHVlKSB7IGdsLnVuaWZvcm0yZnYobG9jYXRpb24sIHZhbHVlKTsgfSxcbiAgICB2ZWMzOiBmdW5jdGlvbiBzZXRWZWMzQXJyYXkoZ2wsIGxvY2F0aW9uLCB2YWx1ZSkgeyBnbC51bmlmb3JtM2Z2KGxvY2F0aW9uLCB2YWx1ZSk7IH0sXG4gICAgdmVjNDogZnVuY3Rpb24gc2V0VmVjNEFycmF5KGdsLCBsb2NhdGlvbiwgdmFsdWUpIHsgZ2wudW5pZm9ybTRmdihsb2NhdGlvbiwgdmFsdWUpOyB9LFxuICAgIGludDogZnVuY3Rpb24gc2V0SW50QXJyYXkoZ2wsIGxvY2F0aW9uLCB2YWx1ZSkgeyBnbC51bmlmb3JtMWl2KGxvY2F0aW9uLCB2YWx1ZSk7IH0sXG4gICAgaXZlYzI6IGZ1bmN0aW9uIHNldEl2ZWMyQXJyYXkoZ2wsIGxvY2F0aW9uLCB2YWx1ZSkgeyBnbC51bmlmb3JtMml2KGxvY2F0aW9uLCB2YWx1ZSk7IH0sXG4gICAgaXZlYzM6IGZ1bmN0aW9uIHNldEl2ZWMzQXJyYXkoZ2wsIGxvY2F0aW9uLCB2YWx1ZSkgeyBnbC51bmlmb3JtM2l2KGxvY2F0aW9uLCB2YWx1ZSk7IH0sXG4gICAgaXZlYzQ6IGZ1bmN0aW9uIHNldEl2ZWM0QXJyYXkoZ2wsIGxvY2F0aW9uLCB2YWx1ZSkgeyBnbC51bmlmb3JtNGl2KGxvY2F0aW9uLCB2YWx1ZSk7IH0sXG4gICAgYm9vbDogZnVuY3Rpb24gc2V0Qm9vbEFycmF5KGdsLCBsb2NhdGlvbiwgdmFsdWUpIHsgZ2wudW5pZm9ybTFpdihsb2NhdGlvbiwgdmFsdWUpOyB9LFxuICAgIGJ2ZWMyOiBmdW5jdGlvbiBzZXRCdmVjMkFycmF5KGdsLCBsb2NhdGlvbiwgdmFsdWUpIHsgZ2wudW5pZm9ybTJpdihsb2NhdGlvbiwgdmFsdWUpOyB9LFxuICAgIGJ2ZWMzOiBmdW5jdGlvbiBzZXRCdmVjM0FycmF5KGdsLCBsb2NhdGlvbiwgdmFsdWUpIHsgZ2wudW5pZm9ybTNpdihsb2NhdGlvbiwgdmFsdWUpOyB9LFxuICAgIGJ2ZWM0OiBmdW5jdGlvbiBzZXRCdmVjNEFycmF5KGdsLCBsb2NhdGlvbiwgdmFsdWUpIHsgZ2wudW5pZm9ybTRpdihsb2NhdGlvbiwgdmFsdWUpOyB9LFxuICAgIHNhbXBsZXIyRDogZnVuY3Rpb24gc2V0U2FtcGxlcjJEQXJyYXkoZ2wsIGxvY2F0aW9uLCB2YWx1ZSkgeyBnbC51bmlmb3JtMWl2KGxvY2F0aW9uLCB2YWx1ZSk7IH0sXG59O1xuXG5mdW5jdGlvbiBnZW5lcmF0ZVNldHRlcihuYW1lLCB1bmlmb3JtKVxue1xuICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB0aGlzLmRhdGFbbmFtZV0udmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdmFyIGxvY2F0aW9uID0gdGhpcy5kYXRhW25hbWVdLmxvY2F0aW9uO1xuICAgICAgICBpZiAodW5pZm9ybS5zaXplID09PSAxKVxuICAgICAgICB7XG4gICAgICAgICAgICBHTFNMX1NJTkdMRV9TRVRURVJTW3VuaWZvcm0udHlwZV0odGhpcy5nbCwgbG9jYXRpb24sIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIGdsc2xTZXRBcnJheShnbCwgbG9jYXRpb24sIHR5cGUsIHZhbHVlKSB7XG4gICAgICAgICAgICBHTFNMX0FSUkFZX1NFVFRFUlNbdW5pZm9ybS50eXBlXSh0aGlzLmdsLCBsb2NhdGlvbiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0VW5pZm9ybUdyb3VwKG5hbWVUb2tlbnMsIHVuaWZvcm0pXG57XG4gICAgdmFyIGN1ciA9IHVuaWZvcm07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWVUb2tlbnMubGVuZ3RoIC0gMTsgaSsrKVxuICAgIHtcbiAgICAgICAgdmFyIG8gPSBjdXJbbmFtZVRva2Vuc1tpXV0gfHwge2RhdGE6e319O1xuICAgICAgICBjdXJbbmFtZVRva2Vuc1tpXV0gPSBvO1xuICAgICAgICBjdXIgPSBvO1xuICAgIH1cblxuICAgIHJldHVybiBjdXI7XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBnZW5lcmF0ZVVuaWZvcm1BY2Nlc3NPYmplY3Q7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBjb21waWxlUHJvZ3JhbTogcmVxdWlyZSgnLi9jb21waWxlUHJvZ3JhbScpLFxuICAgIGRlZmF1bHRWYWx1ZTogcmVxdWlyZSgnLi9kZWZhdWx0VmFsdWUnKSxcbiAgICBleHRyYWN0QXR0cmlidXRlczogcmVxdWlyZSgnLi9leHRyYWN0QXR0cmlidXRlcycpLFxuICAgIGV4dHJhY3RVbmlmb3JtczogcmVxdWlyZSgnLi9leHRyYWN0VW5pZm9ybXMnKSxcbiAgICBnZW5lcmF0ZVVuaWZvcm1BY2Nlc3NPYmplY3Q6IHJlcXVpcmUoJy4vZ2VuZXJhdGVVbmlmb3JtQWNjZXNzT2JqZWN0JyksXG4gICAgc2V0UHJlY2lzaW9uOiByZXF1aXJlKCcuL3NldFByZWNpc2lvbicpLFxuICAgIG1hcFNpemU6IHJlcXVpcmUoJy4vbWFwU2l6ZScpLFxuICAgIG1hcFR5cGU6IHJlcXVpcmUoJy4vbWFwVHlwZScpXG59OyIsIi8qKlxuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgUElYSS5nbENvcmUuc2hhZGVyXG4gKiBAcGFyYW0gdHlwZSB7U3RyaW5nfVxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG52YXIgbWFwU2l6ZSA9IGZ1bmN0aW9uKHR5cGUpIFxueyBcbiAgICByZXR1cm4gR0xTTF9UT19TSVpFW3R5cGVdO1xufTtcblxuXG52YXIgR0xTTF9UT19TSVpFID0ge1xuICAgICdmbG9hdCc6ICAgIDEsXG4gICAgJ3ZlYzInOiAgICAgMixcbiAgICAndmVjMyc6ICAgICAzLFxuICAgICd2ZWM0JzogICAgIDQsXG5cbiAgICAnaW50JzogICAgICAxLFxuICAgICdpdmVjMic6ICAgIDIsXG4gICAgJ2l2ZWMzJzogICAgMyxcbiAgICAnaXZlYzQnOiAgICA0LFxuXG4gICAgJ2Jvb2wnOiAgICAgMSxcbiAgICAnYnZlYzInOiAgICAyLFxuICAgICdidmVjMyc6ICAgIDMsXG4gICAgJ2J2ZWM0JzogICAgNCxcblxuICAgICdtYXQyJzogICAgIDQsXG4gICAgJ21hdDMnOiAgICAgOSxcbiAgICAnbWF0NCc6ICAgICAxNixcblxuICAgICdzYW1wbGVyMkQnOiAgMVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBtYXBTaXplO1xuIiwiXG5cbnZhciBtYXBUeXBlID0gZnVuY3Rpb24oZ2wsIHR5cGUpIFxue1xuICAgIGlmKCFHTF9UQUJMRSkgXG4gICAge1xuICAgICAgICB2YXIgdHlwZU5hbWVzID0gT2JqZWN0LmtleXMoR0xfVE9fR0xTTF9UWVBFUyk7XG5cbiAgICAgICAgR0xfVEFCTEUgPSB7fTtcblxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdHlwZU5hbWVzLmxlbmd0aDsgKytpKSBcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIHRuID0gdHlwZU5hbWVzW2ldO1xuICAgICAgICAgICAgR0xfVEFCTEVbIGdsW3RuXSBdID0gR0xfVE9fR0xTTF9UWVBFU1t0bl07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgcmV0dXJuIEdMX1RBQkxFW3R5cGVdO1xufTtcblxudmFyIEdMX1RBQkxFID0gbnVsbDtcblxudmFyIEdMX1RPX0dMU0xfVFlQRVMgPSB7XG4gICdGTE9BVCc6ICAgICAgICdmbG9hdCcsXG4gICdGTE9BVF9WRUMyJzogICd2ZWMyJyxcbiAgJ0ZMT0FUX1ZFQzMnOiAgJ3ZlYzMnLFxuICAnRkxPQVRfVkVDNCc6ICAndmVjNCcsXG5cbiAgJ0lOVCc6ICAgICAgICAgJ2ludCcsXG4gICdJTlRfVkVDMic6ICAgICdpdmVjMicsXG4gICdJTlRfVkVDMyc6ICAgICdpdmVjMycsXG4gICdJTlRfVkVDNCc6ICAgICdpdmVjNCcsXG4gIFxuICAnQk9PTCc6ICAgICAgICAnYm9vbCcsXG4gICdCT09MX1ZFQzInOiAgICdidmVjMicsXG4gICdCT09MX1ZFQzMnOiAgICdidmVjMycsXG4gICdCT09MX1ZFQzQnOiAgICdidmVjNCcsXG4gIFxuICAnRkxPQVRfTUFUMic6ICAnbWF0MicsXG4gICdGTE9BVF9NQVQzJzogICdtYXQzJyxcbiAgJ0ZMT0FUX01BVDQnOiAgJ21hdDQnLFxuICBcbiAgJ1NBTVBMRVJfMkQnOiAgJ3NhbXBsZXIyRCcgIFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBtYXBUeXBlO1xuIiwiLyoqXG4gKiBTZXRzIHRoZSBmbG9hdCBwcmVjaXNpb24gb24gdGhlIHNoYWRlci4gSWYgdGhlIHByZWNpc2lvbiBpcyBhbHJlYWR5IHByZXNlbnQgdGhpcyBmdW5jdGlvbiB3aWxsIGRvIG5vdGhpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBzcmMgICAgICAgdGhlIHNoYWRlciBzb3VyY2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcmVjaXNpb24gVGhlIGZsb2F0IHByZWNpc2lvbiBvZiB0aGUgc2hhZGVyLiBPcHRpb25zIGFyZSAnbG93cCcsICdtZWRpdW1wJyBvciAnaGlnaHAnLlxuICpcbiAqIEByZXR1cm4ge3N0cmluZ30gbW9kaWZpZWQgc2hhZGVyIHNvdXJjZVxuICovXG52YXIgc2V0UHJlY2lzaW9uID0gZnVuY3Rpb24oc3JjLCBwcmVjaXNpb24pXG57XG4gICAgaWYoc3JjLnN1YnN0cmluZygwLCA5KSAhPT0gJ3ByZWNpc2lvbicpXG4gICAge1xuICAgICAgICByZXR1cm4gJ3ByZWNpc2lvbiAnICsgcHJlY2lzaW9uICsgJyBmbG9hdDtcXG4nICsgc3JjO1xuICAgIH1cblxuICAgIHJldHVybiBzcmM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHNldFByZWNpc2lvbjtcbiIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9jb3JlID0gcmVxdWlyZSgnLi4vY29yZScpO1xuXG52YXIgY29yZSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9jb3JlKTtcblxudmFyIF9pc21vYmlsZWpzID0gcmVxdWlyZSgnaXNtb2JpbGVqcycpO1xuXG52YXIgX2lzbW9iaWxlanMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaXNtb2JpbGVqcyk7XG5cbnZhciBfYWNjZXNzaWJsZVRhcmdldCA9IHJlcXVpcmUoJy4vYWNjZXNzaWJsZVRhcmdldCcpO1xuXG52YXIgX2FjY2Vzc2libGVUYXJnZXQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYWNjZXNzaWJsZVRhcmdldCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8vIGFkZCBzb21lIGV4dHJhIHZhcmlhYmxlcyB0byB0aGUgY29udGFpbmVyLi5cbmNvcmUudXRpbHMubWl4aW5zLmRlbGF5TWl4aW4oY29yZS5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZSwgX2FjY2Vzc2libGVUYXJnZXQyLmRlZmF1bHQpO1xuXG52YXIgS0VZX0NPREVfVEFCID0gOTtcblxudmFyIERJVl9UT1VDSF9TSVpFID0gMTAwO1xudmFyIERJVl9UT1VDSF9QT1NfWCA9IDA7XG52YXIgRElWX1RPVUNIX1BPU19ZID0gMDtcbnZhciBESVZfVE9VQ0hfWklOREVYID0gMjtcblxudmFyIERJVl9IT09LX1NJWkUgPSAxO1xudmFyIERJVl9IT09LX1BPU19YID0gLTEwMDA7XG52YXIgRElWX0hPT0tfUE9TX1kgPSAtMTAwMDtcbnZhciBESVZfSE9PS19aSU5ERVggPSAyO1xuXG4vKipcbiAqIFRoZSBBY2Nlc3NpYmlsaXR5IG1hbmFnZXIgcmVjcmVhdGVzIHRoZSBhYmlsaXR5IHRvIHRhYiBhbmQgaGF2ZSBjb250ZW50IHJlYWQgYnkgc2NyZWVuXG4gKiByZWFkZXJzLiBUaGlzIGlzIHZlcnkgaW1wb3J0YW50IGFzIGl0IGNhbiBwb3NzaWJseSBoZWxwIHBlb3BsZSB3aXRoIGRpc2FiaWxpdGllcyBhY2Nlc3MgcGl4aVxuICogY29udGVudC5cbiAqXG4gKiBNdWNoIGxpa2UgaW50ZXJhY3Rpb24gYW55IERpc3BsYXlPYmplY3QgY2FuIGJlIG1hZGUgYWNjZXNzaWJsZS4gVGhpcyBtYW5hZ2VyIHdpbGwgbWFwIHRoZVxuICogZXZlbnRzIGFzIGlmIHRoZSBtb3VzZSB3YXMgYmVpbmcgdXNlZCwgbWluaW1pemluZyB0aGUgZWZmb3J0IHJlcXVpcmVkIHRvIGltcGxlbWVudC5cbiAqXG4gKiBBbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzIGlzIGF1dG9tYXRpY2FsbHkgY3JlYXRlZCBieSBkZWZhdWx0LCBhbmQgY2FuIGJlIGZvdW5kIGF0IHJlbmRlcmVyLnBsdWdpbnMuYWNjZXNzaWJpbGl0eVxuICpcbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIFBJWEkuYWNjZXNzaWJpbGl0eVxuICovXG5cbnZhciBBY2Nlc3NpYmlsaXR5TWFuYWdlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1BJWEkuQ2FudmFzUmVuZGVyZXJ8UElYSS5XZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIEEgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IHJlbmRlcmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gQWNjZXNzaWJpbGl0eU1hbmFnZXIocmVuZGVyZXIpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFjY2Vzc2liaWxpdHlNYW5hZ2VyKTtcblxuICAgICAgICBpZiAoKF9pc21vYmlsZWpzMi5kZWZhdWx0LnRhYmxldCB8fCBfaXNtb2JpbGVqczIuZGVmYXVsdC5waG9uZSkgJiYgIW5hdmlnYXRvci5pc0NvY29vbkpTKSB7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZVRvdWNoSG9vaygpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmlyc3Qgd2UgY3JlYXRlIGEgZGl2IHRoYXQgd2lsbCBzaXQgb3ZlciB0aGUgUGl4aUpTIGVsZW1lbnQuIFRoaXMgaXMgd2hlcmUgdGhlIGRpdiBvdmVybGF5cyB3aWxsIGdvLlxuICAgICAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICAgICAgZGl2LnN0eWxlLndpZHRoID0gRElWX1RPVUNIX1NJWkUgKyAncHgnO1xuICAgICAgICBkaXYuc3R5bGUuaGVpZ2h0ID0gRElWX1RPVUNIX1NJWkUgKyAncHgnO1xuICAgICAgICBkaXYuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICBkaXYuc3R5bGUudG9wID0gRElWX1RPVUNIX1BPU19YICsgJ3B4JztcbiAgICAgICAgZGl2LnN0eWxlLmxlZnQgPSBESVZfVE9VQ0hfUE9TX1kgKyAncHgnO1xuICAgICAgICBkaXYuc3R5bGUuekluZGV4ID0gRElWX1RPVUNIX1pJTkRFWDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBpcyB0aGUgZG9tIGVsZW1lbnQgdGhhdCB3aWxsIHNpdCBvdmVyIHRoZSBQaXhpSlMgZWxlbWVudC4gVGhpcyBpcyB3aGVyZSB0aGUgZGl2IG92ZXJsYXlzIHdpbGwgZ28uXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGl2ID0gZGl2O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHNpbXBsZSBwb29sIGZvciBzdG9yaW5nIGRpdnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHsqfVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wb29sID0gW107XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgaXMgYSB0aWNrIHVzZWQgdG8gY2hlY2sgaWYgYW4gb2JqZWN0IGlzIG5vIGxvbmdlciBiZWluZyByZW5kZXJlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVuZGVySWQgPSAwO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXR0aW5nIHRoaXMgdG8gdHJ1ZSB3aWxsIHZpc3VhbGx5IHNob3cgdGhlIGRpdnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kZWJ1ZyA9IGZhbHNlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcmVuZGVyZXIgdGhpcyBhY2Nlc3NpYmlsaXR5IG1hbmFnZXIgd29ya3MgZm9yLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLlN5c3RlbVJlbmRlcmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYXJyYXkgb2YgY3VycmVudGx5IGFjdGl2ZSBhY2Nlc3NpYmxlIGl0ZW1zLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtBcnJheTwqPn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogcHJlLWJpbmQgdGhlIGZ1bmN0aW9uc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fb25LZXlEb3duID0gdGhpcy5fb25LZXlEb3duLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuX29uTW91c2VNb3ZlID0gdGhpcy5fb25Nb3VzZU1vdmUuYmluZCh0aGlzKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogc3RvcmVzIHRoZSBzdGF0ZSBvZiB0aGUgbWFuYWdlci4gSWYgdGhlcmUgYXJlIG5vIGFjY2Vzc2libGUgb2JqZWN0cyBvciB0aGUgbW91c2UgaXMgbW92aW5nLCB0aGlzIHdpbGwgYmUgZmFsc2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5PCo+fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pc0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzTW9iaWxlQWNjZXNzYWJpbGxpdHkgPSBmYWxzZTtcblxuICAgICAgICAvLyBsZXQgbGlzdGVuIGZvciB0YWIuLiBvbmNlIHByZXNzZWQgd2UgY2FuIGZpcmUgdXAgYW5kIHNob3cgdGhlIGFjY2Vzc2liaWxpdHkgbGF5ZXJcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl9vbktleURvd24sIGZhbHNlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHRoZSB0b3VjaCBob29rcy5cbiAgICAgKlxuICAgICAqL1xuXG5cbiAgICBBY2Nlc3NpYmlsaXR5TWFuYWdlci5wcm90b3R5cGUuY3JlYXRlVG91Y2hIb29rID0gZnVuY3Rpb24gY3JlYXRlVG91Y2hIb29rKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIHZhciBob29rRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG5cbiAgICAgICAgaG9va0Rpdi5zdHlsZS53aWR0aCA9IERJVl9IT09LX1NJWkUgKyAncHgnO1xuICAgICAgICBob29rRGl2LnN0eWxlLmhlaWdodCA9IERJVl9IT09LX1NJWkUgKyAncHgnO1xuICAgICAgICBob29rRGl2LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgaG9va0Rpdi5zdHlsZS50b3AgPSBESVZfSE9PS19QT1NfWCArICdweCc7XG4gICAgICAgIGhvb2tEaXYuc3R5bGUubGVmdCA9IERJVl9IT09LX1BPU19ZICsgJ3B4JztcbiAgICAgICAgaG9va0Rpdi5zdHlsZS56SW5kZXggPSBESVZfSE9PS19aSU5ERVg7XG4gICAgICAgIGhvb2tEaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJyNGRjAwMDAnO1xuICAgICAgICBob29rRGl2LnRpdGxlID0gJ0hPT0sgRElWJztcblxuICAgICAgICBob29rRGl2LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuaXNNb2JpbGVBY2Nlc3NhYmlsbGl0eSA9IHRydWU7XG4gICAgICAgICAgICBfdGhpcy5hY3RpdmF0ZSgpO1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChob29rRGl2KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChob29rRGl2KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQWN0aXZhdGluZyB3aWxsIGNhdXNlIHRoZSBBY2Nlc3NpYmlsaXR5IGxheWVyIHRvIGJlIHNob3duLiBUaGlzIGlzIGNhbGxlZCB3aGVuIGEgdXNlclxuICAgICAqIHByZXNlcyB0aGUgdGFiIGtleS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cblxuICAgIEFjY2Vzc2liaWxpdHlNYW5hZ2VyLnByb3RvdHlwZS5hY3RpdmF0ZSA9IGZ1bmN0aW9uIGFjdGl2YXRlKCkge1xuICAgICAgICBpZiAodGhpcy5pc0FjdGl2ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pc0FjdGl2ZSA9IHRydWU7XG5cbiAgICAgICAgd2luZG93LmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX29uTW91c2VNb3ZlLCB0cnVlKTtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl9vbktleURvd24sIGZhbHNlKTtcblxuICAgICAgICB0aGlzLnJlbmRlcmVyLm9uKCdwb3N0cmVuZGVyJywgdGhpcy51cGRhdGUsIHRoaXMpO1xuXG4gICAgICAgIGlmICh0aGlzLnJlbmRlcmVyLnZpZXcucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci52aWV3LnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQodGhpcy5kaXYpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERlYWN0aXZhdGluZyB3aWxsIGNhdXNlIHRoZSBBY2Nlc3NpYmlsaXR5IGxheWVyIHRvIGJlIGhpZGRlbi4gVGhpcyBpcyBjYWxsZWQgd2hlbiBhIHVzZXIgbW92ZXNcbiAgICAgKiB0aGUgbW91c2UuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG5cbiAgICBBY2Nlc3NpYmlsaXR5TWFuYWdlci5wcm90b3R5cGUuZGVhY3RpdmF0ZSA9IGZ1bmN0aW9uIGRlYWN0aXZhdGUoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0FjdGl2ZSB8fCB0aGlzLmlzTW9iaWxlQWNjZXNzYWJpbGxpdHkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaXNBY3RpdmUgPSBmYWxzZTtcblxuICAgICAgICB3aW5kb3cuZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUsIHRydWUpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuX29uS2V5RG93biwgZmFsc2UpO1xuXG4gICAgICAgIHRoaXMucmVuZGVyZXIub2ZmKCdwb3N0cmVuZGVyJywgdGhpcy51cGRhdGUpO1xuXG4gICAgICAgIGlmICh0aGlzLmRpdi5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICB0aGlzLmRpdi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZGl2KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIHJlY3Vyc2l2ZSBmdW5jdGlvbiB3aWxsIHJ1biB0aHJvdWdoIHRoZSBzY2VuZSBncmFwaCBhbmQgYWRkIGFueSBuZXcgYWNjZXNzaWJsZSBvYmplY3RzIHRvIHRoZSBET00gbGF5ZXIuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7UElYSS5Db250YWluZXJ9IGRpc3BsYXlPYmplY3QgLSBUaGUgRGlzcGxheU9iamVjdCB0byBjaGVjay5cbiAgICAgKi9cblxuXG4gICAgQWNjZXNzaWJpbGl0eU1hbmFnZXIucHJvdG90eXBlLnVwZGF0ZUFjY2Vzc2libGVPYmplY3RzID0gZnVuY3Rpb24gdXBkYXRlQWNjZXNzaWJsZU9iamVjdHMoZGlzcGxheU9iamVjdCkge1xuICAgICAgICBpZiAoIWRpc3BsYXlPYmplY3QudmlzaWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRpc3BsYXlPYmplY3QuYWNjZXNzaWJsZSAmJiBkaXNwbGF5T2JqZWN0LmludGVyYWN0aXZlKSB7XG4gICAgICAgICAgICBpZiAoIWRpc3BsYXlPYmplY3QuX2FjY2Vzc2libGVBY3RpdmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZENoaWxkKGRpc3BsYXlPYmplY3QpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkaXNwbGF5T2JqZWN0LnJlbmRlcklkID0gdGhpcy5yZW5kZXJJZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjaGlsZHJlbiA9IGRpc3BsYXlPYmplY3QuY2hpbGRyZW47XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVBY2Nlc3NpYmxlT2JqZWN0cyhjaGlsZHJlbltpXSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQmVmb3JlIGVhY2ggcmVuZGVyIHRoaXMgZnVuY3Rpb24gd2lsbCBlbnN1cmUgdGhhdCBhbGwgZGl2cyBhcmUgbWFwcGVkIGNvcnJlY3RseSB0byB0aGVpciBEaXNwbGF5T2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cblxuICAgIEFjY2Vzc2liaWxpdHlNYW5hZ2VyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgICAgIGlmICghdGhpcy5yZW5kZXJlci5yZW5kZXJpbmdUb1NjcmVlbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdXBkYXRlIGNoaWxkcmVuLi4uXG4gICAgICAgIHRoaXMudXBkYXRlQWNjZXNzaWJsZU9iamVjdHModGhpcy5yZW5kZXJlci5fbGFzdE9iamVjdFJlbmRlcmVkKTtcblxuICAgICAgICB2YXIgcmVjdCA9IHRoaXMucmVuZGVyZXIudmlldy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdmFyIHN4ID0gcmVjdC53aWR0aCAvIHRoaXMucmVuZGVyZXIud2lkdGg7XG4gICAgICAgIHZhciBzeSA9IHJlY3QuaGVpZ2h0IC8gdGhpcy5yZW5kZXJlci5oZWlnaHQ7XG5cbiAgICAgICAgdmFyIGRpdiA9IHRoaXMuZGl2O1xuXG4gICAgICAgIGRpdi5zdHlsZS5sZWZ0ID0gcmVjdC5sZWZ0ICsgJ3B4JztcbiAgICAgICAgZGl2LnN0eWxlLnRvcCA9IHJlY3QudG9wICsgJ3B4JztcbiAgICAgICAgZGl2LnN0eWxlLndpZHRoID0gdGhpcy5yZW5kZXJlci53aWR0aCArICdweCc7XG4gICAgICAgIGRpdi5zdHlsZS5oZWlnaHQgPSB0aGlzLnJlbmRlcmVyLmhlaWdodCArICdweCc7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldO1xuXG4gICAgICAgICAgICBpZiAoY2hpbGQucmVuZGVySWQgIT09IHRoaXMucmVuZGVySWQpIHtcbiAgICAgICAgICAgICAgICBjaGlsZC5fYWNjZXNzaWJsZUFjdGl2ZSA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgY29yZS51dGlscy5yZW1vdmVJdGVtcyh0aGlzLmNoaWxkcmVuLCBpLCAxKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRpdi5yZW1vdmVDaGlsZChjaGlsZC5fYWNjZXNzaWJsZURpdik7XG4gICAgICAgICAgICAgICAgdGhpcy5wb29sLnB1c2goY2hpbGQuX2FjY2Vzc2libGVEaXYpO1xuICAgICAgICAgICAgICAgIGNoaWxkLl9hY2Nlc3NpYmxlRGl2ID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIGktLTtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlYWN0aXZhdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIG1hcCBkaXYgdG8gZGlzcGxheS4uXG4gICAgICAgICAgICAgICAgZGl2ID0gY2hpbGQuX2FjY2Vzc2libGVEaXY7XG4gICAgICAgICAgICAgICAgdmFyIGhpdEFyZWEgPSBjaGlsZC5oaXRBcmVhO1xuICAgICAgICAgICAgICAgIHZhciB3dCA9IGNoaWxkLndvcmxkVHJhbnNmb3JtO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLmhpdEFyZWEpIHtcbiAgICAgICAgICAgICAgICAgICAgZGl2LnN0eWxlLmxlZnQgPSAod3QudHggKyBoaXRBcmVhLnggKiB3dC5hKSAqIHN4ICsgJ3B4JztcbiAgICAgICAgICAgICAgICAgICAgZGl2LnN0eWxlLnRvcCA9ICh3dC50eSArIGhpdEFyZWEueSAqIHd0LmQpICogc3kgKyAncHgnO1xuXG4gICAgICAgICAgICAgICAgICAgIGRpdi5zdHlsZS53aWR0aCA9IGhpdEFyZWEud2lkdGggKiB3dC5hICogc3ggKyAncHgnO1xuICAgICAgICAgICAgICAgICAgICBkaXYuc3R5bGUuaGVpZ2h0ID0gaGl0QXJlYS5oZWlnaHQgKiB3dC5kICogc3kgKyAncHgnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGhpdEFyZWEgPSBjaGlsZC5nZXRCb3VuZHMoKTtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhcEhpdEFyZWEoaGl0QXJlYSk7XG5cbiAgICAgICAgICAgICAgICAgICAgZGl2LnN0eWxlLmxlZnQgPSBoaXRBcmVhLnggKiBzeCArICdweCc7XG4gICAgICAgICAgICAgICAgICAgIGRpdi5zdHlsZS50b3AgPSBoaXRBcmVhLnkgKiBzeSArICdweCc7XG5cbiAgICAgICAgICAgICAgICAgICAgZGl2LnN0eWxlLndpZHRoID0gaGl0QXJlYS53aWR0aCAqIHN4ICsgJ3B4JztcbiAgICAgICAgICAgICAgICAgICAgZGl2LnN0eWxlLmhlaWdodCA9IGhpdEFyZWEuaGVpZ2h0ICogc3kgKyAncHgnO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBidXR0b24gdGl0bGVzIGFuZCBoaW50cyBpZiB0aGV5IGV4aXN0IGFuZCB0aGV5J3ZlIGNoYW5nZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpdi50aXRsZSAhPT0gY2hpbGQuYWNjZXNzaWJsZVRpdGxlICYmIGNoaWxkLmFjY2Vzc2libGVUaXRsZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGl2LnRpdGxlID0gY2hpbGQuYWNjZXNzaWJsZVRpdGxlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChkaXYuZ2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJykgIT09IGNoaWxkLmFjY2Vzc2libGVIaW50ICYmIGNoaWxkLmFjY2Vzc2libGVIaW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXYuc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJywgY2hpbGQuYWNjZXNzaWJsZUhpbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaW5jcmVtZW50IHRoZSByZW5kZXIgaWQuLlxuICAgICAgICB0aGlzLnJlbmRlcklkKys7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRPRE86IGRvY3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlY3RhbmdsZX0gaGl0QXJlYSAtIFRPRE8gZG9jc1xuICAgICAqL1xuXG5cbiAgICBBY2Nlc3NpYmlsaXR5TWFuYWdlci5wcm90b3R5cGUuY2FwSGl0QXJlYSA9IGZ1bmN0aW9uIGNhcEhpdEFyZWEoaGl0QXJlYSkge1xuICAgICAgICBpZiAoaGl0QXJlYS54IDwgMCkge1xuICAgICAgICAgICAgaGl0QXJlYS53aWR0aCArPSBoaXRBcmVhLng7XG4gICAgICAgICAgICBoaXRBcmVhLnggPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhpdEFyZWEueSA8IDApIHtcbiAgICAgICAgICAgIGhpdEFyZWEuaGVpZ2h0ICs9IGhpdEFyZWEueTtcbiAgICAgICAgICAgIGhpdEFyZWEueSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGl0QXJlYS54ICsgaGl0QXJlYS53aWR0aCA+IHRoaXMucmVuZGVyZXIud2lkdGgpIHtcbiAgICAgICAgICAgIGhpdEFyZWEud2lkdGggPSB0aGlzLnJlbmRlcmVyLndpZHRoIC0gaGl0QXJlYS54O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhpdEFyZWEueSArIGhpdEFyZWEuaGVpZ2h0ID4gdGhpcy5yZW5kZXJlci5oZWlnaHQpIHtcbiAgICAgICAgICAgIGhpdEFyZWEuaGVpZ2h0ID0gdGhpcy5yZW5kZXJlci5oZWlnaHQgLSBoaXRBcmVhLnk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIERpc3BsYXlPYmplY3QgdG8gdGhlIGFjY2Vzc2liaWxpdHkgbWFuYWdlclxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Rpc3BsYXlPYmplY3R9IGRpc3BsYXlPYmplY3QgLSBUaGUgY2hpbGQgdG8gbWFrZSBhY2Nlc3NpYmxlLlxuICAgICAqL1xuXG5cbiAgICBBY2Nlc3NpYmlsaXR5TWFuYWdlci5wcm90b3R5cGUuYWRkQ2hpbGQgPSBmdW5jdGlvbiBhZGRDaGlsZChkaXNwbGF5T2JqZWN0KSB7XG4gICAgICAgIC8vICAgIHRoaXMuYWN0aXZhdGUoKTtcblxuICAgICAgICB2YXIgZGl2ID0gdGhpcy5wb29sLnBvcCgpO1xuXG4gICAgICAgIGlmICghZGl2KSB7XG4gICAgICAgICAgICBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcblxuICAgICAgICAgICAgZGl2LnN0eWxlLndpZHRoID0gRElWX1RPVUNIX1NJWkUgKyAncHgnO1xuICAgICAgICAgICAgZGl2LnN0eWxlLmhlaWdodCA9IERJVl9UT1VDSF9TSVpFICsgJ3B4JztcbiAgICAgICAgICAgIGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSB0aGlzLmRlYnVnID8gJ3JnYmEoMjU1LDAsMCwwLjUpJyA6ICd0cmFuc3BhcmVudCc7XG4gICAgICAgICAgICBkaXYuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICAgICAgZGl2LnN0eWxlLnpJbmRleCA9IERJVl9UT1VDSF9aSU5ERVg7XG4gICAgICAgICAgICBkaXYuc3R5bGUuYm9yZGVyU3R5bGUgPSAnbm9uZSc7XG5cbiAgICAgICAgICAgIC8vIEFSSUEgYXR0cmlidXRlcyBlbnN1cmUgdGhhdCBidXR0b24gdGl0bGUgYW5kIGhpbnQgdXBkYXRlcyBhcmUgYW5ub3VuY2VkIHByb3Blcmx5XG4gICAgICAgICAgICBpZiAobmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2Nocm9tZScpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAvLyBDaHJvbWUgZG9lc24ndCBuZWVkIGFyaWEtbGl2ZSB0byB3b3JrIGFzIGludGVuZGVkOyBpbiBmYWN0IGl0IGp1c3QgZ2V0cyBtb3JlIGNvbmZ1c2VkLlxuICAgICAgICAgICAgICAgIGRpdi5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGl2ZScsICdvZmYnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGl2LnNldEF0dHJpYnV0ZSgnYXJpYS1saXZlJywgJ3BvbGl0ZScpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvcnY6LipHZWNrb1xcLy8pKSB7XG4gICAgICAgICAgICAgICAgLy8gRmlyZUZveCBuZWVkcyB0aGlzIHRvIGFubm91bmNlIG9ubHkgdGhlIG5ldyBidXR0b24gbmFtZVxuICAgICAgICAgICAgICAgIGRpdi5zZXRBdHRyaWJ1dGUoJ2FyaWEtcmVsZXZhbnQnLCAnYWRkaXRpb25zJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHJlcXVpcmVkIGJ5IElFLCBvdGhlciBicm93c2VycyBkb24ndCBtdWNoIGNhcmVcbiAgICAgICAgICAgICAgICBkaXYuc2V0QXR0cmlidXRlKCdhcmlhLXJlbGV2YW50JywgJ3RleHQnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGl2LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fb25DbGljay5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIGRpdi5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsIHRoaXMuX29uRm9jdXMuYmluZCh0aGlzKSk7XG4gICAgICAgICAgICBkaXYuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXNvdXQnLCB0aGlzLl9vbkZvY3VzT3V0LmJpbmQodGhpcykpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRpc3BsYXlPYmplY3QuYWNjZXNzaWJsZVRpdGxlICYmIGRpc3BsYXlPYmplY3QuYWNjZXNzaWJsZVRpdGxlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBkaXYudGl0bGUgPSBkaXNwbGF5T2JqZWN0LmFjY2Vzc2libGVUaXRsZTtcbiAgICAgICAgfSBlbHNlIGlmICghZGlzcGxheU9iamVjdC5hY2Nlc3NpYmxlSGludCB8fCBkaXNwbGF5T2JqZWN0LmFjY2Vzc2libGVIaW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICBkaXYudGl0bGUgPSAnZGlzcGxheU9iamVjdCAnICsgZGlzcGxheU9iamVjdC50YWJJbmRleDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkaXNwbGF5T2JqZWN0LmFjY2Vzc2libGVIaW50ICYmIGRpc3BsYXlPYmplY3QuYWNjZXNzaWJsZUhpbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGRpdi5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnLCBkaXNwbGF5T2JqZWN0LmFjY2Vzc2libGVIaW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vXG5cbiAgICAgICAgZGlzcGxheU9iamVjdC5fYWNjZXNzaWJsZUFjdGl2ZSA9IHRydWU7XG4gICAgICAgIGRpc3BsYXlPYmplY3QuX2FjY2Vzc2libGVEaXYgPSBkaXY7XG4gICAgICAgIGRpdi5kaXNwbGF5T2JqZWN0ID0gZGlzcGxheU9iamVjdDtcblxuICAgICAgICB0aGlzLmNoaWxkcmVuLnB1c2goZGlzcGxheU9iamVjdCk7XG4gICAgICAgIHRoaXMuZGl2LmFwcGVuZENoaWxkKGRpc3BsYXlPYmplY3QuX2FjY2Vzc2libGVEaXYpO1xuICAgICAgICBkaXNwbGF5T2JqZWN0Ll9hY2Nlc3NpYmxlRGl2LnRhYkluZGV4ID0gZGlzcGxheU9iamVjdC50YWJJbmRleDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTWFwcyB0aGUgZGl2IGJ1dHRvbiBwcmVzcyB0byBwaXhpJ3MgSW50ZXJhY3Rpb25NYW5hZ2VyIChjbGljaylcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBlIC0gVGhlIGNsaWNrIGV2ZW50LlxuICAgICAqL1xuXG5cbiAgICBBY2Nlc3NpYmlsaXR5TWFuYWdlci5wcm90b3R5cGUuX29uQ2xpY2sgPSBmdW5jdGlvbiBfb25DbGljayhlKSB7XG4gICAgICAgIHZhciBpbnRlcmFjdGlvbk1hbmFnZXIgPSB0aGlzLnJlbmRlcmVyLnBsdWdpbnMuaW50ZXJhY3Rpb247XG5cbiAgICAgICAgaW50ZXJhY3Rpb25NYW5hZ2VyLmRpc3BhdGNoRXZlbnQoZS50YXJnZXQuZGlzcGxheU9iamVjdCwgJ2NsaWNrJywgaW50ZXJhY3Rpb25NYW5hZ2VyLmV2ZW50RGF0YSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIE1hcHMgdGhlIGRpdiBmb2N1cyBldmVudHMgdG8gcGl4aSdzIEludGVyYWN0aW9uTWFuYWdlciAobW91c2VvdmVyKVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0ZvY3VzRXZlbnR9IGUgLSBUaGUgZm9jdXMgZXZlbnQuXG4gICAgICovXG5cblxuICAgIEFjY2Vzc2liaWxpdHlNYW5hZ2VyLnByb3RvdHlwZS5fb25Gb2N1cyA9IGZ1bmN0aW9uIF9vbkZvY3VzKGUpIHtcbiAgICAgICAgaWYgKCFlLnRhcmdldC5nZXRBdHRyaWJ1dGUoJ2FyaWEtbGl2ZScsICdvZmYnKSkge1xuICAgICAgICAgICAgZS50YXJnZXQuc2V0QXR0cmlidXRlKCdhcmlhLWxpdmUnLCAnYXNzZXJ0aXZlJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGludGVyYWN0aW9uTWFuYWdlciA9IHRoaXMucmVuZGVyZXIucGx1Z2lucy5pbnRlcmFjdGlvbjtcblxuICAgICAgICBpbnRlcmFjdGlvbk1hbmFnZXIuZGlzcGF0Y2hFdmVudChlLnRhcmdldC5kaXNwbGF5T2JqZWN0LCAnbW91c2VvdmVyJywgaW50ZXJhY3Rpb25NYW5hZ2VyLmV2ZW50RGF0YSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIE1hcHMgdGhlIGRpdiBmb2N1cyBldmVudHMgdG8gcGl4aSdzIEludGVyYWN0aW9uTWFuYWdlciAobW91c2VvdXQpXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Rm9jdXNFdmVudH0gZSAtIFRoZSBmb2N1c291dCBldmVudC5cbiAgICAgKi9cblxuXG4gICAgQWNjZXNzaWJpbGl0eU1hbmFnZXIucHJvdG90eXBlLl9vbkZvY3VzT3V0ID0gZnVuY3Rpb24gX29uRm9jdXNPdXQoZSkge1xuICAgICAgICBpZiAoIWUudGFyZ2V0LmdldEF0dHJpYnV0ZSgnYXJpYS1saXZlJywgJ29mZicpKSB7XG4gICAgICAgICAgICBlLnRhcmdldC5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGl2ZScsICdwb2xpdGUnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW50ZXJhY3Rpb25NYW5hZ2VyID0gdGhpcy5yZW5kZXJlci5wbHVnaW5zLmludGVyYWN0aW9uO1xuXG4gICAgICAgIGludGVyYWN0aW9uTWFuYWdlci5kaXNwYXRjaEV2ZW50KGUudGFyZ2V0LmRpc3BsYXlPYmplY3QsICdtb3VzZW91dCcsIGludGVyYWN0aW9uTWFuYWdlci5ldmVudERhdGEpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJcyBjYWxsZWQgd2hlbiBhIGtleSBpcyBwcmVzc2VkXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZSAtIFRoZSBrZXlkb3duIGV2ZW50LlxuICAgICAqL1xuXG5cbiAgICBBY2Nlc3NpYmlsaXR5TWFuYWdlci5wcm90b3R5cGUuX29uS2V5RG93biA9IGZ1bmN0aW9uIF9vbktleURvd24oZSkge1xuICAgICAgICBpZiAoZS5rZXlDb2RlICE9PSBLRVlfQ09ERV9UQUIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYWN0aXZhdGUoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSXMgY2FsbGVkIHdoZW4gdGhlIG1vdXNlIG1vdmVzIGFjcm9zcyB0aGUgcmVuZGVyZXIgZWxlbWVudFxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGUgLSBUaGUgbW91c2UgZXZlbnQuXG4gICAgICovXG5cblxuICAgIEFjY2Vzc2liaWxpdHlNYW5hZ2VyLnByb3RvdHlwZS5fb25Nb3VzZU1vdmUgPSBmdW5jdGlvbiBfb25Nb3VzZU1vdmUoZSkge1xuICAgICAgICBpZiAoZS5tb3ZlbWVudFggPT09IDAgJiYgZS5tb3ZlbWVudFkgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZGVhY3RpdmF0ZSgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyB0aGUgYWNjZXNzaWJpbGl0eSBtYW5hZ2VyXG4gICAgICpcbiAgICAgKi9cblxuXG4gICAgQWNjZXNzaWJpbGl0eU1hbmFnZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRpdiA9IG51bGw7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuW2ldLmRpdiA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB3aW5kb3cuZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUsIHRydWUpO1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuX29uS2V5RG93bik7XG5cbiAgICAgICAgdGhpcy5wb29sID0gbnVsbDtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IG51bGw7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSBudWxsO1xuICAgIH07XG5cbiAgICByZXR1cm4gQWNjZXNzaWJpbGl0eU1hbmFnZXI7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEFjY2Vzc2liaWxpdHlNYW5hZ2VyO1xuXG5cbmNvcmUuV2ViR0xSZW5kZXJlci5yZWdpc3RlclBsdWdpbignYWNjZXNzaWJpbGl0eScsIEFjY2Vzc2liaWxpdHlNYW5hZ2VyKTtcbmNvcmUuQ2FudmFzUmVuZGVyZXIucmVnaXN0ZXJQbHVnaW4oJ2FjY2Vzc2liaWxpdHknLCBBY2Nlc3NpYmlsaXR5TWFuYWdlcik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BY2Nlc3NpYmlsaXR5TWFuYWdlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbi8qKlxuICogRGVmYXVsdCBwcm9wZXJ0eSB2YWx1ZXMgb2YgYWNjZXNzaWJsZSBvYmplY3RzXG4gKiB1c2VkIGJ5IHtAbGluayBQSVhJLmFjY2Vzc2liaWxpdHkuQWNjZXNzaWJpbGl0eU1hbmFnZXJ9LlxuICpcbiAqIEBmdW5jdGlvbiBhY2Nlc3NpYmxlVGFyZ2V0XG4gKiBAbWVtYmVyb2YgUElYSS5hY2Nlc3NpYmlsaXR5XG4gKiBAZXhhbXBsZVxuICogICAgICBmdW5jdGlvbiBNeU9iamVjdCgpIHt9XG4gKlxuICogICAgICBPYmplY3QuYXNzaWduKFxuICogICAgICAgICAgTXlPYmplY3QucHJvdG90eXBlLFxuICogICAgICAgICAgUElYSS5hY2Nlc3NpYmlsaXR5LmFjY2Vzc2libGVUYXJnZXRcbiAqICAgICAgKTtcbiAqL1xuZXhwb3J0cy5kZWZhdWx0ID0ge1xuICAvKipcbiAgICogIEZsYWcgZm9yIGlmIHRoZSBvYmplY3QgaXMgYWNjZXNzaWJsZS4gSWYgdHJ1ZSBBY2Nlc3NpYmlsaXR5TWFuYWdlciB3aWxsIG92ZXJsYXkgYVxuICAgKiAgIHNoYWRvdyBkaXYgd2l0aCBhdHRyaWJ1dGVzIHNldFxuICAgKlxuICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgKi9cbiAgYWNjZXNzaWJsZTogZmFsc2UsXG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHRpdGxlIGF0dHJpYnV0ZSBvZiB0aGUgc2hhZG93IGRpdlxuICAgKiBJZiBhY2Nlc3NpYmxlVGl0bGUgQU5EIGFjY2Vzc2libGVIaW50IGhhcyBub3QgYmVlbiB0aGlzIHdpbGwgZGVmYXVsdCB0byAnZGlzcGxheU9iamVjdCBbdGFiSW5kZXhdJ1xuICAgKlxuICAgKiBAbWVtYmVyIHtzdHJpbmd9XG4gICAqL1xuICBhY2Nlc3NpYmxlVGl0bGU6IG51bGwsXG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGFyaWEtbGFiZWwgYXR0cmlidXRlIG9mIHRoZSBzaGFkb3cgZGl2XG4gICAqXG4gICAqIEBtZW1iZXIge3N0cmluZ31cbiAgICovXG4gIGFjY2Vzc2libGVIaW50OiBudWxsLFxuXG4gIC8qKlxuICAgKiBAdG9kbyBOZWVkcyBkb2NzLlxuICAgKi9cbiAgdGFiSW5kZXg6IDAsXG5cbiAgLyoqXG4gICAqIEB0b2RvIE5lZWRzIGRvY3MuXG4gICAqL1xuICBfYWNjZXNzaWJsZUFjdGl2ZTogZmFsc2UsXG5cbiAgLyoqXG4gICAqIEB0b2RvIE5lZWRzIGRvY3MuXG4gICAqL1xuICBfYWNjZXNzaWJsZURpdjogZmFsc2Vcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hY2Nlc3NpYmxlVGFyZ2V0LmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9hY2Nlc3NpYmxlVGFyZ2V0ID0gcmVxdWlyZSgnLi9hY2Nlc3NpYmxlVGFyZ2V0Jyk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnYWNjZXNzaWJsZVRhcmdldCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2FjY2Vzc2libGVUYXJnZXQpLmRlZmF1bHQ7XG4gIH1cbn0pO1xuXG52YXIgX0FjY2Vzc2liaWxpdHlNYW5hZ2VyID0gcmVxdWlyZSgnLi9BY2Nlc3NpYmlsaXR5TWFuYWdlcicpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ0FjY2Vzc2liaWxpdHlNYW5hZ2VyJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQWNjZXNzaWJpbGl0eU1hbmFnZXIpLmRlZmF1bHQ7XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2F1dG9EZXRlY3RSZW5kZXJlciA9IHJlcXVpcmUoJy4vYXV0b0RldGVjdFJlbmRlcmVyJyk7XG5cbnZhciBfQ29udGFpbmVyID0gcmVxdWlyZSgnLi9kaXNwbGF5L0NvbnRhaW5lcicpO1xuXG52YXIgX0NvbnRhaW5lcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Db250YWluZXIpO1xuXG52YXIgX3RpY2tlciA9IHJlcXVpcmUoJy4vdGlja2VyJyk7XG5cbnZhciBfc2V0dGluZ3MgPSByZXF1aXJlKCcuL3NldHRpbmdzJyk7XG5cbnZhciBfc2V0dGluZ3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc2V0dGluZ3MpO1xuXG52YXIgX2NvbnN0ID0gcmVxdWlyZSgnLi9jb25zdCcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vKipcbiAqIENvbnZlbmllbmNlIGNsYXNzIHRvIGNyZWF0ZSBhIG5ldyBQSVhJIGFwcGxpY2F0aW9uLlxuICogVGhpcyBjbGFzcyBhdXRvbWF0aWNhbGx5IGNyZWF0ZXMgdGhlIHJlbmRlcmVyLCB0aWNrZXJcbiAqIGFuZCByb290IGNvbnRhaW5lci5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gQ3JlYXRlIHRoZSBhcHBsaWNhdGlvblxuICogY29uc3QgYXBwID0gbmV3IFBJWEkuQXBwbGljYXRpb24oKTtcbiAqXG4gKiAvLyBBZGQgdGhlIHZpZXcgdG8gdGhlIERPTVxuICogZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChhcHAudmlldyk7XG4gKlxuICogLy8gZXgsIGFkZCBkaXNwbGF5IG9iamVjdHNcbiAqIGFwcC5zdGFnZS5hZGRDaGlsZChQSVhJLlNwcml0ZS5mcm9tSW1hZ2UoJ3NvbWV0aGluZy5wbmcnKSk7XG4gKlxuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgUElYSVxuICovXG52YXIgQXBwbGljYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHZhbGlkLWpzZG9jXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAtIFRoZSBvcHRpb25hbCByZW5kZXJlciBwYXJhbWV0ZXJzXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5hdXRvU3RhcnQ9dHJ1ZV0gLSBhdXRvbWF0aWNhbGx5IHN0YXJ0cyB0aGUgcmVuZGVyaW5nIGFmdGVyIHRoZSBjb25zdHJ1Y3Rpb24uXG4gICAgICogICAgIE5vdGUgdGhhdCBzZXR0aW5nIHRoaXMgcGFyYW1ldGVyIHRvIGZhbHNlIGRvZXMgTk9UIHN0b3AgdGhlIHNoYXJlZCB0aWNrZXIgZXZlbiBpZiB5b3Ugc2V0XG4gICAgICogICAgIG9wdGlvbnMuc2hhcmVkVGlja2VyIHRvIHRydWUgaW4gY2FzZSB0aGF0IGl0IGlzIGFscmVhZHkgc3RhcnRlZC4gU3RvcCBpdCBieSB5b3VyIG93bi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMud2lkdGg9ODAwXSAtIHRoZSB3aWR0aCBvZiB0aGUgcmVuZGVyZXJzIHZpZXdcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuaGVpZ2h0PTYwMF0gLSB0aGUgaGVpZ2h0IG9mIHRoZSByZW5kZXJlcnMgdmlld1xuICAgICAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IFtvcHRpb25zLnZpZXddIC0gdGhlIGNhbnZhcyB0byB1c2UgYXMgYSB2aWV3LCBvcHRpb25hbFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhbnNwYXJlbnQ9ZmFsc2VdIC0gSWYgdGhlIHJlbmRlciB2aWV3IGlzIHRyYW5zcGFyZW50LCBkZWZhdWx0IGZhbHNlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5hbnRpYWxpYXM9ZmFsc2VdIC0gc2V0cyBhbnRpYWxpYXMgKG9ubHkgYXBwbGljYWJsZSBpbiBjaHJvbWUgYXQgdGhlIG1vbWVudClcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnByZXNlcnZlRHJhd2luZ0J1ZmZlcj1mYWxzZV0gLSBlbmFibGVzIGRyYXdpbmcgYnVmZmVyIHByZXNlcnZhdGlvbiwgZW5hYmxlIHRoaXMgaWYgeW91XG4gICAgICogIG5lZWQgdG8gY2FsbCB0b0RhdGFVcmwgb24gdGhlIHdlYmdsIGNvbnRleHRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMucmVzb2x1dGlvbj0xXSAtIFRoZSByZXNvbHV0aW9uIC8gZGV2aWNlIHBpeGVsIHJhdGlvIG9mIHRoZSByZW5kZXJlciwgcmV0aW5hIHdvdWxkIGJlIDJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmZvcmNlQ2FudmFzPWZhbHNlXSAtIHByZXZlbnRzIHNlbGVjdGlvbiBvZiBXZWJHTCByZW5kZXJlciwgZXZlbiBpZiBzdWNoIGlzIHByZXNlbnRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuYmFja2dyb3VuZENvbG9yPTB4MDAwMDAwXSAtIFRoZSBiYWNrZ3JvdW5kIGNvbG9yIG9mIHRoZSByZW5kZXJlZCBhcmVhXG4gICAgICogIChzaG93biBpZiBub3QgdHJhbnNwYXJlbnQpLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY2xlYXJCZWZvcmVSZW5kZXI9dHJ1ZV0gLSBUaGlzIHNldHMgaWYgdGhlIHJlbmRlcmVyIHdpbGwgY2xlYXIgdGhlIGNhbnZhcyBvclxuICAgICAqICAgbm90IGJlZm9yZSB0aGUgbmV3IHJlbmRlciBwYXNzLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucm91bmRQaXhlbHM9ZmFsc2VdIC0gSWYgdHJ1ZSBQaXhpSlMgd2lsbCBNYXRoLmZsb29yKCkgeC95IHZhbHVlcyB3aGVuIHJlbmRlcmluZyxcbiAgICAgKiAgc3RvcHBpbmcgcGl4ZWwgaW50ZXJwb2xhdGlvbi5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmZvcmNlRlhBQT1mYWxzZV0gLSBmb3JjZXMgRlhBQSBhbnRpYWxpYXNpbmcgdG8gYmUgdXNlZCBvdmVyIG5hdGl2ZS5cbiAgICAgKiAgRlhBQSBpcyBmYXN0ZXIsIGJ1dCBtYXkgbm90IGFsd2F5cyBsb29rIGFzIGdyZWF0ICoqd2ViZ2wgb25seSoqXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWdhY3k9ZmFsc2VdIC0gYHRydWVgIHRvIGVuc3VyZSBjb21wYXRpYmlsaXR5IHdpdGggb2xkZXIgLyBsZXNzIGFkdmFuY2VkIGRldmljZXMuXG4gICAgICogIElmIHlvdSBleHBlcmllbmNlIHVuZXhwbGFpbmVkIGZsaWNrZXJpbmcgdHJ5IHNldHRpbmcgdGhpcyB0byB0cnVlLiAqKndlYmdsIG9ubHkqKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wb3dlclByZWZlcmVuY2VdIC0gUGFyYW1ldGVyIHBhc3NlZCB0byB3ZWJnbCBjb250ZXh0LCBzZXQgdG8gXCJoaWdoLXBlcmZvcm1hbmNlXCJcbiAgICAgKiAgZm9yIGRldmljZXMgd2l0aCBkdWFsIGdyYXBoaWNzIGNhcmQgKip3ZWJnbCBvbmx5KipcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNoYXJlZFRpY2tlcj1mYWxzZV0gLSBgdHJ1ZWAgdG8gdXNlIFBJWEkudGlja2VyLnNoYXJlZCwgYGZhbHNlYCB0byBjcmVhdGUgbmV3IHRpY2tlci5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNoYXJlZExvYWRlcj1mYWxzZV0gLSBgdHJ1ZWAgdG8gdXNlIFBJWEkubG9hZGVycy5zaGFyZWQsIGBmYWxzZWAgdG8gY3JlYXRlIG5ldyBMb2FkZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gQXBwbGljYXRpb24ob3B0aW9ucywgYXJnMiwgYXJnMywgYXJnNCwgYXJnNSkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQXBwbGljYXRpb24pO1xuXG4gICAgICAgIC8vIFN1cHBvcnQgZm9yIGNvbnN0cnVjdG9yKHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMsIG5vV2ViR0wsIHVzZVNoYXJlZFRpY2tlcilcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgICAgIHdpZHRoOiBvcHRpb25zLFxuICAgICAgICAgICAgICAgIGhlaWdodDogYXJnMiB8fCBfc2V0dGluZ3MyLmRlZmF1bHQuUkVOREVSX09QVElPTlMuaGVpZ2h0LFxuICAgICAgICAgICAgICAgIGZvcmNlQ2FudmFzOiAhIWFyZzQsXG4gICAgICAgICAgICAgICAgc2hhcmVkVGlja2VyOiAhIWFyZzVcbiAgICAgICAgICAgIH0sIGFyZzMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkZWZhdWx0IG9wdGlvbnMsIHNvIHdlIG1peGluIGZ1bmN0aW9uYWxpdHkgbGF0ZXIuXG4gICAgICAgICAqIEBtZW1iZXIge29iamVjdH1cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIGF1dG9TdGFydDogdHJ1ZSxcbiAgICAgICAgICAgIHNoYXJlZFRpY2tlcjogZmFsc2UsXG4gICAgICAgICAgICBmb3JjZUNhbnZhczogZmFsc2UsXG4gICAgICAgICAgICBzaGFyZWRMb2FkZXI6IGZhbHNlXG4gICAgICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXZWJHTCByZW5kZXJlciBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSBDYW52YXNSZW5kZXJlclxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLldlYkdMUmVuZGVyZXJ8UElYSS5DYW52YXNSZW5kZXJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSAoMCwgX2F1dG9EZXRlY3RSZW5kZXJlci5hdXRvRGV0ZWN0UmVuZGVyZXIpKG9wdGlvbnMpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcm9vdCBkaXNwbGF5IGNvbnRhaW5lciB0aGF0J3MgcmVuZGVyZWQuXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuQ29udGFpbmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGFnZSA9IG5ldyBfQ29udGFpbmVyMi5kZWZhdWx0KCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEludGVybmFsIHJlZmVyZW5jZSB0byB0aGUgdGlja2VyXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkudGlja2VyLlRpY2tlcn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3RpY2tlciA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRpY2tlciBmb3IgZG9pbmcgcmVuZGVyIHVwZGF0ZXMuXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkudGlja2VyLlRpY2tlcn1cbiAgICAgICAgICogQGRlZmF1bHQgUElYSS50aWNrZXIuc2hhcmVkXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRpY2tlciA9IG9wdGlvbnMuc2hhcmVkVGlja2VyID8gX3RpY2tlci5zaGFyZWQgOiBuZXcgX3RpY2tlci5UaWNrZXIoKTtcblxuICAgICAgICAvLyBTdGFydCB0aGUgcmVuZGVyaW5nXG4gICAgICAgIGlmIChvcHRpb25zLmF1dG9TdGFydCkge1xuICAgICAgICAgICAgdGhpcy5zdGFydCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIHRoZSBjdXJyZW50IHN0YWdlLlxuICAgICAqL1xuICAgIEFwcGxpY2F0aW9uLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIucmVuZGVyKHRoaXMuc3RhZ2UpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBtZXRob2QgZm9yIHN0b3BwaW5nIHRoZSByZW5kZXIuXG4gICAgICovXG5cblxuICAgIEFwcGxpY2F0aW9uLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gc3RvcCgpIHtcbiAgICAgICAgdGhpcy5fdGlja2VyLnN0b3AoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ29udmVuaWVuY2UgbWV0aG9kIGZvciBzdGFydGluZyB0aGUgcmVuZGVyLlxuICAgICAqL1xuXG5cbiAgICBBcHBsaWNhdGlvbi5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICAgICAgdGhpcy5fdGlja2VyLnN0YXJ0KCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlZmVyZW5jZSB0byB0aGUgcmVuZGVyZXIncyBjYW52YXMgZWxlbWVudC5cbiAgICAgKiBAbWVtYmVyIHtIVE1MQ2FudmFzRWxlbWVudH1cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cblxuXG4gICAgLyoqXG4gICAgICogRGVzdHJveSBhbmQgZG9uJ3QgdXNlIGFmdGVyIHRoaXMuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbcmVtb3ZlVmlldz1mYWxzZV0gQXV0b21hdGljYWxseSByZW1vdmUgY2FudmFzIGZyb20gRE9NLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fGJvb2xlYW59IFtzdGFnZU9wdGlvbnNdIC0gT3B0aW9ucyBwYXJhbWV0ZXIuIEEgYm9vbGVhbiB3aWxsIGFjdCBhcyBpZiBhbGwgb3B0aW9uc1xuICAgICAqICBoYXZlIGJlZW4gc2V0IHRvIHRoYXQgdmFsdWVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtzdGFnZU9wdGlvbnMuY2hpbGRyZW49ZmFsc2VdIC0gaWYgc2V0IHRvIHRydWUsIGFsbCB0aGUgY2hpbGRyZW4gd2lsbCBoYXZlIHRoZWlyIGRlc3Ryb3lcbiAgICAgKiAgbWV0aG9kIGNhbGxlZCBhcyB3ZWxsLiAnc3RhZ2VPcHRpb25zJyB3aWxsIGJlIHBhc3NlZCBvbiB0byB0aG9zZSBjYWxscy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtzdGFnZU9wdGlvbnMudGV4dHVyZT1mYWxzZV0gLSBPbmx5IHVzZWQgZm9yIGNoaWxkIFNwcml0ZXMgaWYgc3RhZ2VPcHRpb25zLmNoaWxkcmVuIGlzIHNldFxuICAgICAqICB0byB0cnVlLiBTaG91bGQgaXQgZGVzdHJveSB0aGUgdGV4dHVyZSBvZiB0aGUgY2hpbGQgc3ByaXRlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbc3RhZ2VPcHRpb25zLmJhc2VUZXh0dXJlPWZhbHNlXSAtIE9ubHkgdXNlZCBmb3IgY2hpbGQgU3ByaXRlcyBpZiBzdGFnZU9wdGlvbnMuY2hpbGRyZW4gaXMgc2V0XG4gICAgICogIHRvIHRydWUuIFNob3VsZCBpdCBkZXN0cm95IHRoZSBiYXNlIHRleHR1cmUgb2YgdGhlIGNoaWxkIHNwcml0ZVxuICAgICAqL1xuICAgIEFwcGxpY2F0aW9uLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveShyZW1vdmVWaWV3LCBzdGFnZU9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RpY2tlcikge1xuICAgICAgICAgICAgdmFyIG9sZFRpY2tlciA9IHRoaXMuX3RpY2tlcjtcblxuICAgICAgICAgICAgdGhpcy50aWNrZXIgPSBudWxsO1xuICAgICAgICAgICAgb2xkVGlja2VyLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc3RhZ2UuZGVzdHJveShzdGFnZU9wdGlvbnMpO1xuICAgICAgICB0aGlzLnN0YWdlID0gbnVsbDtcblxuICAgICAgICB0aGlzLnJlbmRlcmVyLmRlc3Ryb3kocmVtb3ZlVmlldyk7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuX29wdGlvbnMgPSBudWxsO1xuICAgIH07XG5cbiAgICBfY3JlYXRlQ2xhc3MoQXBwbGljYXRpb24sIFt7XG4gICAgICAgIGtleTogJ3RpY2tlcicsXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHRpY2tlcikgLy8gZXNsaW50LWRpc2FibGUtbGluZSByZXF1aXJlLWpzZG9jXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl90aWNrZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90aWNrZXIucmVtb3ZlKHRoaXMucmVuZGVyLCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3RpY2tlciA9IHRpY2tlcjtcbiAgICAgICAgICAgIGlmICh0aWNrZXIpIHtcbiAgICAgICAgICAgICAgICB0aWNrZXIuYWRkKHRoaXMucmVuZGVyLCB0aGlzLCBfY29uc3QuVVBEQVRFX1BSSU9SSVRZLkxPVyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkgLy8gZXNsaW50LWRpc2FibGUtbGluZSByZXF1aXJlLWpzZG9jXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90aWNrZXI7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3ZpZXcnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLnZpZXc7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVmZXJlbmNlIHRvIHRoZSByZW5kZXJlcidzIHNjcmVlbiByZWN0YW5nbGUuIEl0cyBzYWZlIHRvIHVzZSBhcyBmaWx0ZXJBcmVhIG9yIGhpdEFyZWEgZm9yIHdob2xlIHNjcmVlblxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLlJlY3RhbmdsZX1cbiAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdzY3JlZW4nLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLnNjcmVlbjtcbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBBcHBsaWNhdGlvbjtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gQXBwbGljYXRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BcHBsaWNhdGlvbi5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfcGl4aUdsQ29yZSA9IHJlcXVpcmUoJ3BpeGktZ2wtY29yZScpO1xuXG52YXIgX3NldHRpbmdzID0gcmVxdWlyZSgnLi9zZXR0aW5ncycpO1xuXG52YXIgX3NldHRpbmdzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NldHRpbmdzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5mdW5jdGlvbiBjaGVja1ByZWNpc2lvbihzcmMsIGRlZikge1xuICAgIGlmIChzcmMgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICBpZiAoc3JjWzBdLnN1YnN0cmluZygwLCA5KSAhPT0gJ3ByZWNpc2lvbicpIHtcbiAgICAgICAgICAgIHZhciBjb3B5ID0gc3JjLnNsaWNlKDApO1xuXG4gICAgICAgICAgICBjb3B5LnVuc2hpZnQoJ3ByZWNpc2lvbiAnICsgZGVmICsgJyBmbG9hdDsnKTtcblxuICAgICAgICAgICAgcmV0dXJuIGNvcHk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHNyYy50cmltKCkuc3Vic3RyaW5nKDAsIDkpICE9PSAncHJlY2lzaW9uJykge1xuICAgICAgICByZXR1cm4gJ3ByZWNpc2lvbiAnICsgZGVmICsgJyBmbG9hdDtcXG4nICsgc3JjO1xuICAgIH1cblxuICAgIHJldHVybiBzcmM7XG59XG5cbi8qKlxuICogV3JhcHBlciBjbGFzcywgd2ViR0wgU2hhZGVyIGZvciBQaXhpLlxuICogQWRkcyBwcmVjaXNpb24gc3RyaW5nIGlmIHZlcnRleFNyYyBvciBmcmFnbWVudFNyYyBoYXZlIG5vIG1lbnRpb24gb2YgaXQuXG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBHTFNoYWRlclxuICogQG1lbWJlcm9mIFBJWElcbiAqL1xuXG52YXIgU2hhZGVyID0gZnVuY3Rpb24gKF9HTFNoYWRlcikge1xuICAgIF9pbmhlcml0cyhTaGFkZXIsIF9HTFNoYWRlcik7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCAtIFRoZSBjdXJyZW50IFdlYkdMIHJlbmRlcmluZyBjb250ZXh0XG4gICAgICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IHZlcnRleFNyYyAtIFRoZSB2ZXJ0ZXggc2hhZGVyIHNvdXJjZSBhcyBhbiBhcnJheSBvZiBzdHJpbmdzLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBmcmFnbWVudFNyYyAtIFRoZSBmcmFnbWVudCBzaGFkZXIgc291cmNlIGFzIGFuIGFycmF5IG9mIHN0cmluZ3MuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFthdHRyaWJ1dGVMb2NhdGlvbnNdIC0gQSBrZXkgdmFsdWUgcGFpciBzaG93aW5nIHdoaWNoIGxvY2F0aW9uIGVhY3QgYXR0cmlidXRlIHNob3VsZCBzaXQuXG4gICAgICAgICAgICAgICAgICAgICAgIGUuZy4ge3Bvc2l0aW9uOjAsIHV2czoxfS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3ByZWNpc2lvbl0gLSBUaGUgZmxvYXQgcHJlY2lzaW9uIG9mIHRoZSBzaGFkZXIuIE9wdGlvbnMgYXJlICdsb3dwJywgJ21lZGl1bXAnIG9yICdoaWdocCcuXG4gICAgICovXG4gICAgZnVuY3Rpb24gU2hhZGVyKGdsLCB2ZXJ0ZXhTcmMsIGZyYWdtZW50U3JjLCBhdHRyaWJ1dGVMb2NhdGlvbnMsIHByZWNpc2lvbikge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2hhZGVyKTtcblxuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0dMU2hhZGVyLmNhbGwodGhpcywgZ2wsIGNoZWNrUHJlY2lzaW9uKHZlcnRleFNyYywgcHJlY2lzaW9uIHx8IF9zZXR0aW5nczIuZGVmYXVsdC5QUkVDSVNJT05fVkVSVEVYKSwgY2hlY2tQcmVjaXNpb24oZnJhZ21lbnRTcmMsIHByZWNpc2lvbiB8fCBfc2V0dGluZ3MyLmRlZmF1bHQuUFJFQ0lTSU9OX0ZSQUdNRU5UKSwgdW5kZWZpbmVkLCBhdHRyaWJ1dGVMb2NhdGlvbnMpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gU2hhZGVyO1xufShfcGl4aUdsQ29yZS5HTFNoYWRlcik7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFNoYWRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNoYWRlci5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmF1dG9EZXRlY3RSZW5kZXJlciA9IGF1dG9EZXRlY3RSZW5kZXJlcjtcblxudmFyIF91dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxudmFyIHV0aWxzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX3V0aWxzKTtcblxudmFyIF9DYW52YXNSZW5kZXJlciA9IHJlcXVpcmUoJy4vcmVuZGVyZXJzL2NhbnZhcy9DYW52YXNSZW5kZXJlcicpO1xuXG52YXIgX0NhbnZhc1JlbmRlcmVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0NhbnZhc1JlbmRlcmVyKTtcblxudmFyIF9XZWJHTFJlbmRlcmVyID0gcmVxdWlyZSgnLi9yZW5kZXJlcnMvd2ViZ2wvV2ViR0xSZW5kZXJlcicpO1xuXG52YXIgX1dlYkdMUmVuZGVyZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfV2ViR0xSZW5kZXJlcik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB2YWxpZC1qc2RvY1xuLyoqXG4gKiBUaGlzIGhlbHBlciBmdW5jdGlvbiB3aWxsIGF1dG9tYXRpY2FsbHkgZGV0ZWN0IHdoaWNoIHJlbmRlcmVyIHlvdSBzaG91bGQgYmUgdXNpbmcuXG4gKiBXZWJHTCBpcyB0aGUgcHJlZmVycmVkIHJlbmRlcmVyIGFzIGl0IGlzIGEgbG90IGZhc3Rlci4gSWYgd2ViR0wgaXMgbm90IHN1cHBvcnRlZCBieVxuICogdGhlIGJyb3dzZXIgdGhlbiB0aGlzIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIGEgY2FudmFzIHJlbmRlcmVyXG4gKlxuICogQG1lbWJlcm9mIFBJWElcbiAqIEBmdW5jdGlvbiBhdXRvRGV0ZWN0UmVuZGVyZXJcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gLSBUaGUgb3B0aW9uYWwgcmVuZGVyZXIgcGFyYW1ldGVyc1xuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLndpZHRoPTgwMF0gLSB0aGUgd2lkdGggb2YgdGhlIHJlbmRlcmVycyB2aWV3XG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuaGVpZ2h0PTYwMF0gLSB0aGUgaGVpZ2h0IG9mIHRoZSByZW5kZXJlcnMgdmlld1xuICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gW29wdGlvbnMudmlld10gLSB0aGUgY2FudmFzIHRvIHVzZSBhcyBhIHZpZXcsIG9wdGlvbmFsXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYW5zcGFyZW50PWZhbHNlXSAtIElmIHRoZSByZW5kZXIgdmlldyBpcyB0cmFuc3BhcmVudCwgZGVmYXVsdCBmYWxzZVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5hbnRpYWxpYXM9ZmFsc2VdIC0gc2V0cyBhbnRpYWxpYXMgKG9ubHkgYXBwbGljYWJsZSBpbiBjaHJvbWUgYXQgdGhlIG1vbWVudClcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucHJlc2VydmVEcmF3aW5nQnVmZmVyPWZhbHNlXSAtIGVuYWJsZXMgZHJhd2luZyBidWZmZXIgcHJlc2VydmF0aW9uLCBlbmFibGUgdGhpcyBpZiB5b3VcbiAqICBuZWVkIHRvIGNhbGwgdG9EYXRhVXJsIG9uIHRoZSB3ZWJnbCBjb250ZXh0XG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuYmFja2dyb3VuZENvbG9yPTB4MDAwMDAwXSAtIFRoZSBiYWNrZ3JvdW5kIGNvbG9yIG9mIHRoZSByZW5kZXJlZCBhcmVhXG4gKiAgKHNob3duIGlmIG5vdCB0cmFuc3BhcmVudCkuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNsZWFyQmVmb3JlUmVuZGVyPXRydWVdIC0gVGhpcyBzZXRzIGlmIHRoZSByZW5kZXJlciB3aWxsIGNsZWFyIHRoZSBjYW52YXMgb3JcbiAqICAgbm90IGJlZm9yZSB0aGUgbmV3IHJlbmRlciBwYXNzLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnJlc29sdXRpb249MV0gLSBUaGUgcmVzb2x1dGlvbiAvIGRldmljZSBwaXhlbCByYXRpbyBvZiB0aGUgcmVuZGVyZXIsIHJldGluYSB3b3VsZCBiZSAyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmZvcmNlQ2FudmFzPWZhbHNlXSAtIHByZXZlbnRzIHNlbGVjdGlvbiBvZiBXZWJHTCByZW5kZXJlciwgZXZlbiBpZiBzdWNoIGlzIHByZXNlbnRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucm91bmRQaXhlbHM9ZmFsc2VdIC0gSWYgdHJ1ZSBQaXhpSlMgd2lsbCBNYXRoLmZsb29yKCkgeC95IHZhbHVlcyB3aGVuIHJlbmRlcmluZyxcbiAqICBzdG9wcGluZyBwaXhlbCBpbnRlcnBvbGF0aW9uLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5mb3JjZUZYQUE9ZmFsc2VdIC0gZm9yY2VzIEZYQUEgYW50aWFsaWFzaW5nIHRvIGJlIHVzZWQgb3ZlciBuYXRpdmUuXG4gKiAgRlhBQSBpcyBmYXN0ZXIsIGJ1dCBtYXkgbm90IGFsd2F5cyBsb29rIGFzIGdyZWF0ICoqd2ViZ2wgb25seSoqXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxlZ2FjeT1mYWxzZV0gLSBgdHJ1ZWAgdG8gZW5zdXJlIGNvbXBhdGliaWxpdHkgd2l0aCBvbGRlciAvIGxlc3MgYWR2YW5jZWQgZGV2aWNlcy5cbiAqICBJZiB5b3UgZXhwZXJpZW5jZSB1bmV4cGxhaW5lZCBmbGlja2VyaW5nIHRyeSBzZXR0aW5nIHRoaXMgdG8gdHJ1ZS4gKip3ZWJnbCBvbmx5KipcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wb3dlclByZWZlcmVuY2VdIC0gUGFyYW1ldGVyIHBhc3NlZCB0byB3ZWJnbCBjb250ZXh0LCBzZXQgdG8gXCJoaWdoLXBlcmZvcm1hbmNlXCJcbiAqICBmb3IgZGV2aWNlcyB3aXRoIGR1YWwgZ3JhcGhpY3MgY2FyZCAqKndlYmdsIG9ubHkqKlxuICogQHJldHVybiB7UElYSS5XZWJHTFJlbmRlcmVyfFBJWEkuQ2FudmFzUmVuZGVyZXJ9IFJldHVybnMgV2ViR0wgcmVuZGVyZXIgaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgQ2FudmFzUmVuZGVyZXJcbiAqL1xuZnVuY3Rpb24gYXV0b0RldGVjdFJlbmRlcmVyKG9wdGlvbnMsIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICAvLyBCYWNrd2FyZC1jb21wYXRpYmxlIHN1cHBvcnQgZm9yIG5vV2ViR0wgb3B0aW9uXG4gICAgdmFyIGZvcmNlQ2FudmFzID0gb3B0aW9ucyAmJiBvcHRpb25zLmZvcmNlQ2FudmFzO1xuXG4gICAgaWYgKGFyZzMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBmb3JjZUNhbnZhcyA9IGFyZzM7XG4gICAgfVxuXG4gICAgaWYgKCFmb3JjZUNhbnZhcyAmJiB1dGlscy5pc1dlYkdMU3VwcG9ydGVkKCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBfV2ViR0xSZW5kZXJlcjIuZGVmYXVsdChvcHRpb25zLCBhcmcxLCBhcmcyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IF9DYW52YXNSZW5kZXJlcjIuZGVmYXVsdChvcHRpb25zLCBhcmcxLCBhcmcyKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWF1dG9EZXRlY3RSZW5kZXJlci5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG4vKipcbiAqIFN0cmluZyBvZiB0aGUgY3VycmVudCBQSVhJIHZlcnNpb24uXG4gKlxuICogQHN0YXRpY1xuICogQGNvbnN0YW50XG4gKiBAbWVtYmVyb2YgUElYSVxuICogQG5hbWUgVkVSU0lPTlxuICogQHR5cGUge3N0cmluZ31cbiAqL1xudmFyIFZFUlNJT04gPSBleHBvcnRzLlZFUlNJT04gPSAnNC44LjgnO1xuXG4vKipcbiAqIFR3byBQaS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAY29uc3RhbnRcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG52YXIgUElfMiA9IGV4cG9ydHMuUElfMiA9IE1hdGguUEkgKiAyO1xuXG4vKipcbiAqIENvbnZlcnNpb24gZmFjdG9yIGZvciBjb252ZXJ0aW5nIHJhZGlhbnMgdG8gZGVncmVlcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAY29uc3RhbnRcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG52YXIgUkFEX1RPX0RFRyA9IGV4cG9ydHMuUkFEX1RPX0RFRyA9IDE4MCAvIE1hdGguUEk7XG5cbi8qKlxuICogQ29udmVyc2lvbiBmYWN0b3IgZm9yIGNvbnZlcnRpbmcgZGVncmVlcyB0byByYWRpYW5zLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBjb25zdGFudFxuICogQG1lbWJlcm9mIFBJWElcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbnZhciBERUdfVE9fUkFEID0gZXhwb3J0cy5ERUdfVE9fUkFEID0gTWF0aC5QSSAvIDE4MDtcblxuLyoqXG4gKiBDb25zdGFudCB0byBpZGVudGlmeSB0aGUgUmVuZGVyZXIgVHlwZS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAY29uc3RhbnRcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKiBAbmFtZSBSRU5ERVJFUl9UWVBFXG4gKiBAdHlwZSB7b2JqZWN0fVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFVOS05PV04gLSBVbmtub3duIHJlbmRlciB0eXBlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFdFQkdMIC0gV2ViR0wgcmVuZGVyIHR5cGUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gQ0FOVkFTIC0gQ2FudmFzIHJlbmRlciB0eXBlLlxuICovXG52YXIgUkVOREVSRVJfVFlQRSA9IGV4cG9ydHMuUkVOREVSRVJfVFlQRSA9IHtcbiAgVU5LTk9XTjogMCxcbiAgV0VCR0w6IDEsXG4gIENBTlZBUzogMlxufTtcblxuLyoqXG4gKiBWYXJpb3VzIGJsZW5kIG1vZGVzIHN1cHBvcnRlZCBieSBQSVhJLlxuICpcbiAqIElNUE9SVEFOVCAtIFRoZSBXZWJHTCByZW5kZXJlciBvbmx5IHN1cHBvcnRzIHRoZSBOT1JNQUwsIEFERCwgTVVMVElQTFkgYW5kIFNDUkVFTiBibGVuZCBtb2Rlcy5cbiAqIEFueXRoaW5nIGVsc2Ugd2lsbCBzaWxlbnRseSBhY3QgbGlrZSBOT1JNQUwuXG4gKlxuICogQHN0YXRpY1xuICogQGNvbnN0YW50XG4gKiBAbWVtYmVyb2YgUElYSVxuICogQG5hbWUgQkxFTkRfTU9ERVNcbiAqIEB0eXBlIHtvYmplY3R9XG4gKiBAcHJvcGVydHkge251bWJlcn0gTk9STUFMXG4gKiBAcHJvcGVydHkge251bWJlcn0gQUREXG4gKiBAcHJvcGVydHkge251bWJlcn0gTVVMVElQTFlcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBTQ1JFRU5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBPVkVSTEFZXG4gKiBAcHJvcGVydHkge251bWJlcn0gREFSS0VOXG4gKiBAcHJvcGVydHkge251bWJlcn0gTElHSFRFTlxuICogQHByb3BlcnR5IHtudW1iZXJ9IENPTE9SX0RPREdFXG4gKiBAcHJvcGVydHkge251bWJlcn0gQ09MT1JfQlVSTlxuICogQHByb3BlcnR5IHtudW1iZXJ9IEhBUkRfTElHSFRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBTT0ZUX0xJR0hUXG4gKiBAcHJvcGVydHkge251bWJlcn0gRElGRkVSRU5DRVxuICogQHByb3BlcnR5IHtudW1iZXJ9IEVYQ0xVU0lPTlxuICogQHByb3BlcnR5IHtudW1iZXJ9IEhVRVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFNBVFVSQVRJT05cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBDT0xPUlxuICogQHByb3BlcnR5IHtudW1iZXJ9IExVTUlOT1NJVFlcbiAqL1xudmFyIEJMRU5EX01PREVTID0gZXhwb3J0cy5CTEVORF9NT0RFUyA9IHtcbiAgTk9STUFMOiAwLFxuICBBREQ6IDEsXG4gIE1VTFRJUExZOiAyLFxuICBTQ1JFRU46IDMsXG4gIE9WRVJMQVk6IDQsXG4gIERBUktFTjogNSxcbiAgTElHSFRFTjogNixcbiAgQ09MT1JfRE9ER0U6IDcsXG4gIENPTE9SX0JVUk46IDgsXG4gIEhBUkRfTElHSFQ6IDksXG4gIFNPRlRfTElHSFQ6IDEwLFxuICBESUZGRVJFTkNFOiAxMSxcbiAgRVhDTFVTSU9OOiAxMixcbiAgSFVFOiAxMyxcbiAgU0FUVVJBVElPTjogMTQsXG4gIENPTE9SOiAxNSxcbiAgTFVNSU5PU0lUWTogMTYsXG4gIE5PUk1BTF9OUE06IDE3LFxuICBBRERfTlBNOiAxOCxcbiAgU0NSRUVOX05QTTogMTlcbn07XG5cbi8qKlxuICogVmFyaW91cyB3ZWJnbCBkcmF3IG1vZGVzLiBUaGVzZSBjYW4gYmUgdXNlZCB0byBzcGVjaWZ5IHdoaWNoIEdMIGRyYXdNb2RlIHRvIHVzZVxuICogdW5kZXIgY2VydGFpbiBzaXR1YXRpb25zIGFuZCByZW5kZXJlcnMuXG4gKlxuICogQHN0YXRpY1xuICogQGNvbnN0YW50XG4gKiBAbWVtYmVyb2YgUElYSVxuICogQG5hbWUgRFJBV19NT0RFU1xuICogQHR5cGUge29iamVjdH1cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBQT0lOVFNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBMSU5FU1xuICogQHByb3BlcnR5IHtudW1iZXJ9IExJTkVfTE9PUFxuICogQHByb3BlcnR5IHtudW1iZXJ9IExJTkVfU1RSSVBcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBUUklBTkdMRVNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBUUklBTkdMRV9TVFJJUFxuICogQHByb3BlcnR5IHtudW1iZXJ9IFRSSUFOR0xFX0ZBTlxuICovXG52YXIgRFJBV19NT0RFUyA9IGV4cG9ydHMuRFJBV19NT0RFUyA9IHtcbiAgUE9JTlRTOiAwLFxuICBMSU5FUzogMSxcbiAgTElORV9MT09QOiAyLFxuICBMSU5FX1NUUklQOiAzLFxuICBUUklBTkdMRVM6IDQsXG4gIFRSSUFOR0xFX1NUUklQOiA1LFxuICBUUklBTkdMRV9GQU46IDZcbn07XG5cbi8qKlxuICogVGhlIHNjYWxlIG1vZGVzIHRoYXQgYXJlIHN1cHBvcnRlZCBieSBwaXhpLlxuICpcbiAqIFRoZSB7QGxpbmsgUElYSS5zZXR0aW5ncy5TQ0FMRV9NT0RFfSBzY2FsZSBtb2RlIGFmZmVjdHMgdGhlIGRlZmF1bHQgc2NhbGluZyBtb2RlIG9mIGZ1dHVyZSBvcGVyYXRpb25zLlxuICogSXQgY2FuIGJlIHJlLWFzc2lnbmVkIHRvIGVpdGhlciBMSU5FQVIgb3IgTkVBUkVTVCwgZGVwZW5kaW5nIHVwb24gc3VpdGFiaWxpdHkuXG4gKlxuICogQHN0YXRpY1xuICogQGNvbnN0YW50XG4gKiBAbWVtYmVyb2YgUElYSVxuICogQG5hbWUgU0NBTEVfTU9ERVNcbiAqIEB0eXBlIHtvYmplY3R9XG4gKiBAcHJvcGVydHkge251bWJlcn0gTElORUFSIFNtb290aCBzY2FsaW5nXG4gKiBAcHJvcGVydHkge251bWJlcn0gTkVBUkVTVCBQaXhlbGF0aW5nIHNjYWxpbmdcbiAqL1xudmFyIFNDQUxFX01PREVTID0gZXhwb3J0cy5TQ0FMRV9NT0RFUyA9IHtcbiAgTElORUFSOiAwLFxuICBORUFSRVNUOiAxXG59O1xuXG4vKipcbiAqIFRoZSB3cmFwIG1vZGVzIHRoYXQgYXJlIHN1cHBvcnRlZCBieSBwaXhpLlxuICpcbiAqIFRoZSB7QGxpbmsgUElYSS5zZXR0aW5ncy5XUkFQX01PREV9IHdyYXAgbW9kZSBhZmZlY3RzIHRoZSBkZWZhdWx0IHdyYXBwaW5nIG1vZGUgb2YgZnV0dXJlIG9wZXJhdGlvbnMuXG4gKiBJdCBjYW4gYmUgcmUtYXNzaWduZWQgdG8gZWl0aGVyIENMQU1QIG9yIFJFUEVBVCwgZGVwZW5kaW5nIHVwb24gc3VpdGFiaWxpdHkuXG4gKiBJZiB0aGUgdGV4dHVyZSBpcyBub24gcG93ZXIgb2YgdHdvIHRoZW4gY2xhbXAgd2lsbCBiZSB1c2VkIHJlZ2FyZGxlc3MgYXMgd2ViR0wgY2FuXG4gKiBvbmx5IHVzZSBSRVBFQVQgaWYgdGhlIHRleHR1cmUgaXMgcG8yLlxuICpcbiAqIFRoaXMgcHJvcGVydHkgb25seSBhZmZlY3RzIFdlYkdMLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBjb25zdGFudFxuICogQG5hbWUgV1JBUF9NT0RFU1xuICogQG1lbWJlcm9mIFBJWElcbiAqIEB0eXBlIHtvYmplY3R9XG4gKiBAcHJvcGVydHkge251bWJlcn0gQ0xBTVAgLSBUaGUgdGV4dHVyZXMgdXZzIGFyZSBjbGFtcGVkXG4gKiBAcHJvcGVydHkge251bWJlcn0gUkVQRUFUIC0gVGhlIHRleHR1cmUgdXZzIHRpbGUgYW5kIHJlcGVhdFxuICogQHByb3BlcnR5IHtudW1iZXJ9IE1JUlJPUkVEX1JFUEVBVCAtIFRoZSB0ZXh0dXJlIHV2cyB0aWxlIGFuZCByZXBlYXQgd2l0aCBtaXJyb3JpbmdcbiAqL1xudmFyIFdSQVBfTU9ERVMgPSBleHBvcnRzLldSQVBfTU9ERVMgPSB7XG4gIENMQU1QOiAwLFxuICBSRVBFQVQ6IDEsXG4gIE1JUlJPUkVEX1JFUEVBVDogMlxufTtcblxuLyoqXG4gKiBUaGUgZ2MgbW9kZXMgdGhhdCBhcmUgc3VwcG9ydGVkIGJ5IHBpeGkuXG4gKlxuICogVGhlIHtAbGluayBQSVhJLnNldHRpbmdzLkdDX01PREV9IEdhcmJhZ2UgQ29sbGVjdGlvbiBtb2RlIGZvciBQaXhpSlMgdGV4dHVyZXMgaXMgQVVUT1xuICogSWYgc2V0IHRvIEdDX01PREUsIHRoZSByZW5kZXJlciB3aWxsIG9jY2FzaW9uYWxseSBjaGVjayB0ZXh0dXJlcyB1c2FnZS4gSWYgdGhleSBhcmUgbm90XG4gKiB1c2VkIGZvciBhIHNwZWNpZmllZCBwZXJpb2Qgb2YgdGltZSB0aGV5IHdpbGwgYmUgcmVtb3ZlZCBmcm9tIHRoZSBHUFUuIFRoZXkgd2lsbCBvZiBjb3Vyc2VcbiAqIGJlIHVwbG9hZGVkIGFnYWluIHdoZW4gdGhleSBhcmUgcmVxdWlyZWQuIFRoaXMgaXMgYSBzaWxlbnQgYmVoaW5kIHRoZSBzY2VuZXMgcHJvY2VzcyB0aGF0XG4gKiBzaG91bGQgZW5zdXJlIHRoYXQgdGhlIEdQVSBkb2VzIG5vdCAgZ2V0IGZpbGxlZCB1cC5cbiAqXG4gKiBIYW5keSBmb3IgbW9iaWxlIGRldmljZXMhXG4gKiBUaGlzIHByb3BlcnR5IG9ubHkgYWZmZWN0cyBXZWJHTC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAY29uc3RhbnRcbiAqIEBuYW1lIEdDX01PREVTXG4gKiBAbWVtYmVyb2YgUElYSVxuICogQHR5cGUge29iamVjdH1cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBBVVRPIC0gR2FyYmFnZSBjb2xsZWN0aW9uIHdpbGwgaGFwcGVuIHBlcmlvZGljYWxseSBhdXRvbWF0aWNhbGx5XG4gKiBAcHJvcGVydHkge251bWJlcn0gTUFOVUFMIC0gR2FyYmFnZSBjb2xsZWN0aW9uIHdpbGwgbmVlZCB0byBiZSBjYWxsZWQgbWFudWFsbHlcbiAqL1xudmFyIEdDX01PREVTID0gZXhwb3J0cy5HQ19NT0RFUyA9IHtcbiAgQVVUTzogMCxcbiAgTUFOVUFMOiAxXG59O1xuXG4vKipcbiAqIFJlZ2V4cCBmb3IgaW1hZ2UgdHlwZSBieSBleHRlbnNpb24uXG4gKlxuICogQHN0YXRpY1xuICogQGNvbnN0YW50XG4gKiBAbWVtYmVyb2YgUElYSVxuICogQHR5cGUge1JlZ0V4cHxzdHJpbmd9XG4gKiBAZXhhbXBsZSBgaW1hZ2UucG5nYFxuICovXG52YXIgVVJMX0ZJTEVfRVhURU5TSU9OID0gZXhwb3J0cy5VUkxfRklMRV9FWFRFTlNJT04gPSAvXFwuKFxcd3szLDR9KSg/OiR8XFw/fCMpL2k7XG5cbi8qKlxuICogUmVnZXhwIGZvciBkYXRhIFVSSS5cbiAqIEJhc2VkIG9uOiB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3JhZ2luZ3dpbmQvZGF0YS11cmktcmVnZXh9XG4gKlxuICogQHN0YXRpY1xuICogQGNvbnN0YW50XG4gKiBAbmFtZSBEQVRBX1VSSVxuICogQG1lbWJlcm9mIFBJWElcbiAqIEB0eXBlIHtSZWdFeHB8c3RyaW5nfVxuICogQGV4YW1wbGUgZGF0YTppbWFnZS9wbmc7YmFzZTY0XG4gKi9cbnZhciBEQVRBX1VSSSA9IGV4cG9ydHMuREFUQV9VUkkgPSAvXlxccypkYXRhOig/OihbXFx3LV0rKVxcLyhbXFx3Ky4tXSspKT8oPzo7Y2hhcnNldD0oW1xcdy1dKykpPyg/OjsoYmFzZTY0KSk/LCguKikvaTtcblxuLyoqXG4gKiBSZWdleHAgZm9yIFNWRyBzaXplLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBjb25zdGFudFxuICogQG5hbWUgU1ZHX1NJWkVcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKiBAdHlwZSB7UmVnRXhwfHN0cmluZ31cbiAqIEBleGFtcGxlICZsdDtzdmcgd2lkdGg9XCIxMDBcIiBoZWlnaHQ9XCIxMDBcIiZndDsmbHQ7L3N2ZyZndDtcbiAqL1xudmFyIFNWR19TSVpFID0gZXhwb3J0cy5TVkdfU0laRSA9IC88c3ZnW14+XSooPzpcXHMod2lkdGh8aGVpZ2h0KT0oJ3xcIikoXFxkKig/OlxcLlxcZCspPykoPzpweCk/KCd8XCIpKVtePl0qKD86XFxzKHdpZHRofGhlaWdodCk9KCd8XCIpKFxcZCooPzpcXC5cXGQrKT8pKD86cHgpPygnfFwiKSlbXj5dKj4vaTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBtYXgtbGVuXG5cbi8qKlxuICogQ29uc3RhbnRzIHRoYXQgaWRlbnRpZnkgc2hhcGVzLCBtYWlubHkgdG8gcHJldmVudCBgaW5zdGFuY2VvZmAgY2FsbHMuXG4gKlxuICogQHN0YXRpY1xuICogQGNvbnN0YW50XG4gKiBAbmFtZSBTSEFQRVNcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKiBAdHlwZSB7b2JqZWN0fVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFBPTFkgUG9seWdvblxuICogQHByb3BlcnR5IHtudW1iZXJ9IFJFQ1QgUmVjdGFuZ2xlXG4gKiBAcHJvcGVydHkge251bWJlcn0gQ0lSQyBDaXJjbGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBFTElQIEVsbGlwc2VcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBSUkVDIFJvdW5kZWQgUmVjdGFuZ2xlXG4gKi9cbnZhciBTSEFQRVMgPSBleHBvcnRzLlNIQVBFUyA9IHtcbiAgUE9MWTogMCxcbiAgUkVDVDogMSxcbiAgQ0lSQzogMixcbiAgRUxJUDogMyxcbiAgUlJFQzogNFxufTtcblxuLyoqXG4gKiBDb25zdGFudHMgdGhhdCBzcGVjaWZ5IGZsb2F0IHByZWNpc2lvbiBpbiBzaGFkZXJzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBjb25zdGFudFxuICogQG5hbWUgUFJFQ0lTSU9OXG4gKiBAbWVtYmVyb2YgUElYSVxuICogQHR5cGUge29iamVjdH1cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBMT1c9J2xvd3AnXG4gKiBAcHJvcGVydHkge3N0cmluZ30gTUVESVVNPSdtZWRpdW1wJ1xuICogQHByb3BlcnR5IHtzdHJpbmd9IEhJR0g9J2hpZ2hwJ1xuICovXG52YXIgUFJFQ0lTSU9OID0gZXhwb3J0cy5QUkVDSVNJT04gPSB7XG4gIExPVzogJ2xvd3AnLFxuICBNRURJVU06ICdtZWRpdW1wJyxcbiAgSElHSDogJ2hpZ2hwJ1xufTtcblxuLyoqXG4gKiBDb25zdGFudHMgdGhhdCBzcGVjaWZ5IHRoZSB0cmFuc2Zvcm0gdHlwZS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAY29uc3RhbnRcbiAqIEBuYW1lIFRSQU5TRk9STV9NT0RFXG4gKiBAbWVtYmVyb2YgUElYSVxuICogQHR5cGUge29iamVjdH1cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBTVEFUSUNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBEWU5BTUlDXG4gKi9cbnZhciBUUkFOU0ZPUk1fTU9ERSA9IGV4cG9ydHMuVFJBTlNGT1JNX01PREUgPSB7XG4gIFNUQVRJQzogMCxcbiAgRFlOQU1JQzogMVxufTtcblxuLyoqXG4gKiBDb25zdGFudHMgdGhhdCBkZWZpbmUgdGhlIHR5cGUgb2YgZ3JhZGllbnQgb24gdGV4dC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAY29uc3RhbnRcbiAqIEBuYW1lIFRFWFRfR1JBRElFTlRcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKiBAdHlwZSB7b2JqZWN0fVxuICogQHByb3BlcnR5IHtudW1iZXJ9IExJTkVBUl9WRVJUSUNBTCBWZXJ0aWNhbCBncmFkaWVudFxuICogQHByb3BlcnR5IHtudW1iZXJ9IExJTkVBUl9IT1JJWk9OVEFMIExpbmVhciBncmFkaWVudFxuICovXG52YXIgVEVYVF9HUkFESUVOVCA9IGV4cG9ydHMuVEVYVF9HUkFESUVOVCA9IHtcbiAgTElORUFSX1ZFUlRJQ0FMOiAwLFxuICBMSU5FQVJfSE9SSVpPTlRBTDogMVxufTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSB1cGRhdGUgcHJpb3JpdGllcyB1c2VkIGJ5IGludGVybmFsIFBJWEkgY2xhc3NlcyB3aGVuIHJlZ2lzdGVyZWQgd2l0aFxuICogdGhlIHtAbGluayBQSVhJLnRpY2tlci5UaWNrZXJ9IG9iamVjdC4gSGlnaGVyIHByaW9yaXR5IGl0ZW1zIGFyZSB1cGRhdGVkIGZpcnN0IGFuZCBsb3dlclxuICogcHJpb3JpdHkgaXRlbXMsIHN1Y2ggYXMgcmVuZGVyLCBzaG91bGQgZ28gbGF0ZXIuXG4gKlxuICogQHN0YXRpY1xuICogQGNvbnN0YW50XG4gKiBAbmFtZSBVUERBVEVfUFJJT1JJVFlcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKiBAdHlwZSB7b2JqZWN0fVxuICogQHByb3BlcnR5IHtudW1iZXJ9IElOVEVSQUNUSU9OPTUwIEhpZ2hlc3QgcHJpb3JpdHksIHVzZWQgZm9yIHtAbGluayBQSVhJLmludGVyYWN0aW9uLkludGVyYWN0aW9uTWFuYWdlcn1cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBISUdIPTI1IEhpZ2ggcHJpb3JpdHkgdXBkYXRpbmcsIHtAbGluayBQSVhJLlZpZGVvQmFzZVRleHR1cmV9IGFuZCB7QGxpbmsgUElYSS5leHRyYXMuQW5pbWF0ZWRTcHJpdGV9XG4gKiBAcHJvcGVydHkge251bWJlcn0gTk9STUFMPTAgRGVmYXVsdCBwcmlvcml0eSBmb3IgdGlja2VyIGV2ZW50cywgc2VlIHtAbGluayBQSVhJLnRpY2tlci5UaWNrZXIjYWRkfS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBMT1c9LTI1IExvdyBwcmlvcml0eSB1c2VkIGZvciB7QGxpbmsgUElYSS5BcHBsaWNhdGlvbn0gcmVuZGVyaW5nLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFVUSUxJVFk9LTUwIExvd2VzdCBwcmlvcml0eSB1c2VkIGZvciB7QGxpbmsgUElYSS5wcmVwYXJlLkJhc2VQcmVwYXJlfSB1dGlsaXR5LlxuICovXG52YXIgVVBEQVRFX1BSSU9SSVRZID0gZXhwb3J0cy5VUERBVEVfUFJJT1JJVFkgPSB7XG4gIElOVEVSQUNUSU9OOiA1MCxcbiAgSElHSDogMjUsXG4gIE5PUk1BTDogMCxcbiAgTE9XOiAtMjUsXG4gIFVUSUxJVFk6IC01MFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnN0LmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9tYXRoID0gcmVxdWlyZSgnLi4vbWF0aCcpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vKipcbiAqICdCdWlsZGVyJyBwYXR0ZXJuIGZvciBib3VuZHMgcmVjdGFuZ2xlc1xuICogQXhpcy1BbGlnbmVkIEJvdW5kaW5nIEJveFxuICogSXQgaXMgbm90IGEgc2hhcGUhIEl0cyBtdXRhYmxlIHRoaW5nLCBubyAnRU1QVFknIG9yIHRoYXQga2luZCBvZiBwcm9ibGVtc1xuICpcbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIFBJWElcbiAqL1xudmFyIEJvdW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEJvdW5kcygpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJvdW5kcyk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5taW5YID0gSW5maW5pdHk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5taW5ZID0gSW5maW5pdHk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tYXhYID0gLUluZmluaXR5O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubWF4WSA9IC1JbmZpbml0eTtcblxuICAgICAgICB0aGlzLnJlY3QgPSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBib3VuZHMgYXJlIGVtcHR5LlxuICAgICAqXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBlbXB0eS5cbiAgICAgKi9cblxuXG4gICAgQm91bmRzLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gaXNFbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWluWCA+IHRoaXMubWF4WCB8fCB0aGlzLm1pblkgPiB0aGlzLm1heFk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENsZWFycyB0aGUgYm91bmRzIGFuZCByZXNldHMuXG4gICAgICpcbiAgICAgKi9cblxuXG4gICAgQm91bmRzLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZUlEKys7XG5cbiAgICAgICAgdGhpcy5taW5YID0gSW5maW5pdHk7XG4gICAgICAgIHRoaXMubWluWSA9IEluZmluaXR5O1xuICAgICAgICB0aGlzLm1heFggPSAtSW5maW5pdHk7XG4gICAgICAgIHRoaXMubWF4WSA9IC1JbmZpbml0eTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2FuIHJldHVybiBSZWN0YW5nbGUuRU1QVFkgY29uc3RhbnQsIGVpdGhlciBjb25zdHJ1Y3QgbmV3IHJlY3RhbmdsZSwgZWl0aGVyIHVzZSB5b3VyIHJlY3RhbmdsZVxuICAgICAqIEl0IGlzIG5vdCBndWFyYW50ZWVkIHRoYXQgaXQgd2lsbCByZXR1cm4gdGVtcFJlY3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5SZWN0YW5nbGV9IHJlY3QgLSB0ZW1wb3Jhcnkgb2JqZWN0IHdpbGwgYmUgdXNlZCBpZiBBQUJCIGlzIG5vdCBlbXB0eVxuICAgICAqIEByZXR1cm5zIHtQSVhJLlJlY3RhbmdsZX0gQSByZWN0YW5nbGUgb2YgdGhlIGJvdW5kc1xuICAgICAqL1xuXG5cbiAgICBCb3VuZHMucHJvdG90eXBlLmdldFJlY3RhbmdsZSA9IGZ1bmN0aW9uIGdldFJlY3RhbmdsZShyZWN0KSB7XG4gICAgICAgIGlmICh0aGlzLm1pblggPiB0aGlzLm1heFggfHwgdGhpcy5taW5ZID4gdGhpcy5tYXhZKSB7XG4gICAgICAgICAgICByZXR1cm4gX21hdGguUmVjdGFuZ2xlLkVNUFRZO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVjdCA9IHJlY3QgfHwgbmV3IF9tYXRoLlJlY3RhbmdsZSgwLCAwLCAxLCAxKTtcblxuICAgICAgICByZWN0LnggPSB0aGlzLm1pblg7XG4gICAgICAgIHJlY3QueSA9IHRoaXMubWluWTtcbiAgICAgICAgcmVjdC53aWR0aCA9IHRoaXMubWF4WCAtIHRoaXMubWluWDtcbiAgICAgICAgcmVjdC5oZWlnaHQgPSB0aGlzLm1heFkgLSB0aGlzLm1pblk7XG5cbiAgICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gc2hvdWxkIGJlIGlubGluZWQgd2hlbiBpdHMgcG9zc2libGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuUG9pbnR9IHBvaW50IC0gVGhlIHBvaW50IHRvIGFkZC5cbiAgICAgKi9cblxuXG4gICAgQm91bmRzLnByb3RvdHlwZS5hZGRQb2ludCA9IGZ1bmN0aW9uIGFkZFBvaW50KHBvaW50KSB7XG4gICAgICAgIHRoaXMubWluWCA9IE1hdGgubWluKHRoaXMubWluWCwgcG9pbnQueCk7XG4gICAgICAgIHRoaXMubWF4WCA9IE1hdGgubWF4KHRoaXMubWF4WCwgcG9pbnQueCk7XG4gICAgICAgIHRoaXMubWluWSA9IE1hdGgubWluKHRoaXMubWluWSwgcG9pbnQueSk7XG4gICAgICAgIHRoaXMubWF4WSA9IE1hdGgubWF4KHRoaXMubWF4WSwgcG9pbnQueSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBxdWFkLCBub3QgdHJhbnNmb3JtZWRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSB2ZXJ0aWNlcyAtIFRoZSB2ZXJ0cyB0byBhZGQuXG4gICAgICovXG5cblxuICAgIEJvdW5kcy5wcm90b3R5cGUuYWRkUXVhZCA9IGZ1bmN0aW9uIGFkZFF1YWQodmVydGljZXMpIHtcbiAgICAgICAgdmFyIG1pblggPSB0aGlzLm1pblg7XG4gICAgICAgIHZhciBtaW5ZID0gdGhpcy5taW5ZO1xuICAgICAgICB2YXIgbWF4WCA9IHRoaXMubWF4WDtcbiAgICAgICAgdmFyIG1heFkgPSB0aGlzLm1heFk7XG5cbiAgICAgICAgdmFyIHggPSB2ZXJ0aWNlc1swXTtcbiAgICAgICAgdmFyIHkgPSB2ZXJ0aWNlc1sxXTtcblxuICAgICAgICBtaW5YID0geCA8IG1pblggPyB4IDogbWluWDtcbiAgICAgICAgbWluWSA9IHkgPCBtaW5ZID8geSA6IG1pblk7XG4gICAgICAgIG1heFggPSB4ID4gbWF4WCA/IHggOiBtYXhYO1xuICAgICAgICBtYXhZID0geSA+IG1heFkgPyB5IDogbWF4WTtcblxuICAgICAgICB4ID0gdmVydGljZXNbMl07XG4gICAgICAgIHkgPSB2ZXJ0aWNlc1szXTtcbiAgICAgICAgbWluWCA9IHggPCBtaW5YID8geCA6IG1pblg7XG4gICAgICAgIG1pblkgPSB5IDwgbWluWSA/IHkgOiBtaW5ZO1xuICAgICAgICBtYXhYID0geCA+IG1heFggPyB4IDogbWF4WDtcbiAgICAgICAgbWF4WSA9IHkgPiBtYXhZID8geSA6IG1heFk7XG5cbiAgICAgICAgeCA9IHZlcnRpY2VzWzRdO1xuICAgICAgICB5ID0gdmVydGljZXNbNV07XG4gICAgICAgIG1pblggPSB4IDwgbWluWCA/IHggOiBtaW5YO1xuICAgICAgICBtaW5ZID0geSA8IG1pblkgPyB5IDogbWluWTtcbiAgICAgICAgbWF4WCA9IHggPiBtYXhYID8geCA6IG1heFg7XG4gICAgICAgIG1heFkgPSB5ID4gbWF4WSA/IHkgOiBtYXhZO1xuXG4gICAgICAgIHggPSB2ZXJ0aWNlc1s2XTtcbiAgICAgICAgeSA9IHZlcnRpY2VzWzddO1xuICAgICAgICBtaW5YID0geCA8IG1pblggPyB4IDogbWluWDtcbiAgICAgICAgbWluWSA9IHkgPCBtaW5ZID8geSA6IG1pblk7XG4gICAgICAgIG1heFggPSB4ID4gbWF4WCA/IHggOiBtYXhYO1xuICAgICAgICBtYXhZID0geSA+IG1heFkgPyB5IDogbWF4WTtcblxuICAgICAgICB0aGlzLm1pblggPSBtaW5YO1xuICAgICAgICB0aGlzLm1pblkgPSBtaW5ZO1xuICAgICAgICB0aGlzLm1heFggPSBtYXhYO1xuICAgICAgICB0aGlzLm1heFkgPSBtYXhZO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIHNwcml0ZSBmcmFtZSwgdHJhbnNmb3JtZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuVHJhbnNmb3JtQmFzZX0gdHJhbnNmb3JtIC0gVE9ET1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MCAtIFRPRE9cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geTAgLSBUT0RPXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgxIC0gVE9ET1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MSAtIFRPRE9cbiAgICAgKi9cblxuXG4gICAgQm91bmRzLnByb3RvdHlwZS5hZGRGcmFtZSA9IGZ1bmN0aW9uIGFkZEZyYW1lKHRyYW5zZm9ybSwgeDAsIHkwLCB4MSwgeTEpIHtcbiAgICAgICAgdmFyIG1hdHJpeCA9IHRyYW5zZm9ybS53b3JsZFRyYW5zZm9ybTtcbiAgICAgICAgdmFyIGEgPSBtYXRyaXguYTtcbiAgICAgICAgdmFyIGIgPSBtYXRyaXguYjtcbiAgICAgICAgdmFyIGMgPSBtYXRyaXguYztcbiAgICAgICAgdmFyIGQgPSBtYXRyaXguZDtcbiAgICAgICAgdmFyIHR4ID0gbWF0cml4LnR4O1xuICAgICAgICB2YXIgdHkgPSBtYXRyaXgudHk7XG5cbiAgICAgICAgdmFyIG1pblggPSB0aGlzLm1pblg7XG4gICAgICAgIHZhciBtaW5ZID0gdGhpcy5taW5ZO1xuICAgICAgICB2YXIgbWF4WCA9IHRoaXMubWF4WDtcbiAgICAgICAgdmFyIG1heFkgPSB0aGlzLm1heFk7XG5cbiAgICAgICAgdmFyIHggPSBhICogeDAgKyBjICogeTAgKyB0eDtcbiAgICAgICAgdmFyIHkgPSBiICogeDAgKyBkICogeTAgKyB0eTtcblxuICAgICAgICBtaW5YID0geCA8IG1pblggPyB4IDogbWluWDtcbiAgICAgICAgbWluWSA9IHkgPCBtaW5ZID8geSA6IG1pblk7XG4gICAgICAgIG1heFggPSB4ID4gbWF4WCA/IHggOiBtYXhYO1xuICAgICAgICBtYXhZID0geSA+IG1heFkgPyB5IDogbWF4WTtcblxuICAgICAgICB4ID0gYSAqIHgxICsgYyAqIHkwICsgdHg7XG4gICAgICAgIHkgPSBiICogeDEgKyBkICogeTAgKyB0eTtcbiAgICAgICAgbWluWCA9IHggPCBtaW5YID8geCA6IG1pblg7XG4gICAgICAgIG1pblkgPSB5IDwgbWluWSA/IHkgOiBtaW5ZO1xuICAgICAgICBtYXhYID0geCA+IG1heFggPyB4IDogbWF4WDtcbiAgICAgICAgbWF4WSA9IHkgPiBtYXhZID8geSA6IG1heFk7XG5cbiAgICAgICAgeCA9IGEgKiB4MCArIGMgKiB5MSArIHR4O1xuICAgICAgICB5ID0gYiAqIHgwICsgZCAqIHkxICsgdHk7XG4gICAgICAgIG1pblggPSB4IDwgbWluWCA/IHggOiBtaW5YO1xuICAgICAgICBtaW5ZID0geSA8IG1pblkgPyB5IDogbWluWTtcbiAgICAgICAgbWF4WCA9IHggPiBtYXhYID8geCA6IG1heFg7XG4gICAgICAgIG1heFkgPSB5ID4gbWF4WSA/IHkgOiBtYXhZO1xuXG4gICAgICAgIHggPSBhICogeDEgKyBjICogeTEgKyB0eDtcbiAgICAgICAgeSA9IGIgKiB4MSArIGQgKiB5MSArIHR5O1xuICAgICAgICBtaW5YID0geCA8IG1pblggPyB4IDogbWluWDtcbiAgICAgICAgbWluWSA9IHkgPCBtaW5ZID8geSA6IG1pblk7XG4gICAgICAgIG1heFggPSB4ID4gbWF4WCA/IHggOiBtYXhYO1xuICAgICAgICBtYXhZID0geSA+IG1heFkgPyB5IDogbWF4WTtcblxuICAgICAgICB0aGlzLm1pblggPSBtaW5YO1xuICAgICAgICB0aGlzLm1pblkgPSBtaW5ZO1xuICAgICAgICB0aGlzLm1heFggPSBtYXhYO1xuICAgICAgICB0aGlzLm1heFkgPSBtYXhZO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBZGQgYW4gYXJyYXkgb2YgdmVydGljZXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5UcmFuc2Zvcm1CYXNlfSB0cmFuc2Zvcm0gLSBUT0RPXG4gICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl9IHZlcnRpY2VzIC0gVE9ET1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiZWdpbk9mZnNldCAtIFRPRE9cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kT2Zmc2V0IC0gVE9ET1xuICAgICAqL1xuXG5cbiAgICBCb3VuZHMucHJvdG90eXBlLmFkZFZlcnRpY2VzID0gZnVuY3Rpb24gYWRkVmVydGljZXModHJhbnNmb3JtLCB2ZXJ0aWNlcywgYmVnaW5PZmZzZXQsIGVuZE9mZnNldCkge1xuICAgICAgICB2YXIgbWF0cml4ID0gdHJhbnNmb3JtLndvcmxkVHJhbnNmb3JtO1xuICAgICAgICB2YXIgYSA9IG1hdHJpeC5hO1xuICAgICAgICB2YXIgYiA9IG1hdHJpeC5iO1xuICAgICAgICB2YXIgYyA9IG1hdHJpeC5jO1xuICAgICAgICB2YXIgZCA9IG1hdHJpeC5kO1xuICAgICAgICB2YXIgdHggPSBtYXRyaXgudHg7XG4gICAgICAgIHZhciB0eSA9IG1hdHJpeC50eTtcblxuICAgICAgICB2YXIgbWluWCA9IHRoaXMubWluWDtcbiAgICAgICAgdmFyIG1pblkgPSB0aGlzLm1pblk7XG4gICAgICAgIHZhciBtYXhYID0gdGhpcy5tYXhYO1xuICAgICAgICB2YXIgbWF4WSA9IHRoaXMubWF4WTtcblxuICAgICAgICBmb3IgKHZhciBpID0gYmVnaW5PZmZzZXQ7IGkgPCBlbmRPZmZzZXQ7IGkgKz0gMikge1xuICAgICAgICAgICAgdmFyIHJhd1ggPSB2ZXJ0aWNlc1tpXTtcbiAgICAgICAgICAgIHZhciByYXdZID0gdmVydGljZXNbaSArIDFdO1xuICAgICAgICAgICAgdmFyIHggPSBhICogcmF3WCArIGMgKiByYXdZICsgdHg7XG4gICAgICAgICAgICB2YXIgeSA9IGQgKiByYXdZICsgYiAqIHJhd1ggKyB0eTtcblxuICAgICAgICAgICAgbWluWCA9IHggPCBtaW5YID8geCA6IG1pblg7XG4gICAgICAgICAgICBtaW5ZID0geSA8IG1pblkgPyB5IDogbWluWTtcbiAgICAgICAgICAgIG1heFggPSB4ID4gbWF4WCA/IHggOiBtYXhYO1xuICAgICAgICAgICAgbWF4WSA9IHkgPiBtYXhZID8geSA6IG1heFk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm1pblggPSBtaW5YO1xuICAgICAgICB0aGlzLm1pblkgPSBtaW5ZO1xuICAgICAgICB0aGlzLm1heFggPSBtYXhYO1xuICAgICAgICB0aGlzLm1heFkgPSBtYXhZO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIG90aGVyIEJvdW5kc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLkJvdW5kc30gYm91bmRzIC0gVE9ET1xuICAgICAqL1xuXG5cbiAgICBCb3VuZHMucHJvdG90eXBlLmFkZEJvdW5kcyA9IGZ1bmN0aW9uIGFkZEJvdW5kcyhib3VuZHMpIHtcbiAgICAgICAgdmFyIG1pblggPSB0aGlzLm1pblg7XG4gICAgICAgIHZhciBtaW5ZID0gdGhpcy5taW5ZO1xuICAgICAgICB2YXIgbWF4WCA9IHRoaXMubWF4WDtcbiAgICAgICAgdmFyIG1heFkgPSB0aGlzLm1heFk7XG5cbiAgICAgICAgdGhpcy5taW5YID0gYm91bmRzLm1pblggPCBtaW5YID8gYm91bmRzLm1pblggOiBtaW5YO1xuICAgICAgICB0aGlzLm1pblkgPSBib3VuZHMubWluWSA8IG1pblkgPyBib3VuZHMubWluWSA6IG1pblk7XG4gICAgICAgIHRoaXMubWF4WCA9IGJvdW5kcy5tYXhYID4gbWF4WCA/IGJvdW5kcy5tYXhYIDogbWF4WDtcbiAgICAgICAgdGhpcy5tYXhZID0gYm91bmRzLm1heFkgPiBtYXhZID8gYm91bmRzLm1heFkgOiBtYXhZO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIG90aGVyIEJvdW5kcywgbWFza2VkIHdpdGggQm91bmRzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuQm91bmRzfSBib3VuZHMgLSBUT0RPXG4gICAgICogQHBhcmFtIHtQSVhJLkJvdW5kc30gbWFzayAtIFRPRE9cbiAgICAgKi9cblxuXG4gICAgQm91bmRzLnByb3RvdHlwZS5hZGRCb3VuZHNNYXNrID0gZnVuY3Rpb24gYWRkQm91bmRzTWFzayhib3VuZHMsIG1hc2spIHtcbiAgICAgICAgdmFyIF9taW5YID0gYm91bmRzLm1pblggPiBtYXNrLm1pblggPyBib3VuZHMubWluWCA6IG1hc2subWluWDtcbiAgICAgICAgdmFyIF9taW5ZID0gYm91bmRzLm1pblkgPiBtYXNrLm1pblkgPyBib3VuZHMubWluWSA6IG1hc2subWluWTtcbiAgICAgICAgdmFyIF9tYXhYID0gYm91bmRzLm1heFggPCBtYXNrLm1heFggPyBib3VuZHMubWF4WCA6IG1hc2subWF4WDtcbiAgICAgICAgdmFyIF9tYXhZID0gYm91bmRzLm1heFkgPCBtYXNrLm1heFkgPyBib3VuZHMubWF4WSA6IG1hc2subWF4WTtcblxuICAgICAgICBpZiAoX21pblggPD0gX21heFggJiYgX21pblkgPD0gX21heFkpIHtcbiAgICAgICAgICAgIHZhciBtaW5YID0gdGhpcy5taW5YO1xuICAgICAgICAgICAgdmFyIG1pblkgPSB0aGlzLm1pblk7XG4gICAgICAgICAgICB2YXIgbWF4WCA9IHRoaXMubWF4WDtcbiAgICAgICAgICAgIHZhciBtYXhZID0gdGhpcy5tYXhZO1xuXG4gICAgICAgICAgICB0aGlzLm1pblggPSBfbWluWCA8IG1pblggPyBfbWluWCA6IG1pblg7XG4gICAgICAgICAgICB0aGlzLm1pblkgPSBfbWluWSA8IG1pblkgPyBfbWluWSA6IG1pblk7XG4gICAgICAgICAgICB0aGlzLm1heFggPSBfbWF4WCA+IG1heFggPyBfbWF4WCA6IG1heFg7XG4gICAgICAgICAgICB0aGlzLm1heFkgPSBfbWF4WSA+IG1heFkgPyBfbWF4WSA6IG1heFk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQWRkcyBvdGhlciBCb3VuZHMsIG1hc2tlZCB3aXRoIFJlY3RhbmdsZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLkJvdW5kc30gYm91bmRzIC0gVE9ET1xuICAgICAqIEBwYXJhbSB7UElYSS5SZWN0YW5nbGV9IGFyZWEgLSBUT0RPXG4gICAgICovXG5cblxuICAgIEJvdW5kcy5wcm90b3R5cGUuYWRkQm91bmRzQXJlYSA9IGZ1bmN0aW9uIGFkZEJvdW5kc0FyZWEoYm91bmRzLCBhcmVhKSB7XG4gICAgICAgIHZhciBfbWluWCA9IGJvdW5kcy5taW5YID4gYXJlYS54ID8gYm91bmRzLm1pblggOiBhcmVhLng7XG4gICAgICAgIHZhciBfbWluWSA9IGJvdW5kcy5taW5ZID4gYXJlYS55ID8gYm91bmRzLm1pblkgOiBhcmVhLnk7XG4gICAgICAgIHZhciBfbWF4WCA9IGJvdW5kcy5tYXhYIDwgYXJlYS54ICsgYXJlYS53aWR0aCA/IGJvdW5kcy5tYXhYIDogYXJlYS54ICsgYXJlYS53aWR0aDtcbiAgICAgICAgdmFyIF9tYXhZID0gYm91bmRzLm1heFkgPCBhcmVhLnkgKyBhcmVhLmhlaWdodCA/IGJvdW5kcy5tYXhZIDogYXJlYS55ICsgYXJlYS5oZWlnaHQ7XG5cbiAgICAgICAgaWYgKF9taW5YIDw9IF9tYXhYICYmIF9taW5ZIDw9IF9tYXhZKSB7XG4gICAgICAgICAgICB2YXIgbWluWCA9IHRoaXMubWluWDtcbiAgICAgICAgICAgIHZhciBtaW5ZID0gdGhpcy5taW5ZO1xuICAgICAgICAgICAgdmFyIG1heFggPSB0aGlzLm1heFg7XG4gICAgICAgICAgICB2YXIgbWF4WSA9IHRoaXMubWF4WTtcblxuICAgICAgICAgICAgdGhpcy5taW5YID0gX21pblggPCBtaW5YID8gX21pblggOiBtaW5YO1xuICAgICAgICAgICAgdGhpcy5taW5ZID0gX21pblkgPCBtaW5ZID8gX21pblkgOiBtaW5ZO1xuICAgICAgICAgICAgdGhpcy5tYXhYID0gX21heFggPiBtYXhYID8gX21heFggOiBtYXhYO1xuICAgICAgICAgICAgdGhpcy5tYXhZID0gX21heFkgPiBtYXhZID8gX21heFkgOiBtYXhZO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBCb3VuZHM7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEJvdW5kcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJvdW5kcy5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG52YXIgX0Rpc3BsYXlPYmplY3QyID0gcmVxdWlyZSgnLi9EaXNwbGF5T2JqZWN0Jyk7XG5cbnZhciBfRGlzcGxheU9iamVjdDMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9EaXNwbGF5T2JqZWN0Mik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuLyoqXG4gKiBBIENvbnRhaW5lciByZXByZXNlbnRzIGEgY29sbGVjdGlvbiBvZiBkaXNwbGF5IG9iamVjdHMuXG4gKiBJdCBpcyB0aGUgYmFzZSBjbGFzcyBvZiBhbGwgZGlzcGxheSBvYmplY3RzIHRoYXQgYWN0IGFzIGEgY29udGFpbmVyIGZvciBvdGhlciBvYmplY3RzLlxuICpcbiAqYGBganNcbiAqIGxldCBjb250YWluZXIgPSBuZXcgUElYSS5Db250YWluZXIoKTtcbiAqIGNvbnRhaW5lci5hZGRDaGlsZChzcHJpdGUpO1xuICogYGBgXG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQSVhJLkRpc3BsYXlPYmplY3RcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKi9cbnZhciBDb250YWluZXIgPSBmdW5jdGlvbiAoX0Rpc3BsYXlPYmplY3QpIHtcbiAgICBfaW5oZXJpdHMoQ29udGFpbmVyLCBfRGlzcGxheU9iamVjdCk7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIENvbnRhaW5lcigpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvbnRhaW5lcik7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBhcnJheSBvZiBjaGlsZHJlbiBvZiB0aGlzIGNvbnRhaW5lci5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5EaXNwbGF5T2JqZWN0W119XG4gICAgICAgICAqIEByZWFkb25seVxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0Rpc3BsYXlPYmplY3QuY2FsbCh0aGlzKSk7XG5cbiAgICAgICAgX3RoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRhYmxlIG1ldGhvZCB0aGF0IGNhbiBiZSB1c2VkIGJ5IENvbnRhaW5lciBzdWJjbGFzc2VzIHdoZW5ldmVyIHRoZSBjaGlsZHJlbiBhcnJheSBpcyBtb2RpZmllZFxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuXG4gICAgQ29udGFpbmVyLnByb3RvdHlwZS5vbkNoaWxkcmVuQ2hhbmdlID0gZnVuY3Rpb24gb25DaGlsZHJlbkNoYW5nZSgpIHt9XG4gICAgLyogZW1wdHkgKi9cblxuXG4gICAgLyoqXG4gICAgICogQWRkcyBvbmUgb3IgbW9yZSBjaGlsZHJlbiB0byB0aGUgY29udGFpbmVyLlxuICAgICAqXG4gICAgICogTXVsdGlwbGUgaXRlbXMgY2FuIGJlIGFkZGVkIGxpa2Ugc286IGBteUNvbnRhaW5lci5hZGRDaGlsZCh0aGluZ09uZSwgdGhpbmdUd28sIHRoaW5nVGhyZWUpYFxuICAgICAqXG4gICAgICogQHBhcmFtIHsuLi5QSVhJLkRpc3BsYXlPYmplY3R9IGNoaWxkIC0gVGhlIERpc3BsYXlPYmplY3QocykgdG8gYWRkIHRvIHRoZSBjb250YWluZXJcbiAgICAgKiBAcmV0dXJuIHtQSVhJLkRpc3BsYXlPYmplY3R9IFRoZSBmaXJzdCBjaGlsZCB0aGF0IHdhcyBhZGRlZC5cbiAgICAgKi9cbiAgICA7XG5cbiAgICBDb250YWluZXIucHJvdG90eXBlLmFkZENoaWxkID0gZnVuY3Rpb24gYWRkQ2hpbGQoY2hpbGQpIHtcbiAgICAgICAgdmFyIGFyZ3VtZW50c0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cbiAgICAgICAgLy8gaWYgdGhlcmUgaXMgb25seSBvbmUgYXJndW1lbnQgd2UgY2FuIGJ5cGFzcyBsb29waW5nIHRocm91Z2ggdGhlIHRoZW1cbiAgICAgICAgaWYgKGFyZ3VtZW50c0xlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIC8vIGxvb3AgdGhyb3VnaCB0aGUgYXJndW1lbnRzIHByb3BlcnR5IGFuZCBhZGQgYWxsIGNoaWxkcmVuXG4gICAgICAgICAgICAvLyB1c2UgaXQgdGhlIHJpZ2h0IHdheSAoLmxlbmd0aCBhbmQgW2ldKSBzbyB0aGF0IHRoaXMgZnVuY3Rpb24gY2FuIHN0aWxsIGJlIG9wdGltaXNlZCBieSBKUyBydW50aW1lc1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHNMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkQ2hpbGQoYXJndW1lbnRzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBjaGlsZCBoYXMgYSBwYXJlbnQgdGhlbiBsZXRzIHJlbW92ZSBpdCBhcyBQaXhpSlMgb2JqZWN0cyBjYW4gb25seSBleGlzdCBpbiBvbmUgcGxhY2VcbiAgICAgICAgICAgIGlmIChjaGlsZC5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBjaGlsZC5wYXJlbnQucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjaGlsZC5wYXJlbnQgPSB0aGlzO1xuICAgICAgICAgICAgLy8gZW5zdXJlIGNoaWxkIHRyYW5zZm9ybSB3aWxsIGJlIHJlY2FsY3VsYXRlZFxuICAgICAgICAgICAgY2hpbGQudHJhbnNmb3JtLl9wYXJlbnRJRCA9IC0xO1xuXG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuLnB1c2goY2hpbGQpO1xuXG4gICAgICAgICAgICAvLyBlbnN1cmUgYm91bmRzIHdpbGwgYmUgcmVjYWxjdWxhdGVkXG4gICAgICAgICAgICB0aGlzLl9ib3VuZHNJRCsrO1xuXG4gICAgICAgICAgICAvLyBUT0RPIC0gbGV0cyBlaXRoZXIgZG8gYWxsIGNhbGxiYWNrcyBvciBhbGwgZXZlbnRzLi4gbm90IGJvdGghXG4gICAgICAgICAgICB0aGlzLm9uQ2hpbGRyZW5DaGFuZ2UodGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIGNoaWxkLmVtaXQoJ2FkZGVkJywgdGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBjaGlsZCB0byB0aGUgY29udGFpbmVyIGF0IGEgc3BlY2lmaWVkIGluZGV4LiBJZiB0aGUgaW5kZXggaXMgb3V0IG9mIGJvdW5kcyBhbiBlcnJvciB3aWxsIGJlIHRocm93blxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLkRpc3BsYXlPYmplY3R9IGNoaWxkIC0gVGhlIGNoaWxkIHRvIGFkZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIFRoZSBpbmRleCB0byBwbGFjZSB0aGUgY2hpbGQgaW5cbiAgICAgKiBAcmV0dXJuIHtQSVhJLkRpc3BsYXlPYmplY3R9IFRoZSBjaGlsZCB0aGF0IHdhcyBhZGRlZC5cbiAgICAgKi9cblxuXG4gICAgQ29udGFpbmVyLnByb3RvdHlwZS5hZGRDaGlsZEF0ID0gZnVuY3Rpb24gYWRkQ2hpbGRBdChjaGlsZCwgaW5kZXgpIHtcbiAgICAgICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+IHRoaXMuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoY2hpbGQgKyAnYWRkQ2hpbGRBdDogVGhlIGluZGV4ICcgKyBpbmRleCArICcgc3VwcGxpZWQgaXMgb3V0IG9mIGJvdW5kcyAnICsgdGhpcy5jaGlsZHJlbi5sZW5ndGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoaWxkLnBhcmVudCkge1xuICAgICAgICAgICAgY2hpbGQucGFyZW50LnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNoaWxkLnBhcmVudCA9IHRoaXM7XG4gICAgICAgIC8vIGVuc3VyZSBjaGlsZCB0cmFuc2Zvcm0gd2lsbCBiZSByZWNhbGN1bGF0ZWRcbiAgICAgICAgY2hpbGQudHJhbnNmb3JtLl9wYXJlbnRJRCA9IC0xO1xuXG4gICAgICAgIHRoaXMuY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAwLCBjaGlsZCk7XG5cbiAgICAgICAgLy8gZW5zdXJlIGJvdW5kcyB3aWxsIGJlIHJlY2FsY3VsYXRlZFxuICAgICAgICB0aGlzLl9ib3VuZHNJRCsrO1xuXG4gICAgICAgIC8vIFRPRE8gLSBsZXRzIGVpdGhlciBkbyBhbGwgY2FsbGJhY2tzIG9yIGFsbCBldmVudHMuLiBub3QgYm90aCFcbiAgICAgICAgdGhpcy5vbkNoaWxkcmVuQ2hhbmdlKGluZGV4KTtcbiAgICAgICAgY2hpbGQuZW1pdCgnYWRkZWQnLCB0aGlzKTtcblxuICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFN3YXBzIHRoZSBwb3NpdGlvbiBvZiAyIERpc3BsYXkgT2JqZWN0cyB3aXRoaW4gdGhpcyBjb250YWluZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuRGlzcGxheU9iamVjdH0gY2hpbGQgLSBGaXJzdCBkaXNwbGF5IG9iamVjdCB0byBzd2FwXG4gICAgICogQHBhcmFtIHtQSVhJLkRpc3BsYXlPYmplY3R9IGNoaWxkMiAtIFNlY29uZCBkaXNwbGF5IG9iamVjdCB0byBzd2FwXG4gICAgICovXG5cblxuICAgIENvbnRhaW5lci5wcm90b3R5cGUuc3dhcENoaWxkcmVuID0gZnVuY3Rpb24gc3dhcENoaWxkcmVuKGNoaWxkLCBjaGlsZDIpIHtcbiAgICAgICAgaWYgKGNoaWxkID09PSBjaGlsZDIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpbmRleDEgPSB0aGlzLmdldENoaWxkSW5kZXgoY2hpbGQpO1xuICAgICAgICB2YXIgaW5kZXgyID0gdGhpcy5nZXRDaGlsZEluZGV4KGNoaWxkMik7XG5cbiAgICAgICAgdGhpcy5jaGlsZHJlbltpbmRleDFdID0gY2hpbGQyO1xuICAgICAgICB0aGlzLmNoaWxkcmVuW2luZGV4Ml0gPSBjaGlsZDtcbiAgICAgICAgdGhpcy5vbkNoaWxkcmVuQ2hhbmdlKGluZGV4MSA8IGluZGV4MiA/IGluZGV4MSA6IGluZGV4Mik7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGluZGV4IHBvc2l0aW9uIG9mIGEgY2hpbGQgRGlzcGxheU9iamVjdCBpbnN0YW5jZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLkRpc3BsYXlPYmplY3R9IGNoaWxkIC0gVGhlIERpc3BsYXlPYmplY3QgaW5zdGFuY2UgdG8gaWRlbnRpZnlcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBpbmRleCBwb3NpdGlvbiBvZiB0aGUgY2hpbGQgZGlzcGxheSBvYmplY3QgdG8gaWRlbnRpZnlcbiAgICAgKi9cblxuXG4gICAgQ29udGFpbmVyLnByb3RvdHlwZS5nZXRDaGlsZEluZGV4ID0gZnVuY3Rpb24gZ2V0Q2hpbGRJbmRleChjaGlsZCkge1xuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmNoaWxkcmVuLmluZGV4T2YoY2hpbGQpO1xuXG4gICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHN1cHBsaWVkIERpc3BsYXlPYmplY3QgbXVzdCBiZSBhIGNoaWxkIG9mIHRoZSBjYWxsZXInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyB0aGUgcG9zaXRpb24gb2YgYW4gZXhpc3RpbmcgY2hpbGQgaW4gdGhlIGRpc3BsYXkgb2JqZWN0IGNvbnRhaW5lclxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLkRpc3BsYXlPYmplY3R9IGNoaWxkIC0gVGhlIGNoaWxkIERpc3BsYXlPYmplY3QgaW5zdGFuY2UgZm9yIHdoaWNoIHlvdSB3YW50IHRvIGNoYW5nZSB0aGUgaW5kZXggbnVtYmVyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gVGhlIHJlc3VsdGluZyBpbmRleCBudW1iZXIgZm9yIHRoZSBjaGlsZCBkaXNwbGF5IG9iamVjdFxuICAgICAqL1xuXG5cbiAgICBDb250YWluZXIucHJvdG90eXBlLnNldENoaWxkSW5kZXggPSBmdW5jdGlvbiBzZXRDaGlsZEluZGV4KGNoaWxkLCBpbmRleCkge1xuICAgICAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHRoaXMuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBpbmRleCAnICsgaW5kZXggKyAnIHN1cHBsaWVkIGlzIG91dCBvZiBib3VuZHMgJyArIHRoaXMuY2hpbGRyZW4ubGVuZ3RoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjdXJyZW50SW5kZXggPSB0aGlzLmdldENoaWxkSW5kZXgoY2hpbGQpO1xuXG4gICAgICAgICgwLCBfdXRpbHMucmVtb3ZlSXRlbXMpKHRoaXMuY2hpbGRyZW4sIGN1cnJlbnRJbmRleCwgMSk7IC8vIHJlbW92ZSBmcm9tIG9sZCBwb3NpdGlvblxuICAgICAgICB0aGlzLmNoaWxkcmVuLnNwbGljZShpbmRleCwgMCwgY2hpbGQpOyAvLyBhZGQgYXQgbmV3IHBvc2l0aW9uXG5cbiAgICAgICAgdGhpcy5vbkNoaWxkcmVuQ2hhbmdlKGluZGV4KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY2hpbGQgYXQgdGhlIHNwZWNpZmllZCBpbmRleFxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gVGhlIGluZGV4IHRvIGdldCB0aGUgY2hpbGQgYXRcbiAgICAgKiBAcmV0dXJuIHtQSVhJLkRpc3BsYXlPYmplY3R9IFRoZSBjaGlsZCBhdCB0aGUgZ2l2ZW4gaW5kZXgsIGlmIGFueS5cbiAgICAgKi9cblxuXG4gICAgQ29udGFpbmVyLnByb3RvdHlwZS5nZXRDaGlsZEF0ID0gZnVuY3Rpb24gZ2V0Q2hpbGRBdChpbmRleCkge1xuICAgICAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHRoaXMuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dldENoaWxkQXQ6IEluZGV4ICgnICsgaW5kZXggKyAnKSBkb2VzIG5vdCBleGlzdC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuW2luZGV4XTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBvbmUgb3IgbW9yZSBjaGlsZHJlbiBmcm9tIHRoZSBjb250YWluZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gey4uLlBJWEkuRGlzcGxheU9iamVjdH0gY2hpbGQgLSBUaGUgRGlzcGxheU9iamVjdChzKSB0byByZW1vdmVcbiAgICAgKiBAcmV0dXJuIHtQSVhJLkRpc3BsYXlPYmplY3R9IFRoZSBmaXJzdCBjaGlsZCB0aGF0IHdhcyByZW1vdmVkLlxuICAgICAqL1xuXG5cbiAgICBDb250YWluZXIucHJvdG90eXBlLnJlbW92ZUNoaWxkID0gZnVuY3Rpb24gcmVtb3ZlQ2hpbGQoY2hpbGQpIHtcbiAgICAgICAgdmFyIGFyZ3VtZW50c0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cbiAgICAgICAgLy8gaWYgdGhlcmUgaXMgb25seSBvbmUgYXJndW1lbnQgd2UgY2FuIGJ5cGFzcyBsb29waW5nIHRocm91Z2ggdGhlIHRoZW1cbiAgICAgICAgaWYgKGFyZ3VtZW50c0xlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIC8vIGxvb3AgdGhyb3VnaCB0aGUgYXJndW1lbnRzIHByb3BlcnR5IGFuZCBhZGQgYWxsIGNoaWxkcmVuXG4gICAgICAgICAgICAvLyB1c2UgaXQgdGhlIHJpZ2h0IHdheSAoLmxlbmd0aCBhbmQgW2ldKSBzbyB0aGF0IHRoaXMgZnVuY3Rpb24gY2FuIHN0aWxsIGJlIG9wdGltaXNlZCBieSBKUyBydW50aW1lc1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHNMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlQ2hpbGQoYXJndW1lbnRzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuY2hpbGRyZW4uaW5kZXhPZihjaGlsZCk7XG5cbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHJldHVybiBudWxsO1xuXG4gICAgICAgICAgICBjaGlsZC5wYXJlbnQgPSBudWxsO1xuICAgICAgICAgICAgLy8gZW5zdXJlIGNoaWxkIHRyYW5zZm9ybSB3aWxsIGJlIHJlY2FsY3VsYXRlZFxuICAgICAgICAgICAgY2hpbGQudHJhbnNmb3JtLl9wYXJlbnRJRCA9IC0xO1xuICAgICAgICAgICAgKDAsIF91dGlscy5yZW1vdmVJdGVtcykodGhpcy5jaGlsZHJlbiwgaW5kZXgsIDEpO1xuXG4gICAgICAgICAgICAvLyBlbnN1cmUgYm91bmRzIHdpbGwgYmUgcmVjYWxjdWxhdGVkXG4gICAgICAgICAgICB0aGlzLl9ib3VuZHNJRCsrO1xuXG4gICAgICAgICAgICAvLyBUT0RPIC0gbGV0cyBlaXRoZXIgZG8gYWxsIGNhbGxiYWNrcyBvciBhbGwgZXZlbnRzLi4gbm90IGJvdGghXG4gICAgICAgICAgICB0aGlzLm9uQ2hpbGRyZW5DaGFuZ2UoaW5kZXgpO1xuICAgICAgICAgICAgY2hpbGQuZW1pdCgncmVtb3ZlZCcsIHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgY2hpbGQgZnJvbSB0aGUgc3BlY2lmaWVkIGluZGV4IHBvc2l0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gVGhlIGluZGV4IHRvIGdldCB0aGUgY2hpbGQgZnJvbVxuICAgICAqIEByZXR1cm4ge1BJWEkuRGlzcGxheU9iamVjdH0gVGhlIGNoaWxkIHRoYXQgd2FzIHJlbW92ZWQuXG4gICAgICovXG5cblxuICAgIENvbnRhaW5lci5wcm90b3R5cGUucmVtb3ZlQ2hpbGRBdCA9IGZ1bmN0aW9uIHJlbW92ZUNoaWxkQXQoaW5kZXgpIHtcbiAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5nZXRDaGlsZEF0KGluZGV4KTtcblxuICAgICAgICAvLyBlbnN1cmUgY2hpbGQgdHJhbnNmb3JtIHdpbGwgYmUgcmVjYWxjdWxhdGVkLi5cbiAgICAgICAgY2hpbGQucGFyZW50ID0gbnVsbDtcbiAgICAgICAgY2hpbGQudHJhbnNmb3JtLl9wYXJlbnRJRCA9IC0xO1xuICAgICAgICAoMCwgX3V0aWxzLnJlbW92ZUl0ZW1zKSh0aGlzLmNoaWxkcmVuLCBpbmRleCwgMSk7XG5cbiAgICAgICAgLy8gZW5zdXJlIGJvdW5kcyB3aWxsIGJlIHJlY2FsY3VsYXRlZFxuICAgICAgICB0aGlzLl9ib3VuZHNJRCsrO1xuXG4gICAgICAgIC8vIFRPRE8gLSBsZXRzIGVpdGhlciBkbyBhbGwgY2FsbGJhY2tzIG9yIGFsbCBldmVudHMuLiBub3QgYm90aCFcbiAgICAgICAgdGhpcy5vbkNoaWxkcmVuQ2hhbmdlKGluZGV4KTtcbiAgICAgICAgY2hpbGQuZW1pdCgncmVtb3ZlZCcsIHRoaXMpO1xuXG4gICAgICAgIHJldHVybiBjaGlsZDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgY2hpbGRyZW4gZnJvbSB0aGlzIGNvbnRhaW5lciB0aGF0IGFyZSB3aXRoaW4gdGhlIGJlZ2luIGFuZCBlbmQgaW5kZXhlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYmVnaW5JbmRleD0wXSAtIFRoZSBiZWdpbm5pbmcgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtlbmRJbmRleD10aGlzLmNoaWxkcmVuLmxlbmd0aF0gLSBUaGUgZW5kaW5nIHBvc2l0aW9uLiBEZWZhdWx0IHZhbHVlIGlzIHNpemUgb2YgdGhlIGNvbnRhaW5lci5cbiAgICAgKiBAcmV0dXJucyB7RGlzcGxheU9iamVjdFtdfSBMaXN0IG9mIHJlbW92ZWQgY2hpbGRyZW5cbiAgICAgKi9cblxuXG4gICAgQ29udGFpbmVyLnByb3RvdHlwZS5yZW1vdmVDaGlsZHJlbiA9IGZ1bmN0aW9uIHJlbW92ZUNoaWxkcmVuKCkge1xuICAgICAgICB2YXIgYmVnaW5JbmRleCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMDtcbiAgICAgICAgdmFyIGVuZEluZGV4ID0gYXJndW1lbnRzWzFdO1xuXG4gICAgICAgIHZhciBiZWdpbiA9IGJlZ2luSW5kZXg7XG4gICAgICAgIHZhciBlbmQgPSB0eXBlb2YgZW5kSW5kZXggPT09ICdudW1iZXInID8gZW5kSW5kZXggOiB0aGlzLmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgdmFyIHJhbmdlID0gZW5kIC0gYmVnaW47XG4gICAgICAgIHZhciByZW1vdmVkID0gdm9pZCAwO1xuXG4gICAgICAgIGlmIChyYW5nZSA+IDAgJiYgcmFuZ2UgPD0gZW5kKSB7XG4gICAgICAgICAgICByZW1vdmVkID0gdGhpcy5jaGlsZHJlbi5zcGxpY2UoYmVnaW4sIHJhbmdlKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZW1vdmVkLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlZFtpXS5wYXJlbnQgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChyZW1vdmVkW2ldLnRyYW5zZm9ybSkge1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVkW2ldLnRyYW5zZm9ybS5fcGFyZW50SUQgPSAtMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX2JvdW5kc0lEKys7XG5cbiAgICAgICAgICAgIHRoaXMub25DaGlsZHJlbkNoYW5nZShiZWdpbkluZGV4KTtcblxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHJlbW92ZWQubGVuZ3RoOyArK19pKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlZFtfaV0uZW1pdCgncmVtb3ZlZCcsIHRoaXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVtb3ZlZDtcbiAgICAgICAgfSBlbHNlIGlmIChyYW5nZSA9PT0gMCAmJiB0aGlzLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3JlbW92ZUNoaWxkcmVuOiBudW1lcmljIHZhbHVlcyBhcmUgb3V0c2lkZSB0aGUgYWNjZXB0YWJsZSByYW5nZS4nKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgdHJhbnNmb3JtIG9uIGFsbCBjaGlsZHJlbiBvZiB0aGlzIGNvbnRhaW5lciBmb3IgcmVuZGVyaW5nXG4gICAgICovXG5cblxuICAgIENvbnRhaW5lci5wcm90b3R5cGUudXBkYXRlVHJhbnNmb3JtID0gZnVuY3Rpb24gdXBkYXRlVHJhbnNmb3JtKCkge1xuICAgICAgICB0aGlzLl9ib3VuZHNJRCsrO1xuXG4gICAgICAgIHRoaXMudHJhbnNmb3JtLnVwZGF0ZVRyYW5zZm9ybSh0aGlzLnBhcmVudC50cmFuc2Zvcm0pO1xuXG4gICAgICAgIC8vIFRPRE86IGNoZWNrIHJlbmRlciBmbGFncywgaG93IHRvIHByb2Nlc3Mgc3R1ZmYgaGVyZVxuICAgICAgICB0aGlzLndvcmxkQWxwaGEgPSB0aGlzLmFscGhhICogdGhpcy5wYXJlbnQud29ybGRBbHBoYTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgaiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgKytpKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldO1xuXG4gICAgICAgICAgICBpZiAoY2hpbGQudmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIGNoaWxkLnVwZGF0ZVRyYW5zZm9ybSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlY2FsY3VsYXRlcyB0aGUgYm91bmRzIG9mIHRoZSBjb250YWluZXIuXG4gICAgICpcbiAgICAgKi9cblxuXG4gICAgQ29udGFpbmVyLnByb3RvdHlwZS5jYWxjdWxhdGVCb3VuZHMgPSBmdW5jdGlvbiBjYWxjdWxhdGVCb3VuZHMoKSB7XG4gICAgICAgIHRoaXMuX2JvdW5kcy5jbGVhcigpO1xuXG4gICAgICAgIHRoaXMuX2NhbGN1bGF0ZUJvdW5kcygpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXTtcblxuICAgICAgICAgICAgaWYgKCFjaGlsZC52aXNpYmxlIHx8ICFjaGlsZC5yZW5kZXJhYmxlKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNoaWxkLmNhbGN1bGF0ZUJvdW5kcygpO1xuXG4gICAgICAgICAgICAvLyBUT0RPOiBmaWx0ZXIrbWFzaywgbmVlZCB0byBtYXNrIGJvdGggc29tZWhvd1xuICAgICAgICAgICAgaWYgKGNoaWxkLl9tYXNrKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQuX21hc2suY2FsY3VsYXRlQm91bmRzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fYm91bmRzLmFkZEJvdW5kc01hc2soY2hpbGQuX2JvdW5kcywgY2hpbGQuX21hc2suX2JvdW5kcyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoaWxkLmZpbHRlckFyZWEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9ib3VuZHMuYWRkQm91bmRzQXJlYShjaGlsZC5fYm91bmRzLCBjaGlsZC5maWx0ZXJBcmVhKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYm91bmRzLmFkZEJvdW5kcyhjaGlsZC5fYm91bmRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2xhc3RCb3VuZHNJRCA9IHRoaXMuX2JvdW5kc0lEO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZWNhbGN1bGF0ZXMgdGhlIGJvdW5kcyBvZiB0aGUgb2JqZWN0LiBPdmVycmlkZSB0aGlzIHRvXG4gICAgICogY2FsY3VsYXRlIHRoZSBib3VuZHMgb2YgdGhlIHNwZWNpZmljIG9iamVjdCAobm90IGluY2x1ZGluZyBjaGlsZHJlbikuXG4gICAgICpcbiAgICAgKi9cblxuXG4gICAgQ29udGFpbmVyLnByb3RvdHlwZS5fY2FsY3VsYXRlQm91bmRzID0gZnVuY3Rpb24gX2NhbGN1bGF0ZUJvdW5kcygpIHt9XG4gICAgLy8gRklMTCBJTi8vXG5cblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgdGhlIG9iamVjdCB1c2luZyB0aGUgV2ViR0wgcmVuZGVyZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5XZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlclxuICAgICAqL1xuICAgIDtcblxuICAgIENvbnRhaW5lci5wcm90b3R5cGUucmVuZGVyV2ViR0wgPSBmdW5jdGlvbiByZW5kZXJXZWJHTChyZW5kZXJlcikge1xuICAgICAgICAvLyBpZiB0aGUgb2JqZWN0IGlzIG5vdCB2aXNpYmxlIG9yIHRoZSBhbHBoYSBpcyAwIHRoZW4gbm8gbmVlZCB0byByZW5kZXIgdGhpcyBlbGVtZW50XG4gICAgICAgIGlmICghdGhpcy52aXNpYmxlIHx8IHRoaXMud29ybGRBbHBoYSA8PSAwIHx8ICF0aGlzLnJlbmRlcmFibGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGRvIGEgcXVpY2sgY2hlY2sgdG8gc2VlIGlmIHRoaXMgZWxlbWVudCBoYXMgYSBtYXNrIG9yIGEgZmlsdGVyLlxuICAgICAgICBpZiAodGhpcy5fbWFzayB8fCB0aGlzLl9maWx0ZXJzKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlckFkdmFuY2VkV2ViR0wocmVuZGVyZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyV2ViR0wocmVuZGVyZXIpO1xuXG4gICAgICAgICAgICAvLyBzaW1wbGUgcmVuZGVyIGNoaWxkcmVuIVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7ICsraSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5baV0ucmVuZGVyV2ViR0wocmVuZGVyZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciB0aGUgb2JqZWN0IHVzaW5nIHRoZSBXZWJHTCByZW5kZXJlciBhbmQgYWR2YW5jZWQgZmVhdHVyZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7UElYSS5XZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlclxuICAgICAqL1xuXG5cbiAgICBDb250YWluZXIucHJvdG90eXBlLnJlbmRlckFkdmFuY2VkV2ViR0wgPSBmdW5jdGlvbiByZW5kZXJBZHZhbmNlZFdlYkdMKHJlbmRlcmVyKSB7XG4gICAgICAgIHJlbmRlcmVyLmZsdXNoKCk7XG5cbiAgICAgICAgdmFyIGZpbHRlcnMgPSB0aGlzLl9maWx0ZXJzO1xuICAgICAgICB2YXIgbWFzayA9IHRoaXMuX21hc2s7XG5cbiAgICAgICAgLy8gcHVzaCBmaWx0ZXIgZmlyc3QgYXMgd2UgbmVlZCB0byBlbnN1cmUgdGhlIHN0ZW5jaWwgYnVmZmVyIGlzIGNvcnJlY3QgZm9yIGFueSBtYXNraW5nXG4gICAgICAgIGlmIChmaWx0ZXJzKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2VuYWJsZWRGaWx0ZXJzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZW5hYmxlZEZpbHRlcnMgPSBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fZW5hYmxlZEZpbHRlcnMubGVuZ3RoID0gMDtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWx0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpbHRlcnNbaV0uZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9lbmFibGVkRmlsdGVycy5wdXNoKGZpbHRlcnNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuX2VuYWJsZWRGaWx0ZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJlbmRlcmVyLmZpbHRlck1hbmFnZXIucHVzaEZpbHRlcih0aGlzLCB0aGlzLl9lbmFibGVkRmlsdGVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWFzaykge1xuICAgICAgICAgICAgcmVuZGVyZXIubWFza01hbmFnZXIucHVzaE1hc2sodGhpcywgdGhpcy5fbWFzayk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgdGhpcyBvYmplY3QgdG8gdGhlIGJhdGNoLCBvbmx5IHJlbmRlcmVkIGlmIGl0IGhhcyBhIHRleHR1cmUuXG4gICAgICAgIHRoaXMuX3JlbmRlcldlYkdMKHJlbmRlcmVyKTtcblxuICAgICAgICAvLyBub3cgbG9vcCB0aHJvdWdoIHRoZSBjaGlsZHJlbiBhbmQgbWFrZSBzdXJlIHRoZXkgZ2V0IHJlbmRlcmVkXG4gICAgICAgIGZvciAodmFyIF9pMiA9IDAsIGogPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgX2kyIDwgajsgX2kyKyspIHtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5bX2kyXS5yZW5kZXJXZWJHTChyZW5kZXJlcik7XG4gICAgICAgIH1cblxuICAgICAgICByZW5kZXJlci5mbHVzaCgpO1xuXG4gICAgICAgIGlmIChtYXNrKSB7XG4gICAgICAgICAgICByZW5kZXJlci5tYXNrTWFuYWdlci5wb3BNYXNrKHRoaXMsIHRoaXMuX21hc2spO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZpbHRlcnMgJiYgdGhpcy5fZW5hYmxlZEZpbHRlcnMgJiYgdGhpcy5fZW5hYmxlZEZpbHRlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZW5kZXJlci5maWx0ZXJNYW5hZ2VyLnBvcEZpbHRlcigpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRvIGJlIG92ZXJyaWRkZW4gYnkgdGhlIHN1YmNsYXNzZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7UElYSS5XZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlclxuICAgICAqL1xuXG5cbiAgICBDb250YWluZXIucHJvdG90eXBlLl9yZW5kZXJXZWJHTCA9IGZ1bmN0aW9uIF9yZW5kZXJXZWJHTChyZW5kZXJlcikgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIHt9XG4gICAgLy8gdGhpcyBpcyB3aGVyZSBjb250ZW50IGl0c2VsZiBnZXRzIHJlbmRlcmVkLi4uXG5cblxuICAgIC8qKlxuICAgICAqIFRvIGJlIG92ZXJyaWRkZW4gYnkgdGhlIHN1YmNsYXNzXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7UElYSS5DYW52YXNSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXJcbiAgICAgKi9cbiAgICA7XG5cbiAgICBDb250YWluZXIucHJvdG90eXBlLl9yZW5kZXJDYW52YXMgPSBmdW5jdGlvbiBfcmVuZGVyQ2FudmFzKHJlbmRlcmVyKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAge31cbiAgICAvLyB0aGlzIGlzIHdoZXJlIGNvbnRlbnQgaXRzZWxmIGdldHMgcmVuZGVyZWQuLi5cblxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0aGUgb2JqZWN0IHVzaW5nIHRoZSBDYW52YXMgcmVuZGVyZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5DYW52YXNSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXJcbiAgICAgKi9cbiAgICA7XG5cbiAgICBDb250YWluZXIucHJvdG90eXBlLnJlbmRlckNhbnZhcyA9IGZ1bmN0aW9uIHJlbmRlckNhbnZhcyhyZW5kZXJlcikge1xuICAgICAgICAvLyBpZiBub3QgdmlzaWJsZSBvciB0aGUgYWxwaGEgaXMgMCB0aGVuIG5vIG5lZWQgdG8gcmVuZGVyIHRoaXNcbiAgICAgICAgaWYgKCF0aGlzLnZpc2libGUgfHwgdGhpcy53b3JsZEFscGhhIDw9IDAgfHwgIXRoaXMucmVuZGVyYWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX21hc2spIHtcbiAgICAgICAgICAgIHJlbmRlcmVyLm1hc2tNYW5hZ2VyLnB1c2hNYXNrKHRoaXMuX21hc2spO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcmVuZGVyQ2FudmFzKHJlbmRlcmVyKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7ICsraSkge1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbltpXS5yZW5kZXJDYW52YXMocmVuZGVyZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX21hc2spIHtcbiAgICAgICAgICAgIHJlbmRlcmVyLm1hc2tNYW5hZ2VyLnBvcE1hc2socmVuZGVyZXIpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIGludGVybmFsIHJlZmVyZW5jZXMgYW5kIGxpc3RlbmVycyBhcyB3ZWxsIGFzIHJlbW92ZXMgY2hpbGRyZW4gZnJvbSB0aGUgZGlzcGxheSBsaXN0LlxuICAgICAqIERvIG5vdCB1c2UgYSBDb250YWluZXIgYWZ0ZXIgY2FsbGluZyBgZGVzdHJveWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdHxib29sZWFufSBbb3B0aW9uc10gLSBPcHRpb25zIHBhcmFtZXRlci4gQSBib29sZWFuIHdpbGwgYWN0IGFzIGlmIGFsbCBvcHRpb25zXG4gICAgICogIGhhdmUgYmVlbiBzZXQgdG8gdGhhdCB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY2hpbGRyZW49ZmFsc2VdIC0gaWYgc2V0IHRvIHRydWUsIGFsbCB0aGUgY2hpbGRyZW4gd2lsbCBoYXZlIHRoZWlyIGRlc3Ryb3lcbiAgICAgKiAgbWV0aG9kIGNhbGxlZCBhcyB3ZWxsLiAnb3B0aW9ucycgd2lsbCBiZSBwYXNzZWQgb24gdG8gdGhvc2UgY2FsbHMuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50ZXh0dXJlPWZhbHNlXSAtIE9ubHkgdXNlZCBmb3IgY2hpbGQgU3ByaXRlcyBpZiBvcHRpb25zLmNoaWxkcmVuIGlzIHNldCB0byB0cnVlXG4gICAgICogIFNob3VsZCBpdCBkZXN0cm95IHRoZSB0ZXh0dXJlIG9mIHRoZSBjaGlsZCBzcHJpdGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmJhc2VUZXh0dXJlPWZhbHNlXSAtIE9ubHkgdXNlZCBmb3IgY2hpbGQgU3ByaXRlcyBpZiBvcHRpb25zLmNoaWxkcmVuIGlzIHNldCB0byB0cnVlXG4gICAgICogIFNob3VsZCBpdCBkZXN0cm95IHRoZSBiYXNlIHRleHR1cmUgb2YgdGhlIGNoaWxkIHNwcml0ZVxuICAgICAqL1xuXG5cbiAgICBDb250YWluZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KG9wdGlvbnMpIHtcbiAgICAgICAgX0Rpc3BsYXlPYmplY3QucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcblxuICAgICAgICB2YXIgZGVzdHJveUNoaWxkcmVuID0gdHlwZW9mIG9wdGlvbnMgPT09ICdib29sZWFuJyA/IG9wdGlvbnMgOiBvcHRpb25zICYmIG9wdGlvbnMuY2hpbGRyZW47XG5cbiAgICAgICAgdmFyIG9sZENoaWxkcmVuID0gdGhpcy5yZW1vdmVDaGlsZHJlbigwLCB0aGlzLmNoaWxkcmVuLmxlbmd0aCk7XG5cbiAgICAgICAgaWYgKGRlc3Ryb3lDaGlsZHJlbikge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvbGRDaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIG9sZENoaWxkcmVuW2ldLmRlc3Ryb3kob3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIHdpZHRoIG9mIHRoZSBDb250YWluZXIsIHNldHRpbmcgdGhpcyB3aWxsIGFjdHVhbGx5IG1vZGlmeSB0aGUgc2NhbGUgdG8gYWNoaWV2ZSB0aGUgdmFsdWUgc2V0XG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICovXG5cblxuICAgIF9jcmVhdGVDbGFzcyhDb250YWluZXIsIFt7XG4gICAgICAgIGtleTogJ3dpZHRoJyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FsZS54ICogdGhpcy5nZXRMb2NhbEJvdW5kcygpLndpZHRoO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSByZXF1aXJlLWpzZG9jXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHRoaXMuZ2V0TG9jYWxCb3VuZHMoKS53aWR0aDtcblxuICAgICAgICAgICAgaWYgKHdpZHRoICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2FsZS54ID0gdmFsdWUgLyB3aWR0aDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2FsZS54ID0gMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fd2lkdGggPSB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgaGVpZ2h0IG9mIHRoZSBDb250YWluZXIsIHNldHRpbmcgdGhpcyB3aWxsIGFjdHVhbGx5IG1vZGlmeSB0aGUgc2NhbGUgdG8gYWNoaWV2ZSB0aGUgdmFsdWUgc2V0XG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2hlaWdodCcsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhbGUueSAqIHRoaXMuZ2V0TG9jYWxCb3VuZHMoKS5oZWlnaHQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlcXVpcmUtanNkb2NcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IHRoaXMuZ2V0TG9jYWxCb3VuZHMoKS5oZWlnaHQ7XG5cbiAgICAgICAgICAgIGlmIChoZWlnaHQgIT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNjYWxlLnkgPSB2YWx1ZSAvIGhlaWdodDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2FsZS55ID0gMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5faGVpZ2h0ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gQ29udGFpbmVyO1xufShfRGlzcGxheU9iamVjdDMuZGVmYXVsdCk7XG5cbi8vIHBlcmZvcm1hbmNlIGluY3JlYXNlIHRvIGF2b2lkIHVzaW5nIGNhbGwuLiAoMTB4IGZhc3RlcilcblxuXG5leHBvcnRzLmRlZmF1bHQgPSBDb250YWluZXI7XG5Db250YWluZXIucHJvdG90eXBlLmNvbnRhaW5lclVwZGF0ZVRyYW5zZm9ybSA9IENvbnRhaW5lci5wcm90b3R5cGUudXBkYXRlVHJhbnNmb3JtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q29udGFpbmVyLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9ldmVudGVtaXR0ZXIgPSByZXF1aXJlKCdldmVudGVtaXR0ZXIzJyk7XG5cbnZhciBfZXZlbnRlbWl0dGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2V2ZW50ZW1pdHRlcik7XG5cbnZhciBfY29uc3QgPSByZXF1aXJlKCcuLi9jb25zdCcpO1xuXG52YXIgX3NldHRpbmdzID0gcmVxdWlyZSgnLi4vc2V0dGluZ3MnKTtcblxudmFyIF9zZXR0aW5nczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zZXR0aW5ncyk7XG5cbnZhciBfVHJhbnNmb3JtU3RhdGljID0gcmVxdWlyZSgnLi9UcmFuc2Zvcm1TdGF0aWMnKTtcblxudmFyIF9UcmFuc2Zvcm1TdGF0aWMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVHJhbnNmb3JtU3RhdGljKTtcblxudmFyIF9UcmFuc2Zvcm0gPSByZXF1aXJlKCcuL1RyYW5zZm9ybScpO1xuXG52YXIgX1RyYW5zZm9ybTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9UcmFuc2Zvcm0pO1xuXG52YXIgX0JvdW5kcyA9IHJlcXVpcmUoJy4vQm91bmRzJyk7XG5cbnZhciBfQm91bmRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0JvdW5kcyk7XG5cbnZhciBfbWF0aCA9IHJlcXVpcmUoJy4uL21hdGgnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4vLyBfdGVtcERpc3BsYXlPYmplY3RQYXJlbnQgPSBuZXcgRGlzcGxheU9iamVjdCgpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGNsYXNzIGZvciBhbGwgb2JqZWN0cyB0aGF0IGFyZSByZW5kZXJlZCBvbiB0aGUgc2NyZWVuLlxuICogVGhpcyBpcyBhbiBhYnN0cmFjdCBjbGFzcyBhbmQgc2hvdWxkIG5vdCBiZSB1c2VkIG9uIGl0cyBvd24gcmF0aGVyIGl0IHNob3VsZCBiZSBleHRlbmRlZC5cbiAqXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIEV2ZW50RW1pdHRlclxuICogQG1lbWJlcm9mIFBJWElcbiAqL1xudmFyIERpc3BsYXlPYmplY3QgPSBmdW5jdGlvbiAoX0V2ZW50RW1pdHRlcikge1xuICAgIF9pbmhlcml0cyhEaXNwbGF5T2JqZWN0LCBfRXZlbnRFbWl0dGVyKTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgZnVuY3Rpb24gRGlzcGxheU9iamVjdCgpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERpc3BsYXlPYmplY3QpO1xuXG4gICAgICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9FdmVudEVtaXR0ZXIuY2FsbCh0aGlzKSk7XG5cbiAgICAgICAgdmFyIFRyYW5zZm9ybUNsYXNzID0gX3NldHRpbmdzMi5kZWZhdWx0LlRSQU5TRk9STV9NT0RFID09PSBfY29uc3QuVFJBTlNGT1JNX01PREUuU1RBVElDID8gX1RyYW5zZm9ybVN0YXRpYzIuZGVmYXVsdCA6IF9UcmFuc2Zvcm0yLmRlZmF1bHQ7XG5cbiAgICAgICAgX3RoaXMudGVtcERpc3BsYXlPYmplY3RQYXJlbnQgPSBudWxsO1xuXG4gICAgICAgIC8vIFRPRE86IG5lZWQgdG8gY3JlYXRlIFRyYW5zZm9ybSBmcm9tIGZhY3RvcnlcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdvcmxkIHRyYW5zZm9ybSBhbmQgbG9jYWwgdHJhbnNmb3JtIG9mIHRoaXMgb2JqZWN0LlxuICAgICAgICAgKiBUaGlzIHdpbGwgYmVjb21lIHJlYWQtb25seSBsYXRlciwgcGxlYXNlIGRvIG5vdCBhc3NpZ24gYW55dGhpbmcgdGhlcmUgdW5sZXNzIHlvdSBrbm93IHdoYXQgYXJlIHlvdSBkb2luZ1xuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLlRyYW5zZm9ybUJhc2V9XG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy50cmFuc2Zvcm0gPSBuZXcgVHJhbnNmb3JtQ2xhc3MoKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG9wYWNpdHkgb2YgdGhlIG9iamVjdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuYWxwaGEgPSAxO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdmlzaWJpbGl0eSBvZiB0aGUgb2JqZWN0LiBJZiBmYWxzZSB0aGUgb2JqZWN0IHdpbGwgbm90IGJlIGRyYXduLCBhbmRcbiAgICAgICAgICogdGhlIHVwZGF0ZVRyYW5zZm9ybSBmdW5jdGlvbiB3aWxsIG5vdCBiZSBjYWxsZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIE9ubHkgYWZmZWN0cyByZWN1cnNpdmUgY2FsbHMgZnJvbSBwYXJlbnQuIFlvdSBjYW4gYXNrIGZvciBib3VuZHMgb3IgY2FsbCB1cGRhdGVUcmFuc2Zvcm0gbWFudWFsbHlcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLnZpc2libGUgPSB0cnVlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYW4gdGhpcyBvYmplY3QgYmUgcmVuZGVyZWQsIGlmIGZhbHNlIHRoZSBvYmplY3Qgd2lsbCBub3QgYmUgZHJhd24gYnV0IHRoZSB1cGRhdGVUcmFuc2Zvcm1cbiAgICAgICAgICogbWV0aG9kcyB3aWxsIHN0aWxsIGJlIGNhbGxlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogT25seSBhZmZlY3RzIHJlY3Vyc2l2ZSBjYWxscyBmcm9tIHBhcmVudC4gWW91IGNhbiBhc2sgZm9yIGJvdW5kcyBtYW51YWxseVxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMucmVuZGVyYWJsZSA9IHRydWU7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkaXNwbGF5IG9iamVjdCBjb250YWluZXIgdGhhdCBjb250YWlucyB0aGlzIGRpc3BsYXkgb2JqZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLkNvbnRhaW5lcn1cbiAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5wYXJlbnQgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbXVsdGlwbGllZCBhbHBoYSBvZiB0aGUgZGlzcGxheU9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEByZWFkb25seVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMud29ybGRBbHBoYSA9IDE7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBhcmVhIHRoZSBmaWx0ZXIgaXMgYXBwbGllZCB0by4gVGhpcyBpcyB1c2VkIGFzIG1vcmUgb2YgYW4gb3B0aW1pc2F0aW9uXG4gICAgICAgICAqIHJhdGhlciB0aGFuIGZpZ3VyaW5nIG91dCB0aGUgZGltZW5zaW9ucyBvZiB0aGUgZGlzcGxheU9iamVjdCBlYWNoIGZyYW1lIHlvdSBjYW4gc2V0IHRoaXMgcmVjdGFuZ2xlXG4gICAgICAgICAqXG4gICAgICAgICAqIEFsc28gd29ya3MgYXMgYW4gaW50ZXJhY3Rpb24gbWFza1xuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLlJlY3RhbmdsZX1cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLmZpbHRlckFyZWEgPSBudWxsO1xuXG4gICAgICAgIF90aGlzLl9maWx0ZXJzID0gbnVsbDtcbiAgICAgICAgX3RoaXMuX2VuYWJsZWRGaWx0ZXJzID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGJvdW5kcyBvYmplY3QsIHRoaXMgaXMgdXNlZCB0byBjYWxjdWxhdGUgYW5kIHN0b3JlIHRoZSBib3VuZHMgb2YgdGhlIGRpc3BsYXlPYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5SZWN0YW5nbGV9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5fYm91bmRzID0gbmV3IF9Cb3VuZHMyLmRlZmF1bHQoKTtcbiAgICAgICAgX3RoaXMuX2JvdW5kc0lEID0gMDtcbiAgICAgICAgX3RoaXMuX2xhc3RCb3VuZHNJRCA9IC0xO1xuICAgICAgICBfdGhpcy5fYm91bmRzUmVjdCA9IG51bGw7XG4gICAgICAgIF90aGlzLl9sb2NhbEJvdW5kc1JlY3QgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgb3JpZ2luYWwsIGNhY2hlZCBtYXNrIG9mIHRoZSBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5HcmFwaGljc3xQSVhJLlNwcml0ZX1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLl9tYXNrID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdGhlIG9iamVjdCBoYXMgYmVlbiBkZXN0cm95ZWQgdmlhIGRlc3Ryb3koKS4gSWYgdHJ1ZSwgaXQgc2hvdWxkIG5vdCBiZSB1c2VkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAcmVhZG9ubHlcbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLl9kZXN0cm95ZWQgPSBmYWxzZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZWQgd2hlbiB0aGlzIERpc3BsYXlPYmplY3QgaXMgYWRkZWQgdG8gYSBDb250YWluZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBldmVudCBQSVhJLkRpc3BsYXlPYmplY3QjYWRkZWRcbiAgICAgICAgICogQHBhcmFtIHtQSVhJLkNvbnRhaW5lcn0gY29udGFpbmVyIC0gVGhlIGNvbnRhaW5lciBhZGRlZCB0by5cbiAgICAgICAgICovXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVkIHdoZW4gdGhpcyBEaXNwbGF5T2JqZWN0IGlzIHJlbW92ZWQgZnJvbSBhIENvbnRhaW5lci5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV2ZW50IFBJWEkuRGlzcGxheU9iamVjdCNyZW1vdmVkXG4gICAgICAgICAqIEBwYXJhbSB7UElYSS5Db250YWluZXJ9IGNvbnRhaW5lciAtIFRoZSBjb250YWluZXIgcmVtb3ZlZCBmcm9tLlxuICAgICAgICAgKi9cbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG1lbWJlciB7UElYSS5EaXNwbGF5T2JqZWN0fVxuICAgICAqL1xuXG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBvYmplY3QgdHJhbnNmb3JtIGZvciByZW5kZXJpbmdcbiAgICAgKlxuICAgICAqIFRPRE8gLSBPcHRpbWl6YXRpb24gcGFzcyFcbiAgICAgKi9cbiAgICBEaXNwbGF5T2JqZWN0LnByb3RvdHlwZS51cGRhdGVUcmFuc2Zvcm0gPSBmdW5jdGlvbiB1cGRhdGVUcmFuc2Zvcm0oKSB7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtLnVwZGF0ZVRyYW5zZm9ybSh0aGlzLnBhcmVudC50cmFuc2Zvcm0pO1xuICAgICAgICAvLyBtdWx0aXBseSB0aGUgYWxwaGFzLi5cbiAgICAgICAgdGhpcy53b3JsZEFscGhhID0gdGhpcy5hbHBoYSAqIHRoaXMucGFyZW50LndvcmxkQWxwaGE7XG5cbiAgICAgICAgdGhpcy5fYm91bmRzLnVwZGF0ZUlEKys7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHJlY3Vyc2l2ZWx5IHVwZGF0ZXMgdHJhbnNmb3JtIG9mIGFsbCBvYmplY3RzIGZyb20gdGhlIHJvb3QgdG8gdGhpcyBvbmVcbiAgICAgKiBpbnRlcm5hbCBmdW5jdGlvbiBmb3IgdG9Mb2NhbCgpXG4gICAgICovXG5cblxuICAgIERpc3BsYXlPYmplY3QucHJvdG90eXBlLl9yZWN1cnNpdmVQb3N0VXBkYXRlVHJhbnNmb3JtID0gZnVuY3Rpb24gX3JlY3Vyc2l2ZVBvc3RVcGRhdGVUcmFuc2Zvcm0oKSB7XG4gICAgICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQuX3JlY3Vyc2l2ZVBvc3RVcGRhdGVUcmFuc2Zvcm0oKTtcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLnVwZGF0ZVRyYW5zZm9ybSh0aGlzLnBhcmVudC50cmFuc2Zvcm0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm0udXBkYXRlVHJhbnNmb3JtKHRoaXMuX3RlbXBEaXNwbGF5T2JqZWN0UGFyZW50LnRyYW5zZm9ybSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBib3VuZHMgb2YgdGhlIGRpc3BsYXlPYmplY3QgYXMgYSByZWN0YW5nbGUgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sZWFufSBza2lwVXBkYXRlIC0gc2V0dGluZyB0byB0cnVlIHdpbGwgc3RvcCB0aGUgdHJhbnNmb3JtcyBvZiB0aGUgc2NlbmUgZ3JhcGggZnJvbVxuICAgICAqICBiZWluZyB1cGRhdGVkLiBUaGlzIG1lYW5zIHRoZSBjYWxjdWxhdGlvbiByZXR1cm5lZCBNQVkgYmUgb3V0IG9mIGRhdGUgQlVUIHdpbGwgZ2l2ZSB5b3UgYVxuICAgICAqICBuaWNlIHBlcmZvcm1hbmNlIGJvb3N0XG4gICAgICogQHBhcmFtIHtQSVhJLlJlY3RhbmdsZX0gcmVjdCAtIE9wdGlvbmFsIHJlY3RhbmdsZSB0byBzdG9yZSB0aGUgcmVzdWx0IG9mIHRoZSBib3VuZHMgY2FsY3VsYXRpb25cbiAgICAgKiBAcmV0dXJuIHtQSVhJLlJlY3RhbmdsZX0gdGhlIHJlY3Rhbmd1bGFyIGJvdW5kaW5nIGFyZWFcbiAgICAgKi9cblxuXG4gICAgRGlzcGxheU9iamVjdC5wcm90b3R5cGUuZ2V0Qm91bmRzID0gZnVuY3Rpb24gZ2V0Qm91bmRzKHNraXBVcGRhdGUsIHJlY3QpIHtcbiAgICAgICAgaWYgKCFza2lwVXBkYXRlKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSB0aGlzLl90ZW1wRGlzcGxheU9iamVjdFBhcmVudDtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVRyYW5zZm9ybSgpO1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVjdXJzaXZlUG9zdFVwZGF0ZVRyYW5zZm9ybSgpO1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlVHJhbnNmb3JtKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fYm91bmRzSUQgIT09IHRoaXMuX2xhc3RCb3VuZHNJRCkge1xuICAgICAgICAgICAgdGhpcy5jYWxjdWxhdGVCb3VuZHMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcmVjdCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9ib3VuZHNSZWN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYm91bmRzUmVjdCA9IG5ldyBfbWF0aC5SZWN0YW5nbGUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVjdCA9IHRoaXMuX2JvdW5kc1JlY3Q7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fYm91bmRzLmdldFJlY3RhbmdsZShyZWN0KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBsb2NhbCBib3VuZHMgb2YgdGhlIGRpc3BsYXlPYmplY3QgYXMgYSByZWN0YW5nbGUgb2JqZWN0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuUmVjdGFuZ2xlfSBbcmVjdF0gLSBPcHRpb25hbCByZWN0YW5nbGUgdG8gc3RvcmUgdGhlIHJlc3VsdCBvZiB0aGUgYm91bmRzIGNhbGN1bGF0aW9uXG4gICAgICogQHJldHVybiB7UElYSS5SZWN0YW5nbGV9IHRoZSByZWN0YW5ndWxhciBib3VuZGluZyBhcmVhXG4gICAgICovXG5cblxuICAgIERpc3BsYXlPYmplY3QucHJvdG90eXBlLmdldExvY2FsQm91bmRzID0gZnVuY3Rpb24gZ2V0TG9jYWxCb3VuZHMocmVjdCkge1xuICAgICAgICB2YXIgdHJhbnNmb3JtUmVmID0gdGhpcy50cmFuc2Zvcm07XG4gICAgICAgIHZhciBwYXJlbnRSZWYgPSB0aGlzLnBhcmVudDtcblxuICAgICAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtID0gdGhpcy5fdGVtcERpc3BsYXlPYmplY3RQYXJlbnQudHJhbnNmb3JtO1xuXG4gICAgICAgIGlmICghcmVjdCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9sb2NhbEJvdW5kc1JlY3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2NhbEJvdW5kc1JlY3QgPSBuZXcgX21hdGguUmVjdGFuZ2xlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlY3QgPSB0aGlzLl9sb2NhbEJvdW5kc1JlY3Q7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYm91bmRzID0gdGhpcy5nZXRCb3VuZHMoZmFsc2UsIHJlY3QpO1xuXG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50UmVmO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVJlZjtcblxuICAgICAgICByZXR1cm4gYm91bmRzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBnbG9iYWwgcG9zaXRpb24gb2YgdGhlIGRpc3BsYXkgb2JqZWN0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuUG9pbnR9IHBvc2l0aW9uIC0gVGhlIHdvcmxkIG9yaWdpbiB0byBjYWxjdWxhdGUgZnJvbVxuICAgICAqIEBwYXJhbSB7UElYSS5Qb2ludH0gW3BvaW50XSAtIEEgUG9pbnQgb2JqZWN0IGluIHdoaWNoIHRvIHN0b3JlIHRoZSB2YWx1ZSwgb3B0aW9uYWxcbiAgICAgKiAgKG90aGVyd2lzZSB3aWxsIGNyZWF0ZSBhIG5ldyBQb2ludClcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtza2lwVXBkYXRlPWZhbHNlXSAtIFNob3VsZCB3ZSBza2lwIHRoZSB1cGRhdGUgdHJhbnNmb3JtLlxuICAgICAqIEByZXR1cm4ge1BJWEkuUG9pbnR9IEEgcG9pbnQgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgcG9zaXRpb24gb2YgdGhpcyBvYmplY3RcbiAgICAgKi9cblxuXG4gICAgRGlzcGxheU9iamVjdC5wcm90b3R5cGUudG9HbG9iYWwgPSBmdW5jdGlvbiB0b0dsb2JhbChwb3NpdGlvbiwgcG9pbnQpIHtcbiAgICAgICAgdmFyIHNraXBVcGRhdGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuXG4gICAgICAgIGlmICghc2tpcFVwZGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5fcmVjdXJzaXZlUG9zdFVwZGF0ZVRyYW5zZm9ybSgpO1xuXG4gICAgICAgICAgICAvLyB0aGlzIHBhcmVudCBjaGVjayBpcyBmb3IganVzdCBpbiBjYXNlIHRoZSBpdGVtIGlzIGEgcm9vdCBvYmplY3QuXG4gICAgICAgICAgICAvLyBJZiBpdCBpcyB3ZSBuZWVkIHRvIGdpdmUgaXQgYSB0ZW1wb3JhcnkgcGFyZW50IHNvIHRoYXQgZGlzcGxheU9iamVjdFVwZGF0ZVRyYW5zZm9ybSB3b3JrcyBjb3JyZWN0bHlcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgbWFpbmx5IHRvIGF2b2lkIGEgcGFyZW50IGNoZWNrIGluIHRoZSBtYWluIGxvb3AuIEV2ZXJ5IGxpdHRsZSBoZWxwcyBmb3IgcGVyZm9ybWFuY2UgOilcbiAgICAgICAgICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudCA9IHRoaXMuX3RlbXBEaXNwbGF5T2JqZWN0UGFyZW50O1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGxheU9iamVjdFVwZGF0ZVRyYW5zZm9ybSgpO1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwbGF5T2JqZWN0VXBkYXRlVHJhbnNmb3JtKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBkb24ndCBuZWVkIHRvIHVwZGF0ZSB0aGUgbG90XG4gICAgICAgIHJldHVybiB0aGlzLndvcmxkVHJhbnNmb3JtLmFwcGx5KHBvc2l0aW9uLCBwb2ludCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIGxvY2FsIHBvc2l0aW9uIG9mIHRoZSBkaXNwbGF5IG9iamVjdCByZWxhdGl2ZSB0byBhbm90aGVyIHBvaW50XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuUG9pbnR9IHBvc2l0aW9uIC0gVGhlIHdvcmxkIG9yaWdpbiB0byBjYWxjdWxhdGUgZnJvbVxuICAgICAqIEBwYXJhbSB7UElYSS5EaXNwbGF5T2JqZWN0fSBbZnJvbV0gLSBUaGUgRGlzcGxheU9iamVjdCB0byBjYWxjdWxhdGUgdGhlIGdsb2JhbCBwb3NpdGlvbiBmcm9tXG4gICAgICogQHBhcmFtIHtQSVhJLlBvaW50fSBbcG9pbnRdIC0gQSBQb2ludCBvYmplY3QgaW4gd2hpY2ggdG8gc3RvcmUgdGhlIHZhbHVlLCBvcHRpb25hbFxuICAgICAqICAob3RoZXJ3aXNlIHdpbGwgY3JlYXRlIGEgbmV3IFBvaW50KVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NraXBVcGRhdGU9ZmFsc2VdIC0gU2hvdWxkIHdlIHNraXAgdGhlIHVwZGF0ZSB0cmFuc2Zvcm1cbiAgICAgKiBAcmV0dXJuIHtQSVhJLlBvaW50fSBBIHBvaW50IG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHBvc2l0aW9uIG9mIHRoaXMgb2JqZWN0XG4gICAgICovXG5cblxuICAgIERpc3BsYXlPYmplY3QucHJvdG90eXBlLnRvTG9jYWwgPSBmdW5jdGlvbiB0b0xvY2FsKHBvc2l0aW9uLCBmcm9tLCBwb2ludCwgc2tpcFVwZGF0ZSkge1xuICAgICAgICBpZiAoZnJvbSkge1xuICAgICAgICAgICAgcG9zaXRpb24gPSBmcm9tLnRvR2xvYmFsKHBvc2l0aW9uLCBwb2ludCwgc2tpcFVwZGF0ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXNraXBVcGRhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlY3Vyc2l2ZVBvc3RVcGRhdGVUcmFuc2Zvcm0oKTtcblxuICAgICAgICAgICAgLy8gdGhpcyBwYXJlbnQgY2hlY2sgaXMgZm9yIGp1c3QgaW4gY2FzZSB0aGUgaXRlbSBpcyBhIHJvb3Qgb2JqZWN0LlxuICAgICAgICAgICAgLy8gSWYgaXQgaXMgd2UgbmVlZCB0byBnaXZlIGl0IGEgdGVtcG9yYXJ5IHBhcmVudCBzbyB0aGF0IGRpc3BsYXlPYmplY3RVcGRhdGVUcmFuc2Zvcm0gd29ya3MgY29ycmVjdGx5XG4gICAgICAgICAgICAvLyB0aGlzIGlzIG1haW5seSB0byBhdm9pZCBhIHBhcmVudCBjaGVjayBpbiB0aGUgbWFpbiBsb29wLiBFdmVyeSBsaXR0bGUgaGVscHMgZm9yIHBlcmZvcm1hbmNlIDopXG4gICAgICAgICAgICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSB0aGlzLl90ZW1wRGlzcGxheU9iamVjdFBhcmVudDtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BsYXlPYmplY3RVcGRhdGVUcmFuc2Zvcm0oKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGxheU9iamVjdFVwZGF0ZVRyYW5zZm9ybSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2ltcGx5IGFwcGx5IHRoZSBtYXRyaXguLlxuICAgICAgICByZXR1cm4gdGhpcy53b3JsZFRyYW5zZm9ybS5hcHBseUludmVyc2UocG9zaXRpb24sIHBvaW50KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0aGUgb2JqZWN0IHVzaW5nIHRoZSBXZWJHTCByZW5kZXJlclxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLldlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyXG4gICAgICovXG5cblxuICAgIERpc3BsYXlPYmplY3QucHJvdG90eXBlLnJlbmRlcldlYkdMID0gZnVuY3Rpb24gcmVuZGVyV2ViR0wocmVuZGVyZXIpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICB7fVxuICAgIC8vIE9WRVJXUklURTtcblxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0aGUgb2JqZWN0IHVzaW5nIHRoZSBDYW52YXMgcmVuZGVyZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5DYW52YXNSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXJcbiAgICAgKi9cbiAgICA7XG5cbiAgICBEaXNwbGF5T2JqZWN0LnByb3RvdHlwZS5yZW5kZXJDYW52YXMgPSBmdW5jdGlvbiByZW5kZXJDYW52YXMocmVuZGVyZXIpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICB7fVxuICAgIC8vIE9WRVJXUklURTtcblxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBwYXJlbnQgQ29udGFpbmVyIG9mIHRoaXMgRGlzcGxheU9iamVjdFxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLkNvbnRhaW5lcn0gY29udGFpbmVyIC0gVGhlIENvbnRhaW5lciB0byBhZGQgdGhpcyBEaXNwbGF5T2JqZWN0IHRvXG4gICAgICogQHJldHVybiB7UElYSS5Db250YWluZXJ9IFRoZSBDb250YWluZXIgdGhhdCB0aGlzIERpc3BsYXlPYmplY3Qgd2FzIGFkZGVkIHRvXG4gICAgICovXG4gICAgO1xuXG4gICAgRGlzcGxheU9iamVjdC5wcm90b3R5cGUuc2V0UGFyZW50ID0gZnVuY3Rpb24gc2V0UGFyZW50KGNvbnRhaW5lcikge1xuICAgICAgICBpZiAoIWNvbnRhaW5lciB8fCAhY29udGFpbmVyLmFkZENoaWxkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFBhcmVudDogQXJndW1lbnQgbXVzdCBiZSBhIENvbnRhaW5lcicpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGFpbmVyLmFkZENoaWxkKHRoaXMpO1xuXG4gICAgICAgIHJldHVybiBjb250YWluZXI7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlbmllbmNlIGZ1bmN0aW9uIHRvIHNldCB0aGUgcG9zaXRpb24sIHNjYWxlLCBza2V3IGFuZCBwaXZvdCBhdCBvbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt4PTBdIC0gVGhlIFggcG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3k9MF0gLSBUaGUgWSBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc2NhbGVYPTFdIC0gVGhlIFggc2NhbGUgdmFsdWVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3NjYWxlWT0xXSAtIFRoZSBZIHNjYWxlIHZhbHVlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtyb3RhdGlvbj0wXSAtIFRoZSByb3RhdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc2tld1g9MF0gLSBUaGUgWCBza2V3IHZhbHVlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtza2V3WT0wXSAtIFRoZSBZIHNrZXcgdmFsdWVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3Bpdm90WD0wXSAtIFRoZSBYIHBpdm90IHZhbHVlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwaXZvdFk9MF0gLSBUaGUgWSBwaXZvdCB2YWx1ZVxuICAgICAqIEByZXR1cm4ge1BJWEkuRGlzcGxheU9iamVjdH0gVGhlIERpc3BsYXlPYmplY3QgaW5zdGFuY2VcbiAgICAgKi9cblxuXG4gICAgRGlzcGxheU9iamVjdC5wcm90b3R5cGUuc2V0VHJhbnNmb3JtID0gZnVuY3Rpb24gc2V0VHJhbnNmb3JtKCkge1xuICAgICAgICB2YXIgeCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMDtcbiAgICAgICAgdmFyIHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG4gICAgICAgIHZhciBzY2FsZVggPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDE7XG4gICAgICAgIHZhciBzY2FsZVkgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IDE7XG4gICAgICAgIHZhciByb3RhdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogMDtcbiAgICAgICAgdmFyIHNrZXdYID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiAwO1xuICAgICAgICB2YXIgc2tld1kgPSBhcmd1bWVudHMubGVuZ3RoID4gNiAmJiBhcmd1bWVudHNbNl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s2XSA6IDA7XG4gICAgICAgIHZhciBwaXZvdFggPSBhcmd1bWVudHMubGVuZ3RoID4gNyAmJiBhcmd1bWVudHNbN10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s3XSA6IDA7XG4gICAgICAgIHZhciBwaXZvdFkgPSBhcmd1bWVudHMubGVuZ3RoID4gOCAmJiBhcmd1bWVudHNbOF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s4XSA6IDA7XG5cbiAgICAgICAgdGhpcy5wb3NpdGlvbi54ID0geDtcbiAgICAgICAgdGhpcy5wb3NpdGlvbi55ID0geTtcbiAgICAgICAgdGhpcy5zY2FsZS54ID0gIXNjYWxlWCA/IDEgOiBzY2FsZVg7XG4gICAgICAgIHRoaXMuc2NhbGUueSA9ICFzY2FsZVkgPyAxIDogc2NhbGVZO1xuICAgICAgICB0aGlzLnJvdGF0aW9uID0gcm90YXRpb247XG4gICAgICAgIHRoaXMuc2tldy54ID0gc2tld1g7XG4gICAgICAgIHRoaXMuc2tldy55ID0gc2tld1k7XG4gICAgICAgIHRoaXMucGl2b3QueCA9IHBpdm90WDtcbiAgICAgICAgdGhpcy5waXZvdC55ID0gcGl2b3RZO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBCYXNlIGRlc3Ryb3kgbWV0aG9kIGZvciBnZW5lcmljIGRpc3BsYXkgb2JqZWN0cy4gVGhpcyB3aWxsIGF1dG9tYXRpY2FsbHlcbiAgICAgKiByZW1vdmUgdGhlIGRpc3BsYXkgb2JqZWN0IGZyb20gaXRzIHBhcmVudCBDb250YWluZXIgYXMgd2VsbCBhcyByZW1vdmVcbiAgICAgKiBhbGwgY3VycmVudCBldmVudCBsaXN0ZW5lcnMgYW5kIGludGVybmFsIHJlZmVyZW5jZXMuIERvIG5vdCB1c2UgYSBEaXNwbGF5T2JqZWN0XG4gICAgICogYWZ0ZXIgY2FsbGluZyBgZGVzdHJveWAuXG4gICAgICpcbiAgICAgKi9cblxuXG4gICAgRGlzcGxheU9iamVjdC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQucmVtb3ZlQ2hpbGQodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cmFuc2Zvcm0gPSBudWxsO1xuXG4gICAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcblxuICAgICAgICB0aGlzLl9ib3VuZHMgPSBudWxsO1xuICAgICAgICB0aGlzLl9jdXJyZW50Qm91bmRzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbWFzayA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5maWx0ZXJBcmVhID0gbnVsbDtcblxuICAgICAgICB0aGlzLmludGVyYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaW50ZXJhY3RpdmVDaGlsZHJlbiA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuX2Rlc3Ryb3llZCA9IHRydWU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBwb3NpdGlvbiBvZiB0aGUgZGlzcGxheU9iamVjdCBvbiB0aGUgeCBheGlzIHJlbGF0aXZlIHRvIHRoZSBsb2NhbCBjb29yZGluYXRlcyBvZiB0aGUgcGFyZW50LlxuICAgICAqIEFuIGFsaWFzIHRvIHBvc2l0aW9uLnhcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKi9cblxuXG4gICAgX2NyZWF0ZUNsYXNzKERpc3BsYXlPYmplY3QsIFt7XG4gICAgICAgIGtleTogJ190ZW1wRGlzcGxheU9iamVjdFBhcmVudCcsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudGVtcERpc3BsYXlPYmplY3RQYXJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRlbXBEaXNwbGF5T2JqZWN0UGFyZW50ID0gbmV3IERpc3BsYXlPYmplY3QoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGVtcERpc3BsYXlPYmplY3RQYXJlbnQ7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3gnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9uLng7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlcXVpcmUtanNkb2NcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm0ucG9zaXRpb24ueCA9IHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBwb3NpdGlvbiBvZiB0aGUgZGlzcGxheU9iamVjdCBvbiB0aGUgeSBheGlzIHJlbGF0aXZlIHRvIHRoZSBsb2NhbCBjb29yZGluYXRlcyBvZiB0aGUgcGFyZW50LlxuICAgICAgICAgKiBBbiBhbGlhcyB0byBwb3NpdGlvbi55XG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3knLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9uLnk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlcXVpcmUtanNkb2NcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm0ucG9zaXRpb24ueSA9IHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEN1cnJlbnQgdHJhbnNmb3JtIG9mIHRoZSBvYmplY3QgYmFzZWQgb24gd29ybGQgKHBhcmVudCkgZmFjdG9yc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLk1hdHJpeH1cbiAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICd3b3JsZFRyYW5zZm9ybScsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLndvcmxkVHJhbnNmb3JtO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEN1cnJlbnQgdHJhbnNmb3JtIG9mIHRoZSBvYmplY3QgYmFzZWQgb24gbG9jYWwgZmFjdG9yczogcG9zaXRpb24sIHNjYWxlLCBvdGhlciBzdHVmZlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLk1hdHJpeH1cbiAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdsb2NhbFRyYW5zZm9ybScsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLmxvY2FsVHJhbnNmb3JtO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjb29yZGluYXRlIG9mIHRoZSBvYmplY3QgcmVsYXRpdmUgdG8gdGhlIGxvY2FsIGNvb3JkaW5hdGVzIG9mIHRoZSBwYXJlbnQuXG4gICAgICAgICAqIEFzc2lnbm1lbnQgYnkgdmFsdWUgc2luY2UgcGl4aS12NC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5Qb2ludHxQSVhJLk9ic2VydmFibGVQb2ludH1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3Bvc2l0aW9uJyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0ucG9zaXRpb247XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlcXVpcmUtanNkb2NcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm0ucG9zaXRpb24uY29weSh2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHNjYWxlIGZhY3RvciBvZiB0aGUgb2JqZWN0LlxuICAgICAgICAgKiBBc3NpZ25tZW50IGJ5IHZhbHVlIHNpbmNlIHBpeGktdjQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuUG9pbnR8UElYSS5PYnNlcnZhYmxlUG9pbnR9XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdzY2FsZScsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLnNjYWxlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSByZXF1aXJlLWpzZG9jXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLnNjYWxlLmNvcHkodmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBwaXZvdCBwb2ludCBvZiB0aGUgZGlzcGxheU9iamVjdCB0aGF0IGl0IHJvdGF0ZXMgYXJvdW5kLlxuICAgICAgICAgKiBBc3NpZ25tZW50IGJ5IHZhbHVlIHNpbmNlIHBpeGktdjQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuUG9pbnR8UElYSS5PYnNlcnZhYmxlUG9pbnR9XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdwaXZvdCcsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLnBpdm90O1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSByZXF1aXJlLWpzZG9jXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLnBpdm90LmNvcHkodmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBza2V3IGZhY3RvciBmb3IgdGhlIG9iamVjdCBpbiByYWRpYW5zLlxuICAgICAgICAgKiBBc3NpZ25tZW50IGJ5IHZhbHVlIHNpbmNlIHBpeGktdjQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuT2JzZXJ2YWJsZVBvaW50fVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnc2tldycsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLnNrZXc7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlcXVpcmUtanNkb2NcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm0uc2tldy5jb3B5KHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcm90YXRpb24gb2YgdGhlIG9iamVjdCBpbiByYWRpYW5zLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdyb3RhdGlvbicsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLnJvdGF0aW9uO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSByZXF1aXJlLWpzZG9jXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLnJvdGF0aW9uID0gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogSW5kaWNhdGVzIGlmIHRoZSBvYmplY3QgaXMgZ2xvYmFsbHkgdmlzaWJsZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICd3b3JsZFZpc2libGUnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gdGhpcztcblxuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGlmICghaXRlbS52aXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpdGVtID0gaXRlbS5wYXJlbnQ7XG4gICAgICAgICAgICB9IHdoaWxlIChpdGVtKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyBhIG1hc2sgZm9yIHRoZSBkaXNwbGF5T2JqZWN0LiBBIG1hc2sgaXMgYW4gb2JqZWN0IHRoYXQgbGltaXRzIHRoZSB2aXNpYmlsaXR5IG9mIGFuXG4gICAgICAgICAqIG9iamVjdCB0byB0aGUgc2hhcGUgb2YgdGhlIG1hc2sgYXBwbGllZCB0byBpdC4gSW4gUElYSSBhIHJlZ3VsYXIgbWFzayBtdXN0IGJlIGFcbiAgICAgICAgICogUElYSS5HcmFwaGljcyBvciBhIFBJWEkuU3ByaXRlIG9iamVjdC4gVGhpcyBhbGxvd3MgZm9yIG11Y2ggZmFzdGVyIG1hc2tpbmcgaW4gY2FudmFzIGFzIGl0XG4gICAgICAgICAqIHV0aWxpc2VzIHNoYXBlIGNsaXBwaW5nLiBUbyByZW1vdmUgYSBtYXNrLCBzZXQgdGhpcyBwcm9wZXJ0eSB0byBudWxsLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdG9kbyBGb3IgdGhlIG1vbWVudCwgUElYSS5DYW52YXNSZW5kZXJlciBkb2Vzbid0IHN1cHBvcnQgUElYSS5TcHJpdGUgYXMgbWFzay5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5HcmFwaGljc3xQSVhJLlNwcml0ZX1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ21hc2snLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tYXNrO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSByZXF1aXJlLWpzZG9jXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9tYXNrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWFzay5yZW5kZXJhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXNrLmlzTWFzayA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9tYXNrID0gdmFsdWU7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9tYXNrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWFzay5yZW5kZXJhYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWFzay5pc01hc2sgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIGZpbHRlcnMgZm9yIHRoZSBkaXNwbGF5T2JqZWN0LlxuICAgICAgICAgKiAqIElNUE9SVEFOVDogVGhpcyBpcyBhIHdlYkdMIG9ubHkgZmVhdHVyZSBhbmQgd2lsbCBiZSBpZ25vcmVkIGJ5IHRoZSBjYW52YXMgcmVuZGVyZXIuXG4gICAgICAgICAqIFRvIHJlbW92ZSBmaWx0ZXJzIHNpbXBseSBzZXQgdGhpcyBwcm9wZXJ0eSB0byAnbnVsbCdcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5GaWx0ZXJbXX1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2ZpbHRlcnMnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9maWx0ZXJzICYmIHRoaXMuX2ZpbHRlcnMuc2xpY2UoKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcmVxdWlyZS1qc2RvY1xuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9maWx0ZXJzID0gdmFsdWUgJiYgdmFsdWUuc2xpY2UoKTtcbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBEaXNwbGF5T2JqZWN0O1xufShfZXZlbnRlbWl0dGVyMi5kZWZhdWx0KTtcblxuLy8gcGVyZm9ybWFuY2UgaW5jcmVhc2UgdG8gYXZvaWQgdXNpbmcgY2FsbC4uICgxMHggZmFzdGVyKVxuXG5cbmV4cG9ydHMuZGVmYXVsdCA9IERpc3BsYXlPYmplY3Q7XG5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZS5kaXNwbGF5T2JqZWN0VXBkYXRlVHJhbnNmb3JtID0gRGlzcGxheU9iamVjdC5wcm90b3R5cGUudXBkYXRlVHJhbnNmb3JtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RGlzcGxheU9iamVjdC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfbWF0aCA9IHJlcXVpcmUoJy4uL21hdGgnKTtcblxudmFyIF9UcmFuc2Zvcm1CYXNlMiA9IHJlcXVpcmUoJy4vVHJhbnNmb3JtQmFzZScpO1xuXG52YXIgX1RyYW5zZm9ybUJhc2UzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVHJhbnNmb3JtQmFzZTIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbi8qKlxuICogR2VuZXJpYyBjbGFzcyB0byBkZWFsIHdpdGggdHJhZGl0aW9uYWwgMkQgbWF0cml4IHRyYW5zZm9ybXNcbiAqIGxvY2FsIHRyYW5zZm9ybWF0aW9uIGlzIGNhbGN1bGF0ZWQgZnJvbSBwb3NpdGlvbixzY2FsZSxza2V3IGFuZCByb3RhdGlvblxuICpcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgUElYSS5UcmFuc2Zvcm1CYXNlXG4gKiBAbWVtYmVyb2YgUElYSVxuICovXG52YXIgVHJhbnNmb3JtID0gZnVuY3Rpb24gKF9UcmFuc2Zvcm1CYXNlKSB7XG4gIF9pbmhlcml0cyhUcmFuc2Zvcm0sIF9UcmFuc2Zvcm1CYXNlKTtcblxuICAvKipcbiAgICpcbiAgICovXG4gIGZ1bmN0aW9uIFRyYW5zZm9ybSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVHJhbnNmb3JtKTtcblxuICAgIC8qKlxuICAgICogVGhlIGNvb3JkaW5hdGUgb2YgdGhlIG9iamVjdCByZWxhdGl2ZSB0byB0aGUgbG9jYWwgY29vcmRpbmF0ZXMgb2YgdGhlIHBhcmVudC5cbiAgICAqXG4gICAgKiBAbWVtYmVyIHtQSVhJLlBvaW50fVxuICAgICovXG4gICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1RyYW5zZm9ybUJhc2UuY2FsbCh0aGlzKSk7XG5cbiAgICBfdGhpcy5wb3NpdGlvbiA9IG5ldyBfbWF0aC5Qb2ludCgwLCAwKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzY2FsZSBmYWN0b3Igb2YgdGhlIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge1BJWEkuUG9pbnR9XG4gICAgICovXG4gICAgX3RoaXMuc2NhbGUgPSBuZXcgX21hdGguUG9pbnQoMSwgMSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2tldyBhbW91bnQsIG9uIHRoZSB4IGFuZCB5IGF4aXMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtQSVhJLk9ic2VydmFibGVQb2ludH1cbiAgICAgKi9cbiAgICBfdGhpcy5za2V3ID0gbmV3IF9tYXRoLk9ic2VydmFibGVQb2ludChfdGhpcy51cGRhdGVTa2V3LCBfdGhpcywgMCwgMCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcGl2b3QgcG9pbnQgb2YgdGhlIGRpc3BsYXlPYmplY3QgdGhhdCBpdCByb3RhdGVzIGFyb3VuZC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge1BJWEkuUG9pbnR9XG4gICAgICovXG4gICAgX3RoaXMucGl2b3QgPSBuZXcgX21hdGguUG9pbnQoMCwgMCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcm90YXRpb24gdmFsdWUgb2YgdGhlIG9iamVjdCwgaW4gcmFkaWFuc1xuICAgICAqXG4gICAgICogQG1lbWJlciB7TnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3RoaXMuX3JvdGF0aW9uID0gMDtcblxuICAgIF90aGlzLl9jeCA9IDE7IC8vIGNvcyByb3RhdGlvbiArIHNrZXdZO1xuICAgIF90aGlzLl9zeCA9IDA7IC8vIHNpbiByb3RhdGlvbiArIHNrZXdZO1xuICAgIF90aGlzLl9jeSA9IDA7IC8vIGNvcyByb3RhdGlvbiArIE1hdGguUEkvMiAtIHNrZXdYO1xuICAgIF90aGlzLl9zeSA9IDE7IC8vIHNpbiByb3RhdGlvbiArIE1hdGguUEkvMiAtIHNrZXdYO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBza2V3IHZhbHVlcyB3aGVuIHRoZSBza2V3IG9yIHJvdGF0aW9uIGNoYW5nZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgVHJhbnNmb3JtLnByb3RvdHlwZS51cGRhdGVTa2V3ID0gZnVuY3Rpb24gdXBkYXRlU2tldygpIHtcbiAgICB0aGlzLl9jeCA9IE1hdGguY29zKHRoaXMuX3JvdGF0aW9uICsgdGhpcy5za2V3Ll95KTtcbiAgICB0aGlzLl9zeCA9IE1hdGguc2luKHRoaXMuX3JvdGF0aW9uICsgdGhpcy5za2V3Ll95KTtcbiAgICB0aGlzLl9jeSA9IC1NYXRoLnNpbih0aGlzLl9yb3RhdGlvbiAtIHRoaXMuc2tldy5feCk7IC8vIGNvcywgYWRkZWQgUEkvMlxuICAgIHRoaXMuX3N5ID0gTWF0aC5jb3ModGhpcy5fcm90YXRpb24gLSB0aGlzLnNrZXcuX3gpOyAvLyBzaW4sIGFkZGVkIFBJLzJcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlcyBvbmx5IGxvY2FsIG1hdHJpeFxuICAgKi9cblxuXG4gIFRyYW5zZm9ybS5wcm90b3R5cGUudXBkYXRlTG9jYWxUcmFuc2Zvcm0gPSBmdW5jdGlvbiB1cGRhdGVMb2NhbFRyYW5zZm9ybSgpIHtcbiAgICB2YXIgbHQgPSB0aGlzLmxvY2FsVHJhbnNmb3JtO1xuXG4gICAgbHQuYSA9IHRoaXMuX2N4ICogdGhpcy5zY2FsZS54O1xuICAgIGx0LmIgPSB0aGlzLl9zeCAqIHRoaXMuc2NhbGUueDtcbiAgICBsdC5jID0gdGhpcy5fY3kgKiB0aGlzLnNjYWxlLnk7XG4gICAgbHQuZCA9IHRoaXMuX3N5ICogdGhpcy5zY2FsZS55O1xuXG4gICAgbHQudHggPSB0aGlzLnBvc2l0aW9uLnggLSAodGhpcy5waXZvdC54ICogbHQuYSArIHRoaXMucGl2b3QueSAqIGx0LmMpO1xuICAgIGx0LnR5ID0gdGhpcy5wb3NpdGlvbi55IC0gKHRoaXMucGl2b3QueCAqIGx0LmIgKyB0aGlzLnBpdm90LnkgKiBsdC5kKTtcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgdmFsdWVzIG9mIHRoZSBvYmplY3QgYW5kIGFwcGxpZXMgdGhlIHBhcmVudCdzIHRyYW5zZm9ybS5cbiAgICpcbiAgICogQHBhcmFtIHtQSVhJLlRyYW5zZm9ybX0gcGFyZW50VHJhbnNmb3JtIC0gVGhlIHRyYW5zZm9ybSBvZiB0aGUgcGFyZW50IG9mIHRoaXMgb2JqZWN0XG4gICAqL1xuXG5cbiAgVHJhbnNmb3JtLnByb3RvdHlwZS51cGRhdGVUcmFuc2Zvcm0gPSBmdW5jdGlvbiB1cGRhdGVUcmFuc2Zvcm0ocGFyZW50VHJhbnNmb3JtKSB7XG4gICAgdmFyIGx0ID0gdGhpcy5sb2NhbFRyYW5zZm9ybTtcblxuICAgIGx0LmEgPSB0aGlzLl9jeCAqIHRoaXMuc2NhbGUueDtcbiAgICBsdC5iID0gdGhpcy5fc3ggKiB0aGlzLnNjYWxlLng7XG4gICAgbHQuYyA9IHRoaXMuX2N5ICogdGhpcy5zY2FsZS55O1xuICAgIGx0LmQgPSB0aGlzLl9zeSAqIHRoaXMuc2NhbGUueTtcblxuICAgIGx0LnR4ID0gdGhpcy5wb3NpdGlvbi54IC0gKHRoaXMucGl2b3QueCAqIGx0LmEgKyB0aGlzLnBpdm90LnkgKiBsdC5jKTtcbiAgICBsdC50eSA9IHRoaXMucG9zaXRpb24ueSAtICh0aGlzLnBpdm90LnggKiBsdC5iICsgdGhpcy5waXZvdC55ICogbHQuZCk7XG5cbiAgICAvLyBjb25jYXQgdGhlIHBhcmVudCBtYXRyaXggd2l0aCB0aGUgb2JqZWN0cyB0cmFuc2Zvcm0uXG4gICAgdmFyIHB0ID0gcGFyZW50VHJhbnNmb3JtLndvcmxkVHJhbnNmb3JtO1xuICAgIHZhciB3dCA9IHRoaXMud29ybGRUcmFuc2Zvcm07XG5cbiAgICB3dC5hID0gbHQuYSAqIHB0LmEgKyBsdC5iICogcHQuYztcbiAgICB3dC5iID0gbHQuYSAqIHB0LmIgKyBsdC5iICogcHQuZDtcbiAgICB3dC5jID0gbHQuYyAqIHB0LmEgKyBsdC5kICogcHQuYztcbiAgICB3dC5kID0gbHQuYyAqIHB0LmIgKyBsdC5kICogcHQuZDtcbiAgICB3dC50eCA9IGx0LnR4ICogcHQuYSArIGx0LnR5ICogcHQuYyArIHB0LnR4O1xuICAgIHd0LnR5ID0gbHQudHggKiBwdC5iICsgbHQudHkgKiBwdC5kICsgcHQudHk7XG5cbiAgICB0aGlzLl93b3JsZElEKys7XG4gIH07XG5cbiAgLyoqXG4gICAqIERlY29tcG9zZXMgYSBtYXRyaXggYW5kIHNldHMgdGhlIHRyYW5zZm9ybXMgcHJvcGVydGllcyBiYXNlZCBvbiBpdC5cbiAgICpcbiAgICogQHBhcmFtIHtQSVhJLk1hdHJpeH0gbWF0cml4IC0gVGhlIG1hdHJpeCB0byBkZWNvbXBvc2VcbiAgICovXG5cblxuICBUcmFuc2Zvcm0ucHJvdG90eXBlLnNldEZyb21NYXRyaXggPSBmdW5jdGlvbiBzZXRGcm9tTWF0cml4KG1hdHJpeCkge1xuICAgIG1hdHJpeC5kZWNvbXBvc2UodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoZSByb3RhdGlvbiBvZiB0aGUgb2JqZWN0IGluIHJhZGlhbnMuXG4gICAqXG4gICAqIEBtZW1iZXIge251bWJlcn1cbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoVHJhbnNmb3JtLCBbe1xuICAgIGtleTogJ3JvdGF0aW9uJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yb3RhdGlvbjtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlcXVpcmUtanNkb2NcbiAgICB7XG4gICAgICB0aGlzLl9yb3RhdGlvbiA9IHZhbHVlO1xuICAgICAgdGhpcy51cGRhdGVTa2V3KCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFRyYW5zZm9ybTtcbn0oX1RyYW5zZm9ybUJhc2UzLmRlZmF1bHQpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBUcmFuc2Zvcm07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UcmFuc2Zvcm0uanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX21hdGggPSByZXF1aXJlKCcuLi9tYXRoJyk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8qKlxuICogR2VuZXJpYyBjbGFzcyB0byBkZWFsIHdpdGggdHJhZGl0aW9uYWwgMkQgbWF0cml4IHRyYW5zZm9ybXNcbiAqXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKi9cbnZhciBUcmFuc2Zvcm1CYXNlID0gZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICpcbiAgICovXG4gIGZ1bmN0aW9uIFRyYW5zZm9ybUJhc2UoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRyYW5zZm9ybUJhc2UpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGdsb2JhbCBtYXRyaXggdHJhbnNmb3JtLiBJdCBjYW4gYmUgc3dhcHBlZCB0ZW1wb3JhcmlseSBieSBzb21lIGZ1bmN0aW9ucyBsaWtlIGdldExvY2FsQm91bmRzKClcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge1BJWEkuTWF0cml4fVxuICAgICAqL1xuICAgIHRoaXMud29ybGRUcmFuc2Zvcm0gPSBuZXcgX21hdGguTWF0cml4KCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbG9jYWwgbWF0cml4IHRyYW5zZm9ybVxuICAgICAqXG4gICAgICogQG1lbWJlciB7UElYSS5NYXRyaXh9XG4gICAgICovXG4gICAgdGhpcy5sb2NhbFRyYW5zZm9ybSA9IG5ldyBfbWF0aC5NYXRyaXgoKTtcblxuICAgIHRoaXMuX3dvcmxkSUQgPSAwO1xuICAgIHRoaXMuX3BhcmVudElEID0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFuc2Zvcm1CYXNlIGRvZXMgbm90IGhhdmUgZGVjb21wb3NpdGlvbiwgc28gdGhpcyBmdW5jdGlvbiB3b250IGRvIGFueXRoaW5nXG4gICAqL1xuXG5cbiAgVHJhbnNmb3JtQmFzZS5wcm90b3R5cGUudXBkYXRlTG9jYWxUcmFuc2Zvcm0gPSBmdW5jdGlvbiB1cGRhdGVMb2NhbFRyYW5zZm9ybSgpIHt9XG4gIC8vIGVtcHR5XG5cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgdmFsdWVzIG9mIHRoZSBvYmplY3QgYW5kIGFwcGxpZXMgdGhlIHBhcmVudCdzIHRyYW5zZm9ybS5cbiAgICpcbiAgICogQHBhcmFtIHtQSVhJLlRyYW5zZm9ybUJhc2V9IHBhcmVudFRyYW5zZm9ybSAtIFRoZSB0cmFuc2Zvcm0gb2YgdGhlIHBhcmVudCBvZiB0aGlzIG9iamVjdFxuICAgKi9cbiAgO1xuXG4gIFRyYW5zZm9ybUJhc2UucHJvdG90eXBlLnVwZGF0ZVRyYW5zZm9ybSA9IGZ1bmN0aW9uIHVwZGF0ZVRyYW5zZm9ybShwYXJlbnRUcmFuc2Zvcm0pIHtcbiAgICB2YXIgcHQgPSBwYXJlbnRUcmFuc2Zvcm0ud29ybGRUcmFuc2Zvcm07XG4gICAgdmFyIHd0ID0gdGhpcy53b3JsZFRyYW5zZm9ybTtcbiAgICB2YXIgbHQgPSB0aGlzLmxvY2FsVHJhbnNmb3JtO1xuXG4gICAgLy8gY29uY2F0IHRoZSBwYXJlbnQgbWF0cml4IHdpdGggdGhlIG9iamVjdHMgdHJhbnNmb3JtLlxuICAgIHd0LmEgPSBsdC5hICogcHQuYSArIGx0LmIgKiBwdC5jO1xuICAgIHd0LmIgPSBsdC5hICogcHQuYiArIGx0LmIgKiBwdC5kO1xuICAgIHd0LmMgPSBsdC5jICogcHQuYSArIGx0LmQgKiBwdC5jO1xuICAgIHd0LmQgPSBsdC5jICogcHQuYiArIGx0LmQgKiBwdC5kO1xuICAgIHd0LnR4ID0gbHQudHggKiBwdC5hICsgbHQudHkgKiBwdC5jICsgcHQudHg7XG4gICAgd3QudHkgPSBsdC50eCAqIHB0LmIgKyBsdC50eSAqIHB0LmQgKyBwdC50eTtcblxuICAgIHRoaXMuX3dvcmxkSUQrKztcbiAgfTtcblxuICByZXR1cm4gVHJhbnNmb3JtQmFzZTtcbn0oKTtcblxuLyoqXG4gKiBVcGRhdGVzIHRoZSB2YWx1ZXMgb2YgdGhlIG9iamVjdCBhbmQgYXBwbGllcyB0aGUgcGFyZW50J3MgdHJhbnNmb3JtLlxuICogQHBhcmFtICBwYXJlbnRUcmFuc2Zvcm0ge1BJWEkuVHJhbnNmb3JtfSBUaGUgdHJhbnNmb3JtIG9mIHRoZSBwYXJlbnQgb2YgdGhpcyBvYmplY3RcbiAqXG4gKi9cblxuXG5leHBvcnRzLmRlZmF1bHQgPSBUcmFuc2Zvcm1CYXNlO1xuVHJhbnNmb3JtQmFzZS5wcm90b3R5cGUudXBkYXRlV29ybGRUcmFuc2Zvcm0gPSBUcmFuc2Zvcm1CYXNlLnByb3RvdHlwZS51cGRhdGVUcmFuc2Zvcm07XG5cblRyYW5zZm9ybUJhc2UuSURFTlRJVFkgPSBuZXcgVHJhbnNmb3JtQmFzZSgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VHJhbnNmb3JtQmFzZS5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfbWF0aCA9IHJlcXVpcmUoJy4uL21hdGgnKTtcblxudmFyIF9UcmFuc2Zvcm1CYXNlMiA9IHJlcXVpcmUoJy4vVHJhbnNmb3JtQmFzZScpO1xuXG52YXIgX1RyYW5zZm9ybUJhc2UzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVHJhbnNmb3JtQmFzZTIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbi8qKlxuICogVHJhbnNmb3JtIHRoYXQgdGFrZXMgY2FyZSBhYm91dCBpdHMgdmVyc2lvbnNcbiAqXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIFBJWEkuVHJhbnNmb3JtQmFzZVxuICogQG1lbWJlcm9mIFBJWElcbiAqL1xudmFyIFRyYW5zZm9ybVN0YXRpYyA9IGZ1bmN0aW9uIChfVHJhbnNmb3JtQmFzZSkge1xuICAgIF9pbmhlcml0cyhUcmFuc2Zvcm1TdGF0aWMsIF9UcmFuc2Zvcm1CYXNlKTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgZnVuY3Rpb24gVHJhbnNmb3JtU3RhdGljKCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVHJhbnNmb3JtU3RhdGljKTtcblxuICAgICAgICAvKipcbiAgICAgICAgKiBUaGUgY29vcmRpbmF0ZSBvZiB0aGUgb2JqZWN0IHJlbGF0aXZlIHRvIHRoZSBsb2NhbCBjb29yZGluYXRlcyBvZiB0aGUgcGFyZW50LlxuICAgICAgICAqXG4gICAgICAgICogQG1lbWJlciB7UElYSS5PYnNlcnZhYmxlUG9pbnR9XG4gICAgICAgICovXG4gICAgICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9UcmFuc2Zvcm1CYXNlLmNhbGwodGhpcykpO1xuXG4gICAgICAgIF90aGlzLnBvc2l0aW9uID0gbmV3IF9tYXRoLk9ic2VydmFibGVQb2ludChfdGhpcy5vbkNoYW5nZSwgX3RoaXMsIDAsIDApO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgc2NhbGUgZmFjdG9yIG9mIHRoZSBvYmplY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuT2JzZXJ2YWJsZVBvaW50fVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuc2NhbGUgPSBuZXcgX21hdGguT2JzZXJ2YWJsZVBvaW50KF90aGlzLm9uQ2hhbmdlLCBfdGhpcywgMSwgMSk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBwaXZvdCBwb2ludCBvZiB0aGUgZGlzcGxheU9iamVjdCB0aGF0IGl0IHJvdGF0ZXMgYXJvdW5kLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLk9ic2VydmFibGVQb2ludH1cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLnBpdm90ID0gbmV3IF9tYXRoLk9ic2VydmFibGVQb2ludChfdGhpcy5vbkNoYW5nZSwgX3RoaXMsIDAsIDApO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgc2tldyBhbW91bnQsIG9uIHRoZSB4IGFuZCB5IGF4aXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuT2JzZXJ2YWJsZVBvaW50fVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuc2tldyA9IG5ldyBfbWF0aC5PYnNlcnZhYmxlUG9pbnQoX3RoaXMudXBkYXRlU2tldywgX3RoaXMsIDAsIDApO1xuXG4gICAgICAgIF90aGlzLl9yb3RhdGlvbiA9IDA7XG5cbiAgICAgICAgX3RoaXMuX2N4ID0gMTsgLy8gY29zIHJvdGF0aW9uICsgc2tld1k7XG4gICAgICAgIF90aGlzLl9zeCA9IDA7IC8vIHNpbiByb3RhdGlvbiArIHNrZXdZO1xuICAgICAgICBfdGhpcy5fY3kgPSAwOyAvLyBjb3Mgcm90YXRpb24gKyBNYXRoLlBJLzIgLSBza2V3WDtcbiAgICAgICAgX3RoaXMuX3N5ID0gMTsgLy8gc2luIHJvdGF0aW9uICsgTWF0aC5QSS8yIC0gc2tld1g7XG5cbiAgICAgICAgX3RoaXMuX2xvY2FsSUQgPSAwO1xuICAgICAgICBfdGhpcy5fY3VycmVudExvY2FsSUQgPSAwO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gYSB2YWx1ZSBjaGFuZ2VzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuXG4gICAgVHJhbnNmb3JtU3RhdGljLnByb3RvdHlwZS5vbkNoYW5nZSA9IGZ1bmN0aW9uIG9uQ2hhbmdlKCkge1xuICAgICAgICB0aGlzLl9sb2NhbElEKys7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIHNrZXcgb3Igcm90YXRpb24gY2hhbmdlc1xuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuXG4gICAgVHJhbnNmb3JtU3RhdGljLnByb3RvdHlwZS51cGRhdGVTa2V3ID0gZnVuY3Rpb24gdXBkYXRlU2tldygpIHtcbiAgICAgICAgdGhpcy5fY3ggPSBNYXRoLmNvcyh0aGlzLl9yb3RhdGlvbiArIHRoaXMuc2tldy5feSk7XG4gICAgICAgIHRoaXMuX3N4ID0gTWF0aC5zaW4odGhpcy5fcm90YXRpb24gKyB0aGlzLnNrZXcuX3kpO1xuICAgICAgICB0aGlzLl9jeSA9IC1NYXRoLnNpbih0aGlzLl9yb3RhdGlvbiAtIHRoaXMuc2tldy5feCk7IC8vIGNvcywgYWRkZWQgUEkvMlxuICAgICAgICB0aGlzLl9zeSA9IE1hdGguY29zKHRoaXMuX3JvdGF0aW9uIC0gdGhpcy5za2V3Ll94KTsgLy8gc2luLCBhZGRlZCBQSS8yXG5cbiAgICAgICAgdGhpcy5fbG9jYWxJRCsrO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIG9ubHkgbG9jYWwgbWF0cml4XG4gICAgICovXG5cblxuICAgIFRyYW5zZm9ybVN0YXRpYy5wcm90b3R5cGUudXBkYXRlTG9jYWxUcmFuc2Zvcm0gPSBmdW5jdGlvbiB1cGRhdGVMb2NhbFRyYW5zZm9ybSgpIHtcbiAgICAgICAgdmFyIGx0ID0gdGhpcy5sb2NhbFRyYW5zZm9ybTtcblxuICAgICAgICBpZiAodGhpcy5fbG9jYWxJRCAhPT0gdGhpcy5fY3VycmVudExvY2FsSUQpIHtcbiAgICAgICAgICAgIC8vIGdldCB0aGUgbWF0cml4IHZhbHVlcyBvZiB0aGUgZGlzcGxheW9iamVjdCBiYXNlZCBvbiBpdHMgdHJhbnNmb3JtIHByb3BlcnRpZXMuLlxuICAgICAgICAgICAgbHQuYSA9IHRoaXMuX2N4ICogdGhpcy5zY2FsZS5feDtcbiAgICAgICAgICAgIGx0LmIgPSB0aGlzLl9zeCAqIHRoaXMuc2NhbGUuX3g7XG4gICAgICAgICAgICBsdC5jID0gdGhpcy5fY3kgKiB0aGlzLnNjYWxlLl95O1xuICAgICAgICAgICAgbHQuZCA9IHRoaXMuX3N5ICogdGhpcy5zY2FsZS5feTtcblxuICAgICAgICAgICAgbHQudHggPSB0aGlzLnBvc2l0aW9uLl94IC0gKHRoaXMucGl2b3QuX3ggKiBsdC5hICsgdGhpcy5waXZvdC5feSAqIGx0LmMpO1xuICAgICAgICAgICAgbHQudHkgPSB0aGlzLnBvc2l0aW9uLl95IC0gKHRoaXMucGl2b3QuX3ggKiBsdC5iICsgdGhpcy5waXZvdC5feSAqIGx0LmQpO1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudExvY2FsSUQgPSB0aGlzLl9sb2NhbElEO1xuXG4gICAgICAgICAgICAvLyBmb3JjZSBhbiB1cGRhdGUuLlxuICAgICAgICAgICAgdGhpcy5fcGFyZW50SUQgPSAtMTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSB2YWx1ZXMgb2YgdGhlIG9iamVjdCBhbmQgYXBwbGllcyB0aGUgcGFyZW50J3MgdHJhbnNmb3JtLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLlRyYW5zZm9ybX0gcGFyZW50VHJhbnNmb3JtIC0gVGhlIHRyYW5zZm9ybSBvZiB0aGUgcGFyZW50IG9mIHRoaXMgb2JqZWN0XG4gICAgICovXG5cblxuICAgIFRyYW5zZm9ybVN0YXRpYy5wcm90b3R5cGUudXBkYXRlVHJhbnNmb3JtID0gZnVuY3Rpb24gdXBkYXRlVHJhbnNmb3JtKHBhcmVudFRyYW5zZm9ybSkge1xuICAgICAgICB2YXIgbHQgPSB0aGlzLmxvY2FsVHJhbnNmb3JtO1xuXG4gICAgICAgIGlmICh0aGlzLl9sb2NhbElEICE9PSB0aGlzLl9jdXJyZW50TG9jYWxJRCkge1xuICAgICAgICAgICAgLy8gZ2V0IHRoZSBtYXRyaXggdmFsdWVzIG9mIHRoZSBkaXNwbGF5b2JqZWN0IGJhc2VkIG9uIGl0cyB0cmFuc2Zvcm0gcHJvcGVydGllcy4uXG4gICAgICAgICAgICBsdC5hID0gdGhpcy5fY3ggKiB0aGlzLnNjYWxlLl94O1xuICAgICAgICAgICAgbHQuYiA9IHRoaXMuX3N4ICogdGhpcy5zY2FsZS5feDtcbiAgICAgICAgICAgIGx0LmMgPSB0aGlzLl9jeSAqIHRoaXMuc2NhbGUuX3k7XG4gICAgICAgICAgICBsdC5kID0gdGhpcy5fc3kgKiB0aGlzLnNjYWxlLl95O1xuXG4gICAgICAgICAgICBsdC50eCA9IHRoaXMucG9zaXRpb24uX3ggLSAodGhpcy5waXZvdC5feCAqIGx0LmEgKyB0aGlzLnBpdm90Ll95ICogbHQuYyk7XG4gICAgICAgICAgICBsdC50eSA9IHRoaXMucG9zaXRpb24uX3kgLSAodGhpcy5waXZvdC5feCAqIGx0LmIgKyB0aGlzLnBpdm90Ll95ICogbHQuZCk7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50TG9jYWxJRCA9IHRoaXMuX2xvY2FsSUQ7XG5cbiAgICAgICAgICAgIC8vIGZvcmNlIGFuIHVwZGF0ZS4uXG4gICAgICAgICAgICB0aGlzLl9wYXJlbnRJRCA9IC0xO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX3BhcmVudElEICE9PSBwYXJlbnRUcmFuc2Zvcm0uX3dvcmxkSUQpIHtcbiAgICAgICAgICAgIC8vIGNvbmNhdCB0aGUgcGFyZW50IG1hdHJpeCB3aXRoIHRoZSBvYmplY3RzIHRyYW5zZm9ybS5cbiAgICAgICAgICAgIHZhciBwdCA9IHBhcmVudFRyYW5zZm9ybS53b3JsZFRyYW5zZm9ybTtcbiAgICAgICAgICAgIHZhciB3dCA9IHRoaXMud29ybGRUcmFuc2Zvcm07XG5cbiAgICAgICAgICAgIHd0LmEgPSBsdC5hICogcHQuYSArIGx0LmIgKiBwdC5jO1xuICAgICAgICAgICAgd3QuYiA9IGx0LmEgKiBwdC5iICsgbHQuYiAqIHB0LmQ7XG4gICAgICAgICAgICB3dC5jID0gbHQuYyAqIHB0LmEgKyBsdC5kICogcHQuYztcbiAgICAgICAgICAgIHd0LmQgPSBsdC5jICogcHQuYiArIGx0LmQgKiBwdC5kO1xuICAgICAgICAgICAgd3QudHggPSBsdC50eCAqIHB0LmEgKyBsdC50eSAqIHB0LmMgKyBwdC50eDtcbiAgICAgICAgICAgIHd0LnR5ID0gbHQudHggKiBwdC5iICsgbHQudHkgKiBwdC5kICsgcHQudHk7XG5cbiAgICAgICAgICAgIHRoaXMuX3BhcmVudElEID0gcGFyZW50VHJhbnNmb3JtLl93b3JsZElEO1xuXG4gICAgICAgICAgICAvLyB1cGRhdGUgdGhlIGlkIG9mIHRoZSB0cmFuc2Zvcm0uLlxuICAgICAgICAgICAgdGhpcy5fd29ybGRJRCsrO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERlY29tcG9zZXMgYSBtYXRyaXggYW5kIHNldHMgdGhlIHRyYW5zZm9ybXMgcHJvcGVydGllcyBiYXNlZCBvbiBpdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5NYXRyaXh9IG1hdHJpeCAtIFRoZSBtYXRyaXggdG8gZGVjb21wb3NlXG4gICAgICovXG5cblxuICAgIFRyYW5zZm9ybVN0YXRpYy5wcm90b3R5cGUuc2V0RnJvbU1hdHJpeCA9IGZ1bmN0aW9uIHNldEZyb21NYXRyaXgobWF0cml4KSB7XG4gICAgICAgIG1hdHJpeC5kZWNvbXBvc2UodGhpcyk7XG4gICAgICAgIHRoaXMuX2xvY2FsSUQrKztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIHJvdGF0aW9uIG9mIHRoZSBvYmplY3QgaW4gcmFkaWFucy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKi9cblxuXG4gICAgX2NyZWF0ZUNsYXNzKFRyYW5zZm9ybVN0YXRpYywgW3tcbiAgICAgICAga2V5OiAncm90YXRpb24nLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yb3RhdGlvbjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcmVxdWlyZS1qc2RvY1xuICAgICAgICB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcm90YXRpb24gIT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcm90YXRpb24gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVNrZXcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBUcmFuc2Zvcm1TdGF0aWM7XG59KF9UcmFuc2Zvcm1CYXNlMy5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gVHJhbnNmb3JtU3RhdGljO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VHJhbnNmb3JtU3RhdGljLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9Db250YWluZXIyID0gcmVxdWlyZSgnLi4vZGlzcGxheS9Db250YWluZXInKTtcblxudmFyIF9Db250YWluZXIzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQ29udGFpbmVyMik7XG5cbnZhciBfUmVuZGVyVGV4dHVyZSA9IHJlcXVpcmUoJy4uL3RleHR1cmVzL1JlbmRlclRleHR1cmUnKTtcblxudmFyIF9SZW5kZXJUZXh0dXJlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1JlbmRlclRleHR1cmUpO1xuXG52YXIgX1RleHR1cmUgPSByZXF1aXJlKCcuLi90ZXh0dXJlcy9UZXh0dXJlJyk7XG5cbnZhciBfVGV4dHVyZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9UZXh0dXJlKTtcblxudmFyIF9HcmFwaGljc0RhdGEgPSByZXF1aXJlKCcuL0dyYXBoaWNzRGF0YScpO1xuXG52YXIgX0dyYXBoaWNzRGF0YTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9HcmFwaGljc0RhdGEpO1xuXG52YXIgX1Nwcml0ZSA9IHJlcXVpcmUoJy4uL3Nwcml0ZXMvU3ByaXRlJyk7XG5cbnZhciBfU3ByaXRlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1Nwcml0ZSk7XG5cbnZhciBfbWF0aCA9IHJlcXVpcmUoJy4uL21hdGgnKTtcblxudmFyIF91dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbnZhciBfY29uc3QgPSByZXF1aXJlKCcuLi9jb25zdCcpO1xuXG52YXIgX0JvdW5kcyA9IHJlcXVpcmUoJy4uL2Rpc3BsYXkvQm91bmRzJyk7XG5cbnZhciBfQm91bmRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0JvdW5kcyk7XG5cbnZhciBfYmV6aWVyQ3VydmVUbzIgPSByZXF1aXJlKCcuL3V0aWxzL2JlemllckN1cnZlVG8nKTtcblxudmFyIF9iZXppZXJDdXJ2ZVRvMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2JlemllckN1cnZlVG8yKTtcblxudmFyIF9DYW52YXNSZW5kZXJlciA9IHJlcXVpcmUoJy4uL3JlbmRlcmVycy9jYW52YXMvQ2FudmFzUmVuZGVyZXInKTtcblxudmFyIF9DYW52YXNSZW5kZXJlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9DYW52YXNSZW5kZXJlcik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIGNhbnZhc1JlbmRlcmVyID0gdm9pZCAwO1xudmFyIHRlbXBNYXRyaXggPSBuZXcgX21hdGguTWF0cml4KCk7XG52YXIgdGVtcFBvaW50ID0gbmV3IF9tYXRoLlBvaW50KCk7XG52YXIgdGVtcENvbG9yMSA9IG5ldyBGbG9hdDMyQXJyYXkoNCk7XG52YXIgdGVtcENvbG9yMiA9IG5ldyBGbG9hdDMyQXJyYXkoNCk7XG5cbi8qKlxuICogVGhlIEdyYXBoaWNzIGNsYXNzIGNvbnRhaW5zIG1ldGhvZHMgdXNlZCB0byBkcmF3IHByaW1pdGl2ZSBzaGFwZXMgc3VjaCBhcyBsaW5lcywgY2lyY2xlcyBhbmRcbiAqIHJlY3RhbmdsZXMgdG8gdGhlIGRpc3BsYXksIGFuZCB0byBjb2xvciBhbmQgZmlsbCB0aGVtLlxuICpcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgUElYSS5Db250YWluZXJcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKi9cblxudmFyIEdyYXBoaWNzID0gZnVuY3Rpb24gKF9Db250YWluZXIpIHtcbiAgICBfaW5oZXJpdHMoR3JhcGhpY3MsIF9Db250YWluZXIpO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtuYXRpdmVMaW5lcz1mYWxzZV0gLSBJZiB0cnVlIHRoZSBsaW5lcyB3aWxsIGJlIGRyYXcgdXNpbmcgTElORVMgaW5zdGVhZCBvZiBUUklBTkdMRV9TVFJJUFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEdyYXBoaWNzKCkge1xuICAgICAgICB2YXIgbmF0aXZlTGluZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuXG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBHcmFwaGljcyk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBhbHBoYSB2YWx1ZSB1c2VkIHdoZW4gZmlsbGluZyB0aGUgR3JhcGhpY3Mgb2JqZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDFcbiAgICAgICAgICovXG4gICAgICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db250YWluZXIuY2FsbCh0aGlzKSk7XG5cbiAgICAgICAgX3RoaXMuZmlsbEFscGhhID0gMTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHdpZHRoICh0aGlja25lc3MpIG9mIGFueSBsaW5lcyBkcmF3bi5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAwXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5saW5lV2lkdGggPSAwO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0cnVlIHRoZSBsaW5lcyB3aWxsIGJlIGRyYXcgdXNpbmcgTElORVMgaW5zdGVhZCBvZiBUUklBTkdMRV9TVFJJUFxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMubmF0aXZlTGluZXMgPSBuYXRpdmVMaW5lcztcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNvbG9yIG9mIGFueSBsaW5lcyBkcmF3bi5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAwXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5saW5lQ29sb3IgPSAwO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYWxpZ25tZW50IG9mIGFueSBsaW5lcyBkcmF3biAoMC41ID0gbWlkZGxlLCAxID0gb3V0dGVyLCAwID0gaW5uZXIpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDAuNVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMubGluZUFsaWdubWVudCA9IDAuNTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogR3JhcGhpY3MgZGF0YVxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLkdyYXBoaWNzRGF0YVtdfVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuZ3JhcGhpY3NEYXRhID0gW107XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0aW50IGFwcGxpZWQgdG8gdGhlIGdyYXBoaWMgc2hhcGUuIFRoaXMgaXMgYSBoZXggdmFsdWUuIEFwcGx5IGEgdmFsdWUgb2YgMHhGRkZGRkYgdG9cbiAgICAgICAgICogcmVzZXQgdGhlIHRpbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMHhGRkZGRkZcbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLnRpbnQgPSAweEZGRkZGRjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHByZXZpb3VzIHRpbnQgYXBwbGllZCB0byB0aGUgZ3JhcGhpYyBzaGFwZS4gVXNlZCB0byBjb21wYXJlIHRvIHRoZSBjdXJyZW50IHRpbnQgYW5kXG4gICAgICAgICAqIGNoZWNrIGlmIHRoZXJlcyBjaGFuZ2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQGRlZmF1bHQgMHhGRkZGRkZcbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLl9wcmV2VGludCA9IDB4RkZGRkZGO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYmxlbmQgbW9kZSB0byBiZSBhcHBsaWVkIHRvIHRoZSBncmFwaGljIHNoYXBlLiBBcHBseSBhIHZhbHVlIG9mXG4gICAgICAgICAqIGBQSVhJLkJMRU5EX01PREVTLk5PUk1BTGAgdG8gcmVzZXQgdGhlIGJsZW5kIG1vZGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgUElYSS5CTEVORF9NT0RFUy5OT1JNQUw7XG4gICAgICAgICAqIEBzZWUgUElYSS5CTEVORF9NT0RFU1xuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuYmxlbmRNb2RlID0gX2NvbnN0LkJMRU5EX01PREVTLk5PUk1BTDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3VycmVudCBwYXRoXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuR3JhcGhpY3NEYXRhfVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuY3VycmVudFBhdGggPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBcnJheSBjb250YWluaW5nIHNvbWUgV2ViR0wtcmVsYXRlZCBwcm9wZXJ0aWVzIHVzZWQgYnkgdGhlIFdlYkdMIHJlbmRlcmVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtvYmplY3Q8bnVtYmVyLCBvYmplY3Q+fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgLy8gVE9ETyAtIF93ZWJnbCBzaG91bGQgdXNlIGEgcHJvdG90eXBlIG9iamVjdCwgbm90IGEgcmFuZG9tIHVuZG9jdW1lbnRlZCBvYmplY3QuLi5cbiAgICAgICAgX3RoaXMuX3dlYkdMID0ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhpcyBzaGFwZSBpcyBiZWluZyB1c2VkIGFzIGEgbWFzay5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLmlzTWFzayA9IGZhbHNlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYm91bmRzJyBwYWRkaW5nIHVzZWQgZm9yIGJvdW5kcyBjYWxjdWxhdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuYm91bmRzUGFkZGluZyA9IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgY2FjaGUgb2YgdGhlIGxvY2FsIGJvdW5kcyB0byBwcmV2ZW50IHJlY2FsY3VsYXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuUmVjdGFuZ2xlfVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuX2xvY2FsQm91bmRzID0gbmV3IF9Cb3VuZHMyLmRlZmF1bHQoKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVXNlZCB0byBkZXRlY3QgaWYgdGhlIGdyYXBoaWNzIG9iamVjdCBoYXMgY2hhbmdlZC4gSWYgdGhpcyBpcyBzZXQgdG8gdHJ1ZSB0aGVuIHRoZSBncmFwaGljc1xuICAgICAgICAgKiBvYmplY3Qgd2lsbCBiZSByZWNhbGN1bGF0ZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5kaXJ0eSA9IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVzZWQgdG8gZGV0ZWN0IGlmIHdlIG5lZWQgdG8gZG8gYSBmYXN0IHJlY3QgY2hlY2sgdXNpbmcgdGhlIGlkIGNvbXBhcmUgbWV0aG9kXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5mYXN0UmVjdERpcnR5ID0gLTE7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVzZWQgdG8gZGV0ZWN0IGlmIHdlIGNsZWFyIHRoZSBncmFwaGljcyB3ZWJHTCBkYXRhXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5jbGVhckRpcnR5ID0gMDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVXNlZCB0byBkZXRlY3QgaWYgd2Ugd2UgbmVlZCB0byByZWNhbGN1bGF0ZSBsb2NhbCBib3VuZHNcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLmJvdW5kc0RpcnR5ID0gLTE7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVzZWQgdG8gZGV0ZWN0IGlmIHRoZSBjYWNoZWQgc3ByaXRlIG9iamVjdCBuZWVkcyB0byBiZSB1cGRhdGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuY2FjaGVkU3ByaXRlRGlydHkgPSBmYWxzZTtcblxuICAgICAgICBfdGhpcy5fc3ByaXRlUmVjdCA9IG51bGw7XG4gICAgICAgIF90aGlzLl9mYXN0UmVjdCA9IGZhbHNlO1xuXG4gICAgICAgIF90aGlzLl9wcmV2UmVjdFRpbnQgPSBudWxsO1xuICAgICAgICBfdGhpcy5fcHJldlJlY3RGaWxsQ29sb3IgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGVuIGNhY2hlQXNCaXRtYXAgaXMgc2V0IHRvIHRydWUgdGhlIGdyYXBoaWNzIG9iamVjdCB3aWxsIGJlIHJlbmRlcmVkIGFzIGlmIGl0IHdhcyBhIHNwcml0ZS5cbiAgICAgICAgICogVGhpcyBpcyB1c2VmdWwgaWYgeW91ciBncmFwaGljcyBlbGVtZW50IGRvZXMgbm90IGNoYW5nZSBvZnRlbiwgYXMgaXQgd2lsbCBzcGVlZCB1cCB0aGUgcmVuZGVyaW5nXG4gICAgICAgICAqIG9mIHRoZSBvYmplY3QgaW4gZXhjaGFuZ2UgZm9yIHRha2luZyB1cCB0ZXh0dXJlIG1lbW9yeS4gSXQgaXMgYWxzbyB1c2VmdWwgaWYgeW91IG5lZWQgdGhlIGdyYXBoaWNzXG4gICAgICAgICAqIG9iamVjdCB0byBiZSBhbnRpLWFsaWFzZWQsIGJlY2F1c2UgaXQgd2lsbCBiZSByZW5kZXJlZCB1c2luZyBjYW52YXMuIFRoaXMgaXMgbm90IHJlY29tbWVuZGVkIGlmXG4gICAgICAgICAqIHlvdSBhcmUgY29uc3RhbnRseSByZWRyYXdpbmcgdGhlIGdyYXBoaWNzIGVsZW1lbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBuYW1lIGNhY2hlQXNCaXRtYXBcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgICAgICogQG1lbWJlcm9mIFBJWEkuR3JhcGhpY3MjXG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBHcmFwaGljcyBvYmplY3Qgd2l0aCB0aGUgc2FtZSB2YWx1ZXMgYXMgdGhpcyBvbmUuXG4gICAgICogTm90ZSB0aGF0IHRoZSBvbmx5IHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBvYmplY3QgYXJlIGNsb25lZCwgbm90IGl0cyB0cmFuc2Zvcm0gKHBvc2l0aW9uLHNjYWxlLGV0YylcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1BJWEkuR3JhcGhpY3N9IEEgY2xvbmUgb2YgdGhlIGdyYXBoaWNzIG9iamVjdFxuICAgICAqL1xuXG5cbiAgICBHcmFwaGljcy5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgICAgdmFyIGNsb25lID0gbmV3IEdyYXBoaWNzKCk7XG5cbiAgICAgICAgY2xvbmUucmVuZGVyYWJsZSA9IHRoaXMucmVuZGVyYWJsZTtcbiAgICAgICAgY2xvbmUuZmlsbEFscGhhID0gdGhpcy5maWxsQWxwaGE7XG4gICAgICAgIGNsb25lLmxpbmVXaWR0aCA9IHRoaXMubGluZVdpZHRoO1xuICAgICAgICBjbG9uZS5saW5lQ29sb3IgPSB0aGlzLmxpbmVDb2xvcjtcbiAgICAgICAgY2xvbmUubGluZUFsaWdubWVudCA9IHRoaXMubGluZUFsaWdubWVudDtcbiAgICAgICAgY2xvbmUudGludCA9IHRoaXMudGludDtcbiAgICAgICAgY2xvbmUuYmxlbmRNb2RlID0gdGhpcy5ibGVuZE1vZGU7XG4gICAgICAgIGNsb25lLmlzTWFzayA9IHRoaXMuaXNNYXNrO1xuICAgICAgICBjbG9uZS5ib3VuZHNQYWRkaW5nID0gdGhpcy5ib3VuZHNQYWRkaW5nO1xuICAgICAgICBjbG9uZS5kaXJ0eSA9IDA7XG4gICAgICAgIGNsb25lLmNhY2hlZFNwcml0ZURpcnR5ID0gdGhpcy5jYWNoZWRTcHJpdGVEaXJ0eTtcblxuICAgICAgICAvLyBjb3B5IGdyYXBoaWNzIGRhdGFcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmdyYXBoaWNzRGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY2xvbmUuZ3JhcGhpY3NEYXRhLnB1c2godGhpcy5ncmFwaGljc0RhdGFbaV0uY2xvbmUoKSk7XG4gICAgICAgIH1cblxuICAgICAgICBjbG9uZS5jdXJyZW50UGF0aCA9IGNsb25lLmdyYXBoaWNzRGF0YVtjbG9uZS5ncmFwaGljc0RhdGEubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgY2xvbmUudXBkYXRlTG9jYWxCb3VuZHMoKTtcblxuICAgICAgICByZXR1cm4gY2xvbmU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSBsZW5ndGggb2YgcXVhZHJhdGljIGN1cnZlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cDovL3d3dy5tYWxjemFrLmxpbnV4cGwuY29tL2Jsb2cvcXVhZHJhdGljLWJlemllci1jdXJ2ZS1sZW5ndGgvfVxuICAgICAqIGZvciB0aGUgZGV0YWlsZWQgZXhwbGFuYXRpb24gb2YgbWF0aCBiZWhpbmQgdGhpcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGZyb21YIC0geC1jb29yZGluYXRlIG9mIGN1cnZlIHN0YXJ0IHBvaW50XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGZyb21ZIC0geS1jb29yZGluYXRlIG9mIGN1cnZlIHN0YXJ0IHBvaW50XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNwWCAtIHgtY29vcmRpbmF0ZSBvZiBjdXJ2ZSBjb250cm9sIHBvaW50XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNwWSAtIHktY29vcmRpbmF0ZSBvZiBjdXJ2ZSBjb250cm9sIHBvaW50XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRvWCAtIHgtY29vcmRpbmF0ZSBvZiBjdXJ2ZSBlbmQgcG9pbnRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdG9ZIC0geS1jb29yZGluYXRlIG9mIGN1cnZlIGVuZCBwb2ludFxuICAgICAqIEByZXR1cm4ge251bWJlcn0gTGVuZ3RoIG9mIHF1YWRyYXRpYyBjdXJ2ZVxuICAgICAqL1xuXG5cbiAgICBHcmFwaGljcy5wcm90b3R5cGUuX3F1YWRyYXRpY0N1cnZlTGVuZ3RoID0gZnVuY3Rpb24gX3F1YWRyYXRpY0N1cnZlTGVuZ3RoKGZyb21YLCBmcm9tWSwgY3BYLCBjcFksIHRvWCwgdG9ZKSB7XG4gICAgICAgIHZhciBheCA9IGZyb21YIC0gMi4wICogY3BYICsgdG9YO1xuICAgICAgICB2YXIgYXkgPSBmcm9tWSAtIDIuMCAqIGNwWSArIHRvWTtcbiAgICAgICAgdmFyIGJ4ID0gMi4wICogY3BYIC0gMi4wICogZnJvbVg7XG4gICAgICAgIHZhciBieSA9IDIuMCAqIGNwWSAtIDIuMCAqIGZyb21ZO1xuICAgICAgICB2YXIgYSA9IDQuMCAqIChheCAqIGF4ICsgYXkgKiBheSk7XG4gICAgICAgIHZhciBiID0gNC4wICogKGF4ICogYnggKyBheSAqIGJ5KTtcbiAgICAgICAgdmFyIGMgPSBieCAqIGJ4ICsgYnkgKiBieTtcblxuICAgICAgICB2YXIgcyA9IDIuMCAqIE1hdGguc3FydChhICsgYiArIGMpO1xuICAgICAgICB2YXIgYTIgPSBNYXRoLnNxcnQoYSk7XG4gICAgICAgIHZhciBhMzIgPSAyLjAgKiBhICogYTI7XG4gICAgICAgIHZhciBjMiA9IDIuMCAqIE1hdGguc3FydChjKTtcbiAgICAgICAgdmFyIGJhID0gYiAvIGEyO1xuXG4gICAgICAgIHJldHVybiAoYTMyICogcyArIGEyICogYiAqIChzIC0gYzIpICsgKDQuMCAqIGMgKiBhIC0gYiAqIGIpICogTWF0aC5sb2coKDIuMCAqIGEyICsgYmEgKyBzKSAvIChiYSArIGMyKSkpIC8gKDQuMCAqIGEzMik7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSBsZW5ndGggb2YgYmV6aWVyIGN1cnZlLlxuICAgICAqIEFuYWx5dGljYWwgc29sdXRpb24gaXMgaW1wb3NzaWJsZSwgc2luY2UgaXQgaW52b2x2ZXMgYW4gaW50ZWdyYWwgdGhhdCBkb2VzIG5vdCBpbnRlZ3JhdGUgaW4gZ2VuZXJhbC5cbiAgICAgKiBUaGVyZWZvcmUgbnVtZXJpY2FsIHNvbHV0aW9uIGlzIHVzZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tWCAtIFN0YXJ0aW5nIHBvaW50IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZnJvbVkgLSBTdGFydGluZyBwb2ludCB5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNwWCAtIENvbnRyb2wgcG9pbnQgeFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjcFkgLSBDb250cm9sIHBvaW50IHlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY3BYMiAtIFNlY29uZCBDb250cm9sIHBvaW50IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY3BZMiAtIFNlY29uZCBDb250cm9sIHBvaW50IHlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdG9YIC0gRGVzdGluYXRpb24gcG9pbnQgeFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0b1kgLSBEZXN0aW5hdGlvbiBwb2ludCB5XG4gICAgICogQHJldHVybiB7bnVtYmVyfSBMZW5ndGggb2YgYmV6aWVyIGN1cnZlXG4gICAgICovXG5cblxuICAgIEdyYXBoaWNzLnByb3RvdHlwZS5fYmV6aWVyQ3VydmVMZW5ndGggPSBmdW5jdGlvbiBfYmV6aWVyQ3VydmVMZW5ndGgoZnJvbVgsIGZyb21ZLCBjcFgsIGNwWSwgY3BYMiwgY3BZMiwgdG9YLCB0b1kpIHtcbiAgICAgICAgdmFyIG4gPSAxMDtcbiAgICAgICAgdmFyIHJlc3VsdCA9IDAuMDtcbiAgICAgICAgdmFyIHQgPSAwLjA7XG4gICAgICAgIHZhciB0MiA9IDAuMDtcbiAgICAgICAgdmFyIHQzID0gMC4wO1xuICAgICAgICB2YXIgbnQgPSAwLjA7XG4gICAgICAgIHZhciBudDIgPSAwLjA7XG4gICAgICAgIHZhciBudDMgPSAwLjA7XG4gICAgICAgIHZhciB4ID0gMC4wO1xuICAgICAgICB2YXIgeSA9IDAuMDtcbiAgICAgICAgdmFyIGR4ID0gMC4wO1xuICAgICAgICB2YXIgZHkgPSAwLjA7XG4gICAgICAgIHZhciBwcmV2WCA9IGZyb21YO1xuICAgICAgICB2YXIgcHJldlkgPSBmcm9tWTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8PSBuOyArK2kpIHtcbiAgICAgICAgICAgIHQgPSBpIC8gbjtcbiAgICAgICAgICAgIHQyID0gdCAqIHQ7XG4gICAgICAgICAgICB0MyA9IHQyICogdDtcbiAgICAgICAgICAgIG50ID0gMS4wIC0gdDtcbiAgICAgICAgICAgIG50MiA9IG50ICogbnQ7XG4gICAgICAgICAgICBudDMgPSBudDIgKiBudDtcblxuICAgICAgICAgICAgeCA9IG50MyAqIGZyb21YICsgMy4wICogbnQyICogdCAqIGNwWCArIDMuMCAqIG50ICogdDIgKiBjcFgyICsgdDMgKiB0b1g7XG4gICAgICAgICAgICB5ID0gbnQzICogZnJvbVkgKyAzLjAgKiBudDIgKiB0ICogY3BZICsgMyAqIG50ICogdDIgKiBjcFkyICsgdDMgKiB0b1k7XG4gICAgICAgICAgICBkeCA9IHByZXZYIC0geDtcbiAgICAgICAgICAgIGR5ID0gcHJldlkgLSB5O1xuICAgICAgICAgICAgcHJldlggPSB4O1xuICAgICAgICAgICAgcHJldlkgPSB5O1xuXG4gICAgICAgICAgICByZXN1bHQgKz0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSBudW1iZXIgb2Ygc2VnbWVudHMgZm9yIHRoZSBjdXJ2ZSBiYXNlZCBvbiBpdHMgbGVuZ3RoIHRvIGVuc3VyZSBpdHMgc21vb3RobmVzcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aCAtIGxlbmd0aCBvZiBjdXJ2ZVxuICAgICAqIEByZXR1cm4ge251bWJlcn0gTnVtYmVyIG9mIHNlZ21lbnRzXG4gICAgICovXG5cblxuICAgIEdyYXBoaWNzLnByb3RvdHlwZS5fc2VnbWVudHNDb3VudCA9IGZ1bmN0aW9uIF9zZWdtZW50c0NvdW50KGxlbmd0aCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gTWF0aC5jZWlsKGxlbmd0aCAvIEdyYXBoaWNzLkNVUlZFUy5tYXhMZW5ndGgpO1xuXG4gICAgICAgIGlmIChyZXN1bHQgPCBHcmFwaGljcy5DVVJWRVMubWluU2VnbWVudHMpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IEdyYXBoaWNzLkNVUlZFUy5taW5TZWdtZW50cztcbiAgICAgICAgfSBlbHNlIGlmIChyZXN1bHQgPiBHcmFwaGljcy5DVVJWRVMubWF4U2VnbWVudHMpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IEdyYXBoaWNzLkNVUlZFUy5tYXhTZWdtZW50cztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNwZWNpZmllcyB0aGUgbGluZSBzdHlsZSB1c2VkIGZvciBzdWJzZXF1ZW50IGNhbGxzIHRvIEdyYXBoaWNzIG1ldGhvZHMgc3VjaCBhcyB0aGUgbGluZVRvKClcbiAgICAgKiBtZXRob2Qgb3IgdGhlIGRyYXdDaXJjbGUoKSBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbmVXaWR0aD0wXSAtIHdpZHRoIG9mIHRoZSBsaW5lIHRvIGRyYXcsIHdpbGwgdXBkYXRlIHRoZSBvYmplY3RzIHN0b3JlZCBzdHlsZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbY29sb3I9MF0gLSBjb2xvciBvZiB0aGUgbGluZSB0byBkcmF3LCB3aWxsIHVwZGF0ZSB0aGUgb2JqZWN0cyBzdG9yZWQgc3R5bGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FscGhhPTFdIC0gYWxwaGEgb2YgdGhlIGxpbmUgdG8gZHJhdywgd2lsbCB1cGRhdGUgdGhlIG9iamVjdHMgc3RvcmVkIHN0eWxlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthbGlnbm1lbnQ9MC41XSAtIGFsaWdubWVudCBvZiB0aGUgbGluZSB0byBkcmF3LCAoMCA9IGlubmVyLCAwLjUgPSBtaWRkbGUsIDEgPSBvdXR0ZXIpXG4gICAgICogQHJldHVybiB7UElYSS5HcmFwaGljc30gVGhpcyBHcmFwaGljcyBvYmplY3QuIEdvb2QgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxsc1xuICAgICAqL1xuXG5cbiAgICBHcmFwaGljcy5wcm90b3R5cGUubGluZVN0eWxlID0gZnVuY3Rpb24gbGluZVN0eWxlKCkge1xuICAgICAgICB2YXIgbGluZVdpZHRoID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAwO1xuICAgICAgICB2YXIgY29sb3IgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG4gICAgICAgIHZhciBhbHBoYSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMTtcbiAgICAgICAgdmFyIGFsaWdubWVudCA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogMC41O1xuXG4gICAgICAgIHRoaXMubGluZVdpZHRoID0gbGluZVdpZHRoO1xuICAgICAgICB0aGlzLmxpbmVDb2xvciA9IGNvbG9yO1xuICAgICAgICB0aGlzLmxpbmVBbHBoYSA9IGFscGhhO1xuICAgICAgICB0aGlzLmxpbmVBbGlnbm1lbnQgPSBhbGlnbm1lbnQ7XG5cbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFBhdGgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRQYXRoLnNoYXBlLnBvaW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyBoYWxmd2F5IHRocm91Z2ggYSBsaW5lPyBzdGFydCBhIG5ldyBvbmUhXG4gICAgICAgICAgICAgICAgdmFyIHNoYXBlID0gbmV3IF9tYXRoLlBvbHlnb24odGhpcy5jdXJyZW50UGF0aC5zaGFwZS5wb2ludHMuc2xpY2UoLTIpKTtcblxuICAgICAgICAgICAgICAgIHNoYXBlLmNsb3NlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3U2hhcGUoc2hhcGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UgaXRzIGVtcHR5IHNvIGxldHMganVzdCBzZXQgdGhlIGxpbmUgcHJvcGVydGllc1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFBhdGgubGluZVdpZHRoID0gdGhpcy5saW5lV2lkdGg7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50UGF0aC5saW5lQ29sb3IgPSB0aGlzLmxpbmVDb2xvcjtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRQYXRoLmxpbmVBbHBoYSA9IHRoaXMubGluZUFscGhhO1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFBhdGgubGluZUFsaWdubWVudCA9IHRoaXMubGluZUFsaWdubWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBNb3ZlcyB0aGUgY3VycmVudCBkcmF3aW5nIHBvc2l0aW9uIHRvIHgsIHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAtIHRoZSBYIGNvb3JkaW5hdGUgdG8gbW92ZSB0b1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gdGhlIFkgY29vcmRpbmF0ZSB0byBtb3ZlIHRvXG4gICAgICogQHJldHVybiB7UElYSS5HcmFwaGljc30gVGhpcyBHcmFwaGljcyBvYmplY3QuIEdvb2QgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxsc1xuICAgICAqL1xuXG5cbiAgICBHcmFwaGljcy5wcm90b3R5cGUubW92ZVRvID0gZnVuY3Rpb24gbW92ZVRvKHgsIHkpIHtcbiAgICAgICAgdmFyIHNoYXBlID0gbmV3IF9tYXRoLlBvbHlnb24oW3gsIHldKTtcblxuICAgICAgICBzaGFwZS5jbG9zZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kcmF3U2hhcGUoc2hhcGUpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEcmF3cyBhIGxpbmUgdXNpbmcgdGhlIGN1cnJlbnQgbGluZSBzdHlsZSBmcm9tIHRoZSBjdXJyZW50IGRyYXdpbmcgcG9zaXRpb24gdG8gKHgsIHkpO1xuICAgICAqIFRoZSBjdXJyZW50IGRyYXdpbmcgcG9zaXRpb24gaXMgdGhlbiBzZXQgdG8gKHgsIHkpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSB0aGUgWCBjb29yZGluYXRlIHRvIGRyYXcgdG9cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIHRoZSBZIGNvb3JkaW5hdGUgdG8gZHJhdyB0b1xuICAgICAqIEByZXR1cm4ge1BJWEkuR3JhcGhpY3N9IFRoaXMgR3JhcGhpY3Mgb2JqZWN0LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHNcbiAgICAgKi9cblxuXG4gICAgR3JhcGhpY3MucHJvdG90eXBlLmxpbmVUbyA9IGZ1bmN0aW9uIGxpbmVUbyh4LCB5KSB7XG4gICAgICAgIHZhciBwb2ludHMgPSB0aGlzLmN1cnJlbnRQYXRoLnNoYXBlLnBvaW50cztcblxuICAgICAgICB2YXIgZnJvbVggPSBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDJdO1xuICAgICAgICB2YXIgZnJvbVkgPSBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgIGlmIChmcm9tWCAhPT0geCB8fCBmcm9tWSAhPT0geSkge1xuICAgICAgICAgICAgcG9pbnRzLnB1c2goeCwgeSk7XG4gICAgICAgICAgICB0aGlzLmRpcnR5Kys7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBwb2ludHMgZm9yIGEgcXVhZHJhdGljIGJlemllciBjdXJ2ZSBhbmQgdGhlbiBkcmF3cyBpdC5cbiAgICAgKiBCYXNlZCBvbjogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNzg1MDk3L2hvdy1kby1pLWltcGxlbWVudC1hLWJlemllci1jdXJ2ZS1pbi1jXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY3BYIC0gQ29udHJvbCBwb2ludCB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNwWSAtIENvbnRyb2wgcG9pbnQgeVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0b1ggLSBEZXN0aW5hdGlvbiBwb2ludCB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRvWSAtIERlc3RpbmF0aW9uIHBvaW50IHlcbiAgICAgKiBAcmV0dXJuIHtQSVhJLkdyYXBoaWNzfSBUaGlzIEdyYXBoaWNzIG9iamVjdC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzXG4gICAgICovXG5cblxuICAgIEdyYXBoaWNzLnByb3RvdHlwZS5xdWFkcmF0aWNDdXJ2ZVRvID0gZnVuY3Rpb24gcXVhZHJhdGljQ3VydmVUbyhjcFgsIGNwWSwgdG9YLCB0b1kpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFBhdGgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRQYXRoLnNoYXBlLnBvaW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRQYXRoLnNoYXBlLnBvaW50cyA9IFswLCAwXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubW92ZVRvKDAsIDApO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBvaW50cyA9IHRoaXMuY3VycmVudFBhdGguc2hhcGUucG9pbnRzO1xuICAgICAgICB2YXIgeGEgPSAwO1xuICAgICAgICB2YXIgeWEgPSAwO1xuXG4gICAgICAgIGlmIChwb2ludHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLm1vdmVUbygwLCAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmcm9tWCA9IHBvaW50c1twb2ludHMubGVuZ3RoIC0gMl07XG4gICAgICAgIHZhciBmcm9tWSA9IHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV07XG4gICAgICAgIHZhciBuID0gR3JhcGhpY3MuQ1VSVkVTLmFkYXB0aXZlID8gdGhpcy5fc2VnbWVudHNDb3VudCh0aGlzLl9xdWFkcmF0aWNDdXJ2ZUxlbmd0aChmcm9tWCwgZnJvbVksIGNwWCwgY3BZLCB0b1gsIHRvWSkpIDogMjA7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gbjsgKytpKSB7XG4gICAgICAgICAgICB2YXIgaiA9IGkgLyBuO1xuXG4gICAgICAgICAgICB4YSA9IGZyb21YICsgKGNwWCAtIGZyb21YKSAqIGo7XG4gICAgICAgICAgICB5YSA9IGZyb21ZICsgKGNwWSAtIGZyb21ZKSAqIGo7XG5cbiAgICAgICAgICAgIHBvaW50cy5wdXNoKHhhICsgKGNwWCArICh0b1ggLSBjcFgpICogaiAtIHhhKSAqIGosIHlhICsgKGNwWSArICh0b1kgLSBjcFkpICogaiAtIHlhKSAqIGopO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5kaXJ0eSsrO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIHBvaW50cyBmb3IgYSBiZXppZXIgY3VydmUgYW5kIHRoZW4gZHJhd3MgaXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY3BYIC0gQ29udHJvbCBwb2ludCB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNwWSAtIENvbnRyb2wgcG9pbnQgeVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjcFgyIC0gU2Vjb25kIENvbnRyb2wgcG9pbnQgeFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjcFkyIC0gU2Vjb25kIENvbnRyb2wgcG9pbnQgeVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0b1ggLSBEZXN0aW5hdGlvbiBwb2ludCB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRvWSAtIERlc3RpbmF0aW9uIHBvaW50IHlcbiAgICAgKiBAcmV0dXJuIHtQSVhJLkdyYXBoaWNzfSBUaGlzIEdyYXBoaWNzIG9iamVjdC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzXG4gICAgICovXG5cblxuICAgIEdyYXBoaWNzLnByb3RvdHlwZS5iZXppZXJDdXJ2ZVRvID0gZnVuY3Rpb24gYmV6aWVyQ3VydmVUbyhjcFgsIGNwWSwgY3BYMiwgY3BZMiwgdG9YLCB0b1kpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFBhdGgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRQYXRoLnNoYXBlLnBvaW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRQYXRoLnNoYXBlLnBvaW50cyA9IFswLCAwXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubW92ZVRvKDAsIDApO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBvaW50cyA9IHRoaXMuY3VycmVudFBhdGguc2hhcGUucG9pbnRzO1xuXG4gICAgICAgIHZhciBmcm9tWCA9IHBvaW50c1twb2ludHMubGVuZ3RoIC0gMl07XG4gICAgICAgIHZhciBmcm9tWSA9IHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgcG9pbnRzLmxlbmd0aCAtPSAyO1xuXG4gICAgICAgIHZhciBuID0gR3JhcGhpY3MuQ1VSVkVTLmFkYXB0aXZlID8gdGhpcy5fc2VnbWVudHNDb3VudCh0aGlzLl9iZXppZXJDdXJ2ZUxlbmd0aChmcm9tWCwgZnJvbVksIGNwWCwgY3BZLCBjcFgyLCBjcFkyLCB0b1gsIHRvWSkpIDogMjA7XG5cbiAgICAgICAgKDAsIF9iZXppZXJDdXJ2ZVRvMy5kZWZhdWx0KShmcm9tWCwgZnJvbVksIGNwWCwgY3BZLCBjcFgyLCBjcFkyLCB0b1gsIHRvWSwgbiwgcG9pbnRzKTtcblxuICAgICAgICB0aGlzLmRpcnR5Kys7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBhcmNUbygpIG1ldGhvZCBjcmVhdGVzIGFuIGFyYy9jdXJ2ZSBiZXR3ZWVuIHR3byB0YW5nZW50cyBvbiB0aGUgY2FudmFzLlxuICAgICAqXG4gICAgICogXCJib3Jyb3dlZFwiIGZyb20gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9meGNhbnZhcy8gLSB0aGFua3MgZ29vZ2xlIVxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgxIC0gVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcmNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geTEgLSBUaGUgeS1jb29yZGluYXRlIG9mIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFyY1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MiAtIFRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIGVuZCBvZiB0aGUgYXJjXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkyIC0gVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgZW5kIG9mIHRoZSBhcmNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzIC0gVGhlIHJhZGl1cyBvZiB0aGUgYXJjXG4gICAgICogQHJldHVybiB7UElYSS5HcmFwaGljc30gVGhpcyBHcmFwaGljcyBvYmplY3QuIEdvb2QgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxsc1xuICAgICAqL1xuXG5cbiAgICBHcmFwaGljcy5wcm90b3R5cGUuYXJjVG8gPSBmdW5jdGlvbiBhcmNUbyh4MSwgeTEsIHgyLCB5MiwgcmFkaXVzKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRQYXRoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50UGF0aC5zaGFwZS5wb2ludHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50UGF0aC5zaGFwZS5wb2ludHMucHVzaCh4MSwgeTEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tb3ZlVG8oeDEsIHkxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwb2ludHMgPSB0aGlzLmN1cnJlbnRQYXRoLnNoYXBlLnBvaW50cztcbiAgICAgICAgdmFyIGZyb21YID0gcG9pbnRzW3BvaW50cy5sZW5ndGggLSAyXTtcbiAgICAgICAgdmFyIGZyb21ZID0gcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXTtcbiAgICAgICAgdmFyIGExID0gZnJvbVkgLSB5MTtcbiAgICAgICAgdmFyIGIxID0gZnJvbVggLSB4MTtcbiAgICAgICAgdmFyIGEyID0geTIgLSB5MTtcbiAgICAgICAgdmFyIGIyID0geDIgLSB4MTtcbiAgICAgICAgdmFyIG1tID0gTWF0aC5hYnMoYTEgKiBiMiAtIGIxICogYTIpO1xuXG4gICAgICAgIGlmIChtbSA8IDEuMGUtOCB8fCByYWRpdXMgPT09IDApIHtcbiAgICAgICAgICAgIGlmIChwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDJdICE9PSB4MSB8fCBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdICE9PSB5MSkge1xuICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKHgxLCB5MSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgZGQgPSBhMSAqIGExICsgYjEgKiBiMTtcbiAgICAgICAgICAgIHZhciBjYyA9IGEyICogYTIgKyBiMiAqIGIyO1xuICAgICAgICAgICAgdmFyIHR0ID0gYTEgKiBhMiArIGIxICogYjI7XG4gICAgICAgICAgICB2YXIgazEgPSByYWRpdXMgKiBNYXRoLnNxcnQoZGQpIC8gbW07XG4gICAgICAgICAgICB2YXIgazIgPSByYWRpdXMgKiBNYXRoLnNxcnQoY2MpIC8gbW07XG4gICAgICAgICAgICB2YXIgajEgPSBrMSAqIHR0IC8gZGQ7XG4gICAgICAgICAgICB2YXIgajIgPSBrMiAqIHR0IC8gY2M7XG4gICAgICAgICAgICB2YXIgY3ggPSBrMSAqIGIyICsgazIgKiBiMTtcbiAgICAgICAgICAgIHZhciBjeSA9IGsxICogYTIgKyBrMiAqIGExO1xuICAgICAgICAgICAgdmFyIHB4ID0gYjEgKiAoazIgKyBqMSk7XG4gICAgICAgICAgICB2YXIgcHkgPSBhMSAqIChrMiArIGoxKTtcbiAgICAgICAgICAgIHZhciBxeCA9IGIyICogKGsxICsgajIpO1xuICAgICAgICAgICAgdmFyIHF5ID0gYTIgKiAoazEgKyBqMik7XG4gICAgICAgICAgICB2YXIgc3RhcnRBbmdsZSA9IE1hdGguYXRhbjIocHkgLSBjeSwgcHggLSBjeCk7XG4gICAgICAgICAgICB2YXIgZW5kQW5nbGUgPSBNYXRoLmF0YW4yKHF5IC0gY3ksIHF4IC0gY3gpO1xuXG4gICAgICAgICAgICB0aGlzLmFyYyhjeCArIHgxLCBjeSArIHkxLCByYWRpdXMsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBiMSAqIGEyID4gYjIgKiBhMSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRpcnR5Kys7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBhcmMgbWV0aG9kIGNyZWF0ZXMgYW4gYXJjL2N1cnZlICh1c2VkIHRvIGNyZWF0ZSBjaXJjbGVzLCBvciBwYXJ0cyBvZiBjaXJjbGVzKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjeCAtIFRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGUgY2lyY2xlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGN5IC0gVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoZSBjaXJjbGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzIC0gVGhlIHJhZGl1cyBvZiB0aGUgY2lyY2xlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0QW5nbGUgLSBUaGUgc3RhcnRpbmcgYW5nbGUsIGluIHJhZGlhbnMgKDAgaXMgYXQgdGhlIDMgbydjbG9jayBwb3NpdGlvblxuICAgICAqICBvZiB0aGUgYXJjJ3MgY2lyY2xlKVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmRBbmdsZSAtIFRoZSBlbmRpbmcgYW5nbGUsIGluIHJhZGlhbnNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFthbnRpY2xvY2t3aXNlPWZhbHNlXSAtIFNwZWNpZmllcyB3aGV0aGVyIHRoZSBkcmF3aW5nIHNob3VsZCBiZVxuICAgICAqICBjb3VudGVyLWNsb2Nrd2lzZSBvciBjbG9ja3dpc2UuIEZhbHNlIGlzIGRlZmF1bHQsIGFuZCBpbmRpY2F0ZXMgY2xvY2t3aXNlLCB3aGlsZSB0cnVlXG4gICAgICogIGluZGljYXRlcyBjb3VudGVyLWNsb2Nrd2lzZS5cbiAgICAgKiBAcmV0dXJuIHtQSVhJLkdyYXBoaWNzfSBUaGlzIEdyYXBoaWNzIG9iamVjdC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzXG4gICAgICovXG5cblxuICAgIEdyYXBoaWNzLnByb3RvdHlwZS5hcmMgPSBmdW5jdGlvbiBhcmMoY3gsIGN5LCByYWRpdXMsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKSB7XG4gICAgICAgIHZhciBhbnRpY2xvY2t3aXNlID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiBmYWxzZTtcblxuICAgICAgICBpZiAoc3RhcnRBbmdsZSA9PT0gZW5kQW5nbGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFhbnRpY2xvY2t3aXNlICYmIGVuZEFuZ2xlIDw9IHN0YXJ0QW5nbGUpIHtcbiAgICAgICAgICAgIGVuZEFuZ2xlICs9IF9jb25zdC5QSV8yO1xuICAgICAgICB9IGVsc2UgaWYgKGFudGljbG9ja3dpc2UgJiYgc3RhcnRBbmdsZSA8PSBlbmRBbmdsZSkge1xuICAgICAgICAgICAgc3RhcnRBbmdsZSArPSBfY29uc3QuUElfMjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzd2VlcCA9IGVuZEFuZ2xlIC0gc3RhcnRBbmdsZTtcbiAgICAgICAgdmFyIHNlZ3MgPSBHcmFwaGljcy5DVVJWRVMuYWRhcHRpdmUgPyB0aGlzLl9zZWdtZW50c0NvdW50KE1hdGguYWJzKHN3ZWVwKSAqIHJhZGl1cykgOiBNYXRoLmNlaWwoTWF0aC5hYnMoc3dlZXApIC8gX2NvbnN0LlBJXzIpICogNDA7XG5cbiAgICAgICAgaWYgKHN3ZWVwID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzdGFydFggPSBjeCArIE1hdGguY29zKHN0YXJ0QW5nbGUpICogcmFkaXVzO1xuICAgICAgICB2YXIgc3RhcnRZID0gY3kgKyBNYXRoLnNpbihzdGFydEFuZ2xlKSAqIHJhZGl1cztcblxuICAgICAgICAvLyBJZiB0aGUgY3VycmVudFBhdGggZXhpc3RzLCB0YWtlIGl0cyBwb2ludHMuIE90aGVyd2lzZSBjYWxsIGBtb3ZlVG9gIHRvIHN0YXJ0IGEgcGF0aC5cbiAgICAgICAgdmFyIHBvaW50cyA9IHRoaXMuY3VycmVudFBhdGggPyB0aGlzLmN1cnJlbnRQYXRoLnNoYXBlLnBvaW50cyA6IG51bGw7XG5cbiAgICAgICAgaWYgKHBvaW50cykge1xuICAgICAgICAgICAgLy8gV2UgY2hlY2sgaG93IGZhciBvdXIgc3RhcnQgaXMgZnJvbSB0aGUgbGFzdCBleGlzdGluZyBwb2ludFxuICAgICAgICAgICAgdmFyIHhEaWZmID0gTWF0aC5hYnMocG9pbnRzW3BvaW50cy5sZW5ndGggLSAyXSAtIHN0YXJ0WCk7XG4gICAgICAgICAgICB2YXIgeURpZmYgPSBNYXRoLmFicyhwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdIC0gc3RhcnRZKTtcblxuICAgICAgICAgICAgaWYgKHhEaWZmIDwgMC4wMDEgJiYgeURpZmYgPCAwLjAwMSkge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBwb2ludCBpcyB2ZXJ5IGNsb3NlLCB3ZSBkb24ndCBhZGQgaXQsIHNpbmNlIHRoaXMgd291bGQgbGVhZCB0byBhcnRpZmFjdHNcbiAgICAgICAgICAgICAgICAvLyBkdXJpbmcgdGVzc2VsYXRpb24gZHVlIHRvIGZsb2F0aW5nIHBvaW50IGltcHJlY2lzaW9uLlxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwb2ludHMucHVzaChzdGFydFgsIHN0YXJ0WSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1vdmVUbyhzdGFydFgsIHN0YXJ0WSk7XG4gICAgICAgICAgICBwb2ludHMgPSB0aGlzLmN1cnJlbnRQYXRoLnNoYXBlLnBvaW50cztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0aGV0YSA9IHN3ZWVwIC8gKHNlZ3MgKiAyKTtcbiAgICAgICAgdmFyIHRoZXRhMiA9IHRoZXRhICogMjtcblxuICAgICAgICB2YXIgY1RoZXRhID0gTWF0aC5jb3ModGhldGEpO1xuICAgICAgICB2YXIgc1RoZXRhID0gTWF0aC5zaW4odGhldGEpO1xuXG4gICAgICAgIHZhciBzZWdNaW51cyA9IHNlZ3MgLSAxO1xuXG4gICAgICAgIHZhciByZW1haW5kZXIgPSBzZWdNaW51cyAlIDEgLyBzZWdNaW51cztcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBzZWdNaW51czsgKytpKSB7XG4gICAgICAgICAgICB2YXIgcmVhbCA9IGkgKyByZW1haW5kZXIgKiBpO1xuXG4gICAgICAgICAgICB2YXIgYW5nbGUgPSB0aGV0YSArIHN0YXJ0QW5nbGUgKyB0aGV0YTIgKiByZWFsO1xuXG4gICAgICAgICAgICB2YXIgYyA9IE1hdGguY29zKGFuZ2xlKTtcbiAgICAgICAgICAgIHZhciBzID0gLU1hdGguc2luKGFuZ2xlKTtcblxuICAgICAgICAgICAgcG9pbnRzLnB1c2goKGNUaGV0YSAqIGMgKyBzVGhldGEgKiBzKSAqIHJhZGl1cyArIGN4LCAoY1RoZXRhICogLXMgKyBzVGhldGEgKiBjKSAqIHJhZGl1cyArIGN5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZGlydHkrKztcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU3BlY2lmaWVzIGEgc2ltcGxlIG9uZS1jb2xvciBmaWxsIHRoYXQgc3Vic2VxdWVudCBjYWxscyB0byBvdGhlciBHcmFwaGljcyBtZXRob2RzXG4gICAgICogKHN1Y2ggYXMgbGluZVRvKCkgb3IgZHJhd0NpcmNsZSgpKSB1c2Ugd2hlbiBkcmF3aW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtjb2xvcj0wXSAtIHRoZSBjb2xvciBvZiB0aGUgZmlsbFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYWxwaGE9MV0gLSB0aGUgYWxwaGEgb2YgdGhlIGZpbGxcbiAgICAgKiBAcmV0dXJuIHtQSVhJLkdyYXBoaWNzfSBUaGlzIEdyYXBoaWNzIG9iamVjdC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzXG4gICAgICovXG5cblxuICAgIEdyYXBoaWNzLnByb3RvdHlwZS5iZWdpbkZpbGwgPSBmdW5jdGlvbiBiZWdpbkZpbGwoKSB7XG4gICAgICAgIHZhciBjb2xvciA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMDtcbiAgICAgICAgdmFyIGFscGhhID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAxO1xuXG4gICAgICAgIHRoaXMuZmlsbGluZyA9IHRydWU7XG4gICAgICAgIHRoaXMuZmlsbENvbG9yID0gY29sb3I7XG4gICAgICAgIHRoaXMuZmlsbEFscGhhID0gYWxwaGE7XG5cbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFBhdGgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRQYXRoLnNoYXBlLnBvaW50cy5sZW5ndGggPD0gMikge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFBhdGguZmlsbCA9IHRoaXMuZmlsbGluZztcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRQYXRoLmZpbGxDb2xvciA9IHRoaXMuZmlsbENvbG9yO1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFBhdGguZmlsbEFscGhhID0gdGhpcy5maWxsQWxwaGE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQXBwbGllcyBhIGZpbGwgdG8gdGhlIGxpbmVzIGFuZCBzaGFwZXMgdGhhdCB3ZXJlIGFkZGVkIHNpbmNlIHRoZSBsYXN0IGNhbGwgdG8gdGhlIGJlZ2luRmlsbCgpIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1BJWEkuR3JhcGhpY3N9IFRoaXMgR3JhcGhpY3Mgb2JqZWN0LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHNcbiAgICAgKi9cblxuXG4gICAgR3JhcGhpY3MucHJvdG90eXBlLmVuZEZpbGwgPSBmdW5jdGlvbiBlbmRGaWxsKCkge1xuICAgICAgICB0aGlzLmZpbGxpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5maWxsQ29sb3IgPSBudWxsO1xuICAgICAgICB0aGlzLmZpbGxBbHBoYSA9IDE7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgWCBjb29yZCBvZiB0aGUgdG9wLWxlZnQgb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gVGhlIFkgY29vcmQgb2YgdGhlIHRvcC1sZWZ0IG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSBUaGUgd2lkdGggb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0IG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKiBAcmV0dXJuIHtQSVhJLkdyYXBoaWNzfSBUaGlzIEdyYXBoaWNzIG9iamVjdC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzXG4gICAgICovXG5cblxuICAgIEdyYXBoaWNzLnByb3RvdHlwZS5kcmF3UmVjdCA9IGZ1bmN0aW9uIGRyYXdSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgdGhpcy5kcmF3U2hhcGUobmV3IF9tYXRoLlJlY3RhbmdsZSh4LCB5LCB3aWR0aCwgaGVpZ2h0KSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgWCBjb29yZCBvZiB0aGUgdG9wLWxlZnQgb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gVGhlIFkgY29vcmQgb2YgdGhlIHRvcC1sZWZ0IG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSBUaGUgd2lkdGggb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0IG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzIC0gUmFkaXVzIG9mIHRoZSByZWN0YW5nbGUgY29ybmVyc1xuICAgICAqIEByZXR1cm4ge1BJWEkuR3JhcGhpY3N9IFRoaXMgR3JhcGhpY3Mgb2JqZWN0LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHNcbiAgICAgKi9cblxuXG4gICAgR3JhcGhpY3MucHJvdG90eXBlLmRyYXdSb3VuZGVkUmVjdCA9IGZ1bmN0aW9uIGRyYXdSb3VuZGVkUmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0LCByYWRpdXMpIHtcbiAgICAgICAgdGhpcy5kcmF3U2hhcGUobmV3IF9tYXRoLlJvdW5kZWRSZWN0YW5nbGUoeCwgeSwgd2lkdGgsIGhlaWdodCwgcmFkaXVzKSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERyYXdzIGEgY2lyY2xlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBjZW50ZXIgb2YgdGhlIGNpcmNsZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoZSBjaXJjbGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzIC0gVGhlIHJhZGl1cyBvZiB0aGUgY2lyY2xlXG4gICAgICogQHJldHVybiB7UElYSS5HcmFwaGljc30gVGhpcyBHcmFwaGljcyBvYmplY3QuIEdvb2QgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxsc1xuICAgICAqL1xuXG5cbiAgICBHcmFwaGljcy5wcm90b3R5cGUuZHJhd0NpcmNsZSA9IGZ1bmN0aW9uIGRyYXdDaXJjbGUoeCwgeSwgcmFkaXVzKSB7XG4gICAgICAgIHRoaXMuZHJhd1NoYXBlKG5ldyBfbWF0aC5DaXJjbGUoeCwgeSwgcmFkaXVzKSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERyYXdzIGFuIGVsbGlwc2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAtIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGUgZWxsaXBzZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoZSBlbGxpcHNlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIC0gVGhlIGhhbGYgd2lkdGggb2YgdGhlIGVsbGlwc2VcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IC0gVGhlIGhhbGYgaGVpZ2h0IG9mIHRoZSBlbGxpcHNlXG4gICAgICogQHJldHVybiB7UElYSS5HcmFwaGljc30gVGhpcyBHcmFwaGljcyBvYmplY3QuIEdvb2QgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxsc1xuICAgICAqL1xuXG5cbiAgICBHcmFwaGljcy5wcm90b3R5cGUuZHJhd0VsbGlwc2UgPSBmdW5jdGlvbiBkcmF3RWxsaXBzZSh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuZHJhd1NoYXBlKG5ldyBfbWF0aC5FbGxpcHNlKHgsIHksIHdpZHRoLCBoZWlnaHQpKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRHJhd3MgYSBwb2x5Z29uIHVzaW5nIHRoZSBnaXZlbiBwYXRoLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJbXXxQSVhJLlBvaW50W118UElYSS5Qb2x5Z29ufSBwYXRoIC0gVGhlIHBhdGggZGF0YSB1c2VkIHRvIGNvbnN0cnVjdCB0aGUgcG9seWdvbi5cbiAgICAgKiBAcmV0dXJuIHtQSVhJLkdyYXBoaWNzfSBUaGlzIEdyYXBoaWNzIG9iamVjdC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzXG4gICAgICovXG5cblxuICAgIEdyYXBoaWNzLnByb3RvdHlwZS5kcmF3UG9seWdvbiA9IGZ1bmN0aW9uIGRyYXdQb2x5Z29uKHBhdGgpIHtcbiAgICAgICAgLy8gcHJldmVudHMgYW4gYXJndW1lbnQgYXNzaWdubWVudCBkZW9wdFxuICAgICAgICAvLyBzZWUgc2VjdGlvbiAzLjE6IGh0dHBzOi8vZ2l0aHViLmNvbS9wZXRrYWFudG9ub3YvYmx1ZWJpcmQvd2lraS9PcHRpbWl6YXRpb24ta2lsbGVycyMzLW1hbmFnaW5nLWFyZ3VtZW50c1xuICAgICAgICB2YXIgcG9pbnRzID0gcGF0aDtcblxuICAgICAgICB2YXIgY2xvc2VkID0gdHJ1ZTtcblxuICAgICAgICBpZiAocG9pbnRzIGluc3RhbmNlb2YgX21hdGguUG9seWdvbikge1xuICAgICAgICAgICAgY2xvc2VkID0gcG9pbnRzLmNsb3NlZDtcbiAgICAgICAgICAgIHBvaW50cyA9IHBvaW50cy5wb2ludHM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocG9pbnRzKSkge1xuICAgICAgICAgICAgLy8gcHJldmVudHMgYW4gYXJndW1lbnQgbGVhayBkZW9wdFxuICAgICAgICAgICAgLy8gc2VlIHNlY3Rpb24gMy4yOiBodHRwczovL2dpdGh1Yi5jb20vcGV0a2FhbnRvbm92L2JsdWViaXJkL3dpa2kvT3B0aW1pemF0aW9uLWtpbGxlcnMjMy1tYW5hZ2luZy1hcmd1bWVudHNcbiAgICAgICAgICAgIHBvaW50cyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBwb2ludHNbaV0gPSBhcmd1bWVudHNbaV07IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcHJlZmVyLXJlc3QtcGFyYW1zXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2hhcGUgPSBuZXcgX21hdGguUG9seWdvbihwb2ludHMpO1xuXG4gICAgICAgIHNoYXBlLmNsb3NlZCA9IGNsb3NlZDtcblxuICAgICAgICB0aGlzLmRyYXdTaGFwZShzaGFwZSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERyYXcgYSBzdGFyIHNoYXBlIHdpdGggYW4gYWJpdHJhcnkgbnVtYmVyIG9mIHBvaW50cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gQ2VudGVyIFggcG9zaXRpb24gb2YgdGhlIHN0YXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIENlbnRlciBZIHBvc2l0aW9uIG9mIHRoZSBzdGFyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBvaW50cyAtIFRoZSBudW1iZXIgb2YgcG9pbnRzIG9mIHRoZSBzdGFyLCBtdXN0IGJlID4gMVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXMgLSBUaGUgb3V0ZXIgcmFkaXVzIG9mIHRoZSBzdGFyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtpbm5lclJhZGl1c10gLSBUaGUgaW5uZXIgcmFkaXVzIGJldHdlZW4gcG9pbnRzLCBkZWZhdWx0IGhhbGYgYHJhZGl1c2BcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3JvdGF0aW9uPTBdIC0gVGhlIHJvdGF0aW9uIG9mIHRoZSBzdGFyIGluIHJhZGlhbnMsIHdoZXJlIDAgaXMgdmVydGljYWxcbiAgICAgKiBAcmV0dXJuIHtQSVhJLkdyYXBoaWNzfSBUaGlzIEdyYXBoaWNzIG9iamVjdC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzXG4gICAgICovXG5cblxuICAgIEdyYXBoaWNzLnByb3RvdHlwZS5kcmF3U3RhciA9IGZ1bmN0aW9uIGRyYXdTdGFyKHgsIHksIHBvaW50cywgcmFkaXVzLCBpbm5lclJhZGl1cykge1xuICAgICAgICB2YXIgcm90YXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IDA7XG5cbiAgICAgICAgaW5uZXJSYWRpdXMgPSBpbm5lclJhZGl1cyB8fCByYWRpdXMgLyAyO1xuXG4gICAgICAgIHZhciBzdGFydEFuZ2xlID0gLTEgKiBNYXRoLlBJIC8gMiArIHJvdGF0aW9uO1xuICAgICAgICB2YXIgbGVuID0gcG9pbnRzICogMjtcbiAgICAgICAgdmFyIGRlbHRhID0gX2NvbnN0LlBJXzIgLyBsZW47XG4gICAgICAgIHZhciBwb2x5Z29uID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIHIgPSBpICUgMiA/IGlubmVyUmFkaXVzIDogcmFkaXVzO1xuICAgICAgICAgICAgdmFyIGFuZ2xlID0gaSAqIGRlbHRhICsgc3RhcnRBbmdsZTtcblxuICAgICAgICAgICAgcG9seWdvbi5wdXNoKHggKyByICogTWF0aC5jb3MoYW5nbGUpLCB5ICsgciAqIE1hdGguc2luKGFuZ2xlKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5kcmF3UG9seWdvbihwb2x5Z29uKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2xlYXJzIHRoZSBncmFwaGljcyB0aGF0IHdlcmUgZHJhd24gdG8gdGhpcyBHcmFwaGljcyBvYmplY3QsIGFuZCByZXNldHMgZmlsbCBhbmQgbGluZSBzdHlsZSBzZXR0aW5ncy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1BJWEkuR3JhcGhpY3N9IFRoaXMgR3JhcGhpY3Mgb2JqZWN0LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHNcbiAgICAgKi9cblxuXG4gICAgR3JhcGhpY3MucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICAgIGlmICh0aGlzLmxpbmVXaWR0aCB8fCB0aGlzLmZpbGxpbmcgfHwgdGhpcy5ncmFwaGljc0RhdGEubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5saW5lV2lkdGggPSAwO1xuICAgICAgICAgICAgdGhpcy5saW5lQWxpZ25tZW50ID0gMC41O1xuXG4gICAgICAgICAgICB0aGlzLmZpbGxpbmcgPSBmYWxzZTtcblxuICAgICAgICAgICAgdGhpcy5ib3VuZHNEaXJ0eSA9IC0xO1xuICAgICAgICAgICAgdGhpcy5jYW52YXNUaW50RGlydHkgPSAtMTtcbiAgICAgICAgICAgIHRoaXMuZGlydHkrKztcbiAgICAgICAgICAgIHRoaXMuY2xlYXJEaXJ0eSsrO1xuICAgICAgICAgICAgdGhpcy5ncmFwaGljc0RhdGEubGVuZ3RoID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY3VycmVudFBhdGggPSBudWxsO1xuICAgICAgICB0aGlzLl9zcHJpdGVSZWN0ID0gbnVsbDtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVHJ1ZSBpZiBncmFwaGljcyBjb25zaXN0cyBvZiBvbmUgcmVjdGFuZ2xlLCBhbmQgdGh1cywgY2FuIGJlIGRyYXduIGxpa2UgYSBTcHJpdGUgYW5kXG4gICAgICogbWFza2VkIHdpdGggZ2wuc2Npc3Nvci5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIG9ubHkgMSByZWN0LlxuICAgICAqL1xuXG5cbiAgICBHcmFwaGljcy5wcm90b3R5cGUuaXNGYXN0UmVjdCA9IGZ1bmN0aW9uIGlzRmFzdFJlY3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyYXBoaWNzRGF0YS5sZW5ndGggPT09IDEgJiYgdGhpcy5ncmFwaGljc0RhdGFbMF0uc2hhcGUudHlwZSA9PT0gX2NvbnN0LlNIQVBFUy5SRUNUICYmICF0aGlzLmdyYXBoaWNzRGF0YVswXS5saW5lV2lkdGg7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgdGhlIG9iamVjdCB1c2luZyB0aGUgV2ViR0wgcmVuZGVyZXJcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtQSVhJLldlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyXG4gICAgICovXG5cblxuICAgIEdyYXBoaWNzLnByb3RvdHlwZS5fcmVuZGVyV2ViR0wgPSBmdW5jdGlvbiBfcmVuZGVyV2ViR0wocmVuZGVyZXIpIHtcbiAgICAgICAgLy8gaWYgdGhlIHNwcml0ZSBpcyBub3QgdmlzaWJsZSBvciB0aGUgYWxwaGEgaXMgMCB0aGVuIG5vIG5lZWQgdG8gcmVuZGVyIHRoaXMgZWxlbWVudFxuICAgICAgICBpZiAodGhpcy5kaXJ0eSAhPT0gdGhpcy5mYXN0UmVjdERpcnR5KSB7XG4gICAgICAgICAgICB0aGlzLmZhc3RSZWN0RGlydHkgPSB0aGlzLmRpcnR5O1xuICAgICAgICAgICAgdGhpcy5fZmFzdFJlY3QgPSB0aGlzLmlzRmFzdFJlY3QoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRPRE8gdGhpcyBjaGVjayBjYW4gYmUgbW92ZWQgdG8gZGlydHk/XG4gICAgICAgIGlmICh0aGlzLl9mYXN0UmVjdCkge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyU3ByaXRlUmVjdChyZW5kZXJlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZW5kZXJlci5zZXRPYmplY3RSZW5kZXJlcihyZW5kZXJlci5wbHVnaW5zLmdyYXBoaWNzKTtcbiAgICAgICAgICAgIHJlbmRlcmVyLnBsdWdpbnMuZ3JhcGhpY3MucmVuZGVyKHRoaXMpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgYSBzcHJpdGUgcmVjdGFuZ2xlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1BJWEkuV2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXJcbiAgICAgKi9cblxuXG4gICAgR3JhcGhpY3MucHJvdG90eXBlLl9yZW5kZXJTcHJpdGVSZWN0ID0gZnVuY3Rpb24gX3JlbmRlclNwcml0ZVJlY3QocmVuZGVyZXIpIHtcbiAgICAgICAgdmFyIHJlY3QgPSB0aGlzLmdyYXBoaWNzRGF0YVswXS5zaGFwZTtcblxuICAgICAgICBpZiAoIXRoaXMuX3Nwcml0ZVJlY3QpIHtcbiAgICAgICAgICAgIHRoaXMuX3Nwcml0ZVJlY3QgPSBuZXcgX1Nwcml0ZTIuZGVmYXVsdChuZXcgX1RleHR1cmUyLmRlZmF1bHQoX1RleHR1cmUyLmRlZmF1bHQuV0hJVEUpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzcHJpdGUgPSB0aGlzLl9zcHJpdGVSZWN0O1xuICAgICAgICB2YXIgZmlsbENvbG9yID0gdGhpcy5ncmFwaGljc0RhdGFbMF0uZmlsbENvbG9yO1xuXG4gICAgICAgIGlmICh0aGlzLnRpbnQgPT09IDB4ZmZmZmZmKSB7XG4gICAgICAgICAgICBzcHJpdGUudGludCA9IGZpbGxDb2xvcjtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnRpbnQgIT09IHRoaXMuX3ByZXZSZWN0VGludCB8fCBmaWxsQ29sb3IgIT09IHRoaXMuX3ByZXZSZWN0RmlsbENvbG9yKSB7XG4gICAgICAgICAgICB2YXIgdDEgPSB0ZW1wQ29sb3IxO1xuICAgICAgICAgICAgdmFyIHQyID0gdGVtcENvbG9yMjtcblxuICAgICAgICAgICAgKDAsIF91dGlscy5oZXgycmdiKShmaWxsQ29sb3IsIHQxKTtcbiAgICAgICAgICAgICgwLCBfdXRpbHMuaGV4MnJnYikodGhpcy50aW50LCB0Mik7XG5cbiAgICAgICAgICAgIHQxWzBdICo9IHQyWzBdO1xuICAgICAgICAgICAgdDFbMV0gKj0gdDJbMV07XG4gICAgICAgICAgICB0MVsyXSAqPSB0MlsyXTtcblxuICAgICAgICAgICAgc3ByaXRlLnRpbnQgPSAoMCwgX3V0aWxzLnJnYjJoZXgpKHQxKTtcblxuICAgICAgICAgICAgdGhpcy5fcHJldlJlY3RUaW50ID0gdGhpcy50aW50O1xuICAgICAgICAgICAgdGhpcy5fcHJldlJlY3RGaWxsQ29sb3IgPSBmaWxsQ29sb3I7XG4gICAgICAgIH1cblxuICAgICAgICBzcHJpdGUuYWxwaGEgPSB0aGlzLmdyYXBoaWNzRGF0YVswXS5maWxsQWxwaGE7XG4gICAgICAgIHNwcml0ZS53b3JsZEFscGhhID0gdGhpcy53b3JsZEFscGhhICogc3ByaXRlLmFscGhhO1xuICAgICAgICBzcHJpdGUuYmxlbmRNb2RlID0gdGhpcy5ibGVuZE1vZGU7XG5cbiAgICAgICAgc3ByaXRlLl90ZXh0dXJlLl9mcmFtZS53aWR0aCA9IHJlY3Qud2lkdGg7XG4gICAgICAgIHNwcml0ZS5fdGV4dHVyZS5fZnJhbWUuaGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XG5cbiAgICAgICAgc3ByaXRlLnRyYW5zZm9ybS53b3JsZFRyYW5zZm9ybSA9IHRoaXMudHJhbnNmb3JtLndvcmxkVHJhbnNmb3JtO1xuXG4gICAgICAgIHNwcml0ZS5hbmNob3Iuc2V0KC1yZWN0LnggLyByZWN0LndpZHRoLCAtcmVjdC55IC8gcmVjdC5oZWlnaHQpO1xuICAgICAgICBzcHJpdGUuX29uQW5jaG9yVXBkYXRlKCk7XG5cbiAgICAgICAgc3ByaXRlLl9yZW5kZXJXZWJHTChyZW5kZXJlcik7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgdGhlIG9iamVjdCB1c2luZyB0aGUgQ2FudmFzIHJlbmRlcmVyXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7UElYSS5DYW52YXNSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXJcbiAgICAgKi9cblxuXG4gICAgR3JhcGhpY3MucHJvdG90eXBlLl9yZW5kZXJDYW52YXMgPSBmdW5jdGlvbiBfcmVuZGVyQ2FudmFzKHJlbmRlcmVyKSB7XG4gICAgICAgIGlmICh0aGlzLmlzTWFzayA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVuZGVyZXIucGx1Z2lucy5ncmFwaGljcy5yZW5kZXIodGhpcyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgYm91bmRzIG9mIHRoZSBncmFwaGljIHNoYXBlIGFzIGEgcmVjdGFuZ2xlIG9iamVjdFxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuXG4gICAgR3JhcGhpY3MucHJvdG90eXBlLl9jYWxjdWxhdGVCb3VuZHMgPSBmdW5jdGlvbiBfY2FsY3VsYXRlQm91bmRzKCkge1xuICAgICAgICBpZiAodGhpcy5ib3VuZHNEaXJ0eSAhPT0gdGhpcy5kaXJ0eSkge1xuICAgICAgICAgICAgdGhpcy5ib3VuZHNEaXJ0eSA9IHRoaXMuZGlydHk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUxvY2FsQm91bmRzKCk7XG5cbiAgICAgICAgICAgIHRoaXMuY2FjaGVkU3ByaXRlRGlydHkgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxiID0gdGhpcy5fbG9jYWxCb3VuZHM7XG5cbiAgICAgICAgdGhpcy5fYm91bmRzLmFkZEZyYW1lKHRoaXMudHJhbnNmb3JtLCBsYi5taW5YLCBsYi5taW5ZLCBsYi5tYXhYLCBsYi5tYXhZKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGVzdHMgaWYgYSBwb2ludCBpcyBpbnNpZGUgdGhpcyBncmFwaGljcyBvYmplY3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5Qb2ludH0gcG9pbnQgLSB0aGUgcG9pbnQgdG8gdGVzdFxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IHRoZSByZXN1bHQgb2YgdGhlIHRlc3RcbiAgICAgKi9cblxuXG4gICAgR3JhcGhpY3MucHJvdG90eXBlLmNvbnRhaW5zUG9pbnQgPSBmdW5jdGlvbiBjb250YWluc1BvaW50KHBvaW50KSB7XG4gICAgICAgIHRoaXMud29ybGRUcmFuc2Zvcm0uYXBwbHlJbnZlcnNlKHBvaW50LCB0ZW1wUG9pbnQpO1xuXG4gICAgICAgIHZhciBncmFwaGljc0RhdGEgPSB0aGlzLmdyYXBoaWNzRGF0YTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyYXBoaWNzRGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBncmFwaGljc0RhdGFbaV07XG5cbiAgICAgICAgICAgIGlmICghZGF0YS5maWxsKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIG9ubHkgZGVhbCB3aXRoIGZpbGxzLi5cbiAgICAgICAgICAgIGlmIChkYXRhLnNoYXBlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuc2hhcGUuY29udGFpbnModGVtcFBvaW50LngsIHRlbXBQb2ludC55KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5ob2xlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGRhdGEuaG9sZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhvbGUgPSBkYXRhLmhvbGVzW19pXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChob2xlLmNvbnRhaW5zKHRlbXBQb2ludC54LCB0ZW1wUG9pbnQueSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBib3VuZHMgb2YgdGhlIG9iamVjdFxuICAgICAqXG4gICAgICovXG5cblxuICAgIEdyYXBoaWNzLnByb3RvdHlwZS51cGRhdGVMb2NhbEJvdW5kcyA9IGZ1bmN0aW9uIHVwZGF0ZUxvY2FsQm91bmRzKCkge1xuICAgICAgICB2YXIgbWluWCA9IEluZmluaXR5O1xuICAgICAgICB2YXIgbWF4WCA9IC1JbmZpbml0eTtcblxuICAgICAgICB2YXIgbWluWSA9IEluZmluaXR5O1xuICAgICAgICB2YXIgbWF4WSA9IC1JbmZpbml0eTtcblxuICAgICAgICBpZiAodGhpcy5ncmFwaGljc0RhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgc2hhcGUgPSAwO1xuICAgICAgICAgICAgdmFyIHggPSAwO1xuICAgICAgICAgICAgdmFyIHkgPSAwO1xuICAgICAgICAgICAgdmFyIHcgPSAwO1xuICAgICAgICAgICAgdmFyIGggPSAwO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZ3JhcGhpY3NEYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmdyYXBoaWNzRGF0YVtpXTtcbiAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IGRhdGEudHlwZTtcbiAgICAgICAgICAgICAgICB2YXIgbGluZVdpZHRoID0gZGF0YS5saW5lV2lkdGg7XG4gICAgICAgICAgICAgICAgdmFyIGxpbmVBbGlnbm1lbnQgPSBkYXRhLmxpbmVBbGlnbm1lbnQ7XG5cbiAgICAgICAgICAgICAgICB2YXIgbGluZU9mZnNldCA9IGxpbmVXaWR0aCAqIGxpbmVBbGlnbm1lbnQ7XG5cbiAgICAgICAgICAgICAgICBzaGFwZSA9IGRhdGEuc2hhcGU7XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gX2NvbnN0LlNIQVBFUy5SRUNUIHx8IHR5cGUgPT09IF9jb25zdC5TSEFQRVMuUlJFQykge1xuICAgICAgICAgICAgICAgICAgICB4ID0gc2hhcGUueCAtIGxpbmVPZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgIHkgPSBzaGFwZS55IC0gbGluZU9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgdyA9IHNoYXBlLndpZHRoICsgbGluZU9mZnNldCAqIDI7XG4gICAgICAgICAgICAgICAgICAgIGggPSBzaGFwZS5oZWlnaHQgKyBsaW5lT2Zmc2V0ICogMjtcblxuICAgICAgICAgICAgICAgICAgICBtaW5YID0geCA8IG1pblggPyB4IDogbWluWDtcbiAgICAgICAgICAgICAgICAgICAgbWF4WCA9IHggKyB3ID4gbWF4WCA/IHggKyB3IDogbWF4WDtcblxuICAgICAgICAgICAgICAgICAgICBtaW5ZID0geSA8IG1pblkgPyB5IDogbWluWTtcbiAgICAgICAgICAgICAgICAgICAgbWF4WSA9IHkgKyBoID4gbWF4WSA/IHkgKyBoIDogbWF4WTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IF9jb25zdC5TSEFQRVMuQ0lSQykge1xuICAgICAgICAgICAgICAgICAgICB4ID0gc2hhcGUueDtcbiAgICAgICAgICAgICAgICAgICAgeSA9IHNoYXBlLnk7XG4gICAgICAgICAgICAgICAgICAgIHcgPSBzaGFwZS5yYWRpdXMgKyBsaW5lT2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICBoID0gc2hhcGUucmFkaXVzICsgbGluZU9mZnNldDtcblxuICAgICAgICAgICAgICAgICAgICBtaW5YID0geCAtIHcgPCBtaW5YID8geCAtIHcgOiBtaW5YO1xuICAgICAgICAgICAgICAgICAgICBtYXhYID0geCArIHcgPiBtYXhYID8geCArIHcgOiBtYXhYO1xuXG4gICAgICAgICAgICAgICAgICAgIG1pblkgPSB5IC0gaCA8IG1pblkgPyB5IC0gaCA6IG1pblk7XG4gICAgICAgICAgICAgICAgICAgIG1heFkgPSB5ICsgaCA+IG1heFkgPyB5ICsgaCA6IG1heFk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBfY29uc3QuU0hBUEVTLkVMSVApIHtcbiAgICAgICAgICAgICAgICAgICAgeCA9IHNoYXBlLng7XG4gICAgICAgICAgICAgICAgICAgIHkgPSBzaGFwZS55O1xuICAgICAgICAgICAgICAgICAgICB3ID0gc2hhcGUud2lkdGggKyBsaW5lT2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICBoID0gc2hhcGUuaGVpZ2h0ICsgbGluZU9mZnNldDtcblxuICAgICAgICAgICAgICAgICAgICBtaW5YID0geCAtIHcgPCBtaW5YID8geCAtIHcgOiBtaW5YO1xuICAgICAgICAgICAgICAgICAgICBtYXhYID0geCArIHcgPiBtYXhYID8geCArIHcgOiBtYXhYO1xuXG4gICAgICAgICAgICAgICAgICAgIG1pblkgPSB5IC0gaCA8IG1pblkgPyB5IC0gaCA6IG1pblk7XG4gICAgICAgICAgICAgICAgICAgIG1heFkgPSB5ICsgaCA+IG1heFkgPyB5ICsgaCA6IG1heFk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUE9MWVxuICAgICAgICAgICAgICAgICAgICB2YXIgcG9pbnRzID0gc2hhcGUucG9pbnRzO1xuICAgICAgICAgICAgICAgICAgICB2YXIgeDIgPSAwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgeTIgPSAwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZHggPSAwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZHkgPSAwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcncgPSAwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmggPSAwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3ggPSAwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3kgPSAwO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqICsgMiA8IHBvaW50cy5sZW5ndGg7IGogKz0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IHBvaW50c1tqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBwb2ludHNbaiArIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgeDIgPSBwb2ludHNbaiArIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgeTIgPSBwb2ludHNbaiArIDNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZHggPSBNYXRoLmFicyh4MiAtIHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZHkgPSBNYXRoLmFicyh5MiAtIHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaCA9IGxpbmVPZmZzZXQgKiAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgdyA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3IDwgMWUtOSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBydyA9IChoIC8gdyAqIGR5ICsgZHgpIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJoID0gKGggLyB3ICogZHggKyBkeSkgLyAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3ggPSAoeDIgKyB4KSAvIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjeSA9ICh5MiArIHkpIC8gMjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgbWluWCA9IGN4IC0gcncgPCBtaW5YID8gY3ggLSBydyA6IG1pblg7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhYID0gY3ggKyBydyA+IG1heFggPyBjeCArIHJ3IDogbWF4WDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgbWluWSA9IGN5IC0gcmggPCBtaW5ZID8gY3kgLSByaCA6IG1pblk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhZID0gY3kgKyByaCA+IG1heFkgPyBjeSArIHJoIDogbWF4WTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1pblggPSAwO1xuICAgICAgICAgICAgbWF4WCA9IDA7XG4gICAgICAgICAgICBtaW5ZID0gMDtcbiAgICAgICAgICAgIG1heFkgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBhZGRpbmcgPSB0aGlzLmJvdW5kc1BhZGRpbmc7XG5cbiAgICAgICAgdGhpcy5fbG9jYWxCb3VuZHMubWluWCA9IG1pblggLSBwYWRkaW5nO1xuICAgICAgICB0aGlzLl9sb2NhbEJvdW5kcy5tYXhYID0gbWF4WCArIHBhZGRpbmc7XG5cbiAgICAgICAgdGhpcy5fbG9jYWxCb3VuZHMubWluWSA9IG1pblkgLSBwYWRkaW5nO1xuICAgICAgICB0aGlzLl9sb2NhbEJvdW5kcy5tYXhZID0gbWF4WSArIHBhZGRpbmc7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERyYXdzIHRoZSBnaXZlbiBzaGFwZSB0byB0aGlzIEdyYXBoaWNzIG9iamVjdC4gQ2FuIGJlIGFueSBvZiBDaXJjbGUsIFJlY3RhbmdsZSwgRWxsaXBzZSwgTGluZSBvciBQb2x5Z29uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLkNpcmNsZXxQSVhJLkVsbGlwc2V8UElYSS5Qb2x5Z29ufFBJWEkuUmVjdGFuZ2xlfFBJWEkuUm91bmRlZFJlY3RhbmdsZX0gc2hhcGUgLSBUaGUgc2hhcGUgb2JqZWN0IHRvIGRyYXcuXG4gICAgICogQHJldHVybiB7UElYSS5HcmFwaGljc0RhdGF9IFRoZSBnZW5lcmF0ZWQgR3JhcGhpY3NEYXRhIG9iamVjdC5cbiAgICAgKi9cblxuXG4gICAgR3JhcGhpY3MucHJvdG90eXBlLmRyYXdTaGFwZSA9IGZ1bmN0aW9uIGRyYXdTaGFwZShzaGFwZSkge1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50UGF0aCkge1xuICAgICAgICAgICAgLy8gY2hlY2sgY3VycmVudCBwYXRoIVxuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudFBhdGguc2hhcGUucG9pbnRzLmxlbmd0aCA8PSAyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncmFwaGljc0RhdGEucG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmN1cnJlbnRQYXRoID0gbnVsbDtcblxuICAgICAgICB2YXIgZGF0YSA9IG5ldyBfR3JhcGhpY3NEYXRhMi5kZWZhdWx0KHRoaXMubGluZVdpZHRoLCB0aGlzLmxpbmVDb2xvciwgdGhpcy5saW5lQWxwaGEsIHRoaXMuZmlsbENvbG9yLCB0aGlzLmZpbGxBbHBoYSwgdGhpcy5maWxsaW5nLCB0aGlzLm5hdGl2ZUxpbmVzLCBzaGFwZSwgdGhpcy5saW5lQWxpZ25tZW50KTtcblxuICAgICAgICB0aGlzLmdyYXBoaWNzRGF0YS5wdXNoKGRhdGEpO1xuXG4gICAgICAgIGlmIChkYXRhLnR5cGUgPT09IF9jb25zdC5TSEFQRVMuUE9MWSkge1xuICAgICAgICAgICAgZGF0YS5zaGFwZS5jbG9zZWQgPSBkYXRhLnNoYXBlLmNsb3NlZDtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFBhdGggPSBkYXRhO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5kaXJ0eSsrO1xuXG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSBjYW52YXMgdGV4dHVyZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsZU1vZGUgLSBUaGUgc2NhbGUgbW9kZSBvZiB0aGUgdGV4dHVyZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiAtIFRoZSByZXNvbHV0aW9uIG9mIHRoZSB0ZXh0dXJlLlxuICAgICAqIEByZXR1cm4ge1BJWEkuVGV4dHVyZX0gVGhlIG5ldyB0ZXh0dXJlLlxuICAgICAqL1xuXG5cbiAgICBHcmFwaGljcy5wcm90b3R5cGUuZ2VuZXJhdGVDYW52YXNUZXh0dXJlID0gZnVuY3Rpb24gZ2VuZXJhdGVDYW52YXNUZXh0dXJlKHNjYWxlTW9kZSkge1xuICAgICAgICB2YXIgcmVzb2x1dGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMTtcblxuICAgICAgICB2YXIgYm91bmRzID0gdGhpcy5nZXRMb2NhbEJvdW5kcygpO1xuXG4gICAgICAgIHZhciBjYW52YXNCdWZmZXIgPSBfUmVuZGVyVGV4dHVyZTIuZGVmYXVsdC5jcmVhdGUoYm91bmRzLndpZHRoLCBib3VuZHMuaGVpZ2h0LCBzY2FsZU1vZGUsIHJlc29sdXRpb24pO1xuXG4gICAgICAgIGlmICghY2FudmFzUmVuZGVyZXIpIHtcbiAgICAgICAgICAgIGNhbnZhc1JlbmRlcmVyID0gbmV3IF9DYW52YXNSZW5kZXJlcjIuZGVmYXVsdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50cmFuc2Zvcm0udXBkYXRlTG9jYWxUcmFuc2Zvcm0oKTtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0ubG9jYWxUcmFuc2Zvcm0uY29weSh0ZW1wTWF0cml4KTtcblxuICAgICAgICB0ZW1wTWF0cml4LmludmVydCgpO1xuXG4gICAgICAgIHRlbXBNYXRyaXgudHggLT0gYm91bmRzLng7XG4gICAgICAgIHRlbXBNYXRyaXgudHkgLT0gYm91bmRzLnk7XG5cbiAgICAgICAgY2FudmFzUmVuZGVyZXIucmVuZGVyKHRoaXMsIGNhbnZhc0J1ZmZlciwgdHJ1ZSwgdGVtcE1hdHJpeCk7XG5cbiAgICAgICAgdmFyIHRleHR1cmUgPSBfVGV4dHVyZTIuZGVmYXVsdC5mcm9tQ2FudmFzKGNhbnZhc0J1ZmZlci5iYXNlVGV4dHVyZS5fY2FudmFzUmVuZGVyVGFyZ2V0LmNhbnZhcywgc2NhbGVNb2RlLCAnZ3JhcGhpY3MnKTtcblxuICAgICAgICB0ZXh0dXJlLmJhc2VUZXh0dXJlLnJlc29sdXRpb24gPSByZXNvbHV0aW9uO1xuICAgICAgICB0ZXh0dXJlLmJhc2VUZXh0dXJlLnVwZGF0ZSgpO1xuXG4gICAgICAgIHJldHVybiB0ZXh0dXJlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDbG9zZXMgdGhlIGN1cnJlbnQgcGF0aC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1BJWEkuR3JhcGhpY3N9IFJldHVybnMgaXRzZWxmLlxuICAgICAqL1xuXG5cbiAgICBHcmFwaGljcy5wcm90b3R5cGUuY2xvc2VQYXRoID0gZnVuY3Rpb24gY2xvc2VQYXRoKCkge1xuICAgICAgICAvLyBvayBzbyBjbG9zZSBwYXRoIGFzc3VtZXMgbmV4dCBvbmUgaXMgYSBob2xlIVxuICAgICAgICB2YXIgY3VycmVudFBhdGggPSB0aGlzLmN1cnJlbnRQYXRoO1xuXG4gICAgICAgIGlmIChjdXJyZW50UGF0aCAmJiBjdXJyZW50UGF0aC5zaGFwZSkge1xuICAgICAgICAgICAgY3VycmVudFBhdGguc2hhcGUuY2xvc2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgaG9sZSBpbiB0aGUgY3VycmVudCBwYXRoLlxuICAgICAqXG4gICAgICogQHJldHVybiB7UElYSS5HcmFwaGljc30gUmV0dXJucyBpdHNlbGYuXG4gICAgICovXG5cblxuICAgIEdyYXBoaWNzLnByb3RvdHlwZS5hZGRIb2xlID0gZnVuY3Rpb24gYWRkSG9sZSgpIHtcbiAgICAgICAgLy8gdGhpcyBpcyBhIGhvbGUhXG4gICAgICAgIHZhciBob2xlID0gdGhpcy5ncmFwaGljc0RhdGEucG9wKCk7XG5cbiAgICAgICAgdGhpcy5jdXJyZW50UGF0aCA9IHRoaXMuZ3JhcGhpY3NEYXRhW3RoaXMuZ3JhcGhpY3NEYXRhLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgIHRoaXMuY3VycmVudFBhdGguYWRkSG9sZShob2xlLnNoYXBlKTtcbiAgICAgICAgdGhpcy5jdXJyZW50UGF0aCA9IG51bGw7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIHRoZSBHcmFwaGljcyBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdHxib29sZWFufSBbb3B0aW9uc10gLSBPcHRpb25zIHBhcmFtZXRlci4gQSBib29sZWFuIHdpbGwgYWN0IGFzIGlmIGFsbFxuICAgICAqICBvcHRpb25zIGhhdmUgYmVlbiBzZXQgdG8gdGhhdCB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY2hpbGRyZW49ZmFsc2VdIC0gaWYgc2V0IHRvIHRydWUsIGFsbCB0aGUgY2hpbGRyZW4gd2lsbCBoYXZlXG4gICAgICogIHRoZWlyIGRlc3Ryb3kgbWV0aG9kIGNhbGxlZCBhcyB3ZWxsLiAnb3B0aW9ucycgd2lsbCBiZSBwYXNzZWQgb24gdG8gdGhvc2UgY2FsbHMuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50ZXh0dXJlPWZhbHNlXSAtIE9ubHkgdXNlZCBmb3IgY2hpbGQgU3ByaXRlcyBpZiBvcHRpb25zLmNoaWxkcmVuIGlzIHNldCB0byB0cnVlXG4gICAgICogIFNob3VsZCBpdCBkZXN0cm95IHRoZSB0ZXh0dXJlIG9mIHRoZSBjaGlsZCBzcHJpdGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmJhc2VUZXh0dXJlPWZhbHNlXSAtIE9ubHkgdXNlZCBmb3IgY2hpbGQgU3ByaXRlcyBpZiBvcHRpb25zLmNoaWxkcmVuIGlzIHNldCB0byB0cnVlXG4gICAgICogIFNob3VsZCBpdCBkZXN0cm95IHRoZSBiYXNlIHRleHR1cmUgb2YgdGhlIGNoaWxkIHNwcml0ZVxuICAgICAqL1xuXG5cbiAgICBHcmFwaGljcy5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3kob3B0aW9ucykge1xuICAgICAgICBfQ29udGFpbmVyLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgICAgICAgLy8gZGVzdHJveSBlYWNoIG9mIHRoZSBHcmFwaGljc0RhdGEgb2JqZWN0c1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZ3JhcGhpY3NEYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB0aGlzLmdyYXBoaWNzRGF0YVtpXS5kZXN0cm95KCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmb3IgZWFjaCB3ZWJnbCBkYXRhIGVudHJ5LCBkZXN0cm95IHRoZSBXZWJHTEdyYXBoaWNzRGF0YVxuICAgICAgICBmb3IgKHZhciBpZCBpbiB0aGlzLl93ZWJHTCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLl93ZWJHTFtpZF0uZGF0YS5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlYkdMW2lkXS5kYXRhW2pdLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9zcHJpdGVSZWN0KSB7XG4gICAgICAgICAgICB0aGlzLl9zcHJpdGVSZWN0LmRlc3Ryb3koKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZ3JhcGhpY3NEYXRhID0gbnVsbDtcblxuICAgICAgICB0aGlzLmN1cnJlbnRQYXRoID0gbnVsbDtcbiAgICAgICAgdGhpcy5fd2ViR0wgPSBudWxsO1xuICAgICAgICB0aGlzLl9sb2NhbEJvdW5kcyA9IG51bGw7XG4gICAgfTtcblxuICAgIHJldHVybiBHcmFwaGljcztcbn0oX0NvbnRhaW5lcjMuZGVmYXVsdCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEdyYXBoaWNzO1xuXG5cbkdyYXBoaWNzLl9TUFJJVEVfVEVYVFVSRSA9IG51bGw7XG5cbi8qKlxuICogR3JhcGhpY3MgY3VydmVzIHJlc29sdXRpb24gc2V0dGluZ3MuIElmIGBhZGFwdGl2ZWAgZmxhZyBpcyBzZXQgdG8gYHRydWVgLFxuICogdGhlIHJlc29sdXRpb24gaXMgY2FsY3VsYXRlZCBiYXNlZCBvbiB0aGUgY3VydmUncyBsZW5ndGggdG8gZW5zdXJlIGJldHRlciB2aXN1YWwgcXVhbGl0eS5cbiAqIEFkYXB0aXZlIGRyYXcgd29ya3Mgd2l0aCBgYmV6aWVyQ3VydmVUb2AgYW5kIGBxdWFkcmF0aWNDdXJ2ZVRvYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAY29uc3RhbnRcbiAqIEBtZW1iZXJvZiBQSVhJLkdyYXBoaWNzXG4gKiBAbmFtZSBDVVJWRVNcbiAqIEB0eXBlIHtvYmplY3R9XG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGFkYXB0aXZlPWZhbHNlIC0gZmxhZyBpbmRpY2F0aW5nIGlmIHRoZSByZXNvbHV0aW9uIHNob3VsZCBiZSBhZGFwdGl2ZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IG1heExlbmd0aD0xMCAtIG1heGltYWwgbGVuZ3RoIG9mIGEgc2luZ2xlIHNlZ21lbnQgb2YgdGhlIGN1cnZlIChpZiBhZGFwdGl2ZSA9IGZhbHNlLCBpZ25vcmVkKVxuICogQHByb3BlcnR5IHtudW1iZXJ9IG1pblNlZ21lbnRzPTggLSBtaW5pbWFsIG51bWJlciBvZiBzZWdtZW50cyBpbiB0aGUgY3VydmUgKGlmIGFkYXB0aXZlID0gZmFsc2UsIGlnbm9yZWQpXG4gKiBAcHJvcGVydHkge251bWJlcn0gbWF4U2VnbWVudHM9MjA0OCAtIG1heGltYWwgbnVtYmVyIG9mIHNlZ21lbnRzIGluIHRoZSBjdXJ2ZSAoaWYgYWRhcHRpdmUgPSBmYWxzZSwgaWdub3JlZClcbiAqL1xuR3JhcGhpY3MuQ1VSVkVTID0ge1xuICAgIGFkYXB0aXZlOiBmYWxzZSxcbiAgICBtYXhMZW5ndGg6IDEwLFxuICAgIG1pblNlZ21lbnRzOiA4LFxuICAgIG1heFNlZ21lbnRzOiAyMDQ4XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R3JhcGhpY3MuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8qKlxuICogQSBHcmFwaGljc0RhdGEgb2JqZWN0LlxuICpcbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIFBJWElcbiAqL1xudmFyIEdyYXBoaWNzRGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBsaW5lV2lkdGggLSB0aGUgd2lkdGggb2YgdGhlIGxpbmUgdG8gZHJhd1xuICAgKiBAcGFyYW0ge251bWJlcn0gbGluZUNvbG9yIC0gdGhlIGNvbG9yIG9mIHRoZSBsaW5lIHRvIGRyYXdcbiAgICogQHBhcmFtIHtudW1iZXJ9IGxpbmVBbHBoYSAtIHRoZSBhbHBoYSBvZiB0aGUgbGluZSB0byBkcmF3XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmaWxsQ29sb3IgLSB0aGUgY29sb3Igb2YgdGhlIGZpbGxcbiAgICogQHBhcmFtIHtudW1iZXJ9IGZpbGxBbHBoYSAtIHRoZSBhbHBoYSBvZiB0aGUgZmlsbFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZpbGwgLSB3aGV0aGVyIG9yIG5vdCB0aGUgc2hhcGUgaXMgZmlsbGVkIHdpdGggYSBjb2xvdXJcbiAgICogQHBhcmFtIHtib29sZWFufSBuYXRpdmVMaW5lcyAtIHRoZSBtZXRob2QgZm9yIGRyYXdpbmcgbGluZXNcbiAgICogQHBhcmFtIHtQSVhJLkNpcmNsZXxQSVhJLlJlY3RhbmdsZXxQSVhJLkVsbGlwc2V8UElYSS5Qb2x5Z29ufSBzaGFwZSAtIFRoZSBzaGFwZSBvYmplY3QgdG8gZHJhdy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGxpbmVBbGlnbm1lbnQgLSB0aGUgYWxpZ25tZW50IG9mIHRoZSBsaW5lLlxuICAgKi9cbiAgZnVuY3Rpb24gR3JhcGhpY3NEYXRhKGxpbmVXaWR0aCwgbGluZUNvbG9yLCBsaW5lQWxwaGEsIGZpbGxDb2xvciwgZmlsbEFscGhhLCBmaWxsLCBuYXRpdmVMaW5lcywgc2hhcGUsIGxpbmVBbGlnbm1lbnQpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgR3JhcGhpY3NEYXRhKTtcblxuICAgIC8qKlxuICAgICAqIHRoZSB3aWR0aCBvZiB0aGUgbGluZSB0byBkcmF3XG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubGluZVdpZHRoID0gbGluZVdpZHRoO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGFsaWdubWVudCBvZiBhbnkgbGluZXMgZHJhd24gKDAuNSA9IG1pZGRsZSwgMSA9IG91dHRlciwgMCA9IGlubmVyKS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgdGhpcy5saW5lQWxpZ25tZW50ID0gbGluZUFsaWdubWVudDtcblxuICAgIC8qKlxuICAgICAqIGlmIHRydWUgdGhlIGxpZW5zIHdpbGwgYmUgZHJhdyB1c2luZyBMSU5FUyBpbnN0ZWFkIG9mIFRSSUFOR0xFX1NUUklQXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLm5hdGl2ZUxpbmVzID0gbmF0aXZlTGluZXM7XG5cbiAgICAvKipcbiAgICAgKiB0aGUgY29sb3Igb2YgdGhlIGxpbmUgdG8gZHJhd1xuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmxpbmVDb2xvciA9IGxpbmVDb2xvcjtcblxuICAgIC8qKlxuICAgICAqIHRoZSBhbHBoYSBvZiB0aGUgbGluZSB0byBkcmF3XG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubGluZUFscGhhID0gbGluZUFscGhhO1xuXG4gICAgLyoqXG4gICAgICogY2FjaGVkIHRpbnQgb2YgdGhlIGxpbmUgdG8gZHJhd1xuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2xpbmVUaW50ID0gbGluZUNvbG9yO1xuXG4gICAgLyoqXG4gICAgICogdGhlIGNvbG9yIG9mIHRoZSBmaWxsXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZmlsbENvbG9yID0gZmlsbENvbG9yO1xuXG4gICAgLyoqXG4gICAgICogdGhlIGFscGhhIG9mIHRoZSBmaWxsXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZmlsbEFscGhhID0gZmlsbEFscGhhO1xuXG4gICAgLyoqXG4gICAgICogY2FjaGVkIHRpbnQgb2YgdGhlIGZpbGxcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9maWxsVGludCA9IGZpbGxDb2xvcjtcblxuICAgIC8qKlxuICAgICAqIHdoZXRoZXIgb3Igbm90IHRoZSBzaGFwZSBpcyBmaWxsZWQgd2l0aCBhIGNvbG91clxuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5maWxsID0gZmlsbDtcblxuICAgIHRoaXMuaG9sZXMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzaGFwZSBvYmplY3QgdG8gZHJhdy5cbiAgICAgKiBAbWVtYmVyIHtQSVhJLkNpcmNsZXxQSVhJLkVsbGlwc2V8UElYSS5Qb2x5Z29ufFBJWEkuUmVjdGFuZ2xlfFBJWEkuUm91bmRlZFJlY3RhbmdsZX1cbiAgICAgKi9cbiAgICB0aGlzLnNoYXBlID0gc2hhcGU7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBvZiB0aGUgc2hhcGUsIHNlZSB0aGUgQ29uc3QuU2hhcGVzIGZpbGUgZm9yIGFsbCB0aGUgZXhpc3RpbmcgdHlwZXMsXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMudHlwZSA9IHNoYXBlLnR5cGU7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBHcmFwaGljc0RhdGEgb2JqZWN0IHdpdGggdGhlIHNhbWUgdmFsdWVzIGFzIHRoaXMgb25lLlxuICAgKlxuICAgKiBAcmV0dXJuIHtQSVhJLkdyYXBoaWNzRGF0YX0gQ2xvbmVkIEdyYXBoaWNzRGF0YSBvYmplY3RcbiAgICovXG5cblxuICBHcmFwaGljc0RhdGEucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBHcmFwaGljc0RhdGEodGhpcy5saW5lV2lkdGgsIHRoaXMubGluZUNvbG9yLCB0aGlzLmxpbmVBbHBoYSwgdGhpcy5maWxsQ29sb3IsIHRoaXMuZmlsbEFscGhhLCB0aGlzLmZpbGwsIHRoaXMubmF0aXZlTGluZXMsIHRoaXMuc2hhcGUsIHRoaXMubGluZUFsaWdubWVudCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBob2xlIHRvIHRoZSBzaGFwZS5cbiAgICpcbiAgICogQHBhcmFtIHtQSVhJLlJlY3RhbmdsZXxQSVhJLkNpcmNsZX0gc2hhcGUgLSBUaGUgc2hhcGUgb2YgdGhlIGhvbGUuXG4gICAqL1xuXG5cbiAgR3JhcGhpY3NEYXRhLnByb3RvdHlwZS5hZGRIb2xlID0gZnVuY3Rpb24gYWRkSG9sZShzaGFwZSkge1xuICAgIHRoaXMuaG9sZXMucHVzaChzaGFwZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIERlc3Ryb3lzIHRoZSBHcmFwaGljcyBkYXRhLlxuICAgKi9cblxuXG4gIEdyYXBoaWNzRGF0YS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5zaGFwZSA9IG51bGw7XG4gICAgdGhpcy5ob2xlcyA9IG51bGw7XG4gIH07XG5cbiAgcmV0dXJuIEdyYXBoaWNzRGF0YTtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gR3JhcGhpY3NEYXRhO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R3JhcGhpY3NEYXRhLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9DYW52YXNSZW5kZXJlciA9IHJlcXVpcmUoJy4uLy4uL3JlbmRlcmVycy9jYW52YXMvQ2FudmFzUmVuZGVyZXInKTtcblxudmFyIF9DYW52YXNSZW5kZXJlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9DYW52YXNSZW5kZXJlcik7XG5cbnZhciBfY29uc3QgPSByZXF1aXJlKCcuLi8uLi9jb25zdCcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vKipcbiAqIEBhdXRob3IgTWF0IEdyb3Zlc1xuICpcbiAqIEJpZyB0aGFua3MgdG8gdGhlIHZlcnkgY2xldmVyIE1hdHQgRGVzTGF1cmllcnMgPG1hdHRkZXNsPiBodHRwczovL2dpdGh1Yi5jb20vbWF0dGRlc2wvXG4gKiBmb3IgY3JlYXRpbmcgdGhlIG9yaWdpbmFsIFBpeGlKUyB2ZXJzaW9uIVxuICogQWxzbyBhIHRoYW5rcyB0byBodHRwczovL2dpdGh1Yi5jb20vYmNoZXZhbGllciBmb3IgdHdlYWtpbmcgdGhlIHRpbnQgYW5kIGFscGhhIHNvIHRoYXQgdGhleVxuICogbm93IHNoYXJlIDQgYnl0ZXMgb24gdGhlIHZlcnRleCBidWZmZXJcbiAqXG4gKiBIZWF2aWx5IGluc3BpcmVkIGJ5IExpYkdEWCdzIENhbnZhc0dyYXBoaWNzUmVuZGVyZXI6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vbGliZ2R4L2xpYmdkeC9ibG9iLzEuMC4wL2dkeC9zcmMvY29tL2JhZGxvZ2ljL2dkeC9ncmFwaGljcy9nbHV0aWxzL1NoYXBlUmVuZGVyZXIuamF2YVxuICovXG5cbi8qKlxuICogUmVuZGVyZXIgZGVkaWNhdGVkIHRvIGRyYXdpbmcgYW5kIGJhdGNoaW5nIGdyYXBoaWNzIG9iamVjdHMuXG4gKlxuICogQGNsYXNzXG4gKiBAcHJpdmF0ZVxuICogQG1lbWJlcm9mIFBJWElcbiAqL1xudmFyIENhbnZhc0dyYXBoaWNzUmVuZGVyZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtQSVhJLkNhbnZhc1JlbmRlcmVyfSByZW5kZXJlciAtIFRoZSBjdXJyZW50IFBJWEkgcmVuZGVyZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ2FudmFzR3JhcGhpY3NSZW5kZXJlcihyZW5kZXJlcikge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2FudmFzR3JhcGhpY3NSZW5kZXJlcik7XG5cbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgYSBHcmFwaGljcyBvYmplY3QgdG8gYSBjYW52YXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuR3JhcGhpY3N9IGdyYXBoaWNzIC0gdGhlIGFjdHVhbCBncmFwaGljcyBvYmplY3QgdG8gcmVuZGVyXG4gICAgICovXG5cblxuICAgIENhbnZhc0dyYXBoaWNzUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcihncmFwaGljcykge1xuICAgICAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyO1xuICAgICAgICB2YXIgY29udGV4dCA9IHJlbmRlcmVyLmNvbnRleHQ7XG4gICAgICAgIHZhciB3b3JsZEFscGhhID0gZ3JhcGhpY3Mud29ybGRBbHBoYTtcbiAgICAgICAgdmFyIHRyYW5zZm9ybSA9IGdyYXBoaWNzLnRyYW5zZm9ybS53b3JsZFRyYW5zZm9ybTtcbiAgICAgICAgdmFyIHJlc29sdXRpb24gPSByZW5kZXJlci5yZXNvbHV0aW9uO1xuXG4gICAgICAgIGNvbnRleHQuc2V0VHJhbnNmb3JtKHRyYW5zZm9ybS5hICogcmVzb2x1dGlvbiwgdHJhbnNmb3JtLmIgKiByZXNvbHV0aW9uLCB0cmFuc2Zvcm0uYyAqIHJlc29sdXRpb24sIHRyYW5zZm9ybS5kICogcmVzb2x1dGlvbiwgdHJhbnNmb3JtLnR4ICogcmVzb2x1dGlvbiwgdHJhbnNmb3JtLnR5ICogcmVzb2x1dGlvbik7XG5cbiAgICAgICAgLy8gdXBkYXRlIHRpbnQgaWYgZ3JhcGhpY3Mgd2FzIGRpcnR5XG4gICAgICAgIGlmIChncmFwaGljcy5jYW52YXNUaW50RGlydHkgIT09IGdyYXBoaWNzLmRpcnR5IHx8IGdyYXBoaWNzLl9wcmV2VGludCAhPT0gZ3JhcGhpY3MudGludCkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVHcmFwaGljc1RpbnQoZ3JhcGhpY3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVuZGVyZXIuc2V0QmxlbmRNb2RlKGdyYXBoaWNzLmJsZW5kTW9kZSk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncmFwaGljcy5ncmFwaGljc0RhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0gZ3JhcGhpY3MuZ3JhcGhpY3NEYXRhW2ldO1xuICAgICAgICAgICAgdmFyIHNoYXBlID0gZGF0YS5zaGFwZTtcblxuICAgICAgICAgICAgdmFyIGZpbGxDb2xvciA9IGRhdGEuX2ZpbGxUaW50O1xuICAgICAgICAgICAgdmFyIGxpbmVDb2xvciA9IGRhdGEuX2xpbmVUaW50O1xuXG4gICAgICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IGRhdGEubGluZVdpZHRoO1xuXG4gICAgICAgICAgICBpZiAoZGF0YS50eXBlID09PSBfY29uc3QuU0hBUEVTLlBPTFkpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHBvaW50cyA9IHNoYXBlLnBvaW50cztcbiAgICAgICAgICAgICAgICB2YXIgaG9sZXMgPSBkYXRhLmhvbGVzO1xuICAgICAgICAgICAgICAgIHZhciBvdXRlckFyZWEgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgdmFyIGlubmVyQXJlYSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICB2YXIgcHggPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgdmFyIHB5ID0gdm9pZCAwO1xuXG4gICAgICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8ocG9pbnRzWzBdLCBwb2ludHNbMV0pO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDI7IGogPCBwb2ludHMubGVuZ3RoOyBqICs9IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8ocG9pbnRzW2pdLCBwb2ludHNbaiArIDFdKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgZmlyc3QgYW5kIGxhc3QgcG9pbnQgYXJlIHRoZSBzYW1lIGNsb3NlIHRoZSBwYXRoIC0gbXVjaCBuZWF0ZXIgOilcbiAgICAgICAgICAgICAgICBpZiAoc2hhcGUuY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGhvbGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0ZXJBcmVhID0gMDtcbiAgICAgICAgICAgICAgICAgICAgcHggPSBwb2ludHNbMF07XG4gICAgICAgICAgICAgICAgICAgIHB5ID0gcG9pbnRzWzFdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaiA9IDI7IF9qICsgMiA8IHBvaW50cy5sZW5ndGg7IF9qICs9IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dGVyQXJlYSArPSAocG9pbnRzW19qXSAtIHB4KSAqIChwb2ludHNbX2ogKyAzXSAtIHB5KSAtIChwb2ludHNbX2ogKyAyXSAtIHB4KSAqIChwb2ludHNbX2ogKyAxXSAtIHB5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgaG9sZXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cyA9IGhvbGVzW2tdLnBvaW50cztcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwb2ludHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaW5uZXJBcmVhID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHB4ID0gcG9pbnRzWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHkgPSBwb2ludHNbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfajIgPSAyOyBfajIgKyAyIDwgcG9pbnRzLmxlbmd0aDsgX2oyICs9IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbm5lckFyZWEgKz0gKHBvaW50c1tfajJdIC0gcHgpICogKHBvaW50c1tfajIgKyAzXSAtIHB5KSAtIChwb2ludHNbX2oyICsgMl0gLSBweCkgKiAocG9pbnRzW19qMiArIDFdIC0gcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5uZXJBcmVhICogb3V0ZXJBcmVhIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKHBvaW50c1swXSwgcG9pbnRzWzFdKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9qMyA9IDI7IF9qMyA8IHBvaW50cy5sZW5ndGg7IF9qMyArPSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHBvaW50c1tfajNdLCBwb2ludHNbX2ozICsgMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8ocG9pbnRzW3BvaW50cy5sZW5ndGggLSAyXSwgcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfajQgPSBwb2ludHMubGVuZ3RoIC0gNDsgX2o0ID49IDA7IF9qNCAtPSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHBvaW50c1tfajRdLCBwb2ludHNbX2o0ICsgMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhvbGVzW2tdLmNsb3NlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChkYXRhLmZpbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IGRhdGEuZmlsbEFscGhhICogd29ybGRBbHBoYTtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSAnIycgKyAoJzAwMDAwJyArIChmaWxsQ29sb3IgfCAwKS50b1N0cmluZygxNikpLnN1YnN0cigtNik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZmlsbCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5saW5lV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IGRhdGEubGluZUFscGhhICogd29ybGRBbHBoYTtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9ICcjJyArICgnMDAwMDAnICsgKGxpbmVDb2xvciB8IDApLnRvU3RyaW5nKDE2KSkuc3Vic3RyKC02KTtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRhdGEudHlwZSA9PT0gX2NvbnN0LlNIQVBFUy5SRUNUKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuZmlsbENvbG9yIHx8IGRhdGEuZmlsbENvbG9yID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZ2xvYmFsQWxwaGEgPSBkYXRhLmZpbGxBbHBoYSAqIHdvcmxkQWxwaGE7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gJyMnICsgKCcwMDAwMCcgKyAoZmlsbENvbG9yIHwgMCkudG9TdHJpbmcoMTYpKS5zdWJzdHIoLTYpO1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmZpbGxSZWN0KHNoYXBlLngsIHNoYXBlLnksIHNoYXBlLndpZHRoLCBzaGFwZS5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5saW5lV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IGRhdGEubGluZUFscGhhICogd29ybGRBbHBoYTtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9ICcjJyArICgnMDAwMDAnICsgKGxpbmVDb2xvciB8IDApLnRvU3RyaW5nKDE2KSkuc3Vic3RyKC02KTtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5zdHJva2VSZWN0KHNoYXBlLngsIHNoYXBlLnksIHNoYXBlLndpZHRoLCBzaGFwZS5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGF0YS50eXBlID09PSBfY29uc3QuU0hBUEVTLkNJUkMpIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPIC0gbmVlZCB0byBiZSBVbmRlZmluZWQhXG4gICAgICAgICAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmFyYyhzaGFwZS54LCBzaGFwZS55LCBzaGFwZS5yYWRpdXMsIDAsIDIgKiBNYXRoLlBJKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuZmlsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gZGF0YS5maWxsQWxwaGEgKiB3b3JsZEFscGhhO1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9ICcjJyArICgnMDAwMDAnICsgKGZpbGxDb2xvciB8IDApLnRvU3RyaW5nKDE2KSkuc3Vic3RyKC02KTtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5maWxsKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkYXRhLmxpbmVXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gZGF0YS5saW5lQWxwaGEgKiB3b3JsZEFscGhhO1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gJyMnICsgKCcwMDAwMCcgKyAobGluZUNvbG9yIHwgMCkudG9TdHJpbmcoMTYpKS5zdWJzdHIoLTYpO1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGF0YS50eXBlID09PSBfY29uc3QuU0hBUEVTLkVMSVApIHtcbiAgICAgICAgICAgICAgICAvLyBlbGxpcHNlIGNvZGUgdGFrZW4gZnJvbTogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yMTcyNzk4L2hvdy10by1kcmF3LWFuLW92YWwtaW4taHRtbDUtY2FudmFzXG5cbiAgICAgICAgICAgICAgICB2YXIgdyA9IHNoYXBlLndpZHRoICogMjtcbiAgICAgICAgICAgICAgICB2YXIgaCA9IHNoYXBlLmhlaWdodCAqIDI7XG5cbiAgICAgICAgICAgICAgICB2YXIgeCA9IHNoYXBlLnggLSB3IC8gMjtcbiAgICAgICAgICAgICAgICB2YXIgeSA9IHNoYXBlLnkgLSBoIC8gMjtcblxuICAgICAgICAgICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG5cbiAgICAgICAgICAgICAgICB2YXIga2FwcGEgPSAwLjU1MjI4NDg7XG4gICAgICAgICAgICAgICAgdmFyIG94ID0gdyAvIDIgKiBrYXBwYTsgLy8gY29udHJvbCBwb2ludCBvZmZzZXQgaG9yaXpvbnRhbFxuICAgICAgICAgICAgICAgIHZhciBveSA9IGggLyAyICoga2FwcGE7IC8vIGNvbnRyb2wgcG9pbnQgb2Zmc2V0IHZlcnRpY2FsXG4gICAgICAgICAgICAgICAgdmFyIHhlID0geCArIHc7IC8vIHgtZW5kXG4gICAgICAgICAgICAgICAgdmFyIHllID0geSArIGg7IC8vIHktZW5kXG4gICAgICAgICAgICAgICAgdmFyIHhtID0geCArIHcgLyAyOyAvLyB4LW1pZGRsZVxuICAgICAgICAgICAgICAgIHZhciB5bSA9IHkgKyBoIC8gMjsgLy8geS1taWRkbGVcblxuICAgICAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKHgsIHltKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmJlemllckN1cnZlVG8oeCwgeW0gLSBveSwgeG0gLSBveCwgeSwgeG0sIHkpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuYmV6aWVyQ3VydmVUbyh4bSArIG94LCB5LCB4ZSwgeW0gLSBveSwgeGUsIHltKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmJlemllckN1cnZlVG8oeGUsIHltICsgb3ksIHhtICsgb3gsIHllLCB4bSwgeWUpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuYmV6aWVyQ3VydmVUbyh4bSAtIG94LCB5ZSwgeCwgeW0gKyBveSwgeCwgeW0pO1xuXG4gICAgICAgICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcblxuICAgICAgICAgICAgICAgIGlmIChkYXRhLmZpbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IGRhdGEuZmlsbEFscGhhICogd29ybGRBbHBoYTtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSAnIycgKyAoJzAwMDAwJyArIChmaWxsQ29sb3IgfCAwKS50b1N0cmluZygxNikpLnN1YnN0cigtNik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZmlsbCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5saW5lV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IGRhdGEubGluZUFscGhhICogd29ybGRBbHBoYTtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9ICcjJyArICgnMDAwMDAnICsgKGxpbmVDb2xvciB8IDApLnRvU3RyaW5nKDE2KSkuc3Vic3RyKC02KTtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRhdGEudHlwZSA9PT0gX2NvbnN0LlNIQVBFUy5SUkVDKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJ4ID0gc2hhcGUueDtcbiAgICAgICAgICAgICAgICB2YXIgcnkgPSBzaGFwZS55O1xuICAgICAgICAgICAgICAgIHZhciB3aWR0aCA9IHNoYXBlLndpZHRoO1xuICAgICAgICAgICAgICAgIHZhciBoZWlnaHQgPSBzaGFwZS5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgdmFyIHJhZGl1cyA9IHNoYXBlLnJhZGl1cztcblxuICAgICAgICAgICAgICAgIHZhciBtYXhSYWRpdXMgPSBNYXRoLm1pbih3aWR0aCwgaGVpZ2h0KSAvIDIgfCAwO1xuXG4gICAgICAgICAgICAgICAgcmFkaXVzID0gcmFkaXVzID4gbWF4UmFkaXVzID8gbWF4UmFkaXVzIDogcmFkaXVzO1xuXG4gICAgICAgICAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyhyeCwgcnkgKyByYWRpdXMpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHJ4LCByeSArIGhlaWdodCAtIHJhZGl1cyk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKHJ4LCByeSArIGhlaWdodCwgcnggKyByYWRpdXMsIHJ5ICsgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhyeCArIHdpZHRoIC0gcmFkaXVzLCByeSArIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKHJ4ICsgd2lkdGgsIHJ5ICsgaGVpZ2h0LCByeCArIHdpZHRoLCByeSArIGhlaWdodCAtIHJhZGl1cyk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8ocnggKyB3aWR0aCwgcnkgKyByYWRpdXMpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQucXVhZHJhdGljQ3VydmVUbyhyeCArIHdpZHRoLCByeSwgcnggKyB3aWR0aCAtIHJhZGl1cywgcnkpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHJ4ICsgcmFkaXVzLCByeSk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKHJ4LCByeSwgcngsIHJ5ICsgcmFkaXVzKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuZmlsbENvbG9yIHx8IGRhdGEuZmlsbENvbG9yID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZ2xvYmFsQWxwaGEgPSBkYXRhLmZpbGxBbHBoYSAqIHdvcmxkQWxwaGE7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gJyMnICsgKCcwMDAwMCcgKyAoZmlsbENvbG9yIHwgMCkudG9TdHJpbmcoMTYpKS5zdWJzdHIoLTYpO1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmZpbGwoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5saW5lV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IGRhdGEubGluZUFscGhhICogd29ybGRBbHBoYTtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9ICcjJyArICgnMDAwMDAnICsgKGxpbmVDb2xvciB8IDApLnRvU3RyaW5nKDE2KSkuc3Vic3RyKC02KTtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgdGludCBvZiBhIGdyYXBoaWNzIG9iamVjdFxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1BJWEkuR3JhcGhpY3N9IGdyYXBoaWNzIC0gdGhlIGdyYXBoaWNzIHRoYXQgd2lsbCBoYXZlIGl0cyB0aW50IHVwZGF0ZWRcbiAgICAgKi9cblxuXG4gICAgQ2FudmFzR3JhcGhpY3NSZW5kZXJlci5wcm90b3R5cGUudXBkYXRlR3JhcGhpY3NUaW50ID0gZnVuY3Rpb24gdXBkYXRlR3JhcGhpY3NUaW50KGdyYXBoaWNzKSB7XG4gICAgICAgIGdyYXBoaWNzLl9wcmV2VGludCA9IGdyYXBoaWNzLnRpbnQ7XG4gICAgICAgIGdyYXBoaWNzLmNhbnZhc1RpbnREaXJ0eSA9IGdyYXBoaWNzLmRpcnR5O1xuXG4gICAgICAgIHZhciB0aW50UiA9IChncmFwaGljcy50aW50ID4+IDE2ICYgMHhGRikgLyAyNTU7XG4gICAgICAgIHZhciB0aW50RyA9IChncmFwaGljcy50aW50ID4+IDggJiAweEZGKSAvIDI1NTtcbiAgICAgICAgdmFyIHRpbnRCID0gKGdyYXBoaWNzLnRpbnQgJiAweEZGKSAvIDI1NTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyYXBoaWNzLmdyYXBoaWNzRGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBncmFwaGljcy5ncmFwaGljc0RhdGFbaV07XG5cbiAgICAgICAgICAgIHZhciBmaWxsQ29sb3IgPSBkYXRhLmZpbGxDb2xvciB8IDA7XG4gICAgICAgICAgICB2YXIgbGluZUNvbG9yID0gZGF0YS5saW5lQ29sb3IgfCAwO1xuXG4gICAgICAgICAgICAvLyBzdXBlciBpbmxpbmUsIGNvcyBvcHRpbWl6YXRpb24gOilcbiAgICAgICAgICAgIGRhdGEuX2ZpbGxUaW50ID0gKChmaWxsQ29sb3IgPj4gMTYgJiAweEZGKSAvIDI1NSAqIHRpbnRSICogMjU1IDw8IDE2KSArICgoZmlsbENvbG9yID4+IDggJiAweEZGKSAvIDI1NSAqIHRpbnRHICogMjU1IDw8IDgpICsgKGZpbGxDb2xvciAmIDB4RkYpIC8gMjU1ICogdGludEIgKiAyNTU7XG5cbiAgICAgICAgICAgIGRhdGEuX2xpbmVUaW50ID0gKChsaW5lQ29sb3IgPj4gMTYgJiAweEZGKSAvIDI1NSAqIHRpbnRSICogMjU1IDw8IDE2KSArICgobGluZUNvbG9yID4+IDggJiAweEZGKSAvIDI1NSAqIHRpbnRHICogMjU1IDw8IDgpICsgKGxpbmVDb2xvciAmIDB4RkYpIC8gMjU1ICogdGludEIgKiAyNTU7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBhIHBvbHlnb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuUG9pbnRbXX0gcG9pbnRzIC0gVGhlIHBvaW50cyB0byByZW5kZXJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNsb3NlIC0gU2hvdWxkIHRoZSBwb2x5Z29uIGJlIGNsb3NlZFxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0IC0gVGhlIHJlbmRlcmluZyBjb250ZXh0IHRvIHVzZVxuICAgICAqL1xuXG5cbiAgICBDYW52YXNHcmFwaGljc1JlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJQb2x5Z29uID0gZnVuY3Rpb24gcmVuZGVyUG9seWdvbihwb2ludHMsIGNsb3NlLCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnRleHQubW92ZVRvKHBvaW50c1swXSwgcG9pbnRzWzFdKTtcblxuICAgICAgICBmb3IgKHZhciBqID0gMTsgaiA8IHBvaW50cy5sZW5ndGggLyAyOyArK2opIHtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHBvaW50c1tqICogMl0sIHBvaW50c1tqICogMiArIDFdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjbG9zZSkge1xuICAgICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBkZXN0cm95IGdyYXBoaWNzIG9iamVjdFxuICAgICAqXG4gICAgICovXG5cblxuICAgIENhbnZhc0dyYXBoaWNzUmVuZGVyZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gbnVsbDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIENhbnZhc0dyYXBoaWNzUmVuZGVyZXI7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IENhbnZhc0dyYXBoaWNzUmVuZGVyZXI7XG5cblxuX0NhbnZhc1JlbmRlcmVyMi5kZWZhdWx0LnJlZ2lzdGVyUGx1Z2luKCdncmFwaGljcycsIENhbnZhc0dyYXBoaWNzUmVuZGVyZXIpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2FudmFzR3JhcGhpY3NSZW5kZXJlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuZGVmYXVsdCA9IGJlemllckN1cnZlVG87XG4vKipcbiAqIENhbGN1bGF0ZSB0aGUgcG9pbnRzIGZvciBhIGJlemllciBjdXJ2ZSBhbmQgdGhlbiBkcmF3cyBpdC5cbiAqXG4gKiBJZ25vcmVkIGZyb20gZG9jcyBzaW5jZSBpdCBpcyBub3QgZGlyZWN0bHkgZXhwb3NlZC5cbiAqXG4gKiBAaWdub3JlXG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbVggLSBTdGFydGluZyBwb2ludCB4XG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbVkgLSBTdGFydGluZyBwb2ludCB5XG4gKiBAcGFyYW0ge251bWJlcn0gY3BYIC0gQ29udHJvbCBwb2ludCB4XG4gKiBAcGFyYW0ge251bWJlcn0gY3BZIC0gQ29udHJvbCBwb2ludCB5XG4gKiBAcGFyYW0ge251bWJlcn0gY3BYMiAtIFNlY29uZCBDb250cm9sIHBvaW50IHhcbiAqIEBwYXJhbSB7bnVtYmVyfSBjcFkyIC0gU2Vjb25kIENvbnRyb2wgcG9pbnQgeVxuICogQHBhcmFtIHtudW1iZXJ9IHRvWCAtIERlc3RpbmF0aW9uIHBvaW50IHhcbiAqIEBwYXJhbSB7bnVtYmVyfSB0b1kgLSBEZXN0aW5hdGlvbiBwb2ludCB5XG4gKiBAcGFyYW0ge251bWJlcn0gbiAtIE51bWJlciBvZiBzZWdtZW50cyBhcHByb3hpbWF0aW5nIHRoZSBiZXppZXIgY3VydmVcbiAqIEBwYXJhbSB7bnVtYmVyW119IFtwYXRoPVtdXSAtIFBhdGggYXJyYXkgdG8gcHVzaCBwb2ludHMgaW50b1xuICogQHJldHVybiB7bnVtYmVyW119IEFycmF5IG9mIHBvaW50cyBvZiB0aGUgY3VydmVcbiAqL1xuZnVuY3Rpb24gYmV6aWVyQ3VydmVUbyhmcm9tWCwgZnJvbVksIGNwWCwgY3BZLCBjcFgyLCBjcFkyLCB0b1gsIHRvWSwgbikge1xuICAgIHZhciBwYXRoID0gYXJndW1lbnRzLmxlbmd0aCA+IDkgJiYgYXJndW1lbnRzWzldICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbOV0gOiBbXTtcblxuICAgIHZhciBkdCA9IDA7XG4gICAgdmFyIGR0MiA9IDA7XG4gICAgdmFyIGR0MyA9IDA7XG4gICAgdmFyIHQyID0gMDtcbiAgICB2YXIgdDMgPSAwO1xuXG4gICAgcGF0aC5wdXNoKGZyb21YLCBmcm9tWSk7XG5cbiAgICBmb3IgKHZhciBpID0gMSwgaiA9IDA7IGkgPD0gbjsgKytpKSB7XG4gICAgICAgIGogPSBpIC8gbjtcblxuICAgICAgICBkdCA9IDEgLSBqO1xuICAgICAgICBkdDIgPSBkdCAqIGR0O1xuICAgICAgICBkdDMgPSBkdDIgKiBkdDtcblxuICAgICAgICB0MiA9IGogKiBqO1xuICAgICAgICB0MyA9IHQyICogajtcblxuICAgICAgICBwYXRoLnB1c2goZHQzICogZnJvbVggKyAzICogZHQyICogaiAqIGNwWCArIDMgKiBkdCAqIHQyICogY3BYMiArIHQzICogdG9YLCBkdDMgKiBmcm9tWSArIDMgKiBkdDIgKiBqICogY3BZICsgMyAqIGR0ICogdDIgKiBjcFkyICsgdDMgKiB0b1kpO1xuICAgIH1cblxuICAgIHJldHVybiBwYXRoO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmV6aWVyQ3VydmVUby5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfdXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscycpO1xuXG52YXIgX2NvbnN0ID0gcmVxdWlyZSgnLi4vLi4vY29uc3QnKTtcblxudmFyIF9PYmplY3RSZW5kZXJlcjIgPSByZXF1aXJlKCcuLi8uLi9yZW5kZXJlcnMvd2ViZ2wvdXRpbHMvT2JqZWN0UmVuZGVyZXInKTtcblxudmFyIF9PYmplY3RSZW5kZXJlcjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9PYmplY3RSZW5kZXJlcjIpO1xuXG52YXIgX1dlYkdMUmVuZGVyZXIgPSByZXF1aXJlKCcuLi8uLi9yZW5kZXJlcnMvd2ViZ2wvV2ViR0xSZW5kZXJlcicpO1xuXG52YXIgX1dlYkdMUmVuZGVyZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfV2ViR0xSZW5kZXJlcik7XG5cbnZhciBfV2ViR0xHcmFwaGljc0RhdGEgPSByZXF1aXJlKCcuL1dlYkdMR3JhcGhpY3NEYXRhJyk7XG5cbnZhciBfV2ViR0xHcmFwaGljc0RhdGEyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfV2ViR0xHcmFwaGljc0RhdGEpO1xuXG52YXIgX1ByaW1pdGl2ZVNoYWRlciA9IHJlcXVpcmUoJy4vc2hhZGVycy9QcmltaXRpdmVTaGFkZXInKTtcblxudmFyIF9QcmltaXRpdmVTaGFkZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUHJpbWl0aXZlU2hhZGVyKTtcblxudmFyIF9idWlsZFBvbHkgPSByZXF1aXJlKCcuL3V0aWxzL2J1aWxkUG9seScpO1xuXG52YXIgX2J1aWxkUG9seTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9idWlsZFBvbHkpO1xuXG52YXIgX2J1aWxkUmVjdGFuZ2xlID0gcmVxdWlyZSgnLi91dGlscy9idWlsZFJlY3RhbmdsZScpO1xuXG52YXIgX2J1aWxkUmVjdGFuZ2xlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2J1aWxkUmVjdGFuZ2xlKTtcblxudmFyIF9idWlsZFJvdW5kZWRSZWN0YW5nbGUgPSByZXF1aXJlKCcuL3V0aWxzL2J1aWxkUm91bmRlZFJlY3RhbmdsZScpO1xuXG52YXIgX2J1aWxkUm91bmRlZFJlY3RhbmdsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9idWlsZFJvdW5kZWRSZWN0YW5nbGUpO1xuXG52YXIgX2J1aWxkQ2lyY2xlID0gcmVxdWlyZSgnLi91dGlscy9idWlsZENpcmNsZScpO1xuXG52YXIgX2J1aWxkQ2lyY2xlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2J1aWxkQ2lyY2xlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4vKipcbiAqIFJlbmRlcnMgdGhlIGdyYXBoaWNzIG9iamVjdC5cbiAqXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKiBAZXh0ZW5kcyBQSVhJLk9iamVjdFJlbmRlcmVyXG4gKi9cbnZhciBHcmFwaGljc1JlbmRlcmVyID0gZnVuY3Rpb24gKF9PYmplY3RSZW5kZXJlcikge1xuICAgIF9pbmhlcml0cyhHcmFwaGljc1JlbmRlcmVyLCBfT2JqZWN0UmVuZGVyZXIpO1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtQSVhJLldlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyIHRoaXMgb2JqZWN0IHJlbmRlcmVyIHdvcmtzIGZvci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBHcmFwaGljc1JlbmRlcmVyKHJlbmRlcmVyKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBHcmFwaGljc1JlbmRlcmVyKTtcblxuICAgICAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfT2JqZWN0UmVuZGVyZXIuY2FsbCh0aGlzLCByZW5kZXJlcikpO1xuXG4gICAgICAgIF90aGlzLmdyYXBoaWNzRGF0YVBvb2wgPSBbXTtcblxuICAgICAgICBfdGhpcy5wcmltaXRpdmVTaGFkZXIgPSBudWxsO1xuXG4gICAgICAgIF90aGlzLmdsID0gcmVuZGVyZXIuZ2w7XG5cbiAgICAgICAgLy8gZWFzeSBhY2Nlc3MhXG4gICAgICAgIF90aGlzLkNPTlRFWFRfVUlEID0gMDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIHRoZXJlIGlzIGEgV2ViR0wgY29udGV4dCBjaGFuZ2VcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICpcbiAgICAgKi9cblxuXG4gICAgR3JhcGhpY3NSZW5kZXJlci5wcm90b3R5cGUub25Db250ZXh0Q2hhbmdlID0gZnVuY3Rpb24gb25Db250ZXh0Q2hhbmdlKCkge1xuICAgICAgICB0aGlzLmdsID0gdGhpcy5yZW5kZXJlci5nbDtcbiAgICAgICAgdGhpcy5DT05URVhUX1VJRCA9IHRoaXMucmVuZGVyZXIuQ09OVEVYVF9VSUQ7XG4gICAgICAgIHRoaXMucHJpbWl0aXZlU2hhZGVyID0gbmV3IF9QcmltaXRpdmVTaGFkZXIyLmRlZmF1bHQodGhpcy5nbCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIHRoaXMgcmVuZGVyZXIuXG4gICAgICpcbiAgICAgKi9cblxuXG4gICAgR3JhcGhpY3NSZW5kZXJlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIF9PYmplY3RSZW5kZXJlcjMuZGVmYXVsdC5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ncmFwaGljc0RhdGFQb29sLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB0aGlzLmdyYXBoaWNzRGF0YVBvb2xbaV0uZGVzdHJveSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ncmFwaGljc0RhdGFQb29sID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBhIGdyYXBoaWNzIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5HcmFwaGljc30gZ3JhcGhpY3MgLSBUaGUgZ3JhcGhpY3Mgb2JqZWN0IHRvIHJlbmRlci5cbiAgICAgKi9cblxuXG4gICAgR3JhcGhpY3NSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKGdyYXBoaWNzKSB7XG4gICAgICAgIHZhciByZW5kZXJlciA9IHRoaXMucmVuZGVyZXI7XG4gICAgICAgIHZhciBnbCA9IHJlbmRlcmVyLmdsO1xuXG4gICAgICAgIHZhciB3ZWJHTERhdGEgPSB2b2lkIDA7XG4gICAgICAgIHZhciB3ZWJHTCA9IGdyYXBoaWNzLl93ZWJHTFt0aGlzLkNPTlRFWFRfVUlEXTtcblxuICAgICAgICBpZiAoIXdlYkdMIHx8IGdyYXBoaWNzLmRpcnR5ICE9PSB3ZWJHTC5kaXJ0eSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVHcmFwaGljcyhncmFwaGljcyk7XG5cbiAgICAgICAgICAgIHdlYkdMID0gZ3JhcGhpY3MuX3dlYkdMW3RoaXMuQ09OVEVYVF9VSURdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhpcyAgY291bGQgYmUgc3BlZWRlZCB1cCBmb3Igc3VyZSFcbiAgICAgICAgdmFyIHNoYWRlciA9IHRoaXMucHJpbWl0aXZlU2hhZGVyO1xuXG4gICAgICAgIHJlbmRlcmVyLmJpbmRTaGFkZXIoc2hhZGVyKTtcbiAgICAgICAgcmVuZGVyZXIuc3RhdGUuc2V0QmxlbmRNb2RlKGdyYXBoaWNzLmJsZW5kTW9kZSk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSB3ZWJHTC5kYXRhLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgd2ViR0xEYXRhID0gd2ViR0wuZGF0YVtpXTtcbiAgICAgICAgICAgIHZhciBzaGFkZXJUZW1wID0gd2ViR0xEYXRhLnNoYWRlcjtcblxuICAgICAgICAgICAgcmVuZGVyZXIuYmluZFNoYWRlcihzaGFkZXJUZW1wKTtcbiAgICAgICAgICAgIHNoYWRlclRlbXAudW5pZm9ybXMudHJhbnNsYXRpb25NYXRyaXggPSBncmFwaGljcy50cmFuc2Zvcm0ud29ybGRUcmFuc2Zvcm0udG9BcnJheSh0cnVlKTtcbiAgICAgICAgICAgIHNoYWRlclRlbXAudW5pZm9ybXMudGludCA9ICgwLCBfdXRpbHMuaGV4MnJnYikoZ3JhcGhpY3MudGludCk7XG4gICAgICAgICAgICBzaGFkZXJUZW1wLnVuaWZvcm1zLmFscGhhID0gZ3JhcGhpY3Mud29ybGRBbHBoYTtcblxuICAgICAgICAgICAgcmVuZGVyZXIuYmluZFZhbyh3ZWJHTERhdGEudmFvKTtcblxuICAgICAgICAgICAgaWYgKHdlYkdMRGF0YS5uYXRpdmVMaW5lcykge1xuICAgICAgICAgICAgICAgIGdsLmRyYXdBcnJheXMoZ2wuTElORVMsIDAsIHdlYkdMRGF0YS5wb2ludHMubGVuZ3RoIC8gNik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHdlYkdMRGF0YS52YW8uZHJhdyhnbC5UUklBTkdMRV9TVFJJUCwgd2ViR0xEYXRhLmluZGljZXMubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBncmFwaGljcyBvYmplY3RcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtQSVhJLkdyYXBoaWNzfSBncmFwaGljcyAtIFRoZSBncmFwaGljcyBvYmplY3QgdG8gdXBkYXRlXG4gICAgICovXG5cblxuICAgIEdyYXBoaWNzUmVuZGVyZXIucHJvdG90eXBlLnVwZGF0ZUdyYXBoaWNzID0gZnVuY3Rpb24gdXBkYXRlR3JhcGhpY3MoZ3JhcGhpY3MpIHtcbiAgICAgICAgdmFyIGdsID0gdGhpcy5yZW5kZXJlci5nbDtcblxuICAgICAgICAvLyBnZXQgdGhlIGNvbnRleHRzIGdyYXBoaWNzIG9iamVjdFxuICAgICAgICB2YXIgd2ViR0wgPSBncmFwaGljcy5fd2ViR0xbdGhpcy5DT05URVhUX1VJRF07XG5cbiAgICAgICAgLy8gaWYgdGhlIGdyYXBoaWNzIG9iamVjdCBkb2VzIG5vdCBleGlzdCBpbiB0aGUgd2ViR0wgY29udGV4dCB0aW1lIHRvIGNyZWF0ZSBpdCFcbiAgICAgICAgaWYgKCF3ZWJHTCkge1xuICAgICAgICAgICAgd2ViR0wgPSBncmFwaGljcy5fd2ViR0xbdGhpcy5DT05URVhUX1VJRF0gPSB7IGxhc3RJbmRleDogMCwgZGF0YTogW10sIGdsOiBnbCwgY2xlYXJEaXJ0eTogLTEsIGRpcnR5OiAtMSB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmxhZyB0aGUgZ3JhcGhpY3MgYXMgbm90IGRpcnR5IGFzIHdlIGFyZSBhYm91dCB0byB1cGRhdGUgaXQuLi5cbiAgICAgICAgd2ViR0wuZGlydHkgPSBncmFwaGljcy5kaXJ0eTtcblxuICAgICAgICAvLyBpZiB0aGUgdXNlciBjbGVhcmVkIHRoZSBncmFwaGljcyBvYmplY3Qgd2Ugd2lsbCBuZWVkIHRvIGNsZWFyIGV2ZXJ5IG9iamVjdFxuICAgICAgICBpZiAoZ3JhcGhpY3MuY2xlYXJEaXJ0eSAhPT0gd2ViR0wuY2xlYXJEaXJ0eSkge1xuICAgICAgICAgICAgd2ViR0wuY2xlYXJEaXJ0eSA9IGdyYXBoaWNzLmNsZWFyRGlydHk7XG5cbiAgICAgICAgICAgIC8vIGxvb3AgdGhyb3VnaCBhbmQgcmV0dXJuIGFsbCB0aGUgd2ViR0xEYXRhcyB0byB0aGUgb2JqZWN0IHBvb2wgc28gdGhhbiBjYW4gYmUgcmV1c2VkIGxhdGVyIG9uXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHdlYkdMLmRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyYXBoaWNzRGF0YVBvb2wucHVzaCh3ZWJHTC5kYXRhW2ldKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gY2xlYXIgdGhlIGFycmF5IGFuZCByZXNldCB0aGUgaW5kZXguLlxuICAgICAgICAgICAgd2ViR0wuZGF0YS5sZW5ndGggPSAwO1xuICAgICAgICAgICAgd2ViR0wubGFzdEluZGV4ID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB3ZWJHTERhdGEgPSB2b2lkIDA7XG4gICAgICAgIHZhciB3ZWJHTERhdGFOYXRpdmVMaW5lcyA9IHZvaWQgMDtcblxuICAgICAgICAvLyBsb29wIHRocm91Z2ggdGhlIGdyYXBoaWNzIGRhdGFzIGFuZCBjb25zdHJ1Y3QgZWFjaCBvbmUuLlxuICAgICAgICAvLyBpZiB0aGUgb2JqZWN0IGlzIGEgY29tcGxleCBmaWxsIHRoZW4gdGhlIG5ldyBzdGVuY2lsIGJ1ZmZlciB0ZWNobmlxdWUgd2lsbCBiZSB1c2VkXG4gICAgICAgIC8vIG90aGVyIHdpc2UgZ3JhcGhpY3Mgb2JqZWN0cyB3aWxsIGJlIHB1c2hlZCBpbnRvIGEgYmF0Y2guLlxuICAgICAgICBmb3IgKHZhciBfaSA9IHdlYkdMLmxhc3RJbmRleDsgX2kgPCBncmFwaGljcy5ncmFwaGljc0RhdGEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IGdyYXBoaWNzLmdyYXBoaWNzRGF0YVtfaV07XG5cbiAgICAgICAgICAgIC8vIFRPRE8gLSB0aGlzIGNhbiBiZSBzaW1wbGlmaWVkXG4gICAgICAgICAgICB3ZWJHTERhdGEgPSB0aGlzLmdldFdlYkdMRGF0YSh3ZWJHTCwgMCk7XG5cbiAgICAgICAgICAgIGlmIChkYXRhLm5hdGl2ZUxpbmVzICYmIGRhdGEubGluZVdpZHRoKSB7XG4gICAgICAgICAgICAgICAgd2ViR0xEYXRhTmF0aXZlTGluZXMgPSB0aGlzLmdldFdlYkdMRGF0YSh3ZWJHTCwgMCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgd2ViR0wubGFzdEluZGV4Kys7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkYXRhLnR5cGUgPT09IF9jb25zdC5TSEFQRVMuUE9MWSkge1xuICAgICAgICAgICAgICAgICgwLCBfYnVpbGRQb2x5Mi5kZWZhdWx0KShkYXRhLCB3ZWJHTERhdGEsIHdlYkdMRGF0YU5hdGl2ZUxpbmVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRhLnR5cGUgPT09IF9jb25zdC5TSEFQRVMuUkVDVCkge1xuICAgICAgICAgICAgICAgICgwLCBfYnVpbGRSZWN0YW5nbGUyLmRlZmF1bHQpKGRhdGEsIHdlYkdMRGF0YSwgd2ViR0xEYXRhTmF0aXZlTGluZXMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChkYXRhLnR5cGUgPT09IF9jb25zdC5TSEFQRVMuQ0lSQyB8fCBkYXRhLnR5cGUgPT09IF9jb25zdC5TSEFQRVMuRUxJUCkge1xuICAgICAgICAgICAgICAgICgwLCBfYnVpbGRDaXJjbGUyLmRlZmF1bHQpKGRhdGEsIHdlYkdMRGF0YSwgd2ViR0xEYXRhTmF0aXZlTGluZXMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChkYXRhLnR5cGUgPT09IF9jb25zdC5TSEFQRVMuUlJFQykge1xuICAgICAgICAgICAgICAgICgwLCBfYnVpbGRSb3VuZGVkUmVjdGFuZ2xlMi5kZWZhdWx0KShkYXRhLCB3ZWJHTERhdGEsIHdlYkdMRGF0YU5hdGl2ZUxpbmVzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgd2ViR0wubGFzdEluZGV4Kys7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJlbmRlcmVyLmJpbmRWYW8obnVsbCk7XG5cbiAgICAgICAgLy8gdXBsb2FkIGFsbCB0aGUgZGlydHkgZGF0YS4uLlxuICAgICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCB3ZWJHTC5kYXRhLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgICAgIHdlYkdMRGF0YSA9IHdlYkdMLmRhdGFbX2kyXTtcblxuICAgICAgICAgICAgaWYgKHdlYkdMRGF0YS5kaXJ0eSkge1xuICAgICAgICAgICAgICAgIHdlYkdMRGF0YS51cGxvYWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIC0gdGhlIGN1cnJlbnQgV2ViR0wgZHJhd2luZyBjb250ZXh0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHR5cGUgLSBUT0RPIEBBbHZpblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuYXRpdmVMaW5lcyAtIGluZGljYXRlIHdoZXRoZXIgdGhlIHdlYkdMRGF0YSB1c2UgZm9yIG5hdGl2ZUxpbmVzLlxuICAgICAqIEByZXR1cm4geyp9IFRPRE9cbiAgICAgKi9cblxuXG4gICAgR3JhcGhpY3NSZW5kZXJlci5wcm90b3R5cGUuZ2V0V2ViR0xEYXRhID0gZnVuY3Rpb24gZ2V0V2ViR0xEYXRhKGdsLCB0eXBlLCBuYXRpdmVMaW5lcykge1xuICAgICAgICB2YXIgd2ViR0xEYXRhID0gZ2wuZGF0YVtnbC5kYXRhLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgIGlmICghd2ViR0xEYXRhIHx8IHdlYkdMRGF0YS5uYXRpdmVMaW5lcyAhPT0gbmF0aXZlTGluZXMgfHwgd2ViR0xEYXRhLnBvaW50cy5sZW5ndGggPiAzMjAwMDApIHtcbiAgICAgICAgICAgIHdlYkdMRGF0YSA9IHRoaXMuZ3JhcGhpY3NEYXRhUG9vbC5wb3AoKSB8fCBuZXcgX1dlYkdMR3JhcGhpY3NEYXRhMi5kZWZhdWx0KHRoaXMucmVuZGVyZXIuZ2wsIHRoaXMucHJpbWl0aXZlU2hhZGVyLCB0aGlzLnJlbmRlcmVyLnN0YXRlLmF0dHJpYnNTdGF0ZSk7XG4gICAgICAgICAgICB3ZWJHTERhdGEubmF0aXZlTGluZXMgPSBuYXRpdmVMaW5lcztcbiAgICAgICAgICAgIHdlYkdMRGF0YS5yZXNldCh0eXBlKTtcbiAgICAgICAgICAgIGdsLmRhdGEucHVzaCh3ZWJHTERhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgd2ViR0xEYXRhLmRpcnR5ID0gdHJ1ZTtcblxuICAgICAgICByZXR1cm4gd2ViR0xEYXRhO1xuICAgIH07XG5cbiAgICByZXR1cm4gR3JhcGhpY3NSZW5kZXJlcjtcbn0oX09iamVjdFJlbmRlcmVyMy5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gR3JhcGhpY3NSZW5kZXJlcjtcblxuXG5fV2ViR0xSZW5kZXJlcjIuZGVmYXVsdC5yZWdpc3RlclBsdWdpbignZ3JhcGhpY3MnLCBHcmFwaGljc1JlbmRlcmVyKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdyYXBoaWNzUmVuZGVyZXIuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3BpeGlHbENvcmUgPSByZXF1aXJlKCdwaXhpLWdsLWNvcmUnKTtcblxudmFyIF9waXhpR2xDb3JlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BpeGlHbENvcmUpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vKipcbiAqIEFuIG9iamVjdCBjb250YWluaW5nIFdlYkdMIHNwZWNpZmljIHByb3BlcnRpZXMgdG8gYmUgdXNlZCBieSB0aGUgV2ViR0wgcmVuZGVyZXJcbiAqXG4gKiBAY2xhc3NcbiAqIEBwcml2YXRlXG4gKiBAbWVtYmVyb2YgUElYSVxuICovXG52YXIgV2ViR0xHcmFwaGljc0RhdGEgPSBmdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgLSBUaGUgY3VycmVudCBXZWJHTCBkcmF3aW5nIGNvbnRleHRcbiAgICogQHBhcmFtIHtQSVhJLlNoYWRlcn0gc2hhZGVyIC0gVGhlIHNoYWRlclxuICAgKiBAcGFyYW0ge29iamVjdH0gYXR0cmlic1N0YXRlIC0gVGhlIHN0YXRlIGZvciB0aGUgVkFPXG4gICAqL1xuICBmdW5jdGlvbiBXZWJHTEdyYXBoaWNzRGF0YShnbCwgc2hhZGVyLCBhdHRyaWJzU3RhdGUpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgV2ViR0xHcmFwaGljc0RhdGEpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgV2ViR0wgZHJhd2luZyBjb250ZXh0XG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9XG4gICAgICovXG4gICAgdGhpcy5nbCA9IGdsO1xuXG4gICAgLy8gVE9ETyBkb2VzIHRoaXMgbmVlZCB0byBiZSBzcGxpdCBiZWZvcmUgdXBsb2FkaW5nPz9cbiAgICAvKipcbiAgICAgKiBBbiBhcnJheSBvZiBjb2xvciBjb21wb25lbnRzIChyLGcsYilcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJbXX1cbiAgICAgKi9cbiAgICB0aGlzLmNvbG9yID0gWzAsIDAsIDBdOyAvLyBjb2xvciBzcGxpdCFcblxuICAgIC8qKlxuICAgICAqIEFuIGFycmF5IG9mIHBvaW50cyB0byBkcmF3XG4gICAgICogQG1lbWJlciB7UElYSS5Qb2ludFtdfVxuICAgICAqL1xuICAgIHRoaXMucG9pbnRzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW5kaWNlcyBvZiB0aGUgdmVydGljZXNcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJbXX1cbiAgICAgKi9cbiAgICB0aGlzLmluZGljZXMgPSBbXTtcbiAgICAvKipcbiAgICAgKiBUaGUgbWFpbiBidWZmZXJcbiAgICAgKiBAbWVtYmVyIHtXZWJHTEJ1ZmZlcn1cbiAgICAgKi9cbiAgICB0aGlzLmJ1ZmZlciA9IF9waXhpR2xDb3JlMi5kZWZhdWx0LkdMQnVmZmVyLmNyZWF0ZVZlcnRleEJ1ZmZlcihnbCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW5kZXggYnVmZmVyXG4gICAgICogQG1lbWJlciB7V2ViR0xCdWZmZXJ9XG4gICAgICovXG4gICAgdGhpcy5pbmRleEJ1ZmZlciA9IF9waXhpR2xDb3JlMi5kZWZhdWx0LkdMQnVmZmVyLmNyZWF0ZUluZGV4QnVmZmVyKGdsKTtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhpcyBncmFwaGljcyBpcyBkaXJ0eSBvciBub3RcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGlzIGdyYXBoaWNzIGlzIG5hdGl2ZUxpbmVzIG9yIG5vdFxuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5uYXRpdmVMaW5lcyA9IGZhbHNlO1xuXG4gICAgdGhpcy5nbFBvaW50cyA9IG51bGw7XG4gICAgdGhpcy5nbEluZGljZXMgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtQSVhJLlNoYWRlcn1cbiAgICAgKi9cbiAgICB0aGlzLnNoYWRlciA9IHNoYWRlcjtcblxuICAgIHRoaXMudmFvID0gbmV3IF9waXhpR2xDb3JlMi5kZWZhdWx0LlZlcnRleEFycmF5T2JqZWN0KGdsLCBhdHRyaWJzU3RhdGUpLmFkZEluZGV4KHRoaXMuaW5kZXhCdWZmZXIpLmFkZEF0dHJpYnV0ZSh0aGlzLmJ1ZmZlciwgc2hhZGVyLmF0dHJpYnV0ZXMuYVZlcnRleFBvc2l0aW9uLCBnbC5GTE9BVCwgZmFsc2UsIDQgKiA2LCAwKS5hZGRBdHRyaWJ1dGUodGhpcy5idWZmZXIsIHNoYWRlci5hdHRyaWJ1dGVzLmFDb2xvciwgZ2wuRkxPQVQsIGZhbHNlLCA0ICogNiwgMiAqIDQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc2V0cyB0aGUgdmVydGljZXMgYW5kIHRoZSBpbmRpY2VzXG4gICAqL1xuXG5cbiAgV2ViR0xHcmFwaGljc0RhdGEucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgdGhpcy5wb2ludHMubGVuZ3RoID0gMDtcbiAgICB0aGlzLmluZGljZXMubGVuZ3RoID0gMDtcbiAgfTtcblxuICAvKipcbiAgICogQmluZHMgdGhlIGJ1ZmZlcnMgYW5kIHVwbG9hZHMgdGhlIGRhdGFcbiAgICovXG5cblxuICBXZWJHTEdyYXBoaWNzRGF0YS5wcm90b3R5cGUudXBsb2FkID0gZnVuY3Rpb24gdXBsb2FkKCkge1xuICAgIHRoaXMuZ2xQb2ludHMgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMucG9pbnRzKTtcbiAgICB0aGlzLmJ1ZmZlci51cGxvYWQodGhpcy5nbFBvaW50cyk7XG5cbiAgICB0aGlzLmdsSW5kaWNlcyA9IG5ldyBVaW50MTZBcnJheSh0aGlzLmluZGljZXMpO1xuICAgIHRoaXMuaW5kZXhCdWZmZXIudXBsb2FkKHRoaXMuZ2xJbmRpY2VzKTtcblxuICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogRW1wdGllcyBhbGwgdGhlIGRhdGFcbiAgICovXG5cblxuICBXZWJHTEdyYXBoaWNzRGF0YS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5jb2xvciA9IG51bGw7XG4gICAgdGhpcy5wb2ludHMgPSBudWxsO1xuICAgIHRoaXMuaW5kaWNlcyA9IG51bGw7XG5cbiAgICB0aGlzLnZhby5kZXN0cm95KCk7XG4gICAgdGhpcy5idWZmZXIuZGVzdHJveSgpO1xuICAgIHRoaXMuaW5kZXhCdWZmZXIuZGVzdHJveSgpO1xuXG4gICAgdGhpcy5nbCA9IG51bGw7XG5cbiAgICB0aGlzLmJ1ZmZlciA9IG51bGw7XG4gICAgdGhpcy5pbmRleEJ1ZmZlciA9IG51bGw7XG5cbiAgICB0aGlzLmdsUG9pbnRzID0gbnVsbDtcbiAgICB0aGlzLmdsSW5kaWNlcyA9IG51bGw7XG4gIH07XG5cbiAgcmV0dXJuIFdlYkdMR3JhcGhpY3NEYXRhO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBXZWJHTEdyYXBoaWNzRGF0YTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVdlYkdMR3JhcGhpY3NEYXRhLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9TaGFkZXIyID0gcmVxdWlyZSgnLi4vLi4vLi4vU2hhZGVyJyk7XG5cbnZhciBfU2hhZGVyMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1NoYWRlcjIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbi8qKlxuICogVGhpcyBzaGFkZXIgaXMgdXNlZCB0byBkcmF3IHNpbXBsZSBwcmltaXRpdmUgc2hhcGVzIGZvciB7QGxpbmsgUElYSS5HcmFwaGljc30uXG4gKlxuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgUElYSVxuICogQGV4dGVuZHMgUElYSS5TaGFkZXJcbiAqL1xudmFyIFByaW1pdGl2ZVNoYWRlciA9IGZ1bmN0aW9uIChfU2hhZGVyKSB7XG4gICAgX2luaGVyaXRzKFByaW1pdGl2ZVNoYWRlciwgX1NoYWRlcik7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgLSBUaGUgd2ViZ2wgc2hhZGVyIG1hbmFnZXIgdGhpcyBzaGFkZXIgd29ya3MgZm9yLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFByaW1pdGl2ZVNoYWRlcihnbCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUHJpbWl0aXZlU2hhZGVyKTtcblxuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1NoYWRlci5jYWxsKHRoaXMsIGdsLFxuICAgICAgICAvLyB2ZXJ0ZXggc2hhZGVyXG4gICAgICAgIFsnYXR0cmlidXRlIHZlYzIgYVZlcnRleFBvc2l0aW9uOycsICdhdHRyaWJ1dGUgdmVjNCBhQ29sb3I7JywgJ3VuaWZvcm0gbWF0MyB0cmFuc2xhdGlvbk1hdHJpeDsnLCAndW5pZm9ybSBtYXQzIHByb2plY3Rpb25NYXRyaXg7JywgJ3VuaWZvcm0gZmxvYXQgYWxwaGE7JywgJ3VuaWZvcm0gdmVjMyB0aW50OycsICd2YXJ5aW5nIHZlYzQgdkNvbG9yOycsICd2b2lkIG1haW4odm9pZCl7JywgJyAgIGdsX1Bvc2l0aW9uID0gdmVjNCgocHJvamVjdGlvbk1hdHJpeCAqIHRyYW5zbGF0aW9uTWF0cml4ICogdmVjMyhhVmVydGV4UG9zaXRpb24sIDEuMCkpLnh5LCAwLjAsIDEuMCk7JywgJyAgIHZDb2xvciA9IGFDb2xvciAqIHZlYzQodGludCAqIGFscGhhLCBhbHBoYSk7JywgJ30nXS5qb2luKCdcXG4nKSxcbiAgICAgICAgLy8gZnJhZ21lbnQgc2hhZGVyXG4gICAgICAgIFsndmFyeWluZyB2ZWM0IHZDb2xvcjsnLCAndm9pZCBtYWluKHZvaWQpeycsICcgICBnbF9GcmFnQ29sb3IgPSB2Q29sb3I7JywgJ30nXS5qb2luKCdcXG4nKSkpO1xuICAgIH1cblxuICAgIHJldHVybiBQcmltaXRpdmVTaGFkZXI7XG59KF9TaGFkZXIzLmRlZmF1bHQpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBQcmltaXRpdmVTaGFkZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1QcmltaXRpdmVTaGFkZXIuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5kZWZhdWx0ID0gYnVpbGRDaXJjbGU7XG5cbnZhciBfYnVpbGRMaW5lID0gcmVxdWlyZSgnLi9idWlsZExpbmUnKTtcblxudmFyIF9idWlsZExpbmUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYnVpbGRMaW5lKTtcblxudmFyIF9jb25zdCA9IHJlcXVpcmUoJy4uLy4uLy4uL2NvbnN0Jyk7XG5cbnZhciBfdXRpbHMgPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKipcbiAqIEJ1aWxkcyBhIGNpcmNsZSB0byBkcmF3XG4gKlxuICogSWdub3JlZCBmcm9tIGRvY3Mgc2luY2UgaXQgaXMgbm90IGRpcmVjdGx5IGV4cG9zZWQuXG4gKlxuICogQGlnbm9yZVxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7UElYSS5XZWJHTEdyYXBoaWNzRGF0YX0gZ3JhcGhpY3NEYXRhIC0gVGhlIGdyYXBoaWNzIG9iamVjdCB0byBkcmF3XG4gKiBAcGFyYW0ge29iamVjdH0gd2ViR0xEYXRhIC0gYW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSB3ZWJHTC1zcGVjaWZpYyBpbmZvcm1hdGlvbiB0byBjcmVhdGUgdGhpcyBzaGFwZVxuICogQHBhcmFtIHtvYmplY3R9IHdlYkdMRGF0YU5hdGl2ZUxpbmVzIC0gYW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSB3ZWJHTC1zcGVjaWZpYyBpbmZvcm1hdGlvbiB0byBjcmVhdGUgbmF0aXZlTGluZXNcbiAqL1xuZnVuY3Rpb24gYnVpbGRDaXJjbGUoZ3JhcGhpY3NEYXRhLCB3ZWJHTERhdGEsIHdlYkdMRGF0YU5hdGl2ZUxpbmVzKSB7XG4gICAgLy8gbmVlZCB0byBjb252ZXJ0IHBvaW50cyB0byBhIG5pY2UgcmVndWxhciBkYXRhXG4gICAgdmFyIGNpcmNsZURhdGEgPSBncmFwaGljc0RhdGEuc2hhcGU7XG4gICAgdmFyIHggPSBjaXJjbGVEYXRhLng7XG4gICAgdmFyIHkgPSBjaXJjbGVEYXRhLnk7XG4gICAgdmFyIHdpZHRoID0gdm9pZCAwO1xuICAgIHZhciBoZWlnaHQgPSB2b2lkIDA7XG5cbiAgICAvLyBUT0RPIC0gYml0IGhhY2t5Pz9cbiAgICBpZiAoZ3JhcGhpY3NEYXRhLnR5cGUgPT09IF9jb25zdC5TSEFQRVMuQ0lSQykge1xuICAgICAgICB3aWR0aCA9IGNpcmNsZURhdGEucmFkaXVzO1xuICAgICAgICBoZWlnaHQgPSBjaXJjbGVEYXRhLnJhZGl1cztcbiAgICB9IGVsc2Uge1xuICAgICAgICB3aWR0aCA9IGNpcmNsZURhdGEud2lkdGg7XG4gICAgICAgIGhlaWdodCA9IGNpcmNsZURhdGEuaGVpZ2h0O1xuICAgIH1cblxuICAgIGlmICh3aWR0aCA9PT0gMCB8fCBoZWlnaHQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB0b3RhbFNlZ3MgPSBNYXRoLmZsb29yKDMwICogTWF0aC5zcXJ0KGNpcmNsZURhdGEucmFkaXVzKSkgfHwgTWF0aC5mbG9vcigxNSAqIE1hdGguc3FydChjaXJjbGVEYXRhLndpZHRoICsgY2lyY2xlRGF0YS5oZWlnaHQpKTtcblxuICAgIHZhciBzZWcgPSBNYXRoLlBJICogMiAvIHRvdGFsU2VncztcblxuICAgIGlmIChncmFwaGljc0RhdGEuZmlsbCkge1xuICAgICAgICB2YXIgY29sb3IgPSAoMCwgX3V0aWxzLmhleDJyZ2IpKGdyYXBoaWNzRGF0YS5maWxsQ29sb3IpO1xuICAgICAgICB2YXIgYWxwaGEgPSBncmFwaGljc0RhdGEuZmlsbEFscGhhO1xuXG4gICAgICAgIHZhciByID0gY29sb3JbMF0gKiBhbHBoYTtcbiAgICAgICAgdmFyIGcgPSBjb2xvclsxXSAqIGFscGhhO1xuICAgICAgICB2YXIgYiA9IGNvbG9yWzJdICogYWxwaGE7XG5cbiAgICAgICAgdmFyIHZlcnRzID0gd2ViR0xEYXRhLnBvaW50cztcbiAgICAgICAgdmFyIGluZGljZXMgPSB3ZWJHTERhdGEuaW5kaWNlcztcblxuICAgICAgICB2YXIgdmVjUG9zID0gdmVydHMubGVuZ3RoIC8gNjtcblxuICAgICAgICBpbmRpY2VzLnB1c2godmVjUG9zKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvdGFsU2VncyArIDE7IGkrKykge1xuICAgICAgICAgICAgdmVydHMucHVzaCh4LCB5LCByLCBnLCBiLCBhbHBoYSk7XG5cbiAgICAgICAgICAgIHZlcnRzLnB1c2goeCArIE1hdGguc2luKHNlZyAqIGkpICogd2lkdGgsIHkgKyBNYXRoLmNvcyhzZWcgKiBpKSAqIGhlaWdodCwgciwgZywgYiwgYWxwaGEpO1xuXG4gICAgICAgICAgICBpbmRpY2VzLnB1c2godmVjUG9zKyssIHZlY1BvcysrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGluZGljZXMucHVzaCh2ZWNQb3MgLSAxKTtcbiAgICB9XG5cbiAgICBpZiAoZ3JhcGhpY3NEYXRhLmxpbmVXaWR0aCkge1xuICAgICAgICB2YXIgdGVtcFBvaW50cyA9IGdyYXBoaWNzRGF0YS5wb2ludHM7XG5cbiAgICAgICAgZ3JhcGhpY3NEYXRhLnBvaW50cyA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCB0b3RhbFNlZ3M7IF9pKyspIHtcbiAgICAgICAgICAgIGdyYXBoaWNzRGF0YS5wb2ludHMucHVzaCh4ICsgTWF0aC5zaW4oc2VnICogLV9pKSAqIHdpZHRoLCB5ICsgTWF0aC5jb3Moc2VnICogLV9pKSAqIGhlaWdodCk7XG4gICAgICAgIH1cblxuICAgICAgICBncmFwaGljc0RhdGEucG9pbnRzLnB1c2goZ3JhcGhpY3NEYXRhLnBvaW50c1swXSwgZ3JhcGhpY3NEYXRhLnBvaW50c1sxXSk7XG5cbiAgICAgICAgKDAsIF9idWlsZExpbmUyLmRlZmF1bHQpKGdyYXBoaWNzRGF0YSwgd2ViR0xEYXRhLCB3ZWJHTERhdGFOYXRpdmVMaW5lcyk7XG5cbiAgICAgICAgZ3JhcGhpY3NEYXRhLnBvaW50cyA9IHRlbXBQb2ludHM7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnVpbGRDaXJjbGUuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoZ3JhcGhpY3NEYXRhLCB3ZWJHTERhdGEsIHdlYkdMRGF0YU5hdGl2ZUxpbmVzKSB7XG4gICAgaWYgKGdyYXBoaWNzRGF0YS5uYXRpdmVMaW5lcykge1xuICAgICAgICBidWlsZE5hdGl2ZUxpbmUoZ3JhcGhpY3NEYXRhLCB3ZWJHTERhdGFOYXRpdmVMaW5lcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYnVpbGRMaW5lKGdyYXBoaWNzRGF0YSwgd2ViR0xEYXRhKTtcbiAgICB9XG59O1xuXG52YXIgX21hdGggPSByZXF1aXJlKCcuLi8uLi8uLi9tYXRoJyk7XG5cbnZhciBfdXRpbHMgPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuXG4vKipcbiAqIEJ1aWxkcyBhIGxpbmUgdG8gZHJhdyB1c2luZyB0aGUgcG9saWdvbiBtZXRob2QuXG4gKlxuICogSWdub3JlZCBmcm9tIGRvY3Mgc2luY2UgaXQgaXMgbm90IGRpcmVjdGx5IGV4cG9zZWQuXG4gKlxuICogQGlnbm9yZVxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7UElYSS5XZWJHTEdyYXBoaWNzRGF0YX0gZ3JhcGhpY3NEYXRhIC0gVGhlIGdyYXBoaWNzIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgbmVjZXNzYXJ5IHByb3BlcnRpZXNcbiAqIEBwYXJhbSB7b2JqZWN0fSB3ZWJHTERhdGEgLSBhbiBvYmplY3QgY29udGFpbmluZyBhbGwgdGhlIHdlYkdMLXNwZWNpZmljIGluZm9ybWF0aW9uIHRvIGNyZWF0ZSB0aGlzIHNoYXBlXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkTGluZShncmFwaGljc0RhdGEsIHdlYkdMRGF0YSkge1xuICAgIC8vIFRPRE8gT1BUSU1JU0UhXG4gICAgdmFyIHBvaW50cyA9IGdyYXBoaWNzRGF0YS5wb2ludHM7XG5cbiAgICBpZiAocG9pbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIGlmIHRoZSBsaW5lIHdpZHRoIGlzIGFuIG9kZCBudW1iZXIgYWRkIDAuNSB0byBhbGlnbiB0byBhIHdob2xlIHBpeGVsXG4gICAgLy8gY29tbWVudGluZyB0aGlzIG91dCBmaXhlcyAjNzExIGFuZCAjMTYyMFxuICAgIC8vIGlmIChncmFwaGljc0RhdGEubGluZVdpZHRoJTIpXG4gICAgLy8ge1xuICAgIC8vICAgICBmb3IgKGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKVxuICAgIC8vICAgICB7XG4gICAgLy8gICAgICAgICBwb2ludHNbaV0gKz0gMC41O1xuICAgIC8vICAgICB9XG4gICAgLy8gfVxuXG4gICAgLy8gZ2V0IGZpcnN0IGFuZCBsYXN0IHBvaW50Li4gZmlndXJlIG91dCB0aGUgbWlkZGxlIVxuICAgIHZhciBmaXJzdFBvaW50ID0gbmV3IF9tYXRoLlBvaW50KHBvaW50c1swXSwgcG9pbnRzWzFdKTtcbiAgICB2YXIgbGFzdFBvaW50ID0gbmV3IF9tYXRoLlBvaW50KHBvaW50c1twb2ludHMubGVuZ3RoIC0gMl0sIHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV0pO1xuXG4gICAgLy8gaWYgdGhlIGZpcnN0IHBvaW50IGlzIHRoZSBsYXN0IHBvaW50IC0gZ29ubmEgaGF2ZSBpc3N1ZXMgOilcbiAgICBpZiAoZmlyc3RQb2ludC54ID09PSBsYXN0UG9pbnQueCAmJiBmaXJzdFBvaW50LnkgPT09IGxhc3RQb2ludC55KSB7XG4gICAgICAgIC8vIG5lZWQgdG8gY2xvbmUgYXMgd2UgYXJlIGdvaW5nIHRvIHNsaWdodGx5IG1vZGlmeSB0aGUgc2hhcGUuLlxuICAgICAgICBwb2ludHMgPSBwb2ludHMuc2xpY2UoKTtcblxuICAgICAgICBwb2ludHMucG9wKCk7XG4gICAgICAgIHBvaW50cy5wb3AoKTtcblxuICAgICAgICBsYXN0UG9pbnQgPSBuZXcgX21hdGguUG9pbnQocG9pbnRzW3BvaW50cy5sZW5ndGggLSAyXSwgcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXSk7XG5cbiAgICAgICAgdmFyIG1pZFBvaW50WCA9IGxhc3RQb2ludC54ICsgKGZpcnN0UG9pbnQueCAtIGxhc3RQb2ludC54KSAqIDAuNTtcbiAgICAgICAgdmFyIG1pZFBvaW50WSA9IGxhc3RQb2ludC55ICsgKGZpcnN0UG9pbnQueSAtIGxhc3RQb2ludC55KSAqIDAuNTtcblxuICAgICAgICBwb2ludHMudW5zaGlmdChtaWRQb2ludFgsIG1pZFBvaW50WSk7XG4gICAgICAgIHBvaW50cy5wdXNoKG1pZFBvaW50WCwgbWlkUG9pbnRZKTtcbiAgICB9XG5cbiAgICB2YXIgdmVydHMgPSB3ZWJHTERhdGEucG9pbnRzO1xuICAgIHZhciBpbmRpY2VzID0gd2ViR0xEYXRhLmluZGljZXM7XG4gICAgdmFyIGxlbmd0aCA9IHBvaW50cy5sZW5ndGggLyAyO1xuICAgIHZhciBpbmRleENvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgICB2YXIgaW5kZXhTdGFydCA9IHZlcnRzLmxlbmd0aCAvIDY7XG5cbiAgICAvLyBEUkFXIHRoZSBMaW5lXG4gICAgdmFyIHdpZHRoID0gZ3JhcGhpY3NEYXRhLmxpbmVXaWR0aCAvIDI7XG5cbiAgICAvLyBzb3J0IGNvbG9yXG4gICAgdmFyIGNvbG9yID0gKDAsIF91dGlscy5oZXgycmdiKShncmFwaGljc0RhdGEubGluZUNvbG9yKTtcbiAgICB2YXIgYWxwaGEgPSBncmFwaGljc0RhdGEubGluZUFscGhhO1xuICAgIHZhciByID0gY29sb3JbMF0gKiBhbHBoYTtcbiAgICB2YXIgZyA9IGNvbG9yWzFdICogYWxwaGE7XG4gICAgdmFyIGIgPSBjb2xvclsyXSAqIGFscGhhO1xuXG4gICAgdmFyIHAxeCA9IHBvaW50c1swXTtcbiAgICB2YXIgcDF5ID0gcG9pbnRzWzFdO1xuICAgIHZhciBwMnggPSBwb2ludHNbMl07XG4gICAgdmFyIHAyeSA9IHBvaW50c1szXTtcbiAgICB2YXIgcDN4ID0gMDtcbiAgICB2YXIgcDN5ID0gMDtcblxuICAgIHZhciBwZXJweCA9IC0ocDF5IC0gcDJ5KTtcbiAgICB2YXIgcGVycHkgPSBwMXggLSBwMng7XG4gICAgdmFyIHBlcnAyeCA9IDA7XG4gICAgdmFyIHBlcnAyeSA9IDA7XG4gICAgdmFyIHBlcnAzeCA9IDA7XG4gICAgdmFyIHBlcnAzeSA9IDA7XG5cbiAgICB2YXIgZGlzdCA9IE1hdGguc3FydChwZXJweCAqIHBlcnB4ICsgcGVycHkgKiBwZXJweSk7XG5cbiAgICBwZXJweCAvPSBkaXN0O1xuICAgIHBlcnB5IC89IGRpc3Q7XG4gICAgcGVycHggKj0gd2lkdGg7XG4gICAgcGVycHkgKj0gd2lkdGg7XG5cbiAgICB2YXIgcmF0aW8gPSBncmFwaGljc0RhdGEubGluZUFsaWdubWVudDsgLy8gMC41O1xuICAgIHZhciByMSA9ICgxIC0gcmF0aW8pICogMjtcbiAgICB2YXIgcjIgPSByYXRpbyAqIDI7XG5cbiAgICAvLyBzdGFydFxuICAgIHZlcnRzLnB1c2gocDF4IC0gcGVycHggKiByMSwgcDF5IC0gcGVycHkgKiByMSwgciwgZywgYiwgYWxwaGEpO1xuXG4gICAgdmVydHMucHVzaChwMXggKyBwZXJweCAqIHIyLCBwMXkgKyBwZXJweSAqIHIyLCByLCBnLCBiLCBhbHBoYSk7XG5cbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGxlbmd0aCAtIDE7ICsraSkge1xuICAgICAgICBwMXggPSBwb2ludHNbKGkgLSAxKSAqIDJdO1xuICAgICAgICBwMXkgPSBwb2ludHNbKGkgLSAxKSAqIDIgKyAxXTtcblxuICAgICAgICBwMnggPSBwb2ludHNbaSAqIDJdO1xuICAgICAgICBwMnkgPSBwb2ludHNbaSAqIDIgKyAxXTtcblxuICAgICAgICBwM3ggPSBwb2ludHNbKGkgKyAxKSAqIDJdO1xuICAgICAgICBwM3kgPSBwb2ludHNbKGkgKyAxKSAqIDIgKyAxXTtcblxuICAgICAgICBwZXJweCA9IC0ocDF5IC0gcDJ5KTtcbiAgICAgICAgcGVycHkgPSBwMXggLSBwMng7XG5cbiAgICAgICAgZGlzdCA9IE1hdGguc3FydChwZXJweCAqIHBlcnB4ICsgcGVycHkgKiBwZXJweSk7XG4gICAgICAgIHBlcnB4IC89IGRpc3Q7XG4gICAgICAgIHBlcnB5IC89IGRpc3Q7XG4gICAgICAgIHBlcnB4ICo9IHdpZHRoO1xuICAgICAgICBwZXJweSAqPSB3aWR0aDtcblxuICAgICAgICBwZXJwMnggPSAtKHAyeSAtIHAzeSk7XG4gICAgICAgIHBlcnAyeSA9IHAyeCAtIHAzeDtcblxuICAgICAgICBkaXN0ID0gTWF0aC5zcXJ0KHBlcnAyeCAqIHBlcnAyeCArIHBlcnAyeSAqIHBlcnAyeSk7XG4gICAgICAgIHBlcnAyeCAvPSBkaXN0O1xuICAgICAgICBwZXJwMnkgLz0gZGlzdDtcbiAgICAgICAgcGVycDJ4ICo9IHdpZHRoO1xuICAgICAgICBwZXJwMnkgKj0gd2lkdGg7XG5cbiAgICAgICAgdmFyIGExID0gLXBlcnB5ICsgcDF5IC0gKC1wZXJweSArIHAyeSk7XG4gICAgICAgIHZhciBiMSA9IC1wZXJweCArIHAyeCAtICgtcGVycHggKyBwMXgpO1xuICAgICAgICB2YXIgYzEgPSAoLXBlcnB4ICsgcDF4KSAqICgtcGVycHkgKyBwMnkpIC0gKC1wZXJweCArIHAyeCkgKiAoLXBlcnB5ICsgcDF5KTtcbiAgICAgICAgdmFyIGEyID0gLXBlcnAyeSArIHAzeSAtICgtcGVycDJ5ICsgcDJ5KTtcbiAgICAgICAgdmFyIGIyID0gLXBlcnAyeCArIHAyeCAtICgtcGVycDJ4ICsgcDN4KTtcbiAgICAgICAgdmFyIGMyID0gKC1wZXJwMnggKyBwM3gpICogKC1wZXJwMnkgKyBwMnkpIC0gKC1wZXJwMnggKyBwMngpICogKC1wZXJwMnkgKyBwM3kpO1xuXG4gICAgICAgIHZhciBkZW5vbSA9IGExICogYjIgLSBhMiAqIGIxO1xuXG4gICAgICAgIGlmIChNYXRoLmFicyhkZW5vbSkgPCAwLjEpIHtcbiAgICAgICAgICAgIGRlbm9tICs9IDEwLjE7XG4gICAgICAgICAgICB2ZXJ0cy5wdXNoKHAyeCAtIHBlcnB4ICogcjEsIHAyeSAtIHBlcnB5ICogcjEsIHIsIGcsIGIsIGFscGhhKTtcblxuICAgICAgICAgICAgdmVydHMucHVzaChwMnggKyBwZXJweCAqIHIyLCBwMnkgKyBwZXJweSAqIHIyLCByLCBnLCBiLCBhbHBoYSk7XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHB4ID0gKGIxICogYzIgLSBiMiAqIGMxKSAvIGRlbm9tO1xuICAgICAgICB2YXIgcHkgPSAoYTIgKiBjMSAtIGExICogYzIpIC8gZGVub207XG4gICAgICAgIHZhciBwZGlzdCA9IChweCAtIHAyeCkgKiAocHggLSBwMngpICsgKHB5IC0gcDJ5KSAqIChweSAtIHAyeSk7XG5cbiAgICAgICAgaWYgKHBkaXN0ID4gMTk2ICogd2lkdGggKiB3aWR0aCkge1xuICAgICAgICAgICAgcGVycDN4ID0gcGVycHggLSBwZXJwMng7XG4gICAgICAgICAgICBwZXJwM3kgPSBwZXJweSAtIHBlcnAyeTtcblxuICAgICAgICAgICAgZGlzdCA9IE1hdGguc3FydChwZXJwM3ggKiBwZXJwM3ggKyBwZXJwM3kgKiBwZXJwM3kpO1xuICAgICAgICAgICAgcGVycDN4IC89IGRpc3Q7XG4gICAgICAgICAgICBwZXJwM3kgLz0gZGlzdDtcbiAgICAgICAgICAgIHBlcnAzeCAqPSB3aWR0aDtcbiAgICAgICAgICAgIHBlcnAzeSAqPSB3aWR0aDtcblxuICAgICAgICAgICAgdmVydHMucHVzaChwMnggLSBwZXJwM3ggKiByMSwgcDJ5IC0gcGVycDN5ICogcjEpO1xuICAgICAgICAgICAgdmVydHMucHVzaChyLCBnLCBiLCBhbHBoYSk7XG5cbiAgICAgICAgICAgIHZlcnRzLnB1c2gocDJ4ICsgcGVycDN4ICogcjIsIHAyeSArIHBlcnAzeSAqIHIyKTtcbiAgICAgICAgICAgIHZlcnRzLnB1c2gociwgZywgYiwgYWxwaGEpO1xuXG4gICAgICAgICAgICB2ZXJ0cy5wdXNoKHAyeCAtIHBlcnAzeCAqIHIyICogcjEsIHAyeSAtIHBlcnAzeSAqIHIxKTtcbiAgICAgICAgICAgIHZlcnRzLnB1c2gociwgZywgYiwgYWxwaGEpO1xuXG4gICAgICAgICAgICBpbmRleENvdW50Kys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2ZXJ0cy5wdXNoKHAyeCArIChweCAtIHAyeCkgKiByMSwgcDJ5ICsgKHB5IC0gcDJ5KSAqIHIxKTtcbiAgICAgICAgICAgIHZlcnRzLnB1c2gociwgZywgYiwgYWxwaGEpO1xuXG4gICAgICAgICAgICB2ZXJ0cy5wdXNoKHAyeCAtIChweCAtIHAyeCkgKiByMiwgcDJ5IC0gKHB5IC0gcDJ5KSAqIHIyKTtcbiAgICAgICAgICAgIHZlcnRzLnB1c2gociwgZywgYiwgYWxwaGEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcDF4ID0gcG9pbnRzWyhsZW5ndGggLSAyKSAqIDJdO1xuICAgIHAxeSA9IHBvaW50c1sobGVuZ3RoIC0gMikgKiAyICsgMV07XG5cbiAgICBwMnggPSBwb2ludHNbKGxlbmd0aCAtIDEpICogMl07XG4gICAgcDJ5ID0gcG9pbnRzWyhsZW5ndGggLSAxKSAqIDIgKyAxXTtcblxuICAgIHBlcnB4ID0gLShwMXkgLSBwMnkpO1xuICAgIHBlcnB5ID0gcDF4IC0gcDJ4O1xuXG4gICAgZGlzdCA9IE1hdGguc3FydChwZXJweCAqIHBlcnB4ICsgcGVycHkgKiBwZXJweSk7XG4gICAgcGVycHggLz0gZGlzdDtcbiAgICBwZXJweSAvPSBkaXN0O1xuICAgIHBlcnB4ICo9IHdpZHRoO1xuICAgIHBlcnB5ICo9IHdpZHRoO1xuXG4gICAgdmVydHMucHVzaChwMnggLSBwZXJweCAqIHIxLCBwMnkgLSBwZXJweSAqIHIxKTtcbiAgICB2ZXJ0cy5wdXNoKHIsIGcsIGIsIGFscGhhKTtcblxuICAgIHZlcnRzLnB1c2gocDJ4ICsgcGVycHggKiByMiwgcDJ5ICsgcGVycHkgKiByMik7XG4gICAgdmVydHMucHVzaChyLCBnLCBiLCBhbHBoYSk7XG5cbiAgICBpbmRpY2VzLnB1c2goaW5kZXhTdGFydCk7XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgaW5kZXhDb3VudDsgKytfaSkge1xuICAgICAgICBpbmRpY2VzLnB1c2goaW5kZXhTdGFydCsrKTtcbiAgICB9XG5cbiAgICBpbmRpY2VzLnB1c2goaW5kZXhTdGFydCAtIDEpO1xufVxuXG4vKipcbiAqIEJ1aWxkcyBhIGxpbmUgdG8gZHJhdyB1c2luZyB0aGUgZ2wuZHJhd0FycmF5cyhnbC5MSU5FUykgbWV0aG9kXG4gKlxuICogSWdub3JlZCBmcm9tIGRvY3Mgc2luY2UgaXQgaXMgbm90IGRpcmVjdGx5IGV4cG9zZWQuXG4gKlxuICogQGlnbm9yZVxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7UElYSS5XZWJHTEdyYXBoaWNzRGF0YX0gZ3JhcGhpY3NEYXRhIC0gVGhlIGdyYXBoaWNzIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgbmVjZXNzYXJ5IHByb3BlcnRpZXNcbiAqIEBwYXJhbSB7b2JqZWN0fSB3ZWJHTERhdGEgLSBhbiBvYmplY3QgY29udGFpbmluZyBhbGwgdGhlIHdlYkdMLXNwZWNpZmljIGluZm9ybWF0aW9uIHRvIGNyZWF0ZSB0aGlzIHNoYXBlXG4gKi9cblxuXG4vKipcbiAqIEJ1aWxkcyBhIGxpbmUgdG8gZHJhd1xuICpcbiAqIElnbm9yZWQgZnJvbSBkb2NzIHNpbmNlIGl0IGlzIG5vdCBkaXJlY3RseSBleHBvc2VkLlxuICpcbiAqIEBpZ25vcmVcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1BJWEkuV2ViR0xHcmFwaGljc0RhdGF9IGdyYXBoaWNzRGF0YSAtIFRoZSBncmFwaGljcyBvYmplY3QgY29udGFpbmluZyBhbGwgdGhlIG5lY2Vzc2FyeSBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0ge29iamVjdH0gd2ViR0xEYXRhIC0gYW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSB3ZWJHTC1zcGVjaWZpYyBpbmZvcm1hdGlvbiB0byBjcmVhdGUgdGhpcyBzaGFwZVxuICogQHBhcmFtIHtvYmplY3R9IHdlYkdMRGF0YU5hdGl2ZUxpbmVzIC0gYW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSB3ZWJHTC1zcGVjaWZpYyBpbmZvcm1hdGlvbiB0byBjcmVhdGUgbmF0aXZlTGluZXNcbiAqL1xuZnVuY3Rpb24gYnVpbGROYXRpdmVMaW5lKGdyYXBoaWNzRGF0YSwgd2ViR0xEYXRhKSB7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBwb2ludHMgPSBncmFwaGljc0RhdGEucG9pbnRzO1xuXG4gICAgaWYgKHBvaW50cy5sZW5ndGggPT09IDApIHJldHVybjtcblxuICAgIHZhciB2ZXJ0cyA9IHdlYkdMRGF0YS5wb2ludHM7XG4gICAgdmFyIGxlbmd0aCA9IHBvaW50cy5sZW5ndGggLyAyO1xuXG4gICAgLy8gc29ydCBjb2xvclxuICAgIHZhciBjb2xvciA9ICgwLCBfdXRpbHMuaGV4MnJnYikoZ3JhcGhpY3NEYXRhLmxpbmVDb2xvcik7XG4gICAgdmFyIGFscGhhID0gZ3JhcGhpY3NEYXRhLmxpbmVBbHBoYTtcbiAgICB2YXIgciA9IGNvbG9yWzBdICogYWxwaGE7XG4gICAgdmFyIGcgPSBjb2xvclsxXSAqIGFscGhhO1xuICAgIHZhciBiID0gY29sb3JbMl0gKiBhbHBoYTtcblxuICAgIGZvciAoaSA9IDE7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcDF4ID0gcG9pbnRzWyhpIC0gMSkgKiAyXTtcbiAgICAgICAgdmFyIHAxeSA9IHBvaW50c1soaSAtIDEpICogMiArIDFdO1xuXG4gICAgICAgIHZhciBwMnggPSBwb2ludHNbaSAqIDJdO1xuICAgICAgICB2YXIgcDJ5ID0gcG9pbnRzW2kgKiAyICsgMV07XG5cbiAgICAgICAgdmVydHMucHVzaChwMXgsIHAxeSk7XG4gICAgICAgIHZlcnRzLnB1c2gociwgZywgYiwgYWxwaGEpO1xuXG4gICAgICAgIHZlcnRzLnB1c2gocDJ4LCBwMnkpO1xuICAgICAgICB2ZXJ0cy5wdXNoKHIsIGcsIGIsIGFscGhhKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1idWlsZExpbmUuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5kZWZhdWx0ID0gYnVpbGRQb2x5O1xuXG52YXIgX2J1aWxkTGluZSA9IHJlcXVpcmUoJy4vYnVpbGRMaW5lJyk7XG5cbnZhciBfYnVpbGRMaW5lMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2J1aWxkTGluZSk7XG5cbnZhciBfdXRpbHMgPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuXG52YXIgX2VhcmN1dCA9IHJlcXVpcmUoJ2VhcmN1dCcpO1xuXG52YXIgX2VhcmN1dDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9lYXJjdXQpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKipcbiAqIEJ1aWxkcyBhIHBvbHlnb24gdG8gZHJhd1xuICpcbiAqIElnbm9yZWQgZnJvbSBkb2NzIHNpbmNlIGl0IGlzIG5vdCBkaXJlY3RseSBleHBvc2VkLlxuICpcbiAqIEBpZ25vcmVcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1BJWEkuV2ViR0xHcmFwaGljc0RhdGF9IGdyYXBoaWNzRGF0YSAtIFRoZSBncmFwaGljcyBvYmplY3QgY29udGFpbmluZyBhbGwgdGhlIG5lY2Vzc2FyeSBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0ge29iamVjdH0gd2ViR0xEYXRhIC0gYW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSB3ZWJHTC1zcGVjaWZpYyBpbmZvcm1hdGlvbiB0byBjcmVhdGUgdGhpcyBzaGFwZVxuICogQHBhcmFtIHtvYmplY3R9IHdlYkdMRGF0YU5hdGl2ZUxpbmVzIC0gYW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSB3ZWJHTC1zcGVjaWZpYyBpbmZvcm1hdGlvbiB0byBjcmVhdGUgbmF0aXZlTGluZXNcbiAqL1xuZnVuY3Rpb24gYnVpbGRQb2x5KGdyYXBoaWNzRGF0YSwgd2ViR0xEYXRhLCB3ZWJHTERhdGFOYXRpdmVMaW5lcykge1xuICAgIGdyYXBoaWNzRGF0YS5wb2ludHMgPSBncmFwaGljc0RhdGEuc2hhcGUucG9pbnRzLnNsaWNlKCk7XG5cbiAgICB2YXIgcG9pbnRzID0gZ3JhcGhpY3NEYXRhLnBvaW50cztcblxuICAgIGlmIChncmFwaGljc0RhdGEuZmlsbCAmJiBwb2ludHMubGVuZ3RoID49IDYpIHtcbiAgICAgICAgdmFyIGhvbGVBcnJheSA9IFtdO1xuICAgICAgICAvLyBQcm9jZXNzIGhvbGVzLi5cbiAgICAgICAgdmFyIGhvbGVzID0gZ3JhcGhpY3NEYXRhLmhvbGVzO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9sZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBob2xlID0gaG9sZXNbaV07XG5cbiAgICAgICAgICAgIGhvbGVBcnJheS5wdXNoKHBvaW50cy5sZW5ndGggLyAyKTtcblxuICAgICAgICAgICAgcG9pbnRzID0gcG9pbnRzLmNvbmNhdChob2xlLnBvaW50cyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBnZXQgZmlyc3QgYW5kIGxhc3QgcG9pbnQuLiBmaWd1cmUgb3V0IHRoZSBtaWRkbGUhXG4gICAgICAgIHZhciB2ZXJ0cyA9IHdlYkdMRGF0YS5wb2ludHM7XG4gICAgICAgIHZhciBpbmRpY2VzID0gd2ViR0xEYXRhLmluZGljZXM7XG5cbiAgICAgICAgdmFyIGxlbmd0aCA9IHBvaW50cy5sZW5ndGggLyAyO1xuXG4gICAgICAgIC8vIHNvcnQgY29sb3JcbiAgICAgICAgdmFyIGNvbG9yID0gKDAsIF91dGlscy5oZXgycmdiKShncmFwaGljc0RhdGEuZmlsbENvbG9yKTtcbiAgICAgICAgdmFyIGFscGhhID0gZ3JhcGhpY3NEYXRhLmZpbGxBbHBoYTtcbiAgICAgICAgdmFyIHIgPSBjb2xvclswXSAqIGFscGhhO1xuICAgICAgICB2YXIgZyA9IGNvbG9yWzFdICogYWxwaGE7XG4gICAgICAgIHZhciBiID0gY29sb3JbMl0gKiBhbHBoYTtcblxuICAgICAgICB2YXIgdHJpYW5nbGVzID0gKDAsIF9lYXJjdXQyLmRlZmF1bHQpKHBvaW50cywgaG9sZUFycmF5LCAyKTtcblxuICAgICAgICBpZiAoIXRyaWFuZ2xlcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHZlcnRQb3MgPSB2ZXJ0cy5sZW5ndGggLyA2O1xuXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCB0cmlhbmdsZXMubGVuZ3RoOyBfaSArPSAzKSB7XG4gICAgICAgICAgICBpbmRpY2VzLnB1c2godHJpYW5nbGVzW19pXSArIHZlcnRQb3MpO1xuICAgICAgICAgICAgaW5kaWNlcy5wdXNoKHRyaWFuZ2xlc1tfaV0gKyB2ZXJ0UG9zKTtcbiAgICAgICAgICAgIGluZGljZXMucHVzaCh0cmlhbmdsZXNbX2kgKyAxXSArIHZlcnRQb3MpO1xuICAgICAgICAgICAgaW5kaWNlcy5wdXNoKHRyaWFuZ2xlc1tfaSArIDJdICsgdmVydFBvcyk7XG4gICAgICAgICAgICBpbmRpY2VzLnB1c2godHJpYW5nbGVzW19pICsgMl0gKyB2ZXJ0UG9zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IGxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgICAgIHZlcnRzLnB1c2gocG9pbnRzW19pMiAqIDJdLCBwb2ludHNbX2kyICogMiArIDFdLCByLCBnLCBiLCBhbHBoYSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZ3JhcGhpY3NEYXRhLmxpbmVXaWR0aCA+IDApIHtcbiAgICAgICAgKDAsIF9idWlsZExpbmUyLmRlZmF1bHQpKGdyYXBoaWNzRGF0YSwgd2ViR0xEYXRhLCB3ZWJHTERhdGFOYXRpdmVMaW5lcyk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnVpbGRQb2x5LmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuZGVmYXVsdCA9IGJ1aWxkUmVjdGFuZ2xlO1xuXG52YXIgX2J1aWxkTGluZSA9IHJlcXVpcmUoJy4vYnVpbGRMaW5lJyk7XG5cbnZhciBfYnVpbGRMaW5lMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2J1aWxkTGluZSk7XG5cbnZhciBfdXRpbHMgPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKipcbiAqIEJ1aWxkcyBhIHJlY3RhbmdsZSB0byBkcmF3XG4gKlxuICogSWdub3JlZCBmcm9tIGRvY3Mgc2luY2UgaXQgaXMgbm90IGRpcmVjdGx5IGV4cG9zZWQuXG4gKlxuICogQGlnbm9yZVxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7UElYSS5XZWJHTEdyYXBoaWNzRGF0YX0gZ3JhcGhpY3NEYXRhIC0gVGhlIGdyYXBoaWNzIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgbmVjZXNzYXJ5IHByb3BlcnRpZXNcbiAqIEBwYXJhbSB7b2JqZWN0fSB3ZWJHTERhdGEgLSBhbiBvYmplY3QgY29udGFpbmluZyBhbGwgdGhlIHdlYkdMLXNwZWNpZmljIGluZm9ybWF0aW9uIHRvIGNyZWF0ZSB0aGlzIHNoYXBlXG4gKiBAcGFyYW0ge29iamVjdH0gd2ViR0xEYXRhTmF0aXZlTGluZXMgLSBhbiBvYmplY3QgY29udGFpbmluZyBhbGwgdGhlIHdlYkdMLXNwZWNpZmljIGluZm9ybWF0aW9uIHRvIGNyZWF0ZSBuYXRpdmVMaW5lc1xuICovXG5mdW5jdGlvbiBidWlsZFJlY3RhbmdsZShncmFwaGljc0RhdGEsIHdlYkdMRGF0YSwgd2ViR0xEYXRhTmF0aXZlTGluZXMpIHtcbiAgICAvLyAtLS0gLy9cbiAgICAvLyBuZWVkIHRvIGNvbnZlcnQgcG9pbnRzIHRvIGEgbmljZSByZWd1bGFyIGRhdGFcbiAgICAvL1xuICAgIHZhciByZWN0RGF0YSA9IGdyYXBoaWNzRGF0YS5zaGFwZTtcbiAgICB2YXIgeCA9IHJlY3REYXRhLng7XG4gICAgdmFyIHkgPSByZWN0RGF0YS55O1xuICAgIHZhciB3aWR0aCA9IHJlY3REYXRhLndpZHRoO1xuICAgIHZhciBoZWlnaHQgPSByZWN0RGF0YS5oZWlnaHQ7XG5cbiAgICBpZiAoZ3JhcGhpY3NEYXRhLmZpbGwpIHtcbiAgICAgICAgdmFyIGNvbG9yID0gKDAsIF91dGlscy5oZXgycmdiKShncmFwaGljc0RhdGEuZmlsbENvbG9yKTtcbiAgICAgICAgdmFyIGFscGhhID0gZ3JhcGhpY3NEYXRhLmZpbGxBbHBoYTtcblxuICAgICAgICB2YXIgciA9IGNvbG9yWzBdICogYWxwaGE7XG4gICAgICAgIHZhciBnID0gY29sb3JbMV0gKiBhbHBoYTtcbiAgICAgICAgdmFyIGIgPSBjb2xvclsyXSAqIGFscGhhO1xuXG4gICAgICAgIHZhciB2ZXJ0cyA9IHdlYkdMRGF0YS5wb2ludHM7XG4gICAgICAgIHZhciBpbmRpY2VzID0gd2ViR0xEYXRhLmluZGljZXM7XG5cbiAgICAgICAgdmFyIHZlcnRQb3MgPSB2ZXJ0cy5sZW5ndGggLyA2O1xuXG4gICAgICAgIC8vIHN0YXJ0XG4gICAgICAgIHZlcnRzLnB1c2goeCwgeSk7XG4gICAgICAgIHZlcnRzLnB1c2gociwgZywgYiwgYWxwaGEpO1xuXG4gICAgICAgIHZlcnRzLnB1c2goeCArIHdpZHRoLCB5KTtcbiAgICAgICAgdmVydHMucHVzaChyLCBnLCBiLCBhbHBoYSk7XG5cbiAgICAgICAgdmVydHMucHVzaCh4LCB5ICsgaGVpZ2h0KTtcbiAgICAgICAgdmVydHMucHVzaChyLCBnLCBiLCBhbHBoYSk7XG5cbiAgICAgICAgdmVydHMucHVzaCh4ICsgd2lkdGgsIHkgKyBoZWlnaHQpO1xuICAgICAgICB2ZXJ0cy5wdXNoKHIsIGcsIGIsIGFscGhhKTtcblxuICAgICAgICAvLyBpbnNlcnQgMiBkZWFkIHRyaWFuZ2xlcy4uXG4gICAgICAgIGluZGljZXMucHVzaCh2ZXJ0UG9zLCB2ZXJ0UG9zLCB2ZXJ0UG9zICsgMSwgdmVydFBvcyArIDIsIHZlcnRQb3MgKyAzLCB2ZXJ0UG9zICsgMyk7XG4gICAgfVxuXG4gICAgaWYgKGdyYXBoaWNzRGF0YS5saW5lV2lkdGgpIHtcbiAgICAgICAgdmFyIHRlbXBQb2ludHMgPSBncmFwaGljc0RhdGEucG9pbnRzO1xuXG4gICAgICAgIGdyYXBoaWNzRGF0YS5wb2ludHMgPSBbeCwgeSwgeCArIHdpZHRoLCB5LCB4ICsgd2lkdGgsIHkgKyBoZWlnaHQsIHgsIHkgKyBoZWlnaHQsIHgsIHldO1xuXG4gICAgICAgICgwLCBfYnVpbGRMaW5lMi5kZWZhdWx0KShncmFwaGljc0RhdGEsIHdlYkdMRGF0YSwgd2ViR0xEYXRhTmF0aXZlTGluZXMpO1xuXG4gICAgICAgIGdyYXBoaWNzRGF0YS5wb2ludHMgPSB0ZW1wUG9pbnRzO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1aWxkUmVjdGFuZ2xlLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuZGVmYXVsdCA9IGJ1aWxkUm91bmRlZFJlY3RhbmdsZTtcblxudmFyIF9lYXJjdXQgPSByZXF1aXJlKCdlYXJjdXQnKTtcblxudmFyIF9lYXJjdXQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZWFyY3V0KTtcblxudmFyIF9idWlsZExpbmUgPSByZXF1aXJlKCcuL2J1aWxkTGluZScpO1xuXG52YXIgX2J1aWxkTGluZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9idWlsZExpbmUpO1xuXG52YXIgX3V0aWxzID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLyoqXG4gKiBCdWlsZHMgYSByb3VuZGVkIHJlY3RhbmdsZSB0byBkcmF3XG4gKlxuICogSWdub3JlZCBmcm9tIGRvY3Mgc2luY2UgaXQgaXMgbm90IGRpcmVjdGx5IGV4cG9zZWQuXG4gKlxuICogQGlnbm9yZVxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7UElYSS5XZWJHTEdyYXBoaWNzRGF0YX0gZ3JhcGhpY3NEYXRhIC0gVGhlIGdyYXBoaWNzIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgbmVjZXNzYXJ5IHByb3BlcnRpZXNcbiAqIEBwYXJhbSB7b2JqZWN0fSB3ZWJHTERhdGEgLSBhbiBvYmplY3QgY29udGFpbmluZyBhbGwgdGhlIHdlYkdMLXNwZWNpZmljIGluZm9ybWF0aW9uIHRvIGNyZWF0ZSB0aGlzIHNoYXBlXG4gKiBAcGFyYW0ge29iamVjdH0gd2ViR0xEYXRhTmF0aXZlTGluZXMgLSBhbiBvYmplY3QgY29udGFpbmluZyBhbGwgdGhlIHdlYkdMLXNwZWNpZmljIGluZm9ybWF0aW9uIHRvIGNyZWF0ZSBuYXRpdmVMaW5lc1xuICovXG5mdW5jdGlvbiBidWlsZFJvdW5kZWRSZWN0YW5nbGUoZ3JhcGhpY3NEYXRhLCB3ZWJHTERhdGEsIHdlYkdMRGF0YU5hdGl2ZUxpbmVzKSB7XG4gICAgdmFyIHJyZWN0RGF0YSA9IGdyYXBoaWNzRGF0YS5zaGFwZTtcbiAgICB2YXIgeCA9IHJyZWN0RGF0YS54O1xuICAgIHZhciB5ID0gcnJlY3REYXRhLnk7XG4gICAgdmFyIHdpZHRoID0gcnJlY3REYXRhLndpZHRoO1xuICAgIHZhciBoZWlnaHQgPSBycmVjdERhdGEuaGVpZ2h0O1xuXG4gICAgdmFyIHJhZGl1cyA9IHJyZWN0RGF0YS5yYWRpdXM7XG5cbiAgICB2YXIgcmVjUG9pbnRzID0gW107XG5cbiAgICByZWNQb2ludHMucHVzaCh4ICsgcmFkaXVzLCB5KTtcbiAgICBxdWFkcmF0aWNCZXppZXJDdXJ2ZSh4ICsgd2lkdGggLSByYWRpdXMsIHksIHggKyB3aWR0aCwgeSwgeCArIHdpZHRoLCB5ICsgcmFkaXVzLCByZWNQb2ludHMpO1xuICAgIHF1YWRyYXRpY0JlemllckN1cnZlKHggKyB3aWR0aCwgeSArIGhlaWdodCAtIHJhZGl1cywgeCArIHdpZHRoLCB5ICsgaGVpZ2h0LCB4ICsgd2lkdGggLSByYWRpdXMsIHkgKyBoZWlnaHQsIHJlY1BvaW50cyk7XG4gICAgcXVhZHJhdGljQmV6aWVyQ3VydmUoeCArIHJhZGl1cywgeSArIGhlaWdodCwgeCwgeSArIGhlaWdodCwgeCwgeSArIGhlaWdodCAtIHJhZGl1cywgcmVjUG9pbnRzKTtcbiAgICBxdWFkcmF0aWNCZXppZXJDdXJ2ZSh4LCB5ICsgcmFkaXVzLCB4LCB5LCB4ICsgcmFkaXVzICsgMC4wMDAwMDAwMDAxLCB5LCByZWNQb2ludHMpO1xuXG4gICAgLy8gdGhpcyB0aW55IG51bWJlciBkZWFscyB3aXRoIHRoZSBpc3N1ZSB0aGF0IG9jY3VycyB3aGVuIHBvaW50cyBvdmVybGFwIGFuZCBlYXJjdXQgZmFpbHMgdG8gdHJpYW5ndWxhdGUgdGhlIGl0ZW0uXG4gICAgLy8gVE9ETyAtIGZpeCB0aGlzIHByb3Blcmx5LCB0aGlzIGlzIG5vdCB2ZXJ5IGVsZWdhbnQuLiBidXQgaXQgd29ya3MgZm9yIG5vdy5cblxuICAgIGlmIChncmFwaGljc0RhdGEuZmlsbCkge1xuICAgICAgICB2YXIgY29sb3IgPSAoMCwgX3V0aWxzLmhleDJyZ2IpKGdyYXBoaWNzRGF0YS5maWxsQ29sb3IpO1xuICAgICAgICB2YXIgYWxwaGEgPSBncmFwaGljc0RhdGEuZmlsbEFscGhhO1xuXG4gICAgICAgIHZhciByID0gY29sb3JbMF0gKiBhbHBoYTtcbiAgICAgICAgdmFyIGcgPSBjb2xvclsxXSAqIGFscGhhO1xuICAgICAgICB2YXIgYiA9IGNvbG9yWzJdICogYWxwaGE7XG5cbiAgICAgICAgdmFyIHZlcnRzID0gd2ViR0xEYXRhLnBvaW50cztcbiAgICAgICAgdmFyIGluZGljZXMgPSB3ZWJHTERhdGEuaW5kaWNlcztcblxuICAgICAgICB2YXIgdmVjUG9zID0gdmVydHMubGVuZ3RoIC8gNjtcblxuICAgICAgICB2YXIgdHJpYW5nbGVzID0gKDAsIF9lYXJjdXQyLmRlZmF1bHQpKHJlY1BvaW50cywgbnVsbCwgMik7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSB0cmlhbmdsZXMubGVuZ3RoOyBpIDwgajsgaSArPSAzKSB7XG4gICAgICAgICAgICBpbmRpY2VzLnB1c2godHJpYW5nbGVzW2ldICsgdmVjUG9zKTtcbiAgICAgICAgICAgIGluZGljZXMucHVzaCh0cmlhbmdsZXNbaV0gKyB2ZWNQb3MpO1xuICAgICAgICAgICAgaW5kaWNlcy5wdXNoKHRyaWFuZ2xlc1tpICsgMV0gKyB2ZWNQb3MpO1xuICAgICAgICAgICAgaW5kaWNlcy5wdXNoKHRyaWFuZ2xlc1tpICsgMl0gKyB2ZWNQb3MpO1xuICAgICAgICAgICAgaW5kaWNlcy5wdXNoKHRyaWFuZ2xlc1tpICsgMl0gKyB2ZWNQb3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfaiA9IHJlY1BvaW50cy5sZW5ndGg7IF9pIDwgX2o7IF9pKyspIHtcbiAgICAgICAgICAgIHZlcnRzLnB1c2gocmVjUG9pbnRzW19pXSwgcmVjUG9pbnRzWysrX2ldLCByLCBnLCBiLCBhbHBoYSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZ3JhcGhpY3NEYXRhLmxpbmVXaWR0aCkge1xuICAgICAgICB2YXIgdGVtcFBvaW50cyA9IGdyYXBoaWNzRGF0YS5wb2ludHM7XG5cbiAgICAgICAgZ3JhcGhpY3NEYXRhLnBvaW50cyA9IHJlY1BvaW50cztcblxuICAgICAgICAoMCwgX2J1aWxkTGluZTIuZGVmYXVsdCkoZ3JhcGhpY3NEYXRhLCB3ZWJHTERhdGEsIHdlYkdMRGF0YU5hdGl2ZUxpbmVzKTtcblxuICAgICAgICBncmFwaGljc0RhdGEucG9pbnRzID0gdGVtcFBvaW50cztcbiAgICB9XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIGEgc2luZ2xlIHBvaW50IGZvciBhIHF1YWRyYXRpYyBiZXppZXIgY3VydmUuXG4gKiBVdGlsaXR5IGZ1bmN0aW9uIHVzZWQgYnkgcXVhZHJhdGljQmV6aWVyQ3VydmUuXG4gKiBJZ25vcmVkIGZyb20gZG9jcyBzaW5jZSBpdCBpcyBub3QgZGlyZWN0bHkgZXhwb3NlZC5cbiAqXG4gKiBAaWdub3JlXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IG4xIC0gZmlyc3QgbnVtYmVyXG4gKiBAcGFyYW0ge251bWJlcn0gbjIgLSBzZWNvbmQgbnVtYmVyXG4gKiBAcGFyYW0ge251bWJlcn0gcGVyYyAtIHBlcmNlbnRhZ2VcbiAqIEByZXR1cm4ge251bWJlcn0gdGhlIHJlc3VsdFxuICpcbiAqL1xuZnVuY3Rpb24gZ2V0UHQobjEsIG4yLCBwZXJjKSB7XG4gICAgdmFyIGRpZmYgPSBuMiAtIG4xO1xuXG4gICAgcmV0dXJuIG4xICsgZGlmZiAqIHBlcmM7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSBwb2ludHMgZm9yIGEgcXVhZHJhdGljIGJlemllciBjdXJ2ZS4gKGhlbHBlciBmdW5jdGlvbi4uKVxuICogQmFzZWQgb246IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzc4NTA5Ny9ob3ctZG8taS1pbXBsZW1lbnQtYS1iZXppZXItY3VydmUtaW4tY1xuICpcbiAqIElnbm9yZWQgZnJvbSBkb2NzIHNpbmNlIGl0IGlzIG5vdCBkaXJlY3RseSBleHBvc2VkLlxuICpcbiAqIEBpZ25vcmVcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbVggLSBPcmlnaW4gcG9pbnQgeFxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21ZIC0gT3JpZ2luIHBvaW50IHhcbiAqIEBwYXJhbSB7bnVtYmVyfSBjcFggLSBDb250cm9sIHBvaW50IHhcbiAqIEBwYXJhbSB7bnVtYmVyfSBjcFkgLSBDb250cm9sIHBvaW50IHlcbiAqIEBwYXJhbSB7bnVtYmVyfSB0b1ggLSBEZXN0aW5hdGlvbiBwb2ludCB4XG4gKiBAcGFyYW0ge251bWJlcn0gdG9ZIC0gRGVzdGluYXRpb24gcG9pbnQgeVxuICogQHBhcmFtIHtudW1iZXJbXX0gW291dD1bXV0gLSBUaGUgb3V0cHV0IGFycmF5IHRvIGFkZCBwb2ludHMgaW50by4gSWYgbm90IHBhc3NlZCwgYSBuZXcgYXJyYXkgaXMgY3JlYXRlZC5cbiAqIEByZXR1cm4ge251bWJlcltdfSBhbiBhcnJheSBvZiBwb2ludHNcbiAqL1xuZnVuY3Rpb24gcXVhZHJhdGljQmV6aWVyQ3VydmUoZnJvbVgsIGZyb21ZLCBjcFgsIGNwWSwgdG9YLCB0b1kpIHtcbiAgICB2YXIgb3V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDYgJiYgYXJndW1lbnRzWzZdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNl0gOiBbXTtcblxuICAgIHZhciBuID0gMjA7XG4gICAgdmFyIHBvaW50cyA9IG91dDtcblxuICAgIHZhciB4YSA9IDA7XG4gICAgdmFyIHlhID0gMDtcbiAgICB2YXIgeGIgPSAwO1xuICAgIHZhciB5YiA9IDA7XG4gICAgdmFyIHggPSAwO1xuICAgIHZhciB5ID0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwLCBqID0gMDsgaSA8PSBuOyArK2kpIHtcbiAgICAgICAgaiA9IGkgLyBuO1xuXG4gICAgICAgIC8vIFRoZSBHcmVlbiBMaW5lXG4gICAgICAgIHhhID0gZ2V0UHQoZnJvbVgsIGNwWCwgaik7XG4gICAgICAgIHlhID0gZ2V0UHQoZnJvbVksIGNwWSwgaik7XG4gICAgICAgIHhiID0gZ2V0UHQoY3BYLCB0b1gsIGopO1xuICAgICAgICB5YiA9IGdldFB0KGNwWSwgdG9ZLCBqKTtcblxuICAgICAgICAvLyBUaGUgQmxhY2sgRG90XG4gICAgICAgIHggPSBnZXRQdCh4YSwgeGIsIGopO1xuICAgICAgICB5ID0gZ2V0UHQoeWEsIHliLCBqKTtcblxuICAgICAgICBwb2ludHMucHVzaCh4LCB5KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcG9pbnRzO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnVpbGRSb3VuZGVkUmVjdGFuZ2xlLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuYXV0b0RldGVjdFJlbmRlcmVyID0gZXhwb3J0cy5BcHBsaWNhdGlvbiA9IGV4cG9ydHMuRmlsdGVyID0gZXhwb3J0cy5TcHJpdGVNYXNrRmlsdGVyID0gZXhwb3J0cy5RdWFkID0gZXhwb3J0cy5SZW5kZXJUYXJnZXQgPSBleHBvcnRzLk9iamVjdFJlbmRlcmVyID0gZXhwb3J0cy5XZWJHTE1hbmFnZXIgPSBleHBvcnRzLlNoYWRlciA9IGV4cG9ydHMuQ2FudmFzUmVuZGVyVGFyZ2V0ID0gZXhwb3J0cy5UZXh0dXJlVXZzID0gZXhwb3J0cy5WaWRlb0Jhc2VUZXh0dXJlID0gZXhwb3J0cy5CYXNlUmVuZGVyVGV4dHVyZSA9IGV4cG9ydHMuUmVuZGVyVGV4dHVyZSA9IGV4cG9ydHMuQmFzZVRleHR1cmUgPSBleHBvcnRzLlRleHR1cmVNYXRyaXggPSBleHBvcnRzLlRleHR1cmUgPSBleHBvcnRzLlNwcml0ZXNoZWV0ID0gZXhwb3J0cy5DYW52YXNHcmFwaGljc1JlbmRlcmVyID0gZXhwb3J0cy5HcmFwaGljc1JlbmRlcmVyID0gZXhwb3J0cy5HcmFwaGljc0RhdGEgPSBleHBvcnRzLkdyYXBoaWNzID0gZXhwb3J0cy5UZXh0TWV0cmljcyA9IGV4cG9ydHMuVGV4dFN0eWxlID0gZXhwb3J0cy5UZXh0ID0gZXhwb3J0cy5TcHJpdGVSZW5kZXJlciA9IGV4cG9ydHMuQ2FudmFzVGludGVyID0gZXhwb3J0cy5DYW52YXNTcHJpdGVSZW5kZXJlciA9IGV4cG9ydHMuU3ByaXRlID0gZXhwb3J0cy5UcmFuc2Zvcm1CYXNlID0gZXhwb3J0cy5UcmFuc2Zvcm1TdGF0aWMgPSBleHBvcnRzLlRyYW5zZm9ybSA9IGV4cG9ydHMuQ29udGFpbmVyID0gZXhwb3J0cy5EaXNwbGF5T2JqZWN0ID0gZXhwb3J0cy5Cb3VuZHMgPSBleHBvcnRzLmdsQ29yZSA9IGV4cG9ydHMuV2ViR0xSZW5kZXJlciA9IGV4cG9ydHMuQ2FudmFzUmVuZGVyZXIgPSBleHBvcnRzLnRpY2tlciA9IGV4cG9ydHMudXRpbHMgPSBleHBvcnRzLnNldHRpbmdzID0gdW5kZWZpbmVkO1xuXG52YXIgX2NvbnN0ID0gcmVxdWlyZSgnLi9jb25zdCcpO1xuXG5PYmplY3Qua2V5cyhfY29uc3QpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIF9jb25zdFtrZXldO1xuICAgIH1cbiAgfSk7XG59KTtcblxudmFyIF9tYXRoID0gcmVxdWlyZSgnLi9tYXRoJyk7XG5cbk9iamVjdC5rZXlzKF9tYXRoKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBfbWF0aFtrZXldO1xuICAgIH1cbiAgfSk7XG59KTtcblxudmFyIF9waXhpR2xDb3JlID0gcmVxdWlyZSgncGl4aS1nbC1jb3JlJyk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnZ2xDb3JlJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGl4aUdsQ29yZSkuZGVmYXVsdDtcbiAgfVxufSk7XG5cbnZhciBfQm91bmRzID0gcmVxdWlyZSgnLi9kaXNwbGF5L0JvdW5kcycpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ0JvdW5kcycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0JvdW5kcykuZGVmYXVsdDtcbiAgfVxufSk7XG5cbnZhciBfRGlzcGxheU9iamVjdCA9IHJlcXVpcmUoJy4vZGlzcGxheS9EaXNwbGF5T2JqZWN0Jyk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnRGlzcGxheU9iamVjdCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Rpc3BsYXlPYmplY3QpLmRlZmF1bHQ7XG4gIH1cbn0pO1xuXG52YXIgX0NvbnRhaW5lciA9IHJlcXVpcmUoJy4vZGlzcGxheS9Db250YWluZXInKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdDb250YWluZXInLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Db250YWluZXIpLmRlZmF1bHQ7XG4gIH1cbn0pO1xuXG52YXIgX1RyYW5zZm9ybSA9IHJlcXVpcmUoJy4vZGlzcGxheS9UcmFuc2Zvcm0nKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdUcmFuc2Zvcm0nLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9UcmFuc2Zvcm0pLmRlZmF1bHQ7XG4gIH1cbn0pO1xuXG52YXIgX1RyYW5zZm9ybVN0YXRpYyA9IHJlcXVpcmUoJy4vZGlzcGxheS9UcmFuc2Zvcm1TdGF0aWMnKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdUcmFuc2Zvcm1TdGF0aWMnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9UcmFuc2Zvcm1TdGF0aWMpLmRlZmF1bHQ7XG4gIH1cbn0pO1xuXG52YXIgX1RyYW5zZm9ybUJhc2UgPSByZXF1aXJlKCcuL2Rpc3BsYXkvVHJhbnNmb3JtQmFzZScpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ1RyYW5zZm9ybUJhc2UnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9UcmFuc2Zvcm1CYXNlKS5kZWZhdWx0O1xuICB9XG59KTtcblxudmFyIF9TcHJpdGUgPSByZXF1aXJlKCcuL3Nwcml0ZXMvU3ByaXRlJyk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnU3ByaXRlJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU3ByaXRlKS5kZWZhdWx0O1xuICB9XG59KTtcblxudmFyIF9DYW52YXNTcHJpdGVSZW5kZXJlciA9IHJlcXVpcmUoJy4vc3ByaXRlcy9jYW52YXMvQ2FudmFzU3ByaXRlUmVuZGVyZXInKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdDYW52YXNTcHJpdGVSZW5kZXJlcicsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0NhbnZhc1Nwcml0ZVJlbmRlcmVyKS5kZWZhdWx0O1xuICB9XG59KTtcblxudmFyIF9DYW52YXNUaW50ZXIgPSByZXF1aXJlKCcuL3Nwcml0ZXMvY2FudmFzL0NhbnZhc1RpbnRlcicpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ0NhbnZhc1RpbnRlcicsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0NhbnZhc1RpbnRlcikuZGVmYXVsdDtcbiAgfVxufSk7XG5cbnZhciBfU3ByaXRlUmVuZGVyZXIgPSByZXF1aXJlKCcuL3Nwcml0ZXMvd2ViZ2wvU3ByaXRlUmVuZGVyZXInKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdTcHJpdGVSZW5kZXJlcicsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1Nwcml0ZVJlbmRlcmVyKS5kZWZhdWx0O1xuICB9XG59KTtcblxudmFyIF9UZXh0ID0gcmVxdWlyZSgnLi90ZXh0L1RleHQnKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdUZXh0Jywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVGV4dCkuZGVmYXVsdDtcbiAgfVxufSk7XG5cbnZhciBfVGV4dFN0eWxlID0gcmVxdWlyZSgnLi90ZXh0L1RleHRTdHlsZScpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ1RleHRTdHlsZScsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1RleHRTdHlsZSkuZGVmYXVsdDtcbiAgfVxufSk7XG5cbnZhciBfVGV4dE1ldHJpY3MgPSByZXF1aXJlKCcuL3RleHQvVGV4dE1ldHJpY3MnKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdUZXh0TWV0cmljcycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1RleHRNZXRyaWNzKS5kZWZhdWx0O1xuICB9XG59KTtcblxudmFyIF9HcmFwaGljcyA9IHJlcXVpcmUoJy4vZ3JhcGhpY3MvR3JhcGhpY3MnKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdHcmFwaGljcycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0dyYXBoaWNzKS5kZWZhdWx0O1xuICB9XG59KTtcblxudmFyIF9HcmFwaGljc0RhdGEgPSByZXF1aXJlKCcuL2dyYXBoaWNzL0dyYXBoaWNzRGF0YScpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ0dyYXBoaWNzRGF0YScsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0dyYXBoaWNzRGF0YSkuZGVmYXVsdDtcbiAgfVxufSk7XG5cbnZhciBfR3JhcGhpY3NSZW5kZXJlciA9IHJlcXVpcmUoJy4vZ3JhcGhpY3Mvd2ViZ2wvR3JhcGhpY3NSZW5kZXJlcicpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ0dyYXBoaWNzUmVuZGVyZXInLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9HcmFwaGljc1JlbmRlcmVyKS5kZWZhdWx0O1xuICB9XG59KTtcblxudmFyIF9DYW52YXNHcmFwaGljc1JlbmRlcmVyID0gcmVxdWlyZSgnLi9ncmFwaGljcy9jYW52YXMvQ2FudmFzR3JhcGhpY3NSZW5kZXJlcicpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ0NhbnZhc0dyYXBoaWNzUmVuZGVyZXInLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9DYW52YXNHcmFwaGljc1JlbmRlcmVyKS5kZWZhdWx0O1xuICB9XG59KTtcblxudmFyIF9TcHJpdGVzaGVldCA9IHJlcXVpcmUoJy4vdGV4dHVyZXMvU3ByaXRlc2hlZXQnKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdTcHJpdGVzaGVldCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1Nwcml0ZXNoZWV0KS5kZWZhdWx0O1xuICB9XG59KTtcblxudmFyIF9UZXh0dXJlID0gcmVxdWlyZSgnLi90ZXh0dXJlcy9UZXh0dXJlJyk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnVGV4dHVyZScsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1RleHR1cmUpLmRlZmF1bHQ7XG4gIH1cbn0pO1xuXG52YXIgX1RleHR1cmVNYXRyaXggPSByZXF1aXJlKCcuL3RleHR1cmVzL1RleHR1cmVNYXRyaXgnKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdUZXh0dXJlTWF0cml4Jywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVGV4dHVyZU1hdHJpeCkuZGVmYXVsdDtcbiAgfVxufSk7XG5cbnZhciBfQmFzZVRleHR1cmUgPSByZXF1aXJlKCcuL3RleHR1cmVzL0Jhc2VUZXh0dXJlJyk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnQmFzZVRleHR1cmUnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9CYXNlVGV4dHVyZSkuZGVmYXVsdDtcbiAgfVxufSk7XG5cbnZhciBfUmVuZGVyVGV4dHVyZSA9IHJlcXVpcmUoJy4vdGV4dHVyZXMvUmVuZGVyVGV4dHVyZScpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ1JlbmRlclRleHR1cmUnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9SZW5kZXJUZXh0dXJlKS5kZWZhdWx0O1xuICB9XG59KTtcblxudmFyIF9CYXNlUmVuZGVyVGV4dHVyZSA9IHJlcXVpcmUoJy4vdGV4dHVyZXMvQmFzZVJlbmRlclRleHR1cmUnKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdCYXNlUmVuZGVyVGV4dHVyZScsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Jhc2VSZW5kZXJUZXh0dXJlKS5kZWZhdWx0O1xuICB9XG59KTtcblxudmFyIF9WaWRlb0Jhc2VUZXh0dXJlID0gcmVxdWlyZSgnLi90ZXh0dXJlcy9WaWRlb0Jhc2VUZXh0dXJlJyk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnVmlkZW9CYXNlVGV4dHVyZScsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1ZpZGVvQmFzZVRleHR1cmUpLmRlZmF1bHQ7XG4gIH1cbn0pO1xuXG52YXIgX1RleHR1cmVVdnMgPSByZXF1aXJlKCcuL3RleHR1cmVzL1RleHR1cmVVdnMnKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdUZXh0dXJlVXZzJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVGV4dHVyZVV2cykuZGVmYXVsdDtcbiAgfVxufSk7XG5cbnZhciBfQ2FudmFzUmVuZGVyVGFyZ2V0ID0gcmVxdWlyZSgnLi9yZW5kZXJlcnMvY2FudmFzL3V0aWxzL0NhbnZhc1JlbmRlclRhcmdldCcpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ0NhbnZhc1JlbmRlclRhcmdldCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0NhbnZhc1JlbmRlclRhcmdldCkuZGVmYXVsdDtcbiAgfVxufSk7XG5cbnZhciBfU2hhZGVyID0gcmVxdWlyZSgnLi9TaGFkZXInKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdTaGFkZXInLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9TaGFkZXIpLmRlZmF1bHQ7XG4gIH1cbn0pO1xuXG52YXIgX1dlYkdMTWFuYWdlciA9IHJlcXVpcmUoJy4vcmVuZGVyZXJzL3dlYmdsL21hbmFnZXJzL1dlYkdMTWFuYWdlcicpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ1dlYkdMTWFuYWdlcicsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1dlYkdMTWFuYWdlcikuZGVmYXVsdDtcbiAgfVxufSk7XG5cbnZhciBfT2JqZWN0UmVuZGVyZXIgPSByZXF1aXJlKCcuL3JlbmRlcmVycy93ZWJnbC91dGlscy9PYmplY3RSZW5kZXJlcicpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ09iamVjdFJlbmRlcmVyJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfT2JqZWN0UmVuZGVyZXIpLmRlZmF1bHQ7XG4gIH1cbn0pO1xuXG52YXIgX1JlbmRlclRhcmdldCA9IHJlcXVpcmUoJy4vcmVuZGVyZXJzL3dlYmdsL3V0aWxzL1JlbmRlclRhcmdldCcpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ1JlbmRlclRhcmdldCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1JlbmRlclRhcmdldCkuZGVmYXVsdDtcbiAgfVxufSk7XG5cbnZhciBfUXVhZCA9IHJlcXVpcmUoJy4vcmVuZGVyZXJzL3dlYmdsL3V0aWxzL1F1YWQnKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdRdWFkJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUXVhZCkuZGVmYXVsdDtcbiAgfVxufSk7XG5cbnZhciBfU3ByaXRlTWFza0ZpbHRlciA9IHJlcXVpcmUoJy4vcmVuZGVyZXJzL3dlYmdsL2ZpbHRlcnMvc3ByaXRlTWFzay9TcHJpdGVNYXNrRmlsdGVyJyk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnU3ByaXRlTWFza0ZpbHRlcicsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1Nwcml0ZU1hc2tGaWx0ZXIpLmRlZmF1bHQ7XG4gIH1cbn0pO1xuXG52YXIgX0ZpbHRlciA9IHJlcXVpcmUoJy4vcmVuZGVyZXJzL3dlYmdsL2ZpbHRlcnMvRmlsdGVyJyk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnRmlsdGVyJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRmlsdGVyKS5kZWZhdWx0O1xuICB9XG59KTtcblxudmFyIF9BcHBsaWNhdGlvbiA9IHJlcXVpcmUoJy4vQXBwbGljYXRpb24nKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdBcHBsaWNhdGlvbicsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0FwcGxpY2F0aW9uKS5kZWZhdWx0O1xuICB9XG59KTtcblxudmFyIF9hdXRvRGV0ZWN0UmVuZGVyZXIgPSByZXF1aXJlKCcuL2F1dG9EZXRlY3RSZW5kZXJlcicpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2F1dG9EZXRlY3RSZW5kZXJlcicsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9hdXRvRGV0ZWN0UmVuZGVyZXIuYXV0b0RldGVjdFJlbmRlcmVyO1xuICB9XG59KTtcblxudmFyIF91dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxudmFyIHV0aWxzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX3V0aWxzKTtcblxudmFyIF90aWNrZXIgPSByZXF1aXJlKCcuL3RpY2tlcicpO1xuXG52YXIgdGlja2VyID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX3RpY2tlcik7XG5cbnZhciBfc2V0dGluZ3MgPSByZXF1aXJlKCcuL3NldHRpbmdzJyk7XG5cbnZhciBfc2V0dGluZ3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc2V0dGluZ3MpO1xuXG52YXIgX0NhbnZhc1JlbmRlcmVyID0gcmVxdWlyZSgnLi9yZW5kZXJlcnMvY2FudmFzL0NhbnZhc1JlbmRlcmVyJyk7XG5cbnZhciBfQ2FudmFzUmVuZGVyZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQ2FudmFzUmVuZGVyZXIpO1xuXG52YXIgX1dlYkdMUmVuZGVyZXIgPSByZXF1aXJlKCcuL3JlbmRlcmVycy93ZWJnbC9XZWJHTFJlbmRlcmVyJyk7XG5cbnZhciBfV2ViR0xSZW5kZXJlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9XZWJHTFJlbmRlcmVyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5zZXR0aW5ncyA9IF9zZXR0aW5nczIuZGVmYXVsdDtcbmV4cG9ydHMudXRpbHMgPSB1dGlscztcbmV4cG9ydHMudGlja2VyID0gdGlja2VyO1xuZXhwb3J0cy5DYW52YXNSZW5kZXJlciA9IF9DYW52YXNSZW5kZXJlcjIuZGVmYXVsdDtcbmV4cG9ydHMuV2ViR0xSZW5kZXJlciA9IF9XZWJHTFJlbmRlcmVyMi5kZWZhdWx0OyAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbmFtZXNwYWNlIFBJWElcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9NYXRyaXggPSByZXF1aXJlKCcuL01hdHJpeCcpO1xuXG52YXIgX01hdHJpeDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NYXRyaXgpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgdXggPSBbMSwgMSwgMCwgLTEsIC0xLCAtMSwgMCwgMSwgMSwgMSwgMCwgLTEsIC0xLCAtMSwgMCwgMV07IC8vIFlvdXIgZnJpZW5kbHkgbmVpZ2hib3VyIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0RpaGVkcmFsX2dyb3VwIG9mIG9yZGVyIDE2XG5cbnZhciB1eSA9IFswLCAxLCAxLCAxLCAwLCAtMSwgLTEsIC0xLCAwLCAxLCAxLCAxLCAwLCAtMSwgLTEsIC0xXTtcbnZhciB2eCA9IFswLCAtMSwgLTEsIC0xLCAwLCAxLCAxLCAxLCAwLCAxLCAxLCAxLCAwLCAtMSwgLTEsIC0xXTtcbnZhciB2eSA9IFsxLCAxLCAwLCAtMSwgLTEsIC0xLCAwLCAxLCAtMSwgLTEsIDAsIDEsIDEsIDEsIDAsIC0xXTtcbnZhciB0ZW1wTWF0cmljZXMgPSBbXTtcblxudmFyIG11bCA9IFtdO1xuXG5mdW5jdGlvbiBzaWdudW0oeCkge1xuICAgIGlmICh4IDwgMCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGlmICh4ID4gMCkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gaW5pdCgpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICAgICAgdmFyIHJvdyA9IFtdO1xuXG4gICAgICAgIG11bC5wdXNoKHJvdyk7XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCAxNjsgaisrKSB7XG4gICAgICAgICAgICB2YXIgX3V4ID0gc2lnbnVtKHV4W2ldICogdXhbal0gKyB2eFtpXSAqIHV5W2pdKTtcbiAgICAgICAgICAgIHZhciBfdXkgPSBzaWdudW0odXlbaV0gKiB1eFtqXSArIHZ5W2ldICogdXlbal0pO1xuICAgICAgICAgICAgdmFyIF92eCA9IHNpZ251bSh1eFtpXSAqIHZ4W2pdICsgdnhbaV0gKiB2eVtqXSk7XG4gICAgICAgICAgICB2YXIgX3Z5ID0gc2lnbnVtKHV5W2ldICogdnhbal0gKyB2eVtpXSAqIHZ5W2pdKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCAxNjsgaysrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHV4W2tdID09PSBfdXggJiYgdXlba10gPT09IF91eSAmJiB2eFtrXSA9PT0gX3Z4ICYmIHZ5W2tdID09PSBfdnkpIHtcbiAgICAgICAgICAgICAgICAgICAgcm93LnB1c2goayk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCAxNjsgX2krKykge1xuICAgICAgICB2YXIgbWF0ID0gbmV3IF9NYXRyaXgyLmRlZmF1bHQoKTtcblxuICAgICAgICBtYXQuc2V0KHV4W19pXSwgdXlbX2ldLCB2eFtfaV0sIHZ5W19pXSwgMCwgMCk7XG4gICAgICAgIHRlbXBNYXRyaWNlcy5wdXNoKG1hdCk7XG4gICAgfVxufVxuXG5pbml0KCk7XG5cbi8qKlxuICogSW1wbGVtZW50cyBEaWhlZHJhbCBHcm91cCBEXzgsIHNlZSBbZ3JvdXAgRDRde0BsaW5rIGh0dHA6Ly9tYXRod29ybGQud29sZnJhbS5jb20vRGloZWRyYWxHcm91cEQ0Lmh0bWx9LFxuICogRDggaXMgdGhlIHNhbWUgYnV0IHdpdGggZGlhZ29uYWxzLiBVc2VkIGZvciB0ZXh0dXJlIHJvdGF0aW9ucy5cbiAqXG4gKiBWZWN0b3IgeFgoaSksIHhZKGkpIGlzIFUtYXhpcyBvZiBzcHJpdGUgd2l0aCByb3RhdGlvbiBpXG4gKiBWZWN0b3IgeVkoaSksIHlZKGkpIGlzIFYtYXhpcyBvZiBzcHJpdGUgd2l0aCByb3RhdGlvbiBpXG4gKiBSb3RhdGlvbnM6IDAgZ3JhZCAoMCksIDkwIGdyYWQgKDIpLCAxODAgZ3JhZCAoNCksIDI3MCBncmFkICg2KVxuICogTWlycm9yczogdmVydGljYWwgKDgpLCBtYWluIGRpYWdvbmFsICgxMCksIGhvcml6b250YWwgKDEyKSwgcmV2ZXJzZSBkaWFnb25hbCAoMTQpXG4gKiBUaGlzIGlzIHRoZSBzbWFsbCBwYXJ0IG9mIGdhbWVvZmJvbWJzLmNvbSBwb3J0YWwgc3lzdGVtLiBJdCB3b3Jrcy5cbiAqXG4gKiBAYXV0aG9yIEl2YW4gQGl2YW5wb3BlbHlzaGV2XG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKi9cbnZhciBHcm91cEQ4ID0ge1xuICAgIEU6IDAsXG4gICAgU0U6IDEsXG4gICAgUzogMixcbiAgICBTVzogMyxcbiAgICBXOiA0LFxuICAgIE5XOiA1LFxuICAgIE46IDYsXG4gICAgTkU6IDcsXG4gICAgTUlSUk9SX1ZFUlRJQ0FMOiA4LFxuICAgIE1JUlJPUl9IT1JJWk9OVEFMOiAxMixcbiAgICB1WDogZnVuY3Rpb24gdVgoaW5kKSB7XG4gICAgICAgIHJldHVybiB1eFtpbmRdO1xuICAgIH0sXG4gICAgdVk6IGZ1bmN0aW9uIHVZKGluZCkge1xuICAgICAgICByZXR1cm4gdXlbaW5kXTtcbiAgICB9LFxuICAgIHZYOiBmdW5jdGlvbiB2WChpbmQpIHtcbiAgICAgICAgcmV0dXJuIHZ4W2luZF07XG4gICAgfSxcbiAgICB2WTogZnVuY3Rpb24gdlkoaW5kKSB7XG4gICAgICAgIHJldHVybiB2eVtpbmRdO1xuICAgIH0sXG4gICAgaW52OiBmdW5jdGlvbiBpbnYocm90YXRpb24pIHtcbiAgICAgICAgaWYgKHJvdGF0aW9uICYgOCkge1xuICAgICAgICAgICAgcmV0dXJuIHJvdGF0aW9uICYgMTU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gLXJvdGF0aW9uICYgNztcbiAgICB9LFxuICAgIGFkZDogZnVuY3Rpb24gYWRkKHJvdGF0aW9uU2Vjb25kLCByb3RhdGlvbkZpcnN0KSB7XG4gICAgICAgIHJldHVybiBtdWxbcm90YXRpb25TZWNvbmRdW3JvdGF0aW9uRmlyc3RdO1xuICAgIH0sXG4gICAgc3ViOiBmdW5jdGlvbiBzdWIocm90YXRpb25TZWNvbmQsIHJvdGF0aW9uRmlyc3QpIHtcbiAgICAgICAgcmV0dXJuIG11bFtyb3RhdGlvblNlY29uZF1bR3JvdXBEOC5pbnYocm90YXRpb25GaXJzdCldO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIDE4MCBkZWdyZWVzIHRvIHJvdGF0aW9uLiBDb21tdXRhdGl2ZSBvcGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgUElYSS5Hcm91cEQ4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJvdGF0aW9uIC0gVGhlIG51bWJlciB0byByb3RhdGUuXG4gICAgICogQHJldHVybnMge251bWJlcn0gcm90YXRlZCBudW1iZXJcbiAgICAgKi9cbiAgICByb3RhdGUxODA6IGZ1bmN0aW9uIHJvdGF0ZTE4MChyb3RhdGlvbikge1xuICAgICAgICByZXR1cm4gcm90YXRpb24gXiA0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEaXJlY3Rpb24gb2YgbWFpbiB2ZWN0b3IgY2FuIGJlIGhvcml6b250YWwsIHZlcnRpY2FsIG9yIGRpYWdvbmFsLlxuICAgICAqIFNvbWUgb2JqZWN0cyB3b3JrIHdpdGggdmVydGljYWwgZGlyZWN0aW9ucyBkaWZmZXJlbnQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgUElYSS5Hcm91cEQ4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJvdGF0aW9uIC0gVGhlIG51bWJlciB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlIGRpcmVjdGlvbiBpcyB2ZXJ0aWNhbFxuICAgICAqL1xuICAgIGlzVmVydGljYWw6IGZ1bmN0aW9uIGlzVmVydGljYWwocm90YXRpb24pIHtcbiAgICAgICAgcmV0dXJuIChyb3RhdGlvbiAmIDMpID09PSAyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyb2YgUElYSS5Hcm91cEQ4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGR4IC0gVE9ET1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkeSAtIFRPRE9cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge251bWJlcn0gVE9ET1xuICAgICAqL1xuICAgIGJ5RGlyZWN0aW9uOiBmdW5jdGlvbiBieURpcmVjdGlvbihkeCwgZHkpIHtcbiAgICAgICAgaWYgKE1hdGguYWJzKGR4KSAqIDIgPD0gTWF0aC5hYnMoZHkpKSB7XG4gICAgICAgICAgICBpZiAoZHkgPj0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBHcm91cEQ4LlM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBHcm91cEQ4Lk47XG4gICAgICAgIH0gZWxzZSBpZiAoTWF0aC5hYnMoZHkpICogMiA8PSBNYXRoLmFicyhkeCkpIHtcbiAgICAgICAgICAgIGlmIChkeCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gR3JvdXBEOC5FO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gR3JvdXBEOC5XO1xuICAgICAgICB9IGVsc2UgaWYgKGR5ID4gMCkge1xuICAgICAgICAgICAgaWYgKGR4ID4gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBHcm91cEQ4LlNFO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gR3JvdXBEOC5TVztcbiAgICAgICAgfSBlbHNlIGlmIChkeCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBHcm91cEQ4Lk5FO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIEdyb3VwRDguTlc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEhlbHBzIHNwcml0ZSB0byBjb21wZW5zYXRlIHRleHR1cmUgcGFja2VyIHJvdGF0aW9uLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIFBJWEkuR3JvdXBEOFxuICAgICAqIEBwYXJhbSB7UElYSS5NYXRyaXh9IG1hdHJpeCAtIHNwcml0ZSB3b3JsZCBtYXRyaXhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcm90YXRpb24gLSBUaGUgcm90YXRpb24gZmFjdG9yIHRvIHVzZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdHggLSBzcHJpdGUgYW5jaG9yaW5nXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHR5IC0gc3ByaXRlIGFuY2hvcmluZ1xuICAgICAqL1xuICAgIG1hdHJpeEFwcGVuZFJvdGF0aW9uSW52OiBmdW5jdGlvbiBtYXRyaXhBcHBlbmRSb3RhdGlvbkludihtYXRyaXgsIHJvdGF0aW9uKSB7XG4gICAgICAgIHZhciB0eCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMDtcbiAgICAgICAgdmFyIHR5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiAwO1xuXG4gICAgICAgIC8vIFBhY2tlciB1c2VkIFwicm90YXRpb25cIiwgd2UgdXNlIFwiaW52KHJvdGF0aW9uKVwiXG4gICAgICAgIHZhciBtYXQgPSB0ZW1wTWF0cmljZXNbR3JvdXBEOC5pbnYocm90YXRpb24pXTtcblxuICAgICAgICBtYXQudHggPSB0eDtcbiAgICAgICAgbWF0LnR5ID0gdHk7XG4gICAgICAgIG1hdHJpeC5hcHBlbmQobWF0KTtcbiAgICB9XG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBHcm91cEQ4O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R3JvdXBEOC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfUG9pbnQgPSByZXF1aXJlKCcuL1BvaW50Jyk7XG5cbnZhciBfUG9pbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUG9pbnQpO1xuXG52YXIgX2NvbnN0ID0gcmVxdWlyZSgnLi4vY29uc3QnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuLyoqXG4gKiBUaGUgUGl4aUpTIE1hdHJpeCBjbGFzcyBhcyBhbiBvYmplY3QsIHdoaWNoIG1ha2VzIGl0IGEgbG90IGZhc3RlcixcbiAqIGhlcmUgaXMgYSByZXByZXNlbnRhdGlvbiBvZiBpdCA6XG4gKiB8IGEgfCBjIHwgdHh8XG4gKiB8IGIgfCBkIHwgdHl8XG4gKiB8IDAgfCAwIHwgMSB8XG4gKlxuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgUElYSVxuICovXG52YXIgTWF0cml4ID0gZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYT0xXSAtIHggc2NhbGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2I9MF0gLSB4IHNrZXdcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2M9MF0gLSB5IHNrZXdcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Q9MV0gLSB5IHNjYWxlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt0eD0wXSAtIHggdHJhbnNsYXRpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3R5PTBdIC0geSB0cmFuc2xhdGlvblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE1hdHJpeCgpIHtcbiAgICAgICAgdmFyIGEgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDE7XG4gICAgICAgIHZhciBiID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICAgICAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMDtcbiAgICAgICAgdmFyIGQgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IDE7XG4gICAgICAgIHZhciB0eCA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogMDtcbiAgICAgICAgdmFyIHR5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiAwO1xuXG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNYXRyaXgpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDFcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYSA9IGE7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5iID0gYjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAwXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmMgPSBjO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDFcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZCA9IGQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50eCA9IHR4O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudHkgPSB0eTtcblxuICAgICAgICB0aGlzLmFycmF5ID0gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgTWF0cml4IG9iamVjdCBiYXNlZCBvbiB0aGUgZ2l2ZW4gYXJyYXkuIFRoZSBFbGVtZW50IHRvIE1hdHJpeCBtYXBwaW5nIG9yZGVyIGlzIGFzIGZvbGxvd3M6XG4gICAgICpcbiAgICAgKiBhID0gYXJyYXlbMF1cbiAgICAgKiBiID0gYXJyYXlbMV1cbiAgICAgKiBjID0gYXJyYXlbM11cbiAgICAgKiBkID0gYXJyYXlbNF1cbiAgICAgKiB0eCA9IGFycmF5WzJdXG4gICAgICogdHkgPSBhcnJheVs1XVxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gYXJyYXkgLSBUaGUgYXJyYXkgdGhhdCB0aGUgbWF0cml4IHdpbGwgYmUgcG9wdWxhdGVkIGZyb20uXG4gICAgICovXG5cblxuICAgIE1hdHJpeC5wcm90b3R5cGUuZnJvbUFycmF5ID0gZnVuY3Rpb24gZnJvbUFycmF5KGFycmF5KSB7XG4gICAgICAgIHRoaXMuYSA9IGFycmF5WzBdO1xuICAgICAgICB0aGlzLmIgPSBhcnJheVsxXTtcbiAgICAgICAgdGhpcy5jID0gYXJyYXlbM107XG4gICAgICAgIHRoaXMuZCA9IGFycmF5WzRdO1xuICAgICAgICB0aGlzLnR4ID0gYXJyYXlbMl07XG4gICAgICAgIHRoaXMudHkgPSBhcnJheVs1XTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogc2V0cyB0aGUgbWF0cml4IHByb3BlcnRpZXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhIC0gTWF0cml4IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiIC0gTWF0cml4IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjIC0gTWF0cml4IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkIC0gTWF0cml4IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0eCAtIE1hdHJpeCBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdHkgLSBNYXRyaXggY29tcG9uZW50XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtQSVhJLk1hdHJpeH0gVGhpcyBtYXRyaXguIEdvb2QgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cbiAgICAgKi9cblxuXG4gICAgTWF0cml4LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiBzZXQoYSwgYiwgYywgZCwgdHgsIHR5KSB7XG4gICAgICAgIHRoaXMuYSA9IGE7XG4gICAgICAgIHRoaXMuYiA9IGI7XG4gICAgICAgIHRoaXMuYyA9IGM7XG4gICAgICAgIHRoaXMuZCA9IGQ7XG4gICAgICAgIHRoaXMudHggPSB0eDtcbiAgICAgICAgdGhpcy50eSA9IHR5O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IGZyb20gdGhlIGN1cnJlbnQgTWF0cml4IG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gdHJhbnNwb3NlIC0gV2hldGhlciB3ZSBuZWVkIHRvIHRyYW5zcG9zZSB0aGUgbWF0cml4IG9yIG5vdFxuICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSBbb3V0PW5ldyBGbG9hdDMyQXJyYXkoOSldIC0gSWYgcHJvdmlkZWQgdGhlIGFycmF5IHdpbGwgYmUgYXNzaWduZWQgdG8gb3V0XG4gICAgICogQHJldHVybiB7bnVtYmVyW119IHRoZSBuZXdseSBjcmVhdGVkIGFycmF5IHdoaWNoIGNvbnRhaW5zIHRoZSBtYXRyaXhcbiAgICAgKi9cblxuXG4gICAgTWF0cml4LnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gdG9BcnJheSh0cmFuc3Bvc2UsIG91dCkge1xuICAgICAgICBpZiAoIXRoaXMuYXJyYXkpIHtcbiAgICAgICAgICAgIHRoaXMuYXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KDkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGFycmF5ID0gb3V0IHx8IHRoaXMuYXJyYXk7XG5cbiAgICAgICAgaWYgKHRyYW5zcG9zZSkge1xuICAgICAgICAgICAgYXJyYXlbMF0gPSB0aGlzLmE7XG4gICAgICAgICAgICBhcnJheVsxXSA9IHRoaXMuYjtcbiAgICAgICAgICAgIGFycmF5WzJdID0gMDtcbiAgICAgICAgICAgIGFycmF5WzNdID0gdGhpcy5jO1xuICAgICAgICAgICAgYXJyYXlbNF0gPSB0aGlzLmQ7XG4gICAgICAgICAgICBhcnJheVs1XSA9IDA7XG4gICAgICAgICAgICBhcnJheVs2XSA9IHRoaXMudHg7XG4gICAgICAgICAgICBhcnJheVs3XSA9IHRoaXMudHk7XG4gICAgICAgICAgICBhcnJheVs4XSA9IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhcnJheVswXSA9IHRoaXMuYTtcbiAgICAgICAgICAgIGFycmF5WzFdID0gdGhpcy5jO1xuICAgICAgICAgICAgYXJyYXlbMl0gPSB0aGlzLnR4O1xuICAgICAgICAgICAgYXJyYXlbM10gPSB0aGlzLmI7XG4gICAgICAgICAgICBhcnJheVs0XSA9IHRoaXMuZDtcbiAgICAgICAgICAgIGFycmF5WzVdID0gdGhpcy50eTtcbiAgICAgICAgICAgIGFycmF5WzZdID0gMDtcbiAgICAgICAgICAgIGFycmF5WzddID0gMDtcbiAgICAgICAgICAgIGFycmF5WzhdID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhcnJheTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IGEgbmV3IHBvc2l0aW9uIHdpdGggdGhlIGN1cnJlbnQgdHJhbnNmb3JtYXRpb24gYXBwbGllZC5cbiAgICAgKiBDYW4gYmUgdXNlZCB0byBnbyBmcm9tIGEgY2hpbGQncyBjb29yZGluYXRlIHNwYWNlIHRvIHRoZSB3b3JsZCBjb29yZGluYXRlIHNwYWNlLiAoZS5nLiByZW5kZXJpbmcpXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuUG9pbnR9IHBvcyAtIFRoZSBvcmlnaW5cbiAgICAgKiBAcGFyYW0ge1BJWEkuUG9pbnR9IFtuZXdQb3NdIC0gVGhlIHBvaW50IHRoYXQgdGhlIG5ldyBwb3NpdGlvbiBpcyBhc3NpZ25lZCB0byAoYWxsb3dlZCB0byBiZSBzYW1lIGFzIGlucHV0KVxuICAgICAqIEByZXR1cm4ge1BJWEkuUG9pbnR9IFRoZSBuZXcgcG9pbnQsIHRyYW5zZm9ybWVkIHRocm91Z2ggdGhpcyBtYXRyaXhcbiAgICAgKi9cblxuXG4gICAgTWF0cml4LnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uIGFwcGx5KHBvcywgbmV3UG9zKSB7XG4gICAgICAgIG5ld1BvcyA9IG5ld1BvcyB8fCBuZXcgX1BvaW50Mi5kZWZhdWx0KCk7XG5cbiAgICAgICAgdmFyIHggPSBwb3MueDtcbiAgICAgICAgdmFyIHkgPSBwb3MueTtcblxuICAgICAgICBuZXdQb3MueCA9IHRoaXMuYSAqIHggKyB0aGlzLmMgKiB5ICsgdGhpcy50eDtcbiAgICAgICAgbmV3UG9zLnkgPSB0aGlzLmIgKiB4ICsgdGhpcy5kICogeSArIHRoaXMudHk7XG5cbiAgICAgICAgcmV0dXJuIG5ld1BvcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IGEgbmV3IHBvc2l0aW9uIHdpdGggdGhlIGludmVyc2Ugb2YgdGhlIGN1cnJlbnQgdHJhbnNmb3JtYXRpb24gYXBwbGllZC5cbiAgICAgKiBDYW4gYmUgdXNlZCB0byBnbyBmcm9tIHRoZSB3b3JsZCBjb29yZGluYXRlIHNwYWNlIHRvIGEgY2hpbGQncyBjb29yZGluYXRlIHNwYWNlLiAoZS5nLiBpbnB1dClcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5Qb2ludH0gcG9zIC0gVGhlIG9yaWdpblxuICAgICAqIEBwYXJhbSB7UElYSS5Qb2ludH0gW25ld1Bvc10gLSBUaGUgcG9pbnQgdGhhdCB0aGUgbmV3IHBvc2l0aW9uIGlzIGFzc2lnbmVkIHRvIChhbGxvd2VkIHRvIGJlIHNhbWUgYXMgaW5wdXQpXG4gICAgICogQHJldHVybiB7UElYSS5Qb2ludH0gVGhlIG5ldyBwb2ludCwgaW52ZXJzZS10cmFuc2Zvcm1lZCB0aHJvdWdoIHRoaXMgbWF0cml4XG4gICAgICovXG5cblxuICAgIE1hdHJpeC5wcm90b3R5cGUuYXBwbHlJbnZlcnNlID0gZnVuY3Rpb24gYXBwbHlJbnZlcnNlKHBvcywgbmV3UG9zKSB7XG4gICAgICAgIG5ld1BvcyA9IG5ld1BvcyB8fCBuZXcgX1BvaW50Mi5kZWZhdWx0KCk7XG5cbiAgICAgICAgdmFyIGlkID0gMSAvICh0aGlzLmEgKiB0aGlzLmQgKyB0aGlzLmMgKiAtdGhpcy5iKTtcblxuICAgICAgICB2YXIgeCA9IHBvcy54O1xuICAgICAgICB2YXIgeSA9IHBvcy55O1xuXG4gICAgICAgIG5ld1Bvcy54ID0gdGhpcy5kICogaWQgKiB4ICsgLXRoaXMuYyAqIGlkICogeSArICh0aGlzLnR5ICogdGhpcy5jIC0gdGhpcy50eCAqIHRoaXMuZCkgKiBpZDtcbiAgICAgICAgbmV3UG9zLnkgPSB0aGlzLmEgKiBpZCAqIHkgKyAtdGhpcy5iICogaWQgKiB4ICsgKC10aGlzLnR5ICogdGhpcy5hICsgdGhpcy50eCAqIHRoaXMuYikgKiBpZDtcblxuICAgICAgICByZXR1cm4gbmV3UG9zO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2xhdGVzIHRoZSBtYXRyaXggb24gdGhlIHggYW5kIHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCBIb3cgbXVjaCB0byB0cmFuc2xhdGUgeCBieVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IEhvdyBtdWNoIHRvIHRyYW5zbGF0ZSB5IGJ5XG4gICAgICogQHJldHVybiB7UElYSS5NYXRyaXh9IFRoaXMgbWF0cml4LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG4gICAgICovXG5cblxuICAgIE1hdHJpeC5wcm90b3R5cGUudHJhbnNsYXRlID0gZnVuY3Rpb24gdHJhbnNsYXRlKHgsIHkpIHtcbiAgICAgICAgdGhpcy50eCArPSB4O1xuICAgICAgICB0aGlzLnR5ICs9IHk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgYSBzY2FsZSB0cmFuc2Zvcm1hdGlvbiB0byB0aGUgbWF0cml4LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggVGhlIGFtb3VudCB0byBzY2FsZSBob3Jpem9udGFsbHlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSBUaGUgYW1vdW50IHRvIHNjYWxlIHZlcnRpY2FsbHlcbiAgICAgKiBAcmV0dXJuIHtQSVhJLk1hdHJpeH0gVGhpcyBtYXRyaXguIEdvb2QgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cbiAgICAgKi9cblxuXG4gICAgTWF0cml4LnByb3RvdHlwZS5zY2FsZSA9IGZ1bmN0aW9uIHNjYWxlKHgsIHkpIHtcbiAgICAgICAgdGhpcy5hICo9IHg7XG4gICAgICAgIHRoaXMuZCAqPSB5O1xuICAgICAgICB0aGlzLmMgKj0geDtcbiAgICAgICAgdGhpcy5iICo9IHk7XG4gICAgICAgIHRoaXMudHggKj0geDtcbiAgICAgICAgdGhpcy50eSAqPSB5O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGEgcm90YXRpb24gdHJhbnNmb3JtYXRpb24gdG8gdGhlIG1hdHJpeC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZSAtIFRoZSBhbmdsZSBpbiByYWRpYW5zLlxuICAgICAqIEByZXR1cm4ge1BJWEkuTWF0cml4fSBUaGlzIG1hdHJpeC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuICAgICAqL1xuXG5cbiAgICBNYXRyaXgucHJvdG90eXBlLnJvdGF0ZSA9IGZ1bmN0aW9uIHJvdGF0ZShhbmdsZSkge1xuICAgICAgICB2YXIgY29zID0gTWF0aC5jb3MoYW5nbGUpO1xuICAgICAgICB2YXIgc2luID0gTWF0aC5zaW4oYW5nbGUpO1xuXG4gICAgICAgIHZhciBhMSA9IHRoaXMuYTtcbiAgICAgICAgdmFyIGMxID0gdGhpcy5jO1xuICAgICAgICB2YXIgdHgxID0gdGhpcy50eDtcblxuICAgICAgICB0aGlzLmEgPSBhMSAqIGNvcyAtIHRoaXMuYiAqIHNpbjtcbiAgICAgICAgdGhpcy5iID0gYTEgKiBzaW4gKyB0aGlzLmIgKiBjb3M7XG4gICAgICAgIHRoaXMuYyA9IGMxICogY29zIC0gdGhpcy5kICogc2luO1xuICAgICAgICB0aGlzLmQgPSBjMSAqIHNpbiArIHRoaXMuZCAqIGNvcztcbiAgICAgICAgdGhpcy50eCA9IHR4MSAqIGNvcyAtIHRoaXMudHkgKiBzaW47XG4gICAgICAgIHRoaXMudHkgPSB0eDEgKiBzaW4gKyB0aGlzLnR5ICogY29zO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBcHBlbmRzIHRoZSBnaXZlbiBNYXRyaXggdG8gdGhpcyBNYXRyaXguXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuTWF0cml4fSBtYXRyaXggLSBUaGUgbWF0cml4IHRvIGFwcGVuZC5cbiAgICAgKiBAcmV0dXJuIHtQSVhJLk1hdHJpeH0gVGhpcyBtYXRyaXguIEdvb2QgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cbiAgICAgKi9cblxuXG4gICAgTWF0cml4LnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbiBhcHBlbmQobWF0cml4KSB7XG4gICAgICAgIHZhciBhMSA9IHRoaXMuYTtcbiAgICAgICAgdmFyIGIxID0gdGhpcy5iO1xuICAgICAgICB2YXIgYzEgPSB0aGlzLmM7XG4gICAgICAgIHZhciBkMSA9IHRoaXMuZDtcblxuICAgICAgICB0aGlzLmEgPSBtYXRyaXguYSAqIGExICsgbWF0cml4LmIgKiBjMTtcbiAgICAgICAgdGhpcy5iID0gbWF0cml4LmEgKiBiMSArIG1hdHJpeC5iICogZDE7XG4gICAgICAgIHRoaXMuYyA9IG1hdHJpeC5jICogYTEgKyBtYXRyaXguZCAqIGMxO1xuICAgICAgICB0aGlzLmQgPSBtYXRyaXguYyAqIGIxICsgbWF0cml4LmQgKiBkMTtcblxuICAgICAgICB0aGlzLnR4ID0gbWF0cml4LnR4ICogYTEgKyBtYXRyaXgudHkgKiBjMSArIHRoaXMudHg7XG4gICAgICAgIHRoaXMudHkgPSBtYXRyaXgudHggKiBiMSArIG1hdHJpeC50eSAqIGQxICsgdGhpcy50eTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbWF0cml4IGJhc2VkIG9uIGFsbCB0aGUgYXZhaWxhYmxlIHByb3BlcnRpZXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gUG9zaXRpb24gb24gdGhlIHggYXhpc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gUG9zaXRpb24gb24gdGhlIHkgYXhpc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwaXZvdFggLSBQaXZvdCBvbiB0aGUgeCBheGlzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBpdm90WSAtIFBpdm90IG9uIHRoZSB5IGF4aXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2NhbGVYIC0gU2NhbGUgb24gdGhlIHggYXhpc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsZVkgLSBTY2FsZSBvbiB0aGUgeSBheGlzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJvdGF0aW9uIC0gUm90YXRpb24gaW4gcmFkaWFuc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBza2V3WCAtIFNrZXcgb24gdGhlIHggYXhpc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBza2V3WSAtIFNrZXcgb24gdGhlIHkgYXhpc1xuICAgICAqIEByZXR1cm4ge1BJWEkuTWF0cml4fSBUaGlzIG1hdHJpeC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuICAgICAqL1xuXG5cbiAgICBNYXRyaXgucHJvdG90eXBlLnNldFRyYW5zZm9ybSA9IGZ1bmN0aW9uIHNldFRyYW5zZm9ybSh4LCB5LCBwaXZvdFgsIHBpdm90WSwgc2NhbGVYLCBzY2FsZVksIHJvdGF0aW9uLCBza2V3WCwgc2tld1kpIHtcbiAgICAgICAgdGhpcy5hID0gTWF0aC5jb3Mocm90YXRpb24gKyBza2V3WSkgKiBzY2FsZVg7XG4gICAgICAgIHRoaXMuYiA9IE1hdGguc2luKHJvdGF0aW9uICsgc2tld1kpICogc2NhbGVYO1xuICAgICAgICB0aGlzLmMgPSAtTWF0aC5zaW4ocm90YXRpb24gLSBza2V3WCkgKiBzY2FsZVk7XG4gICAgICAgIHRoaXMuZCA9IE1hdGguY29zKHJvdGF0aW9uIC0gc2tld1gpICogc2NhbGVZO1xuXG4gICAgICAgIHRoaXMudHggPSB4IC0gKHBpdm90WCAqIHRoaXMuYSArIHBpdm90WSAqIHRoaXMuYyk7XG4gICAgICAgIHRoaXMudHkgPSB5IC0gKHBpdm90WCAqIHRoaXMuYiArIHBpdm90WSAqIHRoaXMuZCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFByZXBlbmRzIHRoZSBnaXZlbiBNYXRyaXggdG8gdGhpcyBNYXRyaXguXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuTWF0cml4fSBtYXRyaXggLSBUaGUgbWF0cml4IHRvIHByZXBlbmRcbiAgICAgKiBAcmV0dXJuIHtQSVhJLk1hdHJpeH0gVGhpcyBtYXRyaXguIEdvb2QgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cbiAgICAgKi9cblxuXG4gICAgTWF0cml4LnByb3RvdHlwZS5wcmVwZW5kID0gZnVuY3Rpb24gcHJlcGVuZChtYXRyaXgpIHtcbiAgICAgICAgdmFyIHR4MSA9IHRoaXMudHg7XG5cbiAgICAgICAgaWYgKG1hdHJpeC5hICE9PSAxIHx8IG1hdHJpeC5iICE9PSAwIHx8IG1hdHJpeC5jICE9PSAwIHx8IG1hdHJpeC5kICE9PSAxKSB7XG4gICAgICAgICAgICB2YXIgYTEgPSB0aGlzLmE7XG4gICAgICAgICAgICB2YXIgYzEgPSB0aGlzLmM7XG5cbiAgICAgICAgICAgIHRoaXMuYSA9IGExICogbWF0cml4LmEgKyB0aGlzLmIgKiBtYXRyaXguYztcbiAgICAgICAgICAgIHRoaXMuYiA9IGExICogbWF0cml4LmIgKyB0aGlzLmIgKiBtYXRyaXguZDtcbiAgICAgICAgICAgIHRoaXMuYyA9IGMxICogbWF0cml4LmEgKyB0aGlzLmQgKiBtYXRyaXguYztcbiAgICAgICAgICAgIHRoaXMuZCA9IGMxICogbWF0cml4LmIgKyB0aGlzLmQgKiBtYXRyaXguZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudHggPSB0eDEgKiBtYXRyaXguYSArIHRoaXMudHkgKiBtYXRyaXguYyArIG1hdHJpeC50eDtcbiAgICAgICAgdGhpcy50eSA9IHR4MSAqIG1hdHJpeC5iICsgdGhpcy50eSAqIG1hdHJpeC5kICsgbWF0cml4LnR5O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZWNvbXBvc2VzIHRoZSBtYXRyaXggKHgsIHksIHNjYWxlWCwgc2NhbGVZLCBhbmQgcm90YXRpb24pIGFuZCBzZXRzIHRoZSBwcm9wZXJ0aWVzIG9uIHRvIGEgdHJhbnNmb3JtLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLlRyYW5zZm9ybXxQSVhJLlRyYW5zZm9ybVN0YXRpY30gdHJhbnNmb3JtIC0gVGhlIHRyYW5zZm9ybSB0byBhcHBseSB0aGUgcHJvcGVydGllcyB0by5cbiAgICAgKiBAcmV0dXJuIHtQSVhJLlRyYW5zZm9ybXxQSVhJLlRyYW5zZm9ybVN0YXRpY30gVGhlIHRyYW5zZm9ybSB3aXRoIHRoZSBuZXdseSBhcHBsaWVkIHByb3BlcnRpZXNcbiAgICAgKi9cblxuXG4gICAgTWF0cml4LnByb3RvdHlwZS5kZWNvbXBvc2UgPSBmdW5jdGlvbiBkZWNvbXBvc2UodHJhbnNmb3JtKSB7XG4gICAgICAgIC8vIHNvcnQgb3V0IHJvdGF0aW9uIC8gc2tldy4uXG4gICAgICAgIHZhciBhID0gdGhpcy5hO1xuICAgICAgICB2YXIgYiA9IHRoaXMuYjtcbiAgICAgICAgdmFyIGMgPSB0aGlzLmM7XG4gICAgICAgIHZhciBkID0gdGhpcy5kO1xuXG4gICAgICAgIHZhciBza2V3WCA9IC1NYXRoLmF0YW4yKC1jLCBkKTtcbiAgICAgICAgdmFyIHNrZXdZID0gTWF0aC5hdGFuMihiLCBhKTtcblxuICAgICAgICB2YXIgZGVsdGEgPSBNYXRoLmFicyhza2V3WCArIHNrZXdZKTtcblxuICAgICAgICBpZiAoZGVsdGEgPCAwLjAwMDAxIHx8IE1hdGguYWJzKF9jb25zdC5QSV8yIC0gZGVsdGEpIDwgMC4wMDAwMSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtLnJvdGF0aW9uID0gc2tld1k7XG4gICAgICAgICAgICB0cmFuc2Zvcm0uc2tldy54ID0gdHJhbnNmb3JtLnNrZXcueSA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm0ucm90YXRpb24gPSAwO1xuICAgICAgICAgICAgdHJhbnNmb3JtLnNrZXcueCA9IHNrZXdYO1xuICAgICAgICAgICAgdHJhbnNmb3JtLnNrZXcueSA9IHNrZXdZO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbmV4dCBzZXQgc2NhbGVcbiAgICAgICAgdHJhbnNmb3JtLnNjYWxlLnggPSBNYXRoLnNxcnQoYSAqIGEgKyBiICogYik7XG4gICAgICAgIHRyYW5zZm9ybS5zY2FsZS55ID0gTWF0aC5zcXJ0KGMgKiBjICsgZCAqIGQpO1xuXG4gICAgICAgIC8vIG5leHQgc2V0IHBvc2l0aW9uXG4gICAgICAgIHRyYW5zZm9ybS5wb3NpdGlvbi54ID0gdGhpcy50eDtcbiAgICAgICAgdHJhbnNmb3JtLnBvc2l0aW9uLnkgPSB0aGlzLnR5O1xuXG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEludmVydHMgdGhpcyBtYXRyaXhcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1BJWEkuTWF0cml4fSBUaGlzIG1hdHJpeC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuICAgICAqL1xuXG5cbiAgICBNYXRyaXgucHJvdG90eXBlLmludmVydCA9IGZ1bmN0aW9uIGludmVydCgpIHtcbiAgICAgICAgdmFyIGExID0gdGhpcy5hO1xuICAgICAgICB2YXIgYjEgPSB0aGlzLmI7XG4gICAgICAgIHZhciBjMSA9IHRoaXMuYztcbiAgICAgICAgdmFyIGQxID0gdGhpcy5kO1xuICAgICAgICB2YXIgdHgxID0gdGhpcy50eDtcbiAgICAgICAgdmFyIG4gPSBhMSAqIGQxIC0gYjEgKiBjMTtcblxuICAgICAgICB0aGlzLmEgPSBkMSAvIG47XG4gICAgICAgIHRoaXMuYiA9IC1iMSAvIG47XG4gICAgICAgIHRoaXMuYyA9IC1jMSAvIG47XG4gICAgICAgIHRoaXMuZCA9IGExIC8gbjtcbiAgICAgICAgdGhpcy50eCA9IChjMSAqIHRoaXMudHkgLSBkMSAqIHR4MSkgLyBuO1xuICAgICAgICB0aGlzLnR5ID0gLShhMSAqIHRoaXMudHkgLSBiMSAqIHR4MSkgLyBuO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXNldHMgdGhpcyBNYXRpeCB0byBhbiBpZGVudGl0eSAoZGVmYXVsdCkgbWF0cml4LlxuICAgICAqXG4gICAgICogQHJldHVybiB7UElYSS5NYXRyaXh9IFRoaXMgbWF0cml4LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG4gICAgICovXG5cblxuICAgIE1hdHJpeC5wcm90b3R5cGUuaWRlbnRpdHkgPSBmdW5jdGlvbiBpZGVudGl0eSgpIHtcbiAgICAgICAgdGhpcy5hID0gMTtcbiAgICAgICAgdGhpcy5iID0gMDtcbiAgICAgICAgdGhpcy5jID0gMDtcbiAgICAgICAgdGhpcy5kID0gMTtcbiAgICAgICAgdGhpcy50eCA9IDA7XG4gICAgICAgIHRoaXMudHkgPSAwO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IE1hdHJpeCBvYmplY3Qgd2l0aCB0aGUgc2FtZSB2YWx1ZXMgYXMgdGhpcyBvbmUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtQSVhJLk1hdHJpeH0gQSBjb3B5IG9mIHRoaXMgbWF0cml4LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG4gICAgICovXG5cblxuICAgIE1hdHJpeC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgICAgdmFyIG1hdHJpeCA9IG5ldyBNYXRyaXgoKTtcblxuICAgICAgICBtYXRyaXguYSA9IHRoaXMuYTtcbiAgICAgICAgbWF0cml4LmIgPSB0aGlzLmI7XG4gICAgICAgIG1hdHJpeC5jID0gdGhpcy5jO1xuICAgICAgICBtYXRyaXguZCA9IHRoaXMuZDtcbiAgICAgICAgbWF0cml4LnR4ID0gdGhpcy50eDtcbiAgICAgICAgbWF0cml4LnR5ID0gdGhpcy50eTtcblxuICAgICAgICByZXR1cm4gbWF0cml4O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGFuZ2VzIHRoZSB2YWx1ZXMgb2YgdGhlIGdpdmVuIG1hdHJpeCB0byBiZSB0aGUgc2FtZSBhcyB0aGUgb25lcyBpbiB0aGlzIG1hdHJpeFxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLk1hdHJpeH0gbWF0cml4IC0gVGhlIG1hdHJpeCB0byBjb3B5IGZyb20uXG4gICAgICogQHJldHVybiB7UElYSS5NYXRyaXh9IFRoZSBtYXRyaXggZ2l2ZW4gaW4gcGFyYW1ldGVyIHdpdGggaXRzIHZhbHVlcyB1cGRhdGVkLlxuICAgICAqL1xuXG5cbiAgICBNYXRyaXgucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5KG1hdHJpeCkge1xuICAgICAgICBtYXRyaXguYSA9IHRoaXMuYTtcbiAgICAgICAgbWF0cml4LmIgPSB0aGlzLmI7XG4gICAgICAgIG1hdHJpeC5jID0gdGhpcy5jO1xuICAgICAgICBtYXRyaXguZCA9IHRoaXMuZDtcbiAgICAgICAgbWF0cml4LnR4ID0gdGhpcy50eDtcbiAgICAgICAgbWF0cml4LnR5ID0gdGhpcy50eTtcblxuICAgICAgICByZXR1cm4gbWF0cml4O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBIGRlZmF1bHQgKGlkZW50aXR5KSBtYXRyaXhcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAY29uc3RcbiAgICAgKi9cblxuXG4gICAgX2NyZWF0ZUNsYXNzKE1hdHJpeCwgbnVsbCwgW3tcbiAgICAgICAga2V5OiAnSURFTlRJVFknLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTWF0cml4KCk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQSB0ZW1wIG1hdHJpeFxuICAgICAgICAgKlxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBjb25zdFxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnVEVNUF9NQVRSSVgnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTWF0cml4KCk7XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gTWF0cml4O1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBNYXRyaXg7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1NYXRyaXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8qKlxuICogVGhlIFBvaW50IG9iamVjdCByZXByZXNlbnRzIGEgbG9jYXRpb24gaW4gYSB0d28tZGltZW5zaW9uYWwgY29vcmRpbmF0ZSBzeXN0ZW0sIHdoZXJlIHggcmVwcmVzZW50c1xuICogdGhlIGhvcml6b250YWwgYXhpcyBhbmQgeSByZXByZXNlbnRzIHRoZSB2ZXJ0aWNhbCBheGlzLlxuICogQW4gb2JzZXJ2YWJsZSBwb2ludCBpcyBhIHBvaW50IHRoYXQgdHJpZ2dlcnMgYSBjYWxsYmFjayB3aGVuIHRoZSBwb2ludCdzIHBvc2l0aW9uIGlzIGNoYW5nZWQuXG4gKlxuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgUElYSVxuICovXG52YXIgT2JzZXJ2YWJsZVBvaW50ID0gZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIC0gY2FsbGJhY2sgd2hlbiBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNjb3BlIC0gb3duZXIgb2YgY2FsbGJhY2tcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3g9MF0gLSBwb3NpdGlvbiBvZiB0aGUgcG9pbnQgb24gdGhlIHggYXhpc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbeT0wXSAtIHBvc2l0aW9uIG9mIHRoZSBwb2ludCBvbiB0aGUgeSBheGlzXG4gICAgICovXG4gICAgZnVuY3Rpb24gT2JzZXJ2YWJsZVBvaW50KGNiLCBzY29wZSkge1xuICAgICAgICB2YXIgeCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMDtcbiAgICAgICAgdmFyIHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IDA7XG5cbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE9ic2VydmFibGVQb2ludCk7XG5cbiAgICAgICAgdGhpcy5feCA9IHg7XG4gICAgICAgIHRoaXMuX3kgPSB5O1xuXG4gICAgICAgIHRoaXMuY2IgPSBjYjtcbiAgICAgICAgdGhpcy5zY29wZSA9IHNjb3BlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGlzIHBvaW50LlxuICAgICAqIFRoZSBjYWxsYmFjayBhbmQgc2NvcGUgcGFyYW1zIGNhbiBiZSBvdmVyaWRkZW4gb3RoZXJ3aXNlIHRoZXkgd2lsbCBkZWZhdWx0XG4gICAgICogdG8gdGhlIGNsb25lIG9iamVjdCdzIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYj1udWxsXSAtIGNhbGxiYWNrIHdoZW4gY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbc2NvcGU9bnVsbF0gLSBvd25lciBvZiBjYWxsYmFja1xuICAgICAqIEByZXR1cm4ge1BJWEkuT2JzZXJ2YWJsZVBvaW50fSBhIGNvcHkgb2YgdGhlIHBvaW50XG4gICAgICovXG5cblxuICAgIE9ic2VydmFibGVQb2ludC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgICAgdmFyIGNiID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBudWxsO1xuICAgICAgICB2YXIgc2NvcGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG51bGw7XG5cbiAgICAgICAgdmFyIF9jYiA9IGNiIHx8IHRoaXMuY2I7XG4gICAgICAgIHZhciBfc2NvcGUgPSBzY29wZSB8fCB0aGlzLnNjb3BlO1xuXG4gICAgICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZVBvaW50KF9jYiwgX3Njb3BlLCB0aGlzLl94LCB0aGlzLl95KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgcG9pbnQgdG8gYSBuZXcgeCBhbmQgeSBwb3NpdGlvbi5cbiAgICAgKiBJZiB5IGlzIG9taXR0ZWQsIGJvdGggeCBhbmQgeSB3aWxsIGJlIHNldCB0byB4LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt4PTBdIC0gcG9zaXRpb24gb2YgdGhlIHBvaW50IG9uIHRoZSB4IGF4aXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3k9MF0gLSBwb3NpdGlvbiBvZiB0aGUgcG9pbnQgb24gdGhlIHkgYXhpc1xuICAgICAqL1xuXG5cbiAgICBPYnNlcnZhYmxlUG9pbnQucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIHNldCh4LCB5KSB7XG4gICAgICAgIHZhciBfeCA9IHggfHwgMDtcbiAgICAgICAgdmFyIF95ID0geSB8fCAoeSAhPT0gMCA/IF94IDogMCk7XG5cbiAgICAgICAgaWYgKHRoaXMuX3ggIT09IF94IHx8IHRoaXMuX3kgIT09IF95KSB7XG4gICAgICAgICAgICB0aGlzLl94ID0gX3g7XG4gICAgICAgICAgICB0aGlzLl95ID0gX3k7XG4gICAgICAgICAgICB0aGlzLmNiLmNhbGwodGhpcy5zY29wZSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ29waWVzIHRoZSBkYXRhIGZyb20gYW5vdGhlciBwb2ludFxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLlBvaW50fFBJWEkuT2JzZXJ2YWJsZVBvaW50fSBwb2ludCAtIHBvaW50IHRvIGNvcHkgZnJvbVxuICAgICAqL1xuXG5cbiAgICBPYnNlcnZhYmxlUG9pbnQucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5KHBvaW50KSB7XG4gICAgICAgIGlmICh0aGlzLl94ICE9PSBwb2ludC54IHx8IHRoaXMuX3kgIT09IHBvaW50LnkpIHtcbiAgICAgICAgICAgIHRoaXMuX3ggPSBwb2ludC54O1xuICAgICAgICAgICAgdGhpcy5feSA9IHBvaW50Lnk7XG4gICAgICAgICAgICB0aGlzLmNiLmNhbGwodGhpcy5zY29wZSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBwb2ludCBpcyBlcXVhbCB0byB0aGlzIHBvaW50XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuUG9pbnR8UElYSS5PYnNlcnZhYmxlUG9pbnR9IHAgLSBUaGUgcG9pbnQgdG8gY2hlY2tcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2hldGhlciB0aGUgZ2l2ZW4gcG9pbnQgZXF1YWwgdG8gdGhpcyBwb2ludFxuICAgICAqL1xuXG5cbiAgICBPYnNlcnZhYmxlUG9pbnQucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyhwKSB7XG4gICAgICAgIHJldHVybiBwLnggPT09IHRoaXMuX3ggJiYgcC55ID09PSB0aGlzLl95O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcG9zaXRpb24gb2YgdGhlIGRpc3BsYXlPYmplY3Qgb24gdGhlIHggYXhpcyByZWxhdGl2ZSB0byB0aGUgbG9jYWwgY29vcmRpbmF0ZXMgb2YgdGhlIHBhcmVudC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKi9cblxuXG4gICAgX2NyZWF0ZUNsYXNzKE9ic2VydmFibGVQb2ludCwgW3tcbiAgICAgICAga2V5OiBcInhcIixcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5feDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcmVxdWlyZS1qc2RvY1xuICAgICAgICB7XG4gICAgICAgICAgICBpZiAodGhpcy5feCAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl94ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy5jYi5jYWxsKHRoaXMuc2NvcGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBwb3NpdGlvbiBvZiB0aGUgZGlzcGxheU9iamVjdCBvbiB0aGUgeCBheGlzIHJlbGF0aXZlIHRvIHRoZSBsb2NhbCBjb29yZGluYXRlcyBvZiB0aGUgcGFyZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6IFwieVwiLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl95O1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSByZXF1aXJlLWpzZG9jXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl95ICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3kgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmNiLmNhbGwodGhpcy5zY29wZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gT2JzZXJ2YWJsZVBvaW50O1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBPYnNlcnZhYmxlUG9pbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1PYnNlcnZhYmxlUG9pbnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8qKlxuICogVGhlIFBvaW50IG9iamVjdCByZXByZXNlbnRzIGEgbG9jYXRpb24gaW4gYSB0d28tZGltZW5zaW9uYWwgY29vcmRpbmF0ZSBzeXN0ZW0sIHdoZXJlIHggcmVwcmVzZW50c1xuICogdGhlIGhvcml6b250YWwgYXhpcyBhbmQgeSByZXByZXNlbnRzIHRoZSB2ZXJ0aWNhbCBheGlzLlxuICpcbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIFBJWElcbiAqL1xudmFyIFBvaW50ID0gZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IFt4PTBdIC0gcG9zaXRpb24gb2YgdGhlIHBvaW50IG9uIHRoZSB4IGF4aXNcbiAgICogQHBhcmFtIHtudW1iZXJ9IFt5PTBdIC0gcG9zaXRpb24gb2YgdGhlIHBvaW50IG9uIHRoZSB5IGF4aXNcbiAgICovXG4gIGZ1bmN0aW9uIFBvaW50KCkge1xuICAgIHZhciB4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAwO1xuICAgIHZhciB5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBvaW50KTtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgdGhpcy54ID0geDtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgdGhpcy55ID0geTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhpcyBwb2ludFxuICAgKlxuICAgKiBAcmV0dXJuIHtQSVhJLlBvaW50fSBhIGNvcHkgb2YgdGhlIHBvaW50XG4gICAqL1xuXG5cbiAgUG9pbnQucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLngsIHRoaXMueSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENvcGllcyB4IGFuZCB5IGZyb20gdGhlIGdpdmVuIHBvaW50XG4gICAqXG4gICAqIEBwYXJhbSB7UElYSS5Qb2ludH0gcCAtIFRoZSBwb2ludCB0byBjb3B5LlxuICAgKi9cblxuXG4gIFBvaW50LnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weShwKSB7XG4gICAgdGhpcy5zZXQocC54LCBwLnkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHBvaW50IGlzIGVxdWFsIHRvIHRoaXMgcG9pbnRcbiAgICpcbiAgICogQHBhcmFtIHtQSVhJLlBvaW50fSBwIC0gVGhlIHBvaW50IHRvIGNoZWNrXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIHRoZSBnaXZlbiBwb2ludCBlcXVhbCB0byB0aGlzIHBvaW50XG4gICAqL1xuXG5cbiAgUG9pbnQucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyhwKSB7XG4gICAgcmV0dXJuIHAueCA9PT0gdGhpcy54ICYmIHAueSA9PT0gdGhpcy55O1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBwb2ludCB0byBhIG5ldyB4IGFuZCB5IHBvc2l0aW9uLlxuICAgKiBJZiB5IGlzIG9taXR0ZWQsIGJvdGggeCBhbmQgeSB3aWxsIGJlIHNldCB0byB4LlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3g9MF0gLSBwb3NpdGlvbiBvZiB0aGUgcG9pbnQgb24gdGhlIHggYXhpc1xuICAgKiBAcGFyYW0ge251bWJlcn0gW3k9MF0gLSBwb3NpdGlvbiBvZiB0aGUgcG9pbnQgb24gdGhlIHkgYXhpc1xuICAgKi9cblxuXG4gIFBvaW50LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiBzZXQoeCwgeSkge1xuICAgIHRoaXMueCA9IHggfHwgMDtcbiAgICB0aGlzLnkgPSB5IHx8ICh5ICE9PSAwID8gdGhpcy54IDogMCk7XG4gIH07XG5cbiAgcmV0dXJuIFBvaW50O1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBQb2ludDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVBvaW50LmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9Qb2ludCA9IHJlcXVpcmUoJy4vUG9pbnQnKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdQb2ludCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1BvaW50KS5kZWZhdWx0O1xuICB9XG59KTtcblxudmFyIF9PYnNlcnZhYmxlUG9pbnQgPSByZXF1aXJlKCcuL09ic2VydmFibGVQb2ludCcpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ09ic2VydmFibGVQb2ludCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX09ic2VydmFibGVQb2ludCkuZGVmYXVsdDtcbiAgfVxufSk7XG5cbnZhciBfTWF0cml4ID0gcmVxdWlyZSgnLi9NYXRyaXgnKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdNYXRyaXgnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NYXRyaXgpLmRlZmF1bHQ7XG4gIH1cbn0pO1xuXG52YXIgX0dyb3VwRCA9IHJlcXVpcmUoJy4vR3JvdXBEOCcpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ0dyb3VwRDgnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Hcm91cEQpLmRlZmF1bHQ7XG4gIH1cbn0pO1xuXG52YXIgX0NpcmNsZSA9IHJlcXVpcmUoJy4vc2hhcGVzL0NpcmNsZScpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ0NpcmNsZScsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0NpcmNsZSkuZGVmYXVsdDtcbiAgfVxufSk7XG5cbnZhciBfRWxsaXBzZSA9IHJlcXVpcmUoJy4vc2hhcGVzL0VsbGlwc2UnKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdFbGxpcHNlJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRWxsaXBzZSkuZGVmYXVsdDtcbiAgfVxufSk7XG5cbnZhciBfUG9seWdvbiA9IHJlcXVpcmUoJy4vc2hhcGVzL1BvbHlnb24nKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdQb2x5Z29uJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUG9seWdvbikuZGVmYXVsdDtcbiAgfVxufSk7XG5cbnZhciBfUmVjdGFuZ2xlID0gcmVxdWlyZSgnLi9zaGFwZXMvUmVjdGFuZ2xlJyk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnUmVjdGFuZ2xlJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUmVjdGFuZ2xlKS5kZWZhdWx0O1xuICB9XG59KTtcblxudmFyIF9Sb3VuZGVkUmVjdGFuZ2xlID0gcmVxdWlyZSgnLi9zaGFwZXMvUm91bmRlZFJlY3RhbmdsZScpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ1JvdW5kZWRSZWN0YW5nbGUnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Sb3VuZGVkUmVjdGFuZ2xlKS5kZWZhdWx0O1xuICB9XG59KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9SZWN0YW5nbGUgPSByZXF1aXJlKCcuL1JlY3RhbmdsZScpO1xuXG52YXIgX1JlY3RhbmdsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9SZWN0YW5nbGUpO1xuXG52YXIgX2NvbnN0ID0gcmVxdWlyZSgnLi4vLi4vY29uc3QnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuLyoqXG4gKiBUaGUgQ2lyY2xlIG9iamVjdCBjYW4gYmUgdXNlZCB0byBzcGVjaWZ5IGEgaGl0IGFyZWEgZm9yIGRpc3BsYXlPYmplY3RzXG4gKlxuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgUElYSVxuICovXG52YXIgQ2lyY2xlID0gZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IFt4PTBdIC0gVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoaXMgY2lyY2xlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbeT0wXSAtIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGlzIGNpcmNsZVxuICAgKiBAcGFyYW0ge251bWJlcn0gW3JhZGl1cz0wXSAtIFRoZSByYWRpdXMgb2YgdGhlIGNpcmNsZVxuICAgKi9cbiAgZnVuY3Rpb24gQ2lyY2xlKCkge1xuICAgIHZhciB4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAwO1xuICAgIHZhciB5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICAgIHZhciByYWRpdXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDA7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2lyY2xlKTtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgdGhpcy54ID0geDtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgdGhpcy55ID0geTtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgdGhpcy5yYWRpdXMgPSByYWRpdXM7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBvZiB0aGUgb2JqZWN0LCBtYWlubHkgdXNlZCB0byBhdm9pZCBgaW5zdGFuY2VvZmAgY2hlY2tzXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQHJlYWRPbmx5XG4gICAgICogQGRlZmF1bHQgUElYSS5TSEFQRVMuQ0lSQ1xuICAgICAqIEBzZWUgUElYSS5TSEFQRVNcbiAgICAgKi9cbiAgICB0aGlzLnR5cGUgPSBfY29uc3QuU0hBUEVTLkNJUkM7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoaXMgQ2lyY2xlIGluc3RhbmNlXG4gICAqXG4gICAqIEByZXR1cm4ge1BJWEkuQ2lyY2xlfSBhIGNvcHkgb2YgdGhlIENpcmNsZVxuICAgKi9cblxuXG4gIENpcmNsZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IENpcmNsZSh0aGlzLngsIHRoaXMueSwgdGhpcy5yYWRpdXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciB0aGUgeCBhbmQgeSBjb29yZGluYXRlcyBnaXZlbiBhcmUgY29udGFpbmVkIHdpdGhpbiB0aGlzIGNpcmNsZVxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0geCAtIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIHRlc3RcbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byB0ZXN0XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHgveSBjb29yZGluYXRlcyBhcmUgd2l0aGluIHRoaXMgQ2lyY2xlXG4gICAqL1xuXG5cbiAgQ2lyY2xlLnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uIGNvbnRhaW5zKHgsIHkpIHtcbiAgICBpZiAodGhpcy5yYWRpdXMgPD0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciByMiA9IHRoaXMucmFkaXVzICogdGhpcy5yYWRpdXM7XG4gICAgdmFyIGR4ID0gdGhpcy54IC0geDtcbiAgICB2YXIgZHkgPSB0aGlzLnkgLSB5O1xuXG4gICAgZHggKj0gZHg7XG4gICAgZHkgKj0gZHk7XG5cbiAgICByZXR1cm4gZHggKyBkeSA8PSByMjtcbiAgfTtcblxuICAvKipcbiAgKiBSZXR1cm5zIHRoZSBmcmFtaW5nIHJlY3RhbmdsZSBvZiB0aGUgY2lyY2xlIGFzIGEgUmVjdGFuZ2xlIG9iamVjdFxuICAqXG4gICogQHJldHVybiB7UElYSS5SZWN0YW5nbGV9IHRoZSBmcmFtaW5nIHJlY3RhbmdsZVxuICAqL1xuXG5cbiAgQ2lyY2xlLnByb3RvdHlwZS5nZXRCb3VuZHMgPSBmdW5jdGlvbiBnZXRCb3VuZHMoKSB7XG4gICAgcmV0dXJuIG5ldyBfUmVjdGFuZ2xlMi5kZWZhdWx0KHRoaXMueCAtIHRoaXMucmFkaXVzLCB0aGlzLnkgLSB0aGlzLnJhZGl1cywgdGhpcy5yYWRpdXMgKiAyLCB0aGlzLnJhZGl1cyAqIDIpO1xuICB9O1xuXG4gIHJldHVybiBDaXJjbGU7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IENpcmNsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNpcmNsZS5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfUmVjdGFuZ2xlID0gcmVxdWlyZSgnLi9SZWN0YW5nbGUnKTtcblxudmFyIF9SZWN0YW5nbGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUmVjdGFuZ2xlKTtcblxudmFyIF9jb25zdCA9IHJlcXVpcmUoJy4uLy4uL2NvbnN0Jyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8qKlxuICogVGhlIEVsbGlwc2Ugb2JqZWN0IGNhbiBiZSB1c2VkIHRvIHNwZWNpZnkgYSBoaXQgYXJlYSBmb3IgZGlzcGxheU9iamVjdHNcbiAqXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKi9cbnZhciBFbGxpcHNlID0gZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IFt4PTBdIC0gVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoaXMgZWxsaXBzZVxuICAgKiBAcGFyYW0ge251bWJlcn0gW3k9MF0gLSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBjZW50ZXIgb2YgdGhpcyBlbGxpcHNlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbaGFsZldpZHRoPTBdIC0gVGhlIGhhbGYgd2lkdGggb2YgdGhpcyBlbGxpcHNlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbaGFsZkhlaWdodD0wXSAtIFRoZSBoYWxmIGhlaWdodCBvZiB0aGlzIGVsbGlwc2VcbiAgICovXG4gIGZ1bmN0aW9uIEVsbGlwc2UoKSB7XG4gICAgdmFyIHggPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG4gICAgdmFyIHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG4gICAgdmFyIGhhbGZXaWR0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMDtcbiAgICB2YXIgaGFsZkhlaWdodCA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogMDtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFbGxpcHNlKTtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgdGhpcy54ID0geDtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgdGhpcy55ID0geTtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgdGhpcy53aWR0aCA9IGhhbGZXaWR0aDtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgdGhpcy5oZWlnaHQgPSBoYWxmSGVpZ2h0O1xuXG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgb2YgdGhlIG9iamVjdCwgbWFpbmx5IHVzZWQgdG8gYXZvaWQgYGluc3RhbmNlb2ZgIGNoZWNrc1xuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEByZWFkT25seVxuICAgICAqIEBkZWZhdWx0IFBJWEkuU0hBUEVTLkVMSVBcbiAgICAgKiBAc2VlIFBJWEkuU0hBUEVTXG4gICAgICovXG4gICAgdGhpcy50eXBlID0gX2NvbnN0LlNIQVBFUy5FTElQO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGlzIEVsbGlwc2UgaW5zdGFuY2VcbiAgICpcbiAgICogQHJldHVybiB7UElYSS5FbGxpcHNlfSBhIGNvcHkgb2YgdGhlIGVsbGlwc2VcbiAgICovXG5cblxuICBFbGxpcHNlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgRWxsaXBzZSh0aGlzLngsIHRoaXMueSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciB0aGUgeCBhbmQgeSBjb29yZGluYXRlcyBnaXZlbiBhcmUgY29udGFpbmVkIHdpdGhpbiB0aGlzIGVsbGlwc2VcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byB0ZXN0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gdGVzdFxuICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSB4L3kgY29vcmRzIGFyZSB3aXRoaW4gdGhpcyBlbGxpcHNlXG4gICAqL1xuXG5cbiAgRWxsaXBzZS5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbiBjb250YWlucyh4LCB5KSB7XG4gICAgaWYgKHRoaXMud2lkdGggPD0gMCB8fCB0aGlzLmhlaWdodCA8PSAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gbm9ybWFsaXplIHRoZSBjb29yZHMgdG8gYW4gZWxsaXBzZSB3aXRoIGNlbnRlciAwLDBcbiAgICB2YXIgbm9ybXggPSAoeCAtIHRoaXMueCkgLyB0aGlzLndpZHRoO1xuICAgIHZhciBub3JteSA9ICh5IC0gdGhpcy55KSAvIHRoaXMuaGVpZ2h0O1xuXG4gICAgbm9ybXggKj0gbm9ybXg7XG4gICAgbm9ybXkgKj0gbm9ybXk7XG5cbiAgICByZXR1cm4gbm9ybXggKyBub3JteSA8PSAxO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmcmFtaW5nIHJlY3RhbmdsZSBvZiB0aGUgZWxsaXBzZSBhcyBhIFJlY3RhbmdsZSBvYmplY3RcbiAgICpcbiAgICogQHJldHVybiB7UElYSS5SZWN0YW5nbGV9IHRoZSBmcmFtaW5nIHJlY3RhbmdsZVxuICAgKi9cblxuXG4gIEVsbGlwc2UucHJvdG90eXBlLmdldEJvdW5kcyA9IGZ1bmN0aW9uIGdldEJvdW5kcygpIHtcbiAgICByZXR1cm4gbmV3IF9SZWN0YW5nbGUyLmRlZmF1bHQodGhpcy54IC0gdGhpcy53aWR0aCwgdGhpcy55IC0gdGhpcy5oZWlnaHQsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgfTtcblxuICByZXR1cm4gRWxsaXBzZTtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gRWxsaXBzZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUVsbGlwc2UuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX1BvaW50ID0gcmVxdWlyZSgnLi4vUG9pbnQnKTtcblxudmFyIF9Qb2ludDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Qb2ludCk7XG5cbnZhciBfY29uc3QgPSByZXF1aXJlKCcuLi8uLi9jb25zdCcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vKipcbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIFBJWElcbiAqL1xudmFyIFBvbHlnb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtQSVhJLlBvaW50W118bnVtYmVyW119IHBvaW50cyAtIFRoaXMgY2FuIGJlIGFuIGFycmF5IG9mIFBvaW50c1xuICAgICAqICB0aGF0IGZvcm0gdGhlIHBvbHlnb24sIGEgZmxhdCBhcnJheSBvZiBudW1iZXJzIHRoYXQgd2lsbCBiZSBpbnRlcnByZXRlZCBhcyBbeCx5LCB4LHksIC4uLl0sIG9yXG4gICAgICogIHRoZSBhcmd1bWVudHMgcGFzc2VkIGNhbiBiZSBhbGwgdGhlIHBvaW50cyBvZiB0aGUgcG9seWdvbiBlLmcuXG4gICAgICogIGBuZXcgUElYSS5Qb2x5Z29uKG5ldyBQSVhJLlBvaW50KCksIG5ldyBQSVhJLlBvaW50KCksIC4uLilgLCBvciB0aGUgYXJndW1lbnRzIHBhc3NlZCBjYW4gYmUgZmxhdFxuICAgICAqICB4LHkgdmFsdWVzIGUuZy4gYG5ldyBQb2x5Z29uKHgseSwgeCx5LCB4LHksIC4uLilgIHdoZXJlIGB4YCBhbmQgYHlgIGFyZSBOdW1iZXJzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFBvbHlnb24oKSB7XG4gICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBwb2ludHMgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgICAgIHBvaW50c1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQb2x5Z29uKTtcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwb2ludHNbMF0pKSB7XG4gICAgICAgICAgICBwb2ludHMgPSBwb2ludHNbMF07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB0aGlzIGlzIGFuIGFycmF5IG9mIHBvaW50cywgY29udmVydCBpdCB0byBhIGZsYXQgYXJyYXkgb2YgbnVtYmVyc1xuICAgICAgICBpZiAocG9pbnRzWzBdIGluc3RhbmNlb2YgX1BvaW50Mi5kZWZhdWx0KSB7XG4gICAgICAgICAgICB2YXIgcCA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgICAgICAgICAgIHAucHVzaChwb2ludHNbaV0ueCwgcG9pbnRzW2ldLnkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwb2ludHMgPSBwO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jbG9zZWQgPSB0cnVlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBhcnJheSBvZiB0aGUgcG9pbnRzIG9mIHRoaXMgcG9seWdvblxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJbXX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucG9pbnRzID0gcG9pbnRzO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdHlwZSBvZiB0aGUgb2JqZWN0LCBtYWlubHkgdXNlZCB0byBhdm9pZCBgaW5zdGFuY2VvZmAgY2hlY2tzXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQHJlYWRPbmx5XG4gICAgICAgICAqIEBkZWZhdWx0IFBJWEkuU0hBUEVTLlBPTFlcbiAgICAgICAgICogQHNlZSBQSVhJLlNIQVBFU1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50eXBlID0gX2NvbnN0LlNIQVBFUy5QT0xZO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGlzIHBvbHlnb25cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1BJWEkuUG9seWdvbn0gYSBjb3B5IG9mIHRoZSBwb2x5Z29uXG4gICAgICovXG5cblxuICAgIFBvbHlnb24ucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUG9seWdvbih0aGlzLnBvaW50cy5zbGljZSgpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2xvc2VzIHRoZSBwb2x5Z29uLCBhZGRpbmcgcG9pbnRzIGlmIG5lY2Vzc2FyeS5cbiAgICAgKlxuICAgICAqL1xuXG5cbiAgICBQb2x5Z29uLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgICAgICB2YXIgcG9pbnRzID0gdGhpcy5wb2ludHM7XG5cbiAgICAgICAgLy8gY2xvc2UgdGhlIHBvbHkgaWYgdGhlIHZhbHVlIGlzIHRydWUhXG4gICAgICAgIGlmIChwb2ludHNbMF0gIT09IHBvaW50c1twb2ludHMubGVuZ3RoIC0gMl0gfHwgcG9pbnRzWzFdICE9PSBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdKSB7XG4gICAgICAgICAgICBwb2ludHMucHVzaChwb2ludHNbMF0sIHBvaW50c1sxXSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIHggYW5kIHkgY29vcmRpbmF0ZXMgcGFzc2VkIHRvIHRoaXMgZnVuY3Rpb24gYXJlIGNvbnRhaW5lZCB3aXRoaW4gdGhpcyBwb2x5Z29uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAtIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIHRlc3RcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIHRlc3RcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSB4L3kgY29vcmRpbmF0ZXMgYXJlIHdpdGhpbiB0aGlzIHBvbHlnb25cbiAgICAgKi9cblxuXG4gICAgUG9seWdvbi5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbiBjb250YWlucyh4LCB5KSB7XG4gICAgICAgIHZhciBpbnNpZGUgPSBmYWxzZTtcblxuICAgICAgICAvLyB1c2Ugc29tZSByYXljYXN0aW5nIHRvIHRlc3QgaGl0c1xuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vc3Vic3RhY2svcG9pbnQtaW4tcG9seWdvbi9ibG9iL21hc3Rlci9pbmRleC5qc1xuICAgICAgICB2YXIgbGVuZ3RoID0gdGhpcy5wb2ludHMubGVuZ3RoIC8gMjtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgaiA9IGxlbmd0aCAtIDE7IGkgPCBsZW5ndGg7IGogPSBpKyspIHtcbiAgICAgICAgICAgIHZhciB4aSA9IHRoaXMucG9pbnRzW2kgKiAyXTtcbiAgICAgICAgICAgIHZhciB5aSA9IHRoaXMucG9pbnRzW2kgKiAyICsgMV07XG4gICAgICAgICAgICB2YXIgeGogPSB0aGlzLnBvaW50c1tqICogMl07XG4gICAgICAgICAgICB2YXIgeWogPSB0aGlzLnBvaW50c1tqICogMiArIDFdO1xuICAgICAgICAgICAgdmFyIGludGVyc2VjdCA9IHlpID4geSAhPT0geWogPiB5ICYmIHggPCAoeGogLSB4aSkgKiAoKHkgLSB5aSkgLyAoeWogLSB5aSkpICsgeGk7XG5cbiAgICAgICAgICAgIGlmIChpbnRlcnNlY3QpIHtcbiAgICAgICAgICAgICAgICBpbnNpZGUgPSAhaW5zaWRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGluc2lkZTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFBvbHlnb247XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFBvbHlnb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Qb2x5Z29uLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9jb25zdCA9IHJlcXVpcmUoJy4uLy4uL2NvbnN0Jyk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8qKlxuICogUmVjdGFuZ2xlIG9iamVjdCBpcyBhbiBhcmVhIGRlZmluZWQgYnkgaXRzIHBvc2l0aW9uLCBhcyBpbmRpY2F0ZWQgYnkgaXRzIHRvcC1sZWZ0IGNvcm5lclxuICogcG9pbnQgKHgsIHkpIGFuZCBieSBpdHMgd2lkdGggYW5kIGl0cyBoZWlnaHQuXG4gKlxuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgUElYSVxuICovXG52YXIgUmVjdGFuZ2xlID0gZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IFt4PTBdIC0gVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgdXBwZXItbGVmdCBjb3JuZXIgb2YgdGhlIHJlY3RhbmdsZVxuICAgKiBAcGFyYW0ge251bWJlcn0gW3k9MF0gLSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSB1cHBlci1sZWZ0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbd2lkdGg9MF0gLSBUaGUgb3ZlcmFsbCB3aWR0aCBvZiB0aGlzIHJlY3RhbmdsZVxuICAgKiBAcGFyYW0ge251bWJlcn0gW2hlaWdodD0wXSAtIFRoZSBvdmVyYWxsIGhlaWdodCBvZiB0aGlzIHJlY3RhbmdsZVxuICAgKi9cbiAgZnVuY3Rpb24gUmVjdGFuZ2xlKCkge1xuICAgIHZhciB4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAwO1xuICAgIHZhciB5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICAgIHZhciB3aWR0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMDtcbiAgICB2YXIgaGVpZ2h0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiAwO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJlY3RhbmdsZSk7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIHRoaXMueCA9IE51bWJlcih4KTtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgdGhpcy55ID0gTnVtYmVyKHkpO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICB0aGlzLndpZHRoID0gTnVtYmVyKHdpZHRoKTtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgdGhpcy5oZWlnaHQgPSBOdW1iZXIoaGVpZ2h0KTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlIG9mIHRoZSBvYmplY3QsIG1haW5seSB1c2VkIHRvIGF2b2lkIGBpbnN0YW5jZW9mYCBjaGVja3NcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAcmVhZE9ubHlcbiAgICAgKiBAZGVmYXVsdCBQSVhJLlNIQVBFUy5SRUNUXG4gICAgICogQHNlZSBQSVhJLlNIQVBFU1xuICAgICAqL1xuICAgIHRoaXMudHlwZSA9IF9jb25zdC5TSEFQRVMuUkVDVDtcbiAgfVxuXG4gIC8qKlxuICAgKiByZXR1cm5zIHRoZSBsZWZ0IGVkZ2Ugb2YgdGhlIHJlY3RhbmdsZVxuICAgKlxuICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAqL1xuXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGlzIFJlY3RhbmdsZVxuICAgKlxuICAgKiBAcmV0dXJuIHtQSVhJLlJlY3RhbmdsZX0gYSBjb3B5IG9mIHRoZSByZWN0YW5nbGVcbiAgICovXG4gIFJlY3RhbmdsZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IFJlY3RhbmdsZSh0aGlzLngsIHRoaXMueSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDb3BpZXMgYW5vdGhlciByZWN0YW5nbGUgdG8gdGhpcyBvbmUuXG4gICAqXG4gICAqIEBwYXJhbSB7UElYSS5SZWN0YW5nbGV9IHJlY3RhbmdsZSAtIFRoZSByZWN0YW5nbGUgdG8gY29weS5cbiAgICogQHJldHVybiB7UElYSS5SZWN0YW5nbGV9IFJldHVybnMgaXRzZWxmLlxuICAgKi9cblxuXG4gIFJlY3RhbmdsZS5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkocmVjdGFuZ2xlKSB7XG4gICAgdGhpcy54ID0gcmVjdGFuZ2xlLng7XG4gICAgdGhpcy55ID0gcmVjdGFuZ2xlLnk7XG4gICAgdGhpcy53aWR0aCA9IHJlY3RhbmdsZS53aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IHJlY3RhbmdsZS5oZWlnaHQ7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIHggYW5kIHkgY29vcmRpbmF0ZXMgZ2l2ZW4gYXJlIGNvbnRhaW5lZCB3aXRoaW4gdGhpcyBSZWN0YW5nbGVcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byB0ZXN0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gdGVzdFxuICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSB4L3kgY29vcmRpbmF0ZXMgYXJlIHdpdGhpbiB0aGlzIFJlY3RhbmdsZVxuICAgKi9cblxuXG4gIFJlY3RhbmdsZS5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbiBjb250YWlucyh4LCB5KSB7XG4gICAgaWYgKHRoaXMud2lkdGggPD0gMCB8fCB0aGlzLmhlaWdodCA8PSAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHggPj0gdGhpcy54ICYmIHggPCB0aGlzLnggKyB0aGlzLndpZHRoKSB7XG4gICAgICBpZiAoeSA+PSB0aGlzLnkgJiYgeSA8IHRoaXMueSArIHRoaXMuaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogUGFkcyB0aGUgcmVjdGFuZ2xlIG1ha2luZyBpdCBncm93IGluIGFsbCBkaXJlY3Rpb25zLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gcGFkZGluZ1ggLSBUaGUgaG9yaXpvbnRhbCBwYWRkaW5nIGFtb3VudC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtwYWRkaW5nWV0gLSBUaGUgdmVydGljYWwgcGFkZGluZyBhbW91bnQuXG4gICAqL1xuXG5cbiAgUmVjdGFuZ2xlLnByb3RvdHlwZS5wYWQgPSBmdW5jdGlvbiBwYWQocGFkZGluZ1gsIHBhZGRpbmdZKSB7XG4gICAgcGFkZGluZ1ggPSBwYWRkaW5nWCB8fCAwO1xuICAgIHBhZGRpbmdZID0gcGFkZGluZ1kgfHwgKHBhZGRpbmdZICE9PSAwID8gcGFkZGluZ1ggOiAwKTtcblxuICAgIHRoaXMueCAtPSBwYWRkaW5nWDtcbiAgICB0aGlzLnkgLT0gcGFkZGluZ1k7XG5cbiAgICB0aGlzLndpZHRoICs9IHBhZGRpbmdYICogMjtcbiAgICB0aGlzLmhlaWdodCArPSBwYWRkaW5nWSAqIDI7XG4gIH07XG5cbiAgLyoqXG4gICAqIEZpdHMgdGhpcyByZWN0YW5nbGUgYXJvdW5kIHRoZSBwYXNzZWQgb25lLlxuICAgKlxuICAgKiBAcGFyYW0ge1BJWEkuUmVjdGFuZ2xlfSByZWN0YW5nbGUgLSBUaGUgcmVjdGFuZ2xlIHRvIGZpdC5cbiAgICovXG5cblxuICBSZWN0YW5nbGUucHJvdG90eXBlLmZpdCA9IGZ1bmN0aW9uIGZpdChyZWN0YW5nbGUpIHtcbiAgICB2YXIgeDEgPSBNYXRoLm1heCh0aGlzLngsIHJlY3RhbmdsZS54KTtcbiAgICB2YXIgeDIgPSBNYXRoLm1pbih0aGlzLnggKyB0aGlzLndpZHRoLCByZWN0YW5nbGUueCArIHJlY3RhbmdsZS53aWR0aCk7XG4gICAgdmFyIHkxID0gTWF0aC5tYXgodGhpcy55LCByZWN0YW5nbGUueSk7XG4gICAgdmFyIHkyID0gTWF0aC5taW4odGhpcy55ICsgdGhpcy5oZWlnaHQsIHJlY3RhbmdsZS55ICsgcmVjdGFuZ2xlLmhlaWdodCk7XG5cbiAgICB0aGlzLnggPSB4MTtcbiAgICB0aGlzLndpZHRoID0gTWF0aC5tYXgoeDIgLSB4MSwgMCk7XG4gICAgdGhpcy55ID0geTE7XG4gICAgdGhpcy5oZWlnaHQgPSBNYXRoLm1heCh5MiAtIHkxLCAwKTtcbiAgfTtcblxuICAvKipcbiAgICogRW5sYXJnZXMgdGhpcyByZWN0YW5nbGUgdG8gaW5jbHVkZSB0aGUgcGFzc2VkIHJlY3RhbmdsZS5cbiAgICpcbiAgICogQHBhcmFtIHtQSVhJLlJlY3RhbmdsZX0gcmVjdGFuZ2xlIC0gVGhlIHJlY3RhbmdsZSB0byBpbmNsdWRlLlxuICAgKi9cblxuXG4gIFJlY3RhbmdsZS5wcm90b3R5cGUuZW5sYXJnZSA9IGZ1bmN0aW9uIGVubGFyZ2UocmVjdGFuZ2xlKSB7XG4gICAgdmFyIHgxID0gTWF0aC5taW4odGhpcy54LCByZWN0YW5nbGUueCk7XG4gICAgdmFyIHgyID0gTWF0aC5tYXgodGhpcy54ICsgdGhpcy53aWR0aCwgcmVjdGFuZ2xlLnggKyByZWN0YW5nbGUud2lkdGgpO1xuICAgIHZhciB5MSA9IE1hdGgubWluKHRoaXMueSwgcmVjdGFuZ2xlLnkpO1xuICAgIHZhciB5MiA9IE1hdGgubWF4KHRoaXMueSArIHRoaXMuaGVpZ2h0LCByZWN0YW5nbGUueSArIHJlY3RhbmdsZS5oZWlnaHQpO1xuXG4gICAgdGhpcy54ID0geDE7XG4gICAgdGhpcy53aWR0aCA9IHgyIC0geDE7XG4gICAgdGhpcy55ID0geTE7XG4gICAgdGhpcy5oZWlnaHQgPSB5MiAtIHkxO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFbmxhcmdlcyByZWN0YW5nbGUgdGhhdCB3YXkgaXRzIGNvcm5lcnMgbGllIG9uIGdyaWRcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtyZXNvbHV0aW9uPTFdIHJlc29sdXRpb25cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtlcHM9MC4wMDFdIHByZWNpc2lvblxuICAgKi9cblxuXG4gIFJlY3RhbmdsZS5wcm90b3R5cGUuY2VpbCA9IGZ1bmN0aW9uIGNlaWwoKSB7XG4gICAgdmFyIHJlc29sdXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDE7XG4gICAgdmFyIGVwcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMC4wMDE7XG5cbiAgICB2YXIgeDIgPSBNYXRoLmNlaWwoKHRoaXMueCArIHRoaXMud2lkdGggLSBlcHMpICogcmVzb2x1dGlvbikgLyByZXNvbHV0aW9uO1xuICAgIHZhciB5MiA9IE1hdGguY2VpbCgodGhpcy55ICsgdGhpcy5oZWlnaHQgLSBlcHMpICogcmVzb2x1dGlvbikgLyByZXNvbHV0aW9uO1xuXG4gICAgdGhpcy54ID0gTWF0aC5mbG9vcigodGhpcy54ICsgZXBzKSAqIHJlc29sdXRpb24pIC8gcmVzb2x1dGlvbjtcbiAgICB0aGlzLnkgPSBNYXRoLmZsb29yKCh0aGlzLnkgKyBlcHMpICogcmVzb2x1dGlvbikgLyByZXNvbHV0aW9uO1xuXG4gICAgdGhpcy53aWR0aCA9IHgyIC0gdGhpcy54O1xuICAgIHRoaXMuaGVpZ2h0ID0geTIgLSB0aGlzLnk7XG4gIH07XG5cbiAgX2NyZWF0ZUNsYXNzKFJlY3RhbmdsZSwgW3tcbiAgICBrZXk6ICdsZWZ0JyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLng7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmV0dXJucyB0aGUgcmlnaHQgZWRnZSBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3JpZ2h0JyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnggKyB0aGlzLndpZHRoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJldHVybnMgdGhlIHRvcCBlZGdlIG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndG9wJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmV0dXJucyB0aGUgYm90dG9tIGVkZ2Ugb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdib3R0b20nLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMueSArIHRoaXMuaGVpZ2h0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgY29uc3RhbnQgZW1wdHkgcmVjdGFuZ2xlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBjb25zdGFudFxuICAgICAqL1xuXG4gIH1dLCBbe1xuICAgIGtleTogJ0VNUFRZJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBuZXcgUmVjdGFuZ2xlKDAsIDAsIDAsIDApO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBSZWN0YW5nbGU7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFJlY3RhbmdsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJlY3RhbmdsZS5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfY29uc3QgPSByZXF1aXJlKCcuLi8uLi9jb25zdCcpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vKipcbiAqIFRoZSBSb3VuZGVkIFJlY3RhbmdsZSBvYmplY3QgaXMgYW4gYXJlYSB0aGF0IGhhcyBuaWNlIHJvdW5kZWQgY29ybmVycywgYXMgaW5kaWNhdGVkIGJ5IGl0c1xuICogdG9wLWxlZnQgY29ybmVyIHBvaW50ICh4LCB5KSBhbmQgYnkgaXRzIHdpZHRoIGFuZCBpdHMgaGVpZ2h0IGFuZCBpdHMgcmFkaXVzLlxuICpcbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIFBJWElcbiAqL1xudmFyIFJvdW5kZWRSZWN0YW5nbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt4PTBdIC0gVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgdXBwZXItbGVmdCBjb3JuZXIgb2YgdGhlIHJvdW5kZWQgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt5PTBdIC0gVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgdXBwZXItbGVmdCBjb3JuZXIgb2YgdGhlIHJvdW5kZWQgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt3aWR0aD0wXSAtIFRoZSBvdmVyYWxsIHdpZHRoIG9mIHRoaXMgcm91bmRlZCByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2hlaWdodD0wXSAtIFRoZSBvdmVyYWxsIGhlaWdodCBvZiB0aGlzIHJvdW5kZWQgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtyYWRpdXM9MjBdIC0gQ29udHJvbHMgdGhlIHJhZGl1cyBvZiB0aGUgcm91bmRlZCBjb3JuZXJzXG4gICAgICovXG4gICAgZnVuY3Rpb24gUm91bmRlZFJlY3RhbmdsZSgpIHtcbiAgICAgICAgdmFyIHggPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG4gICAgICAgIHZhciB5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICAgICAgICB2YXIgd2lkdGggPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDA7XG4gICAgICAgIHZhciBoZWlnaHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IDA7XG4gICAgICAgIHZhciByYWRpdXMgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IDIwO1xuXG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSb3VuZGVkUmVjdGFuZ2xlKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAwXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnggPSB4O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMueSA9IHk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDIwXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJhZGl1cyA9IHJhZGl1cztcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHR5cGUgb2YgdGhlIG9iamVjdCwgbWFpbmx5IHVzZWQgdG8gYXZvaWQgYGluc3RhbmNlb2ZgIGNoZWNrc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEByZWFkb25seVxuICAgICAgICAgKiBAZGVmYXVsdCBQSVhJLlNIQVBFUy5SUkVDXG4gICAgICAgICAqIEBzZWUgUElYSS5TSEFQRVNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudHlwZSA9IF9jb25zdC5TSEFQRVMuUlJFQztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhpcyBSb3VuZGVkIFJlY3RhbmdsZVxuICAgICAqXG4gICAgICogQHJldHVybiB7UElYSS5Sb3VuZGVkUmVjdGFuZ2xlfSBhIGNvcHkgb2YgdGhlIHJvdW5kZWQgcmVjdGFuZ2xlXG4gICAgICovXG5cblxuICAgIFJvdW5kZWRSZWN0YW5nbGUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUm91bmRlZFJlY3RhbmdsZSh0aGlzLngsIHRoaXMueSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIHRoaXMucmFkaXVzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIHggYW5kIHkgY29vcmRpbmF0ZXMgZ2l2ZW4gYXJlIGNvbnRhaW5lZCB3aXRoaW4gdGhpcyBSb3VuZGVkIFJlY3RhbmdsZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byB0ZXN0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byB0ZXN0XG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgeC95IGNvb3JkaW5hdGVzIGFyZSB3aXRoaW4gdGhpcyBSb3VuZGVkIFJlY3RhbmdsZVxuICAgICAqL1xuXG5cbiAgICBSb3VuZGVkUmVjdGFuZ2xlLnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uIGNvbnRhaW5zKHgsIHkpIHtcbiAgICAgICAgaWYgKHRoaXMud2lkdGggPD0gMCB8fCB0aGlzLmhlaWdodCA8PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHggPj0gdGhpcy54ICYmIHggPD0gdGhpcy54ICsgdGhpcy53aWR0aCkge1xuICAgICAgICAgICAgaWYgKHkgPj0gdGhpcy55ICYmIHkgPD0gdGhpcy55ICsgdGhpcy5oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBpZiAoeSA+PSB0aGlzLnkgKyB0aGlzLnJhZGl1cyAmJiB5IDw9IHRoaXMueSArIHRoaXMuaGVpZ2h0IC0gdGhpcy5yYWRpdXMgfHwgeCA+PSB0aGlzLnggKyB0aGlzLnJhZGl1cyAmJiB4IDw9IHRoaXMueCArIHRoaXMud2lkdGggLSB0aGlzLnJhZGl1cykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGR4ID0geCAtICh0aGlzLnggKyB0aGlzLnJhZGl1cyk7XG4gICAgICAgICAgICAgICAgdmFyIGR5ID0geSAtICh0aGlzLnkgKyB0aGlzLnJhZGl1cyk7XG4gICAgICAgICAgICAgICAgdmFyIHJhZGl1czIgPSB0aGlzLnJhZGl1cyAqIHRoaXMucmFkaXVzO1xuXG4gICAgICAgICAgICAgICAgaWYgKGR4ICogZHggKyBkeSAqIGR5IDw9IHJhZGl1czIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGR4ID0geCAtICh0aGlzLnggKyB0aGlzLndpZHRoIC0gdGhpcy5yYWRpdXMpO1xuICAgICAgICAgICAgICAgIGlmIChkeCAqIGR4ICsgZHkgKiBkeSA8PSByYWRpdXMyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkeSA9IHkgLSAodGhpcy55ICsgdGhpcy5oZWlnaHQgLSB0aGlzLnJhZGl1cyk7XG4gICAgICAgICAgICAgICAgaWYgKGR4ICogZHggKyBkeSAqIGR5IDw9IHJhZGl1czIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGR4ID0geCAtICh0aGlzLnggKyB0aGlzLnJhZGl1cyk7XG4gICAgICAgICAgICAgICAgaWYgKGR4ICogZHggKyBkeSAqIGR5IDw9IHJhZGl1czIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICByZXR1cm4gUm91bmRlZFJlY3RhbmdsZTtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gUm91bmRlZFJlY3RhbmdsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJvdW5kZWRSZWN0YW5nbGUuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX3V0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxudmFyIF9tYXRoID0gcmVxdWlyZSgnLi4vbWF0aCcpO1xuXG52YXIgX2NvbnN0ID0gcmVxdWlyZSgnLi4vY29uc3QnKTtcblxudmFyIF9zZXR0aW5ncyA9IHJlcXVpcmUoJy4uL3NldHRpbmdzJyk7XG5cbnZhciBfc2V0dGluZ3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc2V0dGluZ3MpO1xuXG52YXIgX0NvbnRhaW5lciA9IHJlcXVpcmUoJy4uL2Rpc3BsYXkvQ29udGFpbmVyJyk7XG5cbnZhciBfQ29udGFpbmVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0NvbnRhaW5lcik7XG5cbnZhciBfUmVuZGVyVGV4dHVyZSA9IHJlcXVpcmUoJy4uL3RleHR1cmVzL1JlbmRlclRleHR1cmUnKTtcblxudmFyIF9SZW5kZXJUZXh0dXJlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1JlbmRlclRleHR1cmUpO1xuXG52YXIgX2V2ZW50ZW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50ZW1pdHRlcjMnKTtcblxudmFyIF9ldmVudGVtaXR0ZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZXZlbnRlbWl0dGVyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgdGVtcE1hdHJpeCA9IG5ldyBfbWF0aC5NYXRyaXgoKTtcblxuLyoqXG4gKiBUaGUgU3lzdGVtUmVuZGVyZXIgaXMgdGhlIGJhc2UgZm9yIGEgUGl4aUpTIFJlbmRlcmVyLiBJdCBpcyBleHRlbmRlZCBieSB0aGUge0BsaW5rIFBJWEkuQ2FudmFzUmVuZGVyZXJ9XG4gKiBhbmQge0BsaW5rIFBJWEkuV2ViR0xSZW5kZXJlcn0gd2hpY2ggY2FuIGJlIHVzZWQgZm9yIHJlbmRlcmluZyBhIFBpeGlKUyBzY2VuZS5cbiAqXG4gKiBAYWJzdHJhY3RcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgRXZlbnRFbWl0dGVyXG4gKiBAbWVtYmVyb2YgUElYSVxuICovXG5cbnZhciBTeXN0ZW1SZW5kZXJlciA9IGZ1bmN0aW9uIChfRXZlbnRFbWl0dGVyKSB7XG4gIF9pbmhlcml0cyhTeXN0ZW1SZW5kZXJlciwgX0V2ZW50RW1pdHRlcik7XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHZhbGlkLWpzZG9jXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3lzdGVtIC0gVGhlIG5hbWUgb2YgdGhlIHN5c3RlbSB0aGlzIHJlbmRlcmVyIGlzIGZvci5cbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAtIFRoZSBvcHRpb25hbCByZW5kZXJlciBwYXJhbWV0ZXJzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy53aWR0aD04MDBdIC0gdGhlIHdpZHRoIG9mIHRoZSBzY3JlZW5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmhlaWdodD02MDBdIC0gdGhlIGhlaWdodCBvZiB0aGUgc2NyZWVuXG4gICAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IFtvcHRpb25zLnZpZXddIC0gdGhlIGNhbnZhcyB0byB1c2UgYXMgYSB2aWV3LCBvcHRpb25hbFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYW5zcGFyZW50PWZhbHNlXSAtIElmIHRoZSByZW5kZXIgdmlldyBpcyB0cmFuc3BhcmVudCwgZGVmYXVsdCBmYWxzZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmF1dG9SZXNpemU9ZmFsc2VdIC0gSWYgdGhlIHJlbmRlciB2aWV3IGlzIGF1dG9tYXRpY2FsbHkgcmVzaXplZCwgZGVmYXVsdCBmYWxzZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmFudGlhbGlhcz1mYWxzZV0gLSBzZXRzIGFudGlhbGlhcyAob25seSBhcHBsaWNhYmxlIGluIGNocm9tZSBhdCB0aGUgbW9tZW50KVxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMucmVzb2x1dGlvbj0xXSAtIFRoZSByZXNvbHV0aW9uIC8gZGV2aWNlIHBpeGVsIHJhdGlvIG9mIHRoZSByZW5kZXJlci4gVGhlXG4gICAqICByZXNvbHV0aW9uIG9mIHRoZSByZW5kZXJlciByZXRpbmEgd291bGQgYmUgMi5cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5wcmVzZXJ2ZURyYXdpbmdCdWZmZXI9ZmFsc2VdIC0gZW5hYmxlcyBkcmF3aW5nIGJ1ZmZlciBwcmVzZXJ2YXRpb24sXG4gICAqICBlbmFibGUgdGhpcyBpZiB5b3UgbmVlZCB0byBjYWxsIHRvRGF0YVVybCBvbiB0aGUgd2ViZ2wgY29udGV4dC5cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jbGVhckJlZm9yZVJlbmRlcj10cnVlXSAtIFRoaXMgc2V0cyBpZiB0aGUgcmVuZGVyZXIgd2lsbCBjbGVhciB0aGUgY2FudmFzIG9yXG4gICAqICAgICAgbm90IGJlZm9yZSB0aGUgbmV3IHJlbmRlciBwYXNzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuYmFja2dyb3VuZENvbG9yPTB4MDAwMDAwXSAtIFRoZSBiYWNrZ3JvdW5kIGNvbG9yIG9mIHRoZSByZW5kZXJlZCBhcmVhXG4gICAqICAoc2hvd24gaWYgbm90IHRyYW5zcGFyZW50KS5cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5yb3VuZFBpeGVscz1mYWxzZV0gLSBJZiB0cnVlIFBpeGlKUyB3aWxsIE1hdGguZmxvb3IoKSB4L3kgdmFsdWVzIHdoZW4gcmVuZGVyaW5nLFxuICAgKiAgc3RvcHBpbmcgcGl4ZWwgaW50ZXJwb2xhdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIFN5c3RlbVJlbmRlcmVyKHN5c3RlbSwgb3B0aW9ucywgYXJnMiwgYXJnMykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTeXN0ZW1SZW5kZXJlcik7XG5cbiAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfRXZlbnRFbWl0dGVyLmNhbGwodGhpcykpO1xuXG4gICAgKDAsIF91dGlscy5zYXlIZWxsbykoc3lzdGVtKTtcblxuICAgIC8vIFN1cHBvcnQgZm9yIGNvbnN0cnVjdG9yKHN5c3RlbSwgc2NyZWVuV2lkdGgsIHNjcmVlbkhlaWdodCwgb3B0aW9ucylcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdudW1iZXInKSB7XG4gICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIHdpZHRoOiBvcHRpb25zLFxuICAgICAgICBoZWlnaHQ6IGFyZzIgfHwgX3NldHRpbmdzMi5kZWZhdWx0LlJFTkRFUl9PUFRJT05TLmhlaWdodFxuICAgICAgfSwgYXJnMyk7XG4gICAgfVxuXG4gICAgLy8gQWRkIHRoZSBkZWZhdWx0IHJlbmRlciBvcHRpb25zXG4gICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIF9zZXR0aW5nczIuZGVmYXVsdC5SRU5ERVJfT1BUSU9OUywgb3B0aW9ucyk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3VwcGxpZWQgY29uc3RydWN0b3Igb3B0aW9ucy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge09iamVjdH1cbiAgICAgKiBAcmVhZE9ubHlcbiAgICAgKi9cbiAgICBfdGhpcy5vcHRpb25zID0gb3B0aW9ucztcblxuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlIG9mIHRoZSByZW5kZXJlci5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCBQSVhJLlJFTkRFUkVSX1RZUEUuVU5LTk9XTlxuICAgICAqIEBzZWUgUElYSS5SRU5ERVJFUl9UWVBFXG4gICAgICovXG4gICAgX3RoaXMudHlwZSA9IF9jb25zdC5SRU5ERVJFUl9UWVBFLlVOS05PV047XG5cbiAgICAvKipcbiAgICAgKiBNZWFzdXJlbWVudHMgb2YgdGhlIHNjcmVlbi4gKDAsIDAsIHNjcmVlbldpZHRoLCBzY3JlZW5IZWlnaHQpXG4gICAgICpcbiAgICAgKiBJdHMgc2FmZSB0byB1c2UgYXMgZmlsdGVyQXJlYSBvciBoaXRBcmVhIGZvciB3aG9sZSBzdGFnZVxuICAgICAqXG4gICAgICogQG1lbWJlciB7UElYSS5SZWN0YW5nbGV9XG4gICAgICovXG4gICAgX3RoaXMuc2NyZWVuID0gbmV3IF9tYXRoLlJlY3RhbmdsZSgwLCAwLCBvcHRpb25zLndpZHRoLCBvcHRpb25zLmhlaWdodCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY2FudmFzIGVsZW1lbnQgdGhhdCBldmVyeXRoaW5nIGlzIGRyYXduIHRvXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtIVE1MQ2FudmFzRWxlbWVudH1cbiAgICAgKi9cbiAgICBfdGhpcy52aWV3ID0gb3B0aW9ucy52aWV3IHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHJlc29sdXRpb24gLyBkZXZpY2UgcGl4ZWwgcmF0aW8gb2YgdGhlIHJlbmRlcmVyXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMVxuICAgICAqL1xuICAgIF90aGlzLnJlc29sdXRpb24gPSBvcHRpb25zLnJlc29sdXRpb24gfHwgX3NldHRpbmdzMi5kZWZhdWx0LlJFU09MVVRJT047XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSByZW5kZXIgdmlldyBpcyB0cmFuc3BhcmVudFxuICAgICAqXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBfdGhpcy50cmFuc3BhcmVudCA9IG9wdGlvbnMudHJhbnNwYXJlbnQ7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGNzcyBkaW1lbnNpb25zIG9mIGNhbnZhcyB2aWV3IHNob3VsZCBiZSByZXNpemVkIHRvIHNjcmVlbiBkaW1lbnNpb25zIGF1dG9tYXRpY2FsbHlcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICovXG4gICAgX3RoaXMuYXV0b1Jlc2l6ZSA9IG9wdGlvbnMuYXV0b1Jlc2l6ZSB8fCBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFRyYWNrcyB0aGUgYmxlbmQgbW9kZXMgdXNlZnVsIGZvciB0aGlzIHJlbmRlcmVyLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7b2JqZWN0PHN0cmluZywgbWl4ZWQ+fVxuICAgICAqL1xuICAgIF90aGlzLmJsZW5kTW9kZXMgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIG9mIHRoZSBwcmVzZXJ2ZURyYXdpbmdCdWZmZXIgZmxhZyBhZmZlY3RzIHdoZXRoZXIgb3Igbm90IHRoZSBjb250ZW50cyBvZlxuICAgICAqIHRoZSBzdGVuY2lsIGJ1ZmZlciBpcyByZXRhaW5lZCBhZnRlciByZW5kZXJpbmcuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAqL1xuICAgIF90aGlzLnByZXNlcnZlRHJhd2luZ0J1ZmZlciA9IG9wdGlvbnMucHJlc2VydmVEcmF3aW5nQnVmZmVyO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBzZXRzIGlmIHRoZSBDYW52YXNSZW5kZXJlciB3aWxsIGNsZWFyIHRoZSBjYW52YXMgb3Igbm90IGJlZm9yZSB0aGUgbmV3IHJlbmRlciBwYXNzLlxuICAgICAqIElmIHRoZSBzY2VuZSBpcyBOT1QgdHJhbnNwYXJlbnQgUGl4aUpTIHdpbGwgdXNlIGEgY2FudmFzIHNpemVkIGZpbGxSZWN0IG9wZXJhdGlvbiBldmVyeVxuICAgICAqIGZyYW1lIHRvIHNldCB0aGUgY2FudmFzIGJhY2tncm91bmQgY29sb3IuIElmIHRoZSBzY2VuZSBpcyB0cmFuc3BhcmVudCBQaXhpSlMgd2lsbCB1c2UgY2xlYXJSZWN0XG4gICAgICogdG8gY2xlYXIgdGhlIGNhbnZhcyBldmVyeSBmcmFtZS4gRGlzYWJsZSB0aGlzIGJ5IHNldHRpbmcgdGhpcyB0byBmYWxzZS4gRm9yIGV4YW1wbGUgaWZcbiAgICAgKiB5b3VyIGdhbWUgaGFzIGEgY2FudmFzIGZpbGxpbmcgYmFja2dyb3VuZCBpbWFnZSB5b3Ugb2Z0ZW4gZG9uJ3QgbmVlZCB0aGlzIHNldC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBfdGhpcy5jbGVhckJlZm9yZVJlbmRlciA9IG9wdGlvbnMuY2xlYXJCZWZvcmVSZW5kZXI7XG5cbiAgICAvKipcbiAgICAgKiBJZiB0cnVlIFBpeGlKUyB3aWxsIE1hdGguZmxvb3IoKSB4L3kgdmFsdWVzIHdoZW4gcmVuZGVyaW5nLCBzdG9wcGluZyBwaXhlbCBpbnRlcnBvbGF0aW9uLlxuICAgICAqIEhhbmR5IGZvciBjcmlzcCBwaXhlbCBhcnQgYW5kIHNwZWVkIG9uIGxlZ2FjeSBkZXZpY2VzLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBfdGhpcy5yb3VuZFBpeGVscyA9IG9wdGlvbnMucm91bmRQaXhlbHM7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFja2dyb3VuZCBjb2xvciBhcyBhIG51bWJlci5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF90aGlzLl9iYWNrZ3JvdW5kQ29sb3IgPSAweDAwMDAwMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBiYWNrZ3JvdW5kIGNvbG9yIGFzIGFuIFtSLCBHLCBCXSBhcnJheS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcltdfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3RoaXMuX2JhY2tncm91bmRDb2xvclJnYmEgPSBbMCwgMCwgMCwgMF07XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFja2dyb3VuZCBjb2xvciBhcyBhIHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF90aGlzLl9iYWNrZ3JvdW5kQ29sb3JTdHJpbmcgPSAnIzAwMDAwMCc7XG5cbiAgICBfdGhpcy5iYWNrZ3JvdW5kQ29sb3IgPSBvcHRpb25zLmJhY2tncm91bmRDb2xvciB8fCBfdGhpcy5fYmFja2dyb3VuZENvbG9yOyAvLyBydW4gYmcgY29sb3Igc2V0dGVyXG5cbiAgICAvKipcbiAgICAgKiBUaGlzIHRlbXBvcmFyeSBkaXNwbGF5IG9iamVjdCB1c2VkIGFzIHRoZSBwYXJlbnQgb2YgdGhlIGN1cnJlbnRseSBiZWluZyByZW5kZXJlZCBpdGVtXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtQSVhJLkRpc3BsYXlPYmplY3R9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdGhpcy5fdGVtcERpc3BsYXlPYmplY3RQYXJlbnQgPSBuZXcgX0NvbnRhaW5lcjIuZGVmYXVsdCgpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGxhc3Qgcm9vdCBvYmplY3QgdGhhdCB0aGUgcmVuZGVyZXIgdHJpZWQgdG8gcmVuZGVyLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7UElYSS5EaXNwbGF5T2JqZWN0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3RoaXMuX2xhc3RPYmplY3RSZW5kZXJlZCA9IF90aGlzLl90ZW1wRGlzcGxheU9iamVjdFBhcmVudDtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogU2FtZSBhcyB2aWV3LndpZHRoLCBhY3R1YWwgbnVtYmVyIG9mIHBpeGVscyBpbiB0aGUgY2FudmFzIGJ5IGhvcml6b250YWxcbiAgICpcbiAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgKiBAcmVhZG9ubHlcbiAgICogQGRlZmF1bHQgODAwXG4gICAqL1xuXG5cbiAgLyoqXG4gICAqIFJlc2l6ZXMgdGhlIHNjcmVlbiBhbmQgY2FudmFzIHRvIHRoZSBzcGVjaWZpZWQgd2lkdGggYW5kIGhlaWdodFxuICAgKiBDYW52YXMgZGltZW5zaW9ucyBhcmUgbXVsdGlwbGllZCBieSByZXNvbHV0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzY3JlZW5XaWR0aCAtIHRoZSBuZXcgd2lkdGggb2YgdGhlIHNjcmVlblxuICAgKiBAcGFyYW0ge251bWJlcn0gc2NyZWVuSGVpZ2h0IC0gdGhlIG5ldyBoZWlnaHQgb2YgdGhlIHNjcmVlblxuICAgKi9cbiAgU3lzdGVtUmVuZGVyZXIucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uIHJlc2l6ZShzY3JlZW5XaWR0aCwgc2NyZWVuSGVpZ2h0KSB7XG4gICAgdGhpcy5zY3JlZW4ud2lkdGggPSBzY3JlZW5XaWR0aDtcbiAgICB0aGlzLnNjcmVlbi5oZWlnaHQgPSBzY3JlZW5IZWlnaHQ7XG5cbiAgICB0aGlzLnZpZXcud2lkdGggPSBzY3JlZW5XaWR0aCAqIHRoaXMucmVzb2x1dGlvbjtcbiAgICB0aGlzLnZpZXcuaGVpZ2h0ID0gc2NyZWVuSGVpZ2h0ICogdGhpcy5yZXNvbHV0aW9uO1xuXG4gICAgaWYgKHRoaXMuYXV0b1Jlc2l6ZSkge1xuICAgICAgdGhpcy52aWV3LnN0eWxlLndpZHRoID0gc2NyZWVuV2lkdGggKyAncHgnO1xuICAgICAgdGhpcy52aWV3LnN0eWxlLmhlaWdodCA9IHNjcmVlbkhlaWdodCArICdweCc7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBVc2VmdWwgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgdGV4dHVyZSBvZiB0aGUgZGlzcGxheSBvYmplY3QgdGhhdCBjYW4gdGhlbiBiZSB1c2VkIHRvIGNyZWF0ZSBzcHJpdGVzXG4gICAqIFRoaXMgY2FuIGJlIHF1aXRlIHVzZWZ1bCBpZiB5b3VyIGRpc3BsYXlPYmplY3QgaXMgY29tcGxpY2F0ZWQgYW5kIG5lZWRzIHRvIGJlIHJldXNlZCBtdWx0aXBsZSB0aW1lcy5cbiAgICpcbiAgICogQHBhcmFtIHtQSVhJLkRpc3BsYXlPYmplY3R9IGRpc3BsYXlPYmplY3QgLSBUaGUgZGlzcGxheU9iamVjdCB0aGUgb2JqZWN0IHdpbGwgYmUgZ2VuZXJhdGVkIGZyb21cbiAgICogQHBhcmFtIHtudW1iZXJ9IHNjYWxlTW9kZSAtIFNob3VsZCBiZSBvbmUgb2YgdGhlIHNjYWxlTW9kZSBjb25zdHNcbiAgICogQHBhcmFtIHtudW1iZXJ9IHJlc29sdXRpb24gLSBUaGUgcmVzb2x1dGlvbiAvIGRldmljZSBwaXhlbCByYXRpbyBvZiB0aGUgdGV4dHVyZSBiZWluZyBnZW5lcmF0ZWRcbiAgICogQHBhcmFtIHtQSVhJLlJlY3RhbmdsZX0gW3JlZ2lvbl0gLSBUaGUgcmVnaW9uIG9mIHRoZSBkaXNwbGF5T2JqZWN0LCB0aGF0IHNoYWxsIGJlIHJlbmRlcmVkLFxuICAgKiAgICAgICAgaWYgbm8gcmVnaW9uIGlzIHNwZWNpZmllZCwgZGVmYXVsdHMgdG8gdGhlIGxvY2FsIGJvdW5kcyBvZiB0aGUgZGlzcGxheU9iamVjdC5cbiAgICogQHJldHVybiB7UElYSS5UZXh0dXJlfSBhIHRleHR1cmUgb2YgdGhlIGdyYXBoaWNzIG9iamVjdFxuICAgKi9cblxuXG4gIFN5c3RlbVJlbmRlcmVyLnByb3RvdHlwZS5nZW5lcmF0ZVRleHR1cmUgPSBmdW5jdGlvbiBnZW5lcmF0ZVRleHR1cmUoZGlzcGxheU9iamVjdCwgc2NhbGVNb2RlLCByZXNvbHV0aW9uLCByZWdpb24pIHtcbiAgICByZWdpb24gPSByZWdpb24gfHwgZGlzcGxheU9iamVjdC5nZXRMb2NhbEJvdW5kcygpO1xuXG4gICAgdmFyIHJlbmRlclRleHR1cmUgPSBfUmVuZGVyVGV4dHVyZTIuZGVmYXVsdC5jcmVhdGUocmVnaW9uLndpZHRoIHwgMCwgcmVnaW9uLmhlaWdodCB8IDAsIHNjYWxlTW9kZSwgcmVzb2x1dGlvbik7XG5cbiAgICB0ZW1wTWF0cml4LnR4ID0gLXJlZ2lvbi54O1xuICAgIHRlbXBNYXRyaXgudHkgPSAtcmVnaW9uLnk7XG5cbiAgICB0aGlzLnJlbmRlcihkaXNwbGF5T2JqZWN0LCByZW5kZXJUZXh0dXJlLCBmYWxzZSwgdGVtcE1hdHJpeCwgISFkaXNwbGF5T2JqZWN0LnBhcmVudCk7XG5cbiAgICByZXR1cm4gcmVuZGVyVGV4dHVyZTtcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlcyBldmVyeXRoaW5nIGZyb20gdGhlIHJlbmRlcmVyIGFuZCBvcHRpb25hbGx5IHJlbW92ZXMgdGhlIENhbnZhcyBET00gZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBbcmVtb3ZlVmlldz1mYWxzZV0gLSBSZW1vdmVzIHRoZSBDYW52YXMgZWxlbWVudCBmcm9tIHRoZSBET00uXG4gICAqL1xuXG5cbiAgU3lzdGVtUmVuZGVyZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KHJlbW92ZVZpZXcpIHtcbiAgICBpZiAocmVtb3ZlVmlldyAmJiB0aGlzLnZpZXcucGFyZW50Tm9kZSkge1xuICAgICAgdGhpcy52aWV3LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy52aWV3KTtcbiAgICB9XG5cbiAgICB0aGlzLnR5cGUgPSBfY29uc3QuUkVOREVSRVJfVFlQRS5VTktOT1dOO1xuXG4gICAgdGhpcy52aWV3ID0gbnVsbDtcblxuICAgIHRoaXMuc2NyZWVuID0gbnVsbDtcblxuICAgIHRoaXMucmVzb2x1dGlvbiA9IDA7XG5cbiAgICB0aGlzLnRyYW5zcGFyZW50ID0gZmFsc2U7XG5cbiAgICB0aGlzLmF1dG9SZXNpemUgPSBmYWxzZTtcblxuICAgIHRoaXMuYmxlbmRNb2RlcyA9IG51bGw7XG5cbiAgICB0aGlzLm9wdGlvbnMgPSBudWxsO1xuXG4gICAgdGhpcy5wcmVzZXJ2ZURyYXdpbmdCdWZmZXIgPSBmYWxzZTtcbiAgICB0aGlzLmNsZWFyQmVmb3JlUmVuZGVyID0gZmFsc2U7XG5cbiAgICB0aGlzLnJvdW5kUGl4ZWxzID0gZmFsc2U7XG5cbiAgICB0aGlzLl9iYWNrZ3JvdW5kQ29sb3IgPSAwO1xuICAgIHRoaXMuX2JhY2tncm91bmRDb2xvclJnYmEgPSBudWxsO1xuICAgIHRoaXMuX2JhY2tncm91bmRDb2xvclN0cmluZyA9IG51bGw7XG5cbiAgICB0aGlzLl90ZW1wRGlzcGxheU9iamVjdFBhcmVudCA9IG51bGw7XG4gICAgdGhpcy5fbGFzdE9iamVjdFJlbmRlcmVkID0gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogVGhlIGJhY2tncm91bmQgY29sb3IgdG8gZmlsbCBpZiBub3QgdHJhbnNwYXJlbnRcbiAgICpcbiAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhTeXN0ZW1SZW5kZXJlciwgW3tcbiAgICBrZXk6ICd3aWR0aCcsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy52aWV3LndpZHRoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNhbWUgYXMgdmlldy5oZWlnaHQsIGFjdHVhbCBudW1iZXIgb2YgcGl4ZWxzIGluIHRoZSBjYW52YXMgYnkgdmVydGljYWxcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKiBAZGVmYXVsdCA2MDBcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnaGVpZ2h0JyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnZpZXcuaGVpZ2h0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2JhY2tncm91bmRDb2xvcicsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYmFja2dyb3VuZENvbG9yO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcmVxdWlyZS1qc2RvY1xuICAgIHtcbiAgICAgIHRoaXMuX2JhY2tncm91bmRDb2xvciA9IHZhbHVlO1xuICAgICAgdGhpcy5fYmFja2dyb3VuZENvbG9yU3RyaW5nID0gKDAsIF91dGlscy5oZXgyc3RyaW5nKSh2YWx1ZSk7XG4gICAgICAoMCwgX3V0aWxzLmhleDJyZ2IpKHZhbHVlLCB0aGlzLl9iYWNrZ3JvdW5kQ29sb3JSZ2JhKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU3lzdGVtUmVuZGVyZXI7XG59KF9ldmVudGVtaXR0ZXIyLmRlZmF1bHQpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBTeXN0ZW1SZW5kZXJlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN5c3RlbVJlbmRlcmVyLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9TeXN0ZW1SZW5kZXJlcjIgPSByZXF1aXJlKCcuLi9TeXN0ZW1SZW5kZXJlcicpO1xuXG52YXIgX1N5c3RlbVJlbmRlcmVyMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1N5c3RlbVJlbmRlcmVyMik7XG5cbnZhciBfQ2FudmFzTWFza01hbmFnZXIgPSByZXF1aXJlKCcuL3V0aWxzL0NhbnZhc01hc2tNYW5hZ2VyJyk7XG5cbnZhciBfQ2FudmFzTWFza01hbmFnZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQ2FudmFzTWFza01hbmFnZXIpO1xuXG52YXIgX0NhbnZhc1JlbmRlclRhcmdldCA9IHJlcXVpcmUoJy4vdXRpbHMvQ2FudmFzUmVuZGVyVGFyZ2V0Jyk7XG5cbnZhciBfQ2FudmFzUmVuZGVyVGFyZ2V0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0NhbnZhc1JlbmRlclRhcmdldCk7XG5cbnZhciBfbWFwQ2FudmFzQmxlbmRNb2Rlc1RvUGl4aSA9IHJlcXVpcmUoJy4vdXRpbHMvbWFwQ2FudmFzQmxlbmRNb2Rlc1RvUGl4aScpO1xuXG52YXIgX21hcENhbnZhc0JsZW5kTW9kZXNUb1BpeGkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbWFwQ2FudmFzQmxlbmRNb2Rlc1RvUGl4aSk7XG5cbnZhciBfdXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscycpO1xuXG52YXIgX2NvbnN0ID0gcmVxdWlyZSgnLi4vLi4vY29uc3QnKTtcblxudmFyIF9zZXR0aW5ncyA9IHJlcXVpcmUoJy4uLy4uL3NldHRpbmdzJyk7XG5cbnZhciBfc2V0dGluZ3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc2V0dGluZ3MpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbi8qKlxuICogVGhlIENhbnZhc1JlbmRlcmVyIGRyYXdzIHRoZSBzY2VuZSBhbmQgYWxsIGl0cyBjb250ZW50IG9udG8gYSAyZCBjYW52YXMuIFRoaXMgcmVuZGVyZXIgc2hvdWxkXG4gKiBiZSB1c2VkIGZvciBicm93c2VycyB0aGF0IGRvIG5vdCBzdXBwb3J0IFdlYkdMLiBEb24ndCBmb3JnZXQgdG8gYWRkIHRoZSBDYW52YXNSZW5kZXJlci52aWV3IHRvXG4gKiB5b3VyIERPTSBvciB5b3Ugd2lsbCBub3Qgc2VlIGFueXRoaW5nIDopXG4gKlxuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgUElYSVxuICogQGV4dGVuZHMgUElYSS5TeXN0ZW1SZW5kZXJlclxuICovXG52YXIgQ2FudmFzUmVuZGVyZXIgPSBmdW5jdGlvbiAoX1N5c3RlbVJlbmRlcmVyKSB7XG4gICAgX2luaGVyaXRzKENhbnZhc1JlbmRlcmVyLCBfU3lzdGVtUmVuZGVyZXIpO1xuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHZhbGlkLWpzZG9jXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAtIFRoZSBvcHRpb25hbCByZW5kZXJlciBwYXJhbWV0ZXJzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLndpZHRoPTgwMF0gLSB0aGUgd2lkdGggb2YgdGhlIHNjcmVlblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5oZWlnaHQ9NjAwXSAtIHRoZSBoZWlnaHQgb2YgdGhlIHNjcmVlblxuICAgICAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IFtvcHRpb25zLnZpZXddIC0gdGhlIGNhbnZhcyB0byB1c2UgYXMgYSB2aWV3LCBvcHRpb25hbFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhbnNwYXJlbnQ9ZmFsc2VdIC0gSWYgdGhlIHJlbmRlciB2aWV3IGlzIHRyYW5zcGFyZW50LCBkZWZhdWx0IGZhbHNlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5hdXRvUmVzaXplPWZhbHNlXSAtIElmIHRoZSByZW5kZXIgdmlldyBpcyBhdXRvbWF0aWNhbGx5IHJlc2l6ZWQsIGRlZmF1bHQgZmFsc2VcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmFudGlhbGlhcz1mYWxzZV0gLSBzZXRzIGFudGlhbGlhcyAob25seSBhcHBsaWNhYmxlIGluIGNocm9tZSBhdCB0aGUgbW9tZW50KVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5yZXNvbHV0aW9uPTFdIC0gVGhlIHJlc29sdXRpb24gLyBkZXZpY2UgcGl4ZWwgcmF0aW8gb2YgdGhlIHJlbmRlcmVyLiBUaGVcbiAgICAgKiAgcmVzb2x1dGlvbiBvZiB0aGUgcmVuZGVyZXIgcmV0aW5hIHdvdWxkIGJlIDIuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5wcmVzZXJ2ZURyYXdpbmdCdWZmZXI9ZmFsc2VdIC0gZW5hYmxlcyBkcmF3aW5nIGJ1ZmZlciBwcmVzZXJ2YXRpb24sXG4gICAgICogIGVuYWJsZSB0aGlzIGlmIHlvdSBuZWVkIHRvIGNhbGwgdG9EYXRhVXJsIG9uIHRoZSB3ZWJnbCBjb250ZXh0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY2xlYXJCZWZvcmVSZW5kZXI9dHJ1ZV0gLSBUaGlzIHNldHMgaWYgdGhlIHJlbmRlcmVyIHdpbGwgY2xlYXIgdGhlIGNhbnZhcyBvclxuICAgICAqICAgICAgbm90IGJlZm9yZSB0aGUgbmV3IHJlbmRlciBwYXNzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3I9MHgwMDAwMDBdIC0gVGhlIGJhY2tncm91bmQgY29sb3Igb2YgdGhlIHJlbmRlcmVkIGFyZWFcbiAgICAgKiAgKHNob3duIGlmIG5vdCB0cmFuc3BhcmVudCkuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5yb3VuZFBpeGVscz1mYWxzZV0gLSBJZiB0cnVlIFBpeGlKUyB3aWxsIE1hdGguZmxvb3IoKSB4L3kgdmFsdWVzIHdoZW4gcmVuZGVyaW5nLFxuICAgICAqICBzdG9wcGluZyBwaXhlbCBpbnRlcnBvbGF0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIENhbnZhc1JlbmRlcmVyKG9wdGlvbnMsIGFyZzIsIGFyZzMpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENhbnZhc1JlbmRlcmVyKTtcblxuICAgICAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfU3lzdGVtUmVuZGVyZXIuY2FsbCh0aGlzLCAnQ2FudmFzJywgb3B0aW9ucywgYXJnMiwgYXJnMykpO1xuXG4gICAgICAgIF90aGlzLnR5cGUgPSBfY29uc3QuUkVOREVSRVJfVFlQRS5DQU5WQVM7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSByb290IGNhbnZhcyAyZCBjb250ZXh0IHRoYXQgZXZlcnl0aGluZyBpcyBkcmF3biB3aXRoLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9XG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5yb290Q29udGV4dCA9IF90aGlzLnZpZXcuZ2V0Q29udGV4dCgnMmQnLCB7IGFscGhhOiBfdGhpcy50cmFuc3BhcmVudCB9KTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGN1cnJlbnRseSBhY3RpdmUgY2FudmFzIDJkIGNvbnRleHQgKGNvdWxkIGNoYW5nZSB3aXRoIHJlbmRlclRleHR1cmVzKVxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9XG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5jb250ZXh0ID0gX3RoaXMucm9vdENvbnRleHQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJvb2xlYW4gZmxhZyBjb250cm9sbGluZyBjYW52YXMgcmVmcmVzaC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLnJlZnJlc2ggPSB0cnVlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnN0YW5jZSBvZiBhIENhbnZhc01hc2tNYW5hZ2VyLCBoYW5kbGVzIG1hc2tpbmcgd2hlbiB1c2luZyB0aGUgY2FudmFzIHJlbmRlcmVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLkNhbnZhc01hc2tNYW5hZ2VyfVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMubWFza01hbmFnZXIgPSBuZXcgX0NhbnZhc01hc2tNYW5hZ2VyMi5kZWZhdWx0KF90aGlzKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNhbnZhcyBwcm9wZXJ0eSB1c2VkIHRvIHNldCB0aGUgY2FudmFzIHNtb290aGluZyBwcm9wZXJ0eS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuc21vb3RoUHJvcGVydHkgPSAnaW1hZ2VTbW9vdGhpbmdFbmFibGVkJztcblxuICAgICAgICBpZiAoIV90aGlzLnJvb3RDb250ZXh0LmltYWdlU21vb3RoaW5nRW5hYmxlZCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLnJvb3RDb250ZXh0LndlYmtpdEltYWdlU21vb3RoaW5nRW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnNtb290aFByb3BlcnR5ID0gJ3dlYmtpdEltYWdlU21vb3RoaW5nRW5hYmxlZCc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKF90aGlzLnJvb3RDb250ZXh0Lm1vekltYWdlU21vb3RoaW5nRW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnNtb290aFByb3BlcnR5ID0gJ21vekltYWdlU21vb3RoaW5nRW5hYmxlZCc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKF90aGlzLnJvb3RDb250ZXh0Lm9JbWFnZVNtb290aGluZ0VuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zbW9vdGhQcm9wZXJ0eSA9ICdvSW1hZ2VTbW9vdGhpbmdFbmFibGVkJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoX3RoaXMucm9vdENvbnRleHQubXNJbWFnZVNtb290aGluZ0VuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zbW9vdGhQcm9wZXJ0eSA9ICdtc0ltYWdlU21vb3RoaW5nRW5hYmxlZCc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpcy5pbml0UGx1Z2lucygpO1xuXG4gICAgICAgIF90aGlzLmJsZW5kTW9kZXMgPSAoMCwgX21hcENhbnZhc0JsZW5kTW9kZXNUb1BpeGkyLmRlZmF1bHQpKCk7XG4gICAgICAgIF90aGlzLl9hY3RpdmVCbGVuZE1vZGUgPSBudWxsO1xuXG4gICAgICAgIF90aGlzLnJlbmRlcmluZ1RvU2NyZWVuID0gZmFsc2U7XG5cbiAgICAgICAgX3RoaXMucmVzaXplKF90aGlzLm9wdGlvbnMud2lkdGgsIF90aGlzLm9wdGlvbnMuaGVpZ2h0KTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZWQgYWZ0ZXIgcmVuZGVyaW5nIGZpbmlzaGVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXZlbnQgUElYSS5DYW52YXNSZW5kZXJlciNwb3N0cmVuZGVyXG4gICAgICAgICAqL1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlZCBiZWZvcmUgcmVuZGVyaW5nIHN0YXJ0cy5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV2ZW50IFBJWEkuQ2FudmFzUmVuZGVyZXIjcHJlcmVuZGVyXG4gICAgICAgICAqL1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0aGUgb2JqZWN0IHRvIHRoaXMgY2FudmFzIHZpZXdcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5EaXNwbGF5T2JqZWN0fSBkaXNwbGF5T2JqZWN0IC0gVGhlIG9iamVjdCB0byBiZSByZW5kZXJlZFxuICAgICAqIEBwYXJhbSB7UElYSS5SZW5kZXJUZXh0dXJlfSBbcmVuZGVyVGV4dHVyZV0gLSBBIHJlbmRlciB0ZXh0dXJlIHRvIGJlIHJlbmRlcmVkIHRvLlxuICAgICAqICBJZiB1bnNldCwgaXQgd2lsbCByZW5kZXIgdG8gdGhlIHJvb3QgY29udGV4dC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtjbGVhcj1mYWxzZV0gLSBXaGV0aGVyIHRvIGNsZWFyIHRoZSBjYW52YXMgYmVmb3JlIGRyYXdpbmdcbiAgICAgKiBAcGFyYW0ge1BJWEkuTWF0cml4fSBbdHJhbnNmb3JtXSAtIEEgdHJhbnNmb3JtYXRpb24gdG8gYmUgYXBwbGllZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NraXBVcGRhdGVUcmFuc2Zvcm09ZmFsc2VdIC0gV2hldGhlciB0byBza2lwIHRoZSB1cGRhdGUgdHJhbnNmb3JtXG4gICAgICovXG5cblxuICAgIENhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoZGlzcGxheU9iamVjdCwgcmVuZGVyVGV4dHVyZSwgY2xlYXIsIHRyYW5zZm9ybSwgc2tpcFVwZGF0ZVRyYW5zZm9ybSkge1xuICAgICAgICBpZiAoIXRoaXMudmlldykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2FuIGJlIGhhbmR5IHRvIGtub3chXG4gICAgICAgIHRoaXMucmVuZGVyaW5nVG9TY3JlZW4gPSAhcmVuZGVyVGV4dHVyZTtcblxuICAgICAgICB0aGlzLmVtaXQoJ3ByZXJlbmRlcicpO1xuXG4gICAgICAgIHZhciByb290UmVzb2x1dGlvbiA9IHRoaXMucmVzb2x1dGlvbjtcblxuICAgICAgICBpZiAocmVuZGVyVGV4dHVyZSkge1xuICAgICAgICAgICAgcmVuZGVyVGV4dHVyZSA9IHJlbmRlclRleHR1cmUuYmFzZVRleHR1cmUgfHwgcmVuZGVyVGV4dHVyZTtcblxuICAgICAgICAgICAgaWYgKCFyZW5kZXJUZXh0dXJlLl9jYW52YXNSZW5kZXJUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICByZW5kZXJUZXh0dXJlLl9jYW52YXNSZW5kZXJUYXJnZXQgPSBuZXcgX0NhbnZhc1JlbmRlclRhcmdldDIuZGVmYXVsdChyZW5kZXJUZXh0dXJlLndpZHRoLCByZW5kZXJUZXh0dXJlLmhlaWdodCwgcmVuZGVyVGV4dHVyZS5yZXNvbHV0aW9uKTtcbiAgICAgICAgICAgICAgICByZW5kZXJUZXh0dXJlLnNvdXJjZSA9IHJlbmRlclRleHR1cmUuX2NhbnZhc1JlbmRlclRhcmdldC5jYW52YXM7XG4gICAgICAgICAgICAgICAgcmVuZGVyVGV4dHVyZS52YWxpZCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuY29udGV4dCA9IHJlbmRlclRleHR1cmUuX2NhbnZhc1JlbmRlclRhcmdldC5jb250ZXh0O1xuICAgICAgICAgICAgdGhpcy5yZXNvbHV0aW9uID0gcmVuZGVyVGV4dHVyZS5fY2FudmFzUmVuZGVyVGFyZ2V0LnJlc29sdXRpb247XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQgPSB0aGlzLnJvb3RDb250ZXh0O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG5cbiAgICAgICAgaWYgKCFyZW5kZXJUZXh0dXJlKSB7XG4gICAgICAgICAgICB0aGlzLl9sYXN0T2JqZWN0UmVuZGVyZWQgPSBkaXNwbGF5T2JqZWN0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFza2lwVXBkYXRlVHJhbnNmb3JtKSB7XG4gICAgICAgICAgICAvLyB1cGRhdGUgdGhlIHNjZW5lIGdyYXBoXG4gICAgICAgICAgICB2YXIgY2FjaGVQYXJlbnQgPSBkaXNwbGF5T2JqZWN0LnBhcmVudDtcbiAgICAgICAgICAgIHZhciB0ZW1wV3QgPSB0aGlzLl90ZW1wRGlzcGxheU9iamVjdFBhcmVudC50cmFuc2Zvcm0ud29ybGRUcmFuc2Zvcm07XG5cbiAgICAgICAgICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm0uY29weSh0ZW1wV3QpO1xuXG4gICAgICAgICAgICAgICAgLy8gbGV0cyBub3QgZm9yZ2V0IHRvIGZsYWcgdGhlIHBhcmVudCB0cmFuc2Zvcm0gYXMgZGlydHkuLi5cbiAgICAgICAgICAgICAgICB0aGlzLl90ZW1wRGlzcGxheU9iamVjdFBhcmVudC50cmFuc2Zvcm0uX3dvcmxkSUQgPSAtMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGVtcFd0LmlkZW50aXR5KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRpc3BsYXlPYmplY3QucGFyZW50ID0gdGhpcy5fdGVtcERpc3BsYXlPYmplY3RQYXJlbnQ7XG5cbiAgICAgICAgICAgIGRpc3BsYXlPYmplY3QudXBkYXRlVHJhbnNmb3JtKCk7XG4gICAgICAgICAgICBkaXNwbGF5T2JqZWN0LnBhcmVudCA9IGNhY2hlUGFyZW50O1xuICAgICAgICAgICAgLy8gZGlzcGxheU9iamVjdC5oaXRBcmVhID0gLy9UT0RPIGFkZCBhIHRlbXAgaGl0IGFyZWFcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgICBjb250ZXh0LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IDE7XG4gICAgICAgIHRoaXMuX2FjdGl2ZUJsZW5kTW9kZSA9IF9jb25zdC5CTEVORF9NT0RFUy5OT1JNQUw7XG4gICAgICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gdGhpcy5ibGVuZE1vZGVzW19jb25zdC5CTEVORF9NT0RFUy5OT1JNQUxdO1xuXG4gICAgICAgIGlmIChuYXZpZ2F0b3IuaXNDb2Nvb25KUyAmJiB0aGlzLnZpZXcuc2NyZWVuY2FudmFzKSB7XG4gICAgICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9ICdibGFjayc7XG4gICAgICAgICAgICBjb250ZXh0LmNsZWFyKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2xlYXIgIT09IHVuZGVmaW5lZCA/IGNsZWFyIDogdGhpcy5jbGVhckJlZm9yZVJlbmRlcikge1xuICAgICAgICAgICAgaWYgKHRoaXMucmVuZGVyaW5nVG9TY3JlZW4pIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50cmFuc3BhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSB0aGlzLl9iYWNrZ3JvdW5kQ29sb3JTdHJpbmc7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZmlsbFJlY3QoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gLy8gZWxzZSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBpbXBsZW1lbnQgYmFja2dyb3VuZCBmb3IgQ2FudmFzUmVuZGVyVGFyZ2V0IG9yIFJlbmRlclRleHR1cmU/XG4gICAgICAgICAgICAvLyB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUT0RPIFJFTkRFUiBUQVJHRVQgU1RVRkYgSEVSRS4uXG4gICAgICAgIHZhciB0ZW1wQ29udGV4dCA9IHRoaXMuY29udGV4dDtcblxuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICBkaXNwbGF5T2JqZWN0LnJlbmRlckNhbnZhcyh0aGlzKTtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gdGVtcENvbnRleHQ7XG5cbiAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG5cbiAgICAgICAgdGhpcy5yZXNvbHV0aW9uID0gcm9vdFJlc29sdXRpb247XG5cbiAgICAgICAgdGhpcy5lbWl0KCdwb3N0cmVuZGVyJyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENsZWFyIHRoZSBjYW52YXMgb2YgcmVuZGVyZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NsZWFyQ29sb3JdIC0gQ2xlYXIgdGhlIGNhbnZhcyB3aXRoIHRoaXMgY29sb3IsIGV4Y2VwdCB0aGUgY2FudmFzIGlzIHRyYW5zcGFyZW50LlxuICAgICAqL1xuXG5cbiAgICBDYW52YXNSZW5kZXJlci5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhcihjbGVhckNvbG9yKSB7XG4gICAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuXG4gICAgICAgIGNsZWFyQ29sb3IgPSBjbGVhckNvbG9yIHx8IHRoaXMuX2JhY2tncm91bmRDb2xvclN0cmluZztcblxuICAgICAgICBpZiAoIXRoaXMudHJhbnNwYXJlbnQgJiYgY2xlYXJDb2xvcikge1xuICAgICAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBjbGVhckNvbG9yO1xuICAgICAgICAgICAgY29udGV4dC5maWxsUmVjdCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYmxlbmQgbW9kZSBvZiB0aGUgcmVuZGVyZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYmxlbmRNb2RlIC0gU2VlIHtAbGluayBQSVhJLkJMRU5EX01PREVTfSBmb3IgdmFsaWQgdmFsdWVzLlxuICAgICAqL1xuXG5cbiAgICBDYW52YXNSZW5kZXJlci5wcm90b3R5cGUuc2V0QmxlbmRNb2RlID0gZnVuY3Rpb24gc2V0QmxlbmRNb2RlKGJsZW5kTW9kZSkge1xuICAgICAgICBpZiAodGhpcy5fYWN0aXZlQmxlbmRNb2RlID09PSBibGVuZE1vZGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2FjdGl2ZUJsZW5kTW9kZSA9IGJsZW5kTW9kZTtcbiAgICAgICAgdGhpcy5jb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IHRoaXMuYmxlbmRNb2Rlc1tibGVuZE1vZGVdO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGV2ZXJ5dGhpbmcgZnJvbSB0aGUgcmVuZGVyZXIgYW5kIG9wdGlvbmFsbHkgcmVtb3ZlcyB0aGUgQ2FudmFzIERPTSBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcmVtb3ZlVmlldz1mYWxzZV0gLSBSZW1vdmVzIHRoZSBDYW52YXMgZWxlbWVudCBmcm9tIHRoZSBET00uXG4gICAgICovXG5cblxuICAgIENhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveShyZW1vdmVWaWV3KSB7XG4gICAgICAgIHRoaXMuZGVzdHJveVBsdWdpbnMoKTtcblxuICAgICAgICAvLyBjYWxsIHRoZSBiYXNlIGRlc3Ryb3lcbiAgICAgICAgX1N5c3RlbVJlbmRlcmVyLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcywgcmVtb3ZlVmlldyk7XG5cbiAgICAgICAgdGhpcy5jb250ZXh0ID0gbnVsbDtcblxuICAgICAgICB0aGlzLnJlZnJlc2ggPSB0cnVlO1xuXG4gICAgICAgIHRoaXMubWFza01hbmFnZXIuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLm1hc2tNYW5hZ2VyID0gbnVsbDtcblxuICAgICAgICB0aGlzLnNtb290aFByb3BlcnR5ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVzaXplcyB0aGUgY2FudmFzIHZpZXcgdG8gdGhlIHNwZWNpZmllZCB3aWR0aCBhbmQgaGVpZ2h0LlxuICAgICAqXG4gICAgICogQGV4dGVuZHMgUElYSS5TeXN0ZW1SZW5kZXJlciNyZXNpemVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzY3JlZW5XaWR0aCAtIHRoZSBuZXcgd2lkdGggb2YgdGhlIHNjcmVlblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzY3JlZW5IZWlnaHQgLSB0aGUgbmV3IGhlaWdodCBvZiB0aGUgc2NyZWVuXG4gICAgICovXG5cblxuICAgIENhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbiByZXNpemUoc2NyZWVuV2lkdGgsIHNjcmVlbkhlaWdodCkge1xuICAgICAgICBfU3lzdGVtUmVuZGVyZXIucHJvdG90eXBlLnJlc2l6ZS5jYWxsKHRoaXMsIHNjcmVlbldpZHRoLCBzY3JlZW5IZWlnaHQpO1xuXG4gICAgICAgIC8vIHJlc2V0IHRoZSBzY2FsZSBtb2RlLi4gb2RkbHkgdGhpcyBzZWVtcyB0byBiZSByZXNldCB3aGVuIHRoZSBjYW52YXMgaXMgcmVzaXplZC5cbiAgICAgICAgLy8gc3VyZWx5IGEgYnJvd3NlciBidWc/PyBMZXQgUGl4aUpTIGZpeCB0aGF0IGZvciB5b3UuLlxuICAgICAgICBpZiAodGhpcy5zbW9vdGhQcm9wZXJ0eSkge1xuICAgICAgICAgICAgdGhpcy5yb290Q29udGV4dFt0aGlzLnNtb290aFByb3BlcnR5XSA9IF9zZXR0aW5nczIuZGVmYXVsdC5TQ0FMRV9NT0RFID09PSBfY29uc3QuU0NBTEVfTU9ERVMuTElORUFSO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBibGVuZCBtb2RlIGhhcyBjaGFuZ2VkLlxuICAgICAqL1xuXG5cbiAgICBDYW52YXNSZW5kZXJlci5wcm90b3R5cGUuaW52YWxpZGF0ZUJsZW5kTW9kZSA9IGZ1bmN0aW9uIGludmFsaWRhdGVCbGVuZE1vZGUoKSB7XG4gICAgICAgIHRoaXMuX2FjdGl2ZUJsZW5kTW9kZSA9IHRoaXMuYmxlbmRNb2Rlcy5pbmRleE9mKHRoaXMuY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24pO1xuICAgIH07XG5cbiAgICByZXR1cm4gQ2FudmFzUmVuZGVyZXI7XG59KF9TeXN0ZW1SZW5kZXJlcjMuZGVmYXVsdCk7XG5cbi8qKlxuICogQ29sbGVjdGlvbiBvZiBpbnN0YWxsZWQgcGx1Z2lucy4gVGhlc2UgYXJlIGluY2x1ZGVkIGJ5IGRlZmF1bHQgaW4gUElYSSwgYnV0IGNhbiBiZSBleGNsdWRlZFxuICogYnkgY3JlYXRpbmcgYSBjdXN0b20gYnVpbGQuIENvbnN1bHQgdGhlIFJFQURNRSBmb3IgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCBjcmVhdGluZyBjdXN0b21cbiAqIGJ1aWxkcyBhbmQgZXhjbHVkaW5nIHBsdWdpbnMuXG4gKiBAbmFtZSBQSVhJLkNhbnZhc1JlbmRlcmVyI3BsdWdpbnNcbiAqIEB0eXBlIHtvYmplY3R9XG4gKiBAcmVhZG9ubHlcbiAqIEBwcm9wZXJ0eSB7UElYSS5hY2Nlc3NpYmlsaXR5LkFjY2Vzc2liaWxpdHlNYW5hZ2VyfSBhY2Nlc3NpYmlsaXR5IFN1cHBvcnQgdGFiYmluZyBpbnRlcmFjdGl2ZSBlbGVtZW50cy5cbiAqIEBwcm9wZXJ0eSB7UElYSS5leHRyYWN0LkNhbnZhc0V4dHJhY3R9IGV4dHJhY3QgRXh0cmFjdCBpbWFnZSBkYXRhIGZyb20gcmVuZGVyZXIuXG4gKiBAcHJvcGVydHkge1BJWEkuaW50ZXJhY3Rpb24uSW50ZXJhY3Rpb25NYW5hZ2VyfSBpbnRlcmFjdGlvbiBIYW5kbGVzIG1vdXNlLCB0b3VjaCBhbmQgcG9pbnRlciBldmVudHMuXG4gKiBAcHJvcGVydHkge1BJWEkucHJlcGFyZS5DYW52YXNQcmVwYXJlfSBwcmVwYXJlIFByZS1yZW5kZXIgZGlzcGxheSBvYmplY3RzLlxuICovXG5cbi8qKlxuICogQWRkcyBhIHBsdWdpbiB0byB0aGUgcmVuZGVyZXIuXG4gKlxuICogQG1ldGhvZCBQSVhJLkNhbnZhc1JlbmRlcmVyI3JlZ2lzdGVyUGx1Z2luXG4gKiBAcGFyYW0ge3N0cmluZ30gcGx1Z2luTmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBwbHVnaW4uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdG9yIC0gVGhlIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIG9yIGNsYXNzIGZvciB0aGUgcGx1Z2luLlxuICovXG5cbmV4cG9ydHMuZGVmYXVsdCA9IENhbnZhc1JlbmRlcmVyO1xuX3V0aWxzLnBsdWdpblRhcmdldC5taXhpbihDYW52YXNSZW5kZXJlcik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DYW52YXNSZW5kZXJlci5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfY29uc3QgPSByZXF1aXJlKCcuLi8uLi8uLi9jb25zdCcpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vKipcbiAqIEEgc2V0IG9mIGZ1bmN0aW9ucyB1c2VkIHRvIGhhbmRsZSBtYXNraW5nLlxuICpcbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIFBJWElcbiAqL1xudmFyIENhbnZhc01hc2tNYW5hZ2VyID0gZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7UElYSS5DYW52YXNSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgY2FudmFzIHJlbmRlcmVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIENhbnZhc01hc2tNYW5hZ2VyKHJlbmRlcmVyKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDYW52YXNNYXNrTWFuYWdlcik7XG5cbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGFkZHMgaXQgdG8gdGhlIGN1cnJlbnQgc3RhY2sgb2YgbWFza3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gbWFza0RhdGEgLSB0aGUgbWFza0RhdGEgdGhhdCB3aWxsIGJlIHB1c2hlZFxuICAgICAqL1xuXG5cbiAgICBDYW52YXNNYXNrTWFuYWdlci5wcm90b3R5cGUucHVzaE1hc2sgPSBmdW5jdGlvbiBwdXNoTWFzayhtYXNrRGF0YSkge1xuICAgICAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyO1xuXG4gICAgICAgIHJlbmRlcmVyLmNvbnRleHQuc2F2ZSgpO1xuXG4gICAgICAgIHZhciBjYWNoZUFscGhhID0gbWFza0RhdGEuYWxwaGE7XG4gICAgICAgIHZhciB0cmFuc2Zvcm0gPSBtYXNrRGF0YS50cmFuc2Zvcm0ud29ybGRUcmFuc2Zvcm07XG4gICAgICAgIHZhciByZXNvbHV0aW9uID0gcmVuZGVyZXIucmVzb2x1dGlvbjtcblxuICAgICAgICByZW5kZXJlci5jb250ZXh0LnNldFRyYW5zZm9ybSh0cmFuc2Zvcm0uYSAqIHJlc29sdXRpb24sIHRyYW5zZm9ybS5iICogcmVzb2x1dGlvbiwgdHJhbnNmb3JtLmMgKiByZXNvbHV0aW9uLCB0cmFuc2Zvcm0uZCAqIHJlc29sdXRpb24sIHRyYW5zZm9ybS50eCAqIHJlc29sdXRpb24sIHRyYW5zZm9ybS50eSAqIHJlc29sdXRpb24pO1xuXG4gICAgICAgIC8vIFRPRE8gc3Vwb3J0IHNwcml0ZSBhbHBoYSBtYXNrcz8/XG4gICAgICAgIC8vIGxvdHMgb2YgZWZmb3J0IHJlcXVpcmVkLiBJZiBkZW1hbmQgaXMgZ3JlYXQgZW5vdWdoLi5cbiAgICAgICAgaWYgKCFtYXNrRGF0YS5fdGV4dHVyZSkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJHcmFwaGljc1NoYXBlKG1hc2tEYXRhKTtcbiAgICAgICAgICAgIHJlbmRlcmVyLmNvbnRleHQuY2xpcCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgbWFza0RhdGEud29ybGRBbHBoYSA9IGNhY2hlQWxwaGE7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgYSBQSVhJLkdyYXBoaWNzIHNoYXBlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLkdyYXBoaWNzfSBncmFwaGljcyAtIFRoZSBvYmplY3QgdG8gcmVuZGVyLlxuICAgICAqL1xuXG5cbiAgICBDYW52YXNNYXNrTWFuYWdlci5wcm90b3R5cGUucmVuZGVyR3JhcGhpY3NTaGFwZSA9IGZ1bmN0aW9uIHJlbmRlckdyYXBoaWNzU2hhcGUoZ3JhcGhpY3MpIHtcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLnJlbmRlcmVyLmNvbnRleHQ7XG4gICAgICAgIHZhciBsZW4gPSBncmFwaGljcy5ncmFwaGljc0RhdGEubGVuZ3RoO1xuXG4gICAgICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBncmFwaGljcy5ncmFwaGljc0RhdGFbaV07XG4gICAgICAgICAgICB2YXIgc2hhcGUgPSBkYXRhLnNoYXBlO1xuXG4gICAgICAgICAgICBpZiAoZGF0YS50eXBlID09PSBfY29uc3QuU0hBUEVTLlBPTFkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcG9pbnRzID0gc2hhcGUucG9pbnRzO1xuICAgICAgICAgICAgICAgIHZhciBob2xlcyA9IGRhdGEuaG9sZXM7XG4gICAgICAgICAgICAgICAgdmFyIG91dGVyQXJlYSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICB2YXIgaW5uZXJBcmVhID0gdm9pZCAwO1xuXG4gICAgICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8ocG9pbnRzWzBdLCBwb2ludHNbMV0pO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDI7IGogPCBwb2ludHMubGVuZ3RoOyBqICs9IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8ocG9pbnRzW2pdLCBwb2ludHNbaiArIDFdKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgZmlyc3QgYW5kIGxhc3QgcG9pbnQgYXJlIHRoZSBzYW1lIGNsb3NlIHRoZSBwYXRoIC0gbXVjaCBuZWF0ZXIgOilcbiAgICAgICAgICAgICAgICBpZiAocG9pbnRzWzBdID09PSBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDJdICYmIHBvaW50c1sxXSA9PT0gcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXSkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChob2xlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dGVyQXJlYSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9qID0gMDsgX2ogPCBwb2ludHMubGVuZ3RoOyBfaiArPSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRlckFyZWEgKz0gcG9pbnRzW19qXSAqIHBvaW50c1tfaiArIDNdIC0gcG9pbnRzW19qICsgMV0gKiBwb2ludHNbX2ogKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgaG9sZXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cyA9IGhvbGVzW2tdLnBvaW50cztcblxuICAgICAgICAgICAgICAgICAgICAgICAgaW5uZXJBcmVhID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9qMiA9IDA7IF9qMiA8IHBvaW50cy5sZW5ndGg7IF9qMiArPSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5uZXJBcmVhICs9IHBvaW50c1tfajJdICogcG9pbnRzW19qMiArIDNdIC0gcG9pbnRzW19qMiArIDFdICogcG9pbnRzW19qMiArIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyhwb2ludHNbMF0sIHBvaW50c1sxXSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbm5lckFyZWEgKiBvdXRlckFyZWEgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2ozID0gMjsgX2ozIDwgcG9pbnRzLmxlbmd0aDsgX2ozICs9IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8ocG9pbnRzW19qM10sIHBvaW50c1tfajMgKyAxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfajQgPSBwb2ludHMubGVuZ3RoIC0gMjsgX2o0ID49IDI7IF9qNCAtPSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHBvaW50c1tfajRdLCBwb2ludHNbX2o0ICsgMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGF0YS50eXBlID09PSBfY29uc3QuU0hBUEVTLlJFQ1QpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnJlY3Qoc2hhcGUueCwgc2hhcGUueSwgc2hhcGUud2lkdGgsIHNoYXBlLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGF0YS50eXBlID09PSBfY29uc3QuU0hBUEVTLkNJUkMpIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPIC0gbmVlZCB0byBiZSBVbmRlZmluZWQhXG4gICAgICAgICAgICAgICAgY29udGV4dC5hcmMoc2hhcGUueCwgc2hhcGUueSwgc2hhcGUucmFkaXVzLCAwLCAyICogTWF0aC5QSSk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGF0YS50eXBlID09PSBfY29uc3QuU0hBUEVTLkVMSVApIHtcbiAgICAgICAgICAgICAgICAvLyBlbGxpcHNlIGNvZGUgdGFrZW4gZnJvbTogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yMTcyNzk4L2hvdy10by1kcmF3LWFuLW92YWwtaW4taHRtbDUtY2FudmFzXG5cbiAgICAgICAgICAgICAgICB2YXIgdyA9IHNoYXBlLndpZHRoICogMjtcbiAgICAgICAgICAgICAgICB2YXIgaCA9IHNoYXBlLmhlaWdodCAqIDI7XG5cbiAgICAgICAgICAgICAgICB2YXIgeCA9IHNoYXBlLnggLSB3IC8gMjtcbiAgICAgICAgICAgICAgICB2YXIgeSA9IHNoYXBlLnkgLSBoIC8gMjtcblxuICAgICAgICAgICAgICAgIHZhciBrYXBwYSA9IDAuNTUyMjg0ODtcbiAgICAgICAgICAgICAgICB2YXIgb3ggPSB3IC8gMiAqIGthcHBhOyAvLyBjb250cm9sIHBvaW50IG9mZnNldCBob3Jpem9udGFsXG4gICAgICAgICAgICAgICAgdmFyIG95ID0gaCAvIDIgKiBrYXBwYTsgLy8gY29udHJvbCBwb2ludCBvZmZzZXQgdmVydGljYWxcbiAgICAgICAgICAgICAgICB2YXIgeGUgPSB4ICsgdzsgLy8geC1lbmRcbiAgICAgICAgICAgICAgICB2YXIgeWUgPSB5ICsgaDsgLy8geS1lbmRcbiAgICAgICAgICAgICAgICB2YXIgeG0gPSB4ICsgdyAvIDI7IC8vIHgtbWlkZGxlXG4gICAgICAgICAgICAgICAgdmFyIHltID0geSArIGggLyAyOyAvLyB5LW1pZGRsZVxuXG4gICAgICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8oeCwgeW0pO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuYmV6aWVyQ3VydmVUbyh4LCB5bSAtIG95LCB4bSAtIG94LCB5LCB4bSwgeSk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5iZXppZXJDdXJ2ZVRvKHhtICsgb3gsIHksIHhlLCB5bSAtIG95LCB4ZSwgeW0pO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuYmV6aWVyQ3VydmVUbyh4ZSwgeW0gKyBveSwgeG0gKyBveCwgeWUsIHhtLCB5ZSk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5iZXppZXJDdXJ2ZVRvKHhtIC0gb3gsIHllLCB4LCB5bSArIG95LCB4LCB5bSk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGF0YS50eXBlID09PSBfY29uc3QuU0hBUEVTLlJSRUMpIHtcbiAgICAgICAgICAgICAgICB2YXIgcnggPSBzaGFwZS54O1xuICAgICAgICAgICAgICAgIHZhciByeSA9IHNoYXBlLnk7XG4gICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gc2hhcGUud2lkdGg7XG4gICAgICAgICAgICAgICAgdmFyIGhlaWdodCA9IHNoYXBlLmhlaWdodDtcbiAgICAgICAgICAgICAgICB2YXIgcmFkaXVzID0gc2hhcGUucmFkaXVzO1xuXG4gICAgICAgICAgICAgICAgdmFyIG1heFJhZGl1cyA9IE1hdGgubWluKHdpZHRoLCBoZWlnaHQpIC8gMiB8IDA7XG5cbiAgICAgICAgICAgICAgICByYWRpdXMgPSByYWRpdXMgPiBtYXhSYWRpdXMgPyBtYXhSYWRpdXMgOiByYWRpdXM7XG5cbiAgICAgICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyhyeCwgcnkgKyByYWRpdXMpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHJ4LCByeSArIGhlaWdodCAtIHJhZGl1cyk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKHJ4LCByeSArIGhlaWdodCwgcnggKyByYWRpdXMsIHJ5ICsgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhyeCArIHdpZHRoIC0gcmFkaXVzLCByeSArIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKHJ4ICsgd2lkdGgsIHJ5ICsgaGVpZ2h0LCByeCArIHdpZHRoLCByeSArIGhlaWdodCAtIHJhZGl1cyk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8ocnggKyB3aWR0aCwgcnkgKyByYWRpdXMpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQucXVhZHJhdGljQ3VydmVUbyhyeCArIHdpZHRoLCByeSwgcnggKyB3aWR0aCAtIHJhZGl1cywgcnkpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHJ4ICsgcmFkaXVzLCByeSk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKHJ4LCByeSwgcngsIHJ5ICsgcmFkaXVzKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlc3RvcmVzIHRoZSBjdXJyZW50IGRyYXdpbmcgY29udGV4dCB0byB0aGUgc3RhdGUgaXQgd2FzIGJlZm9yZSB0aGUgbWFzayB3YXMgYXBwbGllZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5DYW52YXNSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIgY29udGV4dCB0byB1c2UuXG4gICAgICovXG5cblxuICAgIENhbnZhc01hc2tNYW5hZ2VyLnByb3RvdHlwZS5wb3BNYXNrID0gZnVuY3Rpb24gcG9wTWFzayhyZW5kZXJlcikge1xuICAgICAgICByZW5kZXJlci5jb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgICAgcmVuZGVyZXIuaW52YWxpZGF0ZUJsZW5kTW9kZSgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyB0aGlzIGNhbnZhcyBtYXNrIG1hbmFnZXIuXG4gICAgICpcbiAgICAgKi9cblxuXG4gICAgQ2FudmFzTWFza01hbmFnZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICAvKiBlbXB0eSAqL1xuICAgIH07XG5cbiAgICByZXR1cm4gQ2FudmFzTWFza01hbmFnZXI7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IENhbnZhc01hc2tNYW5hZ2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2FudmFzTWFza01hbmFnZXIuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX3NldHRpbmdzID0gcmVxdWlyZSgnLi4vLi4vLi4vc2V0dGluZ3MnKTtcblxudmFyIF9zZXR0aW5nczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zZXR0aW5ncyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8qKlxuICogQ3JlYXRlcyBhIENhbnZhcyBlbGVtZW50IG9mIHRoZSBnaXZlbiBzaXplLlxuICpcbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIFBJWElcbiAqL1xudmFyIENhbnZhc1JlbmRlclRhcmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAtIHRoZSB3aWR0aCBmb3IgdGhlIG5ld2x5IGNyZWF0ZWQgY2FudmFzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgLSB0aGUgaGVpZ2h0IGZvciB0aGUgbmV3bHkgY3JlYXRlZCBjYW52YXNcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtyZXNvbHV0aW9uPTFdIC0gVGhlIHJlc29sdXRpb24gLyBkZXZpY2UgcGl4ZWwgcmF0aW8gb2YgdGhlIGNhbnZhc1xuICAgKi9cbiAgZnVuY3Rpb24gQ2FudmFzUmVuZGVyVGFyZ2V0KHdpZHRoLCBoZWlnaHQsIHJlc29sdXRpb24pIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2FudmFzUmVuZGVyVGFyZ2V0KTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBDYW52YXMgb2JqZWN0IHRoYXQgYmVsb25ncyB0byB0aGlzIENhbnZhc1JlbmRlclRhcmdldC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge0hUTUxDYW52YXNFbGVtZW50fVxuICAgICAqL1xuICAgIHRoaXMuY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG5cbiAgICAvKipcbiAgICAgKiBBIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCBvYmplY3QgcmVwcmVzZW50aW5nIGEgdHdvLWRpbWVuc2lvbmFsIHJlbmRlcmluZyBjb250ZXh0LlxuICAgICAqXG4gICAgICogQG1lbWJlciB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfVxuICAgICAqL1xuICAgIHRoaXMuY29udGV4dCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICB0aGlzLnJlc29sdXRpb24gPSByZXNvbHV0aW9uIHx8IF9zZXR0aW5nczIuZGVmYXVsdC5SRVNPTFVUSU9OO1xuXG4gICAgdGhpcy5yZXNpemUod2lkdGgsIGhlaWdodCk7XG4gIH1cblxuICAvKipcbiAgICogQ2xlYXJzIHRoZSBjYW52YXMgdGhhdCB3YXMgY3JlYXRlZCBieSB0aGUgQ2FudmFzUmVuZGVyVGFyZ2V0IGNsYXNzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIENhbnZhc1JlbmRlclRhcmdldC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICB0aGlzLmNvbnRleHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgIHRoaXMuY29udGV4dC5jbGVhclJlY3QoMCwgMCwgdGhpcy5jYW52YXMud2lkdGgsIHRoaXMuY2FudmFzLmhlaWdodCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlc2l6ZXMgdGhlIGNhbnZhcyB0byB0aGUgc3BlY2lmaWVkIHdpZHRoIGFuZCBoZWlnaHQuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAtIHRoZSBuZXcgd2lkdGggb2YgdGhlIGNhbnZhc1xuICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IC0gdGhlIG5ldyBoZWlnaHQgb2YgdGhlIGNhbnZhc1xuICAgKi9cblxuXG4gIENhbnZhc1JlbmRlclRhcmdldC5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24gcmVzaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICB0aGlzLmNhbnZhcy53aWR0aCA9IHdpZHRoICogdGhpcy5yZXNvbHV0aW9uO1xuICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IGhlaWdodCAqIHRoaXMucmVzb2x1dGlvbjtcbiAgfTtcblxuICAvKipcbiAgICogRGVzdHJveXMgdGhpcyBjYW52YXMuXG4gICAqXG4gICAqL1xuXG5cbiAgQ2FudmFzUmVuZGVyVGFyZ2V0LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICB0aGlzLmNvbnRleHQgPSBudWxsO1xuICAgIHRoaXMuY2FudmFzID0gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogVGhlIHdpZHRoIG9mIHRoZSBjYW52YXMgYnVmZmVyIGluIHBpeGVscy5cbiAgICpcbiAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhDYW52YXNSZW5kZXJUYXJnZXQsIFt7XG4gICAga2V5OiAnd2lkdGgnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2FudmFzLndpZHRoO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlcXVpcmUtanNkb2NcbiAgICB7XG4gICAgICB0aGlzLmNhbnZhcy53aWR0aCA9IHZhbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaGVpZ2h0IG9mIHRoZSBjYW52YXMgYnVmZmVyIGluIHBpeGVscy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnaGVpZ2h0JyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNhbnZhcy5oZWlnaHQ7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWwpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcmVxdWlyZS1qc2RvY1xuICAgIHtcbiAgICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IHZhbDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ2FudmFzUmVuZGVyVGFyZ2V0O1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBDYW52YXNSZW5kZXJUYXJnZXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DYW52YXNSZW5kZXJUYXJnZXQuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5kZWZhdWx0ID0gY2FuVXNlTmV3Q2FudmFzQmxlbmRNb2Rlcztcbi8qKlxuICogQ3JlYXRlcyBhIGxpdHRsZSBjb2xvcmVkIGNhbnZhc1xuICpcbiAqIEBpZ25vcmVcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvciAtIFRoZSBjb2xvciB0byBtYWtlIHRoZSBjYW52YXNcbiAqIEByZXR1cm4ge2NhbnZhc30gYSBzbWFsbCBjYW52YXMgZWxlbWVudFxuICovXG5mdW5jdGlvbiBjcmVhdGVDb2xvcmVkQ2FudmFzKGNvbG9yKSB7XG4gICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuXG4gICAgY2FudmFzLndpZHRoID0gNjtcbiAgICBjYW52YXMuaGVpZ2h0ID0gMTtcblxuICAgIHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGNvbG9yO1xuICAgIGNvbnRleHQuZmlsbFJlY3QoMCwgMCwgNiwgMSk7XG5cbiAgICByZXR1cm4gY2FudmFzO1xufVxuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIHRoZSBDYW52YXMgQmxlbmRNb2RlcyBhcmUgc3VwcG9ydGVkIGJ5IHRoZSBjdXJyZW50IGJyb3dzZXJcbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufSB3aGV0aGVyIHRoZXkgYXJlIHN1cHBvcnRlZFxuICovXG5mdW5jdGlvbiBjYW5Vc2VOZXdDYW52YXNCbGVuZE1vZGVzKCkge1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgbWFnZW50YSA9IGNyZWF0ZUNvbG9yZWRDYW52YXMoJyNmZjAwZmYnKTtcbiAgICB2YXIgeWVsbG93ID0gY3JlYXRlQ29sb3JlZENhbnZhcygnI2ZmZmYwMCcpO1xuXG4gICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuXG4gICAgY2FudmFzLndpZHRoID0gNjtcbiAgICBjYW52YXMuaGVpZ2h0ID0gMTtcblxuICAgIHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdtdWx0aXBseSc7XG4gICAgY29udGV4dC5kcmF3SW1hZ2UobWFnZW50YSwgMCwgMCk7XG4gICAgY29udGV4dC5kcmF3SW1hZ2UoeWVsbG93LCAyLCAwKTtcblxuICAgIHZhciBpbWFnZURhdGEgPSBjb250ZXh0LmdldEltYWdlRGF0YSgyLCAwLCAxLCAxKTtcblxuICAgIGlmICghaW1hZ2VEYXRhKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgZGF0YSA9IGltYWdlRGF0YS5kYXRhO1xuXG4gICAgcmV0dXJuIGRhdGFbMF0gPT09IDI1NSAmJiBkYXRhWzFdID09PSAwICYmIGRhdGFbMl0gPT09IDA7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jYW5Vc2VOZXdDYW52YXNCbGVuZE1vZGVzLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuZGVmYXVsdCA9IG1hcENhbnZhc0JsZW5kTW9kZXNUb1BpeGk7XG5cbnZhciBfY29uc3QgPSByZXF1aXJlKCcuLi8uLi8uLi9jb25zdCcpO1xuXG52YXIgX2NhblVzZU5ld0NhbnZhc0JsZW5kTW9kZXMgPSByZXF1aXJlKCcuL2NhblVzZU5ld0NhbnZhc0JsZW5kTW9kZXMnKTtcblxudmFyIF9jYW5Vc2VOZXdDYW52YXNCbGVuZE1vZGVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NhblVzZU5ld0NhbnZhc0JsZW5kTW9kZXMpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKipcbiAqIE1hcHMgYmxlbmQgY29tYmluYXRpb25zIHRvIENhbnZhcy5cbiAqXG4gKiBAbWVtYmVyb2YgUElYSVxuICogQGZ1bmN0aW9uIG1hcENhbnZhc0JsZW5kTW9kZXNUb1BpeGlcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBbYXJyYXk9W11dIC0gVGhlIGFycmF5IHRvIG91dHB1dCBpbnRvLlxuICogQHJldHVybiB7c3RyaW5nW119IE1hcHBlZCBtb2Rlcy5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FudmFzQmxlbmRNb2Rlc1RvUGl4aSgpIHtcbiAgICB2YXIgYXJyYXkgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFtdO1xuXG4gICAgaWYgKCgwLCBfY2FuVXNlTmV3Q2FudmFzQmxlbmRNb2RlczIuZGVmYXVsdCkoKSkge1xuICAgICAgICBhcnJheVtfY29uc3QuQkxFTkRfTU9ERVMuTk9STUFMXSA9ICdzb3VyY2Utb3Zlcic7XG4gICAgICAgIGFycmF5W19jb25zdC5CTEVORF9NT0RFUy5BRERdID0gJ2xpZ2h0ZXInOyAvLyBJUyBUSElTIE9LPz8/XG4gICAgICAgIGFycmF5W19jb25zdC5CTEVORF9NT0RFUy5NVUxUSVBMWV0gPSAnbXVsdGlwbHknO1xuICAgICAgICBhcnJheVtfY29uc3QuQkxFTkRfTU9ERVMuU0NSRUVOXSA9ICdzY3JlZW4nO1xuICAgICAgICBhcnJheVtfY29uc3QuQkxFTkRfTU9ERVMuT1ZFUkxBWV0gPSAnb3ZlcmxheSc7XG4gICAgICAgIGFycmF5W19jb25zdC5CTEVORF9NT0RFUy5EQVJLRU5dID0gJ2Rhcmtlbic7XG4gICAgICAgIGFycmF5W19jb25zdC5CTEVORF9NT0RFUy5MSUdIVEVOXSA9ICdsaWdodGVuJztcbiAgICAgICAgYXJyYXlbX2NvbnN0LkJMRU5EX01PREVTLkNPTE9SX0RPREdFXSA9ICdjb2xvci1kb2RnZSc7XG4gICAgICAgIGFycmF5W19jb25zdC5CTEVORF9NT0RFUy5DT0xPUl9CVVJOXSA9ICdjb2xvci1idXJuJztcbiAgICAgICAgYXJyYXlbX2NvbnN0LkJMRU5EX01PREVTLkhBUkRfTElHSFRdID0gJ2hhcmQtbGlnaHQnO1xuICAgICAgICBhcnJheVtfY29uc3QuQkxFTkRfTU9ERVMuU09GVF9MSUdIVF0gPSAnc29mdC1saWdodCc7XG4gICAgICAgIGFycmF5W19jb25zdC5CTEVORF9NT0RFUy5ESUZGRVJFTkNFXSA9ICdkaWZmZXJlbmNlJztcbiAgICAgICAgYXJyYXlbX2NvbnN0LkJMRU5EX01PREVTLkVYQ0xVU0lPTl0gPSAnZXhjbHVzaW9uJztcbiAgICAgICAgYXJyYXlbX2NvbnN0LkJMRU5EX01PREVTLkhVRV0gPSAnaHVlJztcbiAgICAgICAgYXJyYXlbX2NvbnN0LkJMRU5EX01PREVTLlNBVFVSQVRJT05dID0gJ3NhdHVyYXRlJztcbiAgICAgICAgYXJyYXlbX2NvbnN0LkJMRU5EX01PREVTLkNPTE9SXSA9ICdjb2xvcic7XG4gICAgICAgIGFycmF5W19jb25zdC5CTEVORF9NT0RFUy5MVU1JTk9TSVRZXSA9ICdsdW1pbm9zaXR5JztcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyB0aGlzIG1lYW5zIHRoYXQgdGhlIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCB0aGUgY29vbCBuZXcgYmxlbmQgbW9kZXMgaW4gY2FudmFzICdjb3VnaCcgaWUgJ2NvdWdoJ1xuICAgICAgICBhcnJheVtfY29uc3QuQkxFTkRfTU9ERVMuTk9STUFMXSA9ICdzb3VyY2Utb3Zlcic7XG4gICAgICAgIGFycmF5W19jb25zdC5CTEVORF9NT0RFUy5BRERdID0gJ2xpZ2h0ZXInOyAvLyBJUyBUSElTIE9LPz8/XG4gICAgICAgIGFycmF5W19jb25zdC5CTEVORF9NT0RFUy5NVUxUSVBMWV0gPSAnc291cmNlLW92ZXInO1xuICAgICAgICBhcnJheVtfY29uc3QuQkxFTkRfTU9ERVMuU0NSRUVOXSA9ICdzb3VyY2Utb3Zlcic7XG4gICAgICAgIGFycmF5W19jb25zdC5CTEVORF9NT0RFUy5PVkVSTEFZXSA9ICdzb3VyY2Utb3Zlcic7XG4gICAgICAgIGFycmF5W19jb25zdC5CTEVORF9NT0RFUy5EQVJLRU5dID0gJ3NvdXJjZS1vdmVyJztcbiAgICAgICAgYXJyYXlbX2NvbnN0LkJMRU5EX01PREVTLkxJR0hURU5dID0gJ3NvdXJjZS1vdmVyJztcbiAgICAgICAgYXJyYXlbX2NvbnN0LkJMRU5EX01PREVTLkNPTE9SX0RPREdFXSA9ICdzb3VyY2Utb3Zlcic7XG4gICAgICAgIGFycmF5W19jb25zdC5CTEVORF9NT0RFUy5DT0xPUl9CVVJOXSA9ICdzb3VyY2Utb3Zlcic7XG4gICAgICAgIGFycmF5W19jb25zdC5CTEVORF9NT0RFUy5IQVJEX0xJR0hUXSA9ICdzb3VyY2Utb3Zlcic7XG4gICAgICAgIGFycmF5W19jb25zdC5CTEVORF9NT0RFUy5TT0ZUX0xJR0hUXSA9ICdzb3VyY2Utb3Zlcic7XG4gICAgICAgIGFycmF5W19jb25zdC5CTEVORF9NT0RFUy5ESUZGRVJFTkNFXSA9ICdzb3VyY2Utb3Zlcic7XG4gICAgICAgIGFycmF5W19jb25zdC5CTEVORF9NT0RFUy5FWENMVVNJT05dID0gJ3NvdXJjZS1vdmVyJztcbiAgICAgICAgYXJyYXlbX2NvbnN0LkJMRU5EX01PREVTLkhVRV0gPSAnc291cmNlLW92ZXInO1xuICAgICAgICBhcnJheVtfY29uc3QuQkxFTkRfTU9ERVMuU0FUVVJBVElPTl0gPSAnc291cmNlLW92ZXInO1xuICAgICAgICBhcnJheVtfY29uc3QuQkxFTkRfTU9ERVMuQ09MT1JdID0gJ3NvdXJjZS1vdmVyJztcbiAgICAgICAgYXJyYXlbX2NvbnN0LkJMRU5EX01PREVTLkxVTUlOT1NJVFldID0gJ3NvdXJjZS1vdmVyJztcbiAgICB9XG4gICAgLy8gbm90LXByZW11bHRpcGxpZWQsIG9ubHkgZm9yIHdlYmdsXG4gICAgYXJyYXlbX2NvbnN0LkJMRU5EX01PREVTLk5PUk1BTF9OUE1dID0gYXJyYXlbX2NvbnN0LkJMRU5EX01PREVTLk5PUk1BTF07XG4gICAgYXJyYXlbX2NvbnN0LkJMRU5EX01PREVTLkFERF9OUE1dID0gYXJyYXlbX2NvbnN0LkJMRU5EX01PREVTLkFERF07XG4gICAgYXJyYXlbX2NvbnN0LkJMRU5EX01PREVTLlNDUkVFTl9OUE1dID0gYXJyYXlbX2NvbnN0LkJMRU5EX01PREVTLlNDUkVFTl07XG5cbiAgICByZXR1cm4gYXJyYXk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXBDYW52YXNCbGVuZE1vZGVzVG9QaXhpLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9jb25zdCA9IHJlcXVpcmUoJy4uLy4uL2NvbnN0Jyk7XG5cbnZhciBfc2V0dGluZ3MgPSByZXF1aXJlKCcuLi8uLi9zZXR0aW5ncycpO1xuXG52YXIgX3NldHRpbmdzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NldHRpbmdzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuLyoqXG4gKiBUZXh0dXJlR2FyYmFnZUNvbGxlY3Rvci4gVGhpcyBjbGFzcyBtYW5hZ2VzIHRoZSBHUFUgYW5kIGVuc3VyZXMgdGhhdCBpdCBkb2VzIG5vdCBnZXQgY2xvZ2dlZFxuICogdXAgd2l0aCB0ZXh0dXJlcyB0aGF0IGFyZSBubyBsb25nZXIgYmVpbmcgdXNlZC5cbiAqXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKi9cbnZhciBUZXh0dXJlR2FyYmFnZUNvbGxlY3RvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1BJWEkuV2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIgdGhpcyBtYW5hZ2VyIHdvcmtzIGZvci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBUZXh0dXJlR2FyYmFnZUNvbGxlY3RvcihyZW5kZXJlcikge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVGV4dHVyZUdhcmJhZ2VDb2xsZWN0b3IpO1xuXG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcblxuICAgICAgICB0aGlzLmNvdW50ID0gMDtcbiAgICAgICAgdGhpcy5jaGVja0NvdW50ID0gMDtcbiAgICAgICAgdGhpcy5tYXhJZGxlID0gX3NldHRpbmdzMi5kZWZhdWx0LkdDX01BWF9JRExFO1xuICAgICAgICB0aGlzLmNoZWNrQ291bnRNYXggPSBfc2V0dGluZ3MyLmRlZmF1bHQuR0NfTUFYX0NIRUNLX0NPVU5UO1xuICAgICAgICB0aGlzLm1vZGUgPSBfc2V0dGluZ3MyLmRlZmF1bHQuR0NfTU9ERTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgdG8gc2VlIHdoZW4gdGhlIGxhc3QgdGltZSBhIHRleHR1cmUgd2FzIHVzZWRcbiAgICAgKiBpZiB0aGUgdGV4dHVyZSBoYXMgbm90IGJlZW4gdXNlZCBmb3IgYSBzcGVjaWZpZWQgYW1vdW50IG9mIHRpbWUgaXQgd2lsbCBiZSByZW1vdmVkIGZyb20gdGhlIEdQVVxuICAgICAqL1xuXG5cbiAgICBUZXh0dXJlR2FyYmFnZUNvbGxlY3Rvci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgICAgICB0aGlzLmNvdW50Kys7XG5cbiAgICAgICAgaWYgKHRoaXMubW9kZSA9PT0gX2NvbnN0LkdDX01PREVTLk1BTlVBTCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jaGVja0NvdW50Kys7XG5cbiAgICAgICAgaWYgKHRoaXMuY2hlY2tDb3VudCA+IHRoaXMuY2hlY2tDb3VudE1heCkge1xuICAgICAgICAgICAgdGhpcy5jaGVja0NvdW50ID0gMDtcblxuICAgICAgICAgICAgdGhpcy5ydW4oKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgdG8gc2VlIHdoZW4gdGhlIGxhc3QgdGltZSBhIHRleHR1cmUgd2FzIHVzZWRcbiAgICAgKiBpZiB0aGUgdGV4dHVyZSBoYXMgbm90IGJlZW4gdXNlZCBmb3IgYSBzcGVjaWZpZWQgYW1vdW50IG9mIHRpbWUgaXQgd2lsbCBiZSByZW1vdmVkIGZyb20gdGhlIEdQVVxuICAgICAqL1xuXG5cbiAgICBUZXh0dXJlR2FyYmFnZUNvbGxlY3Rvci5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gcnVuKCkge1xuICAgICAgICB2YXIgdG0gPSB0aGlzLnJlbmRlcmVyLnRleHR1cmVNYW5hZ2VyO1xuICAgICAgICB2YXIgbWFuYWdlZFRleHR1cmVzID0gdG0uX21hbmFnZWRUZXh0dXJlcztcbiAgICAgICAgdmFyIHdhc1JlbW92ZWQgPSBmYWxzZTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hbmFnZWRUZXh0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHRleHR1cmUgPSBtYW5hZ2VkVGV4dHVyZXNbaV07XG5cbiAgICAgICAgICAgIC8vIG9ubHkgc3VwcG9ydHMgbm9uIGdlbmVyYXRlZCB0ZXh0dXJlcyBhdCB0aGUgbW9tZW50IVxuICAgICAgICAgICAgaWYgKCF0ZXh0dXJlLl9nbFJlbmRlclRhcmdldHMgJiYgdGhpcy5jb3VudCAtIHRleHR1cmUudG91Y2hlZCA+IHRoaXMubWF4SWRsZSkge1xuICAgICAgICAgICAgICAgIHRtLmRlc3Ryb3lUZXh0dXJlKHRleHR1cmUsIHRydWUpO1xuICAgICAgICAgICAgICAgIG1hbmFnZWRUZXh0dXJlc1tpXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgd2FzUmVtb3ZlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAod2FzUmVtb3ZlZCkge1xuICAgICAgICAgICAgdmFyIGogPSAwO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbWFuYWdlZFRleHR1cmVzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIGlmIChtYW5hZ2VkVGV4dHVyZXNbX2ldICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hbmFnZWRUZXh0dXJlc1tqKytdID0gbWFuYWdlZFRleHR1cmVzW19pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1hbmFnZWRUZXh0dXJlcy5sZW5ndGggPSBqO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIHRoZSB0ZXh0dXJlcyB3aXRoaW4gdGhlIHNwZWNpZmllZCBkaXNwbGF5T2JqZWN0IGFuZCBpdHMgY2hpbGRyZW4gZnJvbSB0aGUgR1BVXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuRGlzcGxheU9iamVjdH0gZGlzcGxheU9iamVjdCAtIHRoZSBkaXNwbGF5T2JqZWN0IHRvIHJlbW92ZSB0aGUgdGV4dHVyZXMgZnJvbS5cbiAgICAgKi9cblxuXG4gICAgVGV4dHVyZUdhcmJhZ2VDb2xsZWN0b3IucHJvdG90eXBlLnVubG9hZCA9IGZ1bmN0aW9uIHVubG9hZChkaXNwbGF5T2JqZWN0KSB7XG4gICAgICAgIHZhciB0bSA9IHRoaXMucmVuZGVyZXIudGV4dHVyZU1hbmFnZXI7XG5cbiAgICAgICAgLy8gb25seSBkZXN0cm95IG5vbiBnZW5lcmF0ZWQgdGV4dHVyZXNcbiAgICAgICAgaWYgKGRpc3BsYXlPYmplY3QuX3RleHR1cmUgJiYgZGlzcGxheU9iamVjdC5fdGV4dHVyZS5fZ2xSZW5kZXJUYXJnZXRzKSB7XG4gICAgICAgICAgICB0bS5kZXN0cm95VGV4dHVyZShkaXNwbGF5T2JqZWN0Ll90ZXh0dXJlLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSBkaXNwbGF5T2JqZWN0LmNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICB0aGlzLnVubG9hZChkaXNwbGF5T2JqZWN0LmNoaWxkcmVuW2ldKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gVGV4dHVyZUdhcmJhZ2VDb2xsZWN0b3I7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFRleHR1cmVHYXJiYWdlQ29sbGVjdG9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGV4dHVyZUdhcmJhZ2VDb2xsZWN0b3IuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3BpeGlHbENvcmUgPSByZXF1aXJlKCdwaXhpLWdsLWNvcmUnKTtcblxudmFyIF9jb25zdCA9IHJlcXVpcmUoJy4uLy4uL2NvbnN0Jyk7XG5cbnZhciBfUmVuZGVyVGFyZ2V0ID0gcmVxdWlyZSgnLi91dGlscy9SZW5kZXJUYXJnZXQnKTtcblxudmFyIF9SZW5kZXJUYXJnZXQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUmVuZGVyVGFyZ2V0KTtcblxudmFyIF91dGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8qKlxuICogSGVscGVyIGNsYXNzIHRvIGNyZWF0ZSBhIHdlYkdMIFRleHR1cmVcbiAqXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKi9cbnZhciBUZXh0dXJlTWFuYWdlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1BJWEkuV2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBBIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudCByZW5kZXJlclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFRleHR1cmVNYW5hZ2VyKHJlbmRlcmVyKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUZXh0dXJlTWFuYWdlcik7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IHJlbmRlcmVyXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuV2ViR0xSZW5kZXJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGN1cnJlbnQgV2ViR0wgcmVuZGVyaW5nIGNvbnRleHRcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5nbCA9IHJlbmRlcmVyLmdsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcmFjayB0ZXh0dXJlcyBpbiB0aGUgcmVuZGVyZXIgc28gd2UgY2FuIG5vIGxvbmdlciBsaXN0ZW4gdG8gdGhlbSBvbiBkZXN0cnVjdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7QXJyYXk8Kj59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9tYW5hZ2VkVGV4dHVyZXMgPSBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCaW5kcyBhIHRleHR1cmUuXG4gICAgICpcbiAgICAgKi9cblxuXG4gICAgVGV4dHVyZU1hbmFnZXIucHJvdG90eXBlLmJpbmRUZXh0dXJlID0gZnVuY3Rpb24gYmluZFRleHR1cmUoKSB7fVxuICAgIC8vIGVtcHR5XG5cblxuICAgIC8qKlxuICAgICAqIEdldHMgYSB0ZXh0dXJlLlxuICAgICAqXG4gICAgICovXG4gICAgO1xuXG4gICAgVGV4dHVyZU1hbmFnZXIucHJvdG90eXBlLmdldFRleHR1cmUgPSBmdW5jdGlvbiBnZXRUZXh0dXJlKCkge31cbiAgICAvLyBlbXB0eVxuXG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIGFuZC9vciBDcmVhdGVzIGEgV2ViR0wgdGV4dHVyZSBmb3IgdGhlIHJlbmRlcmVyJ3MgY29udGV4dC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5CYXNlVGV4dHVyZXxQSVhJLlRleHR1cmV9IHRleHR1cmUgLSB0aGUgdGV4dHVyZSB0byB1cGRhdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbG9jYXRpb24gLSB0aGUgbG9jYXRpb24gdGhlIHRleHR1cmUgd2lsbCBiZSBib3VuZCB0by5cbiAgICAgKiBAcmV0dXJuIHtHTFRleHR1cmV9IFRoZSBnbCB0ZXh0dXJlLlxuICAgICAqL1xuICAgIDtcblxuICAgIFRleHR1cmVNYW5hZ2VyLnByb3RvdHlwZS51cGRhdGVUZXh0dXJlID0gZnVuY3Rpb24gdXBkYXRlVGV4dHVyZSh0ZXh0dXJlLCBsb2NhdGlvbikge1xuICAgICAgICAvLyBhc3N1bWUgaXQgZ29vZCFcbiAgICAgICAgLy8gdGV4dHVyZSA9IHRleHR1cmUuYmFzZVRleHR1cmUgfHwgdGV4dHVyZTtcblxuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuXG4gICAgICAgIHZhciBpc1JlbmRlclRleHR1cmUgPSAhIXRleHR1cmUuX2dsUmVuZGVyVGFyZ2V0cztcblxuICAgICAgICBpZiAoIXRleHR1cmUuaGFzTG9hZGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBib3VuZFRleHR1cmVzID0gdGhpcy5yZW5kZXJlci5ib3VuZFRleHR1cmVzO1xuXG4gICAgICAgIC8vIGlmIHRoZSBsb2NhdGlvbiBpcyB1bmRlZmluZWQgdGhlbiB0aGlzIG1heSBoYXZlIGJlZW4gY2FsbGVkIGJ5IG4gZXZlbnQuXG4gICAgICAgIC8vIHRoaXMgYmVpbmcgdGhlIGNhc2UgdGhlIHRleHR1cmUgbWF5IGFscmVhZHkgYmUgYm91bmQgdG8gYSBzbG90LiBBcyBhIHRleHR1cmUgY2FuIG9ubHkgYmUgYm91bmQgb25jZVxuICAgICAgICAvLyB3ZSBuZWVkIHRvIGZpbmQgaXRzIGN1cnJlbnQgbG9jYXRpb24gaWYgaXQgZXhpc3RzLlxuICAgICAgICBpZiAobG9jYXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbG9jYXRpb24gPSAwO1xuXG4gICAgICAgICAgICAvLyBUT0RPIG1heWJlIHdlIGNhbiB1c2UgdGV4dHVyZSBib3VuZCBpZHMgbGF0ZXIgb24uLi5cbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRleHR1cmUgaXMgYWxyZWFkeSBib3VuZC4uXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvdW5kVGV4dHVyZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAoYm91bmRUZXh0dXJlc1tpXSA9PT0gdGV4dHVyZSkge1xuICAgICAgICAgICAgICAgICAgICBsb2NhdGlvbiA9IGk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGJvdW5kVGV4dHVyZXNbbG9jYXRpb25dID0gdGV4dHVyZTtcblxuICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwICsgbG9jYXRpb24pO1xuXG4gICAgICAgIHZhciBnbFRleHR1cmUgPSB0ZXh0dXJlLl9nbFRleHR1cmVzW3RoaXMucmVuZGVyZXIuQ09OVEVYVF9VSURdO1xuXG4gICAgICAgIGlmICghZ2xUZXh0dXJlKSB7XG4gICAgICAgICAgICBpZiAoaXNSZW5kZXJUZXh0dXJlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlbmRlclRhcmdldCA9IG5ldyBfUmVuZGVyVGFyZ2V0Mi5kZWZhdWx0KHRoaXMuZ2wsIHRleHR1cmUud2lkdGgsIHRleHR1cmUuaGVpZ2h0LCB0ZXh0dXJlLnNjYWxlTW9kZSwgdGV4dHVyZS5yZXNvbHV0aW9uKTtcblxuICAgICAgICAgICAgICAgIHJlbmRlclRhcmdldC5yZXNpemUodGV4dHVyZS53aWR0aCwgdGV4dHVyZS5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIHRleHR1cmUuX2dsUmVuZGVyVGFyZ2V0c1t0aGlzLnJlbmRlcmVyLkNPTlRFWFRfVUlEXSA9IHJlbmRlclRhcmdldDtcbiAgICAgICAgICAgICAgICBnbFRleHR1cmUgPSByZW5kZXJUYXJnZXQudGV4dHVyZTtcblxuICAgICAgICAgICAgICAgIC8vIGZyYW1lYnVmZmVyIGNvbnN0cnVjdG9yIGRpc2FjdGl2YXRlcyBjdXJyZW50IGZyYW1lYnVmZmVyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnJlbmRlcmVyLl9hY3RpdmVSZW5kZXJUYXJnZXQucm9vdCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLl9hY3RpdmVSZW5kZXJUYXJnZXQuZnJhbWVCdWZmZXIuYmluZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZ2xUZXh0dXJlID0gbmV3IF9waXhpR2xDb3JlLkdMVGV4dHVyZSh0aGlzLmdsLCBudWxsLCBudWxsLCBudWxsLCBudWxsKTtcbiAgICAgICAgICAgICAgICBnbFRleHR1cmUuYmluZChsb2NhdGlvbik7XG4gICAgICAgICAgICAgICAgZ2xUZXh0dXJlLnByZW11bHRpcGx5QWxwaGEgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGdsVGV4dHVyZS51cGxvYWQodGV4dHVyZS5zb3VyY2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0ZXh0dXJlLl9nbFRleHR1cmVzW3RoaXMucmVuZGVyZXIuQ09OVEVYVF9VSURdID0gZ2xUZXh0dXJlO1xuXG4gICAgICAgICAgICB0ZXh0dXJlLm9uKCd1cGRhdGUnLCB0aGlzLnVwZGF0ZVRleHR1cmUsIHRoaXMpO1xuICAgICAgICAgICAgdGV4dHVyZS5vbignZGlzcG9zZScsIHRoaXMuZGVzdHJveVRleHR1cmUsIHRoaXMpO1xuXG4gICAgICAgICAgICB0aGlzLl9tYW5hZ2VkVGV4dHVyZXMucHVzaCh0ZXh0dXJlKTtcblxuICAgICAgICAgICAgaWYgKHRleHR1cmUuaXNQb3dlck9mVHdvKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRleHR1cmUubWlwbWFwKSB7XG4gICAgICAgICAgICAgICAgICAgIGdsVGV4dHVyZS5lbmFibGVNaXBtYXAoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodGV4dHVyZS53cmFwTW9kZSA9PT0gX2NvbnN0LldSQVBfTU9ERVMuQ0xBTVApIHtcbiAgICAgICAgICAgICAgICAgICAgZ2xUZXh0dXJlLmVuYWJsZVdyYXBDbGFtcCgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGV4dHVyZS53cmFwTW9kZSA9PT0gX2NvbnN0LldSQVBfTU9ERVMuUkVQRUFUKSB7XG4gICAgICAgICAgICAgICAgICAgIGdsVGV4dHVyZS5lbmFibGVXcmFwUmVwZWF0KCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZ2xUZXh0dXJlLmVuYWJsZVdyYXBNaXJyb3JSZXBlYXQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGdsVGV4dHVyZS5lbmFibGVXcmFwQ2xhbXAoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRleHR1cmUuc2NhbGVNb2RlID09PSBfY29uc3QuU0NBTEVfTU9ERVMuTkVBUkVTVCkge1xuICAgICAgICAgICAgICAgIGdsVGV4dHVyZS5lbmFibGVOZWFyZXN0U2NhbGluZygpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBnbFRleHR1cmUuZW5hYmxlTGluZWFyU2NhbGluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHRoZSB0ZXh0dXJlIGFscmVhZHkgZXhpc3RzIHNvIHdlIG9ubHkgbmVlZCB0byB1cGRhdGUgaXQuLlxuICAgICAgICBlbHNlIGlmIChpc1JlbmRlclRleHR1cmUpIHtcbiAgICAgICAgICAgICAgICB0ZXh0dXJlLl9nbFJlbmRlclRhcmdldHNbdGhpcy5yZW5kZXJlci5DT05URVhUX1VJRF0ucmVzaXplKHRleHR1cmUud2lkdGgsIHRleHR1cmUuaGVpZ2h0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZ2xUZXh0dXJlLnVwbG9hZCh0ZXh0dXJlLnNvdXJjZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdsVGV4dHVyZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGVsZXRlcyB0aGUgdGV4dHVyZSBmcm9tIFdlYkdMXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuQmFzZVRleHR1cmV8UElYSS5UZXh0dXJlfSB0ZXh0dXJlIC0gdGhlIHRleHR1cmUgdG8gZGVzdHJveVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NraXBSZW1vdmU9ZmFsc2VdIC0gV2hldGhlciB0byBza2lwIHJlbW92aW5nIHRoZSB0ZXh0dXJlIGZyb20gdGhlIFRleHR1cmVNYW5hZ2VyLlxuICAgICAqL1xuXG5cbiAgICBUZXh0dXJlTWFuYWdlci5wcm90b3R5cGUuZGVzdHJveVRleHR1cmUgPSBmdW5jdGlvbiBkZXN0cm95VGV4dHVyZSh0ZXh0dXJlLCBza2lwUmVtb3ZlKSB7XG4gICAgICAgIHRleHR1cmUgPSB0ZXh0dXJlLmJhc2VUZXh0dXJlIHx8IHRleHR1cmU7XG5cbiAgICAgICAgaWYgKCF0ZXh0dXJlLmhhc0xvYWRlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcjtcbiAgICAgICAgdmFyIHVpZCA9IHJlbmRlcmVyLkNPTlRFWFRfVUlEO1xuICAgICAgICB2YXIgZ2xUZXh0dXJlcyA9IHRleHR1cmUuX2dsVGV4dHVyZXM7XG4gICAgICAgIHZhciBnbFJlbmRlclRhcmdldHMgPSB0ZXh0dXJlLl9nbFJlbmRlclRhcmdldHM7XG5cbiAgICAgICAgaWYgKGdsVGV4dHVyZXNbdWlkXSkge1xuICAgICAgICAgICAgcmVuZGVyZXIudW5iaW5kVGV4dHVyZSh0ZXh0dXJlKTtcblxuICAgICAgICAgICAgZ2xUZXh0dXJlc1t1aWRdLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIHRleHR1cmUub2ZmKCd1cGRhdGUnLCB0aGlzLnVwZGF0ZVRleHR1cmUsIHRoaXMpO1xuICAgICAgICAgICAgdGV4dHVyZS5vZmYoJ2Rpc3Bvc2UnLCB0aGlzLmRlc3Ryb3lUZXh0dXJlLCB0aGlzKTtcblxuICAgICAgICAgICAgZGVsZXRlIGdsVGV4dHVyZXNbdWlkXTtcblxuICAgICAgICAgICAgaWYgKCFza2lwUmVtb3ZlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSB0aGlzLl9tYW5hZ2VkVGV4dHVyZXMuaW5kZXhPZih0ZXh0dXJlKTtcblxuICAgICAgICAgICAgICAgIGlmIChpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAoMCwgX3V0aWxzLnJlbW92ZUl0ZW1zKSh0aGlzLl9tYW5hZ2VkVGV4dHVyZXMsIGksIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChnbFJlbmRlclRhcmdldHMgJiYgZ2xSZW5kZXJUYXJnZXRzW3VpZF0pIHtcbiAgICAgICAgICAgIGlmIChyZW5kZXJlci5fYWN0aXZlUmVuZGVyVGFyZ2V0ID09PSBnbFJlbmRlclRhcmdldHNbdWlkXSkge1xuICAgICAgICAgICAgICAgIHJlbmRlcmVyLmJpbmRSZW5kZXJUYXJnZXQocmVuZGVyZXIucm9vdFJlbmRlclRhcmdldCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGdsUmVuZGVyVGFyZ2V0c1t1aWRdLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIGRlbGV0ZSBnbFJlbmRlclRhcmdldHNbdWlkXTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIGFsbCB0aGUgdGV4dHVyZXMgZnJvbSBXZWJHTFxuICAgICAqL1xuXG5cbiAgICBUZXh0dXJlTWFuYWdlci5wcm90b3R5cGUucmVtb3ZlQWxsID0gZnVuY3Rpb24gcmVtb3ZlQWxsKCkge1xuICAgICAgICAvLyBlbXB0eSBhbGwgdGhlIG9sZCBnbCB0ZXh0dXJlcyBhcyB0aGV5IGFyZSB1c2VsZXNzIG5vd1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX21hbmFnZWRUZXh0dXJlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIHRleHR1cmUgPSB0aGlzLl9tYW5hZ2VkVGV4dHVyZXNbaV07XG5cbiAgICAgICAgICAgIGlmICh0ZXh0dXJlLl9nbFRleHR1cmVzW3RoaXMucmVuZGVyZXIuQ09OVEVYVF9VSURdKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRleHR1cmUuX2dsVGV4dHVyZXNbdGhpcy5yZW5kZXJlci5DT05URVhUX1VJRF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGVzdHJveXMgdGhpcyBtYW5hZ2VyIGFuZCByZW1vdmVzIGFsbCBpdHMgdGV4dHVyZXNcbiAgICAgKi9cblxuXG4gICAgVGV4dHVyZU1hbmFnZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICAvLyBkZXN0cm95IG1hbmFnZWQgdGV4dHVyZXNcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9tYW5hZ2VkVGV4dHVyZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciB0ZXh0dXJlID0gdGhpcy5fbWFuYWdlZFRleHR1cmVzW2ldO1xuXG4gICAgICAgICAgICB0aGlzLmRlc3Ryb3lUZXh0dXJlKHRleHR1cmUsIHRydWUpO1xuXG4gICAgICAgICAgICB0ZXh0dXJlLm9mZigndXBkYXRlJywgdGhpcy51cGRhdGVUZXh0dXJlLCB0aGlzKTtcbiAgICAgICAgICAgIHRleHR1cmUub2ZmKCdkaXNwb3NlJywgdGhpcy5kZXN0cm95VGV4dHVyZSwgdGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9tYW5hZ2VkVGV4dHVyZXMgPSBudWxsO1xuICAgIH07XG5cbiAgICByZXR1cm4gVGV4dHVyZU1hbmFnZXI7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFRleHR1cmVNYW5hZ2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGV4dHVyZU1hbmFnZXIuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX1N5c3RlbVJlbmRlcmVyMiA9IHJlcXVpcmUoJy4uL1N5c3RlbVJlbmRlcmVyJyk7XG5cbnZhciBfU3lzdGVtUmVuZGVyZXIzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU3lzdGVtUmVuZGVyZXIyKTtcblxudmFyIF9NYXNrTWFuYWdlciA9IHJlcXVpcmUoJy4vbWFuYWdlcnMvTWFza01hbmFnZXInKTtcblxudmFyIF9NYXNrTWFuYWdlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NYXNrTWFuYWdlcik7XG5cbnZhciBfU3RlbmNpbE1hbmFnZXIgPSByZXF1aXJlKCcuL21hbmFnZXJzL1N0ZW5jaWxNYW5hZ2VyJyk7XG5cbnZhciBfU3RlbmNpbE1hbmFnZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU3RlbmNpbE1hbmFnZXIpO1xuXG52YXIgX0ZpbHRlck1hbmFnZXIgPSByZXF1aXJlKCcuL21hbmFnZXJzL0ZpbHRlck1hbmFnZXInKTtcblxudmFyIF9GaWx0ZXJNYW5hZ2VyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0ZpbHRlck1hbmFnZXIpO1xuXG52YXIgX1JlbmRlclRhcmdldCA9IHJlcXVpcmUoJy4vdXRpbHMvUmVuZGVyVGFyZ2V0Jyk7XG5cbnZhciBfUmVuZGVyVGFyZ2V0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1JlbmRlclRhcmdldCk7XG5cbnZhciBfT2JqZWN0UmVuZGVyZXIgPSByZXF1aXJlKCcuL3V0aWxzL09iamVjdFJlbmRlcmVyJyk7XG5cbnZhciBfT2JqZWN0UmVuZGVyZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfT2JqZWN0UmVuZGVyZXIpO1xuXG52YXIgX1RleHR1cmVNYW5hZ2VyID0gcmVxdWlyZSgnLi9UZXh0dXJlTWFuYWdlcicpO1xuXG52YXIgX1RleHR1cmVNYW5hZ2VyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1RleHR1cmVNYW5hZ2VyKTtcblxudmFyIF9CYXNlVGV4dHVyZSA9IHJlcXVpcmUoJy4uLy4uL3RleHR1cmVzL0Jhc2VUZXh0dXJlJyk7XG5cbnZhciBfQmFzZVRleHR1cmUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQmFzZVRleHR1cmUpO1xuXG52YXIgX1RleHR1cmVHYXJiYWdlQ29sbGVjdG9yID0gcmVxdWlyZSgnLi9UZXh0dXJlR2FyYmFnZUNvbGxlY3RvcicpO1xuXG52YXIgX1RleHR1cmVHYXJiYWdlQ29sbGVjdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1RleHR1cmVHYXJiYWdlQ29sbGVjdG9yKTtcblxudmFyIF9XZWJHTFN0YXRlID0gcmVxdWlyZSgnLi9XZWJHTFN0YXRlJyk7XG5cbnZhciBfV2ViR0xTdGF0ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9XZWJHTFN0YXRlKTtcblxudmFyIF9tYXBXZWJHTERyYXdNb2Rlc1RvUGl4aSA9IHJlcXVpcmUoJy4vdXRpbHMvbWFwV2ViR0xEcmF3TW9kZXNUb1BpeGknKTtcblxudmFyIF9tYXBXZWJHTERyYXdNb2Rlc1RvUGl4aTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tYXBXZWJHTERyYXdNb2Rlc1RvUGl4aSk7XG5cbnZhciBfdmFsaWRhdGVDb250ZXh0ID0gcmVxdWlyZSgnLi91dGlscy92YWxpZGF0ZUNvbnRleHQnKTtcblxudmFyIF92YWxpZGF0ZUNvbnRleHQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdmFsaWRhdGVDb250ZXh0KTtcblxudmFyIF91dGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzJyk7XG5cbnZhciBfcGl4aUdsQ29yZSA9IHJlcXVpcmUoJ3BpeGktZ2wtY29yZScpO1xuXG52YXIgX3BpeGlHbENvcmUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGl4aUdsQ29yZSk7XG5cbnZhciBfY29uc3QgPSByZXF1aXJlKCcuLi8uLi9jb25zdCcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBDT05URVhUX1VJRCA9IDA7XG5cbi8qKlxuICogVGhlIFdlYkdMUmVuZGVyZXIgZHJhd3MgdGhlIHNjZW5lIGFuZCBhbGwgaXRzIGNvbnRlbnQgb250byBhIHdlYkdMIGVuYWJsZWQgY2FudmFzLiBUaGlzIHJlbmRlcmVyXG4gKiBzaG91bGQgYmUgdXNlZCBmb3IgYnJvd3NlcnMgdGhhdCBzdXBwb3J0IHdlYkdMLiBUaGlzIFJlbmRlciB3b3JrcyBieSBhdXRvbWF0aWNhbGx5IG1hbmFnaW5nIHdlYkdMQmF0Y2hzLlxuICogU28gbm8gbmVlZCBmb3IgU3ByaXRlIEJhdGNoZXMgb3IgU3ByaXRlIENsb3Vkcy5cbiAqIERvbid0IGZvcmdldCB0byBhZGQgdGhlIHZpZXcgdG8geW91ciBET00gb3IgeW91IHdpbGwgbm90IHNlZSBhbnl0aGluZyA6KVxuICpcbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIFBJWElcbiAqIEBleHRlbmRzIFBJWEkuU3lzdGVtUmVuZGVyZXJcbiAqL1xuXG52YXIgV2ViR0xSZW5kZXJlciA9IGZ1bmN0aW9uIChfU3lzdGVtUmVuZGVyZXIpIHtcbiAgICBfaW5oZXJpdHMoV2ViR0xSZW5kZXJlciwgX1N5c3RlbVJlbmRlcmVyKTtcblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB2YWxpZC1qc2RvY1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAtIFRoZSBvcHRpb25hbCByZW5kZXJlciBwYXJhbWV0ZXJzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLndpZHRoPTgwMF0gLSB0aGUgd2lkdGggb2YgdGhlIHNjcmVlblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5oZWlnaHQ9NjAwXSAtIHRoZSBoZWlnaHQgb2YgdGhlIHNjcmVlblxuICAgICAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IFtvcHRpb25zLnZpZXddIC0gdGhlIGNhbnZhcyB0byB1c2UgYXMgYSB2aWV3LCBvcHRpb25hbFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhbnNwYXJlbnQ9ZmFsc2VdIC0gSWYgdGhlIHJlbmRlciB2aWV3IGlzIHRyYW5zcGFyZW50LCBkZWZhdWx0IGZhbHNlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5hdXRvUmVzaXplPWZhbHNlXSAtIElmIHRoZSByZW5kZXIgdmlldyBpcyBhdXRvbWF0aWNhbGx5IHJlc2l6ZWQsIGRlZmF1bHQgZmFsc2VcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmFudGlhbGlhcz1mYWxzZV0gLSBzZXRzIGFudGlhbGlhcy4gSWYgbm90IGF2YWlsYWJsZSBuYXRpdmVseSB0aGVuIEZYQUFcbiAgICAgKiAgYW50aWFsaWFzaW5nIGlzIHVzZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmZvcmNlRlhBQT1mYWxzZV0gLSBmb3JjZXMgRlhBQSBhbnRpYWxpYXNpbmcgdG8gYmUgdXNlZCBvdmVyIG5hdGl2ZS5cbiAgICAgKiAgRlhBQSBpcyBmYXN0ZXIsIGJ1dCBtYXkgbm90IGFsd2F5cyBsb29rIGFzIGdyZWF0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnJlc29sdXRpb249MV0gLSBUaGUgcmVzb2x1dGlvbiAvIGRldmljZSBwaXhlbCByYXRpbyBvZiB0aGUgcmVuZGVyZXIuXG4gICAgICogIFRoZSByZXNvbHV0aW9uIG9mIHRoZSByZW5kZXJlciByZXRpbmEgd291bGQgYmUgMi5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNsZWFyQmVmb3JlUmVuZGVyPXRydWVdIC0gVGhpcyBzZXRzIGlmIHRoZSByZW5kZXJlciB3aWxsIGNsZWFyXG4gICAgICogIHRoZSBjYW52YXMgb3Igbm90IGJlZm9yZSB0aGUgbmV3IHJlbmRlciBwYXNzLiBJZiB5b3Ugd2lzaCB0byBzZXQgdGhpcyB0byBmYWxzZSwgeW91ICptdXN0KiBzZXRcbiAgICAgKiAgcHJlc2VydmVEcmF3aW5nQnVmZmVyIHRvIGB0cnVlYC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnByZXNlcnZlRHJhd2luZ0J1ZmZlcj1mYWxzZV0gLSBlbmFibGVzIGRyYXdpbmcgYnVmZmVyIHByZXNlcnZhdGlvbixcbiAgICAgKiAgZW5hYmxlIHRoaXMgaWYgeW91IG5lZWQgdG8gY2FsbCB0b0RhdGFVcmwgb24gdGhlIHdlYmdsIGNvbnRleHQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5yb3VuZFBpeGVscz1mYWxzZV0gLSBJZiB0cnVlIFBpeGlKUyB3aWxsIE1hdGguZmxvb3IoKSB4L3kgdmFsdWVzIHdoZW5cbiAgICAgKiAgcmVuZGVyaW5nLCBzdG9wcGluZyBwaXhlbCBpbnRlcnBvbGF0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3I9MHgwMDAwMDBdIC0gVGhlIGJhY2tncm91bmQgY29sb3Igb2YgdGhlIHJlbmRlcmVkIGFyZWFcbiAgICAgKiAgKHNob3duIGlmIG5vdCB0cmFuc3BhcmVudCkuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWdhY3k9ZmFsc2VdIC0gSWYgdHJ1ZSBQaXhpSlMgd2lsbCBhaW0gdG8gZW5zdXJlIGNvbXBhdGliaWxpdHlcbiAgICAgKiAgd2l0aCBvbGRlciAvIGxlc3MgYWR2YW5jZWQgZGV2aWNlcy4gSWYgeW91IGV4cGVyaWVuY2UgdW5leHBsYWluZWQgZmxpY2tlcmluZyB0cnkgc2V0dGluZyB0aGlzIHRvIHRydWUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnBvd2VyUHJlZmVyZW5jZV0gLSBQYXJhbWV0ZXIgcGFzc2VkIHRvIHdlYmdsIGNvbnRleHQsIHNldCB0byBcImhpZ2gtcGVyZm9ybWFuY2VcIlxuICAgICAqICBmb3IgZGV2aWNlcyB3aXRoIGR1YWwgZ3JhcGhpY3MgY2FyZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFdlYkdMUmVuZGVyZXIob3B0aW9ucywgYXJnMiwgYXJnMykge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgV2ViR0xSZW5kZXJlcik7XG5cbiAgICAgICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1N5c3RlbVJlbmRlcmVyLmNhbGwodGhpcywgJ1dlYkdMJywgb3B0aW9ucywgYXJnMiwgYXJnMykpO1xuXG4gICAgICAgIF90aGlzLmxlZ2FjeSA9IF90aGlzLm9wdGlvbnMubGVnYWN5O1xuXG4gICAgICAgIGlmIChfdGhpcy5sZWdhY3kpIHtcbiAgICAgICAgICAgIF9waXhpR2xDb3JlMi5kZWZhdWx0LlZlcnRleEFycmF5T2JqZWN0LkZPUkNFX05BVElWRSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHR5cGUgb2YgdGhpcyByZW5kZXJlciBhcyBhIHN0YW5kYXJkaXNlZCBjb25zdFxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBzZWUgUElYSS5SRU5ERVJFUl9UWVBFXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy50eXBlID0gX2NvbnN0LlJFTkRFUkVSX1RZUEUuV0VCR0w7XG5cbiAgICAgICAgX3RoaXMuaGFuZGxlQ29udGV4dExvc3QgPSBfdGhpcy5oYW5kbGVDb250ZXh0TG9zdC5iaW5kKF90aGlzKTtcbiAgICAgICAgX3RoaXMuaGFuZGxlQ29udGV4dFJlc3RvcmVkID0gX3RoaXMuaGFuZGxlQ29udGV4dFJlc3RvcmVkLmJpbmQoX3RoaXMpO1xuXG4gICAgICAgIF90aGlzLnZpZXcuYWRkRXZlbnRMaXN0ZW5lcignd2ViZ2xjb250ZXh0bG9zdCcsIF90aGlzLmhhbmRsZUNvbnRleHRMb3N0LCBmYWxzZSk7XG4gICAgICAgIF90aGlzLnZpZXcuYWRkRXZlbnRMaXN0ZW5lcignd2ViZ2xjb250ZXh0cmVzdG9yZWQnLCBfdGhpcy5oYW5kbGVDb250ZXh0UmVzdG9yZWQsIGZhbHNlKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG9wdGlvbnMgcGFzc2VkIGluIHRvIGNyZWF0ZSBhIG5ldyB3ZWJnbCBjb250ZXh0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtvYmplY3R9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5fY29udGV4dE9wdGlvbnMgPSB7XG4gICAgICAgICAgICBhbHBoYTogX3RoaXMudHJhbnNwYXJlbnQsXG4gICAgICAgICAgICBhbnRpYWxpYXM6IF90aGlzLm9wdGlvbnMuYW50aWFsaWFzLFxuICAgICAgICAgICAgcHJlbXVsdGlwbGllZEFscGhhOiBfdGhpcy50cmFuc3BhcmVudCAmJiBfdGhpcy50cmFuc3BhcmVudCAhPT0gJ25vdE11bHRpcGxpZWQnLFxuICAgICAgICAgICAgc3RlbmNpbDogdHJ1ZSxcbiAgICAgICAgICAgIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogX3RoaXMub3B0aW9ucy5wcmVzZXJ2ZURyYXdpbmdCdWZmZXIsXG4gICAgICAgICAgICBwb3dlclByZWZlcmVuY2U6IF90aGlzLm9wdGlvbnMucG93ZXJQcmVmZXJlbmNlXG4gICAgICAgIH07XG5cbiAgICAgICAgX3RoaXMuX2JhY2tncm91bmRDb2xvclJnYmFbM10gPSBfdGhpcy50cmFuc3BhcmVudCA/IDAgOiAxO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYW5hZ2VzIHRoZSBtYXNrcyB1c2luZyB0aGUgc3RlbmNpbCBidWZmZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuTWFza01hbmFnZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5tYXNrTWFuYWdlciA9IG5ldyBfTWFza01hbmFnZXIyLmRlZmF1bHQoX3RoaXMpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYW5hZ2VzIHRoZSBzdGVuY2lsIGJ1ZmZlci5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5TdGVuY2lsTWFuYWdlcn1cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLnN0ZW5jaWxNYW5hZ2VyID0gbmV3IF9TdGVuY2lsTWFuYWdlcjIuZGVmYXVsdChfdGhpcyk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGVtcHR5IHJlbmRlcmVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLk9iamVjdFJlbmRlcmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuZW1wdHlSZW5kZXJlciA9IG5ldyBfT2JqZWN0UmVuZGVyZXIyLmRlZmF1bHQoX3RoaXMpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY3VycmVudGx5IGFjdGl2ZSBPYmplY3RSZW5kZXJlci5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5PYmplY3RSZW5kZXJlcn1cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLmN1cnJlbnRSZW5kZXJlciA9IF90aGlzLmVtcHR5UmVuZGVyZXI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1hbmFnZXMgdGV4dHVyZXNcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5UZXh0dXJlTWFuYWdlcn1cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLnRleHR1cmVNYW5hZ2VyID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogTWFuYWdlcyB0aGUgZmlsdGVycy5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5GaWx0ZXJNYW5hZ2VyfVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuZmlsdGVyTWFuYWdlciA9IG51bGw7XG5cbiAgICAgICAgX3RoaXMuaW5pdFBsdWdpbnMoKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGN1cnJlbnQgV2ViR0wgcmVuZGVyaW5nIGNvbnRleHQsIGl0IGlzIGNyZWF0ZWQgaGVyZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9XG4gICAgICAgICAqL1xuICAgICAgICAvLyBpbml0aWFsaXplIHRoZSBjb250ZXh0IHNvIGl0IGlzIHJlYWR5IGZvciB0aGUgbWFuYWdlcnMuXG4gICAgICAgIGlmIChfdGhpcy5vcHRpb25zLmNvbnRleHQpIHtcbiAgICAgICAgICAgIC8vIGNoZWNrcyB0byBzZWUgaWYgYSBjb250ZXh0IGlzIHZhbGlkLi5cbiAgICAgICAgICAgICgwLCBfdmFsaWRhdGVDb250ZXh0Mi5kZWZhdWx0KShfdGhpcy5vcHRpb25zLmNvbnRleHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMuZ2wgPSBfdGhpcy5vcHRpb25zLmNvbnRleHQgfHwgX3BpeGlHbENvcmUyLmRlZmF1bHQuY3JlYXRlQ29udGV4dChfdGhpcy52aWV3LCBfdGhpcy5fY29udGV4dE9wdGlvbnMpO1xuXG4gICAgICAgIF90aGlzLkNPTlRFWFRfVUlEID0gQ09OVEVYVF9VSUQrKztcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGN1cnJlbnRseSBhY3RpdmUgT2JqZWN0UmVuZGVyZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuV2ViR0xTdGF0ZX1cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLnN0YXRlID0gbmV3IF9XZWJHTFN0YXRlMi5kZWZhdWx0KF90aGlzLmdsKTtcblxuICAgICAgICBfdGhpcy5yZW5kZXJpbmdUb1NjcmVlbiA9IHRydWU7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhvbGRzIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRleHR1cmVzIGJvdW5kIHRvIHRoZSBHUFUuXG4gICAgICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLmJvdW5kVGV4dHVyZXMgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIb2xkcyB0aGUgY3VycmVudCBzaGFkZXJcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5TaGFkZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5fYWN0aXZlU2hhZGVyID0gbnVsbDtcblxuICAgICAgICBfdGhpcy5fYWN0aXZlVmFvID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSG9sZHMgdGhlIGN1cnJlbnQgcmVuZGVyIHRhcmdldFxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLlJlbmRlclRhcmdldH1cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLl9hY3RpdmVSZW5kZXJUYXJnZXQgPSBudWxsO1xuXG4gICAgICAgIF90aGlzLl9pbml0Q29udGV4dCgpO1xuXG4gICAgICAgIC8vIG1hcCBzb21lIHdlYkdMIGJsZW5kIGFuZCBkcmF3bW9kZXMuLlxuICAgICAgICBfdGhpcy5kcmF3TW9kZXMgPSAoMCwgX21hcFdlYkdMRHJhd01vZGVzVG9QaXhpMi5kZWZhdWx0KShfdGhpcy5nbCk7XG5cbiAgICAgICAgX3RoaXMuX25leHRUZXh0dXJlTG9jYXRpb24gPSAwO1xuXG4gICAgICAgIF90aGlzLnNldEJsZW5kTW9kZSgwKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZWQgYWZ0ZXIgcmVuZGVyaW5nIGZpbmlzaGVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXZlbnQgUElYSS5XZWJHTFJlbmRlcmVyI3Bvc3RyZW5kZXJcbiAgICAgICAgICovXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVkIGJlZm9yZSByZW5kZXJpbmcgc3RhcnRzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXZlbnQgUElYSS5XZWJHTFJlbmRlcmVyI3ByZXJlbmRlclxuICAgICAgICAgKi9cblxuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZWQgd2hlbiB0aGUgV2ViR0wgY29udGV4dCBpcyBzZXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBldmVudCBQSVhJLldlYkdMUmVuZGVyZXIjY29udGV4dFxuICAgICAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgLSBXZWJHTCBjb250ZXh0LlxuICAgICAgICAgKi9cbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhlIFdlYkdMIGNvbnRleHRcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cblxuICAgIFdlYkdMUmVuZGVyZXIucHJvdG90eXBlLl9pbml0Q29udGV4dCA9IGZ1bmN0aW9uIF9pbml0Q29udGV4dCgpIHtcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbDtcblxuICAgICAgICAvLyByZXN0b3JlIGEgY29udGV4dCBpZiBpdCB3YXMgcHJldmlvdXNseSBsb3N0XG4gICAgICAgIGlmIChnbC5pc0NvbnRleHRMb3N0KCkgJiYgZ2wuZ2V0RXh0ZW5zaW9uKCdXRUJHTF9sb3NlX2NvbnRleHQnKSkge1xuICAgICAgICAgICAgZ2wuZ2V0RXh0ZW5zaW9uKCdXRUJHTF9sb3NlX2NvbnRleHQnKS5yZXN0b3JlQ29udGV4dCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1heFRleHR1cmVzID0gZ2wuZ2V0UGFyYW1ldGVyKGdsLk1BWF9URVhUVVJFX0lNQUdFX1VOSVRTKTtcblxuICAgICAgICB0aGlzLl9hY3RpdmVTaGFkZXIgPSBudWxsO1xuICAgICAgICB0aGlzLl9hY3RpdmVWYW8gPSBudWxsO1xuXG4gICAgICAgIHRoaXMuYm91bmRUZXh0dXJlcyA9IG5ldyBBcnJheShtYXhUZXh0dXJlcyk7XG4gICAgICAgIHRoaXMuZW1wdHlUZXh0dXJlcyA9IG5ldyBBcnJheShtYXhUZXh0dXJlcyk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpZCBzb21lb25lIHRlbXBlciB3aXRoIHRleHR1cmVzIHN0YXRlPyBXZSdsbCBvdmVyd3JpdGUgdGhlbSB3aGVuIHdlIG5lZWQgdG8gdW5iaW5kIHNvbWV0aGluZy5cbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3Vua25vd25Cb3VuZFRleHR1cmVzID0gZmFsc2U7XG5cbiAgICAgICAgLy8gY3JlYXRlIGEgdGV4dHVyZSBtYW5hZ2VyLi4uXG4gICAgICAgIHRoaXMudGV4dHVyZU1hbmFnZXIgPSBuZXcgX1RleHR1cmVNYW5hZ2VyMi5kZWZhdWx0KHRoaXMpO1xuICAgICAgICB0aGlzLmZpbHRlck1hbmFnZXIgPSBuZXcgX0ZpbHRlck1hbmFnZXIyLmRlZmF1bHQodGhpcyk7XG4gICAgICAgIHRoaXMudGV4dHVyZUdDID0gbmV3IF9UZXh0dXJlR2FyYmFnZUNvbGxlY3RvcjIuZGVmYXVsdCh0aGlzKTtcblxuICAgICAgICB0aGlzLnN0YXRlLnJlc2V0VG9EZWZhdWx0KCk7XG5cbiAgICAgICAgdGhpcy5yb290UmVuZGVyVGFyZ2V0ID0gbmV3IF9SZW5kZXJUYXJnZXQyLmRlZmF1bHQoZ2wsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCBudWxsLCB0aGlzLnJlc29sdXRpb24sIHRydWUpO1xuICAgICAgICB0aGlzLnJvb3RSZW5kZXJUYXJnZXQuY2xlYXJDb2xvciA9IHRoaXMuX2JhY2tncm91bmRDb2xvclJnYmE7XG5cbiAgICAgICAgdGhpcy5iaW5kUmVuZGVyVGFyZ2V0KHRoaXMucm9vdFJlbmRlclRhcmdldCk7XG5cbiAgICAgICAgLy8gbm93IGxldHMgZmlsbCB1cCB0aGUgdGV4dHVyZXMgd2l0aCBlbXB0eSBvbmVzIVxuICAgICAgICB2YXIgZW1wdHlHTFRleHR1cmUgPSBuZXcgX3BpeGlHbENvcmUyLmRlZmF1bHQuR0xUZXh0dXJlLmZyb21EYXRhKGdsLCBudWxsLCAxLCAxKTtcblxuICAgICAgICB2YXIgdGVtcE9iaiA9IHsgX2dsVGV4dHVyZXM6IHt9IH07XG5cbiAgICAgICAgdGVtcE9iai5fZ2xUZXh0dXJlc1t0aGlzLkNPTlRFWFRfVUlEXSA9IHt9O1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWF4VGV4dHVyZXM7IGkrKykge1xuICAgICAgICAgICAgdmFyIGVtcHR5ID0gbmV3IF9CYXNlVGV4dHVyZTIuZGVmYXVsdCgpO1xuXG4gICAgICAgICAgICBlbXB0eS5fZ2xUZXh0dXJlc1t0aGlzLkNPTlRFWFRfVUlEXSA9IGVtcHR5R0xUZXh0dXJlO1xuXG4gICAgICAgICAgICB0aGlzLmJvdW5kVGV4dHVyZXNbaV0gPSB0ZW1wT2JqO1xuICAgICAgICAgICAgdGhpcy5lbXB0eVRleHR1cmVzW2ldID0gZW1wdHk7XG4gICAgICAgICAgICB0aGlzLmJpbmRUZXh0dXJlKG51bGwsIGkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5lbWl0KCdjb250ZXh0JywgZ2wpO1xuXG4gICAgICAgIC8vIHNldHVwIHRoZSB3aWR0aC9oZWlnaHQgcHJvcGVydGllcyBhbmQgZ2wgdmlld3BvcnRcbiAgICAgICAgdGhpcy5yZXNpemUodGhpcy5zY3JlZW4ud2lkdGgsIHRoaXMuc2NyZWVuLmhlaWdodCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgdGhlIG9iamVjdCB0byBpdHMgd2ViR0wgdmlld1xuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLkRpc3BsYXlPYmplY3R9IGRpc3BsYXlPYmplY3QgLSB0aGUgb2JqZWN0IHRvIGJlIHJlbmRlcmVkXG4gICAgICogQHBhcmFtIHtQSVhJLlJlbmRlclRleHR1cmV9IHJlbmRlclRleHR1cmUgLSBUaGUgcmVuZGVyIHRleHR1cmUgdG8gcmVuZGVyIHRvLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2NsZWFyXSAtIFNob3VsZCB0aGUgY2FudmFzIGJlIGNsZWFyZWQgYmVmb3JlIHRoZSBuZXcgcmVuZGVyXG4gICAgICogQHBhcmFtIHtQSVhJLk1hdHJpeH0gW3RyYW5zZm9ybV0gLSBBIHRyYW5zZm9ybSB0byBhcHBseSB0byB0aGUgcmVuZGVyIHRleHR1cmUgYmVmb3JlIHJlbmRlcmluZy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtza2lwVXBkYXRlVHJhbnNmb3JtXSAtIFNob3VsZCB3ZSBza2lwIHRoZSB1cGRhdGUgdHJhbnNmb3JtIHBhc3M/XG4gICAgICovXG5cblxuICAgIFdlYkdMUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcihkaXNwbGF5T2JqZWN0LCByZW5kZXJUZXh0dXJlLCBjbGVhciwgdHJhbnNmb3JtLCBza2lwVXBkYXRlVHJhbnNmb3JtKSB7XG4gICAgICAgIC8vIGNhbiBiZSBoYW5keSB0byBrbm93IVxuICAgICAgICB0aGlzLnJlbmRlcmluZ1RvU2NyZWVuID0gIXJlbmRlclRleHR1cmU7XG5cbiAgICAgICAgdGhpcy5lbWl0KCdwcmVyZW5kZXInKTtcblxuICAgICAgICAvLyBubyBwb2ludCByZW5kZXJpbmcgaWYgb3VyIGNvbnRleHQgaGFzIGJlZW4gYmxvd24gdXAhXG4gICAgICAgIGlmICghdGhpcy5nbCB8fCB0aGlzLmdsLmlzQ29udGV4dExvc3QoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbmV4dFRleHR1cmVMb2NhdGlvbiA9IDA7XG5cbiAgICAgICAgaWYgKCFyZW5kZXJUZXh0dXJlKSB7XG4gICAgICAgICAgICB0aGlzLl9sYXN0T2JqZWN0UmVuZGVyZWQgPSBkaXNwbGF5T2JqZWN0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFza2lwVXBkYXRlVHJhbnNmb3JtKSB7XG4gICAgICAgICAgICAvLyB1cGRhdGUgdGhlIHNjZW5lIGdyYXBoXG4gICAgICAgICAgICB2YXIgY2FjaGVQYXJlbnQgPSBkaXNwbGF5T2JqZWN0LnBhcmVudDtcblxuICAgICAgICAgICAgZGlzcGxheU9iamVjdC5wYXJlbnQgPSB0aGlzLl90ZW1wRGlzcGxheU9iamVjdFBhcmVudDtcbiAgICAgICAgICAgIGRpc3BsYXlPYmplY3QudXBkYXRlVHJhbnNmb3JtKCk7XG4gICAgICAgICAgICBkaXNwbGF5T2JqZWN0LnBhcmVudCA9IGNhY2hlUGFyZW50O1xuICAgICAgICAgICAgLy8gZGlzcGxheU9iamVjdC5oaXRBcmVhID0gLy9UT0RPIGFkZCBhIHRlbXAgaGl0IGFyZWFcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYmluZFJlbmRlclRleHR1cmUocmVuZGVyVGV4dHVyZSwgdHJhbnNmb3JtKTtcblxuICAgICAgICB0aGlzLmN1cnJlbnRSZW5kZXJlci5zdGFydCgpO1xuXG4gICAgICAgIGlmIChjbGVhciAhPT0gdW5kZWZpbmVkID8gY2xlYXIgOiB0aGlzLmNsZWFyQmVmb3JlUmVuZGVyKSB7XG4gICAgICAgICAgICB0aGlzLl9hY3RpdmVSZW5kZXJUYXJnZXQuY2xlYXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRpc3BsYXlPYmplY3QucmVuZGVyV2ViR0wodGhpcyk7XG5cbiAgICAgICAgLy8gYXBwbHkgdHJhbnNmb3JtLi5cbiAgICAgICAgdGhpcy5jdXJyZW50UmVuZGVyZXIuZmx1c2goKTtcblxuICAgICAgICAvLyB0aGlzLnNldE9iamVjdFJlbmRlcmVyKHRoaXMuZW1wdHlSZW5kZXJlcik7XG5cbiAgICAgICAgdGhpcy50ZXh0dXJlR0MudXBkYXRlKCk7XG5cbiAgICAgICAgdGhpcy5lbWl0KCdwb3N0cmVuZGVyJyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENoYW5nZXMgdGhlIGN1cnJlbnQgcmVuZGVyZXIgdG8gdGhlIG9uZSBnaXZlbiBpbiBwYXJhbWV0ZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5PYmplY3RSZW5kZXJlcn0gb2JqZWN0UmVuZGVyZXIgLSBUaGUgb2JqZWN0IHJlbmRlcmVyIHRvIHVzZS5cbiAgICAgKi9cblxuXG4gICAgV2ViR0xSZW5kZXJlci5wcm90b3R5cGUuc2V0T2JqZWN0UmVuZGVyZXIgPSBmdW5jdGlvbiBzZXRPYmplY3RSZW5kZXJlcihvYmplY3RSZW5kZXJlcikge1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50UmVuZGVyZXIgPT09IG9iamVjdFJlbmRlcmVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmN1cnJlbnRSZW5kZXJlci5zdG9wKCk7XG4gICAgICAgIHRoaXMuY3VycmVudFJlbmRlcmVyID0gb2JqZWN0UmVuZGVyZXI7XG4gICAgICAgIHRoaXMuY3VycmVudFJlbmRlcmVyLnN0YXJ0KCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgc2hvdWxkIGJlIGNhbGxlZCBpZiB5b3Ugd2lzaCB0byBkbyBzb21lIGN1c3RvbSByZW5kZXJpbmdcbiAgICAgKiBJdCB3aWxsIGJhc2ljYWxseSByZW5kZXIgYW55dGhpbmcgdGhhdCBtYXkgYmUgYmF0Y2hlZCB1cCBzdWNoIGFzIHNwcml0ZXNcbiAgICAgKlxuICAgICAqL1xuXG5cbiAgICBXZWJHTFJlbmRlcmVyLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uIGZsdXNoKCkge1xuICAgICAgICB0aGlzLnNldE9iamVjdFJlbmRlcmVyKHRoaXMuZW1wdHlSZW5kZXJlcik7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlc2l6ZXMgdGhlIHdlYkdMIHZpZXcgdG8gdGhlIHNwZWNpZmllZCB3aWR0aCBhbmQgaGVpZ2h0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNjcmVlbldpZHRoIC0gdGhlIG5ldyB3aWR0aCBvZiB0aGUgc2NyZWVuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNjcmVlbkhlaWdodCAtIHRoZSBuZXcgaGVpZ2h0IG9mIHRoZSBzY3JlZW5cbiAgICAgKi9cblxuXG4gICAgV2ViR0xSZW5kZXJlci5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24gcmVzaXplKHNjcmVlbldpZHRoLCBzY3JlZW5IZWlnaHQpIHtcbiAgICAgICAgLy8gIGlmKHdpZHRoICogdGhpcy5yZXNvbHV0aW9uID09PSB0aGlzLndpZHRoICYmIGhlaWdodCAqIHRoaXMucmVzb2x1dGlvbiA9PT0gdGhpcy5oZWlnaHQpcmV0dXJuO1xuXG4gICAgICAgIF9TeXN0ZW1SZW5kZXJlcjMuZGVmYXVsdC5wcm90b3R5cGUucmVzaXplLmNhbGwodGhpcywgc2NyZWVuV2lkdGgsIHNjcmVlbkhlaWdodCk7XG5cbiAgICAgICAgdGhpcy5yb290UmVuZGVyVGFyZ2V0LnJlc2l6ZShzY3JlZW5XaWR0aCwgc2NyZWVuSGVpZ2h0KTtcblxuICAgICAgICBpZiAodGhpcy5fYWN0aXZlUmVuZGVyVGFyZ2V0ID09PSB0aGlzLnJvb3RSZW5kZXJUYXJnZXQpIHtcbiAgICAgICAgICAgIHRoaXMucm9vdFJlbmRlclRhcmdldC5hY3RpdmF0ZSgpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fYWN0aXZlU2hhZGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0aXZlU2hhZGVyLnVuaWZvcm1zLnByb2plY3Rpb25NYXRyaXggPSB0aGlzLnJvb3RSZW5kZXJUYXJnZXQucHJvamVjdGlvbk1hdHJpeC50b0FycmF5KHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlc2l6ZXMgdGhlIHdlYkdMIHZpZXcgdG8gdGhlIHNwZWNpZmllZCB3aWR0aCBhbmQgaGVpZ2h0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJsZW5kTW9kZSAtIHRoZSBkZXNpcmVkIGJsZW5kIG1vZGVcbiAgICAgKi9cblxuXG4gICAgV2ViR0xSZW5kZXJlci5wcm90b3R5cGUuc2V0QmxlbmRNb2RlID0gZnVuY3Rpb24gc2V0QmxlbmRNb2RlKGJsZW5kTW9kZSkge1xuICAgICAgICB0aGlzLnN0YXRlLnNldEJsZW5kTW9kZShibGVuZE1vZGUpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBFcmFzZXMgdGhlIGFjdGl2ZSByZW5kZXIgdGFyZ2V0IGFuZCBmaWxscyB0aGUgZHJhd2luZyBhcmVhIHdpdGggYSBjb2xvdXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbY2xlYXJDb2xvcl0gLSBUaGUgY29sb3VyXG4gICAgICovXG5cblxuICAgIFdlYkdMUmVuZGVyZXIucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIoY2xlYXJDb2xvcikge1xuICAgICAgICB0aGlzLl9hY3RpdmVSZW5kZXJUYXJnZXQuY2xlYXIoY2xlYXJDb2xvcik7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHRyYW5zZm9ybSBvZiB0aGUgYWN0aXZlIHJlbmRlciB0YXJnZXQgdG8gdGhlIGdpdmVuIG1hdHJpeFxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLk1hdHJpeH0gbWF0cml4IC0gVGhlIHRyYW5zZm9ybWF0aW9uIG1hdHJpeFxuICAgICAqL1xuXG5cbiAgICBXZWJHTFJlbmRlcmVyLnByb3RvdHlwZS5zZXRUcmFuc2Zvcm0gPSBmdW5jdGlvbiBzZXRUcmFuc2Zvcm0obWF0cml4KSB7XG4gICAgICAgIHRoaXMuX2FjdGl2ZVJlbmRlclRhcmdldC50cmFuc2Zvcm0gPSBtYXRyaXg7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEVyYXNlcyB0aGUgcmVuZGVyIHRleHR1cmUgYW5kIGZpbGxzIHRoZSBkcmF3aW5nIGFyZWEgd2l0aCBhIGNvbG91clxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLlJlbmRlclRleHR1cmV9IHJlbmRlclRleHR1cmUgLSBUaGUgcmVuZGVyIHRleHR1cmUgdG8gY2xlYXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2NsZWFyQ29sb3JdIC0gVGhlIGNvbG91clxuICAgICAqIEByZXR1cm4ge1BJWEkuV2ViR0xSZW5kZXJlcn0gUmV0dXJucyBpdHNlbGYuXG4gICAgICovXG5cblxuICAgIFdlYkdMUmVuZGVyZXIucHJvdG90eXBlLmNsZWFyUmVuZGVyVGV4dHVyZSA9IGZ1bmN0aW9uIGNsZWFyUmVuZGVyVGV4dHVyZShyZW5kZXJUZXh0dXJlLCBjbGVhckNvbG9yKSB7XG4gICAgICAgIHZhciBiYXNlVGV4dHVyZSA9IHJlbmRlclRleHR1cmUuYmFzZVRleHR1cmU7XG4gICAgICAgIHZhciByZW5kZXJUYXJnZXQgPSBiYXNlVGV4dHVyZS5fZ2xSZW5kZXJUYXJnZXRzW3RoaXMuQ09OVEVYVF9VSURdO1xuXG4gICAgICAgIGlmIChyZW5kZXJUYXJnZXQpIHtcbiAgICAgICAgICAgIHJlbmRlclRhcmdldC5jbGVhcihjbGVhckNvbG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBCaW5kcyBhIHJlbmRlciB0ZXh0dXJlIGZvciByZW5kZXJpbmdcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5SZW5kZXJUZXh0dXJlfSByZW5kZXJUZXh0dXJlIC0gVGhlIHJlbmRlciB0ZXh0dXJlIHRvIHJlbmRlclxuICAgICAqIEBwYXJhbSB7UElYSS5NYXRyaXh9IHRyYW5zZm9ybSAtIFRoZSB0cmFuc2Zvcm0gdG8gYmUgYXBwbGllZCB0byB0aGUgcmVuZGVyIHRleHR1cmVcbiAgICAgKiBAcmV0dXJuIHtQSVhJLldlYkdMUmVuZGVyZXJ9IFJldHVybnMgaXRzZWxmLlxuICAgICAqL1xuXG5cbiAgICBXZWJHTFJlbmRlcmVyLnByb3RvdHlwZS5iaW5kUmVuZGVyVGV4dHVyZSA9IGZ1bmN0aW9uIGJpbmRSZW5kZXJUZXh0dXJlKHJlbmRlclRleHR1cmUsIHRyYW5zZm9ybSkge1xuICAgICAgICB2YXIgcmVuZGVyVGFyZ2V0ID0gdm9pZCAwO1xuXG4gICAgICAgIGlmIChyZW5kZXJUZXh0dXJlKSB7XG4gICAgICAgICAgICB2YXIgYmFzZVRleHR1cmUgPSByZW5kZXJUZXh0dXJlLmJhc2VUZXh0dXJlO1xuXG4gICAgICAgICAgICBpZiAoIWJhc2VUZXh0dXJlLl9nbFJlbmRlclRhcmdldHNbdGhpcy5DT05URVhUX1VJRF0pIHtcbiAgICAgICAgICAgICAgICAvLyBiaW5kIHRoZSBjdXJyZW50IHRleHR1cmVcbiAgICAgICAgICAgICAgICB0aGlzLnRleHR1cmVNYW5hZ2VyLnVwZGF0ZVRleHR1cmUoYmFzZVRleHR1cmUsIDApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnVuYmluZFRleHR1cmUoYmFzZVRleHR1cmUpO1xuXG4gICAgICAgICAgICByZW5kZXJUYXJnZXQgPSBiYXNlVGV4dHVyZS5fZ2xSZW5kZXJUYXJnZXRzW3RoaXMuQ09OVEVYVF9VSURdO1xuICAgICAgICAgICAgcmVuZGVyVGFyZ2V0LnNldEZyYW1lKHJlbmRlclRleHR1cmUuZnJhbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVuZGVyVGFyZ2V0ID0gdGhpcy5yb290UmVuZGVyVGFyZ2V0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmVuZGVyVGFyZ2V0LnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgICAgICAgdGhpcy5iaW5kUmVuZGVyVGFyZ2V0KHJlbmRlclRhcmdldCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENoYW5nZXMgdGhlIGN1cnJlbnQgcmVuZGVyIHRhcmdldCB0byB0aGUgb25lIGdpdmVuIGluIHBhcmFtZXRlclxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLlJlbmRlclRhcmdldH0gcmVuZGVyVGFyZ2V0IC0gdGhlIG5ldyByZW5kZXIgdGFyZ2V0XG4gICAgICogQHJldHVybiB7UElYSS5XZWJHTFJlbmRlcmVyfSBSZXR1cm5zIGl0c2VsZi5cbiAgICAgKi9cblxuXG4gICAgV2ViR0xSZW5kZXJlci5wcm90b3R5cGUuYmluZFJlbmRlclRhcmdldCA9IGZ1bmN0aW9uIGJpbmRSZW5kZXJUYXJnZXQocmVuZGVyVGFyZ2V0KSB7XG4gICAgICAgIGlmIChyZW5kZXJUYXJnZXQgIT09IHRoaXMuX2FjdGl2ZVJlbmRlclRhcmdldCkge1xuICAgICAgICAgICAgdGhpcy5fYWN0aXZlUmVuZGVyVGFyZ2V0ID0gcmVuZGVyVGFyZ2V0O1xuICAgICAgICAgICAgcmVuZGVyVGFyZ2V0LmFjdGl2YXRlKCk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9hY3RpdmVTaGFkZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3RpdmVTaGFkZXIudW5pZm9ybXMucHJvamVjdGlvbk1hdHJpeCA9IHJlbmRlclRhcmdldC5wcm9qZWN0aW9uTWF0cml4LnRvQXJyYXkodHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuc3RlbmNpbE1hbmFnZXIuc2V0TWFza1N0YWNrKHJlbmRlclRhcmdldC5zdGVuY2lsTWFza1N0YWNrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGFuZ2VzIHRoZSBjdXJyZW50IHNoYWRlciB0byB0aGUgb25lIGdpdmVuIGluIHBhcmFtZXRlclxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLlNoYWRlcn0gc2hhZGVyIC0gdGhlIG5ldyBzaGFkZXJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFthdXRvUHJvamVjdD10cnVlXSAtIFdoZXRoZXIgYXV0b21hdGljYWxseSBzZXQgdGhlIHByb2plY3Rpb24gbWF0cml4XG4gICAgICogQHJldHVybiB7UElYSS5XZWJHTFJlbmRlcmVyfSBSZXR1cm5zIGl0c2VsZi5cbiAgICAgKi9cblxuXG4gICAgV2ViR0xSZW5kZXJlci5wcm90b3R5cGUuYmluZFNoYWRlciA9IGZ1bmN0aW9uIGJpbmRTaGFkZXIoc2hhZGVyLCBhdXRvUHJvamVjdCkge1xuICAgICAgICAvLyBUT0RPIGNhY2hlXG4gICAgICAgIGlmICh0aGlzLl9hY3RpdmVTaGFkZXIgIT09IHNoYWRlcikge1xuICAgICAgICAgICAgdGhpcy5fYWN0aXZlU2hhZGVyID0gc2hhZGVyO1xuICAgICAgICAgICAgc2hhZGVyLmJpbmQoKTtcblxuICAgICAgICAgICAgLy8gYGF1dG9Qcm9qZWN0YCBub3JtYWxseSB3b3VsZCBiZSBhIGRlZmF1bHQgcGFyYW1ldGVyIHNldCB0byB0cnVlXG4gICAgICAgICAgICAvLyBidXQgYmVjYXVzZSBvZiBob3cgQmFiZWwgdHJhbnNwaWxlcyBkZWZhdWx0IHBhcmFtZXRlcnNcbiAgICAgICAgICAgIC8vIGl0IGhpbmRlcnMgdGhlIHBlcmZvcm1hbmNlIG9mIHRoaXMgbWV0aG9kLlxuICAgICAgICAgICAgaWYgKGF1dG9Qcm9qZWN0ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIC8vIGF1dG9tYXRpY2FsbHkgc2V0IHRoZSBwcm9qZWN0aW9uIG1hdHJpeFxuICAgICAgICAgICAgICAgIHNoYWRlci51bmlmb3Jtcy5wcm9qZWN0aW9uTWF0cml4ID0gdGhpcy5fYWN0aXZlUmVuZGVyVGFyZ2V0LnByb2plY3Rpb25NYXRyaXgudG9BcnJheSh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBCaW5kcyB0aGUgdGV4dHVyZS4gVGhpcyB3aWxsIHJldHVybiB0aGUgbG9jYXRpb24gb2YgdGhlIGJvdW5kIHRleHR1cmUuXG4gICAgICogSXQgbWF5IG5vdCBiZSB0aGUgc2FtZSBhcyB0aGUgb25lIHlvdSBwYXNzIGluLiBUaGlzIGlzIGR1ZSB0byBvcHRpbWlzYXRpb24gdGhhdCBwcmV2ZW50c1xuICAgICAqIG5lZWRsZXNzIGJpbmRpbmcgb2YgdGV4dHVyZXMuIEZvciBleGFtcGxlIGlmIHRoZSB0ZXh0dXJlIGlzIGFscmVhZHkgYm91bmQgaXQgd2lsbCByZXR1cm4gdGhlXG4gICAgICogY3VycmVudCBsb2NhdGlvbiBvZiB0aGUgdGV4dHVyZSBpbnN0ZWFkIG9mIHRoZSBvbmUgcHJvdmlkZWQuIFRvIGJ5cGFzcyB0aGlzIHVzZSBmb3JjZSBsb2NhdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLlRleHR1cmV9IHRleHR1cmUgLSB0aGUgbmV3IHRleHR1cmVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbG9jYXRpb24gLSB0aGUgc3VnZ2VzdGVkIHRleHR1cmUgbG9jYXRpb25cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZvcmNlTG9jYXRpb24gLSBmb3JjZSB0aGUgbG9jYXRpb25cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IGJvdW5kIHRleHR1cmUgbG9jYXRpb25cbiAgICAgKi9cblxuXG4gICAgV2ViR0xSZW5kZXJlci5wcm90b3R5cGUuYmluZFRleHR1cmUgPSBmdW5jdGlvbiBiaW5kVGV4dHVyZSh0ZXh0dXJlLCBsb2NhdGlvbiwgZm9yY2VMb2NhdGlvbikge1xuICAgICAgICB0ZXh0dXJlID0gdGV4dHVyZSB8fCB0aGlzLmVtcHR5VGV4dHVyZXNbbG9jYXRpb25dO1xuICAgICAgICB0ZXh0dXJlID0gdGV4dHVyZS5iYXNlVGV4dHVyZSB8fCB0ZXh0dXJlO1xuICAgICAgICB0ZXh0dXJlLnRvdWNoZWQgPSB0aGlzLnRleHR1cmVHQy5jb3VudDtcblxuICAgICAgICBpZiAoIWZvcmNlTG9jYXRpb24pIHtcbiAgICAgICAgICAgIC8vIFRPRE8gLSBtYXliZSBsb29rIGludG8gYWRkaW5nIGJvdW5kSWRzLi4gc2F2ZSB1cyB0aGUgbG9vcD9cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ib3VuZFRleHR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYm91bmRUZXh0dXJlc1tpXSA9PT0gdGV4dHVyZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChsb2NhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbmV4dFRleHR1cmVMb2NhdGlvbisrO1xuICAgICAgICAgICAgICAgIHRoaXMuX25leHRUZXh0dXJlTG9jYXRpb24gJT0gdGhpcy5ib3VuZFRleHR1cmVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBsb2NhdGlvbiA9IHRoaXMuYm91bmRUZXh0dXJlcy5sZW5ndGggLSB0aGlzLl9uZXh0VGV4dHVyZUxvY2F0aW9uIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvY2F0aW9uID0gbG9jYXRpb24gfHwgMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2w7XG4gICAgICAgIHZhciBnbFRleHR1cmUgPSB0ZXh0dXJlLl9nbFRleHR1cmVzW3RoaXMuQ09OVEVYVF9VSURdO1xuXG4gICAgICAgIGlmICghZ2xUZXh0dXJlKSB7XG4gICAgICAgICAgICAvLyB0aGlzIHdpbGwgYWxzbyBiaW5kIHRoZSB0ZXh0dXJlLi5cbiAgICAgICAgICAgIHRoaXMudGV4dHVyZU1hbmFnZXIudXBkYXRlVGV4dHVyZSh0ZXh0dXJlLCBsb2NhdGlvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBiaW5kIHRoZSBjdXJyZW50IHRleHR1cmVcbiAgICAgICAgICAgIHRoaXMuYm91bmRUZXh0dXJlc1tsb2NhdGlvbl0gPSB0ZXh0dXJlO1xuICAgICAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIGxvY2F0aW9uKTtcbiAgICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIGdsVGV4dHVyZS50ZXh0dXJlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsb2NhdGlvbjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgKiB1bmJpbmRzIHRoZSB0ZXh0dXJlIC4uLlxuICAgICpcbiAgICAqIEBwYXJhbSB7UElYSS5UZXh0dXJlfSB0ZXh0dXJlIC0gdGhlIHRleHR1cmUgdG8gdW5iaW5kXG4gICAgKiBAcmV0dXJuIHtQSVhJLldlYkdMUmVuZGVyZXJ9IFJldHVybnMgaXRzZWxmLlxuICAgICovXG5cblxuICAgIFdlYkdMUmVuZGVyZXIucHJvdG90eXBlLnVuYmluZFRleHR1cmUgPSBmdW5jdGlvbiB1bmJpbmRUZXh0dXJlKHRleHR1cmUpIHtcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbDtcblxuICAgICAgICB0ZXh0dXJlID0gdGV4dHVyZS5iYXNlVGV4dHVyZSB8fCB0ZXh0dXJlO1xuXG4gICAgICAgIGlmICh0aGlzLl91bmtub3duQm91bmRUZXh0dXJlcykge1xuICAgICAgICAgICAgdGhpcy5fdW5rbm93bkJvdW5kVGV4dHVyZXMgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIHNvbWVvbmUgY2hhbmdlZCB3ZWJHTCBzdGF0ZSxcbiAgICAgICAgICAgIC8vIHdlIGhhdmUgdG8gYmUgc3VyZSB0aGF0IG91ciB0ZXh0dXJlIGRvZXMgbm90IGFwcGVhciBpbiBtdWx0aXRleHR1cmUgcmVuZGVyZXIgc2FtcGxlcnNcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmJvdW5kVGV4dHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ib3VuZFRleHR1cmVzW2ldID09PSB0aGlzLmVtcHR5VGV4dHVyZXNbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIGkpO1xuICAgICAgICAgICAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLmVtcHR5VGV4dHVyZXNbaV0uX2dsVGV4dHVyZXNbdGhpcy5DT05URVhUX1VJRF0udGV4dHVyZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHRoaXMuYm91bmRUZXh0dXJlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmJvdW5kVGV4dHVyZXNbX2ldID09PSB0ZXh0dXJlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ib3VuZFRleHR1cmVzW19pXSA9IHRoaXMuZW1wdHlUZXh0dXJlc1tfaV07XG5cbiAgICAgICAgICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwICsgX2kpO1xuICAgICAgICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMuZW1wdHlUZXh0dXJlc1tfaV0uX2dsVGV4dHVyZXNbdGhpcy5DT05URVhUX1VJRF0udGV4dHVyZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBWQU8gZnJvbSB0aGlzIHJlbmRlcmVyJ3MgY29udGV4dCBhbmQgc3RhdGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtWZXJ0ZXhBcnJheU9iamVjdH0gVGhlIG5ldyBWQU8uXG4gICAgICovXG5cblxuICAgIFdlYkdMUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZVZhbyA9IGZ1bmN0aW9uIGNyZWF0ZVZhbygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBfcGl4aUdsQ29yZTIuZGVmYXVsdC5WZXJ0ZXhBcnJheU9iamVjdCh0aGlzLmdsLCB0aGlzLnN0YXRlLmF0dHJpYlN0YXRlKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyB0aGUgY3VycmVudCBWYW8gdG8gdGhlIG9uZSBnaXZlbiBpbiBwYXJhbWV0ZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5WZXJ0ZXhBcnJheU9iamVjdH0gdmFvIC0gdGhlIG5ldyBWYW9cbiAgICAgKiBAcmV0dXJuIHtQSVhJLldlYkdMUmVuZGVyZXJ9IFJldHVybnMgaXRzZWxmLlxuICAgICAqL1xuXG5cbiAgICBXZWJHTFJlbmRlcmVyLnByb3RvdHlwZS5iaW5kVmFvID0gZnVuY3Rpb24gYmluZFZhbyh2YW8pIHtcbiAgICAgICAgaWYgKHRoaXMuX2FjdGl2ZVZhbyA9PT0gdmFvKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YW8pIHtcbiAgICAgICAgICAgIHZhby5iaW5kKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYWN0aXZlVmFvKSB7XG4gICAgICAgICAgICAvLyBUT0RPIHRoaXMgc2hvdWxkIGFsd2F5cyBiZSB0cnVlIGkgdGhpbms/XG4gICAgICAgICAgICB0aGlzLl9hY3RpdmVWYW8udW5iaW5kKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9hY3RpdmVWYW8gPSB2YW87XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlc2V0cyB0aGUgV2ViR0wgc3RhdGUgc28geW91IGNhbiByZW5kZXIgdGhpbmdzIGhvd2V2ZXIgeW91IGZhbmN5IVxuICAgICAqXG4gICAgICogQHJldHVybiB7UElYSS5XZWJHTFJlbmRlcmVyfSBSZXR1cm5zIGl0c2VsZi5cbiAgICAgKi9cblxuXG4gICAgV2ViR0xSZW5kZXJlci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgICAgdGhpcy5zZXRPYmplY3RSZW5kZXJlcih0aGlzLmVtcHR5UmVuZGVyZXIpO1xuXG4gICAgICAgIHRoaXMuYmluZFZhbyhudWxsKTtcbiAgICAgICAgdGhpcy5fYWN0aXZlU2hhZGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5fYWN0aXZlUmVuZGVyVGFyZ2V0ID0gdGhpcy5yb290UmVuZGVyVGFyZ2V0O1xuXG4gICAgICAgIHRoaXMuX3Vua25vd25Cb3VuZFRleHR1cmVzID0gdHJ1ZTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYm91bmRUZXh0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5ib3VuZFRleHR1cmVzW2ldID0gdGhpcy5lbXB0eVRleHR1cmVzW2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYmluZCB0aGUgbWFpbiBmcmFtZSBidWZmZXIgKHRoZSBzY3JlZW4pO1xuICAgICAgICB0aGlzLnJvb3RSZW5kZXJUYXJnZXQuYWN0aXZhdGUoKTtcblxuICAgICAgICB0aGlzLnN0YXRlLnJlc2V0VG9EZWZhdWx0KCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgYSBsb3N0IHdlYmdsIGNvbnRleHRcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtXZWJHTENvbnRleHRFdmVudH0gZXZlbnQgLSBUaGUgY29udGV4dCBsb3N0IGV2ZW50LlxuICAgICAqL1xuXG5cbiAgICBXZWJHTFJlbmRlcmVyLnByb3RvdHlwZS5oYW5kbGVDb250ZXh0TG9zdCA9IGZ1bmN0aW9uIGhhbmRsZUNvbnRleHRMb3N0KGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgYSByZXN0b3JlZCB3ZWJnbCBjb250ZXh0XG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG5cbiAgICBXZWJHTFJlbmRlcmVyLnByb3RvdHlwZS5oYW5kbGVDb250ZXh0UmVzdG9yZWQgPSBmdW5jdGlvbiBoYW5kbGVDb250ZXh0UmVzdG9yZWQoKSB7XG4gICAgICAgIHRoaXMudGV4dHVyZU1hbmFnZXIucmVtb3ZlQWxsKCk7XG4gICAgICAgIHRoaXMuZmlsdGVyTWFuYWdlci5kZXN0cm95KHRydWUpO1xuICAgICAgICB0aGlzLl9pbml0Q29udGV4dCgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGV2ZXJ5dGhpbmcgZnJvbSB0aGUgcmVuZGVyZXIgKGV2ZW50IGxpc3RlbmVycywgc3ByaXRlYmF0Y2gsIGV0Yy4uLilcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JlbW92ZVZpZXc9ZmFsc2VdIC0gUmVtb3ZlcyB0aGUgQ2FudmFzIGVsZW1lbnQgZnJvbSB0aGUgRE9NLlxuICAgICAqICBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9waXhpanMvcGl4aS5qcy9pc3N1ZXMvMjIzM1xuICAgICAqL1xuXG5cbiAgICBXZWJHTFJlbmRlcmVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveShyZW1vdmVWaWV3KSB7XG4gICAgICAgIHRoaXMuZGVzdHJveVBsdWdpbnMoKTtcblxuICAgICAgICAvLyByZW1vdmUgbGlzdGVuZXJzXG4gICAgICAgIHRoaXMudmlldy5yZW1vdmVFdmVudExpc3RlbmVyKCd3ZWJnbGNvbnRleHRsb3N0JywgdGhpcy5oYW5kbGVDb250ZXh0TG9zdCk7XG4gICAgICAgIHRoaXMudmlldy5yZW1vdmVFdmVudExpc3RlbmVyKCd3ZWJnbGNvbnRleHRyZXN0b3JlZCcsIHRoaXMuaGFuZGxlQ29udGV4dFJlc3RvcmVkKTtcblxuICAgICAgICB0aGlzLnRleHR1cmVNYW5hZ2VyLmRlc3Ryb3koKTtcblxuICAgICAgICAvLyBjYWxsIGJhc2UgZGVzdHJveVxuICAgICAgICBfU3lzdGVtUmVuZGVyZXIucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzLCByZW1vdmVWaWV3KTtcblxuICAgICAgICB0aGlzLnVpZCA9IDA7XG5cbiAgICAgICAgLy8gZGVzdHJveSB0aGUgbWFuYWdlcnNcbiAgICAgICAgdGhpcy5tYXNrTWFuYWdlci5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuc3RlbmNpbE1hbmFnZXIuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmZpbHRlck1hbmFnZXIuZGVzdHJveSgpO1xuXG4gICAgICAgIHRoaXMubWFza01hbmFnZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmZpbHRlck1hbmFnZXIgPSBudWxsO1xuICAgICAgICB0aGlzLnRleHR1cmVNYW5hZ2VyID0gbnVsbDtcbiAgICAgICAgdGhpcy5jdXJyZW50UmVuZGVyZXIgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuaGFuZGxlQ29udGV4dExvc3QgPSBudWxsO1xuICAgICAgICB0aGlzLmhhbmRsZUNvbnRleHRSZXN0b3JlZCA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5fY29udGV4dE9wdGlvbnMgPSBudWxsO1xuICAgICAgICB0aGlzLmdsLnVzZVByb2dyYW0obnVsbCk7XG5cbiAgICAgICAgaWYgKHRoaXMuZ2wuZ2V0RXh0ZW5zaW9uKCdXRUJHTF9sb3NlX2NvbnRleHQnKSkge1xuICAgICAgICAgICAgdGhpcy5nbC5nZXRFeHRlbnNpb24oJ1dFQkdMX2xvc2VfY29udGV4dCcpLmxvc2VDb250ZXh0KCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmdsID0gbnVsbDtcblxuICAgICAgICAvLyB0aGlzID0gbnVsbDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFdlYkdMUmVuZGVyZXI7XG59KF9TeXN0ZW1SZW5kZXJlcjMuZGVmYXVsdCk7XG5cbi8qKlxuICogQ29sbGVjdGlvbiBvZiBpbnN0YWxsZWQgcGx1Z2lucy4gVGhlc2UgYXJlIGluY2x1ZGVkIGJ5IGRlZmF1bHQgaW4gUElYSSwgYnV0IGNhbiBiZSBleGNsdWRlZFxuICogYnkgY3JlYXRpbmcgYSBjdXN0b20gYnVpbGQuIENvbnN1bHQgdGhlIFJFQURNRSBmb3IgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCBjcmVhdGluZyBjdXN0b21cbiAqIGJ1aWxkcyBhbmQgZXhjbHVkaW5nIHBsdWdpbnMuXG4gKiBAbmFtZSBQSVhJLldlYkdMUmVuZGVyZXIjcGx1Z2luc1xuICogQHR5cGUge29iamVjdH1cbiAqIEByZWFkb25seVxuICogQHByb3BlcnR5IHtQSVhJLmFjY2Vzc2liaWxpdHkuQWNjZXNzaWJpbGl0eU1hbmFnZXJ9IGFjY2Vzc2liaWxpdHkgU3VwcG9ydCB0YWJiaW5nIGludGVyYWN0aXZlIGVsZW1lbnRzLlxuICogQHByb3BlcnR5IHtQSVhJLmV4dHJhY3QuV2ViR0xFeHRyYWN0fSBleHRyYWN0IEV4dHJhY3QgaW1hZ2UgZGF0YSBmcm9tIHJlbmRlcmVyLlxuICogQHByb3BlcnR5IHtQSVhJLmludGVyYWN0aW9uLkludGVyYWN0aW9uTWFuYWdlcn0gaW50ZXJhY3Rpb24gSGFuZGxlcyBtb3VzZSwgdG91Y2ggYW5kIHBvaW50ZXIgZXZlbnRzLlxuICogQHByb3BlcnR5IHtQSVhJLnByZXBhcmUuV2ViR0xQcmVwYXJlfSBwcmVwYXJlIFByZS1yZW5kZXIgZGlzcGxheSBvYmplY3RzLlxuICovXG5cbi8qKlxuICogQWRkcyBhIHBsdWdpbiB0byB0aGUgcmVuZGVyZXIuXG4gKlxuICogQG1ldGhvZCBQSVhJLldlYkdMUmVuZGVyZXIjcmVnaXN0ZXJQbHVnaW5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwbHVnaW5OYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHBsdWdpbi5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN0b3IgLSBUaGUgY29uc3RydWN0b3IgZnVuY3Rpb24gb3IgY2xhc3MgZm9yIHRoZSBwbHVnaW4uXG4gKi9cblxuZXhwb3J0cy5kZWZhdWx0ID0gV2ViR0xSZW5kZXJlcjtcbl91dGlscy5wbHVnaW5UYXJnZXQubWl4aW4oV2ViR0xSZW5kZXJlcik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1XZWJHTFJlbmRlcmVyLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9tYXBXZWJHTEJsZW5kTW9kZXNUb1BpeGkgPSByZXF1aXJlKCcuL3V0aWxzL21hcFdlYkdMQmxlbmRNb2Rlc1RvUGl4aScpO1xuXG52YXIgX21hcFdlYkdMQmxlbmRNb2Rlc1RvUGl4aTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tYXBXZWJHTEJsZW5kTW9kZXNUb1BpeGkpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgQkxFTkQgPSAwO1xudmFyIERFUFRIX1RFU1QgPSAxO1xudmFyIEZST05UX0ZBQ0UgPSAyO1xudmFyIENVTExfRkFDRSA9IDM7XG52YXIgQkxFTkRfRlVOQyA9IDQ7XG5cbi8qKlxuICogQSBXZWJHTCBzdGF0ZSBtYWNoaW5lc1xuICpcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKiBAY2xhc3NcbiAqL1xuXG52YXIgV2ViR0xTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgLSBUaGUgY3VycmVudCBXZWJHTCByZW5kZXJpbmcgY29udGV4dFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFdlYkdMU3RhdGUoZ2wpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFdlYkdMU3RhdGUpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY3VycmVudCBhY3RpdmUgc3RhdGVcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7VWludDhBcnJheX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYWN0aXZlU3RhdGUgPSBuZXcgVWludDhBcnJheSgxNik7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkZWZhdWx0IHN0YXRlXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge1VpbnQ4QXJyYXl9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRlZmF1bHRTdGF0ZSA9IG5ldyBVaW50OEFycmF5KDE2KTtcblxuICAgICAgICAvLyBkZWZhdWx0IGJsZW5kIG1vZGUuLlxuICAgICAgICB0aGlzLmRlZmF1bHRTdGF0ZVswXSA9IDE7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjdXJyZW50IHN0YXRlIGluZGV4IGluIHRoZSBzdGFja1xuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YWNrSW5kZXggPSAwO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgc3RhY2sgaG9sZGluZyBhbGwgdGhlIGRpZmZlcmVudCBzdGF0ZXNcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7QXJyYXk8Kj59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YWNrID0gW107XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjdXJyZW50IFdlYkdMIHJlbmRlcmluZyBjb250ZXh0XG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge1dlYkdMUmVuZGVyaW5nQ29udGV4dH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2wgPSBnbDtcblxuICAgICAgICB0aGlzLm1heEF0dHJpYnMgPSBnbC5nZXRQYXJhbWV0ZXIoZ2wuTUFYX1ZFUlRFWF9BVFRSSUJTKTtcblxuICAgICAgICB0aGlzLmF0dHJpYlN0YXRlID0ge1xuICAgICAgICAgICAgdGVtcEF0dHJpYlN0YXRlOiBuZXcgQXJyYXkodGhpcy5tYXhBdHRyaWJzKSxcbiAgICAgICAgICAgIGF0dHJpYlN0YXRlOiBuZXcgQXJyYXkodGhpcy5tYXhBdHRyaWJzKVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuYmxlbmRNb2RlcyA9ICgwLCBfbWFwV2ViR0xCbGVuZE1vZGVzVG9QaXhpMi5kZWZhdWx0KShnbCk7XG5cbiAgICAgICAgLy8gY2hlY2sgd2UgaGF2ZSB2YW8uLlxuICAgICAgICB0aGlzLm5hdGl2ZVZhb0V4dGVuc2lvbiA9IGdsLmdldEV4dGVuc2lvbignT0VTX3ZlcnRleF9hcnJheV9vYmplY3QnKSB8fCBnbC5nZXRFeHRlbnNpb24oJ01PWl9PRVNfdmVydGV4X2FycmF5X29iamVjdCcpIHx8IGdsLmdldEV4dGVuc2lvbignV0VCS0lUX09FU192ZXJ0ZXhfYXJyYXlfb2JqZWN0Jyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHVzaGVzIGEgbmV3IGFjdGl2ZSBzdGF0ZVxuICAgICAqL1xuXG5cbiAgICBXZWJHTFN0YXRlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gcHVzaCgpIHtcbiAgICAgICAgLy8gbmV4dCBzdGF0ZS4uXG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhY2tbdGhpcy5zdGFja0luZGV4XTtcblxuICAgICAgICBpZiAoIXN0YXRlKSB7XG4gICAgICAgICAgICBzdGF0ZSA9IHRoaXMuc3RhY2tbdGhpcy5zdGFja0luZGV4XSA9IG5ldyBVaW50OEFycmF5KDE2KTtcbiAgICAgICAgfVxuXG4gICAgICAgICsrdGhpcy5zdGFja0luZGV4O1xuXG4gICAgICAgIC8vIGNvcHkgc3RhdGUuLlxuICAgICAgICAvLyBzZXQgYWN0aXZlIHN0YXRlIHNvIHdlIGNhbiBmb3JjZSBvdmVycmlkZXMgb2YgZ2wgc3RhdGVcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmFjdGl2ZVN0YXRlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBzdGF0ZVtpXSA9IHRoaXMuYWN0aXZlU3RhdGVbaV07XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUG9wcyBhIHN0YXRlIG91dFxuICAgICAqL1xuXG5cbiAgICBXZWJHTFN0YXRlLnByb3RvdHlwZS5wb3AgPSBmdW5jdGlvbiBwb3AoKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhY2tbLS10aGlzLnN0YWNrSW5kZXhdO1xuXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoc3RhdGUpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBjdXJyZW50IHN0YXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IHN0YXRlIC0gVGhlIHN0YXRlIHRvIHNldC5cbiAgICAgKi9cblxuXG4gICAgV2ViR0xTdGF0ZS5wcm90b3R5cGUuc2V0U3RhdGUgPSBmdW5jdGlvbiBzZXRTdGF0ZShzdGF0ZSkge1xuICAgICAgICB0aGlzLnNldEJsZW5kKHN0YXRlW0JMRU5EXSk7XG4gICAgICAgIHRoaXMuc2V0RGVwdGhUZXN0KHN0YXRlW0RFUFRIX1RFU1RdKTtcbiAgICAgICAgdGhpcy5zZXRGcm9udEZhY2Uoc3RhdGVbRlJPTlRfRkFDRV0pO1xuICAgICAgICB0aGlzLnNldEN1bGxGYWNlKHN0YXRlW0NVTExfRkFDRV0pO1xuICAgICAgICB0aGlzLnNldEJsZW5kTW9kZShzdGF0ZVtCTEVORF9GVU5DXSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEVuYWJsZXMgb3IgZGlzYWJsZWQgYmxlbmRpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHZhbHVlIC0gVHVybiBvbiBvciBvZmYgd2ViZ2wgYmxlbmRpbmcuXG4gICAgICovXG5cblxuICAgIFdlYkdMU3RhdGUucHJvdG90eXBlLnNldEJsZW5kID0gZnVuY3Rpb24gc2V0QmxlbmQodmFsdWUpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZSA/IDEgOiAwO1xuXG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZVN0YXRlW0JMRU5EXSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYWN0aXZlU3RhdGVbQkxFTkRdID0gdmFsdWU7XG4gICAgICAgIHRoaXMuZ2xbdmFsdWUgPyAnZW5hYmxlJyA6ICdkaXNhYmxlJ10odGhpcy5nbC5CTEVORCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGJsZW5kIG1vZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSBUaGUgYmxlbmQgbW9kZSB0byBzZXQgdG8uXG4gICAgICovXG5cblxuICAgIFdlYkdMU3RhdGUucHJvdG90eXBlLnNldEJsZW5kTW9kZSA9IGZ1bmN0aW9uIHNldEJsZW5kTW9kZSh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT09IHRoaXMuYWN0aXZlU3RhdGVbQkxFTkRfRlVOQ10pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYWN0aXZlU3RhdGVbQkxFTkRfRlVOQ10gPSB2YWx1ZTtcblxuICAgICAgICB2YXIgbW9kZSA9IHRoaXMuYmxlbmRNb2Rlc1t2YWx1ZV07XG5cbiAgICAgICAgaWYgKG1vZGUubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICB0aGlzLmdsLmJsZW5kRnVuYyhtb2RlWzBdLCBtb2RlWzFdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZ2wuYmxlbmRGdW5jU2VwYXJhdGUobW9kZVswXSwgbW9kZVsxXSwgbW9kZVsyXSwgbW9kZVszXSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0cyB3aGV0aGVyIHRvIGVuYWJsZSBvciBkaXNhYmxlIGRlcHRoIHRlc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHZhbHVlIC0gVHVybiBvbiBvciBvZmYgd2ViZ2wgZGVwdGggdGVzdGluZy5cbiAgICAgKi9cblxuXG4gICAgV2ViR0xTdGF0ZS5wcm90b3R5cGUuc2V0RGVwdGhUZXN0ID0gZnVuY3Rpb24gc2V0RGVwdGhUZXN0KHZhbHVlKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUgPyAxIDogMDtcblxuICAgICAgICBpZiAodGhpcy5hY3RpdmVTdGF0ZVtERVBUSF9URVNUXSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYWN0aXZlU3RhdGVbREVQVEhfVEVTVF0gPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5nbFt2YWx1ZSA/ICdlbmFibGUnIDogJ2Rpc2FibGUnXSh0aGlzLmdsLkRFUFRIX1RFU1QpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHdoZXRoZXIgdG8gZW5hYmxlIG9yIGRpc2FibGUgY3VsbCBmYWNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sZWFufSB2YWx1ZSAtIFR1cm4gb24gb3Igb2ZmIHdlYmdsIGN1bGwgZmFjZS5cbiAgICAgKi9cblxuXG4gICAgV2ViR0xTdGF0ZS5wcm90b3R5cGUuc2V0Q3VsbEZhY2UgPSBmdW5jdGlvbiBzZXRDdWxsRmFjZSh2YWx1ZSkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlID8gMSA6IDA7XG5cbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlU3RhdGVbQ1VMTF9GQUNFXSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYWN0aXZlU3RhdGVbQ1VMTF9GQUNFXSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmdsW3ZhbHVlID8gJ2VuYWJsZScgOiAnZGlzYWJsZSddKHRoaXMuZ2wuQ1VMTF9GQUNFKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgZ2wgZnJvbnQgZmFjZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsdWUgLSB0cnVlIGlzIGNsb2Nrd2lzZSBhbmQgZmFsc2UgaXMgY291bnRlci1jbG9ja3dpc2VcbiAgICAgKi9cblxuXG4gICAgV2ViR0xTdGF0ZS5wcm90b3R5cGUuc2V0RnJvbnRGYWNlID0gZnVuY3Rpb24gc2V0RnJvbnRGYWNlKHZhbHVlKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUgPyAxIDogMDtcblxuICAgICAgICBpZiAodGhpcy5hY3RpdmVTdGF0ZVtGUk9OVF9GQUNFXSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYWN0aXZlU3RhdGVbRlJPTlRfRkFDRV0gPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5nbC5mcm9udEZhY2UodGhpcy5nbFt2YWx1ZSA/ICdDVycgOiAnQ0NXJ10pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEaXNhYmxlcyBhbGwgdGhlIHZhb3MgaW4gdXNlXG4gICAgICpcbiAgICAgKi9cblxuXG4gICAgV2ViR0xTdGF0ZS5wcm90b3R5cGUucmVzZXRBdHRyaWJ1dGVzID0gZnVuY3Rpb24gcmVzZXRBdHRyaWJ1dGVzKCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYXR0cmliU3RhdGUudGVtcEF0dHJpYlN0YXRlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmF0dHJpYlN0YXRlLnRlbXBBdHRyaWJTdGF0ZVtpXSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgdGhpcy5hdHRyaWJTdGF0ZS5hdHRyaWJTdGF0ZS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHRoaXMuYXR0cmliU3RhdGUuYXR0cmliU3RhdGVbX2ldID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGltIGdvaW5nIHRvIGFzc3VtZSBvbmUgaXMgYWx3YXlzIGFjdGl2ZSBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucy5cbiAgICAgICAgZm9yICh2YXIgX2kyID0gMTsgX2kyIDwgdGhpcy5tYXhBdHRyaWJzOyBfaTIrKykge1xuICAgICAgICAgICAgdGhpcy5nbC5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkoX2kyKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyB1c2VkXG4gICAgLyoqXG4gICAgICogUmVzZXRzIGFsbCB0aGUgbG9naWMgYW5kIGRpc2FibGVzIHRoZSB2YW9zXG4gICAgICovXG5cblxuICAgIFdlYkdMU3RhdGUucHJvdG90eXBlLnJlc2V0VG9EZWZhdWx0ID0gZnVuY3Rpb24gcmVzZXRUb0RlZmF1bHQoKSB7XG4gICAgICAgIC8vIHVuYmluZCBhbnkgVkFPIGlmIHRoZXkgZXhpc3QuLlxuICAgICAgICBpZiAodGhpcy5uYXRpdmVWYW9FeHRlbnNpb24pIHtcbiAgICAgICAgICAgIHRoaXMubmF0aXZlVmFvRXh0ZW5zaW9uLmJpbmRWZXJ0ZXhBcnJheU9FUyhudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlc2V0IGFsbCBhdHRyaWJ1dGVzLi5cbiAgICAgICAgdGhpcy5yZXNldEF0dHJpYnV0ZXMoKTtcblxuICAgICAgICAvLyBzZXQgYWN0aXZlIHN0YXRlIHNvIHdlIGNhbiBmb3JjZSBvdmVycmlkZXMgb2YgZ2wgc3RhdGVcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmFjdGl2ZVN0YXRlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZVN0YXRlW2ldID0gMzI7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmdsLnBpeGVsU3RvcmVpKHRoaXMuZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgZmFsc2UpO1xuXG4gICAgICAgIHRoaXMuc2V0U3RhdGUodGhpcy5kZWZhdWx0U3RhdGUpO1xuICAgIH07XG5cbiAgICByZXR1cm4gV2ViR0xTdGF0ZTtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gV2ViR0xTdGF0ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVdlYkdMU3RhdGUuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2V4dHJhY3RVbmlmb3Jtc0Zyb21TcmMgPSByZXF1aXJlKCcuL2V4dHJhY3RVbmlmb3Jtc0Zyb21TcmMnKTtcblxudmFyIF9leHRyYWN0VW5pZm9ybXNGcm9tU3JjMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2V4dHJhY3RVbmlmb3Jtc0Zyb21TcmMpO1xuXG52YXIgX3V0aWxzID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcblxudmFyIF9jb25zdCA9IHJlcXVpcmUoJy4uLy4uLy4uL2NvbnN0Jyk7XG5cbnZhciBfc2V0dGluZ3MgPSByZXF1aXJlKCcuLi8uLi8uLi9zZXR0aW5ncycpO1xuXG52YXIgX3NldHRpbmdzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NldHRpbmdzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIFNPVVJDRV9LRVlfTUFQID0ge307XG5cbi8vIGxldCBtYXRoID0gcmVxdWlyZSgnLi4vLi4vLi4vbWF0aCcpO1xuLyoqXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKiBAZXh0ZW5kcyBQSVhJLlNoYWRlclxuICovXG5cbnZhciBGaWx0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3ZlcnRleFNyY10gLSBUaGUgc291cmNlIG9mIHRoZSB2ZXJ0ZXggc2hhZGVyLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2ZyYWdtZW50U3JjXSAtIFRoZSBzb3VyY2Ugb2YgdGhlIGZyYWdtZW50IHNoYWRlci5cbiAgICogQHBhcmFtIHtvYmplY3R9IFt1bmlmb3JtRGF0YV0gLSBDdXN0b20gdW5pZm9ybXMgdG8gdXNlIHRvIGF1Z21lbnQgdGhlIGJ1aWx0LWluIG9uZXMuXG4gICAqL1xuICBmdW5jdGlvbiBGaWx0ZXIodmVydGV4U3JjLCBmcmFnbWVudFNyYywgdW5pZm9ybURhdGEpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRmlsdGVyKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB2ZXJ0ZXggc2hhZGVyLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMudmVydGV4U3JjID0gdmVydGV4U3JjIHx8IEZpbHRlci5kZWZhdWx0VmVydGV4U3JjO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZyYWdtZW50IHNoYWRlci5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmZyYWdtZW50U3JjID0gZnJhZ21lbnRTcmMgfHwgRmlsdGVyLmRlZmF1bHRGcmFnbWVudFNyYztcblxuICAgIHRoaXMuX2JsZW5kTW9kZSA9IF9jb25zdC5CTEVORF9NT0RFUy5OT1JNQUw7XG5cbiAgICB0aGlzLnVuaWZvcm1EYXRhID0gdW5pZm9ybURhdGEgfHwgKDAsIF9leHRyYWN0VW5pZm9ybXNGcm9tU3JjMi5kZWZhdWx0KSh0aGlzLnZlcnRleFNyYywgdGhpcy5mcmFnbWVudFNyYywgJ3Byb2plY3Rpb25NYXRyaXh8dVNhbXBsZXInKTtcblxuICAgIC8qKlxuICAgICAqIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBjdXJyZW50IHZhbHVlcyBvZiBjdXN0b20gdW5pZm9ybXMuXG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+VXBkYXRpbmcgdGhlIHZhbHVlIG9mIGEgY3VzdG9tIHVuaWZvcm08L2NhcHRpb24+XG4gICAgICogZmlsdGVyLnVuaWZvcm1zLnRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge29iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLnVuaWZvcm1zID0ge307XG5cbiAgICBmb3IgKHZhciBpIGluIHRoaXMudW5pZm9ybURhdGEpIHtcbiAgICAgIHRoaXMudW5pZm9ybXNbaV0gPSB0aGlzLnVuaWZvcm1EYXRhW2ldLnZhbHVlO1xuICAgICAgaWYgKHRoaXMudW5pZm9ybURhdGFbaV0udHlwZSkge1xuICAgICAgICB0aGlzLnVuaWZvcm1EYXRhW2ldLnR5cGUgPSB0aGlzLnVuaWZvcm1EYXRhW2ldLnR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB0aGlzIGlzIHdoZXJlIHdlIHN0b3JlIHNoYWRlciByZWZlcmVuY2VzLi5cbiAgICAvLyBUT0RPIHdlIGNvdWxkIGNhY2hlIHRoaXMhXG4gICAgdGhpcy5nbFNoYWRlcnMgPSB7fTtcblxuICAgIC8vIHVzZWQgZm9yIGNhY2hpbmcuLiBzdXJlIHRoZXJlIGlzIGEgYmV0dGVyIHdheSFcbiAgICBpZiAoIVNPVVJDRV9LRVlfTUFQW3RoaXMudmVydGV4U3JjICsgdGhpcy5mcmFnbWVudFNyY10pIHtcbiAgICAgIFNPVVJDRV9LRVlfTUFQW3RoaXMudmVydGV4U3JjICsgdGhpcy5mcmFnbWVudFNyY10gPSAoMCwgX3V0aWxzLnVpZCkoKTtcbiAgICB9XG5cbiAgICB0aGlzLmdsU2hhZGVyS2V5ID0gU09VUkNFX0tFWV9NQVBbdGhpcy52ZXJ0ZXhTcmMgKyB0aGlzLmZyYWdtZW50U3JjXTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBwYWRkaW5nIG9mIHRoZSBmaWx0ZXIuIFNvbWUgZmlsdGVycyByZXF1aXJlIGV4dHJhIHNwYWNlIHRvIGJyZWF0aCBzdWNoIGFzIGEgYmx1ci5cbiAgICAgKiBJbmNyZWFzaW5nIHRoaXMgd2lsbCBhZGQgZXh0cmEgd2lkdGggYW5kIGhlaWdodCB0byB0aGUgYm91bmRzIG9mIHRoZSBvYmplY3QgdGhhdCB0aGVcbiAgICAgKiBmaWx0ZXIgaXMgYXBwbGllZCB0by5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnBhZGRpbmcgPSA0O1xuXG4gICAgLyoqXG4gICAgICogVGhlIHJlc29sdXRpb24gb2YgdGhlIGZpbHRlci4gU2V0dGluZyB0aGlzIHRvIGJlIGxvd2VyIHdpbGwgbG93ZXIgdGhlIHF1YWxpdHkgYnV0XG4gICAgICogaW5jcmVhc2UgdGhlIHBlcmZvcm1hbmNlIG9mIHRoZSBmaWx0ZXIuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5yZXNvbHV0aW9uID0gX3NldHRpbmdzMi5kZWZhdWx0LkZJTFRFUl9SRVNPTFVUSU9OO1xuXG4gICAgLyoqXG4gICAgICogSWYgZW5hYmxlZCBpcyB0cnVlIHRoZSBmaWx0ZXIgaXMgYXBwbGllZCwgaWYgZmFsc2UgaXQgd2lsbCBub3QuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBJZiBlbmFibGVkLCBQaXhpSlMgd2lsbCBmaXQgdGhlIGZpbHRlciBhcmVhIGludG8gYm91bmRhcmllcyBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlLlxuICAgICAqIFN3aXRjaCBpdCBvZmYgaWYgaXQgZG9lcyBub3Qgd29yayBmb3Igc3BlY2lmaWMgc2hhZGVyLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmF1dG9GaXQgPSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEFwcGxpZXMgdGhlIGZpbHRlclxuICAgKlxuICAgKiBAcGFyYW0ge1BJWEkuRmlsdGVyTWFuYWdlcn0gZmlsdGVyTWFuYWdlciAtIFRoZSByZW5kZXJlciB0byByZXRyaWV2ZSB0aGUgZmlsdGVyIGZyb21cbiAgICogQHBhcmFtIHtQSVhJLlJlbmRlclRhcmdldH0gaW5wdXQgLSBUaGUgaW5wdXQgcmVuZGVyIHRhcmdldC5cbiAgICogQHBhcmFtIHtQSVhJLlJlbmRlclRhcmdldH0gb3V0cHV0IC0gVGhlIHRhcmdldCB0byBvdXRwdXQgdG8uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gY2xlYXIgLSBTaG91bGQgdGhlIG91dHB1dCBiZSBjbGVhcmVkIGJlZm9yZSByZW5kZXJpbmcgdG8gaXRcbiAgICogQHBhcmFtIHtvYmplY3R9IFtjdXJyZW50U3RhdGVdIC0gSXQncyBjdXJyZW50IHN0YXRlIG9mIGZpbHRlci5cbiAgICogICAgICAgIFRoZXJlIGFyZSBzb21lIHVzZWZ1bCBwcm9wZXJ0aWVzIGluIHRoZSBjdXJyZW50U3RhdGUgOlxuICAgKiAgICAgICAgdGFyZ2V0LCBmaWx0ZXJzLCBzb3VyY2VGcmFtZSwgZGVzdGluYXRpb25GcmFtZSwgcmVuZGVyVGFyZ2V0LCByZXNvbHV0aW9uXG4gICAqL1xuXG5cbiAgRmlsdGVyLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uIGFwcGx5KGZpbHRlck1hbmFnZXIsIGlucHV0LCBvdXRwdXQsIGNsZWFyLCBjdXJyZW50U3RhdGUpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAge1xuICAgIC8vIC0tLSAvL1xuICAgIC8vICB0aGlzLnVuaWZvcm1zLmZpbHRlck1hdHJpeCA9IGZpbHRlck1hbmFnZXIuY2FsY3VsYXRlU3ByaXRlTWF0cml4KHRlbXBNYXRyaXgsIHdpbmRvdy5wYW5kYSApO1xuXG4gICAgLy8gZG8gYXMgeW91IHBsZWFzZSFcblxuICAgIGZpbHRlck1hbmFnZXIuYXBwbHlGaWx0ZXIodGhpcywgaW5wdXQsIG91dHB1dCwgY2xlYXIpO1xuXG4gICAgLy8gb3IganVzdCBkbyBhIHJlZ3VsYXIgcmVuZGVyLi5cbiAgfTtcblxuICAvKipcbiAgICogU2V0cyB0aGUgYmxlbmRtb2RlIG9mIHRoZSBmaWx0ZXJcbiAgICpcbiAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgKiBAZGVmYXVsdCBQSVhJLkJMRU5EX01PREVTLk5PUk1BTFxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhGaWx0ZXIsIFt7XG4gICAga2V5OiAnYmxlbmRNb2RlJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9ibGVuZE1vZGU7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSByZXF1aXJlLWpzZG9jXG4gICAge1xuICAgICAgdGhpcy5fYmxlbmRNb2RlID0gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgdmVydGV4IHNoYWRlciBzb3VyY2VcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAY29uc3RhbnRcbiAgICAgKi9cblxuICB9XSwgW3tcbiAgICBrZXk6ICdkZWZhdWx0VmVydGV4U3JjJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBbJ2F0dHJpYnV0ZSB2ZWMyIGFWZXJ0ZXhQb3NpdGlvbjsnLCAnYXR0cmlidXRlIHZlYzIgYVRleHR1cmVDb29yZDsnLCAndW5pZm9ybSBtYXQzIHByb2plY3Rpb25NYXRyaXg7JywgJ3VuaWZvcm0gbWF0MyBmaWx0ZXJNYXRyaXg7JywgJ3ZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkOycsICd2YXJ5aW5nIHZlYzIgdkZpbHRlckNvb3JkOycsICd2b2lkIG1haW4odm9pZCl7JywgJyAgIGdsX1Bvc2l0aW9uID0gdmVjNCgocHJvamVjdGlvbk1hdHJpeCAqIHZlYzMoYVZlcnRleFBvc2l0aW9uLCAxLjApKS54eSwgMC4wLCAxLjApOycsICcgICB2RmlsdGVyQ29vcmQgPSAoIGZpbHRlck1hdHJpeCAqIHZlYzMoIGFUZXh0dXJlQ29vcmQsIDEuMCkgICkueHk7JywgJyAgIHZUZXh0dXJlQ29vcmQgPSBhVGV4dHVyZUNvb3JkIDsnLCAnfSddLmpvaW4oJ1xcbicpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IGZyYWdtZW50IHNoYWRlciBzb3VyY2VcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAY29uc3RhbnRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZGVmYXVsdEZyYWdtZW50U3JjJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBbJ3ZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkOycsICd2YXJ5aW5nIHZlYzIgdkZpbHRlckNvb3JkOycsICd1bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjsnLCAndW5pZm9ybSBzYW1wbGVyMkQgZmlsdGVyU2FtcGxlcjsnLCAndm9pZCBtYWluKHZvaWQpeycsICcgICB2ZWM0IG1hc2t5ID0gdGV4dHVyZTJEKGZpbHRlclNhbXBsZXIsIHZGaWx0ZXJDb29yZCk7JywgJyAgIHZlYzQgc2FtcGxlID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkKTsnLCAnICAgdmVjNCBjb2xvcjsnLCAnICAgaWYobW9kKHZGaWx0ZXJDb29yZC54LCAxLjApID4gMC41KScsICcgICB7JywgJyAgICAgY29sb3IgPSB2ZWM0KDEuMCwgMC4wLCAwLjAsIDEuMCk7JywgJyAgIH0nLCAnICAgZWxzZScsICcgICB7JywgJyAgICAgY29sb3IgPSB2ZWM0KDAuMCwgMS4wLCAwLjAsIDEuMCk7JywgJyAgIH0nLFxuICAgICAgLy8gJyAgIGdsX0ZyYWdDb2xvciA9IHZlYzQobW9kKHZGaWx0ZXJDb29yZC54LCAxLjUpLCB2RmlsdGVyQ29vcmQueSwwLjAsMS4wKTsnLFxuICAgICAgJyAgIGdsX0ZyYWdDb2xvciA9IG1peChzYW1wbGUsIG1hc2t5LCAwLjUpOycsICcgICBnbF9GcmFnQ29sb3IgKj0gc2FtcGxlLmE7JywgJ30nXS5qb2luKCdcXG4nKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRmlsdGVyO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBGaWx0ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1GaWx0ZXIuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5kZWZhdWx0ID0gZXh0cmFjdFVuaWZvcm1zRnJvbVNyYztcblxudmFyIF9waXhpR2xDb3JlID0gcmVxdWlyZSgncGl4aS1nbC1jb3JlJyk7XG5cbnZhciBfcGl4aUdsQ29yZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9waXhpR2xDb3JlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIGRlZmF1bHRWYWx1ZSA9IF9waXhpR2xDb3JlMi5kZWZhdWx0LnNoYWRlci5kZWZhdWx0VmFsdWU7XG5cbmZ1bmN0aW9uIGV4dHJhY3RVbmlmb3Jtc0Zyb21TcmModmVydGV4U3JjLCBmcmFnbWVudFNyYywgbWFzaykge1xuICAgIHZhciB2ZXJ0VW5pZm9ybXMgPSBleHRyYWN0VW5pZm9ybXNGcm9tU3RyaW5nKHZlcnRleFNyYywgbWFzayk7XG4gICAgdmFyIGZyYWdVbmlmb3JtcyA9IGV4dHJhY3RVbmlmb3Jtc0Zyb21TdHJpbmcoZnJhZ21lbnRTcmMsIG1hc2spO1xuXG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24odmVydFVuaWZvcm1zLCBmcmFnVW5pZm9ybXMpO1xufVxuXG5mdW5jdGlvbiBleHRyYWN0VW5pZm9ybXNGcm9tU3RyaW5nKHN0cmluZykge1xuICAgIHZhciBtYXNrUmVnZXggPSBuZXcgUmVnRXhwKCdeKHByb2plY3Rpb25NYXRyaXh8dVNhbXBsZXJ8ZmlsdGVyQXJlYXxmaWx0ZXJDbGFtcCkkJyk7XG5cbiAgICB2YXIgdW5pZm9ybXMgPSB7fTtcbiAgICB2YXIgbmFtZVNwbGl0ID0gdm9pZCAwO1xuXG4gICAgLy8gY2xlYW4gdGhlIGxpbmVzIGEgbGl0dGxlIC0gcmVtb3ZlIGV4dHJhIHNwYWNlcyAvIHRhYnMgZXRjXG4gICAgLy8gdGhlbiBzcGxpdCBhbG9uZyAnOydcbiAgICB2YXIgbGluZXMgPSBzdHJpbmcucmVwbGFjZSgvXFxzKy9nLCAnICcpLnNwbGl0KC9cXHMqO1xccyovKTtcblxuICAgIC8vIGxvb3AgdGhyb3VnaC4uXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbGluZSA9IGxpbmVzW2ldLnRyaW0oKTtcblxuICAgICAgICBpZiAobGluZS5pbmRleE9mKCd1bmlmb3JtJykgPiAtMSkge1xuICAgICAgICAgICAgdmFyIHNwbGl0TGluZSA9IGxpbmUuc3BsaXQoJyAnKTtcbiAgICAgICAgICAgIHZhciB0eXBlID0gc3BsaXRMaW5lWzFdO1xuXG4gICAgICAgICAgICB2YXIgbmFtZSA9IHNwbGl0TGluZVsyXTtcbiAgICAgICAgICAgIHZhciBzaXplID0gMTtcblxuICAgICAgICAgICAgaWYgKG5hbWUuaW5kZXhPZignWycpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAvLyBhcnJheSFcbiAgICAgICAgICAgICAgICBuYW1lU3BsaXQgPSBuYW1lLnNwbGl0KC9cXFt8XS8pO1xuICAgICAgICAgICAgICAgIG5hbWUgPSBuYW1lU3BsaXRbMF07XG4gICAgICAgICAgICAgICAgc2l6ZSAqPSBOdW1iZXIobmFtZVNwbGl0WzFdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFuYW1lLm1hdGNoKG1hc2tSZWdleCkpIHtcbiAgICAgICAgICAgICAgICB1bmlmb3Jtc1tuYW1lXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGRlZmF1bHRWYWx1ZSh0eXBlLCBzaXplKSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogdHlwZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdW5pZm9ybXM7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1leHRyYWN0VW5pZm9ybXNGcm9tU3JjLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuY2FsY3VsYXRlU2NyZWVuU3BhY2VNYXRyaXggPSBjYWxjdWxhdGVTY3JlZW5TcGFjZU1hdHJpeDtcbmV4cG9ydHMuY2FsY3VsYXRlTm9ybWFsaXplZFNjcmVlblNwYWNlTWF0cml4ID0gY2FsY3VsYXRlTm9ybWFsaXplZFNjcmVlblNwYWNlTWF0cml4O1xuZXhwb3J0cy5jYWxjdWxhdGVTcHJpdGVNYXRyaXggPSBjYWxjdWxhdGVTcHJpdGVNYXRyaXg7XG5cbnZhciBfbWF0aCA9IHJlcXVpcmUoJy4uLy4uLy4uL21hdGgnKTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBtYXBwZWQgbWF0cml4XG4gKiBAcGFyYW0gZmlsdGVyQXJlYSB7UmVjdGFuZ2xlfSBUaGUgZmlsdGVyIGFyZWFcbiAqIEBwYXJhbSBzcHJpdGUge1Nwcml0ZX0gdGhlIHRhcmdldCBzcHJpdGVcbiAqIEBwYXJhbSBvdXRwdXRNYXRyaXgge01hdHJpeH0gQGFsdmluXG4gKiBAcHJpdmF0ZVxuICovXG4vLyBUT0RPIHBsYXlpbmcgYXJvdW5kIGhlcmUuLiB0aGlzIGlzIHRlbXBvcmFyeSAtICh3aWxsIGVuZCB1cCBpbiB0aGUgc2hhZGVyKVxuLy8gdGhpcyByZXR1cm5zIGEgbWF0cml4IHRoYXQgd2lsbCBub3JtYWxpc2UgbWFwIGZpbHRlciBjb3JkcyBpbiB0aGUgZmlsdGVyIHRvIHNjcmVlbiBzcGFjZVxuZnVuY3Rpb24gY2FsY3VsYXRlU2NyZWVuU3BhY2VNYXRyaXgob3V0cHV0TWF0cml4LCBmaWx0ZXJBcmVhLCB0ZXh0dXJlU2l6ZSkge1xuICAgIC8vIGxldCB3b3JsZFRyYW5zZm9ybSA9IHNwcml0ZS53b3JsZFRyYW5zZm9ybS5jb3B5KE1hdHJpeC5URU1QX01BVFJJWCksXG4gICAgLy8gbGV0IHRleHR1cmUgPSB7d2lkdGg6MTEzNiwgaGVpZ2h0OjcwMH07Ly9zcHJpdGUuX3RleHR1cmUuYmFzZVRleHR1cmU7XG5cbiAgICAvLyBUT0RPIHVud3JhcD9cbiAgICB2YXIgbWFwcGVkTWF0cml4ID0gb3V0cHV0TWF0cml4LmlkZW50aXR5KCk7XG5cbiAgICBtYXBwZWRNYXRyaXgudHJhbnNsYXRlKGZpbHRlckFyZWEueCAvIHRleHR1cmVTaXplLndpZHRoLCBmaWx0ZXJBcmVhLnkgLyB0ZXh0dXJlU2l6ZS5oZWlnaHQpO1xuXG4gICAgbWFwcGVkTWF0cml4LnNjYWxlKHRleHR1cmVTaXplLndpZHRoLCB0ZXh0dXJlU2l6ZS5oZWlnaHQpO1xuXG4gICAgcmV0dXJuIG1hcHBlZE1hdHJpeDtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlTm9ybWFsaXplZFNjcmVlblNwYWNlTWF0cml4KG91dHB1dE1hdHJpeCwgZmlsdGVyQXJlYSwgdGV4dHVyZVNpemUpIHtcbiAgICB2YXIgbWFwcGVkTWF0cml4ID0gb3V0cHV0TWF0cml4LmlkZW50aXR5KCk7XG5cbiAgICBtYXBwZWRNYXRyaXgudHJhbnNsYXRlKGZpbHRlckFyZWEueCAvIHRleHR1cmVTaXplLndpZHRoLCBmaWx0ZXJBcmVhLnkgLyB0ZXh0dXJlU2l6ZS5oZWlnaHQpO1xuXG4gICAgdmFyIHRyYW5zbGF0ZVNjYWxlWCA9IHRleHR1cmVTaXplLndpZHRoIC8gZmlsdGVyQXJlYS53aWR0aDtcbiAgICB2YXIgdHJhbnNsYXRlU2NhbGVZID0gdGV4dHVyZVNpemUuaGVpZ2h0IC8gZmlsdGVyQXJlYS5oZWlnaHQ7XG5cbiAgICBtYXBwZWRNYXRyaXguc2NhbGUodHJhbnNsYXRlU2NhbGVYLCB0cmFuc2xhdGVTY2FsZVkpO1xuXG4gICAgcmV0dXJuIG1hcHBlZE1hdHJpeDtcbn1cblxuLy8gdGhpcyB3aWxsIG1hcCB0aGUgZmlsdGVyIGNvb3JkIHNvIHRoYXQgYSB0ZXh0dXJlIGNhbiBiZSB1c2VkIGJhc2VkIG9uIHRoZSB0cmFuc2Zvcm0gb2YgYSBzcHJpdGVcbmZ1bmN0aW9uIGNhbGN1bGF0ZVNwcml0ZU1hdHJpeChvdXRwdXRNYXRyaXgsIGZpbHRlckFyZWEsIHRleHR1cmVTaXplLCBzcHJpdGUpIHtcbiAgICB2YXIgb3JpZyA9IHNwcml0ZS5fdGV4dHVyZS5vcmlnO1xuICAgIHZhciBtYXBwZWRNYXRyaXggPSBvdXRwdXRNYXRyaXguc2V0KHRleHR1cmVTaXplLndpZHRoLCAwLCAwLCB0ZXh0dXJlU2l6ZS5oZWlnaHQsIGZpbHRlckFyZWEueCwgZmlsdGVyQXJlYS55KTtcbiAgICB2YXIgd29ybGRUcmFuc2Zvcm0gPSBzcHJpdGUud29ybGRUcmFuc2Zvcm0uY29weShfbWF0aC5NYXRyaXguVEVNUF9NQVRSSVgpO1xuXG4gICAgd29ybGRUcmFuc2Zvcm0uaW52ZXJ0KCk7XG4gICAgbWFwcGVkTWF0cml4LnByZXBlbmQod29ybGRUcmFuc2Zvcm0pO1xuICAgIG1hcHBlZE1hdHJpeC5zY2FsZSgxLjAgLyBvcmlnLndpZHRoLCAxLjAgLyBvcmlnLmhlaWdodCk7XG4gICAgbWFwcGVkTWF0cml4LnRyYW5zbGF0ZShzcHJpdGUuYW5jaG9yLngsIHNwcml0ZS5hbmNob3IueSk7XG5cbiAgICByZXR1cm4gbWFwcGVkTWF0cml4O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmlsdGVyVHJhbnNmb3Jtcy5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfRmlsdGVyMiA9IHJlcXVpcmUoJy4uL0ZpbHRlcicpO1xuXG52YXIgX0ZpbHRlcjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9GaWx0ZXIyKTtcblxudmFyIF9tYXRoID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vbWF0aCcpO1xuXG52YXIgX3BhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5cbnZhciBfVGV4dHVyZU1hdHJpeCA9IHJlcXVpcmUoJy4uLy4uLy4uLy4uL3RleHR1cmVzL1RleHR1cmVNYXRyaXgnKTtcblxudmFyIF9UZXh0dXJlTWF0cml4MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1RleHR1cmVNYXRyaXgpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbi8qKlxuICogVGhlIFNwcml0ZU1hc2tGaWx0ZXIgY2xhc3NcbiAqXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIFBJWEkuRmlsdGVyXG4gKiBAbWVtYmVyb2YgUElYSVxuICovXG52YXIgU3ByaXRlTWFza0ZpbHRlciA9IGZ1bmN0aW9uIChfRmlsdGVyKSB7XG4gICAgX2luaGVyaXRzKFNwcml0ZU1hc2tGaWx0ZXIsIF9GaWx0ZXIpO1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtQSVhJLlNwcml0ZX0gc3ByaXRlIC0gdGhlIHRhcmdldCBzcHJpdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTcHJpdGVNYXNrRmlsdGVyKHNwcml0ZSkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3ByaXRlTWFza0ZpbHRlcik7XG5cbiAgICAgICAgdmFyIG1hc2tNYXRyaXggPSBuZXcgX21hdGguTWF0cml4KCk7XG5cbiAgICAgICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0ZpbHRlci5jYWxsKHRoaXMsICdhdHRyaWJ1dGUgdmVjMiBhVmVydGV4UG9zaXRpb247XFxuYXR0cmlidXRlIHZlYzIgYVRleHR1cmVDb29yZDtcXG5cXG51bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDtcXG51bmlmb3JtIG1hdDMgb3RoZXJNYXRyaXg7XFxuXFxudmFyeWluZyB2ZWMyIHZNYXNrQ29vcmQ7XFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxuXFxudm9pZCBtYWluKHZvaWQpXFxue1xcbiAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoKHByb2plY3Rpb25NYXRyaXggKiB2ZWMzKGFWZXJ0ZXhQb3NpdGlvbiwgMS4wKSkueHksIDAuMCwgMS4wKTtcXG5cXG4gICAgdlRleHR1cmVDb29yZCA9IGFUZXh0dXJlQ29vcmQ7XFxuICAgIHZNYXNrQ29vcmQgPSAoIG90aGVyTWF0cml4ICogdmVjMyggYVRleHR1cmVDb29yZCwgMS4wKSAgKS54eTtcXG59XFxuJywgJ3ZhcnlpbmcgdmVjMiB2TWFza0Nvb3JkO1xcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcblxcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xcbnVuaWZvcm0gc2FtcGxlcjJEIG1hc2s7XFxudW5pZm9ybSBmbG9hdCBhbHBoYTtcXG51bmlmb3JtIHZlYzQgbWFza0NsYW1wO1xcblxcbnZvaWQgbWFpbih2b2lkKVxcbntcXG4gICAgZmxvYXQgY2xpcCA9IHN0ZXAoMy41LFxcbiAgICAgICAgc3RlcChtYXNrQ2xhbXAueCwgdk1hc2tDb29yZC54KSArXFxuICAgICAgICBzdGVwKG1hc2tDbGFtcC55LCB2TWFza0Nvb3JkLnkpICtcXG4gICAgICAgIHN0ZXAodk1hc2tDb29yZC54LCBtYXNrQ2xhbXAueikgK1xcbiAgICAgICAgc3RlcCh2TWFza0Nvb3JkLnksIG1hc2tDbGFtcC53KSk7XFxuXFxuICAgIHZlYzQgb3JpZ2luYWwgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpO1xcbiAgICB2ZWM0IG1hc2t5ID0gdGV4dHVyZTJEKG1hc2ssIHZNYXNrQ29vcmQpO1xcblxcbiAgICBvcmlnaW5hbCAqPSAobWFza3kuciAqIG1hc2t5LmEgKiBhbHBoYSAqIGNsaXApO1xcblxcbiAgICBnbF9GcmFnQ29sb3IgPSBvcmlnaW5hbDtcXG59XFxuJykpO1xuXG4gICAgICAgIHNwcml0ZS5yZW5kZXJhYmxlID0gZmFsc2U7XG5cbiAgICAgICAgX3RoaXMubWFza1Nwcml0ZSA9IHNwcml0ZTtcbiAgICAgICAgX3RoaXMubWFza01hdHJpeCA9IG1hc2tNYXRyaXg7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIHRoZSBmaWx0ZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5GaWx0ZXJNYW5hZ2VyfSBmaWx0ZXJNYW5hZ2VyIC0gVGhlIHJlbmRlcmVyIHRvIHJldHJpZXZlIHRoZSBmaWx0ZXIgZnJvbVxuICAgICAqIEBwYXJhbSB7UElYSS5SZW5kZXJUYXJnZXR9IGlucHV0IC0gVGhlIGlucHV0IHJlbmRlciB0YXJnZXQuXG4gICAgICogQHBhcmFtIHtQSVhJLlJlbmRlclRhcmdldH0gb3V0cHV0IC0gVGhlIHRhcmdldCB0byBvdXRwdXQgdG8uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBjbGVhciAtIFNob3VsZCB0aGUgb3V0cHV0IGJlIGNsZWFyZWQgYmVmb3JlIHJlbmRlcmluZyB0byBpdFxuICAgICAqL1xuXG5cbiAgICBTcHJpdGVNYXNrRmlsdGVyLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uIGFwcGx5KGZpbHRlck1hbmFnZXIsIGlucHV0LCBvdXRwdXQsIGNsZWFyKSB7XG4gICAgICAgIHZhciBtYXNrU3ByaXRlID0gdGhpcy5tYXNrU3ByaXRlO1xuICAgICAgICB2YXIgdGV4ID0gdGhpcy5tYXNrU3ByaXRlLnRleHR1cmU7XG5cbiAgICAgICAgaWYgKCF0ZXgudmFsaWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRleC50cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIC8vIG1hcmdpbiA9IDAuMCwgbGV0IGl0IGJsZWVkIGEgYml0LCBzaGFkZXIgY29kZSBiZWNvbWVzIGVhc2llclxuICAgICAgICAgICAgLy8gYXNzdW1pbmcgdGhhdCBhdGxhcyB0ZXh0dXJlcyB3ZXJlIG1hZGUgd2l0aCAxLXBpeGVsIHBhZGRpbmdcbiAgICAgICAgICAgIHRleC50cmFuc2Zvcm0gPSBuZXcgX1RleHR1cmVNYXRyaXgyLmRlZmF1bHQodGV4LCAwLjApO1xuICAgICAgICB9XG4gICAgICAgIHRleC50cmFuc2Zvcm0udXBkYXRlKCk7XG5cbiAgICAgICAgdGhpcy51bmlmb3Jtcy5tYXNrID0gdGV4O1xuICAgICAgICB0aGlzLnVuaWZvcm1zLm90aGVyTWF0cml4ID0gZmlsdGVyTWFuYWdlci5jYWxjdWxhdGVTcHJpdGVNYXRyaXgodGhpcy5tYXNrTWF0cml4LCBtYXNrU3ByaXRlKS5wcmVwZW5kKHRleC50cmFuc2Zvcm0ubWFwQ29vcmQpO1xuICAgICAgICB0aGlzLnVuaWZvcm1zLmFscGhhID0gbWFza1Nwcml0ZS53b3JsZEFscGhhO1xuICAgICAgICB0aGlzLnVuaWZvcm1zLm1hc2tDbGFtcCA9IHRleC50cmFuc2Zvcm0udUNsYW1wRnJhbWU7XG5cbiAgICAgICAgZmlsdGVyTWFuYWdlci5hcHBseUZpbHRlcih0aGlzLCBpbnB1dCwgb3V0cHV0LCBjbGVhcik7XG4gICAgfTtcblxuICAgIHJldHVybiBTcHJpdGVNYXNrRmlsdGVyO1xufShfRmlsdGVyMy5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gU3ByaXRlTWFza0ZpbHRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNwcml0ZU1hc2tGaWx0ZXIuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX1dlYkdMTWFuYWdlcjIgPSByZXF1aXJlKCcuL1dlYkdMTWFuYWdlcicpO1xuXG52YXIgX1dlYkdMTWFuYWdlcjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9XZWJHTE1hbmFnZXIyKTtcblxudmFyIF9SZW5kZXJUYXJnZXQgPSByZXF1aXJlKCcuLi91dGlscy9SZW5kZXJUYXJnZXQnKTtcblxudmFyIF9SZW5kZXJUYXJnZXQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUmVuZGVyVGFyZ2V0KTtcblxudmFyIF9RdWFkID0gcmVxdWlyZSgnLi4vdXRpbHMvUXVhZCcpO1xuXG52YXIgX1F1YWQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUXVhZCk7XG5cbnZhciBfbWF0aCA9IHJlcXVpcmUoJy4uLy4uLy4uL21hdGgnKTtcblxudmFyIF9TaGFkZXIgPSByZXF1aXJlKCcuLi8uLi8uLi9TaGFkZXInKTtcblxudmFyIF9TaGFkZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU2hhZGVyKTtcblxudmFyIF9maWx0ZXJUcmFuc2Zvcm1zID0gcmVxdWlyZSgnLi4vZmlsdGVycy9maWx0ZXJUcmFuc2Zvcm1zJyk7XG5cbnZhciBmaWx0ZXJUcmFuc2Zvcm1zID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX2ZpbHRlclRyYW5zZm9ybXMpO1xuXG52YXIgX2JpdFR3aWRkbGUgPSByZXF1aXJlKCdiaXQtdHdpZGRsZScpO1xuXG52YXIgX2JpdFR3aWRkbGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYml0VHdpZGRsZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuLyoqXG4gKiBAaWdub3JlXG4gKiBAY2xhc3NcbiAqL1xudmFyIEZpbHRlclN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgZnVuY3Rpb24gRmlsdGVyU3RhdGUoKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBGaWx0ZXJTdGF0ZSk7XG5cbiAgICAgICAgdGhpcy5yZW5kZXJUYXJnZXQgPSBudWxsO1xuICAgICAgICB0aGlzLnRhcmdldCA9IG51bGw7XG4gICAgICAgIHRoaXMucmVzb2x1dGlvbiA9IDE7XG5cbiAgICAgICAgLy8gdGhvc2UgdGhyZWUgb2JqZWN0cyBhcmUgdXNlZCBvbmx5IGZvciByb290XG4gICAgICAgIC8vIHJlLWFzc2lnbmVkIGZvciBldmVyeXRoaW5nIGVsc2VcbiAgICAgICAgdGhpcy5zb3VyY2VGcmFtZSA9IG5ldyBfbWF0aC5SZWN0YW5nbGUoKTtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbkZyYW1lID0gbmV3IF9tYXRoLlJlY3RhbmdsZSgpO1xuICAgICAgICB0aGlzLmZpbHRlcnMgPSBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjbGVhcnMgdGhlIHN0YXRlXG4gICAgICovXG5cblxuICAgIEZpbHRlclN0YXRlLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgICB0aGlzLmZpbHRlcnMgPSBudWxsO1xuICAgICAgICB0aGlzLnRhcmdldCA9IG51bGw7XG4gICAgICAgIHRoaXMucmVuZGVyVGFyZ2V0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEZpbHRlclN0YXRlO1xufSgpO1xuXG52YXIgc2NyZWVuS2V5ID0gJ3NjcmVlbic7XG5cbi8qKlxuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgUElYSVxuICogQGV4dGVuZHMgUElYSS5XZWJHTE1hbmFnZXJcbiAqL1xuXG52YXIgRmlsdGVyTWFuYWdlciA9IGZ1bmN0aW9uIChfV2ViR0xNYW5hZ2VyKSB7XG4gICAgX2luaGVyaXRzKEZpbHRlck1hbmFnZXIsIF9XZWJHTE1hbmFnZXIpO1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtQSVhJLldlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyIHRoaXMgbWFuYWdlciB3b3JrcyBmb3IuXG4gICAgICovXG4gICAgZnVuY3Rpb24gRmlsdGVyTWFuYWdlcihyZW5kZXJlcikge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRmlsdGVyTWFuYWdlcik7XG5cbiAgICAgICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1dlYkdMTWFuYWdlci5jYWxsKHRoaXMsIHJlbmRlcmVyKSk7XG5cbiAgICAgICAgX3RoaXMuZ2wgPSBfdGhpcy5yZW5kZXJlci5nbDtcbiAgICAgICAgLy8ga25vdyBhYm91dCBzcHJpdGVzIVxuICAgICAgICBfdGhpcy5xdWFkID0gbmV3IF9RdWFkMi5kZWZhdWx0KF90aGlzLmdsLCByZW5kZXJlci5zdGF0ZS5hdHRyaWJTdGF0ZSk7XG5cbiAgICAgICAgX3RoaXMuc2hhZGVyQ2FjaGUgPSB7fTtcbiAgICAgICAgLy8gdG9kbyBhZGQgZGVmYXVsdCFcbiAgICAgICAgX3RoaXMucG9vbCA9IHt9O1xuXG4gICAgICAgIF90aGlzLmZpbHRlckRhdGEgPSBudWxsO1xuXG4gICAgICAgIF90aGlzLm1hbmFnZWRGaWx0ZXJzID0gW107XG5cbiAgICAgICAgX3RoaXMucmVuZGVyZXIub24oJ3ByZXJlbmRlcicsIF90aGlzLm9uUHJlcmVuZGVyLCBfdGhpcyk7XG5cbiAgICAgICAgX3RoaXMuX3NjcmVlbldpZHRoID0gcmVuZGVyZXIudmlldy53aWR0aDtcbiAgICAgICAgX3RoaXMuX3NjcmVlbkhlaWdodCA9IHJlbmRlcmVyLnZpZXcuaGVpZ2h0O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIG5ldyBmaWx0ZXIgdG8gdGhlIG1hbmFnZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuRGlzcGxheU9iamVjdH0gdGFyZ2V0IC0gVGhlIHRhcmdldCBvZiB0aGUgZmlsdGVyIHRvIHJlbmRlci5cbiAgICAgKiBAcGFyYW0ge1BJWEkuRmlsdGVyW119IGZpbHRlcnMgLSBUaGUgZmlsdGVycyB0byBhcHBseS5cbiAgICAgKi9cblxuXG4gICAgRmlsdGVyTWFuYWdlci5wcm90b3R5cGUucHVzaEZpbHRlciA9IGZ1bmN0aW9uIHB1c2hGaWx0ZXIodGFyZ2V0LCBmaWx0ZXJzKSB7XG4gICAgICAgIHZhciByZW5kZXJlciA9IHRoaXMucmVuZGVyZXI7XG5cbiAgICAgICAgdmFyIGZpbHRlckRhdGEgPSB0aGlzLmZpbHRlckRhdGE7XG5cbiAgICAgICAgaWYgKCFmaWx0ZXJEYXRhKSB7XG4gICAgICAgICAgICBmaWx0ZXJEYXRhID0gdGhpcy5yZW5kZXJlci5fYWN0aXZlUmVuZGVyVGFyZ2V0LmZpbHRlclN0YWNrO1xuXG4gICAgICAgICAgICAvLyBhZGQgbmV3IHN0YWNrXG4gICAgICAgICAgICB2YXIgZmlsdGVyU3RhdGUgPSBuZXcgRmlsdGVyU3RhdGUoKTtcblxuICAgICAgICAgICAgZmlsdGVyU3RhdGUuc291cmNlRnJhbWUgPSBmaWx0ZXJTdGF0ZS5kZXN0aW5hdGlvbkZyYW1lID0gdGhpcy5yZW5kZXJlci5fYWN0aXZlUmVuZGVyVGFyZ2V0LnNpemU7XG4gICAgICAgICAgICBmaWx0ZXJTdGF0ZS5yZW5kZXJUYXJnZXQgPSByZW5kZXJlci5fYWN0aXZlUmVuZGVyVGFyZ2V0O1xuXG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLl9hY3RpdmVSZW5kZXJUYXJnZXQuZmlsdGVyRGF0YSA9IGZpbHRlckRhdGEgPSB7XG4gICAgICAgICAgICAgICAgaW5kZXg6IDAsXG4gICAgICAgICAgICAgICAgc3RhY2s6IFtmaWx0ZXJTdGF0ZV1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMuZmlsdGVyRGF0YSA9IGZpbHRlckRhdGE7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBnZXQgdGhlIGN1cnJlbnQgZmlsdGVyIHN0YXRlLi5cbiAgICAgICAgdmFyIGN1cnJlbnRTdGF0ZSA9IGZpbHRlckRhdGEuc3RhY2tbKytmaWx0ZXJEYXRhLmluZGV4XTtcbiAgICAgICAgdmFyIHJlbmRlclRhcmdldEZyYW1lID0gZmlsdGVyRGF0YS5zdGFja1swXS5kZXN0aW5hdGlvbkZyYW1lO1xuXG4gICAgICAgIGlmICghY3VycmVudFN0YXRlKSB7XG4gICAgICAgICAgICBjdXJyZW50U3RhdGUgPSBmaWx0ZXJEYXRhLnN0YWNrW2ZpbHRlckRhdGEuaW5kZXhdID0gbmV3IEZpbHRlclN0YXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZnVsbFNjcmVlbiA9IHRhcmdldC5maWx0ZXJBcmVhICYmIHRhcmdldC5maWx0ZXJBcmVhLnggPT09IDAgJiYgdGFyZ2V0LmZpbHRlckFyZWEueSA9PT0gMCAmJiB0YXJnZXQuZmlsdGVyQXJlYS53aWR0aCA9PT0gcmVuZGVyZXIuc2NyZWVuLndpZHRoICYmIHRhcmdldC5maWx0ZXJBcmVhLmhlaWdodCA9PT0gcmVuZGVyZXIuc2NyZWVuLmhlaWdodDtcblxuICAgICAgICAvLyBmb3Igbm93IHdlIGdvIG9mZiB0aGUgZmlsdGVyIG9mIHRoZSBmaXJzdCByZXNvbHV0aW9uLi5cbiAgICAgICAgdmFyIHJlc29sdXRpb24gPSBmaWx0ZXJzWzBdLnJlc29sdXRpb247XG4gICAgICAgIHZhciBwYWRkaW5nID0gZmlsdGVyc1swXS5wYWRkaW5nIHwgMDtcbiAgICAgICAgdmFyIHRhcmdldEJvdW5kcyA9IGZ1bGxTY3JlZW4gPyByZW5kZXJlci5zY3JlZW4gOiB0YXJnZXQuZmlsdGVyQXJlYSB8fCB0YXJnZXQuZ2V0Qm91bmRzKHRydWUpO1xuICAgICAgICB2YXIgc291cmNlRnJhbWUgPSBjdXJyZW50U3RhdGUuc291cmNlRnJhbWU7XG4gICAgICAgIHZhciBkZXN0aW5hdGlvbkZyYW1lID0gY3VycmVudFN0YXRlLmRlc3RpbmF0aW9uRnJhbWU7XG5cbiAgICAgICAgc291cmNlRnJhbWUueCA9ICh0YXJnZXRCb3VuZHMueCAqIHJlc29sdXRpb24gfCAwKSAvIHJlc29sdXRpb247XG4gICAgICAgIHNvdXJjZUZyYW1lLnkgPSAodGFyZ2V0Qm91bmRzLnkgKiByZXNvbHV0aW9uIHwgMCkgLyByZXNvbHV0aW9uO1xuICAgICAgICBzb3VyY2VGcmFtZS53aWR0aCA9ICh0YXJnZXRCb3VuZHMud2lkdGggKiByZXNvbHV0aW9uIHwgMCkgLyByZXNvbHV0aW9uO1xuICAgICAgICBzb3VyY2VGcmFtZS5oZWlnaHQgPSAodGFyZ2V0Qm91bmRzLmhlaWdodCAqIHJlc29sdXRpb24gfCAwKSAvIHJlc29sdXRpb247XG5cbiAgICAgICAgaWYgKCFmdWxsU2NyZWVuKSB7XG4gICAgICAgICAgICBpZiAoZmlsdGVyRGF0YS5zdGFja1swXS5yZW5kZXJUYXJnZXQudHJhbnNmb3JtKSB7Ly9cblxuICAgICAgICAgICAgICAgIC8vIFRPRE8gd2Ugc2hvdWxkIGZpdCB0aGUgcmVjdCBhcm91bmQgdGhlIHRyYW5zZm9ybS4uXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZpbHRlcnNbMF0uYXV0b0ZpdCkge1xuICAgICAgICAgICAgICAgIHNvdXJjZUZyYW1lLmZpdChyZW5kZXJUYXJnZXRGcmFtZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGxldHMgYXBwbHkgdGhlIHBhZGRpbmcgQWZ0ZXIgd2UgZml0IHRoZSBlbGVtZW50IHRvIHRoZSBzY3JlZW4uXG4gICAgICAgICAgICAvLyB0aGlzIHNob3VsZCBzdG9wIHRoZSBzdHJhbmdlIHNpZGUgZWZmZWN0cyB0aGF0IGNhbiBvY2N1ciB3aGVuIGNyb3BwaW5nIHRvIHRoZSBlZGdlc1xuICAgICAgICAgICAgc291cmNlRnJhbWUucGFkKHBhZGRpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVzdGluYXRpb25GcmFtZS53aWR0aCA9IHNvdXJjZUZyYW1lLndpZHRoO1xuICAgICAgICBkZXN0aW5hdGlvbkZyYW1lLmhlaWdodCA9IHNvdXJjZUZyYW1lLmhlaWdodDtcblxuICAgICAgICAvLyBsZXRzIHBsYXkgdGhlIHBhZGRpbmcgYWZ0ZXIgd2UgZml0IHRoZSBlbGVtZW50IHRvIHRoZSBzY3JlZW4uXG4gICAgICAgIC8vIHRoaXMgc2hvdWxkIHN0b3AgdGhlIHN0cmFuZ2Ugc2lkZSBlZmZlY3RzIHRoYXQgY2FuIG9jY3VyIHdoZW4gY3JvcHBpbmcgdG8gdGhlIGVkZ2VzXG5cbiAgICAgICAgdmFyIHJlbmRlclRhcmdldCA9IHRoaXMuZ2V0UG90UmVuZGVyVGFyZ2V0KHJlbmRlcmVyLmdsLCBzb3VyY2VGcmFtZS53aWR0aCwgc291cmNlRnJhbWUuaGVpZ2h0LCByZXNvbHV0aW9uKTtcblxuICAgICAgICBjdXJyZW50U3RhdGUudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICBjdXJyZW50U3RhdGUuZmlsdGVycyA9IGZpbHRlcnM7XG4gICAgICAgIGN1cnJlbnRTdGF0ZS5yZXNvbHV0aW9uID0gcmVzb2x1dGlvbjtcbiAgICAgICAgY3VycmVudFN0YXRlLnJlbmRlclRhcmdldCA9IHJlbmRlclRhcmdldDtcblxuICAgICAgICAvLyBiaW5kIHRoZSByZW5kZXIgdGFyZ2V0IHRvIGRyYXcgdGhlIHNoYXBlIGluIHRoZSB0b3AgY29ybmVyLi5cblxuICAgICAgICByZW5kZXJUYXJnZXQuc2V0RnJhbWUoZGVzdGluYXRpb25GcmFtZSwgc291cmNlRnJhbWUpO1xuXG4gICAgICAgIC8vIGJpbmQgdGhlIHJlbmRlciB0YXJnZXRcbiAgICAgICAgcmVuZGVyZXIuYmluZFJlbmRlclRhcmdldChyZW5kZXJUYXJnZXQpO1xuICAgICAgICByZW5kZXJUYXJnZXQuY2xlYXIoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUG9wcyBvZmYgdGhlIGZpbHRlciBhbmQgYXBwbGllcyBpdC5cbiAgICAgKlxuICAgICAqL1xuXG5cbiAgICBGaWx0ZXJNYW5hZ2VyLnByb3RvdHlwZS5wb3BGaWx0ZXIgPSBmdW5jdGlvbiBwb3BGaWx0ZXIoKSB7XG4gICAgICAgIHZhciBmaWx0ZXJEYXRhID0gdGhpcy5maWx0ZXJEYXRhO1xuXG4gICAgICAgIHZhciBsYXN0U3RhdGUgPSBmaWx0ZXJEYXRhLnN0YWNrW2ZpbHRlckRhdGEuaW5kZXggLSAxXTtcbiAgICAgICAgdmFyIGN1cnJlbnRTdGF0ZSA9IGZpbHRlckRhdGEuc3RhY2tbZmlsdGVyRGF0YS5pbmRleF07XG5cbiAgICAgICAgdGhpcy5xdWFkLm1hcChjdXJyZW50U3RhdGUucmVuZGVyVGFyZ2V0LnNpemUsIGN1cnJlbnRTdGF0ZS5zb3VyY2VGcmFtZSkudXBsb2FkKCk7XG5cbiAgICAgICAgdmFyIGZpbHRlcnMgPSBjdXJyZW50U3RhdGUuZmlsdGVycztcblxuICAgICAgICBpZiAoZmlsdGVycy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGZpbHRlcnNbMF0uYXBwbHkodGhpcywgY3VycmVudFN0YXRlLnJlbmRlclRhcmdldCwgbGFzdFN0YXRlLnJlbmRlclRhcmdldCwgZmFsc2UsIGN1cnJlbnRTdGF0ZSk7XG4gICAgICAgICAgICB0aGlzLmZyZWVQb3RSZW5kZXJUYXJnZXQoY3VycmVudFN0YXRlLnJlbmRlclRhcmdldCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgZmxpcCA9IGN1cnJlbnRTdGF0ZS5yZW5kZXJUYXJnZXQ7XG4gICAgICAgICAgICB2YXIgZmxvcCA9IHRoaXMuZ2V0UG90UmVuZGVyVGFyZ2V0KHRoaXMucmVuZGVyZXIuZ2wsIGN1cnJlbnRTdGF0ZS5zb3VyY2VGcmFtZS53aWR0aCwgY3VycmVudFN0YXRlLnNvdXJjZUZyYW1lLmhlaWdodCwgY3VycmVudFN0YXRlLnJlc29sdXRpb24pO1xuXG4gICAgICAgICAgICBmbG9wLnNldEZyYW1lKGN1cnJlbnRTdGF0ZS5kZXN0aW5hdGlvbkZyYW1lLCBjdXJyZW50U3RhdGUuc291cmNlRnJhbWUpO1xuXG4gICAgICAgICAgICAvLyBmaW5hbGx5IGxldHMgY2xlYXIgdGhlIHJlbmRlciB0YXJnZXQgYmVmb3JlIGRyYXdpbmcgdG8gaXQuLlxuICAgICAgICAgICAgZmxvcC5jbGVhcigpO1xuXG4gICAgICAgICAgICB2YXIgaSA9IDA7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBmaWx0ZXJzLmxlbmd0aCAtIDE7ICsraSkge1xuICAgICAgICAgICAgICAgIGZpbHRlcnNbaV0uYXBwbHkodGhpcywgZmxpcCwgZmxvcCwgdHJ1ZSwgY3VycmVudFN0YXRlKTtcblxuICAgICAgICAgICAgICAgIHZhciB0ID0gZmxpcDtcblxuICAgICAgICAgICAgICAgIGZsaXAgPSBmbG9wO1xuICAgICAgICAgICAgICAgIGZsb3AgPSB0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmaWx0ZXJzW2ldLmFwcGx5KHRoaXMsIGZsaXAsIGxhc3RTdGF0ZS5yZW5kZXJUYXJnZXQsIGZhbHNlLCBjdXJyZW50U3RhdGUpO1xuXG4gICAgICAgICAgICB0aGlzLmZyZWVQb3RSZW5kZXJUYXJnZXQoZmxpcCk7XG4gICAgICAgICAgICB0aGlzLmZyZWVQb3RSZW5kZXJUYXJnZXQoZmxvcCk7XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50U3RhdGUuY2xlYXIoKTtcbiAgICAgICAgZmlsdGVyRGF0YS5pbmRleC0tO1xuXG4gICAgICAgIGlmIChmaWx0ZXJEYXRhLmluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmZpbHRlckRhdGEgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERyYXdzIGEgZmlsdGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLkZpbHRlcn0gZmlsdGVyIC0gVGhlIGZpbHRlciB0byBkcmF3LlxuICAgICAqIEBwYXJhbSB7UElYSS5SZW5kZXJUYXJnZXR9IGlucHV0IC0gVGhlIGlucHV0IHJlbmRlciB0YXJnZXQuXG4gICAgICogQHBhcmFtIHtQSVhJLlJlbmRlclRhcmdldH0gb3V0cHV0IC0gVGhlIHRhcmdldCB0byBvdXRwdXQgdG8uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBjbGVhciAtIFNob3VsZCB0aGUgb3V0cHV0IGJlIGNsZWFyZWQgYmVmb3JlIHJlbmRlcmluZyB0byBpdFxuICAgICAqL1xuXG5cbiAgICBGaWx0ZXJNYW5hZ2VyLnByb3RvdHlwZS5hcHBseUZpbHRlciA9IGZ1bmN0aW9uIGFwcGx5RmlsdGVyKGZpbHRlciwgaW5wdXQsIG91dHB1dCwgY2xlYXIpIHtcbiAgICAgICAgdmFyIHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcjtcbiAgICAgICAgdmFyIGdsID0gcmVuZGVyZXIuZ2w7XG5cbiAgICAgICAgdmFyIHNoYWRlciA9IGZpbHRlci5nbFNoYWRlcnNbcmVuZGVyZXIuQ09OVEVYVF9VSURdO1xuXG4gICAgICAgIC8vIGNhY2hpbmcuLlxuICAgICAgICBpZiAoIXNoYWRlcikge1xuICAgICAgICAgICAgaWYgKGZpbHRlci5nbFNoYWRlcktleSkge1xuICAgICAgICAgICAgICAgIHNoYWRlciA9IHRoaXMuc2hhZGVyQ2FjaGVbZmlsdGVyLmdsU2hhZGVyS2V5XTtcblxuICAgICAgICAgICAgICAgIGlmICghc2hhZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHNoYWRlciA9IG5ldyBfU2hhZGVyMi5kZWZhdWx0KHRoaXMuZ2wsIGZpbHRlci52ZXJ0ZXhTcmMsIGZpbHRlci5mcmFnbWVudFNyYyk7XG5cbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyLmdsU2hhZGVyc1tyZW5kZXJlci5DT05URVhUX1VJRF0gPSB0aGlzLnNoYWRlckNhY2hlW2ZpbHRlci5nbFNoYWRlcktleV0gPSBzaGFkZXI7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWFuYWdlZEZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2hhZGVyID0gZmlsdGVyLmdsU2hhZGVyc1tyZW5kZXJlci5DT05URVhUX1VJRF0gPSBuZXcgX1NoYWRlcjIuZGVmYXVsdCh0aGlzLmdsLCBmaWx0ZXIudmVydGV4U3JjLCBmaWx0ZXIuZnJhZ21lbnRTcmMpO1xuICAgICAgICAgICAgICAgIHRoaXMubWFuYWdlZEZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBUT0RPIC0gdGhpcyBvbmx5IG5lZWRzIHRvIGJlIGRvbmUgb25jZT9cbiAgICAgICAgICAgIHJlbmRlcmVyLmJpbmRWYW8obnVsbCk7XG5cbiAgICAgICAgICAgIHRoaXMucXVhZC5pbml0VmFvKHNoYWRlcik7XG4gICAgICAgIH1cblxuICAgICAgICByZW5kZXJlci5iaW5kVmFvKHRoaXMucXVhZC52YW8pO1xuXG4gICAgICAgIHJlbmRlcmVyLmJpbmRSZW5kZXJUYXJnZXQob3V0cHV0KTtcblxuICAgICAgICBpZiAoY2xlYXIpIHtcbiAgICAgICAgICAgIGdsLmRpc2FibGUoZ2wuU0NJU1NPUl9URVNUKTtcbiAgICAgICAgICAgIHJlbmRlcmVyLmNsZWFyKCk7IC8vIFsxLCAxLCAxLCAxXSk7XG4gICAgICAgICAgICBnbC5lbmFibGUoZ2wuU0NJU1NPUl9URVNUKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGluIGNhc2UgdGhlIHJlbmRlciB0YXJnZXQgaXMgYmVpbmcgbWFza2VkIHVzaW5nIGEgc2Npc3NvciByZWN0XG4gICAgICAgIGlmIChvdXRwdXQgPT09IHJlbmRlcmVyLm1hc2tNYW5hZ2VyLnNjaXNzb3JSZW5kZXJUYXJnZXQpIHtcbiAgICAgICAgICAgIHJlbmRlcmVyLm1hc2tNYW5hZ2VyLnB1c2hTY2lzc29yTWFzayhudWxsLCByZW5kZXJlci5tYXNrTWFuYWdlci5zY2lzc29yRGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICByZW5kZXJlci5iaW5kU2hhZGVyKHNoYWRlcik7XG5cbiAgICAgICAgLy8gZnJlZSB1bml0IDAgZm9yIHVzLCBkb2Vzbid0IG1hdHRlciB3aGF0IHdhcyB0aGVyZVxuICAgICAgICAvLyBkb24ndCB0cnkgdG8gcmVzdG9yZSBpdCwgYmVjYXVzZSBzeW5jVW5pZm9ybXMgY2FuIHVwbG9hZCBpdCB0byBhbm90aGVyIHNsb3RcbiAgICAgICAgLy8gYW5kIGl0J2xsIGJlIGEgcHJvYmxlbVxuICAgICAgICB2YXIgdGV4ID0gdGhpcy5yZW5kZXJlci5lbXB0eVRleHR1cmVzWzBdO1xuXG4gICAgICAgIHRoaXMucmVuZGVyZXIuYm91bmRUZXh0dXJlc1swXSA9IHRleDtcbiAgICAgICAgLy8gdGhpcyBzeW5jcyB0aGUgUGl4aUpTIGZpbHRlcnMgIHVuaWZvcm1zIHdpdGggZ2xzbCB1bmlmb3Jtc1xuICAgICAgICB0aGlzLnN5bmNVbmlmb3JtcyhzaGFkZXIsIGZpbHRlcik7XG5cbiAgICAgICAgcmVuZGVyZXIuc3RhdGUuc2V0QmxlbmRNb2RlKGZpbHRlci5ibGVuZE1vZGUpO1xuXG4gICAgICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTApO1xuICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBpbnB1dC50ZXh0dXJlLnRleHR1cmUpO1xuXG4gICAgICAgIHRoaXMucXVhZC52YW8uZHJhdyh0aGlzLnJlbmRlcmVyLmdsLlRSSUFOR0xFUywgNiwgMCk7XG5cbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4Ll9nbFRleHR1cmVzW3RoaXMucmVuZGVyZXIuQ09OVEVYVF9VSURdLnRleHR1cmUpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBVcGxvYWRzIHRoZSB1bmlmb3JtcyBvZiB0aGUgZmlsdGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtHTFNoYWRlcn0gc2hhZGVyIC0gVGhlIHVuZGVybHlpbmcgZ2wgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7UElYSS5GaWx0ZXJ9IGZpbHRlciAtIFRoZSBmaWx0ZXIgd2UgYXJlIHN5bmNocm9uaXppbmcuXG4gICAgICovXG5cblxuICAgIEZpbHRlck1hbmFnZXIucHJvdG90eXBlLnN5bmNVbmlmb3JtcyA9IGZ1bmN0aW9uIHN5bmNVbmlmb3JtcyhzaGFkZXIsIGZpbHRlcikge1xuICAgICAgICB2YXIgdW5pZm9ybURhdGEgPSBmaWx0ZXIudW5pZm9ybURhdGE7XG4gICAgICAgIHZhciB1bmlmb3JtcyA9IGZpbHRlci51bmlmb3JtcztcblxuICAgICAgICAvLyAwIGlzIHJlc2VydmVkIGZvciB0aGUgUGl4aUpTIHRleHR1cmUgc28gd2Ugc3RhcnQgYXQgMSFcbiAgICAgICAgdmFyIHRleHR1cmVDb3VudCA9IDE7XG4gICAgICAgIHZhciBjdXJyZW50U3RhdGUgPSB2b2lkIDA7XG5cbiAgICAgICAgLy8gZmlsdGVyQXJlYSBhbmQgZmlsdGVyQ2xhbXAgdGhhdCBhcmUgaGFuZGxlZCBieSBGaWx0ZXJNYW5hZ2VyIGRpcmVjdGx5XG4gICAgICAgIC8vIHRoZXkgbXVzdCBub3QgYXBwZWFyIGluIHVuaWZvcm1EYXRhXG5cbiAgICAgICAgaWYgKHNoYWRlci51bmlmb3Jtcy5maWx0ZXJBcmVhKSB7XG4gICAgICAgICAgICBjdXJyZW50U3RhdGUgPSB0aGlzLmZpbHRlckRhdGEuc3RhY2tbdGhpcy5maWx0ZXJEYXRhLmluZGV4XTtcblxuICAgICAgICAgICAgdmFyIGZpbHRlckFyZWEgPSBzaGFkZXIudW5pZm9ybXMuZmlsdGVyQXJlYTtcblxuICAgICAgICAgICAgZmlsdGVyQXJlYVswXSA9IGN1cnJlbnRTdGF0ZS5yZW5kZXJUYXJnZXQuc2l6ZS53aWR0aDtcbiAgICAgICAgICAgIGZpbHRlckFyZWFbMV0gPSBjdXJyZW50U3RhdGUucmVuZGVyVGFyZ2V0LnNpemUuaGVpZ2h0O1xuICAgICAgICAgICAgZmlsdGVyQXJlYVsyXSA9IGN1cnJlbnRTdGF0ZS5zb3VyY2VGcmFtZS54O1xuICAgICAgICAgICAgZmlsdGVyQXJlYVszXSA9IGN1cnJlbnRTdGF0ZS5zb3VyY2VGcmFtZS55O1xuXG4gICAgICAgICAgICBzaGFkZXIudW5pZm9ybXMuZmlsdGVyQXJlYSA9IGZpbHRlckFyZWE7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB1c2UgdGhpcyB0byBjbGFtcCBkaXNwbGFjZWQgdGV4dHVyZSBjb29yZHMgc28gdGhleSBiZWxvbmcgdG8gZmlsdGVyQXJlYVxuICAgICAgICAvLyBzZWUgZGlzcGxhY2VtZW50RmlsdGVyIGZyYWdtZW50IHNoYWRlciBmb3IgYW4gZXhhbXBsZVxuICAgICAgICBpZiAoc2hhZGVyLnVuaWZvcm1zLmZpbHRlckNsYW1wKSB7XG4gICAgICAgICAgICBjdXJyZW50U3RhdGUgPSBjdXJyZW50U3RhdGUgfHwgdGhpcy5maWx0ZXJEYXRhLnN0YWNrW3RoaXMuZmlsdGVyRGF0YS5pbmRleF07XG5cbiAgICAgICAgICAgIHZhciBmaWx0ZXJDbGFtcCA9IHNoYWRlci51bmlmb3Jtcy5maWx0ZXJDbGFtcDtcblxuICAgICAgICAgICAgZmlsdGVyQ2xhbXBbMF0gPSAwO1xuICAgICAgICAgICAgZmlsdGVyQ2xhbXBbMV0gPSAwO1xuICAgICAgICAgICAgZmlsdGVyQ2xhbXBbMl0gPSAoY3VycmVudFN0YXRlLnNvdXJjZUZyYW1lLndpZHRoIC0gMSkgLyBjdXJyZW50U3RhdGUucmVuZGVyVGFyZ2V0LnNpemUud2lkdGg7XG4gICAgICAgICAgICBmaWx0ZXJDbGFtcFszXSA9IChjdXJyZW50U3RhdGUuc291cmNlRnJhbWUuaGVpZ2h0IC0gMSkgLyBjdXJyZW50U3RhdGUucmVuZGVyVGFyZ2V0LnNpemUuaGVpZ2h0O1xuXG4gICAgICAgICAgICBzaGFkZXIudW5pZm9ybXMuZmlsdGVyQ2xhbXAgPSBmaWx0ZXJDbGFtcDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRPRE8gQ2FjaGluZyBsYXllci4uXG4gICAgICAgIGZvciAodmFyIGkgaW4gdW5pZm9ybURhdGEpIHtcbiAgICAgICAgICAgIGlmICghc2hhZGVyLnVuaWZvcm1zLmRhdGFbaV0pIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHR5cGUgPSB1bmlmb3JtRGF0YVtpXS50eXBlO1xuXG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ3NhbXBsZXIyZCcgJiYgdW5pZm9ybXNbaV0gIT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAodW5pZm9ybXNbaV0uYmFzZVRleHR1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2hhZGVyLnVuaWZvcm1zW2ldID0gdGhpcy5yZW5kZXJlci5iaW5kVGV4dHVyZSh1bmlmb3Jtc1tpXS5iYXNlVGV4dHVyZSwgdGV4dHVyZUNvdW50KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzaGFkZXIudW5pZm9ybXNbaV0gPSB0ZXh0dXJlQ291bnQ7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ET1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIGhlbHBmdWwgYXMgcmVuZGVyVGFyZ2V0cyBjYW4gYWxzbyBiZSBzZXQuXG4gICAgICAgICAgICAgICAgICAgIC8vIEFsdGhvdWdoIHRoaW5raW5nIGFib3V0IGl0LCB3ZSBjb3VsZCBwcm9iYWJseVxuICAgICAgICAgICAgICAgICAgICAvLyBtYWtlIHRoZSBmaWx0ZXIgdGV4dHVyZSBjYWNoZSByZXR1cm4gYSBSZW5kZXJUZXh0dXJlXG4gICAgICAgICAgICAgICAgICAgIC8vIHJhdGhlciB0aGFuIGEgcmVuZGVyVGFyZ2V0XG4gICAgICAgICAgICAgICAgICAgIHZhciBnbCA9IHRoaXMucmVuZGVyZXIuZ2w7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5ib3VuZFRleHR1cmVzW3RleHR1cmVDb3VudF0gPSB0aGlzLnJlbmRlcmVyLmVtcHR5VGV4dHVyZXNbdGV4dHVyZUNvdW50XTtcbiAgICAgICAgICAgICAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIHRleHR1cmVDb3VudCk7XG5cbiAgICAgICAgICAgICAgICAgICAgdW5pZm9ybXNbaV0udGV4dHVyZS5iaW5kKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGV4dHVyZUNvdW50Kys7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdtYXQzJykge1xuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIGl0cyBQaXhpSlMgbWF0cml4Li5cbiAgICAgICAgICAgICAgICBpZiAodW5pZm9ybXNbaV0uYSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHNoYWRlci51bmlmb3Jtc1tpXSA9IHVuaWZvcm1zW2ldLnRvQXJyYXkodHJ1ZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2hhZGVyLnVuaWZvcm1zW2ldID0gdW5pZm9ybXNbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAndmVjMicpIHtcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiBpdHMgYSBwb2ludC4uXG4gICAgICAgICAgICAgICAgaWYgKHVuaWZvcm1zW2ldLnggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsID0gc2hhZGVyLnVuaWZvcm1zW2ldIHx8IG5ldyBGbG9hdDMyQXJyYXkoMik7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFsWzBdID0gdW5pZm9ybXNbaV0ueDtcbiAgICAgICAgICAgICAgICAgICAgdmFsWzFdID0gdW5pZm9ybXNbaV0ueTtcbiAgICAgICAgICAgICAgICAgICAgc2hhZGVyLnVuaWZvcm1zW2ldID0gdmFsO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNoYWRlci51bmlmb3Jtc1tpXSA9IHVuaWZvcm1zW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2Zsb2F0Jykge1xuICAgICAgICAgICAgICAgIGlmIChzaGFkZXIudW5pZm9ybXMuZGF0YVtpXS52YWx1ZSAhPT0gdW5pZm9ybURhdGFbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgc2hhZGVyLnVuaWZvcm1zW2ldID0gdW5pZm9ybXNbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzaGFkZXIudW5pZm9ybXNbaV0gPSB1bmlmb3Jtc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgcmVuZGVyIHRhcmdldCBmcm9tIHRoZSBwb29sLCBvciBjcmVhdGVzIGEgbmV3IG9uZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gY2xlYXIgLSBTaG91bGQgd2UgY2xlYXIgdGhlIHJlbmRlciB0ZXh0dXJlIHdoZW4gd2UgZ2V0IGl0P1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uIC0gVGhlIHJlc29sdXRpb24gb2YgdGhlIHRhcmdldC5cbiAgICAgKiBAcmV0dXJuIHtQSVhJLlJlbmRlclRhcmdldH0gVGhlIG5ldyByZW5kZXIgdGFyZ2V0XG4gICAgICovXG5cblxuICAgIEZpbHRlck1hbmFnZXIucHJvdG90eXBlLmdldFJlbmRlclRhcmdldCA9IGZ1bmN0aW9uIGdldFJlbmRlclRhcmdldChjbGVhciwgcmVzb2x1dGlvbikge1xuICAgICAgICB2YXIgY3VycmVudFN0YXRlID0gdGhpcy5maWx0ZXJEYXRhLnN0YWNrW3RoaXMuZmlsdGVyRGF0YS5pbmRleF07XG4gICAgICAgIHZhciByZW5kZXJUYXJnZXQgPSB0aGlzLmdldFBvdFJlbmRlclRhcmdldCh0aGlzLnJlbmRlcmVyLmdsLCBjdXJyZW50U3RhdGUuc291cmNlRnJhbWUud2lkdGgsIGN1cnJlbnRTdGF0ZS5zb3VyY2VGcmFtZS5oZWlnaHQsIHJlc29sdXRpb24gfHwgY3VycmVudFN0YXRlLnJlc29sdXRpb24pO1xuXG4gICAgICAgIHJlbmRlclRhcmdldC5zZXRGcmFtZShjdXJyZW50U3RhdGUuZGVzdGluYXRpb25GcmFtZSwgY3VycmVudFN0YXRlLnNvdXJjZUZyYW1lKTtcblxuICAgICAgICByZXR1cm4gcmVuZGVyVGFyZ2V0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcmVuZGVyIHRhcmdldCB0byB0aGUgcG9vbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5SZW5kZXJUYXJnZXR9IHJlbmRlclRhcmdldCAtIFRoZSByZW5kZXIgdGFyZ2V0IHRvIHJldHVybi5cbiAgICAgKi9cblxuXG4gICAgRmlsdGVyTWFuYWdlci5wcm90b3R5cGUucmV0dXJuUmVuZGVyVGFyZ2V0ID0gZnVuY3Rpb24gcmV0dXJuUmVuZGVyVGFyZ2V0KHJlbmRlclRhcmdldCkge1xuICAgICAgICB0aGlzLmZyZWVQb3RSZW5kZXJUYXJnZXQocmVuZGVyVGFyZ2V0KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgbWFwcGVkIG1hdHJpeC5cbiAgICAgKlxuICAgICAqIFRPRE8gcGxheWluZyBhcm91bmQgaGVyZS4uIHRoaXMgaXMgdGVtcG9yYXJ5IC0gKHdpbGwgZW5kIHVwIGluIHRoZSBzaGFkZXIpXG4gICAgICogdGhpcyByZXR1cm5zIGEgbWF0cml4IHRoYXQgd2lsbCBub3JtYWxpc2UgbWFwIGZpbHRlciBjb3JkcyBpbiB0aGUgZmlsdGVyIHRvIHNjcmVlbiBzcGFjZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLk1hdHJpeH0gb3V0cHV0TWF0cml4IC0gdGhlIG1hdHJpeCB0byBvdXRwdXQgdG8uXG4gICAgICogQHJldHVybiB7UElYSS5NYXRyaXh9IFRoZSBtYXBwZWQgbWF0cml4LlxuICAgICAqL1xuXG5cbiAgICBGaWx0ZXJNYW5hZ2VyLnByb3RvdHlwZS5jYWxjdWxhdGVTY3JlZW5TcGFjZU1hdHJpeCA9IGZ1bmN0aW9uIGNhbGN1bGF0ZVNjcmVlblNwYWNlTWF0cml4KG91dHB1dE1hdHJpeCkge1xuICAgICAgICB2YXIgY3VycmVudFN0YXRlID0gdGhpcy5maWx0ZXJEYXRhLnN0YWNrW3RoaXMuZmlsdGVyRGF0YS5pbmRleF07XG5cbiAgICAgICAgcmV0dXJuIGZpbHRlclRyYW5zZm9ybXMuY2FsY3VsYXRlU2NyZWVuU3BhY2VNYXRyaXgob3V0cHV0TWF0cml4LCBjdXJyZW50U3RhdGUuc291cmNlRnJhbWUsIGN1cnJlbnRTdGF0ZS5yZW5kZXJUYXJnZXQuc2l6ZSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIE11bHRpcGx5IHZUZXh0dXJlQ29vcmQgdG8gdGhpcyBtYXRyaXggdG8gYWNoaWV2ZSAoMCwwLDEsMSkgZm9yIGZpbHRlckFyZWFcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5NYXRyaXh9IG91dHB1dE1hdHJpeCAtIFRoZSBtYXRyaXggdG8gb3V0cHV0IHRvLlxuICAgICAqIEByZXR1cm4ge1BJWEkuTWF0cml4fSBUaGUgbWFwcGVkIG1hdHJpeC5cbiAgICAgKi9cblxuXG4gICAgRmlsdGVyTWFuYWdlci5wcm90b3R5cGUuY2FsY3VsYXRlTm9ybWFsaXplZFNjcmVlblNwYWNlTWF0cml4ID0gZnVuY3Rpb24gY2FsY3VsYXRlTm9ybWFsaXplZFNjcmVlblNwYWNlTWF0cml4KG91dHB1dE1hdHJpeCkge1xuICAgICAgICB2YXIgY3VycmVudFN0YXRlID0gdGhpcy5maWx0ZXJEYXRhLnN0YWNrW3RoaXMuZmlsdGVyRGF0YS5pbmRleF07XG5cbiAgICAgICAgcmV0dXJuIGZpbHRlclRyYW5zZm9ybXMuY2FsY3VsYXRlTm9ybWFsaXplZFNjcmVlblNwYWNlTWF0cml4KG91dHB1dE1hdHJpeCwgY3VycmVudFN0YXRlLnNvdXJjZUZyYW1lLCBjdXJyZW50U3RhdGUucmVuZGVyVGFyZ2V0LnNpemUsIGN1cnJlbnRTdGF0ZS5kZXN0aW5hdGlvbkZyYW1lKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhpcyB3aWxsIG1hcCB0aGUgZmlsdGVyIGNvb3JkIHNvIHRoYXQgYSB0ZXh0dXJlIGNhbiBiZSB1c2VkIGJhc2VkIG9uIHRoZSB0cmFuc2Zvcm0gb2YgYSBzcHJpdGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5NYXRyaXh9IG91dHB1dE1hdHJpeCAtIFRoZSBtYXRyaXggdG8gb3V0cHV0IHRvLlxuICAgICAqIEBwYXJhbSB7UElYSS5TcHJpdGV9IHNwcml0ZSAtIFRoZSBzcHJpdGUgdG8gbWFwIHRvLlxuICAgICAqIEByZXR1cm4ge1BJWEkuTWF0cml4fSBUaGUgbWFwcGVkIG1hdHJpeC5cbiAgICAgKi9cblxuXG4gICAgRmlsdGVyTWFuYWdlci5wcm90b3R5cGUuY2FsY3VsYXRlU3ByaXRlTWF0cml4ID0gZnVuY3Rpb24gY2FsY3VsYXRlU3ByaXRlTWF0cml4KG91dHB1dE1hdHJpeCwgc3ByaXRlKSB7XG4gICAgICAgIHZhciBjdXJyZW50U3RhdGUgPSB0aGlzLmZpbHRlckRhdGEuc3RhY2tbdGhpcy5maWx0ZXJEYXRhLmluZGV4XTtcblxuICAgICAgICByZXR1cm4gZmlsdGVyVHJhbnNmb3Jtcy5jYWxjdWxhdGVTcHJpdGVNYXRyaXgob3V0cHV0TWF0cml4LCBjdXJyZW50U3RhdGUuc291cmNlRnJhbWUsIGN1cnJlbnRTdGF0ZS5yZW5kZXJUYXJnZXQuc2l6ZSwgc3ByaXRlKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGVzdHJveXMgdGhpcyBGaWx0ZXIgTWFuYWdlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2NvbnRleHRMb3N0PWZhbHNlXSBjb250ZXh0IHdhcyBsb3N0LCBkbyBub3QgZnJlZSBzaGFkZXJzXG4gICAgICpcbiAgICAgKi9cblxuXG4gICAgRmlsdGVyTWFuYWdlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIHZhciBjb250ZXh0TG9zdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZmFsc2U7XG5cbiAgICAgICAgdmFyIHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcjtcbiAgICAgICAgdmFyIGZpbHRlcnMgPSB0aGlzLm1hbmFnZWRGaWx0ZXJzO1xuXG4gICAgICAgIHJlbmRlcmVyLm9mZigncHJlcmVuZGVyJywgdGhpcy5vblByZXJlbmRlciwgdGhpcyk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWx0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIWNvbnRleHRMb3N0KSB7XG4gICAgICAgICAgICAgICAgZmlsdGVyc1tpXS5nbFNoYWRlcnNbcmVuZGVyZXIuQ09OVEVYVF9VSURdLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlbGV0ZSBmaWx0ZXJzW2ldLmdsU2hhZGVyc1tyZW5kZXJlci5DT05URVhUX1VJRF07XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNoYWRlckNhY2hlID0ge307XG4gICAgICAgIGlmICghY29udGV4dExvc3QpIHtcbiAgICAgICAgICAgIHRoaXMuZW1wdHlQb29sKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnBvb2wgPSB7fTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgUG93ZXItb2YtVHdvIHJlbmRlciB0ZXh0dXJlLlxuICAgICAqXG4gICAgICogVE9ETyBtb3ZlIHRvIGEgc2VwYXJhdGUgY2xhc3MgY291bGQgYmUgb24gcmVuZGVyZXI/XG4gICAgICogYWxzbyAtIGNvdWxkIGNhdXNlIGlzc3VlIHdpdGggbXVsdGlwbGUgY29udGV4dHM/XG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCAtIFRoZSB3ZWJnbCByZW5kZXJpbmcgY29udGV4dFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaW5XaWR0aCAtIFRoZSBtaW5pbXVtIHdpZHRoIG9mIHRoZSByZW5kZXIgdGFyZ2V0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaW5IZWlnaHQgLSBUaGUgbWluaW11bSBoZWlnaHQgb2YgdGhlIHJlbmRlciB0YXJnZXQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJlc29sdXRpb24gLSBUaGUgcmVzb2x1dGlvbiBvZiB0aGUgcmVuZGVyIHRhcmdldC5cbiAgICAgKiBAcmV0dXJuIHtQSVhJLlJlbmRlclRhcmdldH0gVGhlIG5ldyByZW5kZXIgdGFyZ2V0LlxuICAgICAqL1xuXG5cbiAgICBGaWx0ZXJNYW5hZ2VyLnByb3RvdHlwZS5nZXRQb3RSZW5kZXJUYXJnZXQgPSBmdW5jdGlvbiBnZXRQb3RSZW5kZXJUYXJnZXQoZ2wsIG1pbldpZHRoLCBtaW5IZWlnaHQsIHJlc29sdXRpb24pIHtcbiAgICAgICAgdmFyIGtleSA9IHNjcmVlbktleTtcblxuICAgICAgICBtaW5XaWR0aCAqPSByZXNvbHV0aW9uO1xuICAgICAgICBtaW5IZWlnaHQgKj0gcmVzb2x1dGlvbjtcblxuICAgICAgICBpZiAobWluV2lkdGggIT09IHRoaXMuX3NjcmVlbldpZHRoIHx8IG1pbkhlaWdodCAhPT0gdGhpcy5fc2NyZWVuSGVpZ2h0KSB7XG4gICAgICAgICAgICAvLyBUT0RPIHlvdSBjb3VsZCByZXR1cm4gYSBiaWdnZXIgdGV4dHVyZSBpZiB0aGVyZSBpcyBub3Qgb25lIGluIHRoZSBwb29sP1xuICAgICAgICAgICAgbWluV2lkdGggPSBfYml0VHdpZGRsZTIuZGVmYXVsdC5uZXh0UG93MihtaW5XaWR0aCk7XG4gICAgICAgICAgICBtaW5IZWlnaHQgPSBfYml0VHdpZGRsZTIuZGVmYXVsdC5uZXh0UG93MihtaW5IZWlnaHQpO1xuICAgICAgICAgICAga2V5ID0gKG1pbldpZHRoICYgMHhGRkZGKSA8PCAxNiB8IG1pbkhlaWdodCAmIDB4RkZGRjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5wb29sW2tleV0pIHtcbiAgICAgICAgICAgIHRoaXMucG9vbFtrZXldID0gW107XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVuZGVyVGFyZ2V0ID0gdGhpcy5wb29sW2tleV0ucG9wKCk7XG5cbiAgICAgICAgLy8gY3JlYXRpbmcgcmVuZGVyIHRhcmdldCB3aWxsIGNhdXNlIHRleHR1cmUgdG8gYmUgYm91bmQhXG4gICAgICAgIGlmICghcmVuZGVyVGFyZ2V0KSB7XG4gICAgICAgICAgICAvLyB0ZW1wb3JhcnkgYnlwYXNzIGNhY2hlLi5cbiAgICAgICAgICAgIHZhciB0ZXggPSB0aGlzLnJlbmRlcmVyLmJvdW5kVGV4dHVyZXNbMF07XG5cbiAgICAgICAgICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTApO1xuXG4gICAgICAgICAgICAvLyBpbnRlcm5hbGx5IC0gdGhpcyB3aWxsIGNhdXNlIGEgdGV4dHVyZSB0byBiZSBib3VuZC4uXG4gICAgICAgICAgICByZW5kZXJUYXJnZXQgPSBuZXcgX1JlbmRlclRhcmdldDIuZGVmYXVsdChnbCwgbWluV2lkdGgsIG1pbkhlaWdodCwgbnVsbCwgMSk7XG5cbiAgICAgICAgICAgIC8vIHNldCB0aGUgY3VycmVudCBvbmUgYmFja1xuICAgICAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4Ll9nbFRleHR1cmVzW3RoaXMucmVuZGVyZXIuQ09OVEVYVF9VSURdLnRleHR1cmUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbWFudWFsbHkgdHdlYWsgdGhlIHJlc29sdXRpb24uLi5cbiAgICAgICAgLy8gdGhpcyB3aWxsIG5vdCBtb2RpZnkgdGhlIHNpemUgb2YgdGhlIGZyYW1lIGJ1ZmZlciwganVzdCBpdHMgcmVzb2x1dGlvbi5cbiAgICAgICAgcmVuZGVyVGFyZ2V0LnJlc29sdXRpb24gPSByZXNvbHV0aW9uO1xuICAgICAgICByZW5kZXJUYXJnZXQuZGVmYXVsdEZyYW1lLndpZHRoID0gcmVuZGVyVGFyZ2V0LnNpemUud2lkdGggPSBtaW5XaWR0aCAvIHJlc29sdXRpb247XG4gICAgICAgIHJlbmRlclRhcmdldC5kZWZhdWx0RnJhbWUuaGVpZ2h0ID0gcmVuZGVyVGFyZ2V0LnNpemUuaGVpZ2h0ID0gbWluSGVpZ2h0IC8gcmVzb2x1dGlvbjtcbiAgICAgICAgcmVuZGVyVGFyZ2V0LmZpbHRlclBvb2xLZXkgPSBrZXk7XG5cbiAgICAgICAgcmV0dXJuIHJlbmRlclRhcmdldDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRW1wdGllcyB0aGUgdGV4dHVyZSBwb29sLlxuICAgICAqXG4gICAgICovXG5cblxuICAgIEZpbHRlck1hbmFnZXIucHJvdG90eXBlLmVtcHR5UG9vbCA9IGZ1bmN0aW9uIGVtcHR5UG9vbCgpIHtcbiAgICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLnBvb2wpIHtcbiAgICAgICAgICAgIHZhciB0ZXh0dXJlcyA9IHRoaXMucG9vbFtpXTtcblxuICAgICAgICAgICAgaWYgKHRleHR1cmVzKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0ZXh0dXJlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlc1tqXS5kZXN0cm95KHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucG9vbCA9IHt9O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGcmVlcyBhIHJlbmRlciB0YXJnZXQgYmFjayBpbnRvIHRoZSBwb29sLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLlJlbmRlclRhcmdldH0gcmVuZGVyVGFyZ2V0IC0gVGhlIHJlbmRlclRhcmdldCB0byBmcmVlXG4gICAgICovXG5cblxuICAgIEZpbHRlck1hbmFnZXIucHJvdG90eXBlLmZyZWVQb3RSZW5kZXJUYXJnZXQgPSBmdW5jdGlvbiBmcmVlUG90UmVuZGVyVGFyZ2V0KHJlbmRlclRhcmdldCkge1xuICAgICAgICB0aGlzLnBvb2xbcmVuZGVyVGFyZ2V0LmZpbHRlclBvb2xLZXldLnB1c2gocmVuZGVyVGFyZ2V0KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIGJlZm9yZSB0aGUgcmVuZGVyZXIgc3RhcnRzIHJlbmRlcmluZy5cbiAgICAgKlxuICAgICAqL1xuXG5cbiAgICBGaWx0ZXJNYW5hZ2VyLnByb3RvdHlwZS5vblByZXJlbmRlciA9IGZ1bmN0aW9uIG9uUHJlcmVuZGVyKCkge1xuICAgICAgICBpZiAodGhpcy5fc2NyZWVuV2lkdGggIT09IHRoaXMucmVuZGVyZXIudmlldy53aWR0aCB8fCB0aGlzLl9zY3JlZW5IZWlnaHQgIT09IHRoaXMucmVuZGVyZXIudmlldy5oZWlnaHQpIHtcbiAgICAgICAgICAgIHRoaXMuX3NjcmVlbldpZHRoID0gdGhpcy5yZW5kZXJlci52aWV3LndpZHRoO1xuICAgICAgICAgICAgdGhpcy5fc2NyZWVuSGVpZ2h0ID0gdGhpcy5yZW5kZXJlci52aWV3LmhlaWdodDtcblxuICAgICAgICAgICAgdmFyIHRleHR1cmVzID0gdGhpcy5wb29sW3NjcmVlbktleV07XG5cbiAgICAgICAgICAgIGlmICh0ZXh0dXJlcykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGV4dHVyZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dHVyZXNbal0uZGVzdHJveSh0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnBvb2xbc2NyZWVuS2V5XSA9IFtdO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBGaWx0ZXJNYW5hZ2VyO1xufShfV2ViR0xNYW5hZ2VyMy5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gRmlsdGVyTWFuYWdlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZpbHRlck1hbmFnZXIuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX1dlYkdMTWFuYWdlcjIgPSByZXF1aXJlKCcuL1dlYkdMTWFuYWdlcicpO1xuXG52YXIgX1dlYkdMTWFuYWdlcjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9XZWJHTE1hbmFnZXIyKTtcblxudmFyIF9TcHJpdGVNYXNrRmlsdGVyID0gcmVxdWlyZSgnLi4vZmlsdGVycy9zcHJpdGVNYXNrL1Nwcml0ZU1hc2tGaWx0ZXInKTtcblxudmFyIF9TcHJpdGVNYXNrRmlsdGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1Nwcml0ZU1hc2tGaWx0ZXIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbi8qKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQSVhJLldlYkdMTWFuYWdlclxuICogQG1lbWJlcm9mIFBJWElcbiAqL1xudmFyIE1hc2tNYW5hZ2VyID0gZnVuY3Rpb24gKF9XZWJHTE1hbmFnZXIpIHtcbiAgICBfaW5oZXJpdHMoTWFza01hbmFnZXIsIF9XZWJHTE1hbmFnZXIpO1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtQSVhJLldlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyIHRoaXMgbWFuYWdlciB3b3JrcyBmb3IuXG4gICAgICovXG4gICAgZnVuY3Rpb24gTWFza01hbmFnZXIocmVuZGVyZXIpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1hc2tNYW5hZ2VyKTtcblxuICAgICAgICAvLyBUT0RPIC0gd2UgZG9uJ3QgbmVlZCBib3RoIVxuICAgICAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfV2ViR0xNYW5hZ2VyLmNhbGwodGhpcywgcmVuZGVyZXIpKTtcblxuICAgICAgICBfdGhpcy5zY2lzc29yID0gZmFsc2U7XG4gICAgICAgIF90aGlzLnNjaXNzb3JEYXRhID0gbnVsbDtcbiAgICAgICAgX3RoaXMuc2Npc3NvclJlbmRlclRhcmdldCA9IG51bGw7XG5cbiAgICAgICAgX3RoaXMuZW5hYmxlU2Npc3NvciA9IHRydWU7XG5cbiAgICAgICAgX3RoaXMuYWxwaGFNYXNrUG9vbCA9IFtdO1xuICAgICAgICBfdGhpcy5hbHBoYU1hc2tJbmRleCA9IDA7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIHRoZSBNYXNrIGFuZCBhZGRzIGl0IHRvIHRoZSBjdXJyZW50IGZpbHRlciBzdGFjay5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5EaXNwbGF5T2JqZWN0fSB0YXJnZXQgLSBEaXNwbGF5IE9iamVjdCB0byBwdXNoIHRoZSBtYXNrIHRvXG4gICAgICogQHBhcmFtIHtQSVhJLlNwcml0ZXxQSVhJLkdyYXBoaWNzfSBtYXNrRGF0YSAtIFRoZSBtYXNraW5nIGRhdGEuXG4gICAgICovXG5cblxuICAgIE1hc2tNYW5hZ2VyLnByb3RvdHlwZS5wdXNoTWFzayA9IGZ1bmN0aW9uIHB1c2hNYXNrKHRhcmdldCwgbWFza0RhdGEpIHtcbiAgICAgICAgLy8gVE9ETyB0aGUgcm9vdCBjaGVjayBtZWFucyBzY2lzc29yIHJlY3Qgd2lsbCBub3RcbiAgICAgICAgLy8gYmUgdXNlZCBvbiByZW5kZXIgdGV4dHVyZXMgbW9yZSBpbmZvIGhlcmU6XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9waXhpanMvcGl4aS5qcy9wdWxsLzM1NDVcblxuICAgICAgICBpZiAobWFza0RhdGEudGV4dHVyZSkge1xuICAgICAgICAgICAgdGhpcy5wdXNoU3ByaXRlTWFzayh0YXJnZXQsIG1hc2tEYXRhKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmVuYWJsZVNjaXNzb3IgJiYgIXRoaXMuc2Npc3NvciAmJiB0aGlzLnJlbmRlcmVyLl9hY3RpdmVSZW5kZXJUYXJnZXQucm9vdCAmJiAhdGhpcy5yZW5kZXJlci5zdGVuY2lsTWFuYWdlci5zdGVuY2lsTWFza1N0YWNrLmxlbmd0aCAmJiBtYXNrRGF0YS5pc0Zhc3RSZWN0KCkpIHtcbiAgICAgICAgICAgIHZhciBtYXRyaXggPSBtYXNrRGF0YS53b3JsZFRyYW5zZm9ybTtcblxuICAgICAgICAgICAgdmFyIHJvdCA9IE1hdGguYXRhbjIobWF0cml4LmIsIG1hdHJpeC5hKTtcblxuICAgICAgICAgICAgLy8gdXNlIHRoZSBuZWFyZXN0IGRlZ3JlZSFcbiAgICAgICAgICAgIHJvdCA9IE1hdGgucm91bmQocm90ICogKDE4MCAvIE1hdGguUEkpKTtcblxuICAgICAgICAgICAgaWYgKHJvdCAlIDkwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wdXNoU3RlbmNpbE1hc2sobWFza0RhdGEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnB1c2hTY2lzc29yTWFzayh0YXJnZXQsIG1hc2tEYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucHVzaFN0ZW5jaWxNYXNrKG1hc2tEYXRhKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBsYXN0IG1hc2sgZnJvbSB0aGUgbWFzayBzdGFjayBhbmQgZG9lc24ndCByZXR1cm4gaXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuRGlzcGxheU9iamVjdH0gdGFyZ2V0IC0gRGlzcGxheSBPYmplY3QgdG8gcG9wIHRoZSBtYXNrIGZyb21cbiAgICAgKiBAcGFyYW0ge1BJWEkuU3ByaXRlfFBJWEkuR3JhcGhpY3N9IG1hc2tEYXRhIC0gVGhlIG1hc2tpbmcgZGF0YS5cbiAgICAgKi9cblxuXG4gICAgTWFza01hbmFnZXIucHJvdG90eXBlLnBvcE1hc2sgPSBmdW5jdGlvbiBwb3BNYXNrKHRhcmdldCwgbWFza0RhdGEpIHtcbiAgICAgICAgaWYgKG1hc2tEYXRhLnRleHR1cmUpIHtcbiAgICAgICAgICAgIHRoaXMucG9wU3ByaXRlTWFzayh0YXJnZXQsIG1hc2tEYXRhKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmVuYWJsZVNjaXNzb3IgJiYgIXRoaXMucmVuZGVyZXIuc3RlbmNpbE1hbmFnZXIuc3RlbmNpbE1hc2tTdGFjay5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMucG9wU2Npc3Nvck1hc2sodGFyZ2V0LCBtYXNrRGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnBvcFN0ZW5jaWxNYXNrKHRhcmdldCwgbWFza0RhdGEpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgdGhlIE1hc2sgYW5kIGFkZHMgaXQgdG8gdGhlIGN1cnJlbnQgZmlsdGVyIHN0YWNrLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLlJlbmRlclRhcmdldH0gdGFyZ2V0IC0gRGlzcGxheSBPYmplY3QgdG8gcHVzaCB0aGUgc3ByaXRlIG1hc2sgdG9cbiAgICAgKiBAcGFyYW0ge1BJWEkuU3ByaXRlfSBtYXNrRGF0YSAtIFNwcml0ZSB0byBiZSB1c2VkIGFzIHRoZSBtYXNrXG4gICAgICovXG5cblxuICAgIE1hc2tNYW5hZ2VyLnByb3RvdHlwZS5wdXNoU3ByaXRlTWFzayA9IGZ1bmN0aW9uIHB1c2hTcHJpdGVNYXNrKHRhcmdldCwgbWFza0RhdGEpIHtcbiAgICAgICAgdmFyIGFscGhhTWFza0ZpbHRlciA9IHRoaXMuYWxwaGFNYXNrUG9vbFt0aGlzLmFscGhhTWFza0luZGV4XTtcblxuICAgICAgICBpZiAoIWFscGhhTWFza0ZpbHRlcikge1xuICAgICAgICAgICAgYWxwaGFNYXNrRmlsdGVyID0gdGhpcy5hbHBoYU1hc2tQb29sW3RoaXMuYWxwaGFNYXNrSW5kZXhdID0gW25ldyBfU3ByaXRlTWFza0ZpbHRlcjIuZGVmYXVsdChtYXNrRGF0YSldO1xuICAgICAgICB9XG5cbiAgICAgICAgYWxwaGFNYXNrRmlsdGVyWzBdLnJlc29sdXRpb24gPSB0aGlzLnJlbmRlcmVyLnJlc29sdXRpb247XG4gICAgICAgIGFscGhhTWFza0ZpbHRlclswXS5tYXNrU3ByaXRlID0gbWFza0RhdGE7XG5cbiAgICAgICAgdmFyIHN0YXNoRmlsdGVyQXJlYSA9IHRhcmdldC5maWx0ZXJBcmVhO1xuXG4gICAgICAgIHRhcmdldC5maWx0ZXJBcmVhID0gbWFza0RhdGEuZ2V0Qm91bmRzKHRydWUpO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLmZpbHRlck1hbmFnZXIucHVzaEZpbHRlcih0YXJnZXQsIGFscGhhTWFza0ZpbHRlcik7XG4gICAgICAgIHRhcmdldC5maWx0ZXJBcmVhID0gc3Rhc2hGaWx0ZXJBcmVhO1xuXG4gICAgICAgIHRoaXMuYWxwaGFNYXNrSW5kZXgrKztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgbGFzdCBmaWx0ZXIgZnJvbSB0aGUgZmlsdGVyIHN0YWNrIGFuZCBkb2Vzbid0IHJldHVybiBpdC5cbiAgICAgKlxuICAgICAqL1xuXG5cbiAgICBNYXNrTWFuYWdlci5wcm90b3R5cGUucG9wU3ByaXRlTWFzayA9IGZ1bmN0aW9uIHBvcFNwcml0ZU1hc2soKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuZmlsdGVyTWFuYWdlci5wb3BGaWx0ZXIoKTtcbiAgICAgICAgdGhpcy5hbHBoYU1hc2tJbmRleC0tO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIHRoZSBNYXNrIGFuZCBhZGRzIGl0IHRvIHRoZSBjdXJyZW50IGZpbHRlciBzdGFjay5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5TcHJpdGV8UElYSS5HcmFwaGljc30gbWFza0RhdGEgLSBUaGUgbWFza2luZyBkYXRhLlxuICAgICAqL1xuXG5cbiAgICBNYXNrTWFuYWdlci5wcm90b3R5cGUucHVzaFN0ZW5jaWxNYXNrID0gZnVuY3Rpb24gcHVzaFN0ZW5jaWxNYXNrKG1hc2tEYXRhKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuY3VycmVudFJlbmRlcmVyLnN0b3AoKTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zdGVuY2lsTWFuYWdlci5wdXNoU3RlbmNpbChtYXNrRGF0YSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIGxhc3QgZmlsdGVyIGZyb20gdGhlIGZpbHRlciBzdGFjayBhbmQgZG9lc24ndCByZXR1cm4gaXQuXG4gICAgICpcbiAgICAgKi9cblxuXG4gICAgTWFza01hbmFnZXIucHJvdG90eXBlLnBvcFN0ZW5jaWxNYXNrID0gZnVuY3Rpb24gcG9wU3RlbmNpbE1hc2soKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuY3VycmVudFJlbmRlcmVyLnN0b3AoKTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zdGVuY2lsTWFuYWdlci5wb3BTdGVuY2lsKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLkRpc3BsYXlPYmplY3R9IHRhcmdldCAtIERpc3BsYXkgT2JqZWN0IHRvIHB1c2ggdGhlIG1hc2sgdG9cbiAgICAgKiBAcGFyYW0ge1BJWEkuR3JhcGhpY3N9IG1hc2tEYXRhIC0gVGhlIG1hc2tpbmcgZGF0YS5cbiAgICAgKi9cblxuXG4gICAgTWFza01hbmFnZXIucHJvdG90eXBlLnB1c2hTY2lzc29yTWFzayA9IGZ1bmN0aW9uIHB1c2hTY2lzc29yTWFzayh0YXJnZXQsIG1hc2tEYXRhKSB7XG4gICAgICAgIG1hc2tEYXRhLnJlbmRlcmFibGUgPSB0cnVlO1xuXG4gICAgICAgIHZhciByZW5kZXJUYXJnZXQgPSB0aGlzLnJlbmRlcmVyLl9hY3RpdmVSZW5kZXJUYXJnZXQ7XG5cbiAgICAgICAgdmFyIGJvdW5kcyA9IG1hc2tEYXRhLmdldEJvdW5kcygpO1xuXG4gICAgICAgIGJvdW5kcy5maXQocmVuZGVyVGFyZ2V0LnNpemUpO1xuICAgICAgICBtYXNrRGF0YS5yZW5kZXJhYmxlID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5yZW5kZXJlci5nbC5lbmFibGUodGhpcy5yZW5kZXJlci5nbC5TQ0lTU09SX1RFU1QpO1xuXG4gICAgICAgIHZhciByZXNvbHV0aW9uID0gdGhpcy5yZW5kZXJlci5yZXNvbHV0aW9uO1xuXG4gICAgICAgIHRoaXMucmVuZGVyZXIuZ2wuc2Npc3Nvcihib3VuZHMueCAqIHJlc29sdXRpb24sIChyZW5kZXJUYXJnZXQucm9vdCA/IHJlbmRlclRhcmdldC5zaXplLmhlaWdodCAtIGJvdW5kcy55IC0gYm91bmRzLmhlaWdodCA6IGJvdW5kcy55KSAqIHJlc29sdXRpb24sIGJvdW5kcy53aWR0aCAqIHJlc29sdXRpb24sIGJvdW5kcy5oZWlnaHQgKiByZXNvbHV0aW9uKTtcblxuICAgICAgICB0aGlzLnNjaXNzb3JSZW5kZXJUYXJnZXQgPSByZW5kZXJUYXJnZXQ7XG4gICAgICAgIHRoaXMuc2Npc3NvckRhdGEgPSBtYXNrRGF0YTtcbiAgICAgICAgdGhpcy5zY2lzc29yID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKlxuICAgICAqL1xuXG5cbiAgICBNYXNrTWFuYWdlci5wcm90b3R5cGUucG9wU2Npc3Nvck1hc2sgPSBmdW5jdGlvbiBwb3BTY2lzc29yTWFzaygpIHtcbiAgICAgICAgdGhpcy5zY2lzc29yUmVuZGVyVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5zY2lzc29yRGF0YSA9IG51bGw7XG4gICAgICAgIHRoaXMuc2Npc3NvciA9IGZhbHNlO1xuXG4gICAgICAgIC8vIG11c3QgYmUgc2Npc3NvciFcbiAgICAgICAgdmFyIGdsID0gdGhpcy5yZW5kZXJlci5nbDtcblxuICAgICAgICBnbC5kaXNhYmxlKGdsLlNDSVNTT1JfVEVTVCk7XG4gICAgfTtcblxuICAgIHJldHVybiBNYXNrTWFuYWdlcjtcbn0oX1dlYkdMTWFuYWdlcjMuZGVmYXVsdCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IE1hc2tNYW5hZ2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TWFza01hbmFnZXIuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX1dlYkdMTWFuYWdlcjIgPSByZXF1aXJlKCcuL1dlYkdMTWFuYWdlcicpO1xuXG52YXIgX1dlYkdMTWFuYWdlcjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9XZWJHTE1hbmFnZXIyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4vKipcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgUElYSS5XZWJHTE1hbmFnZXJcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKi9cbnZhciBTdGVuY2lsTWFuYWdlciA9IGZ1bmN0aW9uIChfV2ViR0xNYW5hZ2VyKSB7XG4gICAgX2luaGVyaXRzKFN0ZW5jaWxNYW5hZ2VyLCBfV2ViR0xNYW5hZ2VyKTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7UElYSS5XZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlciB0aGlzIG1hbmFnZXIgd29ya3MgZm9yLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFN0ZW5jaWxNYW5hZ2VyKHJlbmRlcmVyKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTdGVuY2lsTWFuYWdlcik7XG5cbiAgICAgICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1dlYkdMTWFuYWdlci5jYWxsKHRoaXMsIHJlbmRlcmVyKSk7XG5cbiAgICAgICAgX3RoaXMuc3RlbmNpbE1hc2tTdGFjayA9IG51bGw7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGFuZ2VzIHRoZSBtYXNrIHN0YWNrIHRoYXQgaXMgdXNlZCBieSB0aGlzIG1hbmFnZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuR3JhcGhpY3NbXX0gc3RlbmNpbE1hc2tTdGFjayAtIFRoZSBtYXNrIHN0YWNrXG4gICAgICovXG5cblxuICAgIFN0ZW5jaWxNYW5hZ2VyLnByb3RvdHlwZS5zZXRNYXNrU3RhY2sgPSBmdW5jdGlvbiBzZXRNYXNrU3RhY2soc3RlbmNpbE1hc2tTdGFjaykge1xuICAgICAgICB0aGlzLnN0ZW5jaWxNYXNrU3RhY2sgPSBzdGVuY2lsTWFza1N0YWNrO1xuXG4gICAgICAgIHZhciBnbCA9IHRoaXMucmVuZGVyZXIuZ2w7XG5cbiAgICAgICAgaWYgKHN0ZW5jaWxNYXNrU3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBnbC5kaXNhYmxlKGdsLlNURU5DSUxfVEVTVCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbC5lbmFibGUoZ2wuU1RFTkNJTF9URVNUKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIHRoZSBNYXNrIGFuZCBhZGRzIGl0IHRvIHRoZSBjdXJyZW50IHN0ZW5jaWwgc3RhY2suIEBhbHZpblxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLkdyYXBoaWNzfSBncmFwaGljcyAtIFRoZSBtYXNrXG4gICAgICovXG5cblxuICAgIFN0ZW5jaWxNYW5hZ2VyLnByb3RvdHlwZS5wdXNoU3RlbmNpbCA9IGZ1bmN0aW9uIHB1c2hTdGVuY2lsKGdyYXBoaWNzKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2V0T2JqZWN0UmVuZGVyZXIodGhpcy5yZW5kZXJlci5wbHVnaW5zLmdyYXBoaWNzKTtcblxuICAgICAgICB0aGlzLnJlbmRlcmVyLl9hY3RpdmVSZW5kZXJUYXJnZXQuYXR0YWNoU3RlbmNpbEJ1ZmZlcigpO1xuXG4gICAgICAgIHZhciBnbCA9IHRoaXMucmVuZGVyZXIuZ2w7XG4gICAgICAgIHZhciBwcmV2TWFza0NvdW50ID0gdGhpcy5zdGVuY2lsTWFza1N0YWNrLmxlbmd0aDtcblxuICAgICAgICBpZiAocHJldk1hc2tDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgZ2wuZW5hYmxlKGdsLlNURU5DSUxfVEVTVCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnN0ZW5jaWxNYXNrU3RhY2sucHVzaChncmFwaGljcyk7XG5cbiAgICAgICAgLy8gSW5jcmVtZW50IHRoZSByZWZlcmVuY2Ugc3RlbmNpbCB2YWx1ZSB3aGVyZSB0aGUgbmV3IG1hc2sgb3ZlcmxhcHMgd2l0aCB0aGUgb2xkIG9uZXMuXG4gICAgICAgIGdsLmNvbG9yTWFzayhmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSk7XG4gICAgICAgIGdsLnN0ZW5jaWxGdW5jKGdsLkVRVUFMLCBwcmV2TWFza0NvdW50LCB0aGlzLl9nZXRCaXR3aXNlTWFzaygpKTtcbiAgICAgICAgZ2wuc3RlbmNpbE9wKGdsLktFRVAsIGdsLktFRVAsIGdsLklOQ1IpO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnBsdWdpbnMuZ3JhcGhpY3MucmVuZGVyKGdyYXBoaWNzKTtcblxuICAgICAgICB0aGlzLl91c2VDdXJyZW50KCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIGxhc3QgbWFzayBmcm9tIHRoZSBzdGVuY2lsIHN0YWNrLiBAYWx2aW5cbiAgICAgKi9cblxuXG4gICAgU3RlbmNpbE1hbmFnZXIucHJvdG90eXBlLnBvcFN0ZW5jaWwgPSBmdW5jdGlvbiBwb3BTdGVuY2lsKCkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnNldE9iamVjdFJlbmRlcmVyKHRoaXMucmVuZGVyZXIucGx1Z2lucy5ncmFwaGljcyk7XG5cbiAgICAgICAgdmFyIGdsID0gdGhpcy5yZW5kZXJlci5nbDtcbiAgICAgICAgdmFyIGdyYXBoaWNzID0gdGhpcy5zdGVuY2lsTWFza1N0YWNrLnBvcCgpO1xuXG4gICAgICAgIGlmICh0aGlzLnN0ZW5jaWxNYXNrU3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAvLyB0aGUgc3RhY2sgaXMgZW1wdHkhXG4gICAgICAgICAgICBnbC5kaXNhYmxlKGdsLlNURU5DSUxfVEVTVCk7XG4gICAgICAgICAgICBnbC5jbGVhcihnbC5TVEVOQ0lMX0JVRkZFUl9CSVQpO1xuICAgICAgICAgICAgZ2wuY2xlYXJTdGVuY2lsKDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRGVjcmVtZW50IHRoZSByZWZlcmVuY2Ugc3RlbmNpbCB2YWx1ZSB3aGVyZSB0aGUgcG9wcGVkIG1hc2sgb3ZlcmxhcHMgd2l0aCB0aGUgb3RoZXIgb25lc1xuICAgICAgICAgICAgZ2wuY29sb3JNYXNrKGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgICAgIGdsLnN0ZW5jaWxPcChnbC5LRUVQLCBnbC5LRUVQLCBnbC5ERUNSKTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIucGx1Z2lucy5ncmFwaGljcy5yZW5kZXIoZ3JhcGhpY3MpO1xuXG4gICAgICAgICAgICB0aGlzLl91c2VDdXJyZW50KCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0dXAgcmVuZGVyZXIgdG8gdXNlIHRoZSBjdXJyZW50IHN0ZW5jaWwgZGF0YS5cbiAgICAgKi9cblxuXG4gICAgU3RlbmNpbE1hbmFnZXIucHJvdG90eXBlLl91c2VDdXJyZW50ID0gZnVuY3Rpb24gX3VzZUN1cnJlbnQoKSB7XG4gICAgICAgIHZhciBnbCA9IHRoaXMucmVuZGVyZXIuZ2w7XG5cbiAgICAgICAgZ2wuY29sb3JNYXNrKHRydWUsIHRydWUsIHRydWUsIHRydWUpO1xuICAgICAgICBnbC5zdGVuY2lsRnVuYyhnbC5FUVVBTCwgdGhpcy5zdGVuY2lsTWFza1N0YWNrLmxlbmd0aCwgdGhpcy5fZ2V0Qml0d2lzZU1hc2soKSk7XG4gICAgICAgIGdsLnN0ZW5jaWxPcChnbC5LRUVQLCBnbC5LRUVQLCBnbC5LRUVQKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRmlsbCAxcyBlcXVhbCB0byB0aGUgbnVtYmVyIG9mIGFjaXR2ZSBzdGVuY2lsIG1hc2tzLlxuICAgICAqXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgYml0d2lzZSBtYXNrLlxuICAgICAqL1xuXG5cbiAgICBTdGVuY2lsTWFuYWdlci5wcm90b3R5cGUuX2dldEJpdHdpc2VNYXNrID0gZnVuY3Rpb24gX2dldEJpdHdpc2VNYXNrKCkge1xuICAgICAgICByZXR1cm4gKDEgPDwgdGhpcy5zdGVuY2lsTWFza1N0YWNrLmxlbmd0aCkgLSAxO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyB0aGUgbWFzayBzdGFjay5cbiAgICAgKlxuICAgICAqL1xuXG5cbiAgICBTdGVuY2lsTWFuYWdlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIF9XZWJHTE1hbmFnZXIzLmRlZmF1bHQucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcblxuICAgICAgICB0aGlzLnN0ZW5jaWxNYXNrU3RhY2suc3RlbmNpbFN0YWNrID0gbnVsbDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFN0ZW5jaWxNYW5hZ2VyO1xufShfV2ViR0xNYW5hZ2VyMy5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gU3RlbmNpbE1hbmFnZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdGVuY2lsTWFuYWdlci5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8qKlxuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgUElYSVxuICovXG52YXIgV2ViR0xNYW5hZ2VyID0gZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHBhcmFtIHtQSVhJLldlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyIHRoaXMgbWFuYWdlciB3b3JrcyBmb3IuXG4gICAqL1xuICBmdW5jdGlvbiBXZWJHTE1hbmFnZXIocmVuZGVyZXIpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgV2ViR0xNYW5hZ2VyKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSByZW5kZXJlciB0aGlzIG1hbmFnZXIgd29ya3MgZm9yLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7UElYSS5XZWJHTFJlbmRlcmVyfVxuICAgICAqL1xuICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcblxuICAgIHRoaXMucmVuZGVyZXIub24oJ2NvbnRleHQnLCB0aGlzLm9uQ29udGV4dENoYW5nZSwgdGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJpYyBtZXRob2QgY2FsbGVkIHdoZW4gdGhlcmUgaXMgYSBXZWJHTCBjb250ZXh0IGNoYW5nZS5cbiAgICpcbiAgICovXG5cblxuICBXZWJHTE1hbmFnZXIucHJvdG90eXBlLm9uQ29udGV4dENoYW5nZSA9IGZ1bmN0aW9uIG9uQ29udGV4dENoYW5nZSgpIHt9XG4gIC8vIGRvIHNvbWUgY29kZXMgaW5pdCFcblxuXG4gIC8qKlxuICAgKiBHZW5lcmljIGRlc3Ryb3kgbWV0aG9kcyB0byBiZSBvdmVycmlkZGVuIGJ5IHRoZSBzdWJjbGFzc1xuICAgKlxuICAgKi9cbiAgO1xuXG4gIFdlYkdMTWFuYWdlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5yZW5kZXJlci5vZmYoJ2NvbnRleHQnLCB0aGlzLm9uQ29udGV4dENoYW5nZSwgdGhpcyk7XG5cbiAgICB0aGlzLnJlbmRlcmVyID0gbnVsbDtcbiAgfTtcblxuICByZXR1cm4gV2ViR0xNYW5hZ2VyO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBXZWJHTE1hbmFnZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1XZWJHTE1hbmFnZXIuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX1dlYkdMTWFuYWdlcjIgPSByZXF1aXJlKCcuLi9tYW5hZ2Vycy9XZWJHTE1hbmFnZXInKTtcblxudmFyIF9XZWJHTE1hbmFnZXIzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfV2ViR0xNYW5hZ2VyMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuLyoqXG4gKiBCYXNlIGZvciBhIGNvbW1vbiBvYmplY3QgcmVuZGVyZXIgdGhhdCBjYW4gYmUgdXNlZCBhcyBhIHN5c3RlbSByZW5kZXJlciBwbHVnaW4uXG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQSVhJLldlYkdMTWFuYWdlclxuICogQG1lbWJlcm9mIFBJWElcbiAqL1xudmFyIE9iamVjdFJlbmRlcmVyID0gZnVuY3Rpb24gKF9XZWJHTE1hbmFnZXIpIHtcbiAgX2luaGVyaXRzKE9iamVjdFJlbmRlcmVyLCBfV2ViR0xNYW5hZ2VyKTtcblxuICBmdW5jdGlvbiBPYmplY3RSZW5kZXJlcigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgT2JqZWN0UmVuZGVyZXIpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9XZWJHTE1hbmFnZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICAvKipcbiAgICogU3RhcnRzIHRoZSByZW5kZXJlciBhbmQgc2V0cyB0aGUgc2hhZGVyXG4gICAqXG4gICAqL1xuICBPYmplY3RSZW5kZXJlci5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiBzdGFydCgpIHt9XG4gIC8vIHNldCB0aGUgc2hhZGVyLi5cblxuXG4gIC8qKlxuICAgKiBTdG9wcyB0aGUgcmVuZGVyZXJcbiAgICpcbiAgICovXG4gIDtcblxuICBPYmplY3RSZW5kZXJlci5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgdGhpcy5mbHVzaCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTdHViIG1ldGhvZCBmb3IgcmVuZGVyaW5nIGNvbnRlbnQgYW5kIGVtcHR5aW5nIHRoZSBjdXJyZW50IGJhdGNoLlxuICAgKlxuICAgKi9cblxuXG4gIE9iamVjdFJlbmRlcmVyLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uIGZsdXNoKCkge31cbiAgLy8gZmx1c2ghXG5cblxuICAvKipcbiAgICogUmVuZGVycyBhbiBvYmplY3RcbiAgICpcbiAgICogQHBhcmFtIHtQSVhJLkRpc3BsYXlPYmplY3R9IG9iamVjdCAtIFRoZSBvYmplY3QgdG8gcmVuZGVyLlxuICAgKi9cbiAgO1xuXG4gIE9iamVjdFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIob2JqZWN0KSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gIHtcbiAgICAvLyByZW5kZXIgdGhlIG9iamVjdFxuICB9O1xuXG4gIHJldHVybiBPYmplY3RSZW5kZXJlcjtcbn0oX1dlYkdMTWFuYWdlcjMuZGVmYXVsdCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IE9iamVjdFJlbmRlcmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9T2JqZWN0UmVuZGVyZXIuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3BpeGlHbENvcmUgPSByZXF1aXJlKCdwaXhpLWdsLWNvcmUnKTtcblxudmFyIF9waXhpR2xDb3JlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BpeGlHbENvcmUpO1xuXG52YXIgX2NyZWF0ZUluZGljZXNGb3JRdWFkcyA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzL2NyZWF0ZUluZGljZXNGb3JRdWFkcycpO1xuXG52YXIgX2NyZWF0ZUluZGljZXNGb3JRdWFkczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVJbmRpY2VzRm9yUXVhZHMpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vKipcbiAqIEhlbHBlciBjbGFzcyB0byBjcmVhdGUgYSBxdWFkXG4gKlxuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgUElYSVxuICovXG52YXIgUXVhZCA9IGZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCAtIFRoZSBnbCBjb250ZXh0IGZvciB0aGlzIHF1YWQgdG8gdXNlLlxuICAgKiBAcGFyYW0ge29iamVjdH0gc3RhdGUgLSBUT0RPOiBEZXNjcmlwdGlvblxuICAgKi9cbiAgZnVuY3Rpb24gUXVhZChnbCwgc3RhdGUpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUXVhZCk7XG5cbiAgICAvKipcbiAgICAgKiB0aGUgY3VycmVudCBXZWJHTCBkcmF3aW5nIGNvbnRleHRcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge1dlYkdMUmVuZGVyaW5nQ29udGV4dH1cbiAgICAgKi9cbiAgICB0aGlzLmdsID0gZ2w7XG5cbiAgICAvKipcbiAgICAgKiBBbiBhcnJheSBvZiB2ZXJ0aWNlc1xuICAgICAqXG4gICAgICogQG1lbWJlciB7RmxvYXQzMkFycmF5fVxuICAgICAqL1xuICAgIHRoaXMudmVydGljZXMgPSBuZXcgRmxvYXQzMkFycmF5KFstMSwgLTEsIDEsIC0xLCAxLCAxLCAtMSwgMV0pO1xuXG4gICAgLyoqXG4gICAgICogVGhlIFV2cyBvZiB0aGUgcXVhZFxuICAgICAqXG4gICAgICogQG1lbWJlciB7RmxvYXQzMkFycmF5fVxuICAgICAqL1xuICAgIHRoaXMudXZzID0gbmV3IEZsb2F0MzJBcnJheShbMCwgMCwgMSwgMCwgMSwgMSwgMCwgMV0pO1xuXG4gICAgdGhpcy5pbnRlcmxlYXZlZCA9IG5ldyBGbG9hdDMyQXJyYXkoOCAqIDIpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgIHRoaXMuaW50ZXJsZWF2ZWRbaSAqIDRdID0gdGhpcy52ZXJ0aWNlc1tpICogMl07XG4gICAgICB0aGlzLmludGVybGVhdmVkW2kgKiA0ICsgMV0gPSB0aGlzLnZlcnRpY2VzW2kgKiAyICsgMV07XG4gICAgICB0aGlzLmludGVybGVhdmVkW2kgKiA0ICsgMl0gPSB0aGlzLnV2c1tpICogMl07XG4gICAgICB0aGlzLmludGVybGVhdmVkW2kgKiA0ICsgM10gPSB0aGlzLnV2c1tpICogMiArIDFdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIGluZGljZXMgb2YgdGhlIHZlcnRpY2VzXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtVaW50MTZBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmluZGljZXMgPSAoMCwgX2NyZWF0ZUluZGljZXNGb3JRdWFkczIuZGVmYXVsdCkoMSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdmVydGV4IGJ1ZmZlclxuICAgICAqXG4gICAgICogQG1lbWJlciB7Z2xDb3JlLkdMQnVmZmVyfVxuICAgICAqL1xuICAgIHRoaXMudmVydGV4QnVmZmVyID0gX3BpeGlHbENvcmUyLmRlZmF1bHQuR0xCdWZmZXIuY3JlYXRlVmVydGV4QnVmZmVyKGdsLCB0aGlzLmludGVybGVhdmVkLCBnbC5TVEFUSUNfRFJBVyk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW5kZXggYnVmZmVyXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtnbENvcmUuR0xCdWZmZXJ9XG4gICAgICovXG4gICAgdGhpcy5pbmRleEJ1ZmZlciA9IF9waXhpR2xDb3JlMi5kZWZhdWx0LkdMQnVmZmVyLmNyZWF0ZUluZGV4QnVmZmVyKGdsLCB0aGlzLmluZGljZXMsIGdsLlNUQVRJQ19EUkFXKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB2ZXJ0ZXggYXJyYXkgb2JqZWN0XG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtnbENvcmUuVmVydGV4QXJyYXlPYmplY3R9XG4gICAgICovXG4gICAgdGhpcy52YW8gPSBuZXcgX3BpeGlHbENvcmUyLmRlZmF1bHQuVmVydGV4QXJyYXlPYmplY3QoZ2wsIHN0YXRlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXNlcyB0aGUgdmFvcyBhbmQgdXNlcyB0aGUgc2hhZGVyLlxuICAgKlxuICAgKiBAcGFyYW0ge1BJWEkuU2hhZGVyfSBzaGFkZXIgLSB0aGUgc2hhZGVyIHRvIHVzZVxuICAgKi9cblxuXG4gIFF1YWQucHJvdG90eXBlLmluaXRWYW8gPSBmdW5jdGlvbiBpbml0VmFvKHNoYWRlcikge1xuICAgIHRoaXMudmFvLmNsZWFyKCkuYWRkSW5kZXgodGhpcy5pbmRleEJ1ZmZlcikuYWRkQXR0cmlidXRlKHRoaXMudmVydGV4QnVmZmVyLCBzaGFkZXIuYXR0cmlidXRlcy5hVmVydGV4UG9zaXRpb24sIHRoaXMuZ2wuRkxPQVQsIGZhbHNlLCA0ICogNCwgMCkuYWRkQXR0cmlidXRlKHRoaXMudmVydGV4QnVmZmVyLCBzaGFkZXIuYXR0cmlidXRlcy5hVGV4dHVyZUNvb3JkLCB0aGlzLmdsLkZMT0FULCBmYWxzZSwgNCAqIDQsIDIgKiA0KTtcbiAgfTtcblxuICAvKipcbiAgICogTWFwcyB0d28gUmVjdGFuZ2xlIHRvIHRoZSBxdWFkLlxuICAgKlxuICAgKiBAcGFyYW0ge1BJWEkuUmVjdGFuZ2xlfSB0YXJnZXRUZXh0dXJlRnJhbWUgLSB0aGUgZmlyc3QgcmVjdGFuZ2xlXG4gICAqIEBwYXJhbSB7UElYSS5SZWN0YW5nbGV9IGRlc3RpbmF0aW9uRnJhbWUgLSB0aGUgc2Vjb25kIHJlY3RhbmdsZVxuICAgKiBAcmV0dXJuIHtQSVhJLlF1YWR9IFJldHVybnMgaXRzZWxmLlxuICAgKi9cblxuXG4gIFF1YWQucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIG1hcCh0YXJnZXRUZXh0dXJlRnJhbWUsIGRlc3RpbmF0aW9uRnJhbWUpIHtcbiAgICB2YXIgeCA9IDA7IC8vIGRlc3RpbmF0aW9uRnJhbWUueCAvIHRhcmdldFRleHR1cmVGcmFtZS53aWR0aDtcbiAgICB2YXIgeSA9IDA7IC8vIGRlc3RpbmF0aW9uRnJhbWUueSAvIHRhcmdldFRleHR1cmVGcmFtZS5oZWlnaHQ7XG5cbiAgICB0aGlzLnV2c1swXSA9IHg7XG4gICAgdGhpcy51dnNbMV0gPSB5O1xuXG4gICAgdGhpcy51dnNbMl0gPSB4ICsgZGVzdGluYXRpb25GcmFtZS53aWR0aCAvIHRhcmdldFRleHR1cmVGcmFtZS53aWR0aDtcbiAgICB0aGlzLnV2c1szXSA9IHk7XG5cbiAgICB0aGlzLnV2c1s0XSA9IHggKyBkZXN0aW5hdGlvbkZyYW1lLndpZHRoIC8gdGFyZ2V0VGV4dHVyZUZyYW1lLndpZHRoO1xuICAgIHRoaXMudXZzWzVdID0geSArIGRlc3RpbmF0aW9uRnJhbWUuaGVpZ2h0IC8gdGFyZ2V0VGV4dHVyZUZyYW1lLmhlaWdodDtcblxuICAgIHRoaXMudXZzWzZdID0geDtcbiAgICB0aGlzLnV2c1s3XSA9IHkgKyBkZXN0aW5hdGlvbkZyYW1lLmhlaWdodCAvIHRhcmdldFRleHR1cmVGcmFtZS5oZWlnaHQ7XG5cbiAgICB4ID0gZGVzdGluYXRpb25GcmFtZS54O1xuICAgIHkgPSBkZXN0aW5hdGlvbkZyYW1lLnk7XG5cbiAgICB0aGlzLnZlcnRpY2VzWzBdID0geDtcbiAgICB0aGlzLnZlcnRpY2VzWzFdID0geTtcblxuICAgIHRoaXMudmVydGljZXNbMl0gPSB4ICsgZGVzdGluYXRpb25GcmFtZS53aWR0aDtcbiAgICB0aGlzLnZlcnRpY2VzWzNdID0geTtcblxuICAgIHRoaXMudmVydGljZXNbNF0gPSB4ICsgZGVzdGluYXRpb25GcmFtZS53aWR0aDtcbiAgICB0aGlzLnZlcnRpY2VzWzVdID0geSArIGRlc3RpbmF0aW9uRnJhbWUuaGVpZ2h0O1xuXG4gICAgdGhpcy52ZXJ0aWNlc1s2XSA9IHg7XG4gICAgdGhpcy52ZXJ0aWNlc1s3XSA9IHkgKyBkZXN0aW5hdGlvbkZyYW1lLmhlaWdodDtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBCaW5kcyB0aGUgYnVmZmVyIGFuZCB1cGxvYWRzIHRoZSBkYXRhXG4gICAqXG4gICAqIEByZXR1cm4ge1BJWEkuUXVhZH0gUmV0dXJucyBpdHNlbGYuXG4gICAqL1xuXG5cbiAgUXVhZC5wcm90b3R5cGUudXBsb2FkID0gZnVuY3Rpb24gdXBsb2FkKCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICB0aGlzLmludGVybGVhdmVkW2kgKiA0XSA9IHRoaXMudmVydGljZXNbaSAqIDJdO1xuICAgICAgdGhpcy5pbnRlcmxlYXZlZFtpICogNCArIDFdID0gdGhpcy52ZXJ0aWNlc1tpICogMiArIDFdO1xuICAgICAgdGhpcy5pbnRlcmxlYXZlZFtpICogNCArIDJdID0gdGhpcy51dnNbaSAqIDJdO1xuICAgICAgdGhpcy5pbnRlcmxlYXZlZFtpICogNCArIDNdID0gdGhpcy51dnNbaSAqIDIgKyAxXTtcbiAgICB9XG5cbiAgICB0aGlzLnZlcnRleEJ1ZmZlci51cGxvYWQodGhpcy5pbnRlcmxlYXZlZCk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlcyB0aGlzIHF1YWQgZnJvbSBXZWJHTFxuICAgKi9cblxuXG4gIFF1YWQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIHZhciBnbCA9IHRoaXMuZ2w7XG5cbiAgICBnbC5kZWxldGVCdWZmZXIodGhpcy52ZXJ0ZXhCdWZmZXIpO1xuICAgIGdsLmRlbGV0ZUJ1ZmZlcih0aGlzLmluZGV4QnVmZmVyKTtcbiAgfTtcblxuICByZXR1cm4gUXVhZDtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gUXVhZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVF1YWQuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX21hdGggPSByZXF1aXJlKCcuLi8uLi8uLi9tYXRoJyk7XG5cbnZhciBfY29uc3QgPSByZXF1aXJlKCcuLi8uLi8uLi9jb25zdCcpO1xuXG52YXIgX3NldHRpbmdzID0gcmVxdWlyZSgnLi4vLi4vLi4vc2V0dGluZ3MnKTtcblxudmFyIF9zZXR0aW5nczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zZXR0aW5ncyk7XG5cbnZhciBfcGl4aUdsQ29yZSA9IHJlcXVpcmUoJ3BpeGktZ2wtY29yZScpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vKipcbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIFBJWElcbiAqL1xudmFyIFJlbmRlclRhcmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCAtIFRoZSBjdXJyZW50IFdlYkdMIGRyYXdpbmcgY29udGV4dFxuICAgKiBAcGFyYW0ge251bWJlcn0gW3dpZHRoPTBdIC0gdGhlIGhvcml6b250YWwgcmFuZ2Ugb2YgdGhlIGZpbHRlclxuICAgKiBAcGFyYW0ge251bWJlcn0gW2hlaWdodD0wXSAtIHRoZSB2ZXJ0aWNhbCByYW5nZSBvZiB0aGUgZmlsdGVyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbc2NhbGVNb2RlPVBJWEkuc2V0dGluZ3MuU0NBTEVfTU9ERV0gLSBTZWUge0BsaW5rIFBJWEkuU0NBTEVfTU9ERVN9IGZvciBwb3NzaWJsZSB2YWx1ZXNcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtyZXNvbHV0aW9uPTFdIC0gVGhlIGN1cnJlbnQgcmVzb2x1dGlvbiAvIGRldmljZSBwaXhlbCByYXRpb1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyb290PWZhbHNlXSAtIFdoZXRoZXIgdGhpcyBvYmplY3QgaXMgdGhlIHJvb3QgZWxlbWVudCBvciBub3RcbiAgICovXG4gIGZ1bmN0aW9uIFJlbmRlclRhcmdldChnbCwgd2lkdGgsIGhlaWdodCwgc2NhbGVNb2RlLCByZXNvbHV0aW9uLCByb290KSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJlbmRlclRhcmdldCk7XG5cbiAgICAvLyBUT0RPIFJlc29sdXRpb24gY291bGQgZ28gaGVyZSAoIGVnIGxvdyByZXMgYmx1cnMgKVxuXG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgV2ViR0wgZHJhd2luZyBjb250ZXh0LlxuICAgICAqXG4gICAgICogQG1lbWJlciB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fVxuICAgICAqL1xuICAgIHRoaXMuZ2wgPSBnbDtcblxuICAgIC8vIG5leHQgdGltZSB0byBjcmVhdGUgYSBmcmFtZSBidWZmZXIgYW5kIHRleHR1cmVcblxuICAgIC8qKlxuICAgICAqIEEgZnJhbWUgYnVmZmVyXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtQSVhJLmdsQ29yZS5HTEZyYW1lYnVmZmVyfVxuICAgICAqL1xuICAgIHRoaXMuZnJhbWVCdWZmZXIgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHRleHR1cmVcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge1BJWEkuZ2xDb3JlLkdMVGV4dHVyZX1cbiAgICAgKi9cbiAgICB0aGlzLnRleHR1cmUgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJhY2tncm91bmQgY29sb3VyIG9mIHRoaXMgcmVuZGVyIHRhcmdldCwgYXMgYW4gYXJyYXkgb2YgW3IsZyxiLGFdIHZhbHVlc1xuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyW119XG4gICAgICovXG4gICAgdGhpcy5jbGVhckNvbG9yID0gWzAsIDAsIDAsIDBdO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNpemUgb2YgdGhlIG9iamVjdCBhcyBhIHJlY3RhbmdsZVxuICAgICAqXG4gICAgICogQG1lbWJlciB7UElYSS5SZWN0YW5nbGV9XG4gICAgICovXG4gICAgdGhpcy5zaXplID0gbmV3IF9tYXRoLlJlY3RhbmdsZSgwLCAwLCAxLCAxKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBjdXJyZW50IHJlc29sdXRpb24gLyBkZXZpY2UgcGl4ZWwgcmF0aW9cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAxXG4gICAgICovXG4gICAgdGhpcy5yZXNvbHV0aW9uID0gcmVzb2x1dGlvbiB8fCBfc2V0dGluZ3MyLmRlZmF1bHQuUkVTT0xVVElPTjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBwcm9qZWN0aW9uIG1hdHJpeFxuICAgICAqXG4gICAgICogQG1lbWJlciB7UElYSS5NYXRyaXh9XG4gICAgICovXG4gICAgdGhpcy5wcm9qZWN0aW9uTWF0cml4ID0gbmV3IF9tYXRoLk1hdHJpeCgpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG9iamVjdCdzIHRyYW5zZm9ybVxuICAgICAqXG4gICAgICogQG1lbWJlciB7UElYSS5NYXRyaXh9XG4gICAgICovXG4gICAgdGhpcy50cmFuc2Zvcm0gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZyYW1lLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7UElYSS5SZWN0YW5nbGV9XG4gICAgICovXG4gICAgdGhpcy5mcmFtZSA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3RlbmNpbCBidWZmZXIgc3RvcmVzIG1hc2tpbmcgZGF0YSBmb3IgdGhlIHJlbmRlciB0YXJnZXRcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge2dsQ29yZS5HTEJ1ZmZlcn1cbiAgICAgKi9cbiAgICB0aGlzLmRlZmF1bHRGcmFtZSA9IG5ldyBfbWF0aC5SZWN0YW5nbGUoKTtcbiAgICB0aGlzLmRlc3RpbmF0aW9uRnJhbWUgPSBudWxsO1xuICAgIHRoaXMuc291cmNlRnJhbWUgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHN0ZW5jaWwgYnVmZmVyIHN0b3JlcyBtYXNraW5nIGRhdGEgZm9yIHRoZSByZW5kZXIgdGFyZ2V0XG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtnbENvcmUuR0xCdWZmZXJ9XG4gICAgICovXG4gICAgdGhpcy5zdGVuY2lsQnVmZmVyID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBkYXRhIHN0cnVjdHVyZSBmb3IgdGhlIHN0ZW5jaWwgbWFza3NcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge1BJWEkuR3JhcGhpY3NbXX1cbiAgICAgKi9cbiAgICB0aGlzLnN0ZW5jaWxNYXNrU3RhY2sgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIFN0b3JlcyBmaWx0ZXIgZGF0YSBmb3IgdGhlIHJlbmRlciB0YXJnZXRcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge29iamVjdFtdfVxuICAgICAqL1xuICAgIHRoaXMuZmlsdGVyRGF0YSA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUga2V5IGZvciBwb29sZWQgdGV4dHVyZSBvZiBGaWx0ZXJTeXN0ZW1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBtZW1iZXIge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmZpbHRlclBvb2xLZXkgPSAnJztcblxuICAgIC8qKlxuICAgICAqIFRoZSBzY2FsZSBtb2RlLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IFBJWEkuc2V0dGluZ3MuU0NBTEVfTU9ERVxuICAgICAqIEBzZWUgUElYSS5TQ0FMRV9NT0RFU1xuICAgICAqL1xuICAgIHRoaXMuc2NhbGVNb2RlID0gc2NhbGVNb2RlICE9PSB1bmRlZmluZWQgPyBzY2FsZU1vZGUgOiBfc2V0dGluZ3MyLmRlZmF1bHQuU0NBTEVfTU9ERTtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhpcyBvYmplY3QgaXMgdGhlIHJvb3QgZWxlbWVudCBvciBub3RcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cbiAgICB0aGlzLnJvb3QgPSByb290IHx8IGZhbHNlO1xuXG4gICAgaWYgKCF0aGlzLnJvb3QpIHtcbiAgICAgIHRoaXMuZnJhbWVCdWZmZXIgPSBfcGl4aUdsQ29yZS5HTEZyYW1lYnVmZmVyLmNyZWF0ZVJHQkEoZ2wsIDEwMCwgMTAwKTtcblxuICAgICAgaWYgKHRoaXMuc2NhbGVNb2RlID09PSBfY29uc3QuU0NBTEVfTU9ERVMuTkVBUkVTVCkge1xuICAgICAgICB0aGlzLmZyYW1lQnVmZmVyLnRleHR1cmUuZW5hYmxlTmVhcmVzdFNjYWxpbmcoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZnJhbWVCdWZmZXIudGV4dHVyZS5lbmFibGVMaW5lYXJTY2FsaW5nKCk7XG4gICAgICB9XG4gICAgICAvKlxuICAgICAgICAgIEEgZnJhbWUgYnVmZmVyIG5lZWRzIGEgdGFyZ2V0IHRvIHJlbmRlciB0by4uXG4gICAgICAgICAgY3JlYXRlIGEgdGV4dHVyZSBhbmQgYmluZCBpdCBhdHRhY2ggaXQgdG8gdGhlIGZyYW1lYnVmZmVyLi5cbiAgICAgICAqL1xuXG4gICAgICAvLyB0aGlzIGlzIHVzZWQgYnkgdGhlIGJhc2UgdGV4dHVyZVxuICAgICAgdGhpcy50ZXh0dXJlID0gdGhpcy5mcmFtZUJ1ZmZlci50ZXh0dXJlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBtYWtlIGl0IGEgbnVsbCBmcmFtZWJ1ZmZlci4uXG4gICAgICB0aGlzLmZyYW1lQnVmZmVyID0gbmV3IF9waXhpR2xDb3JlLkdMRnJhbWVidWZmZXIoZ2wsIDEwMCwgMTAwKTtcbiAgICAgIHRoaXMuZnJhbWVCdWZmZXIuZnJhbWVidWZmZXIgPSBudWxsO1xuICAgIH1cblxuICAgIHRoaXMuc2V0RnJhbWUoKTtcblxuICAgIHRoaXMucmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFycyB0aGUgZmlsdGVyIHRleHR1cmUuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyW119IFtjbGVhckNvbG9yPXRoaXMuY2xlYXJDb2xvcl0gLSBBcnJheSBvZiBbcixnLGIsYV0gdG8gY2xlYXIgdGhlIGZyYW1lYnVmZmVyXG4gICAqL1xuXG5cbiAgUmVuZGVyVGFyZ2V0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyKGNsZWFyQ29sb3IpIHtcbiAgICB2YXIgY2MgPSBjbGVhckNvbG9yIHx8IHRoaXMuY2xlYXJDb2xvcjtcblxuICAgIHRoaXMuZnJhbWVCdWZmZXIuY2xlYXIoY2NbMF0sIGNjWzFdLCBjY1syXSwgY2NbM10pOyAvLyByLGcsYixhKTtcbiAgfTtcblxuICAvKipcbiAgICogQmluZHMgdGhlIHN0ZW5jaWwgYnVmZmVyLlxuICAgKlxuICAgKi9cblxuXG4gIFJlbmRlclRhcmdldC5wcm90b3R5cGUuYXR0YWNoU3RlbmNpbEJ1ZmZlciA9IGZ1bmN0aW9uIGF0dGFjaFN0ZW5jaWxCdWZmZXIoKSB7XG4gICAgLy8gVE9ETyBjaGVjayBpZiBzdGVuY2lsIGlzIGRvbmU/XG4gICAgLyoqXG4gICAgICogVGhlIHN0ZW5jaWwgYnVmZmVyIGlzIHVzZWQgZm9yIG1hc2tpbmcgaW4gcGl4aVxuICAgICAqIGxldHMgY3JlYXRlIG9uZSBhbmQgdGhlbiBhZGQgYXR0YWNoIGl0IHRvIHRoZSBmcmFtZWJ1ZmZlci4uXG4gICAgICovXG4gICAgaWYgKCF0aGlzLnJvb3QpIHtcbiAgICAgIHRoaXMuZnJhbWVCdWZmZXIuZW5hYmxlU3RlbmNpbCgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2V0cyB0aGUgZnJhbWUgb2YgdGhlIHJlbmRlciB0YXJnZXQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVjdGFuZ2xlfSBkZXN0aW5hdGlvbkZyYW1lIC0gVGhlIGRlc3RpbmF0aW9uIGZyYW1lLlxuICAgKiBAcGFyYW0ge1JlY3RhbmdsZX0gc291cmNlRnJhbWUgLSBUaGUgc291cmNlIGZyYW1lLlxuICAgKi9cblxuXG4gIFJlbmRlclRhcmdldC5wcm90b3R5cGUuc2V0RnJhbWUgPSBmdW5jdGlvbiBzZXRGcmFtZShkZXN0aW5hdGlvbkZyYW1lLCBzb3VyY2VGcmFtZSkge1xuICAgIHRoaXMuZGVzdGluYXRpb25GcmFtZSA9IGRlc3RpbmF0aW9uRnJhbWUgfHwgdGhpcy5kZXN0aW5hdGlvbkZyYW1lIHx8IHRoaXMuZGVmYXVsdEZyYW1lO1xuICAgIHRoaXMuc291cmNlRnJhbWUgPSBzb3VyY2VGcmFtZSB8fCB0aGlzLnNvdXJjZUZyYW1lIHx8IHRoaXMuZGVzdGluYXRpb25GcmFtZTtcbiAgfTtcblxuICAvKipcbiAgICogQmluZHMgdGhlIGJ1ZmZlcnMgYW5kIGluaXRpYWxpc2VzIHRoZSB2aWV3cG9ydC5cbiAgICpcbiAgICovXG5cblxuICBSZW5kZXJUYXJnZXQucHJvdG90eXBlLmFjdGl2YXRlID0gZnVuY3Rpb24gYWN0aXZhdGUoKSB7XG4gICAgLy8gVE9ETyByZWZhY3RvciB1c2FnZSBvZiBmcmFtZS4uXG4gICAgdmFyIGdsID0gdGhpcy5nbDtcblxuICAgIC8vIG1ha2Ugc3VyZSB0aGUgdGV4dHVyZSBpcyB1bmJvdW5kIVxuICAgIHRoaXMuZnJhbWVCdWZmZXIuYmluZCgpO1xuXG4gICAgdGhpcy5jYWxjdWxhdGVQcm9qZWN0aW9uKHRoaXMuZGVzdGluYXRpb25GcmFtZSwgdGhpcy5zb3VyY2VGcmFtZSk7XG5cbiAgICBpZiAodGhpcy50cmFuc2Zvcm0pIHtcbiAgICAgIHRoaXMucHJvamVjdGlvbk1hdHJpeC5hcHBlbmQodGhpcy50cmFuc2Zvcm0pO1xuICAgIH1cblxuICAgIC8vIFRPRE8gYWRkIGEgY2hlY2sgYXMgdGhlbSBtYXkgYmUgdGhlIHNhbWUhXG4gICAgaWYgKHRoaXMuZGVzdGluYXRpb25GcmFtZSAhPT0gdGhpcy5zb3VyY2VGcmFtZSkge1xuICAgICAgZ2wuZW5hYmxlKGdsLlNDSVNTT1JfVEVTVCk7XG4gICAgICBnbC5zY2lzc29yKHRoaXMuZGVzdGluYXRpb25GcmFtZS54IHwgMCwgdGhpcy5kZXN0aW5hdGlvbkZyYW1lLnkgfCAwLCB0aGlzLmRlc3RpbmF0aW9uRnJhbWUud2lkdGggKiB0aGlzLnJlc29sdXRpb24gfCAwLCB0aGlzLmRlc3RpbmF0aW9uRnJhbWUuaGVpZ2h0ICogdGhpcy5yZXNvbHV0aW9uIHwgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdsLmRpc2FibGUoZ2wuU0NJU1NPUl9URVNUKTtcbiAgICB9XG5cbiAgICAvLyBUT0RPIC0gZG9lcyBub3QgbmVlZCB0byBiZSB1cGRhdGVkIGFsbCB0aGUgdGltZT8/XG4gICAgZ2wudmlld3BvcnQodGhpcy5kZXN0aW5hdGlvbkZyYW1lLnggfCAwLCB0aGlzLmRlc3RpbmF0aW9uRnJhbWUueSB8IDAsIHRoaXMuZGVzdGluYXRpb25GcmFtZS53aWR0aCAqIHRoaXMucmVzb2x1dGlvbiB8IDAsIHRoaXMuZGVzdGluYXRpb25GcmFtZS5oZWlnaHQgKiB0aGlzLnJlc29sdXRpb24gfCAwKTtcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgcHJvamVjdGlvbiBtYXRyaXggYmFzZWQgb24gYSBwcm9qZWN0aW9uIGZyYW1lICh3aGljaCBpcyBhIHJlY3RhbmdsZSlcbiAgICpcbiAgICogQHBhcmFtIHtSZWN0YW5nbGV9IGRlc3RpbmF0aW9uRnJhbWUgLSBUaGUgZGVzdGluYXRpb24gZnJhbWUuXG4gICAqIEBwYXJhbSB7UmVjdGFuZ2xlfSBzb3VyY2VGcmFtZSAtIFRoZSBzb3VyY2UgZnJhbWUuXG4gICAqL1xuXG5cbiAgUmVuZGVyVGFyZ2V0LnByb3RvdHlwZS5jYWxjdWxhdGVQcm9qZWN0aW9uID0gZnVuY3Rpb24gY2FsY3VsYXRlUHJvamVjdGlvbihkZXN0aW5hdGlvbkZyYW1lLCBzb3VyY2VGcmFtZSkge1xuICAgIHZhciBwbSA9IHRoaXMucHJvamVjdGlvbk1hdHJpeDtcblxuICAgIHNvdXJjZUZyYW1lID0gc291cmNlRnJhbWUgfHwgZGVzdGluYXRpb25GcmFtZTtcblxuICAgIHBtLmlkZW50aXR5KCk7XG5cbiAgICAvLyBUT0RPOiBtYWtlIGRlc3Qgc2NhbGUgc291cmNlXG4gICAgaWYgKCF0aGlzLnJvb3QpIHtcbiAgICAgIHBtLmEgPSAxIC8gZGVzdGluYXRpb25GcmFtZS53aWR0aCAqIDI7XG4gICAgICBwbS5kID0gMSAvIGRlc3RpbmF0aW9uRnJhbWUuaGVpZ2h0ICogMjtcblxuICAgICAgcG0udHggPSAtMSAtIHNvdXJjZUZyYW1lLnggKiBwbS5hO1xuICAgICAgcG0udHkgPSAtMSAtIHNvdXJjZUZyYW1lLnkgKiBwbS5kO1xuICAgIH0gZWxzZSB7XG4gICAgICBwbS5hID0gMSAvIGRlc3RpbmF0aW9uRnJhbWUud2lkdGggKiAyO1xuICAgICAgcG0uZCA9IC0xIC8gZGVzdGluYXRpb25GcmFtZS5oZWlnaHQgKiAyO1xuXG4gICAgICBwbS50eCA9IC0xIC0gc291cmNlRnJhbWUueCAqIHBtLmE7XG4gICAgICBwbS50eSA9IDEgLSBzb3VyY2VGcmFtZS55ICogcG0uZDtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlc2l6ZXMgdGhlIHRleHR1cmUgdG8gdGhlIHNwZWNpZmllZCB3aWR0aCBhbmQgaGVpZ2h0XG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAtIHRoZSBuZXcgd2lkdGggb2YgdGhlIHRleHR1cmVcbiAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIHRoZSBuZXcgaGVpZ2h0IG9mIHRoZSB0ZXh0dXJlXG4gICAqL1xuXG5cbiAgUmVuZGVyVGFyZ2V0LnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbiByZXNpemUod2lkdGgsIGhlaWdodCkge1xuICAgIHdpZHRoID0gd2lkdGggfCAwO1xuICAgIGhlaWdodCA9IGhlaWdodCB8IDA7XG5cbiAgICBpZiAodGhpcy5zaXplLndpZHRoID09PSB3aWR0aCAmJiB0aGlzLnNpemUuaGVpZ2h0ID09PSBoZWlnaHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnNpemUud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLnNpemUuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgdGhpcy5kZWZhdWx0RnJhbWUud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmRlZmF1bHRGcmFtZS5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICB0aGlzLmZyYW1lQnVmZmVyLnJlc2l6ZSh3aWR0aCAqIHRoaXMucmVzb2x1dGlvbiwgaGVpZ2h0ICogdGhpcy5yZXNvbHV0aW9uKTtcblxuICAgIHZhciBwcm9qZWN0aW9uRnJhbWUgPSB0aGlzLmZyYW1lIHx8IHRoaXMuc2l6ZTtcblxuICAgIHRoaXMuY2FsY3VsYXRlUHJvamVjdGlvbihwcm9qZWN0aW9uRnJhbWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZXN0cm95cyB0aGUgcmVuZGVyIHRhcmdldC5cbiAgICpcbiAgICovXG5cblxuICBSZW5kZXJUYXJnZXQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIGlmICh0aGlzLmZyYW1lQnVmZmVyLnN0ZW5jaWwpIHtcbiAgICAgIHRoaXMuZ2wuZGVsZXRlUmVuZGVyYnVmZmVyKHRoaXMuZnJhbWVCdWZmZXIuc3RlbmNpbCk7XG4gICAgfVxuICAgIHRoaXMuZnJhbWVCdWZmZXIuZGVzdHJveSgpO1xuXG4gICAgdGhpcy5mcmFtZUJ1ZmZlciA9IG51bGw7XG4gICAgdGhpcy50ZXh0dXJlID0gbnVsbDtcbiAgfTtcblxuICByZXR1cm4gUmVuZGVyVGFyZ2V0O1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBSZW5kZXJUYXJnZXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZW5kZXJUYXJnZXQuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5kZWZhdWx0ID0gY2hlY2tNYXhJZlN0YXRtZW50c0luU2hhZGVyO1xuXG52YXIgX3BpeGlHbENvcmUgPSByZXF1aXJlKCdwaXhpLWdsLWNvcmUnKTtcblxudmFyIF9waXhpR2xDb3JlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BpeGlHbENvcmUpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgZnJhZ1RlbXBsYXRlID0gWydwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsnLCAndm9pZCBtYWluKHZvaWQpeycsICdmbG9hdCB0ZXN0ID0gMC4xOycsICclZm9ybG9vcCUnLCAnZ2xfRnJhZ0NvbG9yID0gdmVjNCgwLjApOycsICd9J10uam9pbignXFxuJyk7XG5cbmZ1bmN0aW9uIGNoZWNrTWF4SWZTdGF0bWVudHNJblNoYWRlcihtYXhJZnMsIGdsKSB7XG4gICAgdmFyIGNyZWF0ZVRlbXBDb250ZXh0ID0gIWdsO1xuXG4gICAgLy8gQGlmIERFQlVHXG4gICAgaWYgKG1heElmcyA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdmFsdWUgb2YgYDBgIHBhc3NlZCB0byBgY2hlY2tNYXhJZlN0YXRlbWVudHNJblNoYWRlcmAnKTtcbiAgICB9XG4gICAgLy8gQGVuZGlmXG5cbiAgICBpZiAoY3JlYXRlVGVtcENvbnRleHQpIHtcbiAgICAgICAgdmFyIHRpbnlDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcblxuICAgICAgICB0aW55Q2FudmFzLndpZHRoID0gMTtcbiAgICAgICAgdGlueUNhbnZhcy5oZWlnaHQgPSAxO1xuXG4gICAgICAgIGdsID0gX3BpeGlHbENvcmUyLmRlZmF1bHQuY3JlYXRlQ29udGV4dCh0aW55Q2FudmFzKTtcbiAgICB9XG5cbiAgICB2YXIgc2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKGdsLkZSQUdNRU5UX1NIQURFUik7XG5cbiAgICB3aGlsZSAodHJ1ZSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zdGFudC1jb25kaXRpb25cbiAgICB7XG4gICAgICAgIHZhciBmcmFnbWVudFNyYyA9IGZyYWdUZW1wbGF0ZS5yZXBsYWNlKC8lZm9ybG9vcCUvZ2ksIGdlbmVyYXRlSWZUZXN0U3JjKG1heElmcykpO1xuXG4gICAgICAgIGdsLnNoYWRlclNvdXJjZShzaGFkZXIsIGZyYWdtZW50U3JjKTtcbiAgICAgICAgZ2wuY29tcGlsZVNoYWRlcihzaGFkZXIpO1xuXG4gICAgICAgIGlmICghZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpKSB7XG4gICAgICAgICAgICBtYXhJZnMgPSBtYXhJZnMgLyAyIHwgMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHZhbGlkIVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY3JlYXRlVGVtcENvbnRleHQpIHtcbiAgICAgICAgLy8gZ2V0IHJpZCBvZiBjb250ZXh0XG4gICAgICAgIGlmIChnbC5nZXRFeHRlbnNpb24oJ1dFQkdMX2xvc2VfY29udGV4dCcpKSB7XG4gICAgICAgICAgICBnbC5nZXRFeHRlbnNpb24oJ1dFQkdMX2xvc2VfY29udGV4dCcpLmxvc2VDb250ZXh0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWF4SWZzO1xufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZUlmVGVzdFNyYyhtYXhJZnMpIHtcbiAgICB2YXIgc3JjID0gJyc7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1heElmczsgKytpKSB7XG4gICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgc3JjICs9ICdcXG5lbHNlICc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaSA8IG1heElmcyAtIDEpIHtcbiAgICAgICAgICAgIHNyYyArPSAnaWYodGVzdCA9PSAnICsgaSArICcuMCl7fSc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3JjO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hlY2tNYXhJZlN0YXRtZW50c0luU2hhZGVyLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuZGVmYXVsdCA9IG1hcFdlYkdMQmxlbmRNb2Rlc1RvUGl4aTtcblxudmFyIF9jb25zdCA9IHJlcXVpcmUoJy4uLy4uLy4uL2NvbnN0Jyk7XG5cbi8qKlxuICogTWFwcyBnbCBibGVuZCBjb21iaW5hdGlvbnMgdG8gV2ViR0wuXG4gKlxuICogQG1lbWJlcm9mIFBJWElcbiAqIEBmdW5jdGlvbiBtYXBXZWJHTEJsZW5kTW9kZXNUb1BpeGlcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgLSBUaGUgcmVuZGVyaW5nIGNvbnRleHQuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBbYXJyYXk9W11dIC0gVGhlIGFycmF5IHRvIG91dHB1dCBpbnRvLlxuICogQHJldHVybiB7c3RyaW5nW119IE1hcHBlZCBtb2Rlcy5cbiAqL1xuZnVuY3Rpb24gbWFwV2ViR0xCbGVuZE1vZGVzVG9QaXhpKGdsKSB7XG4gICAgdmFyIGFycmF5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBbXTtcblxuICAgIC8vIFRPRE8gLSBwcmVtdWx0aXBseSBhbHBoYSB3b3VsZCBiZSBkaWZmZXJlbnQuXG4gICAgLy8gYWRkIGEgYm9vbGVhbiBmb3IgdGhhdCFcbiAgICBhcnJheVtfY29uc3QuQkxFTkRfTU9ERVMuTk9STUFMXSA9IFtnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdO1xuICAgIGFycmF5W19jb25zdC5CTEVORF9NT0RFUy5BRERdID0gW2dsLk9ORSwgZ2wuT05FXTtcbiAgICBhcnJheVtfY29uc3QuQkxFTkRfTU9ERVMuTVVMVElQTFldID0gW2dsLkRTVF9DT0xPUiwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSwgZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcbiAgICBhcnJheVtfY29uc3QuQkxFTkRfTU9ERVMuU0NSRUVOXSA9IFtnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQ09MT1IsIGdsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XG4gICAgYXJyYXlbX2NvbnN0LkJMRU5EX01PREVTLk9WRVJMQVldID0gW2dsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XG4gICAgYXJyYXlbX2NvbnN0LkJMRU5EX01PREVTLkRBUktFTl0gPSBbZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcbiAgICBhcnJheVtfY29uc3QuQkxFTkRfTU9ERVMuTElHSFRFTl0gPSBbZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcbiAgICBhcnJheVtfY29uc3QuQkxFTkRfTU9ERVMuQ09MT1JfRE9ER0VdID0gW2dsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XG4gICAgYXJyYXlbX2NvbnN0LkJMRU5EX01PREVTLkNPTE9SX0JVUk5dID0gW2dsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XG4gICAgYXJyYXlbX2NvbnN0LkJMRU5EX01PREVTLkhBUkRfTElHSFRdID0gW2dsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XG4gICAgYXJyYXlbX2NvbnN0LkJMRU5EX01PREVTLlNPRlRfTElHSFRdID0gW2dsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XG4gICAgYXJyYXlbX2NvbnN0LkJMRU5EX01PREVTLkRJRkZFUkVOQ0VdID0gW2dsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XG4gICAgYXJyYXlbX2NvbnN0LkJMRU5EX01PREVTLkVYQ0xVU0lPTl0gPSBbZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcbiAgICBhcnJheVtfY29uc3QuQkxFTkRfTU9ERVMuSFVFXSA9IFtnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdO1xuICAgIGFycmF5W19jb25zdC5CTEVORF9NT0RFUy5TQVRVUkFUSU9OXSA9IFtnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdO1xuICAgIGFycmF5W19jb25zdC5CTEVORF9NT0RFUy5DT0xPUl0gPSBbZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcbiAgICBhcnJheVtfY29uc3QuQkxFTkRfTU9ERVMuTFVNSU5PU0lUWV0gPSBbZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcblxuICAgIC8vIG5vdC1wcmVtdWx0aXBsaWVkIGJsZW5kIG1vZGVzXG4gICAgYXJyYXlbX2NvbnN0LkJMRU5EX01PREVTLk5PUk1BTF9OUE1dID0gW2dsLlNSQ19BTFBIQSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSwgZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcbiAgICBhcnJheVtfY29uc3QuQkxFTkRfTU9ERVMuQUREX05QTV0gPSBbZ2wuU1JDX0FMUEhBLCBnbC5PTkUsIGdsLk9ORSwgZ2wuT05FXTtcbiAgICBhcnJheVtfY29uc3QuQkxFTkRfTU9ERVMuU0NSRUVOX05QTV0gPSBbZ2wuU1JDX0FMUEhBLCBnbC5PTkVfTUlOVVNfU1JDX0NPTE9SLCBnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdO1xuXG4gICAgcmV0dXJuIGFycmF5O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFwV2ViR0xCbGVuZE1vZGVzVG9QaXhpLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuZGVmYXVsdCA9IG1hcFdlYkdMRHJhd01vZGVzVG9QaXhpO1xuXG52YXIgX2NvbnN0ID0gcmVxdWlyZSgnLi4vLi4vLi4vY29uc3QnKTtcblxuLyoqXG4gKiBHZW5lcmljIE1hc2sgU3RhY2sgZGF0YSBzdHJ1Y3R1cmUuXG4gKlxuICogQG1lbWJlcm9mIFBJWElcbiAqIEBmdW5jdGlvbiBtYXBXZWJHTERyYXdNb2Rlc1RvUGl4aVxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCAtIFRoZSBjdXJyZW50IFdlYkdMIGRyYXdpbmcgY29udGV4dFxuICogQHBhcmFtIHtvYmplY3R9IFtvYmplY3Q9e31dIC0gVGhlIG9iamVjdCB0byBtYXAgaW50b1xuICogQHJldHVybiB7b2JqZWN0fSBUaGUgbWFwcGVkIGRyYXcgbW9kZXMuXG4gKi9cbmZ1bmN0aW9uIG1hcFdlYkdMRHJhd01vZGVzVG9QaXhpKGdsKSB7XG4gIHZhciBvYmplY3QgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gIG9iamVjdFtfY29uc3QuRFJBV19NT0RFUy5QT0lOVFNdID0gZ2wuUE9JTlRTO1xuICBvYmplY3RbX2NvbnN0LkRSQVdfTU9ERVMuTElORVNdID0gZ2wuTElORVM7XG4gIG9iamVjdFtfY29uc3QuRFJBV19NT0RFUy5MSU5FX0xPT1BdID0gZ2wuTElORV9MT09QO1xuICBvYmplY3RbX2NvbnN0LkRSQVdfTU9ERVMuTElORV9TVFJJUF0gPSBnbC5MSU5FX1NUUklQO1xuICBvYmplY3RbX2NvbnN0LkRSQVdfTU9ERVMuVFJJQU5HTEVTXSA9IGdsLlRSSUFOR0xFUztcbiAgb2JqZWN0W19jb25zdC5EUkFXX01PREVTLlRSSUFOR0xFX1NUUklQXSA9IGdsLlRSSUFOR0xFX1NUUklQO1xuICBvYmplY3RbX2NvbnN0LkRSQVdfTU9ERVMuVFJJQU5HTEVfRkFOXSA9IGdsLlRSSUFOR0xFX0ZBTjtcblxuICByZXR1cm4gb2JqZWN0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFwV2ViR0xEcmF3TW9kZXNUb1BpeGkuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5kZWZhdWx0ID0gdmFsaWRhdGVDb250ZXh0O1xuZnVuY3Rpb24gdmFsaWRhdGVDb250ZXh0KGdsKSB7XG4gICAgdmFyIGF0dHJpYnV0ZXMgPSBnbC5nZXRDb250ZXh0QXR0cmlidXRlcygpO1xuXG4gICAgLy8gdGhpcyBpcyBnb2luZyB0byBiZSBmYWlybHkgc2ltcGxlIGZvciBub3cuLiBidXQgYXQgbGVhc3Qgd2UgaGF2ZSByb29tIHRvIGdyb3chXG4gICAgaWYgKCFhdHRyaWJ1dGVzLnN0ZW5jaWwpIHtcbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xuICAgICAgICBjb25zb2xlLndhcm4oJ1Byb3ZpZGVkIFdlYkdMIGNvbnRleHQgZG9lcyBub3QgaGF2ZSBhIHN0ZW5jaWwgYnVmZmVyLCBtYXNrcyBtYXkgbm90IHJlbmRlciBjb3JyZWN0bHknKTtcbiAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1jb25zb2xlICovXG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmFsaWRhdGVDb250ZXh0LmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9tYXhSZWNvbW1lbmRlZFRleHR1cmVzID0gcmVxdWlyZSgnLi91dGlscy9tYXhSZWNvbW1lbmRlZFRleHR1cmVzJyk7XG5cbnZhciBfbWF4UmVjb21tZW5kZWRUZXh0dXJlczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tYXhSZWNvbW1lbmRlZFRleHR1cmVzKTtcblxudmFyIF9jYW5VcGxvYWRTYW1lQnVmZmVyID0gcmVxdWlyZSgnLi91dGlscy9jYW5VcGxvYWRTYW1lQnVmZmVyJyk7XG5cbnZhciBfY2FuVXBsb2FkU2FtZUJ1ZmZlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jYW5VcGxvYWRTYW1lQnVmZmVyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLyoqXG4gKiBVc2VyJ3MgY3VzdG9taXphYmxlIGdsb2JhbHMgZm9yIG92ZXJyaWRpbmcgdGhlIGRlZmF1bHQgUElYSSBzZXR0aW5ncywgc3VjaFxuICogYXMgYSByZW5kZXJlcidzIGRlZmF1bHQgcmVzb2x1dGlvbiwgZnJhbWVyYXRlLCBmbG9hdCBwZXJjaXNpb24sIGV0Yy5cbiAqIEBleGFtcGxlXG4gKiAvLyBVc2UgdGhlIG5hdGl2ZSB3aW5kb3cgcmVzb2x1dGlvbiBhcyB0aGUgZGVmYXVsdCByZXNvbHV0aW9uXG4gKiAvLyB3aWxsIHN1cHBvcnQgaGlnaC1kZW5zaXR5IGRpc3BsYXlzIHdoZW4gcmVuZGVyaW5nXG4gKiBQSVhJLnNldHRpbmdzLlJFU09MVVRJT04gPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpby5cbiAqXG4gKiAvLyBEaXNhYmxlIGludGVycG9sYXRpb24gd2hlbiBzY2FsaW5nLCB3aWxsIG1ha2UgdGV4dHVyZSBiZSBwaXhlbGF0ZWRcbiAqIFBJWEkuc2V0dGluZ3MuU0NBTEVfTU9ERSA9IFBJWEkuU0NBTEVfTU9ERVMuTkVBUkVTVDtcbiAqIEBuYW1lc3BhY2UgUElYSS5zZXR0aW5nc1xuICovXG5leHBvcnRzLmRlZmF1bHQgPSB7XG5cbiAgLyoqXG4gICAqIFRhcmdldCBmcmFtZXMgcGVyIG1pbGxpc2Vjb25kLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJvZiBQSVhJLnNldHRpbmdzXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBkZWZhdWx0IDAuMDZcbiAgICovXG4gIFRBUkdFVF9GUE1TOiAwLjA2LFxuXG4gIC8qKlxuICAgKiBJZiBzZXQgdG8gdHJ1ZSBXZWJHTCB3aWxsIGF0dGVtcHQgbWFrZSB0ZXh0dXJlcyBtaW1wYXBlZCBieSBkZWZhdWx0LlxuICAgKiBNaXBtYXBwaW5nIHdpbGwgb25seSBzdWNjZWVkIGlmIHRoZSBiYXNlIHRleHR1cmUgdXBsb2FkZWQgaGFzIHBvd2VyIG9mIHR3byBkaW1lbnNpb25zLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJvZiBQSVhJLnNldHRpbmdzXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICBNSVBNQVBfVEVYVFVSRVM6IHRydWUsXG5cbiAgLyoqXG4gICAqIERlZmF1bHQgcmVzb2x1dGlvbiAvIGRldmljZSBwaXhlbCByYXRpbyBvZiB0aGUgcmVuZGVyZXIuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlcm9mIFBJWEkuc2V0dGluZ3NcbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQGRlZmF1bHQgMVxuICAgKi9cbiAgUkVTT0xVVElPTjogMSxcblxuICAvKipcbiAgICogRGVmYXVsdCBmaWx0ZXIgcmVzb2x1dGlvbi5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyb2YgUElYSS5zZXR0aW5nc1xuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAZGVmYXVsdCAxXG4gICAqL1xuICBGSUxURVJfUkVTT0xVVElPTjogMSxcblxuICAvKipcbiAgICogVGhlIG1heGltdW0gdGV4dHVyZXMgdGhhdCB0aGlzIGRldmljZSBzdXBwb3J0cy5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyb2YgUElYSS5zZXR0aW5nc1xuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAZGVmYXVsdCAzMlxuICAgKi9cbiAgU1BSSVRFX01BWF9URVhUVVJFUzogKDAsIF9tYXhSZWNvbW1lbmRlZFRleHR1cmVzMi5kZWZhdWx0KSgzMiksXG5cbiAgLy8gVE9ETzogbWF5YmUgY2hhbmdlIHRvIFNQUklURS5CQVRDSF9TSVpFOiAyMDAwXG4gIC8vIFRPRE86IG1heWJlIGFkZCBQQVJUSUNMRS5CQVRDSF9TSVpFOiAxNTAwMFxuXG4gIC8qKlxuICAgKiBUaGUgZGVmYXVsdCBzcHJpdGUgYmF0Y2ggc2l6ZS5cbiAgICpcbiAgICogVGhlIGRlZmF1bHQgYWltcyB0byBiYWxhbmNlIGRlc2t0b3AgYW5kIG1vYmlsZSBkZXZpY2VzLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJvZiBQSVhJLnNldHRpbmdzXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBkZWZhdWx0IDQwOTZcbiAgICovXG4gIFNQUklURV9CQVRDSF9TSVpFOiA0MDk2LFxuXG4gIC8qKlxuICAgKiBUaGUgcHJlZml4IHRoYXQgZGVub3RlcyBhIFVSTCBpcyBmb3IgYSByZXRpbmEgYXNzZXQuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlcm9mIFBJWEkuc2V0dGluZ3NcbiAgICogQHR5cGUge1JlZ0V4cH1cbiAgICogQGV4YW1wbGUgYEAyeGBcbiAgICogQGRlZmF1bHQgL0AoWzAtOVxcLl0rKXgvXG4gICAqL1xuICBSRVRJTkFfUFJFRklYOiAvQChbMC05XFwuXSspeC8sXG5cbiAgLyoqXG4gICAqIFRoZSBkZWZhdWx0IHJlbmRlciBvcHRpb25zIGlmIG5vbmUgYXJlIHN1cHBsaWVkIHRvIHtAbGluayBQSVhJLldlYkdMUmVuZGVyZXJ9XG4gICAqIG9yIHtAbGluayBQSVhJLkNhbnZhc1JlbmRlcmVyfS5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAY29uc3RhbnRcbiAgICogQG1lbWJlcm9mIFBJWEkuc2V0dGluZ3NcbiAgICogQHR5cGUge29iamVjdH1cbiAgICogQHByb3BlcnR5IHtIVE1MQ2FudmFzRWxlbWVudH0gdmlldz1udWxsXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSByZXNvbHV0aW9uPTFcbiAgICogQHByb3BlcnR5IHtib29sZWFufSBhbnRpYWxpYXM9ZmFsc2VcbiAgICogQHByb3BlcnR5IHtib29sZWFufSBmb3JjZUZYQUE9ZmFsc2VcbiAgICogQHByb3BlcnR5IHtib29sZWFufSBhdXRvUmVzaXplPWZhbHNlXG4gICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gdHJhbnNwYXJlbnQ9ZmFsc2VcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IGJhY2tncm91bmRDb2xvcj0weDAwMDAwMFxuICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGNsZWFyQmVmb3JlUmVuZGVyPXRydWVcbiAgICogQHByb3BlcnR5IHtib29sZWFufSBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI9ZmFsc2VcbiAgICogQHByb3BlcnR5IHtib29sZWFufSByb3VuZFBpeGVscz1mYWxzZVxuICAgKiBAcHJvcGVydHkge251bWJlcn0gd2lkdGg9ODAwXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBoZWlnaHQ9NjAwXG4gICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gbGVnYWN5PWZhbHNlXG4gICAqL1xuICBSRU5ERVJfT1BUSU9OUzoge1xuICAgIHZpZXc6IG51bGwsXG4gICAgYW50aWFsaWFzOiBmYWxzZSxcbiAgICBmb3JjZUZYQUE6IGZhbHNlLFxuICAgIGF1dG9SZXNpemU6IGZhbHNlLFxuICAgIHRyYW5zcGFyZW50OiBmYWxzZSxcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IDB4MDAwMDAwLFxuICAgIGNsZWFyQmVmb3JlUmVuZGVyOiB0cnVlLFxuICAgIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogZmFsc2UsXG4gICAgcm91bmRQaXhlbHM6IGZhbHNlLFxuICAgIHdpZHRoOiA4MDAsXG4gICAgaGVpZ2h0OiA2MDAsXG4gICAgbGVnYWN5OiBmYWxzZVxuICB9LFxuXG4gIC8qKlxuICAgKiBEZWZhdWx0IHRyYW5zZm9ybSB0eXBlLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJvZiBQSVhJLnNldHRpbmdzXG4gICAqIEB0eXBlIHtQSVhJLlRSQU5TRk9STV9NT0RFfVxuICAgKiBAZGVmYXVsdCBQSVhJLlRSQU5TRk9STV9NT0RFLlNUQVRJQ1xuICAgKi9cbiAgVFJBTlNGT1JNX01PREU6IDAsXG5cbiAgLyoqXG4gICAqIERlZmF1bHQgR2FyYmFnZSBDb2xsZWN0aW9uIG1vZGUuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlcm9mIFBJWEkuc2V0dGluZ3NcbiAgICogQHR5cGUge1BJWEkuR0NfTU9ERVN9XG4gICAqIEBkZWZhdWx0IFBJWEkuR0NfTU9ERVMuQVVUT1xuICAgKi9cbiAgR0NfTU9ERTogMCxcblxuICAvKipcbiAgICogRGVmYXVsdCBHYXJiYWdlIENvbGxlY3Rpb24gbWF4IGlkbGUuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlcm9mIFBJWEkuc2V0dGluZ3NcbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQGRlZmF1bHQgMzYwMFxuICAgKi9cbiAgR0NfTUFYX0lETEU6IDYwICogNjAsXG5cbiAgLyoqXG4gICAqIERlZmF1bHQgR2FyYmFnZSBDb2xsZWN0aW9uIG1heGltdW0gY2hlY2sgY291bnQuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlcm9mIFBJWEkuc2V0dGluZ3NcbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQGRlZmF1bHQgNjAwXG4gICAqL1xuICBHQ19NQVhfQ0hFQ0tfQ09VTlQ6IDYwICogMTAsXG5cbiAgLyoqXG4gICAqIERlZmF1bHQgd3JhcCBtb2RlcyB0aGF0IGFyZSBzdXBwb3J0ZWQgYnkgcGl4aS5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyb2YgUElYSS5zZXR0aW5nc1xuICAgKiBAdHlwZSB7UElYSS5XUkFQX01PREVTfVxuICAgKiBAZGVmYXVsdCBQSVhJLldSQVBfTU9ERVMuQ0xBTVBcbiAgICovXG4gIFdSQVBfTU9ERTogMCxcblxuICAvKipcbiAgICogVGhlIHNjYWxlIG1vZGVzIHRoYXQgYXJlIHN1cHBvcnRlZCBieSBwaXhpLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJvZiBQSVhJLnNldHRpbmdzXG4gICAqIEB0eXBlIHtQSVhJLlNDQUxFX01PREVTfVxuICAgKiBAZGVmYXVsdCBQSVhJLlNDQUxFX01PREVTLkxJTkVBUlxuICAgKi9cbiAgU0NBTEVfTU9ERTogMCxcblxuICAvKipcbiAgICogRGVmYXVsdCBzcGVjaWZ5IGZsb2F0IHByZWNpc2lvbiBpbiB2ZXJ0ZXggc2hhZGVyLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJvZiBQSVhJLnNldHRpbmdzXG4gICAqIEB0eXBlIHtQSVhJLlBSRUNJU0lPTn1cbiAgICogQGRlZmF1bHQgUElYSS5QUkVDSVNJT04uSElHSFxuICAgKi9cbiAgUFJFQ0lTSU9OX1ZFUlRFWDogJ2hpZ2hwJyxcblxuICAvKipcbiAgICogRGVmYXVsdCBzcGVjaWZ5IGZsb2F0IHByZWNpc2lvbiBpbiBmcmFnbWVudCBzaGFkZXIuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlcm9mIFBJWEkuc2V0dGluZ3NcbiAgICogQHR5cGUge1BJWEkuUFJFQ0lTSU9OfVxuICAgKiBAZGVmYXVsdCBQSVhJLlBSRUNJU0lPTi5NRURJVU1cbiAgICovXG4gIFBSRUNJU0lPTl9GUkFHTUVOVDogJ21lZGl1bXAnLFxuXG4gIC8qKlxuICAgKiBDYW4gd2UgdXBsb2FkIHRoZSBzYW1lIGJ1ZmZlciBpbiBhIHNpbmdsZSBmcmFtZT9cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAY29uc3RhbnRcbiAgICogQG1lbWJlcm9mIFBJWEkuc2V0dGluZ3NcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBDQU5fVVBMT0FEX1NBTUVfQlVGRkVSOiAoMCwgX2NhblVwbG9hZFNhbWVCdWZmZXIyLmRlZmF1bHQpKCksXG5cbiAgLyoqXG4gICAqIERlZmF1bHQgTWVzaCBgY2FudmFzUGFkZGluZ2AuXG4gICAqXG4gICAqIEBzZWUgUElYSS5tZXNoLk1lc2gjY2FudmFzUGFkZGluZ1xuICAgKiBAc3RhdGljXG4gICAqIEBjb25zdGFudFxuICAgKiBAbWVtYmVyb2YgUElYSS5zZXR0aW5nc1xuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgTUVTSF9DQU5WQVNfUEFERElORzogMFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNldHRpbmdzLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9tYXRoID0gcmVxdWlyZSgnLi4vbWF0aCcpO1xuXG52YXIgX3V0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxudmFyIF9jb25zdCA9IHJlcXVpcmUoJy4uL2NvbnN0Jyk7XG5cbnZhciBfVGV4dHVyZSA9IHJlcXVpcmUoJy4uL3RleHR1cmVzL1RleHR1cmUnKTtcblxudmFyIF9UZXh0dXJlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1RleHR1cmUpO1xuXG52YXIgX0NvbnRhaW5lcjIgPSByZXF1aXJlKCcuLi9kaXNwbGF5L0NvbnRhaW5lcicpO1xuXG52YXIgX0NvbnRhaW5lcjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Db250YWluZXIyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgdGVtcFBvaW50ID0gbmV3IF9tYXRoLlBvaW50KCk7XG5cbi8qKlxuICogVGhlIFNwcml0ZSBvYmplY3QgaXMgdGhlIGJhc2UgZm9yIGFsbCB0ZXh0dXJlZCBvYmplY3RzIHRoYXQgYXJlIHJlbmRlcmVkIHRvIHRoZSBzY3JlZW5cbiAqXG4gKiBBIHNwcml0ZSBjYW4gYmUgY3JlYXRlZCBkaXJlY3RseSBmcm9tIGFuIGltYWdlIGxpa2UgdGhpczpcbiAqXG4gKiBgYGBqc1xuICogbGV0IHNwcml0ZSA9IG5ldyBQSVhJLlNwcml0ZS5mcm9tSW1hZ2UoJ2Fzc2V0cy9pbWFnZS5wbmcnKTtcbiAqIGBgYFxuICpcbiAqIFRoZSBtb3JlIGVmZmljaWVudCB3YXkgdG8gY3JlYXRlIHNwcml0ZXMgaXMgdXNpbmcgYSB7QGxpbmsgUElYSS5TcHJpdGVzaGVldH06XG4gKlxuICogYGBganNcbiAqIFBJWEkubG9hZGVyLmFkZChcImFzc2V0cy9zcHJpdGVzaGVldC5qc29uXCIpLmxvYWQoc2V0dXApO1xuICpcbiAqIGZ1bmN0aW9uIHNldHVwKCkge1xuICogICBsZXQgc2hlZXQgPSBQSVhJLmxvYWRlci5yZXNvdXJjZXNbXCJhc3NldHMvc3ByaXRlc2hlZXQuanNvblwiXS5zcHJpdGVzaGVldDtcbiAqICAgbGV0IHNwcml0ZSA9IG5ldyBQSVhJLlNwcml0ZShzaGVldC50ZXh0dXJlc1tcImltYWdlLnBuZ1wiXSk7XG4gKiAgIC4uLlxuICogfVxuICogYGBgXG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQSVhJLkNvbnRhaW5lclxuICogQG1lbWJlcm9mIFBJWElcbiAqL1xuXG52YXIgU3ByaXRlID0gZnVuY3Rpb24gKF9Db250YWluZXIpIHtcbiAgICBfaW5oZXJpdHMoU3ByaXRlLCBfQ29udGFpbmVyKTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7UElYSS5UZXh0dXJlfSB0ZXh0dXJlIC0gVGhlIHRleHR1cmUgZm9yIHRoaXMgc3ByaXRlXG4gICAgICovXG4gICAgZnVuY3Rpb24gU3ByaXRlKHRleHR1cmUpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNwcml0ZSk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBhbmNob3Igc2V0cyB0aGUgb3JpZ2luIHBvaW50IG9mIHRoZSB0ZXh0dXJlLlxuICAgICAgICAgKiBUaGUgZGVmYXVsdCBpcyAwLDAgb3IgdGFrZW4gZnJvbSB0aGUge0BsaW5rIFBJWEkuVGV4dHVyZSNkZWZhdWx0QW5jaG9yfFRleHR1cmV9XG4gICAgICAgICAqIHBhc3NlZCB0byB0aGUgY29uc3RydWN0b3IuIEEgdmFsdWUgb2YgMCwwIG1lYW5zIHRoZSB0ZXh0dXJlJ3Mgb3JpZ2luIGlzIHRoZSB0b3AgbGVmdC5cbiAgICAgICAgICogU2V0dGluZyB0aGUgYW5jaG9yIHRvIDAuNSwwLjUgbWVhbnMgdGhlIHRleHR1cmUncyBvcmlnaW4gaXMgY2VudGVyZWQuXG4gICAgICAgICAqIFNldHRpbmcgdGhlIGFuY2hvciB0byAxLDEgd291bGQgbWVhbiB0aGUgdGV4dHVyZSdzIG9yaWdpbiBwb2ludCB3aWxsIGJlIHRoZSBib3R0b20gcmlnaHQgY29ybmVyLlxuICAgICAgICAgKiBOb3RlOiBVcGRhdGluZyB0aGUge0BsaW5rIFBJWEkuVGV4dHVyZSNkZWZhdWx0QW5jaG9yfSBhZnRlciBhIFRleHR1cmUgaXNcbiAgICAgICAgICogY3JlYXRlZCBkb2VzIF9ub3RfIHVwZGF0ZSB0aGUgU3ByaXRlJ3MgYW5jaG9yIHZhbHVlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5PYnNlcnZhYmxlUG9pbnR9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29udGFpbmVyLmNhbGwodGhpcykpO1xuXG4gICAgICAgIF90aGlzLl9hbmNob3IgPSBuZXcgX21hdGguT2JzZXJ2YWJsZVBvaW50KF90aGlzLl9vbkFuY2hvclVwZGF0ZSwgX3RoaXMsIHRleHR1cmUgPyB0ZXh0dXJlLmRlZmF1bHRBbmNob3IueCA6IDAsIHRleHR1cmUgPyB0ZXh0dXJlLmRlZmF1bHRBbmNob3IueSA6IDApO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdGV4dHVyZSB0aGF0IHRoZSBzcHJpdGUgaXMgdXNpbmdcbiAgICAgICAgICpcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5UZXh0dXJlfVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuX3RleHR1cmUgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgd2lkdGggb2YgdGhlIHNwcml0ZSAodGhpcyBpcyBpbml0aWFsbHkgc2V0IGJ5IHRoZSB0ZXh0dXJlKVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5fd2lkdGggPSAwO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgaGVpZ2h0IG9mIHRoZSBzcHJpdGUgKHRoaXMgaXMgaW5pdGlhbGx5IHNldCBieSB0aGUgdGV4dHVyZSlcbiAgICAgICAgICpcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuX2hlaWdodCA9IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0aW50IGFwcGxpZWQgdG8gdGhlIHNwcml0ZS4gVGhpcyBpcyBhIGhleCB2YWx1ZS4gQSB2YWx1ZSBvZiAweEZGRkZGRiB3aWxsIHJlbW92ZSBhbnkgdGludCBlZmZlY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMHhGRkZGRkZcbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLl90aW50ID0gbnVsbDtcbiAgICAgICAgX3RoaXMuX3RpbnRSR0IgPSBudWxsO1xuICAgICAgICBfdGhpcy50aW50ID0gMHhGRkZGRkY7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBibGVuZCBtb2RlIHRvIGJlIGFwcGxpZWQgdG8gdGhlIHNwcml0ZS4gQXBwbHkgYSB2YWx1ZSBvZiBgUElYSS5CTEVORF9NT0RFUy5OT1JNQUxgIHRvIHJlc2V0IHRoZSBibGVuZCBtb2RlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IFBJWEkuQkxFTkRfTU9ERVMuTk9STUFMXG4gICAgICAgICAqIEBzZWUgUElYSS5CTEVORF9NT0RFU1xuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuYmxlbmRNb2RlID0gX2NvbnN0LkJMRU5EX01PREVTLk5PUk1BTDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHNoYWRlciB0aGF0IHdpbGwgYmUgdXNlZCB0byByZW5kZXIgdGhlIHNwcml0ZS4gU2V0IHRvIG51bGwgdG8gcmVtb3ZlIGEgY3VycmVudCBzaGFkZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuRmlsdGVyfFBJWEkuU2hhZGVyfVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuc2hhZGVyID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQW4gaW50ZXJuYWwgY2FjaGVkIHZhbHVlIG9mIHRoZSB0aW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDB4RkZGRkZGXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5jYWNoZWRUaW50ID0gMHhGRkZGRkY7XG5cbiAgICAgICAgLy8gY2FsbCB0ZXh0dXJlIHNldHRlclxuICAgICAgICBfdGhpcy50ZXh0dXJlID0gdGV4dHVyZSB8fCBfVGV4dHVyZTIuZGVmYXVsdC5FTVBUWTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogdGhpcyBpcyB1c2VkIHRvIHN0b3JlIHRoZSB2ZXJ0ZXggZGF0YSBvZiB0aGUgc3ByaXRlIChiYXNpY2FsbHkgYSBxdWFkKVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAbWVtYmVyIHtGbG9hdDMyQXJyYXl9XG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy52ZXJ0ZXhEYXRhID0gbmV3IEZsb2F0MzJBcnJheSg4KTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBpcyB1c2VkIHRvIGNhbGN1bGF0ZSB0aGUgYm91bmRzIG9mIHRoZSBvYmplY3QgSUYgaXQgaXMgYSB0cmltbWVkIHNwcml0ZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAbWVtYmVyIHtGbG9hdDMyQXJyYXl9XG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy52ZXJ0ZXhUcmltbWVkRGF0YSA9IG51bGw7XG5cbiAgICAgICAgX3RoaXMuX3RyYW5zZm9ybUlEID0gLTE7XG4gICAgICAgIF90aGlzLl90ZXh0dXJlSUQgPSAtMTtcblxuICAgICAgICBfdGhpcy5fdHJhbnNmb3JtVHJpbW1lZElEID0gLTE7XG4gICAgICAgIF90aGlzLl90ZXh0dXJlVHJpbW1lZElEID0gLTE7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBsdWdpbiB0aGF0IGlzIHJlc3BvbnNpYmxlIGZvciByZW5kZXJpbmcgdGhpcyBlbGVtZW50LlxuICAgICAgICAgKiBBbGxvd3MgdG8gY3VzdG9taXplIHRoZSByZW5kZXJpbmcgcHJvY2VzcyB3aXRob3V0IG92ZXJyaWRpbmcgJ19yZW5kZXJXZWJHTCcgJiAnX3JlbmRlckNhbnZhcycgbWV0aG9kcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAnc3ByaXRlJ1xuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMucGx1Z2luTmFtZSA9ICdzcHJpdGUnO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2hlbiB0aGUgdGV4dHVyZSBpcyB1cGRhdGVkLCB0aGlzIGV2ZW50IHdpbGwgZmlyZSB0byB1cGRhdGUgdGhlIHNjYWxlIGFuZCBmcmFtZVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuXG4gICAgU3ByaXRlLnByb3RvdHlwZS5fb25UZXh0dXJlVXBkYXRlID0gZnVuY3Rpb24gX29uVGV4dHVyZVVwZGF0ZSgpIHtcbiAgICAgICAgdGhpcy5fdGV4dHVyZUlEID0gLTE7XG4gICAgICAgIHRoaXMuX3RleHR1cmVUcmltbWVkSUQgPSAtMTtcbiAgICAgICAgdGhpcy5jYWNoZWRUaW50ID0gMHhGRkZGRkY7XG5cbiAgICAgICAgLy8gc28gaWYgX3dpZHRoIGlzIDAgdGhlbiB3aWR0aCB3YXMgbm90IHNldC4uXG4gICAgICAgIGlmICh0aGlzLl93aWR0aCkge1xuICAgICAgICAgICAgdGhpcy5zY2FsZS54ID0gKDAsIF91dGlscy5zaWduKSh0aGlzLnNjYWxlLngpICogdGhpcy5fd2lkdGggLyB0aGlzLl90ZXh0dXJlLm9yaWcud2lkdGg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5faGVpZ2h0KSB7XG4gICAgICAgICAgICB0aGlzLnNjYWxlLnkgPSAoMCwgX3V0aWxzLnNpZ24pKHRoaXMuc2NhbGUueSkgKiB0aGlzLl9oZWlnaHQgLyB0aGlzLl90ZXh0dXJlLm9yaWcuaGVpZ2h0O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIHRoZSBhbmNob3IgcG9zaXRpb24gdXBkYXRlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cblxuICAgIFNwcml0ZS5wcm90b3R5cGUuX29uQW5jaG9yVXBkYXRlID0gZnVuY3Rpb24gX29uQW5jaG9yVXBkYXRlKCkge1xuICAgICAgICB0aGlzLl90cmFuc2Zvcm1JRCA9IC0xO1xuICAgICAgICB0aGlzLl90cmFuc2Zvcm1UcmltbWVkSUQgPSAtMTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogY2FsY3VsYXRlcyB3b3JsZFRyYW5zZm9ybSAqIHZlcnRpY2VzLCBzdG9yZSBpdCBpbiB2ZXJ0ZXhEYXRhXG4gICAgICovXG5cblxuICAgIFNwcml0ZS5wcm90b3R5cGUuY2FsY3VsYXRlVmVydGljZXMgPSBmdW5jdGlvbiBjYWxjdWxhdGVWZXJ0aWNlcygpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RyYW5zZm9ybUlEID09PSB0aGlzLnRyYW5zZm9ybS5fd29ybGRJRCAmJiB0aGlzLl90ZXh0dXJlSUQgPT09IHRoaXMuX3RleHR1cmUuX3VwZGF0ZUlEKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl90cmFuc2Zvcm1JRCA9IHRoaXMudHJhbnNmb3JtLl93b3JsZElEO1xuICAgICAgICB0aGlzLl90ZXh0dXJlSUQgPSB0aGlzLl90ZXh0dXJlLl91cGRhdGVJRDtcblxuICAgICAgICAvLyBzZXQgdGhlIHZlcnRleCBkYXRhXG5cbiAgICAgICAgdmFyIHRleHR1cmUgPSB0aGlzLl90ZXh0dXJlO1xuICAgICAgICB2YXIgd3QgPSB0aGlzLnRyYW5zZm9ybS53b3JsZFRyYW5zZm9ybTtcbiAgICAgICAgdmFyIGEgPSB3dC5hO1xuICAgICAgICB2YXIgYiA9IHd0LmI7XG4gICAgICAgIHZhciBjID0gd3QuYztcbiAgICAgICAgdmFyIGQgPSB3dC5kO1xuICAgICAgICB2YXIgdHggPSB3dC50eDtcbiAgICAgICAgdmFyIHR5ID0gd3QudHk7XG4gICAgICAgIHZhciB2ZXJ0ZXhEYXRhID0gdGhpcy52ZXJ0ZXhEYXRhO1xuICAgICAgICB2YXIgdHJpbSA9IHRleHR1cmUudHJpbTtcbiAgICAgICAgdmFyIG9yaWcgPSB0ZXh0dXJlLm9yaWc7XG4gICAgICAgIHZhciBhbmNob3IgPSB0aGlzLl9hbmNob3I7XG5cbiAgICAgICAgdmFyIHcwID0gMDtcbiAgICAgICAgdmFyIHcxID0gMDtcbiAgICAgICAgdmFyIGgwID0gMDtcbiAgICAgICAgdmFyIGgxID0gMDtcblxuICAgICAgICBpZiAodHJpbSkge1xuICAgICAgICAgICAgLy8gaWYgdGhlIHNwcml0ZSBpcyB0cmltbWVkIGFuZCBpcyBub3QgYSB0aWxpbmdzcHJpdGUgdGhlbiB3ZSBuZWVkIHRvIGFkZCB0aGUgZXh0cmFcbiAgICAgICAgICAgIC8vIHNwYWNlIGJlZm9yZSB0cmFuc2Zvcm1pbmcgdGhlIHNwcml0ZSBjb29yZHMuXG4gICAgICAgICAgICB3MSA9IHRyaW0ueCAtIGFuY2hvci5feCAqIG9yaWcud2lkdGg7XG4gICAgICAgICAgICB3MCA9IHcxICsgdHJpbS53aWR0aDtcblxuICAgICAgICAgICAgaDEgPSB0cmltLnkgLSBhbmNob3IuX3kgKiBvcmlnLmhlaWdodDtcbiAgICAgICAgICAgIGgwID0gaDEgKyB0cmltLmhlaWdodDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHcxID0gLWFuY2hvci5feCAqIG9yaWcud2lkdGg7XG4gICAgICAgICAgICB3MCA9IHcxICsgb3JpZy53aWR0aDtcblxuICAgICAgICAgICAgaDEgPSAtYW5jaG9yLl95ICogb3JpZy5oZWlnaHQ7XG4gICAgICAgICAgICBoMCA9IGgxICsgb3JpZy5oZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB4eVxuICAgICAgICB2ZXJ0ZXhEYXRhWzBdID0gYSAqIHcxICsgYyAqIGgxICsgdHg7XG4gICAgICAgIHZlcnRleERhdGFbMV0gPSBkICogaDEgKyBiICogdzEgKyB0eTtcblxuICAgICAgICAvLyB4eVxuICAgICAgICB2ZXJ0ZXhEYXRhWzJdID0gYSAqIHcwICsgYyAqIGgxICsgdHg7XG4gICAgICAgIHZlcnRleERhdGFbM10gPSBkICogaDEgKyBiICogdzAgKyB0eTtcblxuICAgICAgICAvLyB4eVxuICAgICAgICB2ZXJ0ZXhEYXRhWzRdID0gYSAqIHcwICsgYyAqIGgwICsgdHg7XG4gICAgICAgIHZlcnRleERhdGFbNV0gPSBkICogaDAgKyBiICogdzAgKyB0eTtcblxuICAgICAgICAvLyB4eVxuICAgICAgICB2ZXJ0ZXhEYXRhWzZdID0gYSAqIHcxICsgYyAqIGgwICsgdHg7XG4gICAgICAgIHZlcnRleERhdGFbN10gPSBkICogaDAgKyBiICogdzEgKyB0eTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogY2FsY3VsYXRlcyB3b3JsZFRyYW5zZm9ybSAqIHZlcnRpY2VzIGZvciBhIG5vbiB0ZXh0dXJlIHdpdGggYSB0cmltLiBzdG9yZSBpdCBpbiB2ZXJ0ZXhUcmltbWVkRGF0YVxuICAgICAqIFRoaXMgaXMgdXNlZCB0byBlbnN1cmUgdGhhdCB0aGUgdHJ1ZSB3aWR0aCBhbmQgaGVpZ2h0IG9mIGEgdHJpbW1lZCB0ZXh0dXJlIGlzIHJlc3BlY3RlZFxuICAgICAqL1xuXG5cbiAgICBTcHJpdGUucHJvdG90eXBlLmNhbGN1bGF0ZVRyaW1tZWRWZXJ0aWNlcyA9IGZ1bmN0aW9uIGNhbGN1bGF0ZVRyaW1tZWRWZXJ0aWNlcygpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZlcnRleFRyaW1tZWREYXRhKSB7XG4gICAgICAgICAgICB0aGlzLnZlcnRleFRyaW1tZWREYXRhID0gbmV3IEZsb2F0MzJBcnJheSg4KTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl90cmFuc2Zvcm1UcmltbWVkSUQgPT09IHRoaXMudHJhbnNmb3JtLl93b3JsZElEICYmIHRoaXMuX3RleHR1cmVUcmltbWVkSUQgPT09IHRoaXMuX3RleHR1cmUuX3VwZGF0ZUlEKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl90cmFuc2Zvcm1UcmltbWVkSUQgPSB0aGlzLnRyYW5zZm9ybS5fd29ybGRJRDtcbiAgICAgICAgdGhpcy5fdGV4dHVyZVRyaW1tZWRJRCA9IHRoaXMuX3RleHR1cmUuX3VwZGF0ZUlEO1xuXG4gICAgICAgIC8vIGxldHMgZG8gc29tZSBzcGVjaWFsIHRyaW0gY29kZSFcbiAgICAgICAgdmFyIHRleHR1cmUgPSB0aGlzLl90ZXh0dXJlO1xuICAgICAgICB2YXIgdmVydGV4RGF0YSA9IHRoaXMudmVydGV4VHJpbW1lZERhdGE7XG4gICAgICAgIHZhciBvcmlnID0gdGV4dHVyZS5vcmlnO1xuICAgICAgICB2YXIgYW5jaG9yID0gdGhpcy5fYW5jaG9yO1xuXG4gICAgICAgIC8vIGxldHMgY2FsY3VsYXRlIHRoZSBuZXcgdW50cmltbWVkIGJvdW5kcy4uXG4gICAgICAgIHZhciB3dCA9IHRoaXMudHJhbnNmb3JtLndvcmxkVHJhbnNmb3JtO1xuICAgICAgICB2YXIgYSA9IHd0LmE7XG4gICAgICAgIHZhciBiID0gd3QuYjtcbiAgICAgICAgdmFyIGMgPSB3dC5jO1xuICAgICAgICB2YXIgZCA9IHd0LmQ7XG4gICAgICAgIHZhciB0eCA9IHd0LnR4O1xuICAgICAgICB2YXIgdHkgPSB3dC50eTtcblxuICAgICAgICB2YXIgdzEgPSAtYW5jaG9yLl94ICogb3JpZy53aWR0aDtcbiAgICAgICAgdmFyIHcwID0gdzEgKyBvcmlnLndpZHRoO1xuXG4gICAgICAgIHZhciBoMSA9IC1hbmNob3IuX3kgKiBvcmlnLmhlaWdodDtcbiAgICAgICAgdmFyIGgwID0gaDEgKyBvcmlnLmhlaWdodDtcblxuICAgICAgICAvLyB4eVxuICAgICAgICB2ZXJ0ZXhEYXRhWzBdID0gYSAqIHcxICsgYyAqIGgxICsgdHg7XG4gICAgICAgIHZlcnRleERhdGFbMV0gPSBkICogaDEgKyBiICogdzEgKyB0eTtcblxuICAgICAgICAvLyB4eVxuICAgICAgICB2ZXJ0ZXhEYXRhWzJdID0gYSAqIHcwICsgYyAqIGgxICsgdHg7XG4gICAgICAgIHZlcnRleERhdGFbM10gPSBkICogaDEgKyBiICogdzAgKyB0eTtcblxuICAgICAgICAvLyB4eVxuICAgICAgICB2ZXJ0ZXhEYXRhWzRdID0gYSAqIHcwICsgYyAqIGgwICsgdHg7XG4gICAgICAgIHZlcnRleERhdGFbNV0gPSBkICogaDAgKyBiICogdzAgKyB0eTtcblxuICAgICAgICAvLyB4eVxuICAgICAgICB2ZXJ0ZXhEYXRhWzZdID0gYSAqIHcxICsgYyAqIGgwICsgdHg7XG4gICAgICAgIHZlcnRleERhdGFbN10gPSBkICogaDAgKyBiICogdzEgKyB0eTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgKlxuICAgICogUmVuZGVycyB0aGUgb2JqZWN0IHVzaW5nIHRoZSBXZWJHTCByZW5kZXJlclxuICAgICpcbiAgICAqIEBwcml2YXRlXG4gICAgKiBAcGFyYW0ge1BJWEkuV2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgd2ViZ2wgcmVuZGVyZXIgdG8gdXNlLlxuICAgICovXG5cblxuICAgIFNwcml0ZS5wcm90b3R5cGUuX3JlbmRlcldlYkdMID0gZnVuY3Rpb24gX3JlbmRlcldlYkdMKHJlbmRlcmVyKSB7XG4gICAgICAgIHRoaXMuY2FsY3VsYXRlVmVydGljZXMoKTtcblxuICAgICAgICByZW5kZXJlci5zZXRPYmplY3RSZW5kZXJlcihyZW5kZXJlci5wbHVnaW5zW3RoaXMucGx1Z2luTmFtZV0pO1xuICAgICAgICByZW5kZXJlci5wbHVnaW5zW3RoaXMucGx1Z2luTmFtZV0ucmVuZGVyKHRoaXMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAqIFJlbmRlcnMgdGhlIG9iamVjdCB1c2luZyB0aGUgQ2FudmFzIHJlbmRlcmVyXG4gICAgKlxuICAgICogQHByaXZhdGVcbiAgICAqIEBwYXJhbSB7UElYSS5DYW52YXNSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXJcbiAgICAqL1xuXG5cbiAgICBTcHJpdGUucHJvdG90eXBlLl9yZW5kZXJDYW52YXMgPSBmdW5jdGlvbiBfcmVuZGVyQ2FudmFzKHJlbmRlcmVyKSB7XG4gICAgICAgIHJlbmRlcmVyLnBsdWdpbnNbdGhpcy5wbHVnaW5OYW1lXS5yZW5kZXIodGhpcyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGJvdW5kcyBvZiB0aGUgc3ByaXRlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuXG4gICAgU3ByaXRlLnByb3RvdHlwZS5fY2FsY3VsYXRlQm91bmRzID0gZnVuY3Rpb24gX2NhbGN1bGF0ZUJvdW5kcygpIHtcbiAgICAgICAgdmFyIHRyaW0gPSB0aGlzLl90ZXh0dXJlLnRyaW07XG4gICAgICAgIHZhciBvcmlnID0gdGhpcy5fdGV4dHVyZS5vcmlnO1xuXG4gICAgICAgIC8vIEZpcnN0IGxldHMgY2hlY2sgdG8gc2VlIGlmIHRoZSBjdXJyZW50IHRleHR1cmUgaGFzIGEgdHJpbS4uXG4gICAgICAgIGlmICghdHJpbSB8fCB0cmltLndpZHRoID09PSBvcmlnLndpZHRoICYmIHRyaW0uaGVpZ2h0ID09PSBvcmlnLmhlaWdodCkge1xuICAgICAgICAgICAgLy8gbm8gdHJpbSEgbGV0cyB1c2UgdGhlIHVzdWFsIGNhbGN1bGF0aW9ucy4uXG4gICAgICAgICAgICB0aGlzLmNhbGN1bGF0ZVZlcnRpY2VzKCk7XG4gICAgICAgICAgICB0aGlzLl9ib3VuZHMuYWRkUXVhZCh0aGlzLnZlcnRleERhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gbGV0cyBjYWxjdWxhdGUgYSBzcGVjaWFsIHRyaW1tZWQgYm91bmRzLi4uXG4gICAgICAgICAgICB0aGlzLmNhbGN1bGF0ZVRyaW1tZWRWZXJ0aWNlcygpO1xuICAgICAgICAgICAgdGhpcy5fYm91bmRzLmFkZFF1YWQodGhpcy52ZXJ0ZXhUcmltbWVkRGF0YSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbG9jYWwgYm91bmRzIG9mIHRoZSBzcHJpdGUgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLlJlY3RhbmdsZX0gcmVjdCAtIFRoZSBvdXRwdXQgcmVjdGFuZ2xlLlxuICAgICAqIEByZXR1cm4ge1BJWEkuUmVjdGFuZ2xlfSBUaGUgYm91bmRzLlxuICAgICAqL1xuXG5cbiAgICBTcHJpdGUucHJvdG90eXBlLmdldExvY2FsQm91bmRzID0gZnVuY3Rpb24gZ2V0TG9jYWxCb3VuZHMocmVjdCkge1xuICAgICAgICAvLyB3ZSBjYW4gZG8gYSBmYXN0IGxvY2FsIGJvdW5kcyBpZiB0aGUgc3ByaXRlIGhhcyBubyBjaGlsZHJlbiFcbiAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9ib3VuZHMubWluWCA9IHRoaXMuX3RleHR1cmUub3JpZy53aWR0aCAqIC10aGlzLl9hbmNob3IuX3g7XG4gICAgICAgICAgICB0aGlzLl9ib3VuZHMubWluWSA9IHRoaXMuX3RleHR1cmUub3JpZy5oZWlnaHQgKiAtdGhpcy5fYW5jaG9yLl95O1xuICAgICAgICAgICAgdGhpcy5fYm91bmRzLm1heFggPSB0aGlzLl90ZXh0dXJlLm9yaWcud2lkdGggKiAoMSAtIHRoaXMuX2FuY2hvci5feCk7XG4gICAgICAgICAgICB0aGlzLl9ib3VuZHMubWF4WSA9IHRoaXMuX3RleHR1cmUub3JpZy5oZWlnaHQgKiAoMSAtIHRoaXMuX2FuY2hvci5feSk7XG5cbiAgICAgICAgICAgIGlmICghcmVjdCkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fbG9jYWxCb3VuZHNSZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvY2FsQm91bmRzUmVjdCA9IG5ldyBfbWF0aC5SZWN0YW5nbGUoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZWN0ID0gdGhpcy5fbG9jYWxCb3VuZHNSZWN0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYm91bmRzLmdldFJlY3RhbmdsZShyZWN0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBfQ29udGFpbmVyLnByb3RvdHlwZS5nZXRMb2NhbEJvdW5kcy5jYWxsKHRoaXMsIHJlY3QpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUZXN0cyBpZiBhIHBvaW50IGlzIGluc2lkZSB0aGlzIHNwcml0ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLlBvaW50fSBwb2ludCAtIHRoZSBwb2ludCB0byB0ZXN0XG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gdGhlIHJlc3VsdCBvZiB0aGUgdGVzdFxuICAgICAqL1xuXG5cbiAgICBTcHJpdGUucHJvdG90eXBlLmNvbnRhaW5zUG9pbnQgPSBmdW5jdGlvbiBjb250YWluc1BvaW50KHBvaW50KSB7XG4gICAgICAgIHRoaXMud29ybGRUcmFuc2Zvcm0uYXBwbHlJbnZlcnNlKHBvaW50LCB0ZW1wUG9pbnQpO1xuXG4gICAgICAgIHZhciB3aWR0aCA9IHRoaXMuX3RleHR1cmUub3JpZy53aWR0aDtcbiAgICAgICAgdmFyIGhlaWdodCA9IHRoaXMuX3RleHR1cmUub3JpZy5oZWlnaHQ7XG4gICAgICAgIHZhciB4MSA9IC13aWR0aCAqIHRoaXMuYW5jaG9yLng7XG4gICAgICAgIHZhciB5MSA9IDA7XG5cbiAgICAgICAgaWYgKHRlbXBQb2ludC54ID49IHgxICYmIHRlbXBQb2ludC54IDwgeDEgKyB3aWR0aCkge1xuICAgICAgICAgICAgeTEgPSAtaGVpZ2h0ICogdGhpcy5hbmNob3IueTtcblxuICAgICAgICAgICAgaWYgKHRlbXBQb2ludC55ID49IHkxICYmIHRlbXBQb2ludC55IDwgeTEgKyBoZWlnaHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGVzdHJveXMgdGhpcyBzcHJpdGUgYW5kIG9wdGlvbmFsbHkgaXRzIHRleHR1cmUgYW5kIGNoaWxkcmVuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdHxib29sZWFufSBbb3B0aW9uc10gLSBPcHRpb25zIHBhcmFtZXRlci4gQSBib29sZWFuIHdpbGwgYWN0IGFzIGlmIGFsbCBvcHRpb25zXG4gICAgICogIGhhdmUgYmVlbiBzZXQgdG8gdGhhdCB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY2hpbGRyZW49ZmFsc2VdIC0gaWYgc2V0IHRvIHRydWUsIGFsbCB0aGUgY2hpbGRyZW4gd2lsbCBoYXZlIHRoZWlyIGRlc3Ryb3lcbiAgICAgKiAgICAgIG1ldGhvZCBjYWxsZWQgYXMgd2VsbC4gJ29wdGlvbnMnIHdpbGwgYmUgcGFzc2VkIG9uIHRvIHRob3NlIGNhbGxzLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudGV4dHVyZT1mYWxzZV0gLSBTaG91bGQgaXQgZGVzdHJveSB0aGUgY3VycmVudCB0ZXh0dXJlIG9mIHRoZSBzcHJpdGUgYXMgd2VsbFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuYmFzZVRleHR1cmU9ZmFsc2VdIC0gU2hvdWxkIGl0IGRlc3Ryb3kgdGhlIGJhc2UgdGV4dHVyZSBvZiB0aGUgc3ByaXRlIGFzIHdlbGxcbiAgICAgKi9cblxuXG4gICAgU3ByaXRlLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveShvcHRpb25zKSB7XG4gICAgICAgIF9Db250YWluZXIucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICAgICAgICB0aGlzLl90ZXh0dXJlLm9mZigndXBkYXRlJywgdGhpcy5fb25UZXh0dXJlVXBkYXRlLCB0aGlzKTtcblxuICAgICAgICB0aGlzLl9hbmNob3IgPSBudWxsO1xuXG4gICAgICAgIHZhciBkZXN0cm95VGV4dHVyZSA9IHR5cGVvZiBvcHRpb25zID09PSAnYm9vbGVhbicgPyBvcHRpb25zIDogb3B0aW9ucyAmJiBvcHRpb25zLnRleHR1cmU7XG5cbiAgICAgICAgaWYgKGRlc3Ryb3lUZXh0dXJlKSB7XG4gICAgICAgICAgICB2YXIgZGVzdHJveUJhc2VUZXh0dXJlID0gdHlwZW9mIG9wdGlvbnMgPT09ICdib29sZWFuJyA/IG9wdGlvbnMgOiBvcHRpb25zICYmIG9wdGlvbnMuYmFzZVRleHR1cmU7XG5cbiAgICAgICAgICAgIHRoaXMuX3RleHR1cmUuZGVzdHJveSghIWRlc3Ryb3lCYXNlVGV4dHVyZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl90ZXh0dXJlID0gbnVsbDtcbiAgICAgICAgdGhpcy5zaGFkZXIgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBzb21lIGhlbHBlciBmdW5jdGlvbnMuLlxuXG4gICAgLyoqXG4gICAgICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyBhIG5ldyBzcHJpdGUgYmFzZWQgb24gdGhlIHNvdXJjZSB5b3UgcHJvdmlkZS5cbiAgICAgKiBUaGUgc291cmNlIGNhbiBiZSAtIGZyYW1lIGlkLCBpbWFnZSB1cmwsIHZpZGVvIHVybCwgY2FudmFzIGVsZW1lbnQsIHZpZGVvIGVsZW1lbnQsIGJhc2UgdGV4dHVyZVxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ3xQSVhJLkJhc2VUZXh0dXJlfEhUTUxDYW52YXNFbGVtZW50fEhUTUxWaWRlb0VsZW1lbnR9IHNvdXJjZSBTb3VyY2UgdG8gY3JlYXRlIHRleHR1cmUgZnJvbVxuICAgICAqIEByZXR1cm4ge1BJWEkuU3ByaXRlfSBUaGUgbmV3bHkgY3JlYXRlZCBzcHJpdGVcbiAgICAgKi9cblxuXG4gICAgU3ByaXRlLmZyb20gPSBmdW5jdGlvbiBmcm9tKHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gbmV3IFNwcml0ZShfVGV4dHVyZTIuZGVmYXVsdC5mcm9tKHNvdXJjZSkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIGEgc3ByaXRlIHRoYXQgd2lsbCBjb250YWluIGEgdGV4dHVyZSBmcm9tIHRoZSBUZXh0dXJlQ2FjaGUgYmFzZWQgb24gdGhlIGZyYW1lSWRcbiAgICAgKiBUaGUgZnJhbWUgaWRzIGFyZSBjcmVhdGVkIHdoZW4gYSBUZXh0dXJlIHBhY2tlciBmaWxlIGhhcyBiZWVuIGxvYWRlZFxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmcmFtZUlkIC0gVGhlIGZyYW1lIElkIG9mIHRoZSB0ZXh0dXJlIGluIHRoZSBjYWNoZVxuICAgICAqIEByZXR1cm4ge1BJWEkuU3ByaXRlfSBBIG5ldyBTcHJpdGUgdXNpbmcgYSB0ZXh0dXJlIGZyb20gdGhlIHRleHR1cmUgY2FjaGUgbWF0Y2hpbmcgdGhlIGZyYW1lSWRcbiAgICAgKi9cblxuXG4gICAgU3ByaXRlLmZyb21GcmFtZSA9IGZ1bmN0aW9uIGZyb21GcmFtZShmcmFtZUlkKSB7XG4gICAgICAgIHZhciB0ZXh0dXJlID0gX3V0aWxzLlRleHR1cmVDYWNoZVtmcmFtZUlkXTtcblxuICAgICAgICBpZiAoIXRleHR1cmUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGZyYW1lSWQgXCInICsgZnJhbWVJZCArICdcIiBkb2VzIG5vdCBleGlzdCBpbiB0aGUgdGV4dHVyZSBjYWNoZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBTcHJpdGUodGV4dHVyZSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgYSBzcHJpdGUgdGhhdCB3aWxsIGNvbnRhaW4gYSB0ZXh0dXJlIGJhc2VkIG9uIGFuIGltYWdlIHVybFxuICAgICAqIElmIHRoZSBpbWFnZSBpcyBub3QgaW4gdGhlIHRleHR1cmUgY2FjaGUgaXQgd2lsbCBiZSBsb2FkZWRcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaW1hZ2VJZCAtIFRoZSBpbWFnZSB1cmwgb2YgdGhlIHRleHR1cmVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtjcm9zc29yaWdpbj0oYXV0byldIC0gaWYgeW91IHdhbnQgdG8gc3BlY2lmeSB0aGUgY3Jvc3Mtb3JpZ2luIHBhcmFtZXRlclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc2NhbGVNb2RlPVBJWEkuc2V0dGluZ3MuU0NBTEVfTU9ERV0gLSBpZiB5b3Ugd2FudCB0byBzcGVjaWZ5IHRoZSBzY2FsZSBtb2RlLFxuICAgICAqICBzZWUge0BsaW5rIFBJWEkuU0NBTEVfTU9ERVN9IGZvciBwb3NzaWJsZSB2YWx1ZXNcbiAgICAgKiBAcmV0dXJuIHtQSVhJLlNwcml0ZX0gQSBuZXcgU3ByaXRlIHVzaW5nIGEgdGV4dHVyZSBmcm9tIHRoZSB0ZXh0dXJlIGNhY2hlIG1hdGNoaW5nIHRoZSBpbWFnZSBpZFxuICAgICAqL1xuXG5cbiAgICBTcHJpdGUuZnJvbUltYWdlID0gZnVuY3Rpb24gZnJvbUltYWdlKGltYWdlSWQsIGNyb3Nzb3JpZ2luLCBzY2FsZU1vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTcHJpdGUoX1RleHR1cmUyLmRlZmF1bHQuZnJvbUltYWdlKGltYWdlSWQsIGNyb3Nzb3JpZ2luLCBzY2FsZU1vZGUpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIHdpZHRoIG9mIHRoZSBzcHJpdGUsIHNldHRpbmcgdGhpcyB3aWxsIGFjdHVhbGx5IG1vZGlmeSB0aGUgc2NhbGUgdG8gYWNoaWV2ZSB0aGUgdmFsdWUgc2V0XG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICovXG5cblxuICAgIF9jcmVhdGVDbGFzcyhTcHJpdGUsIFt7XG4gICAgICAgIGtleTogJ3dpZHRoJyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5hYnModGhpcy5zY2FsZS54KSAqIHRoaXMuX3RleHR1cmUub3JpZy53aWR0aDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcmVxdWlyZS1qc2RvY1xuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgcyA9ICgwLCBfdXRpbHMuc2lnbikodGhpcy5zY2FsZS54KSB8fCAxO1xuXG4gICAgICAgICAgICB0aGlzLnNjYWxlLnggPSBzICogdmFsdWUgLyB0aGlzLl90ZXh0dXJlLm9yaWcud2lkdGg7XG4gICAgICAgICAgICB0aGlzLl93aWR0aCA9IHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBoZWlnaHQgb2YgdGhlIHNwcml0ZSwgc2V0dGluZyB0aGlzIHdpbGwgYWN0dWFsbHkgbW9kaWZ5IHRoZSBzY2FsZSB0byBhY2hpZXZlIHRoZSB2YWx1ZSBzZXRcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnaGVpZ2h0JyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5hYnModGhpcy5zY2FsZS55KSAqIHRoaXMuX3RleHR1cmUub3JpZy5oZWlnaHQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlcXVpcmUtanNkb2NcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIHMgPSAoMCwgX3V0aWxzLnNpZ24pKHRoaXMuc2NhbGUueSkgfHwgMTtcblxuICAgICAgICAgICAgdGhpcy5zY2FsZS55ID0gcyAqIHZhbHVlIC8gdGhpcy5fdGV4dHVyZS5vcmlnLmhlaWdodDtcbiAgICAgICAgICAgIHRoaXMuX2hlaWdodCA9IHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBhbmNob3Igc2V0cyB0aGUgb3JpZ2luIHBvaW50IG9mIHRoZSB0ZXh0dXJlLlxuICAgICAgICAgKiBUaGUgZGVmYXVsdCBpcyAwLDAgb3IgdGFrZW4gZnJvbSB0aGUge0BsaW5rIFBJWEkuVGV4dHVyZXxUZXh0dXJlfSBwYXNzZWQgdG8gdGhlIGNvbnN0cnVjdG9yLlxuICAgICAgICAgKiBTZXR0aW5nIHRoZSB0ZXh0dXJlIGF0IGEgbGF0ZXIgcG9pbnQgb2YgdGltZSBkb2VzIG5vdCBjaGFuZ2UgdGhlIGFuY2hvci5cbiAgICAgICAgICpcbiAgICAgICAgICogMCwwIG1lYW5zIHRoZSB0ZXh0dXJlJ3Mgb3JpZ2luIGlzIHRoZSB0b3AgbGVmdCwgMC41LDAuNSBpcyB0aGUgY2VudGVyLCAxLDEgdGhlIGJvdHRvbSByaWdodCBjb3JuZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuT2JzZXJ2YWJsZVBvaW50fVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnYW5jaG9yJyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYW5jaG9yO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSByZXF1aXJlLWpzZG9jXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX2FuY2hvci5jb3B5KHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdGludCBhcHBsaWVkIHRvIHRoZSBzcHJpdGUuIFRoaXMgaXMgYSBoZXggdmFsdWUuXG4gICAgICAgICAqIEEgdmFsdWUgb2YgMHhGRkZGRkYgd2lsbCByZW1vdmUgYW55IHRpbnQgZWZmZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDB4RkZGRkZGXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICd0aW50JyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGludDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcmVxdWlyZS1qc2RvY1xuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl90aW50ID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLl90aW50UkdCID0gKHZhbHVlID4+IDE2KSArICh2YWx1ZSAmIDB4ZmYwMCkgKyAoKHZhbHVlICYgMHhmZikgPDwgMTYpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0ZXh0dXJlIHRoYXQgdGhlIHNwcml0ZSBpcyB1c2luZ1xuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLlRleHR1cmV9XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICd0ZXh0dXJlJyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGV4dHVyZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcmVxdWlyZS1qc2RvY1xuICAgICAgICB7XG4gICAgICAgICAgICBpZiAodGhpcy5fdGV4dHVyZSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX3RleHR1cmUgPSB2YWx1ZSB8fCBfVGV4dHVyZTIuZGVmYXVsdC5FTVBUWTtcbiAgICAgICAgICAgIHRoaXMuY2FjaGVkVGludCA9IDB4RkZGRkZGO1xuXG4gICAgICAgICAgICB0aGlzLl90ZXh0dXJlSUQgPSAtMTtcbiAgICAgICAgICAgIHRoaXMuX3RleHR1cmVUcmltbWVkSUQgPSAtMTtcblxuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgLy8gd2FpdCBmb3IgdGhlIHRleHR1cmUgdG8gbG9hZFxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5iYXNlVGV4dHVyZS5oYXNMb2FkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb25UZXh0dXJlVXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUub25jZSgndXBkYXRlJywgdGhpcy5fb25UZXh0dXJlVXBkYXRlLCB0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gU3ByaXRlO1xufShfQ29udGFpbmVyMy5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gU3ByaXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3ByaXRlLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9DYW52YXNSZW5kZXJlciA9IHJlcXVpcmUoJy4uLy4uL3JlbmRlcmVycy9jYW52YXMvQ2FudmFzUmVuZGVyZXInKTtcblxudmFyIF9DYW52YXNSZW5kZXJlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9DYW52YXNSZW5kZXJlcik7XG5cbnZhciBfY29uc3QgPSByZXF1aXJlKCcuLi8uLi9jb25zdCcpO1xuXG52YXIgX21hdGggPSByZXF1aXJlKCcuLi8uLi9tYXRoJyk7XG5cbnZhciBfQ2FudmFzVGludGVyID0gcmVxdWlyZSgnLi9DYW52YXNUaW50ZXInKTtcblxudmFyIF9DYW52YXNUaW50ZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQ2FudmFzVGludGVyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIGNhbnZhc1JlbmRlcldvcmxkVHJhbnNmb3JtID0gbmV3IF9tYXRoLk1hdHJpeCgpO1xuXG4vKipcbiAqIEBhdXRob3IgTWF0IEdyb3Zlc1xuICpcbiAqIEJpZyB0aGFua3MgdG8gdGhlIHZlcnkgY2xldmVyIE1hdHQgRGVzTGF1cmllcnMgPG1hdHRkZXNsPiBodHRwczovL2dpdGh1Yi5jb20vbWF0dGRlc2wvXG4gKiBmb3IgY3JlYXRpbmcgdGhlIG9yaWdpbmFsIFBpeGlKUyB2ZXJzaW9uIVxuICogQWxzbyBhIHRoYW5rcyB0byBodHRwczovL2dpdGh1Yi5jb20vYmNoZXZhbGllciBmb3IgdHdlYWtpbmcgdGhlIHRpbnQgYW5kIGFscGhhIHNvIHRoYXQgdGhleSBub3dcbiAqIHNoYXJlIDQgYnl0ZXMgb24gdGhlIHZlcnRleCBidWZmZXJcbiAqXG4gKiBIZWF2aWx5IGluc3BpcmVkIGJ5IExpYkdEWCdzIENhbnZhc1Nwcml0ZVJlbmRlcmVyOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2xpYmdkeC9saWJnZHgvYmxvYi9tYXN0ZXIvZ2R4L3NyYy9jb20vYmFkbG9naWMvZ2R4L2dyYXBoaWNzL2cyZC9DYW52YXNTcHJpdGVSZW5kZXJlci5qYXZhXG4gKi9cblxuLyoqXG4gKiBSZW5kZXJlciBkZWRpY2F0ZWQgdG8gZHJhd2luZyBhbmQgYmF0Y2hpbmcgc3ByaXRlcy5cbiAqXG4gKiBAY2xhc3NcbiAqIEBwcml2YXRlXG4gKiBAbWVtYmVyb2YgUElYSVxuICovXG5cbnZhciBDYW52YXNTcHJpdGVSZW5kZXJlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1BJWEkuV2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLVRoZSByZW5kZXJlciBzcHJpdGUgdGhpcyBiYXRjaCB3b3JrcyBmb3IuXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ2FudmFzU3ByaXRlUmVuZGVyZXIocmVuZGVyZXIpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENhbnZhc1Nwcml0ZVJlbmRlcmVyKTtcblxuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0aGUgc3ByaXRlIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5TcHJpdGV9IHNwcml0ZSAtIHRoZSBzcHJpdGUgdG8gcmVuZGVyIHdoZW4gdXNpbmcgdGhpcyBzcHJpdGViYXRjaFxuICAgICAqL1xuXG5cbiAgICBDYW52YXNTcHJpdGVSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKHNwcml0ZSkge1xuICAgICAgICB2YXIgdGV4dHVyZSA9IHNwcml0ZS5fdGV4dHVyZTtcbiAgICAgICAgdmFyIHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcjtcblxuICAgICAgICB2YXIgd2lkdGggPSB0ZXh0dXJlLl9mcmFtZS53aWR0aDtcbiAgICAgICAgdmFyIGhlaWdodCA9IHRleHR1cmUuX2ZyYW1lLmhlaWdodDtcblxuICAgICAgICB2YXIgd3QgPSBzcHJpdGUudHJhbnNmb3JtLndvcmxkVHJhbnNmb3JtO1xuICAgICAgICB2YXIgZHggPSAwO1xuICAgICAgICB2YXIgZHkgPSAwO1xuXG4gICAgICAgIGlmICh0ZXh0dXJlLm9yaWcud2lkdGggPD0gMCB8fCB0ZXh0dXJlLm9yaWcuaGVpZ2h0IDw9IDAgfHwgIXRleHR1cmUuYmFzZVRleHR1cmUuc291cmNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICByZW5kZXJlci5zZXRCbGVuZE1vZGUoc3ByaXRlLmJsZW5kTW9kZSk7XG5cbiAgICAgICAgLy8gIElnbm9yZSBudWxsIHNvdXJjZXNcbiAgICAgICAgaWYgKHRleHR1cmUudmFsaWQpIHtcbiAgICAgICAgICAgIHJlbmRlcmVyLmNvbnRleHQuZ2xvYmFsQWxwaGEgPSBzcHJpdGUud29ybGRBbHBoYTtcblxuICAgICAgICAgICAgLy8gSWYgc21vb3RoaW5nRW5hYmxlZCBpcyBzdXBwb3J0ZWQgYW5kIHdlIG5lZWQgdG8gY2hhbmdlIHRoZSBzbW9vdGhpbmcgcHJvcGVydHkgZm9yIHNwcml0ZSB0ZXh0dXJlXG4gICAgICAgICAgICB2YXIgc21vb3RoaW5nRW5hYmxlZCA9IHRleHR1cmUuYmFzZVRleHR1cmUuc2NhbGVNb2RlID09PSBfY29uc3QuU0NBTEVfTU9ERVMuTElORUFSO1xuXG4gICAgICAgICAgICBpZiAocmVuZGVyZXIuc21vb3RoUHJvcGVydHkgJiYgcmVuZGVyZXIuY29udGV4dFtyZW5kZXJlci5zbW9vdGhQcm9wZXJ0eV0gIT09IHNtb290aGluZ0VuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICByZW5kZXJlci5jb250ZXh0W3JlbmRlcmVyLnNtb290aFByb3BlcnR5XSA9IHNtb290aGluZ0VuYWJsZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0ZXh0dXJlLnRyaW0pIHtcbiAgICAgICAgICAgICAgICBkeCA9IHRleHR1cmUudHJpbS53aWR0aCAvIDIgKyB0ZXh0dXJlLnRyaW0ueCAtIHNwcml0ZS5hbmNob3IueCAqIHRleHR1cmUub3JpZy53aWR0aDtcbiAgICAgICAgICAgICAgICBkeSA9IHRleHR1cmUudHJpbS5oZWlnaHQgLyAyICsgdGV4dHVyZS50cmltLnkgLSBzcHJpdGUuYW5jaG9yLnkgKiB0ZXh0dXJlLm9yaWcuaGVpZ2h0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkeCA9ICgwLjUgLSBzcHJpdGUuYW5jaG9yLngpICogdGV4dHVyZS5vcmlnLndpZHRoO1xuICAgICAgICAgICAgICAgIGR5ID0gKDAuNSAtIHNwcml0ZS5hbmNob3IueSkgKiB0ZXh0dXJlLm9yaWcuaGVpZ2h0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGV4dHVyZS5yb3RhdGUpIHtcbiAgICAgICAgICAgICAgICB3dC5jb3B5KGNhbnZhc1JlbmRlcldvcmxkVHJhbnNmb3JtKTtcbiAgICAgICAgICAgICAgICB3dCA9IGNhbnZhc1JlbmRlcldvcmxkVHJhbnNmb3JtO1xuICAgICAgICAgICAgICAgIF9tYXRoLkdyb3VwRDgubWF0cml4QXBwZW5kUm90YXRpb25JbnYod3QsIHRleHR1cmUucm90YXRlLCBkeCwgZHkpO1xuICAgICAgICAgICAgICAgIC8vIHRoZSBhbmNob3IgaGFzIGFscmVhZHkgYmVlbiBhcHBsaWVkIGFib3ZlLCBzbyBsZXRzIHNldCBpdCB0byB6ZXJvXG4gICAgICAgICAgICAgICAgZHggPSAwO1xuICAgICAgICAgICAgICAgIGR5ID0gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZHggLT0gd2lkdGggLyAyO1xuICAgICAgICAgICAgZHkgLT0gaGVpZ2h0IC8gMjtcblxuICAgICAgICAgICAgLy8gQWxsb3cgZm9yIHBpeGVsIHJvdW5kaW5nXG4gICAgICAgICAgICBpZiAocmVuZGVyZXIucm91bmRQaXhlbHMpIHtcbiAgICAgICAgICAgICAgICByZW5kZXJlci5jb250ZXh0LnNldFRyYW5zZm9ybSh3dC5hLCB3dC5iLCB3dC5jLCB3dC5kLCB3dC50eCAqIHJlbmRlcmVyLnJlc29sdXRpb24gfCAwLCB3dC50eSAqIHJlbmRlcmVyLnJlc29sdXRpb24gfCAwKTtcblxuICAgICAgICAgICAgICAgIGR4ID0gZHggfCAwO1xuICAgICAgICAgICAgICAgIGR5ID0gZHkgfCAwO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZW5kZXJlci5jb250ZXh0LnNldFRyYW5zZm9ybSh3dC5hLCB3dC5iLCB3dC5jLCB3dC5kLCB3dC50eCAqIHJlbmRlcmVyLnJlc29sdXRpb24sIHd0LnR5ICogcmVuZGVyZXIucmVzb2x1dGlvbik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciByZXNvbHV0aW9uID0gdGV4dHVyZS5iYXNlVGV4dHVyZS5yZXNvbHV0aW9uO1xuXG4gICAgICAgICAgICBpZiAoc3ByaXRlLnRpbnQgIT09IDB4RkZGRkZGKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNwcml0ZS5jYWNoZWRUaW50ICE9PSBzcHJpdGUudGludCB8fCBzcHJpdGUudGludGVkVGV4dHVyZS50aW50SWQgIT09IHNwcml0ZS5fdGV4dHVyZS5fdXBkYXRlSUQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3ByaXRlLmNhY2hlZFRpbnQgPSBzcHJpdGUudGludDtcblxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIGNsZWFuIHVwIGNhY2hpbmcgLSBob3cgdG8gY2xlYW4gdXAgdGhlIGNhY2hlcz9cbiAgICAgICAgICAgICAgICAgICAgc3ByaXRlLnRpbnRlZFRleHR1cmUgPSBfQ2FudmFzVGludGVyMi5kZWZhdWx0LmdldFRpbnRlZFRleHR1cmUoc3ByaXRlLCBzcHJpdGUudGludCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmVuZGVyZXIuY29udGV4dC5kcmF3SW1hZ2Uoc3ByaXRlLnRpbnRlZFRleHR1cmUsIDAsIDAsIHdpZHRoICogcmVzb2x1dGlvbiwgaGVpZ2h0ICogcmVzb2x1dGlvbiwgZHggKiByZW5kZXJlci5yZXNvbHV0aW9uLCBkeSAqIHJlbmRlcmVyLnJlc29sdXRpb24sIHdpZHRoICogcmVuZGVyZXIucmVzb2x1dGlvbiwgaGVpZ2h0ICogcmVuZGVyZXIucmVzb2x1dGlvbik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlbmRlcmVyLmNvbnRleHQuZHJhd0ltYWdlKHRleHR1cmUuYmFzZVRleHR1cmUuc291cmNlLCB0ZXh0dXJlLl9mcmFtZS54ICogcmVzb2x1dGlvbiwgdGV4dHVyZS5fZnJhbWUueSAqIHJlc29sdXRpb24sIHdpZHRoICogcmVzb2x1dGlvbiwgaGVpZ2h0ICogcmVzb2x1dGlvbiwgZHggKiByZW5kZXJlci5yZXNvbHV0aW9uLCBkeSAqIHJlbmRlcmVyLnJlc29sdXRpb24sIHdpZHRoICogcmVuZGVyZXIucmVzb2x1dGlvbiwgaGVpZ2h0ICogcmVuZGVyZXIucmVzb2x1dGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogZGVzdHJveSB0aGUgc3ByaXRlIG9iamVjdC5cbiAgICAgKlxuICAgICAqL1xuXG5cbiAgICBDYW52YXNTcHJpdGVSZW5kZXJlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSBudWxsO1xuICAgIH07XG5cbiAgICByZXR1cm4gQ2FudmFzU3ByaXRlUmVuZGVyZXI7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IENhbnZhc1Nwcml0ZVJlbmRlcmVyO1xuXG5cbl9DYW52YXNSZW5kZXJlcjIuZGVmYXVsdC5yZWdpc3RlclBsdWdpbignc3ByaXRlJywgQ2FudmFzU3ByaXRlUmVuZGVyZXIpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2FudmFzU3ByaXRlUmVuZGVyZXIuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3V0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMnKTtcblxudmFyIF9jYW5Vc2VOZXdDYW52YXNCbGVuZE1vZGVzID0gcmVxdWlyZSgnLi4vLi4vcmVuZGVyZXJzL2NhbnZhcy91dGlscy9jYW5Vc2VOZXdDYW52YXNCbGVuZE1vZGVzJyk7XG5cbnZhciBfY2FuVXNlTmV3Q2FudmFzQmxlbmRNb2RlczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jYW5Vc2VOZXdDYW52YXNCbGVuZE1vZGVzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLyoqXG4gKiBVdGlsaXR5IG1ldGhvZHMgZm9yIFNwcml0ZS9UZXh0dXJlIHRpbnRpbmcuXG4gKlxuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgUElYSVxuICovXG52YXIgQ2FudmFzVGludGVyID0ge1xuICAgIC8qKlxuICAgICAqIEJhc2ljYWxseSB0aGlzIG1ldGhvZCBqdXN0IG5lZWRzIGEgc3ByaXRlIGFuZCBhIGNvbG9yIGFuZCB0aW50cyB0aGUgc3ByaXRlIHdpdGggdGhlIGdpdmVuIGNvbG9yLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIFBJWEkuQ2FudmFzVGludGVyXG4gICAgICogQHBhcmFtIHtQSVhJLlNwcml0ZX0gc3ByaXRlIC0gdGhlIHNwcml0ZSB0byB0aW50XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbG9yIC0gdGhlIGNvbG9yIHRvIHVzZSB0byB0aW50IHRoZSBzcHJpdGUgd2l0aFxuICAgICAqIEByZXR1cm4ge0hUTUxDYW52YXNFbGVtZW50fSBUaGUgdGludGVkIGNhbnZhc1xuICAgICAqL1xuICAgIGdldFRpbnRlZFRleHR1cmU6IGZ1bmN0aW9uIGdldFRpbnRlZFRleHR1cmUoc3ByaXRlLCBjb2xvcikge1xuICAgICAgICB2YXIgdGV4dHVyZSA9IHNwcml0ZS5fdGV4dHVyZTtcblxuICAgICAgICBjb2xvciA9IENhbnZhc1RpbnRlci5yb3VuZENvbG9yKGNvbG9yKTtcblxuICAgICAgICB2YXIgc3RyaW5nQ29sb3IgPSAnIycgKyAoJzAwMDAwJyArIChjb2xvciB8IDApLnRvU3RyaW5nKDE2KSkuc3Vic3RyKC02KTtcblxuICAgICAgICB0ZXh0dXJlLnRpbnRDYWNoZSA9IHRleHR1cmUudGludENhY2hlIHx8IHt9O1xuXG4gICAgICAgIHZhciBjYWNoZWRUZXh0dXJlID0gdGV4dHVyZS50aW50Q2FjaGVbc3RyaW5nQ29sb3JdO1xuXG4gICAgICAgIHZhciBjYW52YXMgPSB2b2lkIDA7XG5cbiAgICAgICAgaWYgKGNhY2hlZFRleHR1cmUpIHtcbiAgICAgICAgICAgIGlmIChjYWNoZWRUZXh0dXJlLnRpbnRJZCA9PT0gdGV4dHVyZS5fdXBkYXRlSUQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGV4dHVyZS50aW50Q2FjaGVbc3RyaW5nQ29sb3JdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYW52YXMgPSB0ZXh0dXJlLnRpbnRDYWNoZVtzdHJpbmdDb2xvcl07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYW52YXMgPSBDYW52YXNUaW50ZXIuY2FudmFzIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICB9XG5cbiAgICAgICAgQ2FudmFzVGludGVyLnRpbnRNZXRob2QodGV4dHVyZSwgY29sb3IsIGNhbnZhcyk7XG5cbiAgICAgICAgY2FudmFzLnRpbnRJZCA9IHRleHR1cmUuX3VwZGF0ZUlEO1xuXG4gICAgICAgIGlmIChDYW52YXNUaW50ZXIuY29udmVydFRpbnRUb0ltYWdlKSB7XG4gICAgICAgICAgICAvLyBpcyB0aGlzIGJldHRlcj9cbiAgICAgICAgICAgIHZhciB0aW50SW1hZ2UgPSBuZXcgSW1hZ2UoKTtcblxuICAgICAgICAgICAgdGludEltYWdlLnNyYyA9IGNhbnZhcy50b0RhdGFVUkwoKTtcblxuICAgICAgICAgICAgdGV4dHVyZS50aW50Q2FjaGVbc3RyaW5nQ29sb3JdID0gdGludEltYWdlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGV4dHVyZS50aW50Q2FjaGVbc3RyaW5nQ29sb3JdID0gY2FudmFzO1xuICAgICAgICAgICAgLy8gaWYgd2UgYXJlIG5vdCBjb252ZXJ0aW5nIHRoZSB0ZXh0dXJlIHRvIGFuIGltYWdlIHRoZW4gd2UgbmVlZCB0byBsb3NlIHRoZSByZWZlcmVuY2UgdG8gdGhlIGNhbnZhc1xuICAgICAgICAgICAgQ2FudmFzVGludGVyLmNhbnZhcyA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2FudmFzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaW50IGEgdGV4dHVyZSB1c2luZyB0aGUgJ211bHRpcGx5JyBvcGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgUElYSS5DYW52YXNUaW50ZXJcbiAgICAgKiBAcGFyYW0ge1BJWEkuVGV4dHVyZX0gdGV4dHVyZSAtIHRoZSB0ZXh0dXJlIHRvIHRpbnRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sb3IgLSB0aGUgY29sb3IgdG8gdXNlIHRvIHRpbnQgdGhlIHNwcml0ZSB3aXRoXG4gICAgICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzIC0gdGhlIGN1cnJlbnQgY2FudmFzXG4gICAgICovXG4gICAgdGludFdpdGhNdWx0aXBseTogZnVuY3Rpb24gdGludFdpdGhNdWx0aXBseSh0ZXh0dXJlLCBjb2xvciwgY2FudmFzKSB7XG4gICAgICAgIHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIHZhciBjcm9wID0gdGV4dHVyZS5fZnJhbWUuY2xvbmUoKTtcbiAgICAgICAgdmFyIHJlc29sdXRpb24gPSB0ZXh0dXJlLmJhc2VUZXh0dXJlLnJlc29sdXRpb247XG5cbiAgICAgICAgY3JvcC54ICo9IHJlc29sdXRpb247XG4gICAgICAgIGNyb3AueSAqPSByZXNvbHV0aW9uO1xuICAgICAgICBjcm9wLndpZHRoICo9IHJlc29sdXRpb247XG4gICAgICAgIGNyb3AuaGVpZ2h0ICo9IHJlc29sdXRpb247XG5cbiAgICAgICAgY2FudmFzLndpZHRoID0gTWF0aC5jZWlsKGNyb3Aud2lkdGgpO1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gTWF0aC5jZWlsKGNyb3AuaGVpZ2h0KTtcblxuICAgICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSAnIycgKyAoJzAwMDAwJyArIChjb2xvciB8IDApLnRvU3RyaW5nKDE2KSkuc3Vic3RyKC02KTtcblxuICAgICAgICBjb250ZXh0LmZpbGxSZWN0KDAsIDAsIGNyb3Aud2lkdGgsIGNyb3AuaGVpZ2h0KTtcblxuICAgICAgICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdtdWx0aXBseSc7XG5cbiAgICAgICAgY29udGV4dC5kcmF3SW1hZ2UodGV4dHVyZS5iYXNlVGV4dHVyZS5zb3VyY2UsIGNyb3AueCwgY3JvcC55LCBjcm9wLndpZHRoLCBjcm9wLmhlaWdodCwgMCwgMCwgY3JvcC53aWR0aCwgY3JvcC5oZWlnaHQpO1xuXG4gICAgICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2Rlc3RpbmF0aW9uLWF0b3AnO1xuXG4gICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKHRleHR1cmUuYmFzZVRleHR1cmUuc291cmNlLCBjcm9wLngsIGNyb3AueSwgY3JvcC53aWR0aCwgY3JvcC5oZWlnaHQsIDAsIDAsIGNyb3Aud2lkdGgsIGNyb3AuaGVpZ2h0KTtcbiAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRpbnQgYSB0ZXh0dXJlIHVzaW5nIHRoZSAnb3ZlcmxheScgb3BlcmF0aW9uLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIFBJWEkuQ2FudmFzVGludGVyXG4gICAgICogQHBhcmFtIHtQSVhJLlRleHR1cmV9IHRleHR1cmUgLSB0aGUgdGV4dHVyZSB0byB0aW50XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbG9yIC0gdGhlIGNvbG9yIHRvIHVzZSB0byB0aW50IHRoZSBzcHJpdGUgd2l0aFxuICAgICAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhcyAtIHRoZSBjdXJyZW50IGNhbnZhc1xuICAgICAqL1xuICAgIHRpbnRXaXRoT3ZlcmxheTogZnVuY3Rpb24gdGludFdpdGhPdmVybGF5KHRleHR1cmUsIGNvbG9yLCBjYW52YXMpIHtcbiAgICAgICAgdmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgdmFyIGNyb3AgPSB0ZXh0dXJlLl9mcmFtZS5jbG9uZSgpO1xuICAgICAgICB2YXIgcmVzb2x1dGlvbiA9IHRleHR1cmUuYmFzZVRleHR1cmUucmVzb2x1dGlvbjtcblxuICAgICAgICBjcm9wLnggKj0gcmVzb2x1dGlvbjtcbiAgICAgICAgY3JvcC55ICo9IHJlc29sdXRpb247XG4gICAgICAgIGNyb3Aud2lkdGggKj0gcmVzb2x1dGlvbjtcbiAgICAgICAgY3JvcC5oZWlnaHQgKj0gcmVzb2x1dGlvbjtcblxuICAgICAgICBjYW52YXMud2lkdGggPSBNYXRoLmNlaWwoY3JvcC53aWR0aCk7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBNYXRoLmNlaWwoY3JvcC5oZWlnaHQpO1xuXG4gICAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdjb3B5JztcbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSAnIycgKyAoJzAwMDAwJyArIChjb2xvciB8IDApLnRvU3RyaW5nKDE2KSkuc3Vic3RyKC02KTtcbiAgICAgICAgY29udGV4dC5maWxsUmVjdCgwLCAwLCBjcm9wLndpZHRoLCBjcm9wLmhlaWdodCk7XG5cbiAgICAgICAgY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnZGVzdGluYXRpb24tYXRvcCc7XG4gICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKHRleHR1cmUuYmFzZVRleHR1cmUuc291cmNlLCBjcm9wLngsIGNyb3AueSwgY3JvcC53aWR0aCwgY3JvcC5oZWlnaHQsIDAsIDAsIGNyb3Aud2lkdGgsIGNyb3AuaGVpZ2h0KTtcblxuICAgICAgICAvLyBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdjb3B5JztcbiAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogVGludCBhIHRleHR1cmUgcGl4ZWwgcGVyIHBpeGVsLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIFBJWEkuQ2FudmFzVGludGVyXG4gICAgICogQHBhcmFtIHtQSVhJLlRleHR1cmV9IHRleHR1cmUgLSB0aGUgdGV4dHVyZSB0byB0aW50XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbG9yIC0gdGhlIGNvbG9yIHRvIHVzZSB0byB0aW50IHRoZSBzcHJpdGUgd2l0aFxuICAgICAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhcyAtIHRoZSBjdXJyZW50IGNhbnZhc1xuICAgICAqL1xuICAgIHRpbnRXaXRoUGVyUGl4ZWw6IGZ1bmN0aW9uIHRpbnRXaXRoUGVyUGl4ZWwodGV4dHVyZSwgY29sb3IsIGNhbnZhcykge1xuICAgICAgICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICB2YXIgY3JvcCA9IHRleHR1cmUuX2ZyYW1lLmNsb25lKCk7XG4gICAgICAgIHZhciByZXNvbHV0aW9uID0gdGV4dHVyZS5iYXNlVGV4dHVyZS5yZXNvbHV0aW9uO1xuXG4gICAgICAgIGNyb3AueCAqPSByZXNvbHV0aW9uO1xuICAgICAgICBjcm9wLnkgKj0gcmVzb2x1dGlvbjtcbiAgICAgICAgY3JvcC53aWR0aCAqPSByZXNvbHV0aW9uO1xuICAgICAgICBjcm9wLmhlaWdodCAqPSByZXNvbHV0aW9uO1xuXG4gICAgICAgIGNhbnZhcy53aWR0aCA9IE1hdGguY2VpbChjcm9wLndpZHRoKTtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IE1hdGguY2VpbChjcm9wLmhlaWdodCk7XG5cbiAgICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2NvcHknO1xuICAgICAgICBjb250ZXh0LmRyYXdJbWFnZSh0ZXh0dXJlLmJhc2VUZXh0dXJlLnNvdXJjZSwgY3JvcC54LCBjcm9wLnksIGNyb3Aud2lkdGgsIGNyb3AuaGVpZ2h0LCAwLCAwLCBjcm9wLndpZHRoLCBjcm9wLmhlaWdodCk7XG4gICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuXG4gICAgICAgIHZhciByZ2JWYWx1ZXMgPSAoMCwgX3V0aWxzLmhleDJyZ2IpKGNvbG9yKTtcbiAgICAgICAgdmFyIHIgPSByZ2JWYWx1ZXNbMF07XG4gICAgICAgIHZhciBnID0gcmdiVmFsdWVzWzFdO1xuICAgICAgICB2YXIgYiA9IHJnYlZhbHVlc1syXTtcblxuICAgICAgICB2YXIgcGl4ZWxEYXRhID0gY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgY3JvcC53aWR0aCwgY3JvcC5oZWlnaHQpO1xuXG4gICAgICAgIHZhciBwaXhlbHMgPSBwaXhlbERhdGEuZGF0YTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBpeGVscy5sZW5ndGg7IGkgKz0gNCkge1xuICAgICAgICAgICAgcGl4ZWxzW2kgKyAwXSAqPSByO1xuICAgICAgICAgICAgcGl4ZWxzW2kgKyAxXSAqPSBnO1xuICAgICAgICAgICAgcGl4ZWxzW2kgKyAyXSAqPSBiO1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5wdXRJbWFnZURhdGEocGl4ZWxEYXRhLCAwLCAwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUm91bmRzIHRoZSBzcGVjaWZpZWQgY29sb3IgYWNjb3JkaW5nIHRvIHRoZSBDYW52YXNUaW50ZXIuY2FjaGVTdGVwc1BlckNvbG9yQ2hhbm5lbC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBQSVhJLkNhbnZhc1RpbnRlclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2xvciAtIHRoZSBjb2xvciB0byByb3VuZCwgc2hvdWxkIGJlIGEgaGV4IGNvbG9yXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgcm91bmRlZCBjb2xvci5cbiAgICAgKi9cbiAgICByb3VuZENvbG9yOiBmdW5jdGlvbiByb3VuZENvbG9yKGNvbG9yKSB7XG4gICAgICAgIHZhciBzdGVwID0gQ2FudmFzVGludGVyLmNhY2hlU3RlcHNQZXJDb2xvckNoYW5uZWw7XG5cbiAgICAgICAgdmFyIHJnYlZhbHVlcyA9ICgwLCBfdXRpbHMuaGV4MnJnYikoY29sb3IpO1xuXG4gICAgICAgIHJnYlZhbHVlc1swXSA9IE1hdGgubWluKDI1NSwgcmdiVmFsdWVzWzBdIC8gc3RlcCAqIHN0ZXApO1xuICAgICAgICByZ2JWYWx1ZXNbMV0gPSBNYXRoLm1pbigyNTUsIHJnYlZhbHVlc1sxXSAvIHN0ZXAgKiBzdGVwKTtcbiAgICAgICAgcmdiVmFsdWVzWzJdID0gTWF0aC5taW4oMjU1LCByZ2JWYWx1ZXNbMl0gLyBzdGVwICogc3RlcCk7XG5cbiAgICAgICAgcmV0dXJuICgwLCBfdXRpbHMucmdiMmhleCkocmdiVmFsdWVzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTnVtYmVyIG9mIHN0ZXBzIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhIGNhcCB3aGVuIHJvdW5kaW5nIGNvbG9ycy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBQSVhJLkNhbnZhc1RpbnRlclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgY2FjaGVTdGVwc1BlckNvbG9yQ2hhbm5lbDogOCxcblxuICAgIC8qKlxuICAgICAqIFRpbnQgY2FjaGUgYm9vbGVhbiBmbGFnLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIFBJWEkuQ2FudmFzVGludGVyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgY29udmVydFRpbnRUb0ltYWdlOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSBDYW52YXMgQmxlbmRNb2RlcyBhcmUgc3VwcG9ydGVkLCBjb25zZXF1ZW50bHkgdGhlIGFiaWxpdHkgdG8gdGludCB1c2luZyB0aGUgbXVsdGlwbHkgbWV0aG9kLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIFBJWEkuQ2FudmFzVGludGVyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgY2FuVXNlTXVsdGlwbHk6ICgwLCBfY2FuVXNlTmV3Q2FudmFzQmxlbmRNb2RlczIuZGVmYXVsdCkoKSxcblxuICAgIC8qKlxuICAgICAqIFRoZSB0aW50aW5nIG1ldGhvZCB0aGF0IHdpbGwgYmUgdXNlZC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBQSVhJLkNhbnZhc1RpbnRlclxuICAgICAqIEB0eXBlIHt0aW50TWV0aG9kRnVuY3Rpb25UeXBlfVxuICAgICAqL1xuICAgIHRpbnRNZXRob2Q6IDBcbn07XG5cbkNhbnZhc1RpbnRlci50aW50TWV0aG9kID0gQ2FudmFzVGludGVyLmNhblVzZU11bHRpcGx5ID8gQ2FudmFzVGludGVyLnRpbnRXaXRoTXVsdGlwbHkgOiBDYW52YXNUaW50ZXIudGludFdpdGhQZXJQaXhlbDtcblxuLyoqXG4gKiBUaGUgdGludE1ldGhvZCB0eXBlLlxuICpcbiAqIEBtZW1iZXJvZiBQSVhJLkNhbnZhc1RpbnRlclxuICogQGNhbGxiYWNrIHRpbnRNZXRob2RGdW5jdGlvblR5cGVcbiAqIEBwYXJhbSB0ZXh0dXJlIHtQSVhJLlRleHR1cmV9IHRoZSB0ZXh0dXJlIHRvIHRpbnRcbiAqIEBwYXJhbSBjb2xvciB7bnVtYmVyfSB0aGUgY29sb3IgdG8gdXNlIHRvIHRpbnQgdGhlIHNwcml0ZSB3aXRoXG4gKiBAcGFyYW0gY2FudmFzIHtIVE1MQ2FudmFzRWxlbWVudH0gdGhlIGN1cnJlbnQgY2FudmFzXG4gKi9cblxuZXhwb3J0cy5kZWZhdWx0ID0gQ2FudmFzVGludGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2FudmFzVGludGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vKipcbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIFBJWElcbiAqL1xudmFyIEJ1ZmZlciA9IGZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzaXplIC0gVGhlIHNpemUgb2YgdGhlIGJ1ZmZlciBpbiBieXRlcy5cbiAgICovXG4gIGZ1bmN0aW9uIEJ1ZmZlcihzaXplKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJ1ZmZlcik7XG5cbiAgICB0aGlzLnZlcnRpY2VzID0gbmV3IEFycmF5QnVmZmVyKHNpemUpO1xuXG4gICAgLyoqXG4gICAgICogVmlldyBvbiB0aGUgdmVydGljZXMgYXMgYSBGbG9hdDMyQXJyYXkgZm9yIHBvc2l0aW9uc1xuICAgICAqXG4gICAgICogQG1lbWJlciB7RmxvYXQzMkFycmF5fVxuICAgICAqL1xuICAgIHRoaXMuZmxvYXQzMlZpZXcgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMudmVydGljZXMpO1xuXG4gICAgLyoqXG4gICAgICogVmlldyBvbiB0aGUgdmVydGljZXMgYXMgYSBVaW50MzJBcnJheSBmb3IgdXZzXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtGbG9hdDMyQXJyYXl9XG4gICAgICovXG4gICAgdGhpcy51aW50MzJWaWV3ID0gbmV3IFVpbnQzMkFycmF5KHRoaXMudmVydGljZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlc3Ryb3lzIHRoZSBidWZmZXIuXG4gICAqXG4gICAqL1xuXG5cbiAgQnVmZmVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICB0aGlzLnZlcnRpY2VzID0gbnVsbDtcbiAgICB0aGlzLnBvc2l0aW9ucyA9IG51bGw7XG4gICAgdGhpcy51dnMgPSBudWxsO1xuICAgIHRoaXMuY29sb3JzID0gbnVsbDtcbiAgfTtcblxuICByZXR1cm4gQnVmZmVyO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBCdWZmZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CYXRjaEJ1ZmZlci5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfT2JqZWN0UmVuZGVyZXIyID0gcmVxdWlyZSgnLi4vLi4vcmVuZGVyZXJzL3dlYmdsL3V0aWxzL09iamVjdFJlbmRlcmVyJyk7XG5cbnZhciBfT2JqZWN0UmVuZGVyZXIzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfT2JqZWN0UmVuZGVyZXIyKTtcblxudmFyIF9XZWJHTFJlbmRlcmVyID0gcmVxdWlyZSgnLi4vLi4vcmVuZGVyZXJzL3dlYmdsL1dlYkdMUmVuZGVyZXInKTtcblxudmFyIF9XZWJHTFJlbmRlcmVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1dlYkdMUmVuZGVyZXIpO1xuXG52YXIgX2NyZWF0ZUluZGljZXNGb3JRdWFkcyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2NyZWF0ZUluZGljZXNGb3JRdWFkcycpO1xuXG52YXIgX2NyZWF0ZUluZGljZXNGb3JRdWFkczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVJbmRpY2VzRm9yUXVhZHMpO1xuXG52YXIgX2dlbmVyYXRlTXVsdGlUZXh0dXJlU2hhZGVyID0gcmVxdWlyZSgnLi9nZW5lcmF0ZU11bHRpVGV4dHVyZVNoYWRlcicpO1xuXG52YXIgX2dlbmVyYXRlTXVsdGlUZXh0dXJlU2hhZGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dlbmVyYXRlTXVsdGlUZXh0dXJlU2hhZGVyKTtcblxudmFyIF9jaGVja01heElmU3RhdG1lbnRzSW5TaGFkZXIgPSByZXF1aXJlKCcuLi8uLi9yZW5kZXJlcnMvd2ViZ2wvdXRpbHMvY2hlY2tNYXhJZlN0YXRtZW50c0luU2hhZGVyJyk7XG5cbnZhciBfY2hlY2tNYXhJZlN0YXRtZW50c0luU2hhZGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NoZWNrTWF4SWZTdGF0bWVudHNJblNoYWRlcik7XG5cbnZhciBfQmF0Y2hCdWZmZXIgPSByZXF1aXJlKCcuL0JhdGNoQnVmZmVyJyk7XG5cbnZhciBfQmF0Y2hCdWZmZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQmF0Y2hCdWZmZXIpO1xuXG52YXIgX3NldHRpbmdzID0gcmVxdWlyZSgnLi4vLi4vc2V0dGluZ3MnKTtcblxudmFyIF9zZXR0aW5nczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zZXR0aW5ncyk7XG5cbnZhciBfdXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscycpO1xuXG52YXIgX3BpeGlHbENvcmUgPSByZXF1aXJlKCdwaXhpLWdsLWNvcmUnKTtcblxudmFyIF9waXhpR2xDb3JlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BpeGlHbENvcmUpO1xuXG52YXIgX2JpdFR3aWRkbGUgPSByZXF1aXJlKCdiaXQtdHdpZGRsZScpO1xuXG52YXIgX2JpdFR3aWRkbGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYml0VHdpZGRsZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIFRJQ0sgPSAwO1xudmFyIFRFWFRVUkVfVElDSyA9IDA7XG5cbi8qKlxuICogUmVuZGVyZXIgZGVkaWNhdGVkIHRvIGRyYXdpbmcgYW5kIGJhdGNoaW5nIHNwcml0ZXMuXG4gKlxuICogQGNsYXNzXG4gKiBAcHJpdmF0ZVxuICogQG1lbWJlcm9mIFBJWElcbiAqIEBleHRlbmRzIFBJWEkuT2JqZWN0UmVuZGVyZXJcbiAqL1xuXG52YXIgU3ByaXRlUmVuZGVyZXIgPSBmdW5jdGlvbiAoX09iamVjdFJlbmRlcmVyKSB7XG4gICAgX2luaGVyaXRzKFNwcml0ZVJlbmRlcmVyLCBfT2JqZWN0UmVuZGVyZXIpO1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtQSVhJLldlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyIHRoaXMgc3ByaXRlIGJhdGNoIHdvcmtzIGZvci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTcHJpdGVSZW5kZXJlcihyZW5kZXJlcikge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3ByaXRlUmVuZGVyZXIpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOdW1iZXIgb2YgdmFsdWVzIHNlbnQgaW4gdGhlIHZlcnRleCBidWZmZXIuXG4gICAgICAgICAqIGFWZXJ0ZXhQb3NpdGlvbigyKSwgYVRleHR1cmVDb29yZCgxKSwgYUNvbG9yKDEpLCBhVGV4dHVyZUlkKDEpID0gNVxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfT2JqZWN0UmVuZGVyZXIuY2FsbCh0aGlzLCByZW5kZXJlcikpO1xuXG4gICAgICAgIF90aGlzLnZlcnRTaXplID0gNTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHNpemUgb2YgdGhlIHZlcnRleCBpbmZvcm1hdGlvbiBpbiBieXRlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMudmVydEJ5dGVTaXplID0gX3RoaXMudmVydFNpemUgKiA0O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbnVtYmVyIG9mIGltYWdlcyBpbiB0aGUgU3ByaXRlUmVuZGVyZXIgYmVmb3JlIGl0IGZsdXNoZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLnNpemUgPSBfc2V0dGluZ3MyLmRlZmF1bHQuU1BSSVRFX0JBVENIX1NJWkU7IC8vIDIwMDAgaXMgYSBuaWNlIGJhbGFuY2UgYmV0d2VlbiBtb2JpbGUgLyBkZXNrdG9wXG5cbiAgICAgICAgLy8gdGhlIHRvdGFsIG51bWJlciBvZiBieXRlcyBpbiBvdXIgYmF0Y2hcbiAgICAgICAgLy8gbGV0IG51bVZlcnRzID0gdGhpcy5zaXplICogNCAqIHRoaXMudmVydEJ5dGVTaXplO1xuXG4gICAgICAgIF90aGlzLmJ1ZmZlcnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gX2JpdFR3aWRkbGUyLmRlZmF1bHQubmV4dFBvdzIoX3RoaXMuc2l6ZSk7IGkgKj0gMikge1xuICAgICAgICAgICAgX3RoaXMuYnVmZmVycy5wdXNoKG5ldyBfQmF0Y2hCdWZmZXIyLmRlZmF1bHQoaSAqIDQgKiBfdGhpcy52ZXJ0Qnl0ZVNpemUpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIb2xkcyB0aGUgaW5kaWNlcyBvZiB0aGUgZ2VvbWV0cnkgKHF1YWRzKSB0byBkcmF3XG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge1VpbnQxNkFycmF5fVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuaW5kaWNlcyA9ICgwLCBfY3JlYXRlSW5kaWNlc0ZvclF1YWRzMi5kZWZhdWx0KShfdGhpcy5zaXplKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGRlZmF1bHQgc2hhZGVycyB0aGF0IGlzIHVzZWQgaWYgYSBzcHJpdGUgZG9lc24ndCBoYXZlIGEgbW9yZSBzcGVjaWZpYyBvbmUuXG4gICAgICAgICAqIHRoZXJlIGlzIGEgc2hhZGVyIGZvciBlYWNoIG51bWJlciBvZiB0ZXh0dXJlcyB0aGF0IGNhbiBiZSByZW5kZXJlcmQuXG4gICAgICAgICAqIFRoZXNlIHNoYWRlcnMgd2lsbCBhbHNvIGJlIGdlbmVyYXRlZCBvbiB0aGUgZmx5IGFzIHJlcXVpcmVkLlxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLlNoYWRlcltdfVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuc2hhZGVyID0gbnVsbDtcblxuICAgICAgICBfdGhpcy5jdXJyZW50SW5kZXggPSAwO1xuICAgICAgICBfdGhpcy5ncm91cHMgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IF90aGlzLnNpemU7IGsrKykge1xuICAgICAgICAgICAgX3RoaXMuZ3JvdXBzW2tdID0geyB0ZXh0dXJlczogW10sIHRleHR1cmVDb3VudDogMCwgaWRzOiBbXSwgc2l6ZTogMCwgc3RhcnQ6IDAsIGJsZW5kOiAwIH07XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpcy5zcHJpdGVzID0gW107XG5cbiAgICAgICAgX3RoaXMudmVydGV4QnVmZmVycyA9IFtdO1xuICAgICAgICBfdGhpcy52YW9zID0gW107XG5cbiAgICAgICAgX3RoaXMudmFvTWF4ID0gMjtcbiAgICAgICAgX3RoaXMudmVydGV4Q291bnQgPSAwO1xuXG4gICAgICAgIF90aGlzLnJlbmRlcmVyLm9uKCdwcmVyZW5kZXInLCBfdGhpcy5vblByZXJlbmRlciwgX3RoaXMpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB1cCB0aGUgcmVuZGVyZXIgY29udGV4dCBhbmQgbmVjZXNzYXJ5IGJ1ZmZlcnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG5cbiAgICBTcHJpdGVSZW5kZXJlci5wcm90b3R5cGUub25Db250ZXh0Q2hhbmdlID0gZnVuY3Rpb24gb25Db250ZXh0Q2hhbmdlKCkge1xuICAgICAgICB2YXIgZ2wgPSB0aGlzLnJlbmRlcmVyLmdsO1xuXG4gICAgICAgIGlmICh0aGlzLnJlbmRlcmVyLmxlZ2FjeSkge1xuICAgICAgICAgICAgdGhpcy5NQVhfVEVYVFVSRVMgPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gc3RlcCAxOiBmaXJzdCBjaGVjayBtYXggdGV4dHVyZXMgdGhlIEdQVSBjYW4gaGFuZGxlLlxuICAgICAgICAgICAgdGhpcy5NQVhfVEVYVFVSRVMgPSBNYXRoLm1pbihnbC5nZXRQYXJhbWV0ZXIoZ2wuTUFYX1RFWFRVUkVfSU1BR0VfVU5JVFMpLCBfc2V0dGluZ3MyLmRlZmF1bHQuU1BSSVRFX01BWF9URVhUVVJFUyk7XG5cbiAgICAgICAgICAgIC8vIHN0ZXAgMjogY2hlY2sgdGhlIG1heGltdW0gbnVtYmVyIG9mIGlmIHN0YXRlbWVudHMgdGhlIHNoYWRlciBjYW4gaGF2ZSB0b28uLlxuICAgICAgICAgICAgdGhpcy5NQVhfVEVYVFVSRVMgPSAoMCwgX2NoZWNrTWF4SWZTdGF0bWVudHNJblNoYWRlcjIuZGVmYXVsdCkodGhpcy5NQVhfVEVYVFVSRVMsIGdsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2hhZGVyID0gKDAsIF9nZW5lcmF0ZU11bHRpVGV4dHVyZVNoYWRlcjIuZGVmYXVsdCkoZ2wsIHRoaXMuTUFYX1RFWFRVUkVTKTtcblxuICAgICAgICAvLyBjcmVhdGUgYSBjb3VwbGUgb2YgYnVmZmVyc1xuICAgICAgICB0aGlzLmluZGV4QnVmZmVyID0gX3BpeGlHbENvcmUyLmRlZmF1bHQuR0xCdWZmZXIuY3JlYXRlSW5kZXhCdWZmZXIoZ2wsIHRoaXMuaW5kaWNlcywgZ2wuU1RBVElDX0RSQVcpO1xuXG4gICAgICAgIC8vIHdlIHVzZSB0aGUgc2Vjb25kIHNoYWRlciBhcyB0aGUgZmlyc3Qgb25lIGRlcGVuZGluZyBvbiB5b3VyIGJyb3dzZXIgbWF5IG9taXQgYVRleHR1cmVJZFxuICAgICAgICAvLyBhcyBpdCBpcyBub3QgdXNlZCBieSB0aGUgc2hhZGVyIHNvIGlzIG9wdGltaXplZCBvdXQuXG5cbiAgICAgICAgdGhpcy5yZW5kZXJlci5iaW5kVmFvKG51bGwpO1xuXG4gICAgICAgIHZhciBhdHRycyA9IHRoaXMuc2hhZGVyLmF0dHJpYnV0ZXM7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnZhb01heDsgaSsrKSB7XG4gICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG4gICAgICAgICAgICB2YXIgdmVydGV4QnVmZmVyID0gdGhpcy52ZXJ0ZXhCdWZmZXJzW2ldID0gX3BpeGlHbENvcmUyLmRlZmF1bHQuR0xCdWZmZXIuY3JlYXRlVmVydGV4QnVmZmVyKGdsLCBudWxsLCBnbC5TVFJFQU1fRFJBVyk7XG4gICAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4gKi9cblxuICAgICAgICAgICAgLy8gYnVpbGQgdGhlIHZhbyBvYmplY3QgdGhhdCB3aWxsIHJlbmRlci4uXG4gICAgICAgICAgICB2YXIgdmFvID0gdGhpcy5yZW5kZXJlci5jcmVhdGVWYW8oKS5hZGRJbmRleCh0aGlzLmluZGV4QnVmZmVyKS5hZGRBdHRyaWJ1dGUodmVydGV4QnVmZmVyLCBhdHRycy5hVmVydGV4UG9zaXRpb24sIGdsLkZMT0FULCBmYWxzZSwgdGhpcy52ZXJ0Qnl0ZVNpemUsIDApLmFkZEF0dHJpYnV0ZSh2ZXJ0ZXhCdWZmZXIsIGF0dHJzLmFUZXh0dXJlQ29vcmQsIGdsLlVOU0lHTkVEX1NIT1JULCB0cnVlLCB0aGlzLnZlcnRCeXRlU2l6ZSwgMiAqIDQpLmFkZEF0dHJpYnV0ZSh2ZXJ0ZXhCdWZmZXIsIGF0dHJzLmFDb2xvciwgZ2wuVU5TSUdORURfQllURSwgdHJ1ZSwgdGhpcy52ZXJ0Qnl0ZVNpemUsIDMgKiA0KTtcblxuICAgICAgICAgICAgaWYgKGF0dHJzLmFUZXh0dXJlSWQpIHtcbiAgICAgICAgICAgICAgICB2YW8uYWRkQXR0cmlidXRlKHZlcnRleEJ1ZmZlciwgYXR0cnMuYVRleHR1cmVJZCwgZ2wuRkxPQVQsIGZhbHNlLCB0aGlzLnZlcnRCeXRlU2l6ZSwgNCAqIDQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnZhb3NbaV0gPSB2YW87XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnZhbyA9IHRoaXMudmFvc1swXTtcbiAgICAgICAgdGhpcy5jdXJyZW50QmxlbmRNb2RlID0gOTk5OTk7XG5cbiAgICAgICAgdGhpcy5ib3VuZFRleHR1cmVzID0gbmV3IEFycmF5KHRoaXMuTUFYX1RFWFRVUkVTKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIGJlZm9yZSB0aGUgcmVuZGVyZXIgc3RhcnRzIHJlbmRlcmluZy5cbiAgICAgKlxuICAgICAqL1xuXG5cbiAgICBTcHJpdGVSZW5kZXJlci5wcm90b3R5cGUub25QcmVyZW5kZXIgPSBmdW5jdGlvbiBvblByZXJlbmRlcigpIHtcbiAgICAgICAgdGhpcy52ZXJ0ZXhDb3VudCA9IDA7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgdGhlIHNwcml0ZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuU3ByaXRlfSBzcHJpdGUgLSB0aGUgc3ByaXRlIHRvIHJlbmRlciB3aGVuIHVzaW5nIHRoaXMgc3ByaXRlYmF0Y2hcbiAgICAgKi9cblxuXG4gICAgU3ByaXRlUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcihzcHJpdGUpIHtcbiAgICAgICAgLy8gVE9ETyBzZXQgYmxlbmQgbW9kZXMuLlxuICAgICAgICAvLyBjaGVjayB0ZXh0dXJlLi5cbiAgICAgICAgaWYgKHRoaXMuY3VycmVudEluZGV4ID49IHRoaXMuc2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZ2V0IHRoZSB1dnMgZm9yIHRoZSB0ZXh0dXJlXG5cbiAgICAgICAgLy8gaWYgdGhlIHV2cyBoYXZlIG5vdCB1cGRhdGVkIHRoZW4gbm8gcG9pbnQgcmVuZGVyaW5nIGp1c3QgeWV0IVxuICAgICAgICBpZiAoIXNwcml0ZS5fdGV4dHVyZS5fdXZzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBwdXNoIGEgdGV4dHVyZS5cbiAgICAgICAgLy8gaW5jcmVtZW50IHRoZSBiYXRjaHNpemVcbiAgICAgICAgdGhpcy5zcHJpdGVzW3RoaXMuY3VycmVudEluZGV4KytdID0gc3ByaXRlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIHRoZSBjb250ZW50IGFuZCBlbXB0aWVzIHRoZSBjdXJyZW50IGJhdGNoLlxuICAgICAqXG4gICAgICovXG5cblxuICAgIFNwcml0ZVJlbmRlcmVyLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uIGZsdXNoKCkge1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50SW5kZXggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBnbCA9IHRoaXMucmVuZGVyZXIuZ2w7XG4gICAgICAgIHZhciBNQVhfVEVYVFVSRVMgPSB0aGlzLk1BWF9URVhUVVJFUztcblxuICAgICAgICB2YXIgbnAyID0gX2JpdFR3aWRkbGUyLmRlZmF1bHQubmV4dFBvdzIodGhpcy5jdXJyZW50SW5kZXgpO1xuICAgICAgICB2YXIgbG9nMiA9IF9iaXRUd2lkZGxlMi5kZWZhdWx0LmxvZzIobnAyKTtcbiAgICAgICAgdmFyIGJ1ZmZlciA9IHRoaXMuYnVmZmVyc1tsb2cyXTtcblxuICAgICAgICB2YXIgc3ByaXRlcyA9IHRoaXMuc3ByaXRlcztcbiAgICAgICAgdmFyIGdyb3VwcyA9IHRoaXMuZ3JvdXBzO1xuXG4gICAgICAgIHZhciBmbG9hdDMyVmlldyA9IGJ1ZmZlci5mbG9hdDMyVmlldztcbiAgICAgICAgdmFyIHVpbnQzMlZpZXcgPSBidWZmZXIudWludDMyVmlldztcblxuICAgICAgICB2YXIgYm91bmRUZXh0dXJlcyA9IHRoaXMuYm91bmRUZXh0dXJlcztcbiAgICAgICAgdmFyIHJlbmRlcmVyQm91bmRUZXh0dXJlcyA9IHRoaXMucmVuZGVyZXIuYm91bmRUZXh0dXJlcztcbiAgICAgICAgdmFyIHRvdWNoID0gdGhpcy5yZW5kZXJlci50ZXh0dXJlR0MuY291bnQ7XG5cbiAgICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgICAgdmFyIG5leHRUZXh0dXJlID0gdm9pZCAwO1xuICAgICAgICB2YXIgY3VycmVudFRleHR1cmUgPSB2b2lkIDA7XG4gICAgICAgIHZhciBncm91cENvdW50ID0gMTtcbiAgICAgICAgdmFyIHRleHR1cmVDb3VudCA9IDA7XG4gICAgICAgIHZhciBjdXJyZW50R3JvdXAgPSBncm91cHNbMF07XG4gICAgICAgIHZhciB2ZXJ0ZXhEYXRhID0gdm9pZCAwO1xuICAgICAgICB2YXIgdXZzID0gdm9pZCAwO1xuICAgICAgICB2YXIgYmxlbmRNb2RlID0gX3V0aWxzLnByZW11bHRpcGx5QmxlbmRNb2RlW3Nwcml0ZXNbMF0uX3RleHR1cmUuYmFzZVRleHR1cmUucHJlbXVsdGlwbGllZEFscGhhID8gMSA6IDBdW3Nwcml0ZXNbMF0uYmxlbmRNb2RlXTtcblxuICAgICAgICBjdXJyZW50R3JvdXAudGV4dHVyZUNvdW50ID0gMDtcbiAgICAgICAgY3VycmVudEdyb3VwLnN0YXJ0ID0gMDtcbiAgICAgICAgY3VycmVudEdyb3VwLmJsZW5kID0gYmxlbmRNb2RlO1xuXG4gICAgICAgIFRJQ0srKztcblxuICAgICAgICB2YXIgaSA9IHZvaWQgMDtcblxuICAgICAgICAvLyBjb3B5IHRleHR1cmVzLi5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IE1BWF9URVhUVVJFUzsgKytpKSB7XG4gICAgICAgICAgICB2YXIgYnQgPSByZW5kZXJlckJvdW5kVGV4dHVyZXNbaV07XG5cbiAgICAgICAgICAgIGlmIChidC5fZW5hYmxlZCA9PT0gVElDSykge1xuICAgICAgICAgICAgICAgIGJvdW5kVGV4dHVyZXNbaV0gPSB0aGlzLnJlbmRlcmVyLmVtcHR5VGV4dHVyZXNbaV07XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJvdW5kVGV4dHVyZXNbaV0gPSBidDtcbiAgICAgICAgICAgIGJ0Ll92aXJ0YWxCb3VuZElkID0gaTtcbiAgICAgICAgICAgIGJ0Ll9lbmFibGVkID0gVElDSztcbiAgICAgICAgfVxuICAgICAgICBUSUNLKys7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuY3VycmVudEluZGV4OyArK2kpIHtcbiAgICAgICAgICAgIC8vIHVwbG9hZCB0aGUgc3ByaXRlIGVsZW1ldG5zLi4uXG4gICAgICAgICAgICAvLyB0aGV5IGhhdmUgYWxsIHJlYWR5IGJlZW4gY2FsY3VsYXRlZCBzbyB3ZSBqdXN0IG5lZWQgdG8gcHVzaCB0aGVtIGludG8gdGhlIGJ1ZmZlci5cbiAgICAgICAgICAgIHZhciBzcHJpdGUgPSBzcHJpdGVzW2ldO1xuXG4gICAgICAgICAgICBzcHJpdGVzW2ldID0gbnVsbDtcblxuICAgICAgICAgICAgbmV4dFRleHR1cmUgPSBzcHJpdGUuX3RleHR1cmUuYmFzZVRleHR1cmU7XG5cbiAgICAgICAgICAgIHZhciBzcHJpdGVCbGVuZE1vZGUgPSBfdXRpbHMucHJlbXVsdGlwbHlCbGVuZE1vZGVbTnVtYmVyKG5leHRUZXh0dXJlLnByZW11bHRpcGxpZWRBbHBoYSldW3Nwcml0ZS5ibGVuZE1vZGVdO1xuXG4gICAgICAgICAgICBpZiAoYmxlbmRNb2RlICE9PSBzcHJpdGVCbGVuZE1vZGUpIHtcbiAgICAgICAgICAgICAgICAvLyBmaW5pc2ggYSBncm91cC4uXG4gICAgICAgICAgICAgICAgYmxlbmRNb2RlID0gc3ByaXRlQmxlbmRNb2RlO1xuXG4gICAgICAgICAgICAgICAgLy8gZm9yY2UgdGhlIGJhdGNoIHRvIGJyZWFrIVxuICAgICAgICAgICAgICAgIGN1cnJlbnRUZXh0dXJlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0ZXh0dXJlQ291bnQgPSBNQVhfVEVYVFVSRVM7XG4gICAgICAgICAgICAgICAgVElDSysrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY3VycmVudFRleHR1cmUgIT09IG5leHRUZXh0dXJlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFRleHR1cmUgPSBuZXh0VGV4dHVyZTtcblxuICAgICAgICAgICAgICAgIGlmIChuZXh0VGV4dHVyZS5fZW5hYmxlZCAhPT0gVElDSykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGV4dHVyZUNvdW50ID09PSBNQVhfVEVYVFVSRVMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFRJQ0srKztcblxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEdyb3VwLnNpemUgPSBpIC0gY3VycmVudEdyb3VwLnN0YXJ0O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlQ291bnQgPSAwO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50R3JvdXAgPSBncm91cHNbZ3JvdXBDb3VudCsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRHcm91cC5ibGVuZCA9IGJsZW5kTW9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRHcm91cC50ZXh0dXJlQ291bnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEdyb3VwLnN0YXJ0ID0gaTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIG5leHRUZXh0dXJlLnRvdWNoZWQgPSB0b3VjaDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dFRleHR1cmUuX3ZpcnRhbEJvdW5kSWQgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IE1BWF9URVhUVVJFUzsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRJbmRleCA9IChqICsgVEVYVFVSRV9USUNLKSAlIE1BWF9URVhUVVJFUztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gYm91bmRUZXh0dXJlc1t0SW5kZXhdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHQuX2VuYWJsZWQgIT09IFRJQ0spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVEVYVFVSRV9USUNLKys7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdC5fdmlydGFsQm91bmRJZCA9IC0xO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRUZXh0dXJlLl92aXJ0YWxCb3VuZElkID0gdEluZGV4O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvdW5kVGV4dHVyZXNbdEluZGV4XSA9IG5leHRUZXh0dXJlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBuZXh0VGV4dHVyZS5fZW5hYmxlZCA9IFRJQ0s7XG5cbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEdyb3VwLnRleHR1cmVDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50R3JvdXAuaWRzW3RleHR1cmVDb3VudF0gPSBuZXh0VGV4dHVyZS5fdmlydGFsQm91bmRJZDtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEdyb3VwLnRleHR1cmVzW3RleHR1cmVDb3VudCsrXSA9IG5leHRUZXh0dXJlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmVydGV4RGF0YSA9IHNwcml0ZS52ZXJ0ZXhEYXRhO1xuXG4gICAgICAgICAgICAvLyBUT0RPIHRoaXMgc3VtIGRvZXMgbm90IG5lZWQgdG8gYmUgc2V0IGVhY2ggZnJhbWUuLlxuICAgICAgICAgICAgdXZzID0gc3ByaXRlLl90ZXh0dXJlLl91dnMudXZzVWludDMyO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5yZW5kZXJlci5yb3VuZFBpeGVscykge1xuICAgICAgICAgICAgICAgIHZhciByZXNvbHV0aW9uID0gdGhpcy5yZW5kZXJlci5yZXNvbHV0aW9uO1xuXG4gICAgICAgICAgICAgICAgLy8geHlcbiAgICAgICAgICAgICAgICBmbG9hdDMyVmlld1tpbmRleF0gPSAodmVydGV4RGF0YVswXSAqIHJlc29sdXRpb24gfCAwKSAvIHJlc29sdXRpb247XG4gICAgICAgICAgICAgICAgZmxvYXQzMlZpZXdbaW5kZXggKyAxXSA9ICh2ZXJ0ZXhEYXRhWzFdICogcmVzb2x1dGlvbiB8IDApIC8gcmVzb2x1dGlvbjtcblxuICAgICAgICAgICAgICAgIC8vIHh5XG4gICAgICAgICAgICAgICAgZmxvYXQzMlZpZXdbaW5kZXggKyA1XSA9ICh2ZXJ0ZXhEYXRhWzJdICogcmVzb2x1dGlvbiB8IDApIC8gcmVzb2x1dGlvbjtcbiAgICAgICAgICAgICAgICBmbG9hdDMyVmlld1tpbmRleCArIDZdID0gKHZlcnRleERhdGFbM10gKiByZXNvbHV0aW9uIHwgMCkgLyByZXNvbHV0aW9uO1xuXG4gICAgICAgICAgICAgICAgLy8geHlcbiAgICAgICAgICAgICAgICBmbG9hdDMyVmlld1tpbmRleCArIDEwXSA9ICh2ZXJ0ZXhEYXRhWzRdICogcmVzb2x1dGlvbiB8IDApIC8gcmVzb2x1dGlvbjtcbiAgICAgICAgICAgICAgICBmbG9hdDMyVmlld1tpbmRleCArIDExXSA9ICh2ZXJ0ZXhEYXRhWzVdICogcmVzb2x1dGlvbiB8IDApIC8gcmVzb2x1dGlvbjtcblxuICAgICAgICAgICAgICAgIC8vIHh5XG4gICAgICAgICAgICAgICAgZmxvYXQzMlZpZXdbaW5kZXggKyAxNV0gPSAodmVydGV4RGF0YVs2XSAqIHJlc29sdXRpb24gfCAwKSAvIHJlc29sdXRpb247XG4gICAgICAgICAgICAgICAgZmxvYXQzMlZpZXdbaW5kZXggKyAxNl0gPSAodmVydGV4RGF0YVs3XSAqIHJlc29sdXRpb24gfCAwKSAvIHJlc29sdXRpb247XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHh5XG4gICAgICAgICAgICAgICAgZmxvYXQzMlZpZXdbaW5kZXhdID0gdmVydGV4RGF0YVswXTtcbiAgICAgICAgICAgICAgICBmbG9hdDMyVmlld1tpbmRleCArIDFdID0gdmVydGV4RGF0YVsxXTtcblxuICAgICAgICAgICAgICAgIC8vIHh5XG4gICAgICAgICAgICAgICAgZmxvYXQzMlZpZXdbaW5kZXggKyA1XSA9IHZlcnRleERhdGFbMl07XG4gICAgICAgICAgICAgICAgZmxvYXQzMlZpZXdbaW5kZXggKyA2XSA9IHZlcnRleERhdGFbM107XG5cbiAgICAgICAgICAgICAgICAvLyB4eVxuICAgICAgICAgICAgICAgIGZsb2F0MzJWaWV3W2luZGV4ICsgMTBdID0gdmVydGV4RGF0YVs0XTtcbiAgICAgICAgICAgICAgICBmbG9hdDMyVmlld1tpbmRleCArIDExXSA9IHZlcnRleERhdGFbNV07XG5cbiAgICAgICAgICAgICAgICAvLyB4eVxuICAgICAgICAgICAgICAgIGZsb2F0MzJWaWV3W2luZGV4ICsgMTVdID0gdmVydGV4RGF0YVs2XTtcbiAgICAgICAgICAgICAgICBmbG9hdDMyVmlld1tpbmRleCArIDE2XSA9IHZlcnRleERhdGFbN107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHVpbnQzMlZpZXdbaW5kZXggKyAyXSA9IHV2c1swXTtcbiAgICAgICAgICAgIHVpbnQzMlZpZXdbaW5kZXggKyA3XSA9IHV2c1sxXTtcbiAgICAgICAgICAgIHVpbnQzMlZpZXdbaW5kZXggKyAxMl0gPSB1dnNbMl07XG4gICAgICAgICAgICB1aW50MzJWaWV3W2luZGV4ICsgMTddID0gdXZzWzNdO1xuICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuICAgICAgICAgICAgdmFyIGFscGhhID0gTWF0aC5taW4oc3ByaXRlLndvcmxkQWxwaGEsIDEuMCk7XG4gICAgICAgICAgICAvLyB3ZSBkb250IGNhbGwgZXh0cmEgZnVuY3Rpb24gaWYgYWxwaGEgaXMgMS4wLCB0aGF0J3MgZmFzdGVyXG4gICAgICAgICAgICB2YXIgYXJnYiA9IGFscGhhIDwgMS4wICYmIG5leHRUZXh0dXJlLnByZW11bHRpcGxpZWRBbHBoYSA/ICgwLCBfdXRpbHMucHJlbXVsdGlwbHlUaW50KShzcHJpdGUuX3RpbnRSR0IsIGFscGhhKSA6IHNwcml0ZS5fdGludFJHQiArIChhbHBoYSAqIDI1NSA8PCAyNCk7XG5cbiAgICAgICAgICAgIHVpbnQzMlZpZXdbaW5kZXggKyAzXSA9IHVpbnQzMlZpZXdbaW5kZXggKyA4XSA9IHVpbnQzMlZpZXdbaW5kZXggKyAxM10gPSB1aW50MzJWaWV3W2luZGV4ICsgMThdID0gYXJnYjtcbiAgICAgICAgICAgIGZsb2F0MzJWaWV3W2luZGV4ICsgNF0gPSBmbG9hdDMyVmlld1tpbmRleCArIDldID0gZmxvYXQzMlZpZXdbaW5kZXggKyAxNF0gPSBmbG9hdDMyVmlld1tpbmRleCArIDE5XSA9IG5leHRUZXh0dXJlLl92aXJ0YWxCb3VuZElkO1xuICAgICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuICovXG5cbiAgICAgICAgICAgIGluZGV4ICs9IDIwO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudEdyb3VwLnNpemUgPSBpIC0gY3VycmVudEdyb3VwLnN0YXJ0O1xuXG4gICAgICAgIGlmICghX3NldHRpbmdzMi5kZWZhdWx0LkNBTl9VUExPQURfU0FNRV9CVUZGRVIpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgc3RpbGwgbmVlZGVkIGZvciBJT1MgcGVyZm9ybWFuY2UuLlxuICAgICAgICAgICAgLy8gaXQgcmVhbGx5IGRvZXMgbm90IGxpa2UgdXBsb2FkaW5nIHRvIHRoZSBzYW1lIGJ1ZmZlciBpbiBhIHNpbmdsZSBmcmFtZSFcbiAgICAgICAgICAgIGlmICh0aGlzLnZhb01heCA8PSB0aGlzLnZlcnRleENvdW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy52YW9NYXgrKztcblxuICAgICAgICAgICAgICAgIHZhciBhdHRycyA9IHRoaXMuc2hhZGVyLmF0dHJpYnV0ZXM7XG5cbiAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG4gICAgICAgICAgICAgICAgdmFyIHZlcnRleEJ1ZmZlciA9IHRoaXMudmVydGV4QnVmZmVyc1t0aGlzLnZlcnRleENvdW50XSA9IF9waXhpR2xDb3JlMi5kZWZhdWx0LkdMQnVmZmVyLmNyZWF0ZVZlcnRleEJ1ZmZlcihnbCwgbnVsbCwgZ2wuU1RSRUFNX0RSQVcpO1xuICAgICAgICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuXG4gICAgICAgICAgICAgICAgLy8gYnVpbGQgdGhlIHZhbyBvYmplY3QgdGhhdCB3aWxsIHJlbmRlci4uXG4gICAgICAgICAgICAgICAgdmFyIHZhbyA9IHRoaXMucmVuZGVyZXIuY3JlYXRlVmFvKCkuYWRkSW5kZXgodGhpcy5pbmRleEJ1ZmZlcikuYWRkQXR0cmlidXRlKHZlcnRleEJ1ZmZlciwgYXR0cnMuYVZlcnRleFBvc2l0aW9uLCBnbC5GTE9BVCwgZmFsc2UsIHRoaXMudmVydEJ5dGVTaXplLCAwKS5hZGRBdHRyaWJ1dGUodmVydGV4QnVmZmVyLCBhdHRycy5hVGV4dHVyZUNvb3JkLCBnbC5VTlNJR05FRF9TSE9SVCwgdHJ1ZSwgdGhpcy52ZXJ0Qnl0ZVNpemUsIDIgKiA0KS5hZGRBdHRyaWJ1dGUodmVydGV4QnVmZmVyLCBhdHRycy5hQ29sb3IsIGdsLlVOU0lHTkVEX0JZVEUsIHRydWUsIHRoaXMudmVydEJ5dGVTaXplLCAzICogNCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoYXR0cnMuYVRleHR1cmVJZCkge1xuICAgICAgICAgICAgICAgICAgICB2YW8uYWRkQXR0cmlidXRlKHZlcnRleEJ1ZmZlciwgYXR0cnMuYVRleHR1cmVJZCwgZ2wuRkxPQVQsIGZhbHNlLCB0aGlzLnZlcnRCeXRlU2l6ZSwgNCAqIDQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMudmFvc1t0aGlzLnZlcnRleENvdW50XSA9IHZhbztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5iaW5kVmFvKHRoaXMudmFvc1t0aGlzLnZlcnRleENvdW50XSk7XG5cbiAgICAgICAgICAgIHRoaXMudmVydGV4QnVmZmVyc1t0aGlzLnZlcnRleENvdW50XS51cGxvYWQoYnVmZmVyLnZlcnRpY2VzLCAwLCBmYWxzZSk7XG5cbiAgICAgICAgICAgIHRoaXMudmVydGV4Q291bnQrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGxldHMgdXNlIHRoZSBmYXN0ZXIgb3B0aW9uLCBhbHdheXMgdXNlIGJ1ZmZlciBudW1iZXIgMFxuICAgICAgICAgICAgdGhpcy52ZXJ0ZXhCdWZmZXJzW3RoaXMudmVydGV4Q291bnRdLnVwbG9hZChidWZmZXIudmVydGljZXMsIDAsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IE1BWF9URVhUVVJFUzsgKytpKSB7XG4gICAgICAgICAgICByZW5kZXJlckJvdW5kVGV4dHVyZXNbaV0uX3ZpcnRhbEJvdW5kSWQgPSAtMTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlbmRlciB0aGUgZ3JvdXBzLi5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGdyb3VwQ291bnQ7ICsraSkge1xuICAgICAgICAgICAgdmFyIGdyb3VwID0gZ3JvdXBzW2ldO1xuICAgICAgICAgICAgdmFyIGdyb3VwVGV4dHVyZUNvdW50ID0gZ3JvdXAudGV4dHVyZUNvdW50O1xuXG4gICAgICAgICAgICBmb3IgKHZhciBfaiA9IDA7IF9qIDwgZ3JvdXBUZXh0dXJlQ291bnQ7IF9qKyspIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50VGV4dHVyZSA9IGdyb3VwLnRleHR1cmVzW19qXTtcblxuICAgICAgICAgICAgICAgIC8vIHJlc2V0IHZpcnR1YWwgaWRzLi5cbiAgICAgICAgICAgICAgICAvLyBsZXRzIGRvIGEgcXVpY2sgY2hlY2suLlxuICAgICAgICAgICAgICAgIGlmIChyZW5kZXJlckJvdW5kVGV4dHVyZXNbZ3JvdXAuaWRzW19qXV0gIT09IGN1cnJlbnRUZXh0dXJlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuYmluZFRleHR1cmUoY3VycmVudFRleHR1cmUsIGdyb3VwLmlkc1tfal0sIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHJlc2V0IHRoZSB2aXJ0dWFsSWQuLlxuICAgICAgICAgICAgICAgIGN1cnJlbnRUZXh0dXJlLl92aXJ0YWxCb3VuZElkID0gLTE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHNldCB0aGUgYmxlbmQgbW9kZS4uXG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnN0YXRlLnNldEJsZW5kTW9kZShncm91cC5ibGVuZCk7XG5cbiAgICAgICAgICAgIGdsLmRyYXdFbGVtZW50cyhnbC5UUklBTkdMRVMsIGdyb3VwLnNpemUgKiA2LCBnbC5VTlNJR05FRF9TSE9SVCwgZ3JvdXAuc3RhcnQgKiA2ICogMik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXNldCBlbGVtZW50cyBmb3IgdGhlIG5leHQgZmx1c2hcbiAgICAgICAgdGhpcy5jdXJyZW50SW5kZXggPSAwO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTdGFydHMgYSBuZXcgc3ByaXRlIGJhdGNoLlxuICAgICAqL1xuXG5cbiAgICBTcHJpdGVSZW5kZXJlci5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5iaW5kU2hhZGVyKHRoaXMuc2hhZGVyKTtcblxuICAgICAgICBpZiAoX3NldHRpbmdzMi5kZWZhdWx0LkNBTl9VUExPQURfU0FNRV9CVUZGRVIpIHtcbiAgICAgICAgICAgIC8vIGJpbmQgYnVmZmVyICMwLCB3ZSBkb24ndCBuZWVkIG90aGVyc1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5iaW5kVmFvKHRoaXMudmFvc1t0aGlzLnZlcnRleENvdW50XSk7XG5cbiAgICAgICAgICAgIHRoaXMudmVydGV4QnVmZmVyc1t0aGlzLnZlcnRleENvdW50XS5iaW5kKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU3RvcHMgYW5kIGZsdXNoZXMgdGhlIGN1cnJlbnQgYmF0Y2guXG4gICAgICpcbiAgICAgKi9cblxuXG4gICAgU3ByaXRlUmVuZGVyZXIucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgICB0aGlzLmZsdXNoKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIHRoZSBTcHJpdGVSZW5kZXJlci5cbiAgICAgKlxuICAgICAqL1xuXG5cbiAgICBTcHJpdGVSZW5kZXJlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy52YW9NYXg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMudmVydGV4QnVmZmVyc1tpXSkge1xuICAgICAgICAgICAgICAgIHRoaXMudmVydGV4QnVmZmVyc1tpXS5kZXN0cm95KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy52YW9zW2ldKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52YW9zW2ldLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmluZGV4QnVmZmVyKSB7XG4gICAgICAgICAgICB0aGlzLmluZGV4QnVmZmVyLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucmVuZGVyZXIub2ZmKCdwcmVyZW5kZXInLCB0aGlzLm9uUHJlcmVuZGVyLCB0aGlzKTtcblxuICAgICAgICBfT2JqZWN0UmVuZGVyZXIucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcblxuICAgICAgICBpZiAodGhpcy5zaGFkZXIpIHtcbiAgICAgICAgICAgIHRoaXMuc2hhZGVyLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIHRoaXMuc2hhZGVyID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudmVydGV4QnVmZmVycyA9IG51bGw7XG4gICAgICAgIHRoaXMudmFvcyA9IG51bGw7XG4gICAgICAgIHRoaXMuaW5kZXhCdWZmZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmluZGljZXMgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuc3ByaXRlcyA9IG51bGw7XG5cbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHRoaXMuYnVmZmVycy5sZW5ndGg7ICsrX2kpIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyc1tfaV0uZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBTcHJpdGVSZW5kZXJlcjtcbn0oX09iamVjdFJlbmRlcmVyMy5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gU3ByaXRlUmVuZGVyZXI7XG5cblxuX1dlYkdMUmVuZGVyZXIyLmRlZmF1bHQucmVnaXN0ZXJQbHVnaW4oJ3Nwcml0ZScsIFNwcml0ZVJlbmRlcmVyKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNwcml0ZVJlbmRlcmVyLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuZGVmYXVsdCA9IGdlbmVyYXRlTXVsdGlUZXh0dXJlU2hhZGVyO1xuXG52YXIgX1NoYWRlciA9IHJlcXVpcmUoJy4uLy4uL1NoYWRlcicpO1xuXG52YXIgX1NoYWRlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9TaGFkZXIpO1xuXG52YXIgX3BhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBmcmFnVGVtcGxhdGUgPSBbJ3ZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkOycsICd2YXJ5aW5nIHZlYzQgdkNvbG9yOycsICd2YXJ5aW5nIGZsb2F0IHZUZXh0dXJlSWQ7JywgJ3VuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyc1slY291bnQlXTsnLCAndm9pZCBtYWluKHZvaWQpeycsICd2ZWM0IGNvbG9yOycsICclZm9ybG9vcCUnLCAnZ2xfRnJhZ0NvbG9yID0gY29sb3IgKiB2Q29sb3I7JywgJ30nXS5qb2luKCdcXG4nKTtcblxuZnVuY3Rpb24gZ2VuZXJhdGVNdWx0aVRleHR1cmVTaGFkZXIoZ2wsIG1heFRleHR1cmVzKSB7XG4gICAgdmFyIHZlcnRleFNyYyA9ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuYXR0cmlidXRlIHZlYzIgYVZlcnRleFBvc2l0aW9uO1xcbmF0dHJpYnV0ZSB2ZWMyIGFUZXh0dXJlQ29vcmQ7XFxuYXR0cmlidXRlIHZlYzQgYUNvbG9yO1xcbmF0dHJpYnV0ZSBmbG9hdCBhVGV4dHVyZUlkO1xcblxcbnVuaWZvcm0gbWF0MyBwcm9qZWN0aW9uTWF0cml4O1xcblxcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcbnZhcnlpbmcgdmVjNCB2Q29sb3I7XFxudmFyeWluZyBmbG9hdCB2VGV4dHVyZUlkO1xcblxcbnZvaWQgbWFpbih2b2lkKXtcXG4gICAgZ2xfUG9zaXRpb24gPSB2ZWM0KChwcm9qZWN0aW9uTWF0cml4ICogdmVjMyhhVmVydGV4UG9zaXRpb24sIDEuMCkpLnh5LCAwLjAsIDEuMCk7XFxuXFxuICAgIHZUZXh0dXJlQ29vcmQgPSBhVGV4dHVyZUNvb3JkO1xcbiAgICB2VGV4dHVyZUlkID0gYVRleHR1cmVJZDtcXG4gICAgdkNvbG9yID0gYUNvbG9yO1xcbn1cXG4nO1xuICAgIHZhciBmcmFnbWVudFNyYyA9IGZyYWdUZW1wbGF0ZTtcblxuICAgIGZyYWdtZW50U3JjID0gZnJhZ21lbnRTcmMucmVwbGFjZSgvJWNvdW50JS9naSwgbWF4VGV4dHVyZXMpO1xuICAgIGZyYWdtZW50U3JjID0gZnJhZ21lbnRTcmMucmVwbGFjZSgvJWZvcmxvb3AlL2dpLCBnZW5lcmF0ZVNhbXBsZVNyYyhtYXhUZXh0dXJlcykpO1xuXG4gICAgdmFyIHNoYWRlciA9IG5ldyBfU2hhZGVyMi5kZWZhdWx0KGdsLCB2ZXJ0ZXhTcmMsIGZyYWdtZW50U3JjKTtcblxuICAgIHZhciBzYW1wbGVWYWx1ZXMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWF4VGV4dHVyZXM7IGkrKykge1xuICAgICAgICBzYW1wbGVWYWx1ZXNbaV0gPSBpO1xuICAgIH1cblxuICAgIHNoYWRlci5iaW5kKCk7XG4gICAgc2hhZGVyLnVuaWZvcm1zLnVTYW1wbGVycyA9IHNhbXBsZVZhbHVlcztcblxuICAgIHJldHVybiBzaGFkZXI7XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlU2FtcGxlU3JjKG1heFRleHR1cmVzKSB7XG4gICAgdmFyIHNyYyA9ICcnO1xuXG4gICAgc3JjICs9ICdcXG4nO1xuICAgIHNyYyArPSAnXFxuJztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWF4VGV4dHVyZXM7IGkrKykge1xuICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgIHNyYyArPSAnXFxuZWxzZSAnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGkgPCBtYXhUZXh0dXJlcyAtIDEpIHtcbiAgICAgICAgICAgIHNyYyArPSAnaWYodlRleHR1cmVJZCA8ICcgKyBpICsgJy41KSc7XG4gICAgICAgIH1cblxuICAgICAgICBzcmMgKz0gJ1xcbnsnO1xuICAgICAgICBzcmMgKz0gJ1xcblxcdGNvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyc1snICsgaSArICddLCB2VGV4dHVyZUNvb3JkKTsnO1xuICAgICAgICBzcmMgKz0gJ1xcbn0nO1xuICAgIH1cblxuICAgIHNyYyArPSAnXFxuJztcbiAgICBzcmMgKz0gJ1xcbic7XG5cbiAgICByZXR1cm4gc3JjO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2VuZXJhdGVNdWx0aVRleHR1cmVTaGFkZXIuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX1Nwcml0ZTIgPSByZXF1aXJlKCcuLi9zcHJpdGVzL1Nwcml0ZScpO1xuXG52YXIgX1Nwcml0ZTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9TcHJpdGUyKTtcblxudmFyIF9UZXh0dXJlID0gcmVxdWlyZSgnLi4vdGV4dHVyZXMvVGV4dHVyZScpO1xuXG52YXIgX1RleHR1cmUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVGV4dHVyZSk7XG5cbnZhciBfbWF0aCA9IHJlcXVpcmUoJy4uL21hdGgnKTtcblxudmFyIF91dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbnZhciBfY29uc3QgPSByZXF1aXJlKCcuLi9jb25zdCcpO1xuXG52YXIgX3NldHRpbmdzID0gcmVxdWlyZSgnLi4vc2V0dGluZ3MnKTtcblxudmFyIF9zZXR0aW5nczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zZXR0aW5ncyk7XG5cbnZhciBfVGV4dFN0eWxlID0gcmVxdWlyZSgnLi9UZXh0U3R5bGUnKTtcblxudmFyIF9UZXh0U3R5bGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVGV4dFN0eWxlKTtcblxudmFyIF9UZXh0TWV0cmljcyA9IHJlcXVpcmUoJy4vVGV4dE1ldHJpY3MnKTtcblxudmFyIF9UZXh0TWV0cmljczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9UZXh0TWV0cmljcyk7XG5cbnZhciBfdHJpbUNhbnZhcyA9IHJlcXVpcmUoJy4uL3V0aWxzL3RyaW1DYW52YXMnKTtcblxudmFyIF90cmltQ2FudmFzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RyaW1DYW52YXMpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9IC8qIGVzbGludCBtYXgtZGVwdGg6IFsyLCA4XSAqL1xuXG5cbnZhciBkZWZhdWx0RGVzdHJveU9wdGlvbnMgPSB7XG4gICAgdGV4dHVyZTogdHJ1ZSxcbiAgICBjaGlsZHJlbjogZmFsc2UsXG4gICAgYmFzZVRleHR1cmU6IHRydWVcbn07XG5cbi8qKlxuICogQSBUZXh0IE9iamVjdCB3aWxsIGNyZWF0ZSBhIGxpbmUgb3IgbXVsdGlwbGUgbGluZXMgb2YgdGV4dC4gVG8gc3BsaXQgYSBsaW5lIHlvdSBjYW4gdXNlICdcXG4nIGluIHlvdXIgdGV4dCBzdHJpbmcsXG4gKiBvciBhZGQgYSB3b3JkV3JhcCBwcm9wZXJ0eSBzZXQgdG8gdHJ1ZSBhbmQgYW5kIHdvcmRXcmFwV2lkdGggcHJvcGVydHkgd2l0aCBhIHZhbHVlIGluIHRoZSBzdHlsZSBvYmplY3QuXG4gKlxuICogQSBUZXh0IGNhbiBiZSBjcmVhdGVkIGRpcmVjdGx5IGZyb20gYSBzdHJpbmcgYW5kIGEgc3R5bGUgb2JqZWN0LFxuICogd2hpY2ggY2FuIGJlIGdlbmVyYXRlZCBbaGVyZV0oaHR0cHM6Ly9waXhpanMuaW8vcGl4aS10ZXh0LXN0eWxlKS5cbiAqXG4gKiBgYGBqc1xuICogbGV0IHRleHQgPSBuZXcgUElYSS5UZXh0KCdUaGlzIGlzIGEgUGl4aUpTIHRleHQnLHtmb250RmFtaWx5IDogJ0FyaWFsJywgZm9udFNpemU6IDI0LCBmaWxsIDogMHhmZjEwMTAsIGFsaWduIDogJ2NlbnRlcid9KTtcbiAqIGBgYFxuICpcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgUElYSS5TcHJpdGVcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKi9cblxudmFyIFRleHQgPSBmdW5jdGlvbiAoX1Nwcml0ZSkge1xuICAgIF9pbmhlcml0cyhUZXh0LCBfU3ByaXRlKTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gVGhlIHN0cmluZyB0aGF0IHlvdSB3b3VsZCBsaWtlIHRoZSB0ZXh0IHRvIGRpc3BsYXlcbiAgICAgKiBAcGFyYW0ge29iamVjdHxQSVhJLlRleHRTdHlsZX0gW3N0eWxlXSAtIFRoZSBzdHlsZSBwYXJhbWV0ZXJzXG4gICAgICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gW2NhbnZhc10gLSBUaGUgY2FudmFzIGVsZW1lbnQgZm9yIGRyYXdpbmcgdGV4dFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFRleHQodGV4dCwgc3R5bGUsIGNhbnZhcykge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVGV4dCk7XG5cbiAgICAgICAgY2FudmFzID0gY2FudmFzIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuXG4gICAgICAgIGNhbnZhcy53aWR0aCA9IDM7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSAzO1xuXG4gICAgICAgIHZhciB0ZXh0dXJlID0gX1RleHR1cmUyLmRlZmF1bHQuZnJvbUNhbnZhcyhjYW52YXMsIF9zZXR0aW5nczIuZGVmYXVsdC5TQ0FMRV9NT0RFLCAndGV4dCcpO1xuXG4gICAgICAgIHRleHR1cmUub3JpZyA9IG5ldyBfbWF0aC5SZWN0YW5nbGUoKTtcbiAgICAgICAgdGV4dHVyZS50cmltID0gbmV3IF9tYXRoLlJlY3RhbmdsZSgpO1xuXG4gICAgICAgIC8vIGJhc2UgdGV4dHVyZSBpcyBhbHJlYWR5IGF1dG9tYXRpY2FsbHkgYWRkZWQgdG8gdGhlIGNhY2hlLCBub3cgYWRkaW5nIHRoZSBhY3R1YWwgdGV4dHVyZVxuICAgICAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfU3ByaXRlLmNhbGwodGhpcywgdGV4dHVyZSkpO1xuXG4gICAgICAgIF9UZXh0dXJlMi5kZWZhdWx0LmFkZFRvQ2FjaGUoX3RoaXMuX3RleHR1cmUsIF90aGlzLl90ZXh0dXJlLmJhc2VUZXh0dXJlLnRleHR1cmVDYWNoZUlkc1swXSk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjYW52YXMgZWxlbWVudCB0aGF0IGV2ZXJ5dGhpbmcgaXMgZHJhd24gdG9cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7SFRNTENhbnZhc0VsZW1lbnR9XG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5jYW52YXMgPSBjYW52YXM7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjYW52YXMgMmQgY29udGV4dCB0aGF0IGV2ZXJ5dGhpbmcgaXMgZHJhd24gd2l0aFxuICAgICAgICAgKiBAbWVtYmVyIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9XG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5jb250ZXh0ID0gX3RoaXMuY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSByZXNvbHV0aW9uIC8gZGV2aWNlIHBpeGVsIHJhdGlvIG9mIHRoZSBjYW52YXMuIFRoaXMgaXMgc2V0IGF1dG9tYXRpY2FsbHkgYnkgdGhlIHJlbmRlcmVyLlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDFcbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLnJlc29sdXRpb24gPSBfc2V0dGluZ3MyLmRlZmF1bHQuUkVTT0xVVElPTjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUHJpdmF0ZSB0cmFja2VyIGZvciB0aGUgY3VycmVudCB0ZXh0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5fdGV4dCA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByaXZhdGUgdHJhY2tlciBmb3IgdGhlIGN1cnJlbnQgc3R5bGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge29iamVjdH1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLl9zdHlsZSA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcml2YXRlIGxpc3RlbmVyIHRvIHRyYWNrIHN0eWxlIGNoYW5nZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge0Z1bmN0aW9ufVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuX3N0eWxlTGlzdGVuZXIgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcml2YXRlIHRyYWNrZXIgZm9yIHRoZSBjdXJyZW50IGZvbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge3N0cmluZ31cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLl9mb250ID0gJyc7XG5cbiAgICAgICAgX3RoaXMudGV4dCA9IHRleHQ7XG4gICAgICAgIF90aGlzLnN0eWxlID0gc3R5bGU7XG5cbiAgICAgICAgX3RoaXMubG9jYWxTdHlsZUlEID0gLTE7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIHRleHQgYW5kIHVwZGF0ZXMgaXQgd2hlbiBuZWVkZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVzcGVjdERpcnR5IC0gV2hldGhlciB0byBhYm9ydCB1cGRhdGluZyB0aGUgdGV4dCBpZiB0aGUgVGV4dCBpc24ndCBkaXJ0eSBhbmQgdGhlIGZ1bmN0aW9uIGlzIGNhbGxlZC5cbiAgICAgKi9cblxuXG4gICAgVGV4dC5wcm90b3R5cGUudXBkYXRlVGV4dCA9IGZ1bmN0aW9uIHVwZGF0ZVRleHQocmVzcGVjdERpcnR5KSB7XG4gICAgICAgIHZhciBzdHlsZSA9IHRoaXMuX3N0eWxlO1xuXG4gICAgICAgIC8vIGNoZWNrIGlmIHN0eWxlIGhhcyBjaGFuZ2VkLi5cbiAgICAgICAgaWYgKHRoaXMubG9jYWxTdHlsZUlEICE9PSBzdHlsZS5zdHlsZUlEKSB7XG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMubG9jYWxTdHlsZUlEID0gc3R5bGUuc3R5bGVJRDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5kaXJ0eSAmJiByZXNwZWN0RGlydHkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2ZvbnQgPSB0aGlzLl9zdHlsZS50b0ZvbnRTdHJpbmcoKTtcblxuICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgdmFyIG1lYXN1cmVkID0gX1RleHRNZXRyaWNzMi5kZWZhdWx0Lm1lYXN1cmVUZXh0KHRoaXMuX3RleHQsIHRoaXMuX3N0eWxlLCB0aGlzLl9zdHlsZS53b3JkV3JhcCwgdGhpcy5jYW52YXMpO1xuICAgICAgICB2YXIgd2lkdGggPSBtZWFzdXJlZC53aWR0aDtcbiAgICAgICAgdmFyIGhlaWdodCA9IG1lYXN1cmVkLmhlaWdodDtcbiAgICAgICAgdmFyIGxpbmVzID0gbWVhc3VyZWQubGluZXM7XG4gICAgICAgIHZhciBsaW5lSGVpZ2h0ID0gbWVhc3VyZWQubGluZUhlaWdodDtcbiAgICAgICAgdmFyIGxpbmVXaWR0aHMgPSBtZWFzdXJlZC5saW5lV2lkdGhzO1xuICAgICAgICB2YXIgbWF4TGluZVdpZHRoID0gbWVhc3VyZWQubWF4TGluZVdpZHRoO1xuICAgICAgICB2YXIgZm9udFByb3BlcnRpZXMgPSBtZWFzdXJlZC5mb250UHJvcGVydGllcztcblxuICAgICAgICB0aGlzLmNhbnZhcy53aWR0aCA9IE1hdGguY2VpbCgoTWF0aC5tYXgoMSwgd2lkdGgpICsgc3R5bGUucGFkZGluZyAqIDIpICogdGhpcy5yZXNvbHV0aW9uKTtcbiAgICAgICAgdGhpcy5jYW52YXMuaGVpZ2h0ID0gTWF0aC5jZWlsKChNYXRoLm1heCgxLCBoZWlnaHQpICsgc3R5bGUucGFkZGluZyAqIDIpICogdGhpcy5yZXNvbHV0aW9uKTtcblxuICAgICAgICBjb250ZXh0LnNjYWxlKHRoaXMucmVzb2x1dGlvbiwgdGhpcy5yZXNvbHV0aW9uKTtcblxuICAgICAgICBjb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB0aGlzLmNhbnZhcy53aWR0aCwgdGhpcy5jYW52YXMuaGVpZ2h0KTtcblxuICAgICAgICBjb250ZXh0LmZvbnQgPSB0aGlzLl9mb250O1xuICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gc3R5bGUuc3Ryb2tlO1xuICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IHN0eWxlLnN0cm9rZVRoaWNrbmVzcztcbiAgICAgICAgY29udGV4dC50ZXh0QmFzZWxpbmUgPSBzdHlsZS50ZXh0QmFzZWxpbmU7XG4gICAgICAgIGNvbnRleHQubGluZUpvaW4gPSBzdHlsZS5saW5lSm9pbjtcbiAgICAgICAgY29udGV4dC5taXRlckxpbWl0ID0gc3R5bGUubWl0ZXJMaW1pdDtcblxuICAgICAgICB2YXIgbGluZVBvc2l0aW9uWCA9IHZvaWQgMDtcbiAgICAgICAgdmFyIGxpbmVQb3NpdGlvblkgPSB2b2lkIDA7XG5cbiAgICAgICAgaWYgKHN0eWxlLmRyb3BTaGFkb3cpIHtcbiAgICAgICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gc3R5bGUuZHJvcFNoYWRvd0NvbG9yO1xuICAgICAgICAgICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IHN0eWxlLmRyb3BTaGFkb3dBbHBoYTtcbiAgICAgICAgICAgIGNvbnRleHQuc2hhZG93Qmx1ciA9IHN0eWxlLmRyb3BTaGFkb3dCbHVyO1xuXG4gICAgICAgICAgICBpZiAoc3R5bGUuZHJvcFNoYWRvd0JsdXIgPiAwKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5zaGFkb3dDb2xvciA9IHN0eWxlLmRyb3BTaGFkb3dDb2xvcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHhTaGFkb3dPZmZzZXQgPSBNYXRoLmNvcyhzdHlsZS5kcm9wU2hhZG93QW5nbGUpICogc3R5bGUuZHJvcFNoYWRvd0Rpc3RhbmNlO1xuICAgICAgICAgICAgdmFyIHlTaGFkb3dPZmZzZXQgPSBNYXRoLnNpbihzdHlsZS5kcm9wU2hhZG93QW5nbGUpICogc3R5bGUuZHJvcFNoYWRvd0Rpc3RhbmNlO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGluZVBvc2l0aW9uWCA9IHN0eWxlLnN0cm9rZVRoaWNrbmVzcyAvIDI7XG4gICAgICAgICAgICAgICAgbGluZVBvc2l0aW9uWSA9IHN0eWxlLnN0cm9rZVRoaWNrbmVzcyAvIDIgKyBpICogbGluZUhlaWdodCArIGZvbnRQcm9wZXJ0aWVzLmFzY2VudDtcblxuICAgICAgICAgICAgICAgIGlmIChzdHlsZS5hbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgICAgICAgICAgICBsaW5lUG9zaXRpb25YICs9IG1heExpbmVXaWR0aCAtIGxpbmVXaWR0aHNbaV07XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdHlsZS5hbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZVBvc2l0aW9uWCArPSAobWF4TGluZVdpZHRoIC0gbGluZVdpZHRoc1tpXSkgLyAyO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChzdHlsZS5maWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd0xldHRlclNwYWNpbmcobGluZXNbaV0sIGxpbmVQb3NpdGlvblggKyB4U2hhZG93T2Zmc2V0ICsgc3R5bGUucGFkZGluZywgbGluZVBvc2l0aW9uWSArIHlTaGFkb3dPZmZzZXQgKyBzdHlsZS5wYWRkaW5nKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoc3R5bGUuc3Ryb2tlICYmIHN0eWxlLnN0cm9rZVRoaWNrbmVzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IHN0eWxlLmRyb3BTaGFkb3dDb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd0xldHRlclNwYWNpbmcobGluZXNbaV0sIGxpbmVQb3NpdGlvblggKyB4U2hhZG93T2Zmc2V0ICsgc3R5bGUucGFkZGluZywgbGluZVBvc2l0aW9uWSArIHlTaGFkb3dPZmZzZXQgKyBzdHlsZS5wYWRkaW5nLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBzdHlsZS5zdHJva2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXNldCB0aGUgc2hhZG93IGJsdXIgYW5kIGFscGhhIHRoYXQgd2FzIHNldCBieSB0aGUgZHJvcCBzaGFkb3csIGZvciB0aGUgcmVndWxhciB0ZXh0XG4gICAgICAgIGNvbnRleHQuc2hhZG93Qmx1ciA9IDA7XG4gICAgICAgIGNvbnRleHQuZ2xvYmFsQWxwaGEgPSAxO1xuXG4gICAgICAgIC8vIHNldCBjYW52YXMgdGV4dCBzdHlsZXNcbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSB0aGlzLl9nZW5lcmF0ZUZpbGxTdHlsZShzdHlsZSwgbGluZXMpO1xuXG4gICAgICAgIC8vIGRyYXcgbGluZXMgbGluZSBieSBsaW5lXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBsaW5lcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGxpbmVQb3NpdGlvblggPSBzdHlsZS5zdHJva2VUaGlja25lc3MgLyAyO1xuICAgICAgICAgICAgbGluZVBvc2l0aW9uWSA9IHN0eWxlLnN0cm9rZVRoaWNrbmVzcyAvIDIgKyBfaSAqIGxpbmVIZWlnaHQgKyBmb250UHJvcGVydGllcy5hc2NlbnQ7XG5cbiAgICAgICAgICAgIGlmIChzdHlsZS5hbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgICAgICAgIGxpbmVQb3NpdGlvblggKz0gbWF4TGluZVdpZHRoIC0gbGluZVdpZHRoc1tfaV07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0eWxlLmFsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICAgICAgICAgIGxpbmVQb3NpdGlvblggKz0gKG1heExpbmVXaWR0aCAtIGxpbmVXaWR0aHNbX2ldKSAvIDI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzdHlsZS5zdHJva2UgJiYgc3R5bGUuc3Ryb2tlVGhpY2tuZXNzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3TGV0dGVyU3BhY2luZyhsaW5lc1tfaV0sIGxpbmVQb3NpdGlvblggKyBzdHlsZS5wYWRkaW5nLCBsaW5lUG9zaXRpb25ZICsgc3R5bGUucGFkZGluZywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzdHlsZS5maWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3TGV0dGVyU3BhY2luZyhsaW5lc1tfaV0sIGxpbmVQb3NpdGlvblggKyBzdHlsZS5wYWRkaW5nLCBsaW5lUG9zaXRpb25ZICsgc3R5bGUucGFkZGluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnVwZGF0ZVRleHR1cmUoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIHRoZSB0ZXh0IHdpdGggbGV0dGVyLXNwYWNpbmcuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSBUaGUgdGV4dCB0byBkcmF3XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBIb3Jpem9udGFsIHBvc2l0aW9uIHRvIGRyYXcgdGhlIHRleHRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIFZlcnRpY2FsIHBvc2l0aW9uIHRvIGRyYXcgdGhlIHRleHRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc1N0cm9rZT1mYWxzZV0gLSBJcyB0aGlzIGRyYXdpbmcgZm9yIHRoZSBvdXRzaWRlIHN0cm9rZSBvZiB0aGVcbiAgICAgKiAgdGV4dD8gSWYgbm90LCBpdCdzIGZvciB0aGUgaW5zaWRlIGZpbGxcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG5cbiAgICBUZXh0LnByb3RvdHlwZS5kcmF3TGV0dGVyU3BhY2luZyA9IGZ1bmN0aW9uIGRyYXdMZXR0ZXJTcGFjaW5nKHRleHQsIHgsIHkpIHtcbiAgICAgICAgdmFyIGlzU3Ryb2tlID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBmYWxzZTtcblxuICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLl9zdHlsZTtcblxuICAgICAgICAvLyBsZXR0ZXJTcGFjaW5nIG9mIDAgbWVhbnMgbm9ybWFsXG4gICAgICAgIHZhciBsZXR0ZXJTcGFjaW5nID0gc3R5bGUubGV0dGVyU3BhY2luZztcblxuICAgICAgICBpZiAobGV0dGVyU3BhY2luZyA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKGlzU3Ryb2tlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LnN0cm9rZVRleHQodGV4dCwgeCwgeSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5maWxsVGV4dCh0ZXh0LCB4LCB5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNoYXJhY3RlcnMgPSBTdHJpbmcucHJvdG90eXBlLnNwbGl0LmNhbGwodGV4dCwgJycpO1xuICAgICAgICB2YXIgY3VycmVudFBvc2l0aW9uID0geDtcbiAgICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSAnJztcblxuICAgICAgICB3aGlsZSAoaW5kZXggPCB0ZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgY3VycmVudCA9IGNoYXJhY3RlcnNbaW5kZXgrK107XG4gICAgICAgICAgICBpZiAoaXNTdHJva2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuc3Ryb2tlVGV4dChjdXJyZW50LCBjdXJyZW50UG9zaXRpb24sIHkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuZmlsbFRleHQoY3VycmVudCwgY3VycmVudFBvc2l0aW9uLCB5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRQb3NpdGlvbiArPSB0aGlzLmNvbnRleHQubWVhc3VyZVRleHQoY3VycmVudCkud2lkdGggKyBsZXR0ZXJTcGFjaW5nO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGV4dHVyZSBzaXplIGJhc2VkIG9uIGNhbnZhcyBzaXplXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG5cbiAgICBUZXh0LnByb3RvdHlwZS51cGRhdGVUZXh0dXJlID0gZnVuY3Rpb24gdXBkYXRlVGV4dHVyZSgpIHtcbiAgICAgICAgdmFyIGNhbnZhcyA9IHRoaXMuY2FudmFzO1xuXG4gICAgICAgIGlmICh0aGlzLl9zdHlsZS50cmltKSB7XG4gICAgICAgICAgICB2YXIgdHJpbW1lZCA9ICgwLCBfdHJpbUNhbnZhczIuZGVmYXVsdCkoY2FudmFzKTtcblxuICAgICAgICAgICAgaWYgKHRyaW1tZWQuZGF0YSkge1xuICAgICAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IHRyaW1tZWQud2lkdGg7XG4gICAgICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IHRyaW1tZWQuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5wdXRJbWFnZURhdGEodHJpbW1lZC5kYXRhLCAwLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0ZXh0dXJlID0gdGhpcy5fdGV4dHVyZTtcbiAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5fc3R5bGU7XG4gICAgICAgIHZhciBwYWRkaW5nID0gc3R5bGUudHJpbSA/IDAgOiBzdHlsZS5wYWRkaW5nO1xuICAgICAgICB2YXIgYmFzZVRleHR1cmUgPSB0ZXh0dXJlLmJhc2VUZXh0dXJlO1xuXG4gICAgICAgIGJhc2VUZXh0dXJlLmhhc0xvYWRlZCA9IHRydWU7XG4gICAgICAgIGJhc2VUZXh0dXJlLnJlc29sdXRpb24gPSB0aGlzLnJlc29sdXRpb247XG5cbiAgICAgICAgYmFzZVRleHR1cmUucmVhbFdpZHRoID0gY2FudmFzLndpZHRoO1xuICAgICAgICBiYXNlVGV4dHVyZS5yZWFsSGVpZ2h0ID0gY2FudmFzLmhlaWdodDtcbiAgICAgICAgYmFzZVRleHR1cmUud2lkdGggPSBjYW52YXMud2lkdGggLyB0aGlzLnJlc29sdXRpb247XG4gICAgICAgIGJhc2VUZXh0dXJlLmhlaWdodCA9IGNhbnZhcy5oZWlnaHQgLyB0aGlzLnJlc29sdXRpb247XG5cbiAgICAgICAgdGV4dHVyZS50cmltLndpZHRoID0gdGV4dHVyZS5fZnJhbWUud2lkdGggPSBjYW52YXMud2lkdGggLyB0aGlzLnJlc29sdXRpb247XG4gICAgICAgIHRleHR1cmUudHJpbS5oZWlnaHQgPSB0ZXh0dXJlLl9mcmFtZS5oZWlnaHQgPSBjYW52YXMuaGVpZ2h0IC8gdGhpcy5yZXNvbHV0aW9uO1xuICAgICAgICB0ZXh0dXJlLnRyaW0ueCA9IC1wYWRkaW5nO1xuICAgICAgICB0ZXh0dXJlLnRyaW0ueSA9IC1wYWRkaW5nO1xuXG4gICAgICAgIHRleHR1cmUub3JpZy53aWR0aCA9IHRleHR1cmUuX2ZyYW1lLndpZHRoIC0gcGFkZGluZyAqIDI7XG4gICAgICAgIHRleHR1cmUub3JpZy5oZWlnaHQgPSB0ZXh0dXJlLl9mcmFtZS5oZWlnaHQgLSBwYWRkaW5nICogMjtcblxuICAgICAgICAvLyBjYWxsIHNwcml0ZSBvblRleHR1cmVVcGRhdGUgdG8gdXBkYXRlIHNjYWxlIGlmIF93aWR0aCBvciBfaGVpZ2h0IHdlcmUgc2V0XG4gICAgICAgIHRoaXMuX29uVGV4dHVyZVVwZGF0ZSgpO1xuXG4gICAgICAgIGJhc2VUZXh0dXJlLmVtaXQoJ3VwZGF0ZScsIGJhc2VUZXh0dXJlKTtcblxuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgdGhlIG9iamVjdCB1c2luZyB0aGUgV2ViR0wgcmVuZGVyZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5XZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlclxuICAgICAqL1xuXG5cbiAgICBUZXh0LnByb3RvdHlwZS5yZW5kZXJXZWJHTCA9IGZ1bmN0aW9uIHJlbmRlcldlYkdMKHJlbmRlcmVyKSB7XG4gICAgICAgIGlmICh0aGlzLnJlc29sdXRpb24gIT09IHJlbmRlcmVyLnJlc29sdXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMucmVzb2x1dGlvbiA9IHJlbmRlcmVyLnJlc29sdXRpb247XG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudXBkYXRlVGV4dCh0cnVlKTtcblxuICAgICAgICBfU3ByaXRlLnByb3RvdHlwZS5yZW5kZXJXZWJHTC5jYWxsKHRoaXMsIHJlbmRlcmVyKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0aGUgb2JqZWN0IHVzaW5nIHRoZSBDYW52YXMgcmVuZGVyZXJcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtQSVhJLkNhbnZhc1JlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlclxuICAgICAqL1xuXG5cbiAgICBUZXh0LnByb3RvdHlwZS5fcmVuZGVyQ2FudmFzID0gZnVuY3Rpb24gX3JlbmRlckNhbnZhcyhyZW5kZXJlcikge1xuICAgICAgICBpZiAodGhpcy5yZXNvbHV0aW9uICE9PSByZW5kZXJlci5yZXNvbHV0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnJlc29sdXRpb24gPSByZW5kZXJlci5yZXNvbHV0aW9uO1xuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnVwZGF0ZVRleHQodHJ1ZSk7XG5cbiAgICAgICAgX1Nwcml0ZS5wcm90b3R5cGUuX3JlbmRlckNhbnZhcy5jYWxsKHRoaXMsIHJlbmRlcmVyKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbG9jYWwgYm91bmRzIG9mIHRoZSB0ZXh0IG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UmVjdGFuZ2xlfSByZWN0IC0gVGhlIG91dHB1dCByZWN0YW5nbGUuXG4gICAgICogQHJldHVybiB7UmVjdGFuZ2xlfSBUaGUgYm91bmRzLlxuICAgICAqL1xuXG5cbiAgICBUZXh0LnByb3RvdHlwZS5nZXRMb2NhbEJvdW5kcyA9IGZ1bmN0aW9uIGdldExvY2FsQm91bmRzKHJlY3QpIHtcbiAgICAgICAgdGhpcy51cGRhdGVUZXh0KHRydWUpO1xuXG4gICAgICAgIHJldHVybiBfU3ByaXRlLnByb3RvdHlwZS5nZXRMb2NhbEJvdW5kcy5jYWxsKHRoaXMsIHJlY3QpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBjYWxjdWxhdGVzIHRoZSBib3VuZHMgb2YgdGhlIFRleHQgYXMgYSByZWN0YW5nbGUuIFRoZSBib3VuZHMgY2FsY3VsYXRpb24gdGFrZXMgdGhlIHdvcmxkVHJhbnNmb3JtIGludG8gYWNjb3VudC5cbiAgICAgKi9cblxuXG4gICAgVGV4dC5wcm90b3R5cGUuX2NhbGN1bGF0ZUJvdW5kcyA9IGZ1bmN0aW9uIF9jYWxjdWxhdGVCb3VuZHMoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlVGV4dCh0cnVlKTtcbiAgICAgICAgdGhpcy5jYWxjdWxhdGVWZXJ0aWNlcygpO1xuICAgICAgICAvLyBpZiB3ZSBoYXZlIGFscmVhZHkgZG9uZSB0aGlzIG9uIFRISVMgZnJhbWUuXG4gICAgICAgIHRoaXMuX2JvdW5kcy5hZGRRdWFkKHRoaXMudmVydGV4RGF0YSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB0byBiZSBjYWxsZWQgdXBvbiBhIFRleHRTdHlsZSBjaGFuZ2UuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuXG4gICAgVGV4dC5wcm90b3R5cGUuX29uU3R5bGVDaGFuZ2UgPSBmdW5jdGlvbiBfb25TdHlsZUNoYW5nZSgpIHtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyB0aGUgZmlsbCBzdHlsZS4gQ2FuIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGUgYSBncmFkaWVudCBiYXNlZCBvbiB0aGUgZmlsbCBzdHlsZSBiZWluZyBhbiBhcnJheVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc3R5bGUgLSBUaGUgc3R5bGUuXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gbGluZXMgLSBUaGUgbGluZXMgb2YgdGV4dC5cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd8bnVtYmVyfENhbnZhc0dyYWRpZW50fSBUaGUgZmlsbCBzdHlsZVxuICAgICAqL1xuXG5cbiAgICBUZXh0LnByb3RvdHlwZS5fZ2VuZXJhdGVGaWxsU3R5bGUgPSBmdW5jdGlvbiBfZ2VuZXJhdGVGaWxsU3R5bGUoc3R5bGUsIGxpbmVzKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShzdHlsZS5maWxsKSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0eWxlLmZpbGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb2Nvb24gb24gY2FudmFzKyBjYW5ub3QgZ2VuZXJhdGUgdGV4dHVyZXMsIHNvIHVzZSB0aGUgZmlyc3QgY29sb3VyIGluc3RlYWRcbiAgICAgICAgaWYgKG5hdmlnYXRvci5pc0NvY29vbkpTKSB7XG4gICAgICAgICAgICByZXR1cm4gc3R5bGUuZmlsbFswXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRoZSBncmFkaWVudCB3aWxsIGJlIGV2ZW5seSBzcGFjZWQgb3V0IGFjY29yZGluZyB0byBob3cgbGFyZ2UgdGhlIGFycmF5IGlzLlxuICAgICAgICAvLyBbJyNGRjAwMDAnLCAnIzAwRkYwMCcsICcjMDAwMEZGJ10gd291bGQgY3JlYXRlZCBzdG9wcyBhdCAwLjI1LCAwLjUgYW5kIDAuNzVcbiAgICAgICAgdmFyIGdyYWRpZW50ID0gdm9pZCAwO1xuICAgICAgICB2YXIgdG90YWxJdGVyYXRpb25zID0gdm9pZCAwO1xuICAgICAgICB2YXIgY3VycmVudEl0ZXJhdGlvbiA9IHZvaWQgMDtcbiAgICAgICAgdmFyIHN0b3AgPSB2b2lkIDA7XG5cbiAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5jYW52YXMud2lkdGggLyB0aGlzLnJlc29sdXRpb247XG4gICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLmNhbnZhcy5oZWlnaHQgLyB0aGlzLnJlc29sdXRpb247XG5cbiAgICAgICAgLy8gbWFrZSBhIGNvcHkgb2YgdGhlIHN0eWxlIHNldHRpbmdzLCBzbyB3ZSBjYW4gbWFuaXB1bGF0ZSB0aGVtIGxhdGVyXG4gICAgICAgIHZhciBmaWxsID0gc3R5bGUuZmlsbC5zbGljZSgpO1xuICAgICAgICB2YXIgZmlsbEdyYWRpZW50U3RvcHMgPSBzdHlsZS5maWxsR3JhZGllbnRTdG9wcy5zbGljZSgpO1xuXG4gICAgICAgIC8vIHdhbnRpbmcgdG8gZXZlbmx5IGRpc3RyaWJ1dGUgdGhlIGZpbGxzLiBTbyBhbiBhcnJheSBvZiA0IGNvbG91cnMgc2hvdWxkIGdpdmUgZmlsbHMgb2YgMC4yNSwgMC41IGFuZCAwLjc1XG4gICAgICAgIGlmICghZmlsbEdyYWRpZW50U3RvcHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgbGVuZ3RoUGx1czEgPSBmaWxsLmxlbmd0aCArIDE7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuZ3RoUGx1czE7ICsraSkge1xuICAgICAgICAgICAgICAgIGZpbGxHcmFkaWVudFN0b3BzLnB1c2goaSAvIGxlbmd0aFBsdXMxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHN0b3AgdGhlIGJsZWVkaW5nIG9mIHRoZSBsYXN0IGdyYWRpZW50IG9uIHRoZSBsaW5lIGFib3ZlIHRvIHRoZSB0b3AgZ3JhZGllbnQgb2YgdGhlIHRoaXMgbGluZVxuICAgICAgICAvLyBieSBoYXJkIGRlZmluaW5nIHRoZSBmaXJzdCBncmFkaWVudCBjb2xvdXIgYXQgcG9pbnQgMCwgYW5kIGxhc3QgZ3JhZGllbnQgY29sb3VyIGF0IHBvaW50IDFcbiAgICAgICAgZmlsbC51bnNoaWZ0KHN0eWxlLmZpbGxbMF0pO1xuICAgICAgICBmaWxsR3JhZGllbnRTdG9wcy51bnNoaWZ0KDApO1xuXG4gICAgICAgIGZpbGwucHVzaChzdHlsZS5maWxsW3N0eWxlLmZpbGwubGVuZ3RoIC0gMV0pO1xuICAgICAgICBmaWxsR3JhZGllbnRTdG9wcy5wdXNoKDEpO1xuXG4gICAgICAgIGlmIChzdHlsZS5maWxsR3JhZGllbnRUeXBlID09PSBfY29uc3QuVEVYVF9HUkFESUVOVC5MSU5FQVJfVkVSVElDQUwpIHtcbiAgICAgICAgICAgIC8vIHN0YXJ0IHRoZSBncmFkaWVudCBhdCB0aGUgdG9wIGNlbnRlciBvZiB0aGUgY2FudmFzLCBhbmQgZW5kIGF0IHRoZSBib3R0b20gbWlkZGxlIG9mIHRoZSBjYW52YXNcbiAgICAgICAgICAgIGdyYWRpZW50ID0gdGhpcy5jb250ZXh0LmNyZWF0ZUxpbmVhckdyYWRpZW50KHdpZHRoIC8gMiwgMCwgd2lkdGggLyAyLCBoZWlnaHQpO1xuXG4gICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIHJlcGVhdCB0aGUgZ3JhZGllbnQgc28gdGhhdCBlYWNoIGluZGl2aWR1YWwgbGluZSBvZiB0ZXh0IGhhcyB0aGUgc2FtZSB2ZXJ0aWNhbCBncmFkaWVudCBlZmZlY3RcbiAgICAgICAgICAgIC8vIFsnI0ZGMDAwMCcsICcjMDBGRjAwJywgJyMwMDAwRkYnXSBvdmVyIDIgbGluZXMgd291bGQgY3JlYXRlIHN0b3BzIGF0IDAuMTI1LCAwLjI1LCAwLjM3NSwgMC42MjUsIDAuNzUsIDAuODc1XG4gICAgICAgICAgICB0b3RhbEl0ZXJhdGlvbnMgPSAoZmlsbC5sZW5ndGggKyAxKSAqIGxpbmVzLmxlbmd0aDtcbiAgICAgICAgICAgIGN1cnJlbnRJdGVyYXRpb24gPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgbGluZXMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRJdGVyYXRpb24gKz0gMTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGZpbGwubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmaWxsR3JhZGllbnRTdG9wc1tqXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3AgPSBmaWxsR3JhZGllbnRTdG9wc1tqXSAvIGxpbmVzLmxlbmd0aCArIF9pMiAvIGxpbmVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3AgPSBjdXJyZW50SXRlcmF0aW9uIC8gdG90YWxJdGVyYXRpb25zO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcChzdG9wLCBmaWxsW2pdKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEl0ZXJhdGlvbisrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHN0YXJ0IHRoZSBncmFkaWVudCBhdCB0aGUgY2VudGVyIGxlZnQgb2YgdGhlIGNhbnZhcywgYW5kIGVuZCBhdCB0aGUgY2VudGVyIHJpZ2h0IG9mIHRoZSBjYW52YXNcbiAgICAgICAgICAgIGdyYWRpZW50ID0gdGhpcy5jb250ZXh0LmNyZWF0ZUxpbmVhckdyYWRpZW50KDAsIGhlaWdodCAvIDIsIHdpZHRoLCBoZWlnaHQgLyAyKTtcblxuICAgICAgICAgICAgLy8gY2FuIGp1c3QgZXZlbmx5IHNwYWNlIG91dCB0aGUgZ3JhZGllbnRzIGluIHRoaXMgY2FzZSwgYXMgbXVsdGlwbGUgbGluZXMgbWFrZXMgbm8gZGlmZmVyZW5jZVxuICAgICAgICAgICAgLy8gdG8gYW4gZXZlbiBsZWZ0IHRvIHJpZ2h0IGdyYWRpZW50XG4gICAgICAgICAgICB0b3RhbEl0ZXJhdGlvbnMgPSBmaWxsLmxlbmd0aCArIDE7XG4gICAgICAgICAgICBjdXJyZW50SXRlcmF0aW9uID0gMTtcblxuICAgICAgICAgICAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgZmlsbC5sZW5ndGg7IF9pMysrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmaWxsR3JhZGllbnRTdG9wc1tfaTNdID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICBzdG9wID0gZmlsbEdyYWRpZW50U3RvcHNbX2kzXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdG9wID0gY3VycmVudEl0ZXJhdGlvbiAvIHRvdGFsSXRlcmF0aW9ucztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKHN0b3AsIGZpbGxbX2kzXSk7XG4gICAgICAgICAgICAgICAgY3VycmVudEl0ZXJhdGlvbisrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdyYWRpZW50O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyB0aGlzIHRleHQgb2JqZWN0LlxuICAgICAqIE5vdGUqIFVubGlrZSBhIFNwcml0ZSwgYSBUZXh0IG9iamVjdCB3aWxsIGF1dG9tYXRpY2FsbHkgZGVzdHJveSBpdHMgYmFzZVRleHR1cmUgYW5kIHRleHR1cmUgYXNcbiAgICAgKiB0aGUgbWFqb3JpdHkgb2YgdGhlIHRpbWUgdGhlIHRleHR1cmUgd2lsbCBub3QgYmUgc2hhcmVkIHdpdGggYW55IG90aGVyIFNwcml0ZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdHxib29sZWFufSBbb3B0aW9uc10gLSBPcHRpb25zIHBhcmFtZXRlci4gQSBib29sZWFuIHdpbGwgYWN0IGFzIGlmIGFsbCBvcHRpb25zXG4gICAgICogIGhhdmUgYmVlbiBzZXQgdG8gdGhhdCB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY2hpbGRyZW49ZmFsc2VdIC0gaWYgc2V0IHRvIHRydWUsIGFsbCB0aGUgY2hpbGRyZW4gd2lsbCBoYXZlIHRoZWlyXG4gICAgICogIGRlc3Ryb3kgbWV0aG9kIGNhbGxlZCBhcyB3ZWxsLiAnb3B0aW9ucycgd2lsbCBiZSBwYXNzZWQgb24gdG8gdGhvc2UgY2FsbHMuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50ZXh0dXJlPXRydWVdIC0gU2hvdWxkIGl0IGRlc3Ryb3kgdGhlIGN1cnJlbnQgdGV4dHVyZSBvZiB0aGUgc3ByaXRlIGFzIHdlbGxcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmJhc2VUZXh0dXJlPXRydWVdIC0gU2hvdWxkIGl0IGRlc3Ryb3kgdGhlIGJhc2UgdGV4dHVyZSBvZiB0aGUgc3ByaXRlIGFzIHdlbGxcbiAgICAgKi9cblxuXG4gICAgVGV4dC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3kob3B0aW9ucykge1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHsgY2hpbGRyZW46IG9wdGlvbnMgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0RGVzdHJveU9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgICAgIF9TcHJpdGUucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICAgICAgICAvLyBtYWtlIHN1cmUgdG8gcmVzZXQgdGhlIHRoZSBjb250ZXh0IGFuZCBjYW52YXMuLiBkb250IHdhbnQgdGhpcyBoYW5naW5nIGFyb3VuZCBpbiBtZW1vcnkhXG4gICAgICAgIHRoaXMuY29udGV4dCA9IG51bGw7XG4gICAgICAgIHRoaXMuY2FudmFzID0gbnVsbDtcblxuICAgICAgICB0aGlzLl9zdHlsZSA9IG51bGw7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB3aWR0aCBvZiB0aGUgVGV4dCwgc2V0dGluZyB0aGlzIHdpbGwgYWN0dWFsbHkgbW9kaWZ5IHRoZSBzY2FsZSB0byBhY2hpZXZlIHRoZSB2YWx1ZSBzZXRcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKi9cblxuXG4gICAgX2NyZWF0ZUNsYXNzKFRleHQsIFt7XG4gICAgICAgIGtleTogJ3dpZHRoJyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVRleHQodHJ1ZSk7XG5cbiAgICAgICAgICAgIHJldHVybiBNYXRoLmFicyh0aGlzLnNjYWxlLngpICogdGhpcy5fdGV4dHVyZS5vcmlnLndpZHRoO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSByZXF1aXJlLWpzZG9jXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVGV4dCh0cnVlKTtcblxuICAgICAgICAgICAgdmFyIHMgPSAoMCwgX3V0aWxzLnNpZ24pKHRoaXMuc2NhbGUueCkgfHwgMTtcblxuICAgICAgICAgICAgdGhpcy5zY2FsZS54ID0gcyAqIHZhbHVlIC8gdGhpcy5fdGV4dHVyZS5vcmlnLndpZHRoO1xuICAgICAgICAgICAgdGhpcy5fd2lkdGggPSB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgaGVpZ2h0IG9mIHRoZSBUZXh0LCBzZXR0aW5nIHRoaXMgd2lsbCBhY3R1YWxseSBtb2RpZnkgdGhlIHNjYWxlIHRvIGFjaGlldmUgdGhlIHZhbHVlIHNldFxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdoZWlnaHQnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVGV4dCh0cnVlKTtcblxuICAgICAgICAgICAgcmV0dXJuIE1hdGguYWJzKHRoaXMuc2NhbGUueSkgKiB0aGlzLl90ZXh0dXJlLm9yaWcuaGVpZ2h0O1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSByZXF1aXJlLWpzZG9jXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVGV4dCh0cnVlKTtcblxuICAgICAgICAgICAgdmFyIHMgPSAoMCwgX3V0aWxzLnNpZ24pKHRoaXMuc2NhbGUueSkgfHwgMTtcblxuICAgICAgICAgICAgdGhpcy5zY2FsZS55ID0gcyAqIHZhbHVlIC8gdGhpcy5fdGV4dHVyZS5vcmlnLmhlaWdodDtcbiAgICAgICAgICAgIHRoaXMuX2hlaWdodCA9IHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGUgc3R5bGUgb2YgdGhlIHRleHQuIFNldCB1cCBhbiBldmVudCBsaXN0ZW5lciB0byBsaXN0ZW4gZm9yIGNoYW5nZXMgb24gdGhlIHN0eWxlXG4gICAgICAgICAqIG9iamVjdCBhbmQgbWFyayB0aGUgdGV4dCBhcyBkaXJ0eS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7b2JqZWN0fFBJWEkuVGV4dFN0eWxlfVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnc3R5bGUnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdHlsZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoc3R5bGUpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcmVxdWlyZS1qc2RvY1xuICAgICAgICB7XG4gICAgICAgICAgICBzdHlsZSA9IHN0eWxlIHx8IHt9O1xuXG4gICAgICAgICAgICBpZiAoc3R5bGUgaW5zdGFuY2VvZiBfVGV4dFN0eWxlMi5kZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3R5bGUgPSBzdHlsZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3R5bGUgPSBuZXcgX1RleHRTdHlsZTIuZGVmYXVsdChzdHlsZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMubG9jYWxTdHlsZUlEID0gLTE7XG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhlIGNvcHkgZm9yIHRoZSB0ZXh0IG9iamVjdC4gVG8gc3BsaXQgYSBsaW5lIHlvdSBjYW4gdXNlICdcXG4nLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICd0ZXh0JyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGV4dDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodGV4dCkgLy8gZXNsaW50LWRpc2FibGUtbGluZSByZXF1aXJlLWpzZG9jXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRleHQgPSBTdHJpbmcodGV4dCA9PT0gJycgfHwgdGV4dCA9PT0gbnVsbCB8fCB0ZXh0ID09PSB1bmRlZmluZWQgPyAnICcgOiB0ZXh0KTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX3RleHQgPT09IHRleHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl90ZXh0ID0gdGV4dDtcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFRleHQ7XG59KF9TcHJpdGUzLmRlZmF1bHQpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBUZXh0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGV4dC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8qKlxuICogVGhlIFRleHRNZXRyaWNzIG9iamVjdCByZXByZXNlbnRzIHRoZSBtZWFzdXJlbWVudCBvZiBhIGJsb2NrIG9mIHRleHQgd2l0aCBhIHNwZWNpZmllZCBzdHlsZS5cbiAqXG4gKiBgYGBqc1xuICogbGV0IHN0eWxlID0gbmV3IFBJWEkuVGV4dFN0eWxlKHtmb250RmFtaWx5IDogJ0FyaWFsJywgZm9udFNpemU6IDI0LCBmaWxsIDogMHhmZjEwMTAsIGFsaWduIDogJ2NlbnRlcid9KVxuICogbGV0IHRleHRNZXRyaWNzID0gUElYSS5UZXh0TWV0cmljcy5tZWFzdXJlVGV4dCgnWW91ciB0ZXh0Jywgc3R5bGUpXG4gKiBgYGBcbiAqXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJPZiBQSVhJXG4gKi9cbnZhciBUZXh0TWV0cmljcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIHRoZSB0ZXh0IHRoYXQgd2FzIG1lYXN1cmVkXG4gICAgICogQHBhcmFtIHtQSVhJLlRleHRTdHlsZX0gc3R5bGUgLSB0aGUgc3R5bGUgdGhhdCB3YXMgbWVhc3VyZWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSB0aGUgbWVhc3VyZWQgd2lkdGggb2YgdGhlIHRleHRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IC0gdGhlIG1lYXN1cmVkIGhlaWdodCBvZiB0aGUgdGV4dFxuICAgICAqIEBwYXJhbSB7YXJyYXl9IGxpbmVzIC0gYW4gYXJyYXkgb2YgdGhlIGxpbmVzIG9mIHRleHQgYnJva2VuIGJ5IG5ldyBsaW5lcyBhbmQgd3JhcHBpbmcgaWYgc3BlY2lmaWVkIGluIHN0eWxlXG4gICAgICogQHBhcmFtIHthcnJheX0gbGluZVdpZHRocyAtIGFuIGFycmF5IG9mIHRoZSBsaW5lIHdpZHRocyBmb3IgZWFjaCBsaW5lIG1hdGNoZWQgdG8gYGxpbmVzYFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsaW5lSGVpZ2h0IC0gdGhlIG1lYXN1cmVkIGxpbmUgaGVpZ2h0IGZvciB0aGlzIHN0eWxlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1heExpbmVXaWR0aCAtIHRoZSBtYXhpbXVtIGxpbmUgd2lkdGggZm9yIGFsbCBtZWFzdXJlZCBsaW5lc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBmb250UHJvcGVydGllcyAtIHRoZSBmb250IHByb3BlcnRpZXMgb2JqZWN0IGZyb20gVGV4dE1ldHJpY3MubWVhc3VyZUZvbnRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBUZXh0TWV0cmljcyh0ZXh0LCBzdHlsZSwgd2lkdGgsIGhlaWdodCwgbGluZXMsIGxpbmVXaWR0aHMsIGxpbmVIZWlnaHQsIG1heExpbmVXaWR0aCwgZm9udFByb3BlcnRpZXMpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRleHRNZXRyaWNzKTtcblxuICAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgICAgICB0aGlzLnN0eWxlID0gc3R5bGU7XG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHRoaXMubGluZXMgPSBsaW5lcztcbiAgICAgICAgdGhpcy5saW5lV2lkdGhzID0gbGluZVdpZHRocztcbiAgICAgICAgdGhpcy5saW5lSGVpZ2h0ID0gbGluZUhlaWdodDtcbiAgICAgICAgdGhpcy5tYXhMaW5lV2lkdGggPSBtYXhMaW5lV2lkdGg7XG4gICAgICAgIHRoaXMuZm9udFByb3BlcnRpZXMgPSBmb250UHJvcGVydGllcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZWFzdXJlcyB0aGUgc3VwcGxpZWQgc3RyaW5nIG9mIHRleHQgYW5kIHJldHVybnMgYSBSZWN0YW5nbGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIHRoZSB0ZXh0IHRvIG1lYXN1cmUuXG4gICAgICogQHBhcmFtIHtQSVhJLlRleHRTdHlsZX0gc3R5bGUgLSB0aGUgdGV4dCBzdHlsZSB0byB1c2UgZm9yIG1lYXN1cmluZ1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3dvcmRXcmFwXSAtIG9wdGlvbmFsIG92ZXJyaWRlIGZvciBpZiB3b3JkLXdyYXAgc2hvdWxkIGJlIGFwcGxpZWQgdG8gdGhlIHRleHQuXG4gICAgICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gW2NhbnZhc10gLSBvcHRpb25hbCBzcGVjaWZpY2F0aW9uIG9mIHRoZSBjYW52YXMgdG8gdXNlIGZvciBtZWFzdXJpbmcuXG4gICAgICogQHJldHVybiB7UElYSS5UZXh0TWV0cmljc30gbWVhc3VyZWQgd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgdGV4dC5cbiAgICAgKi9cblxuXG4gICAgVGV4dE1ldHJpY3MubWVhc3VyZVRleHQgPSBmdW5jdGlvbiBtZWFzdXJlVGV4dCh0ZXh0LCBzdHlsZSwgd29yZFdyYXApIHtcbiAgICAgICAgdmFyIGNhbnZhcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogVGV4dE1ldHJpY3MuX2NhbnZhcztcblxuICAgICAgICB3b3JkV3JhcCA9IHdvcmRXcmFwID09PSB1bmRlZmluZWQgfHwgd29yZFdyYXAgPT09IG51bGwgPyBzdHlsZS53b3JkV3JhcCA6IHdvcmRXcmFwO1xuICAgICAgICB2YXIgZm9udCA9IHN0eWxlLnRvRm9udFN0cmluZygpO1xuICAgICAgICB2YXIgZm9udFByb3BlcnRpZXMgPSBUZXh0TWV0cmljcy5tZWFzdXJlRm9udChmb250KTtcbiAgICAgICAgdmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgICAgICBjb250ZXh0LmZvbnQgPSBmb250O1xuXG4gICAgICAgIHZhciBvdXRwdXRUZXh0ID0gd29yZFdyYXAgPyBUZXh0TWV0cmljcy53b3JkV3JhcCh0ZXh0LCBzdHlsZSwgY2FudmFzKSA6IHRleHQ7XG4gICAgICAgIHZhciBsaW5lcyA9IG91dHB1dFRleHQuc3BsaXQoLyg/OlxcclxcbnxcXHJ8XFxuKS8pO1xuICAgICAgICB2YXIgbGluZVdpZHRocyA9IG5ldyBBcnJheShsaW5lcy5sZW5ndGgpO1xuICAgICAgICB2YXIgbWF4TGluZVdpZHRoID0gMDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbGluZVdpZHRoID0gY29udGV4dC5tZWFzdXJlVGV4dChsaW5lc1tpXSkud2lkdGggKyAobGluZXNbaV0ubGVuZ3RoIC0gMSkgKiBzdHlsZS5sZXR0ZXJTcGFjaW5nO1xuXG4gICAgICAgICAgICBsaW5lV2lkdGhzW2ldID0gbGluZVdpZHRoO1xuICAgICAgICAgICAgbWF4TGluZVdpZHRoID0gTWF0aC5tYXgobWF4TGluZVdpZHRoLCBsaW5lV2lkdGgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB3aWR0aCA9IG1heExpbmVXaWR0aCArIHN0eWxlLnN0cm9rZVRoaWNrbmVzcztcblxuICAgICAgICBpZiAoc3R5bGUuZHJvcFNoYWRvdykge1xuICAgICAgICAgICAgd2lkdGggKz0gc3R5bGUuZHJvcFNoYWRvd0Rpc3RhbmNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxpbmVIZWlnaHQgPSBzdHlsZS5saW5lSGVpZ2h0IHx8IGZvbnRQcm9wZXJ0aWVzLmZvbnRTaXplICsgc3R5bGUuc3Ryb2tlVGhpY2tuZXNzO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gTWF0aC5tYXgobGluZUhlaWdodCwgZm9udFByb3BlcnRpZXMuZm9udFNpemUgKyBzdHlsZS5zdHJva2VUaGlja25lc3MpICsgKGxpbmVzLmxlbmd0aCAtIDEpICogKGxpbmVIZWlnaHQgKyBzdHlsZS5sZWFkaW5nKTtcblxuICAgICAgICBpZiAoc3R5bGUuZHJvcFNoYWRvdykge1xuICAgICAgICAgICAgaGVpZ2h0ICs9IHN0eWxlLmRyb3BTaGFkb3dEaXN0YW5jZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgVGV4dE1ldHJpY3ModGV4dCwgc3R5bGUsIHdpZHRoLCBoZWlnaHQsIGxpbmVzLCBsaW5lV2lkdGhzLCBsaW5lSGVpZ2h0ICsgc3R5bGUubGVhZGluZywgbWF4TGluZVdpZHRoLCBmb250UHJvcGVydGllcyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgbmV3bGluZXMgdG8gYSBzdHJpbmcgdG8gaGF2ZSBpdCBvcHRpbWFsbHkgZml0IGludG8gdGhlIGhvcml6b250YWxcbiAgICAgKiBib3VuZHMgc2V0IGJ5IHRoZSBUZXh0IG9iamVjdCdzIHdvcmRXcmFwV2lkdGggcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gU3RyaW5nIHRvIGFwcGx5IHdvcmQgd3JhcHBpbmcgdG9cbiAgICAgKiBAcGFyYW0ge1BJWEkuVGV4dFN0eWxlfSBzdHlsZSAtIHRoZSBzdHlsZSB0byB1c2Ugd2hlbiB3cmFwcGluZ1xuICAgICAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IFtjYW52YXNdIC0gb3B0aW9uYWwgc3BlY2lmaWNhdGlvbiBvZiB0aGUgY2FudmFzIHRvIHVzZSBmb3IgbWVhc3VyaW5nLlxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gTmV3IHN0cmluZyB3aXRoIG5ldyBsaW5lcyBhcHBsaWVkIHdoZXJlIHJlcXVpcmVkXG4gICAgICovXG5cblxuICAgIFRleHRNZXRyaWNzLndvcmRXcmFwID0gZnVuY3Rpb24gd29yZFdyYXAodGV4dCwgc3R5bGUpIHtcbiAgICAgICAgdmFyIGNhbnZhcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogVGV4dE1ldHJpY3MuX2NhbnZhcztcblxuICAgICAgICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgICAgIHZhciB3aWR0aCA9IDA7XG4gICAgICAgIHZhciBsaW5lID0gJyc7XG4gICAgICAgIHZhciBsaW5lcyA9ICcnO1xuXG4gICAgICAgIHZhciBjYWNoZSA9IHt9O1xuICAgICAgICB2YXIgbGV0dGVyU3BhY2luZyA9IHN0eWxlLmxldHRlclNwYWNpbmcsXG4gICAgICAgICAgICB3aGl0ZVNwYWNlID0gc3R5bGUud2hpdGVTcGFjZTtcblxuICAgICAgICAvLyBIb3cgdG8gaGFuZGxlIHdoaXRlc3BhY2VzXG5cbiAgICAgICAgdmFyIGNvbGxhcHNlU3BhY2VzID0gVGV4dE1ldHJpY3MuY29sbGFwc2VTcGFjZXMod2hpdGVTcGFjZSk7XG4gICAgICAgIHZhciBjb2xsYXBzZU5ld2xpbmVzID0gVGV4dE1ldHJpY3MuY29sbGFwc2VOZXdsaW5lcyh3aGl0ZVNwYWNlKTtcblxuICAgICAgICAvLyB3aGV0aGVyIG9yIG5vdCBzcGFjZXMgbWF5IGJlIGFkZGVkIHRvIHRoZSBiZWdpbm5pbmcgb2YgbGluZXNcbiAgICAgICAgdmFyIGNhblByZXBlbmRTcGFjZXMgPSAhY29sbGFwc2VTcGFjZXM7XG5cbiAgICAgICAgLy8gVGhlcmUgaXMgbGV0dGVyU3BhY2luZyBhZnRlciBldmVyeSBjaGFyIGV4Y2VwdCB0aGUgbGFzdCBvbmVcbiAgICAgICAgLy8gdF9oX2lfc18nICdfaV9zXycgJ19hX25fJyAnX2VfeF9hX21fcF9sX2VfJyAnXyFcbiAgICAgICAgLy8gc28gZm9yIGNvbnZlbmllbmNlIHRoZSBhYm92ZSBuZWVkcyB0byBiZSBjb21wYXJlZCB0byB3aWR0aCArIDEgZXh0cmEgbGV0dGVyU3BhY2VcbiAgICAgICAgLy8gdF9oX2lfc18nICdfaV9zXycgJ19hX25fJyAnX2VfeF9hX21fcF9sX2VfJyAnXyFfXG4gICAgICAgIC8vIF9fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX1xuICAgICAgICAvLyBBbmQgdGhlbiB0aGUgZmluYWwgc3BhY2UgaXMgc2ltcGx5IG5vIGFwcGVuZGVkIHRvIGVhY2ggbGluZVxuICAgICAgICB2YXIgd29yZFdyYXBXaWR0aCA9IHN0eWxlLndvcmRXcmFwV2lkdGggKyBsZXR0ZXJTcGFjaW5nO1xuXG4gICAgICAgIC8vIGJyZWFrIHRleHQgaW50byB3b3Jkcywgc3BhY2VzIGFuZCBuZXdsaW5lIGNoYXJzXG4gICAgICAgIHZhciB0b2tlbnMgPSBUZXh0TWV0cmljcy50b2tlbml6ZSh0ZXh0KTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgLy8gZ2V0IHRoZSB3b3JkLCBzcGFjZSBvciBuZXdsaW5lQ2hhclxuICAgICAgICAgICAgdmFyIHRva2VuID0gdG9rZW5zW2ldO1xuXG4gICAgICAgICAgICAvLyBpZiB3b3JkIGlzIGEgbmV3IGxpbmVcbiAgICAgICAgICAgIGlmIChUZXh0TWV0cmljcy5pc05ld2xpbmUodG9rZW4pKSB7XG4gICAgICAgICAgICAgICAgLy8ga2VlcCB0aGUgbmV3IGxpbmVcbiAgICAgICAgICAgICAgICBpZiAoIWNvbGxhcHNlTmV3bGluZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZXMgKz0gVGV4dE1ldHJpY3MuYWRkTGluZShsaW5lKTtcbiAgICAgICAgICAgICAgICAgICAgY2FuUHJlcGVuZFNwYWNlcyA9ICFjb2xsYXBzZVNwYWNlcztcbiAgICAgICAgICAgICAgICAgICAgbGluZSA9ICcnO1xuICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGlmIHdlIHNob3VsZCBjb2xsYXBzZSBuZXcgbGluZXNcbiAgICAgICAgICAgICAgICAvLyB3ZSBzaW1wbHkgY29udmVydCBpdCBpbnRvIGEgc3BhY2VcbiAgICAgICAgICAgICAgICB0b2tlbiA9ICcgJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgd2Ugc2hvdWxkIGNvbGxhcHNlIHJlcGVhdGVkIHdoaXRlc3BhY2VzXG4gICAgICAgICAgICBpZiAoY29sbGFwc2VTcGFjZXMpIHtcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBib3RoIHRoaXMgYW5kIHRoZSBsYXN0IHRva2VucyBmb3Igc3BhY2VzXG4gICAgICAgICAgICAgICAgdmFyIGN1cnJJc0JyZWFraW5nU3BhY2UgPSBUZXh0TWV0cmljcy5pc0JyZWFraW5nU3BhY2UodG9rZW4pO1xuICAgICAgICAgICAgICAgIHZhciBsYXN0SXNCcmVha2luZ1NwYWNlID0gVGV4dE1ldHJpY3MuaXNCcmVha2luZ1NwYWNlKGxpbmVbbGluZS5sZW5ndGggLSAxXSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoY3VycklzQnJlYWtpbmdTcGFjZSAmJiBsYXN0SXNCcmVha2luZ1NwYWNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZ2V0IHdvcmQgd2lkdGggZnJvbSBjYWNoZSBpZiBwb3NzaWJsZVxuICAgICAgICAgICAgdmFyIHRva2VuV2lkdGggPSBUZXh0TWV0cmljcy5nZXRGcm9tQ2FjaGUodG9rZW4sIGxldHRlclNwYWNpbmcsIGNhY2hlLCBjb250ZXh0KTtcblxuICAgICAgICAgICAgLy8gd29yZCBpcyBsb25nZXIgdGhhbiBkZXNpcmVkIGJvdW5kc1xuICAgICAgICAgICAgaWYgKHRva2VuV2lkdGggPiB3b3JkV3JhcFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgd2UgYXJlIG5vdCBhbHJlYWR5IGF0IHRoZSBiZWdpbm5pbmcgb2YgYSBsaW5lXG4gICAgICAgICAgICAgICAgaWYgKGxpbmUgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHN0YXJ0IG5ld2xpbmVzIGZvciBvdmVyZmxvdyB3b3Jkc1xuICAgICAgICAgICAgICAgICAgICBsaW5lcyArPSBUZXh0TWV0cmljcy5hZGRMaW5lKGxpbmUpO1xuICAgICAgICAgICAgICAgICAgICBsaW5lID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoID0gMDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBicmVhayBsYXJnZSB3b3JkIG92ZXIgbXVsdGlwbGUgbGluZXNcbiAgICAgICAgICAgICAgICBpZiAoVGV4dE1ldHJpY3MuY2FuQnJlYWtXb3Jkcyh0b2tlbiwgc3R5bGUuYnJlYWtXb3JkcykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYnJlYWsgd29yZCBpbnRvIGNoYXJhY3RlcnNcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoYXJhY3RlcnMgPSB0b2tlbi5zcGxpdCgnJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gbG9vcCB0aGUgY2hhcmFjdGVyc1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNoYXJhY3RlcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaGFyID0gY2hhcmFjdGVyc1tqXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGsgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgYXJlIG5vdCBhdCB0aGUgZW5kIG9mIHRoZSB0b2tlblxuXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoY2hhcmFjdGVyc1tqICsga10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dENoYXIgPSBjaGFyYWN0ZXJzW2ogKyBrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGFzdENoYXIgPSBjaGFyW2NoYXIubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzaG91bGQgbm90IHNwbGl0IGNoYXJzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFUZXh0TWV0cmljcy5jYW5CcmVha0NoYXJzKGxhc3RDaGFyLCBuZXh0Q2hhciwgdG9rZW4sIGosIHN0eWxlLmJyZWFrV29yZHMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbWJpbmUgY2hhcnMgJiBtb3ZlIGZvcndhcmQgb25lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYXIgKz0gbmV4dENoYXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaysrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBqICs9IGNoYXIubGVuZ3RoIC0gMTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNoYXJhY3RlcldpZHRoID0gVGV4dE1ldHJpY3MuZ2V0RnJvbUNhY2hlKGNoYXIsIGxldHRlclNwYWNpbmcsIGNhY2hlLCBjb250ZXh0KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoYXJhY3RlcldpZHRoICsgd2lkdGggPiB3b3JkV3JhcFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZXMgKz0gVGV4dE1ldHJpY3MuYWRkTGluZShsaW5lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5QcmVwZW5kU3BhY2VzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZSA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZSArPSBjaGFyO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGggKz0gY2hhcmFjdGVyV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBydW4gd29yZCBvdXQgb2YgdGhlIGJvdW5kc1xuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgYXJlIHdvcmRzIGluIHRoaXMgbGluZSBhbHJlYWR5XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmaW5pc2ggdGhhdCBsaW5lIGFuZCBzdGFydCBhIG5ldyBvbmVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsaW5lLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lcyArPSBUZXh0TWV0cmljcy5hZGRMaW5lKGxpbmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmUgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpc0xhc3RUb2tlbiA9IGkgPT09IHRva2Vucy5sZW5ndGggLSAxO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBnaXZlIGl0IGl0cyBvd24gbGluZSBpZiBpdCdzIG5vdCB0aGUgZW5kXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lcyArPSBUZXh0TWV0cmljcy5hZGRMaW5lKHRva2VuLCAhaXNMYXN0VG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FuUHJlcGVuZFNwYWNlcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGluZSA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGggPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHdvcmQgY291bGQgZml0XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gd29yZCB3b24ndCBmaXQgYmVjYXVzZSBvZiBleGlzdGluZyB3b3Jkc1xuICAgICAgICAgICAgICAgICAgICAvLyBzdGFydCBhIG5ldyBsaW5lXG4gICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbldpZHRoICsgd2lkdGggPiB3b3JkV3JhcFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBpdHMgYSBzcGFjZSB3ZSBkb24ndCB3YW50IGl0XG4gICAgICAgICAgICAgICAgICAgICAgICBjYW5QcmVwZW5kU3BhY2VzID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkZCBhIG5ldyBsaW5lXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lcyArPSBUZXh0TWV0cmljcy5hZGRMaW5lKGxpbmUpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzdGFydCBhIG5ldyBsaW5lXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lID0gJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBkb24ndCBhZGQgc3BhY2VzIHRvIHRoZSBiZWdpbm5pbmcgb2YgbGluZXNcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmUubGVuZ3RoID4gMCB8fCAhVGV4dE1ldHJpY3MuaXNCcmVha2luZ1NwYWNlKHRva2VuKSB8fCBjYW5QcmVwZW5kU3BhY2VzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGQgdGhlIHdvcmQgdG8gdGhlIGN1cnJlbnQgbGluZVxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZSArPSB0b2tlbjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlIHdpZHRoIGNvdW50ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoICs9IHRva2VuV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsaW5lcyArPSBUZXh0TWV0cmljcy5hZGRMaW5lKGxpbmUsIGZhbHNlKTtcblxuICAgICAgICByZXR1cm4gbGluZXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvbnZpZW5pZW5jZSBmdW5jdGlvbiBmb3IgbG9nZ2luZyBlYWNoIGxpbmUgYWRkZWQgZHVyaW5nIHRoZSB3b3JkV3JhcFxuICAgICAqIG1ldGhvZFxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9ICAgbGluZSAgICAgICAgLSBUaGUgbGluZSBvZiB0ZXh0IHRvIGFkZFxuICAgICAqIEBwYXJhbSAge2Jvb2xlYW59ICBuZXdMaW5lICAgICAtIEFkZCBuZXcgbGluZSBjaGFyYWN0ZXIgdG8gZW5kXG4gICAgICogQHJldHVybiB7c3RyaW5nfSAgIEEgZm9ybWF0dGVkIGxpbmVcbiAgICAgKi9cblxuXG4gICAgVGV4dE1ldHJpY3MuYWRkTGluZSA9IGZ1bmN0aW9uIGFkZExpbmUobGluZSkge1xuICAgICAgICB2YXIgbmV3TGluZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcblxuICAgICAgICBsaW5lID0gVGV4dE1ldHJpY3MudHJpbVJpZ2h0KGxpbmUpO1xuXG4gICAgICAgIGxpbmUgPSBuZXdMaW5lID8gbGluZSArICdcXG4nIDogbGluZTtcblxuICAgICAgICByZXR1cm4gbGluZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyAmIHNldHMgdGhlIHdpZHRocyBvZiBjYWxjdWxhdGVkIGNoYXJhY3RlcnMgaW4gYSBjYWNoZSBvYmplY3RcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSAgICAgICAgICAgICAgICAgICAga2V5ICAgICAgICAgICAgVGhlIGtleVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gICAgICAgICAgICAgICAgICAgIGxldHRlclNwYWNpbmcgIFRoZSBsZXR0ZXIgc3BhY2luZ1xuICAgICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgIGNhY2hlICAgICAgICAgIFRoZSBjYWNoZVxuICAgICAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gIGNvbnRleHQgICAgICAgIFRoZSBjYW52YXMgY29udGV4dFxuICAgICAqIEByZXR1cm4ge251bWJlcn0gICAgICAgICAgICAgICAgICAgIFRoZSBmcm9tIGNhY2hlLlxuICAgICAqL1xuXG5cbiAgICBUZXh0TWV0cmljcy5nZXRGcm9tQ2FjaGUgPSBmdW5jdGlvbiBnZXRGcm9tQ2FjaGUoa2V5LCBsZXR0ZXJTcGFjaW5nLCBjYWNoZSwgY29udGV4dCkge1xuICAgICAgICB2YXIgd2lkdGggPSBjYWNoZVtrZXldO1xuXG4gICAgICAgIGlmICh3aWR0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgc3BhY2luZyA9IGtleS5sZW5ndGggKiBsZXR0ZXJTcGFjaW5nO1xuXG4gICAgICAgICAgICB3aWR0aCA9IGNvbnRleHQubWVhc3VyZVRleHQoa2V5KS53aWR0aCArIHNwYWNpbmc7XG4gICAgICAgICAgICBjYWNoZVtrZXldID0gd2lkdGg7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gd2lkdGg7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgd2hldGhlciB3ZSBzaG91bGQgY29sbGFwc2UgYnJlYWtpbmcgc3BhY2VzXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gICB3aGl0ZVNwYWNlICBUaGUgVGV4dFN0eWxlIHByb3BlcnR5IHdoaXRlU3BhY2VcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSAgc2hvdWxkIGNvbGxhcHNlXG4gICAgICovXG5cblxuICAgIFRleHRNZXRyaWNzLmNvbGxhcHNlU3BhY2VzID0gZnVuY3Rpb24gY29sbGFwc2VTcGFjZXMod2hpdGVTcGFjZSkge1xuICAgICAgICByZXR1cm4gd2hpdGVTcGFjZSA9PT0gJ25vcm1hbCcgfHwgd2hpdGVTcGFjZSA9PT0gJ3ByZS1saW5lJztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHdlIHNob3VsZCBjb2xsYXBzZSBuZXdMaW5lIGNoYXJzXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gICB3aGl0ZVNwYWNlICBUaGUgd2hpdGUgc3BhY2VcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSAgc2hvdWxkIGNvbGxhcHNlXG4gICAgICovXG5cblxuICAgIFRleHRNZXRyaWNzLmNvbGxhcHNlTmV3bGluZXMgPSBmdW5jdGlvbiBjb2xsYXBzZU5ld2xpbmVzKHdoaXRlU3BhY2UpIHtcbiAgICAgICAgcmV0dXJuIHdoaXRlU3BhY2UgPT09ICdub3JtYWwnO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiB0cmltcyBicmVha2luZyB3aGl0ZXNwYWNlcyBmcm9tIHN0cmluZ1xuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9ICB0ZXh0ICBUaGUgdGV4dFxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gIHRyaW1tZWQgc3RyaW5nXG4gICAgICovXG5cblxuICAgIFRleHRNZXRyaWNzLnRyaW1SaWdodCA9IGZ1bmN0aW9uIHRyaW1SaWdodCh0ZXh0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGV4dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSB0ZXh0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICB2YXIgY2hhciA9IHRleHRbaV07XG5cbiAgICAgICAgICAgIGlmICghVGV4dE1ldHJpY3MuaXNCcmVha2luZ1NwYWNlKGNoYXIpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRleHQgPSB0ZXh0LnNsaWNlKDAsIC0xKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGlmIGNoYXIgaXMgYSBuZXdsaW5lLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9ICBjaGFyICBUaGUgY2hhcmFjdGVyXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gIFRydWUgaWYgbmV3bGluZSwgRmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuXG5cbiAgICBUZXh0TWV0cmljcy5pc05ld2xpbmUgPSBmdW5jdGlvbiBpc05ld2xpbmUoY2hhcikge1xuICAgICAgICBpZiAodHlwZW9mIGNoYXIgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gVGV4dE1ldHJpY3MuX25ld2xpbmVzLmluZGV4T2YoY2hhci5jaGFyQ29kZUF0KDApKSA+PSAwO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGlmIGNoYXIgaXMgYSBicmVha2luZyB3aGl0ZXNwYWNlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9ICBjaGFyICBUaGUgY2hhcmFjdGVyXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gIFRydWUgaWYgd2hpdGVzcGFjZSwgRmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuXG5cbiAgICBUZXh0TWV0cmljcy5pc0JyZWFraW5nU3BhY2UgPSBmdW5jdGlvbiBpc0JyZWFraW5nU3BhY2UoY2hhcikge1xuICAgICAgICBpZiAodHlwZW9mIGNoYXIgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gVGV4dE1ldHJpY3MuX2JyZWFraW5nU3BhY2VzLmluZGV4T2YoY2hhci5jaGFyQ29kZUF0KDApKSA+PSAwO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTcGxpdHMgYSBzdHJpbmcgaW50byB3b3JkcywgYnJlYWtpbmctc3BhY2VzIGFuZCBuZXdMaW5lIGNoYXJhY3RlcnNcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSAgdGV4dCAgICAgICBUaGUgdGV4dFxuICAgICAqIEByZXR1cm4ge2FycmF5fSAgQSB0b2tlbml6ZWQgYXJyYXlcbiAgICAgKi9cblxuXG4gICAgVGV4dE1ldHJpY3MudG9rZW5pemUgPSBmdW5jdGlvbiB0b2tlbml6ZSh0ZXh0KSB7XG4gICAgICAgIHZhciB0b2tlbnMgPSBbXTtcbiAgICAgICAgdmFyIHRva2VuID0gJyc7XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0ZXh0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHRva2VucztcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNoYXIgPSB0ZXh0W2ldO1xuXG4gICAgICAgICAgICBpZiAoVGV4dE1ldHJpY3MuaXNCcmVha2luZ1NwYWNlKGNoYXIpIHx8IFRleHRNZXRyaWNzLmlzTmV3bGluZShjaGFyKSkge1xuICAgICAgICAgICAgICAgIGlmICh0b2tlbiAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9ICcnO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKGNoYXIpO1xuXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRva2VuICs9IGNoYXI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodG9rZW4gIT09ICcnKSB7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdG9rZW5zO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBleGlzdHMgdG8gYmUgZWFzaWx5IG92ZXJyaWRkZW5cbiAgICAgKiBJdCBhbGxvd3Mgb25lIHRvIGN1c3RvbWlzZSB3aGljaCB3b3JkcyBzaG91bGQgYnJlYWtcbiAgICAgKiBFeGFtcGxlcyBhcmUgaWYgdGhlIHRva2VuIGlzIENKSyBvciBudW1iZXJzLlxuICAgICAqIEl0IG11c3QgcmV0dXJuIGEgYm9vbGVhbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSAgdG9rZW4gICAgICAgVGhlIHRva2VuXG4gICAgICogQHBhcmFtICB7Ym9vbGVhbn0gIGJyZWFrV29yZHMgIFRoZSBzdHlsZSBhdHRyIGJyZWFrIHdvcmRzXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gd2hldGhlciB0byBicmVhayB3b3JkIG9yIG5vdFxuICAgICAqL1xuXG5cbiAgICBUZXh0TWV0cmljcy5jYW5CcmVha1dvcmRzID0gZnVuY3Rpb24gY2FuQnJlYWtXb3Jkcyh0b2tlbiwgYnJlYWtXb3Jkcykge1xuICAgICAgICByZXR1cm4gYnJlYWtXb3JkcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgZXhpc3RzIHRvIGJlIGVhc2lseSBvdmVycmlkZGVuXG4gICAgICogSXQgYWxsb3dzIG9uZSB0byBkZXRlcm1pbmUgd2hldGhlciBhIHBhaXIgb2YgY2hhcmFjdGVyc1xuICAgICAqIHNob3VsZCBiZSBicm9rZW4gYnkgbmV3bGluZXNcbiAgICAgKiBGb3IgZXhhbXBsZSBjZXJ0YWluIGNoYXJhY3RlcnMgaW4gQ0pLIGxhbmdzIG9yIG51bWJlcnMuXG4gICAgICogSXQgbXVzdCByZXR1cm4gYSBib29sZWFuLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9ICBjaGFyICAgICAgVGhlIGNoYXJhY3RlclxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gIG5leHRDaGFyICBUaGUgbmV4dCBjaGFyYWN0ZXJcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9ICB0b2tlbiAgICAgVGhlIHRva2VuL3dvcmQgdGhlIGNoYXJhY3RlcnMgYXJlIGZyb21cbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICBpbmRleCAgICAgVGhlIGluZGV4IGluIHRoZSB0b2tlbiBvZiB0aGUgY2hhclxuICAgICAqIEBwYXJhbSAge2Jvb2xlYW59ICBicmVha1dvcmRzICBUaGUgc3R5bGUgYXR0ciBicmVhayB3b3Jkc1xuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IHdoZXRoZXIgdG8gYnJlYWsgd29yZCBvciBub3RcbiAgICAgKi9cblxuXG4gICAgVGV4dE1ldHJpY3MuY2FuQnJlYWtDaGFycyA9IGZ1bmN0aW9uIGNhbkJyZWFrQ2hhcnMoY2hhciwgbmV4dENoYXIsIHRva2VuLCBpbmRleCwgYnJlYWtXb3JkcykgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIGFzY2VudCwgZGVzY2VudCBhbmQgZm9udFNpemUgb2YgYSBnaXZlbiBmb250LXN0eWxlXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZvbnQgLSBTdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBzdHlsZSBvZiB0aGUgZm9udFxuICAgICAqIEByZXR1cm4ge1BJWEkuVGV4dE1ldHJpY3N+Rm9udE1ldHJpY3N9IEZvbnQgcHJvcGVydGllcyBvYmplY3RcbiAgICAgKi9cblxuXG4gICAgVGV4dE1ldHJpY3MubWVhc3VyZUZvbnQgPSBmdW5jdGlvbiBtZWFzdXJlRm9udChmb250KSB7XG4gICAgICAgIC8vIGFzIHRoaXMgbWV0aG9kIGlzIHVzZWQgZm9yIHByZXBhcmluZyBhc3NldHMsIGRvbid0IHJlY2FsY3VsYXRlIHRoaW5ncyBpZiB3ZSBkb24ndCBuZWVkIHRvXG4gICAgICAgIGlmIChUZXh0TWV0cmljcy5fZm9udHNbZm9udF0pIHtcbiAgICAgICAgICAgIHJldHVybiBUZXh0TWV0cmljcy5fZm9udHNbZm9udF07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcHJvcGVydGllcyA9IHt9O1xuXG4gICAgICAgIHZhciBjYW52YXMgPSBUZXh0TWV0cmljcy5fY2FudmFzO1xuICAgICAgICB2YXIgY29udGV4dCA9IFRleHRNZXRyaWNzLl9jb250ZXh0O1xuXG4gICAgICAgIGNvbnRleHQuZm9udCA9IGZvbnQ7XG5cbiAgICAgICAgdmFyIG1ldHJpY3NTdHJpbmcgPSBUZXh0TWV0cmljcy5NRVRSSUNTX1NUUklORyArIFRleHRNZXRyaWNzLkJBU0VMSU5FX1NZTUJPTDtcbiAgICAgICAgdmFyIHdpZHRoID0gTWF0aC5jZWlsKGNvbnRleHQubWVhc3VyZVRleHQobWV0cmljc1N0cmluZykud2lkdGgpO1xuICAgICAgICB2YXIgYmFzZWxpbmUgPSBNYXRoLmNlaWwoY29udGV4dC5tZWFzdXJlVGV4dChUZXh0TWV0cmljcy5CQVNFTElORV9TWU1CT0wpLndpZHRoKTtcbiAgICAgICAgdmFyIGhlaWdodCA9IDIgKiBiYXNlbGluZTtcblxuICAgICAgICBiYXNlbGluZSA9IGJhc2VsaW5lICogVGV4dE1ldHJpY3MuQkFTRUxJTkVfTVVMVElQTElFUiB8IDA7XG5cbiAgICAgICAgY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSAnI2YwMCc7XG4gICAgICAgIGNvbnRleHQuZmlsbFJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG5cbiAgICAgICAgY29udGV4dC5mb250ID0gZm9udDtcblxuICAgICAgICBjb250ZXh0LnRleHRCYXNlbGluZSA9ICdhbHBoYWJldGljJztcbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSAnIzAwMCc7XG4gICAgICAgIGNvbnRleHQuZmlsbFRleHQobWV0cmljc1N0cmluZywgMCwgYmFzZWxpbmUpO1xuXG4gICAgICAgIHZhciBpbWFnZWRhdGEgPSBjb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCB3aWR0aCwgaGVpZ2h0KS5kYXRhO1xuICAgICAgICB2YXIgcGl4ZWxzID0gaW1hZ2VkYXRhLmxlbmd0aDtcbiAgICAgICAgdmFyIGxpbmUgPSB3aWR0aCAqIDQ7XG5cbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgaWR4ID0gMDtcbiAgICAgICAgdmFyIHN0b3AgPSBmYWxzZTtcblxuICAgICAgICAvLyBhc2NlbnQuIHNjYW4gZnJvbSB0b3AgdG8gYm90dG9tIHVudGlsIHdlIGZpbmQgYSBub24gcmVkIHBpeGVsXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBiYXNlbGluZTsgKytpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxpbmU7IGogKz0gNCkge1xuICAgICAgICAgICAgICAgIGlmIChpbWFnZWRhdGFbaWR4ICsgal0gIT09IDI1NSkge1xuICAgICAgICAgICAgICAgICAgICBzdG9wID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFzdG9wKSB7XG4gICAgICAgICAgICAgICAgaWR4ICs9IGxpbmU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcHJvcGVydGllcy5hc2NlbnQgPSBiYXNlbGluZSAtIGk7XG5cbiAgICAgICAgaWR4ID0gcGl4ZWxzIC0gbGluZTtcbiAgICAgICAgc3RvcCA9IGZhbHNlO1xuXG4gICAgICAgIC8vIGRlc2NlbnQuIHNjYW4gZnJvbSBib3R0b20gdG8gdG9wIHVudGlsIHdlIGZpbmQgYSBub24gcmVkIHBpeGVsXG4gICAgICAgIGZvciAoaSA9IGhlaWdodDsgaSA+IGJhc2VsaW5lOyAtLWkpIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9qID0gMDsgX2ogPCBsaW5lOyBfaiArPSA0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGltYWdlZGF0YVtpZHggKyBfal0gIT09IDI1NSkge1xuICAgICAgICAgICAgICAgICAgICBzdG9wID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXN0b3ApIHtcbiAgICAgICAgICAgICAgICBpZHggLT0gbGluZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBwcm9wZXJ0aWVzLmRlc2NlbnQgPSBpIC0gYmFzZWxpbmU7XG4gICAgICAgIHByb3BlcnRpZXMuZm9udFNpemUgPSBwcm9wZXJ0aWVzLmFzY2VudCArIHByb3BlcnRpZXMuZGVzY2VudDtcblxuICAgICAgICBUZXh0TWV0cmljcy5fZm9udHNbZm9udF0gPSBwcm9wZXJ0aWVzO1xuXG4gICAgICAgIHJldHVybiBwcm9wZXJ0aWVzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDbGVhciBmb250IG1ldHJpY3MgaW4gbWV0cmljcyBjYWNoZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2ZvbnRdIC0gZm9udCBuYW1lLiBJZiBmb250IG5hbWUgbm90IHNldCB0aGVuIGNsZWFyIGNhY2hlIGZvciBhbGwgZm9udHMuXG4gICAgICovXG5cblxuICAgIFRleHRNZXRyaWNzLmNsZWFyTWV0cmljcyA9IGZ1bmN0aW9uIGNsZWFyTWV0cmljcygpIHtcbiAgICAgICAgdmFyIGZvbnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6ICcnO1xuXG4gICAgICAgIGlmIChmb250KSB7XG4gICAgICAgICAgICBkZWxldGUgVGV4dE1ldHJpY3MuX2ZvbnRzW2ZvbnRdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgVGV4dE1ldHJpY3MuX2ZvbnRzID0ge307XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIFRleHRNZXRyaWNzO1xufSgpO1xuXG4vKipcbiAqIEludGVybmFsIHJldHVybiBvYmplY3QgZm9yIHtAbGluayBQSVhJLlRleHRNZXRyaWNzLm1lYXN1cmVGb250IGBUZXh0TWV0cmljcy5tZWFzdXJlRm9udGB9LlxuICogQGNsYXNzIEZvbnRNZXRyaWNzXG4gKiBAbWVtYmVyb2YgUElYSS5UZXh0TWV0cmljc35cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBhc2NlbnQgLSBUaGUgYXNjZW50IGRpc3RhbmNlXG4gKiBAcHJvcGVydHkge251bWJlcn0gZGVzY2VudCAtIFRoZSBkZXNjZW50IGRpc3RhbmNlXG4gKiBAcHJvcGVydHkge251bWJlcn0gZm9udFNpemUgLSBGb250IHNpemUgZnJvbSBhc2NlbnQgdG8gZGVzY2VudFxuICovXG5cbmV4cG9ydHMuZGVmYXVsdCA9IFRleHRNZXRyaWNzO1xudmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuXG5jYW52YXMud2lkdGggPSBjYW52YXMuaGVpZ2h0ID0gMTA7XG5cbi8qKlxuICogQ2FjaGVkIGNhbnZhcyBlbGVtZW50IGZvciBtZWFzdXJpbmcgdGV4dFxuICogQG1lbWJlcm9mIFBJWEkuVGV4dE1ldHJpY3NcbiAqIEB0eXBlIHtIVE1MQ2FudmFzRWxlbWVudH1cbiAqIEBwcml2YXRlXG4gKi9cblRleHRNZXRyaWNzLl9jYW52YXMgPSBjYW52YXM7XG5cbi8qKlxuICogQ2FjaGUgZm9yIGNvbnRleHQgdG8gdXNlLlxuICogQG1lbWJlcm9mIFBJWEkuVGV4dE1ldHJpY3NcbiAqIEB0eXBlIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9XG4gKiBAcHJpdmF0ZVxuICovXG5UZXh0TWV0cmljcy5fY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4vKipcbiAqIENhY2hlIG9mIFBJWEkuVGV4dE1ldHJpY3N+Rm9udE1ldHJpY3Mgb2JqZWN0cy5cbiAqIEBtZW1iZXJvZiBQSVhJLlRleHRNZXRyaWNzXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xuVGV4dE1ldHJpY3MuX2ZvbnRzID0ge307XG5cbi8qKlxuICogU3RyaW5nIHVzZWQgZm9yIGNhbGN1bGF0ZSBmb250IG1ldHJpY3MuXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyb2YgUElYSS5UZXh0TWV0cmljc1xuICogQG5hbWUgTUVUUklDU19TVFJJTkdcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAZGVmYXVsdCB8w4lxXG4gKi9cblRleHRNZXRyaWNzLk1FVFJJQ1NfU1RSSU5HID0gJ3zDiXEnO1xuXG4vKipcbiAqIEJhc2VsaW5lIHN5bWJvbCBmb3IgY2FsY3VsYXRlIGZvbnQgbWV0cmljcy5cbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJvZiBQSVhJLlRleHRNZXRyaWNzXG4gKiBAbmFtZSBCQVNFTElORV9TWU1CT0xcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAZGVmYXVsdCBNXG4gKi9cblRleHRNZXRyaWNzLkJBU0VMSU5FX1NZTUJPTCA9ICdNJztcblxuLyoqXG4gKiBCYXNlbGluZSBtdWx0aXBsaWVyIGZvciBjYWxjdWxhdGUgZm9udCBtZXRyaWNzLlxuICogQHN0YXRpY1xuICogQG1lbWJlcm9mIFBJWEkuVGV4dE1ldHJpY3NcbiAqIEBuYW1lIEJBU0VMSU5FX01VTFRJUExJRVJcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAZGVmYXVsdCAxLjRcbiAqL1xuVGV4dE1ldHJpY3MuQkFTRUxJTkVfTVVMVElQTElFUiA9IDEuNDtcblxuLyoqXG4gKiBDYWNoZSBvZiBuZXcgbGluZSBjaGFycy5cbiAqIEBtZW1iZXJvZiBQSVhJLlRleHRNZXRyaWNzXG4gKiBAdHlwZSB7bnVtYmVyW119XG4gKiBAcHJpdmF0ZVxuICovXG5UZXh0TWV0cmljcy5fbmV3bGluZXMgPSBbMHgwMDBBLCAvLyBsaW5lIGZlZWRcbjB4MDAwRF07XG5cbi8qKlxuICogQ2FjaGUgb2YgYnJlYWtpbmcgc3BhY2VzLlxuICogQG1lbWJlcm9mIFBJWEkuVGV4dE1ldHJpY3NcbiAqIEB0eXBlIHtudW1iZXJbXX1cbiAqIEBwcml2YXRlXG4gKi9cblRleHRNZXRyaWNzLl9icmVha2luZ1NwYWNlcyA9IFsweDAwMDksIC8vIGNoYXJhY3RlciB0YWJ1bGF0aW9uXG4weDAwMjAsIC8vIHNwYWNlXG4weDIwMDAsIC8vIGVuIHF1YWRcbjB4MjAwMSwgLy8gZW0gcXVhZFxuMHgyMDAyLCAvLyBlbiBzcGFjZVxuMHgyMDAzLCAvLyBlbSBzcGFjZVxuMHgyMDA0LCAvLyB0aHJlZS1wZXItZW0gc3BhY2VcbjB4MjAwNSwgLy8gZm91ci1wZXItZW0gc3BhY2VcbjB4MjAwNiwgLy8gc2l4LXBlci1lbSBzcGFjZVxuMHgyMDA4LCAvLyBwdW5jdHVhdGlvbiBzcGFjZVxuMHgyMDA5LCAvLyB0aGluIHNwYWNlXG4weDIwMEEsIC8vIGhhaXIgc3BhY2VcbjB4MjA1RiwgLy8gbWVkaXVtIG1hdGhlbWF0aWNhbCBzcGFjZVxuMHgzMDAwXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRleHRNZXRyaWNzLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTsgLy8gZGlzYWJsaW5nIGVzbGludCBmb3Igbm93LCBnb2luZyB0byByZXdyaXRlIHRoaXMgaW4gdjVcbi8qIGVzbGludC1kaXNhYmxlICovXG5cbnZhciBfY29uc3QgPSByZXF1aXJlKCcuLi9jb25zdCcpO1xuXG52YXIgX3V0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIGRlZmF1bHRTdHlsZSA9IHtcbiAgICBhbGlnbjogJ2xlZnQnLFxuICAgIGJyZWFrV29yZHM6IGZhbHNlLFxuICAgIGRyb3BTaGFkb3c6IGZhbHNlLFxuICAgIGRyb3BTaGFkb3dBbHBoYTogMSxcbiAgICBkcm9wU2hhZG93QW5nbGU6IE1hdGguUEkgLyA2LFxuICAgIGRyb3BTaGFkb3dCbHVyOiAwLFxuICAgIGRyb3BTaGFkb3dDb2xvcjogJ2JsYWNrJyxcbiAgICBkcm9wU2hhZG93RGlzdGFuY2U6IDUsXG4gICAgZmlsbDogJ2JsYWNrJyxcbiAgICBmaWxsR3JhZGllbnRUeXBlOiBfY29uc3QuVEVYVF9HUkFESUVOVC5MSU5FQVJfVkVSVElDQUwsXG4gICAgZmlsbEdyYWRpZW50U3RvcHM6IFtdLFxuICAgIGZvbnRGYW1pbHk6ICdBcmlhbCcsXG4gICAgZm9udFNpemU6IDI2LFxuICAgIGZvbnRTdHlsZTogJ25vcm1hbCcsXG4gICAgZm9udFZhcmlhbnQ6ICdub3JtYWwnLFxuICAgIGZvbnRXZWlnaHQ6ICdub3JtYWwnLFxuICAgIGxldHRlclNwYWNpbmc6IDAsXG4gICAgbGluZUhlaWdodDogMCxcbiAgICBsaW5lSm9pbjogJ21pdGVyJyxcbiAgICBtaXRlckxpbWl0OiAxMCxcbiAgICBwYWRkaW5nOiAwLFxuICAgIHN0cm9rZTogJ2JsYWNrJyxcbiAgICBzdHJva2VUaGlja25lc3M6IDAsXG4gICAgdGV4dEJhc2VsaW5lOiAnYWxwaGFiZXRpYycsXG4gICAgdHJpbTogZmFsc2UsXG4gICAgd2hpdGVTcGFjZTogJ3ByZScsXG4gICAgd29yZFdyYXA6IGZhbHNlLFxuICAgIHdvcmRXcmFwV2lkdGg6IDEwMCxcbiAgICBsZWFkaW5nOiAwXG59O1xuXG52YXIgZ2VuZXJpY0ZvbnRGYW1pbGllcyA9IFsnc2VyaWYnLCAnc2Fucy1zZXJpZicsICdtb25vc3BhY2UnLCAnY3Vyc2l2ZScsICdmYW50YXN5JywgJ3N5c3RlbS11aSddO1xuXG4vKipcbiAqIEEgVGV4dFN0eWxlIE9iamVjdCBkZWNvcmF0ZXMgYSBUZXh0IE9iamVjdC4gSXQgY2FuIGJlIHNoYXJlZCBiZXR3ZWVuXG4gKiBtdWx0aXBsZSBUZXh0IG9iamVjdHMuIENoYW5naW5nIHRoZSBzdHlsZSB3aWxsIHVwZGF0ZSBhbGwgdGV4dCBvYmplY3RzIHVzaW5nIGl0LlxuICogSXQgY2FuIGJlIGdlbmVyYXRlZCBbaGVyZV0oaHR0cHM6Ly9waXhpanMuaW8vcGl4aS10ZXh0LXN0eWxlKS5cbiAqXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKi9cblxudmFyIFRleHRTdHlsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW3N0eWxlXSAtIFRoZSBzdHlsZSBwYXJhbWV0ZXJzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHlsZS5hbGlnbj0nbGVmdCddIC0gQWxpZ25tZW50IGZvciBtdWx0aWxpbmUgdGV4dCAoJ2xlZnQnLCAnY2VudGVyJyBvciAncmlnaHQnKSxcbiAgICAgKiAgZG9lcyBub3QgYWZmZWN0IHNpbmdsZSBsaW5lIHRleHRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtzdHlsZS5icmVha1dvcmRzPWZhbHNlXSAtIEluZGljYXRlcyBpZiBsaW5lcyBjYW4gYmUgd3JhcHBlZCB3aXRoaW4gd29yZHMsIGl0XG4gICAgICogIG5lZWRzIHdvcmRXcmFwIHRvIGJlIHNldCB0byB0cnVlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbc3R5bGUuZHJvcFNoYWRvdz1mYWxzZV0gLSBTZXQgYSBkcm9wIHNoYWRvdyBmb3IgdGhlIHRleHRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0eWxlLmRyb3BTaGFkb3dBbHBoYT0xXSAtIFNldCBhbHBoYSBmb3IgdGhlIGRyb3Agc2hhZG93XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdHlsZS5kcm9wU2hhZG93QW5nbGU9TWF0aC5QSS82XSAtIFNldCBhIGFuZ2xlIG9mIHRoZSBkcm9wIHNoYWRvd1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3R5bGUuZHJvcFNoYWRvd0JsdXI9MF0gLSBTZXQgYSBzaGFkb3cgYmx1ciByYWRpdXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IFtzdHlsZS5kcm9wU2hhZG93Q29sb3I9J2JsYWNrJ10gLSBBIGZpbGwgc3R5bGUgdG8gYmUgdXNlZCBvbiB0aGUgZHJvcHNoYWRvdyBlLmcgJ3JlZCcsICcjMDBGRjAwJ1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3R5bGUuZHJvcFNoYWRvd0Rpc3RhbmNlPTVdIC0gU2V0IGEgZGlzdGFuY2Ugb2YgdGhlIGRyb3Agc2hhZG93XG4gICAgICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW118bnVtYmVyfG51bWJlcltdfENhbnZhc0dyYWRpZW50fENhbnZhc1BhdHRlcm59IFtzdHlsZS5maWxsPSdibGFjayddIC0gQSBjYW52YXNcbiAgICAgKiAgZmlsbHN0eWxlIHRoYXQgd2lsbCBiZSB1c2VkIG9uIHRoZSB0ZXh0IGUuZyAncmVkJywgJyMwMEZGMDAnLiBDYW4gYmUgYW4gYXJyYXkgdG8gY3JlYXRlIGEgZ3JhZGllbnRcbiAgICAgKiAgZWcgWycjMDAwMDAwJywnI0ZGRkZGRiddXG4gICAgICoge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvZmlsbFN0eWxlfE1ETn1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0eWxlLmZpbGxHcmFkaWVudFR5cGU9UElYSS5URVhUX0dSQURJRU5ULkxJTkVBUl9WRVJUSUNBTF0gLSBJZiBmaWxsIGlzIGFuIGFycmF5IG9mIGNvbG91cnNcbiAgICAgKiAgdG8gY3JlYXRlIGEgZ3JhZGllbnQsIHRoaXMgY2FuIGNoYW5nZSB0aGUgdHlwZS9kaXJlY3Rpb24gb2YgdGhlIGdyYWRpZW50LiBTZWUge0BsaW5rIFBJWEkuVEVYVF9HUkFESUVOVH1cbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBbc3R5bGUuZmlsbEdyYWRpZW50U3RvcHNdIC0gSWYgZmlsbCBpcyBhbiBhcnJheSBvZiBjb2xvdXJzIHRvIGNyZWF0ZSBhIGdyYWRpZW50LCB0aGlzIGFycmF5IGNhbiBzZXRcbiAgICAgKiB0aGUgc3RvcCBwb2ludHMgKG51bWJlcnMgYmV0d2VlbiAwIGFuZCAxKSBmb3IgdGhlIGNvbG9yLCBvdmVycmlkaW5nIHRoZSBkZWZhdWx0IGJlaGF2aW91ciBvZiBldmVubHkgc3BhY2luZyB0aGVtLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBbc3R5bGUuZm9udEZhbWlseT0nQXJpYWwnXSAtIFRoZSBmb250IGZhbWlseVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW3N0eWxlLmZvbnRTaXplPTI2XSAtIFRoZSBmb250IHNpemUgKGFzIGEgbnVtYmVyIGl0IGNvbnZlcnRzIHRvIHB4LCBidXQgYXMgYSBzdHJpbmcsXG4gICAgICogIGVxdWl2YWxlbnRzIGFyZSAnMjZweCcsJzIwcHQnLCcxNjAlJyBvciAnMS42ZW0nKVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3R5bGUuZm9udFN0eWxlPSdub3JtYWwnXSAtIFRoZSBmb250IHN0eWxlICgnbm9ybWFsJywgJ2l0YWxpYycgb3IgJ29ibGlxdWUnKVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3R5bGUuZm9udFZhcmlhbnQ9J25vcm1hbCddIC0gVGhlIGZvbnQgdmFyaWFudCAoJ25vcm1hbCcgb3IgJ3NtYWxsLWNhcHMnKVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3R5bGUuZm9udFdlaWdodD0nbm9ybWFsJ10gLSBUaGUgZm9udCB3ZWlnaHQgKCdub3JtYWwnLCAnYm9sZCcsICdib2xkZXInLCAnbGlnaHRlcicgYW5kICcxMDAnLFxuICAgICAqICAnMjAwJywgJzMwMCcsICc0MDAnLCAnNTAwJywgJzYwMCcsICc3MDAnLCA4MDAnIG9yICc5MDAnKVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3R5bGUubGVhZGluZz0wXSAtIFRoZSBzcGFjZSBiZXR3ZWVuIGxpbmVzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdHlsZS5sZXR0ZXJTcGFjaW5nPTBdIC0gVGhlIGFtb3VudCBvZiBzcGFjaW5nIGJldHdlZW4gbGV0dGVycywgZGVmYXVsdCBpcyAwXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdHlsZS5saW5lSGVpZ2h0XSAtIFRoZSBsaW5lIGhlaWdodCwgYSBudW1iZXIgdGhhdCByZXByZXNlbnRzIHRoZSB2ZXJ0aWNhbCBzcGFjZSB0aGF0IGEgbGV0dGVyIHVzZXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0eWxlLmxpbmVKb2luPSdtaXRlciddIC0gVGhlIGxpbmVKb2luIHByb3BlcnR5IHNldHMgdGhlIHR5cGUgb2YgY29ybmVyIGNyZWF0ZWQsIGl0IGNhbiByZXNvbHZlXG4gICAgICogICAgICBzcGlrZWQgdGV4dCBpc3N1ZXMuIFBvc3NpYmxlIHZhbHVlcyBcIm1pdGVyXCIgKGNyZWF0ZXMgYSBzaGFycCBjb3JuZXIpLCBcInJvdW5kXCIgKGNyZWF0ZXMgYSByb3VuZCBjb3JuZXIpIG9yIFwiYmV2ZWxcIlxuICAgICAqICAgICAgKGNyZWF0ZXMgYSBzcXVhcmVkIGNvcm5lcikuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdHlsZS5taXRlckxpbWl0PTEwXSAtIFRoZSBtaXRlciBsaW1pdCB0byB1c2Ugd2hlbiB1c2luZyB0aGUgJ21pdGVyJyBsaW5lSm9pbiBtb2RlLiBUaGlzIGNhbiByZWR1Y2VcbiAgICAgKiAgICAgIG9yIGluY3JlYXNlIHRoZSBzcGlraW5lc3Mgb2YgcmVuZGVyZWQgdGV4dC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0eWxlLnBhZGRpbmc9MF0gLSBPY2Nhc2lvbmFsbHkgc29tZSBmb250cyBhcmUgY3JvcHBlZC4gQWRkaW5nIHNvbWUgcGFkZGluZyB3aWxsIHByZXZlbnQgdGhpcyBmcm9tXG4gICAgICogICAgIGhhcHBlbmluZyBieSBhZGRpbmcgcGFkZGluZyB0byBhbGwgc2lkZXMgb2YgdGhlIHRleHQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBbc3R5bGUuc3Ryb2tlPSdibGFjayddIC0gQSBjYW52YXMgZmlsbHN0eWxlIHRoYXQgd2lsbCBiZSB1c2VkIG9uIHRoZSB0ZXh0IHN0cm9rZVxuICAgICAqICBlLmcgJ2JsdWUnLCAnI0ZDRkYwMCdcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0eWxlLnN0cm9rZVRoaWNrbmVzcz0wXSAtIEEgbnVtYmVyIHRoYXQgcmVwcmVzZW50cyB0aGUgdGhpY2tuZXNzIG9mIHRoZSBzdHJva2UuXG4gICAgICogIERlZmF1bHQgaXMgMCAobm8gc3Ryb2tlKVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3N0eWxlLnRyaW09ZmFsc2VdIC0gVHJpbSB0cmFuc3BhcmVudCBib3JkZXJzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHlsZS50ZXh0QmFzZWxpbmU9J2FscGhhYmV0aWMnXSAtIFRoZSBiYXNlbGluZSBvZiB0aGUgdGV4dCB0aGF0IGlzIHJlbmRlcmVkLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3N0eWxlLndoaXRlU3BhY2U9J3ByZSddIC0gRGV0ZXJtaW5lcyB3aGV0aGVyIG5ld2xpbmVzICYgc3BhY2VzIGFyZSBjb2xsYXBzZWQgb3IgcHJlc2VydmVkIFwibm9ybWFsXCJcbiAgICAgKiAgICAgIChjb2xsYXBzZSwgY29sbGFwc2UpLCBcInByZVwiIChwcmVzZXJ2ZSwgcHJlc2VydmUpIHwgXCJwcmUtbGluZVwiIChwcmVzZXJ2ZSwgY29sbGFwc2UpLiBJdCBuZWVkcyB3b3JkV3JhcCB0byBiZSBzZXQgdG8gdHJ1ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3N0eWxlLndvcmRXcmFwPWZhbHNlXSAtIEluZGljYXRlcyBpZiB3b3JkIHdyYXAgc2hvdWxkIGJlIHVzZWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0eWxlLndvcmRXcmFwV2lkdGg9MTAwXSAtIFRoZSB3aWR0aCBhdCB3aGljaCB0ZXh0IHdpbGwgd3JhcCwgaXQgbmVlZHMgd29yZFdyYXAgdG8gYmUgc2V0IHRvIHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBUZXh0U3R5bGUoc3R5bGUpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRleHRTdHlsZSk7XG5cbiAgICAgICAgdGhpcy5zdHlsZUlEID0gMDtcblxuICAgICAgICB0aGlzLnJlc2V0KCk7XG5cbiAgICAgICAgZGVlcENvcHlQcm9wZXJ0aWVzKHRoaXMsIHN0eWxlLCBzdHlsZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBUZXh0U3R5bGUgb2JqZWN0IHdpdGggdGhlIHNhbWUgdmFsdWVzIGFzIHRoaXMgb25lLlxuICAgICAqIE5vdGUgdGhhdCB0aGUgb25seSB0aGUgcHJvcGVydGllcyBvZiB0aGUgb2JqZWN0IGFyZSBjbG9uZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtQSVhJLlRleHRTdHlsZX0gTmV3IGNsb25lZCBUZXh0U3R5bGUgb2JqZWN0XG4gICAgICovXG5cblxuICAgIFRleHRTdHlsZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgICAgdmFyIGNsb25lZFByb3BlcnRpZXMgPSB7fTtcblxuICAgICAgICBkZWVwQ29weVByb3BlcnRpZXMoY2xvbmVkUHJvcGVydGllcywgdGhpcywgZGVmYXVsdFN0eWxlKTtcblxuICAgICAgICByZXR1cm4gbmV3IFRleHRTdHlsZShjbG9uZWRQcm9wZXJ0aWVzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVzZXRzIGFsbCBwcm9wZXJ0aWVzIHRvIHRoZSBkZWZhdWx0cyBzcGVjaWZpZWQgaW4gVGV4dFN0eWxlLnByb3RvdHlwZS5fZGVmYXVsdFxuICAgICAqL1xuXG5cbiAgICBUZXh0U3R5bGUucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICAgIGRlZXBDb3B5UHJvcGVydGllcyh0aGlzLCBkZWZhdWx0U3R5bGUsIGRlZmF1bHRTdHlsZSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFsaWdubWVudCBmb3IgbXVsdGlsaW5lIHRleHQgKCdsZWZ0JywgJ2NlbnRlcicgb3IgJ3JpZ2h0JyksIGRvZXMgbm90IGFmZmVjdCBzaW5nbGUgbGluZSB0ZXh0XG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9XG4gICAgICovXG5cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIGZvbnQgc3R5bGUgc3RyaW5nIHRvIHVzZSBmb3IgYFRleHRNZXRyaWNzLm1lYXN1cmVGb250KClgLlxuICAgICAqXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBGb250IHN0eWxlIHN0cmluZywgZm9yIHBhc3NpbmcgdG8gYFRleHRNZXRyaWNzLm1lYXN1cmVGb250KClgXG4gICAgICovXG4gICAgVGV4dFN0eWxlLnByb3RvdHlwZS50b0ZvbnRTdHJpbmcgPSBmdW5jdGlvbiB0b0ZvbnRTdHJpbmcoKSB7XG4gICAgICAgIC8vIGJ1aWxkIGNhbnZhcyBhcGkgZm9udCBzZXR0aW5nIGZyb20gaW5kaXZpZHVhbCBjb21wb25lbnRzLiBDb252ZXJ0IGEgbnVtZXJpYyB0aGlzLmZvbnRTaXplIHRvIHB4XG4gICAgICAgIHZhciBmb250U2l6ZVN0cmluZyA9IHR5cGVvZiB0aGlzLmZvbnRTaXplID09PSAnbnVtYmVyJyA/IHRoaXMuZm9udFNpemUgKyAncHgnIDogdGhpcy5mb250U2l6ZTtcblxuICAgICAgICAvLyBDbGVhbi11cCBmb250RmFtaWx5IHByb3BlcnR5IGJ5IHF1b3RpbmcgZWFjaCBmb250IG5hbWVcbiAgICAgICAgLy8gdGhpcyB3aWxsIHN1cHBvcnQgZm9udCBuYW1lcyB3aXRoIHNwYWNlc1xuICAgICAgICB2YXIgZm9udEZhbWlsaWVzID0gdGhpcy5mb250RmFtaWx5O1xuXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh0aGlzLmZvbnRGYW1pbHkpKSB7XG4gICAgICAgICAgICBmb250RmFtaWxpZXMgPSB0aGlzLmZvbnRGYW1pbHkuc3BsaXQoJywnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSBmb250RmFtaWxpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIC8vIFRyaW0gYW55IGV4dHJhIHdoaXRlLXNwYWNlXG4gICAgICAgICAgICB2YXIgZm9udEZhbWlseSA9IGZvbnRGYW1pbGllc1tpXS50cmltKCk7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIGZvbnQgaXMgYWxyZWFkeSBlc2NhcGVkIGluIHF1b3RlcyBleGNlcHQgZm9yIENTUyBnZW5lcmljIGZvbnRzXG4gICAgICAgICAgICBpZiAoIS8oW1xcXCJcXCddKVteXFwnXFxcIl0rXFwxLy50ZXN0KGZvbnRGYW1pbHkpICYmIGdlbmVyaWNGb250RmFtaWxpZXMuaW5kZXhPZihmb250RmFtaWx5KSA8IDApIHtcbiAgICAgICAgICAgICAgICBmb250RmFtaWx5ID0gJ1wiJyArIGZvbnRGYW1pbHkgKyAnXCInO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9udEZhbWlsaWVzW2ldID0gZm9udEZhbWlseTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmZvbnRTdHlsZSArICcgJyArIHRoaXMuZm9udFZhcmlhbnQgKyAnICcgKyB0aGlzLmZvbnRXZWlnaHQgKyAnICcgKyBmb250U2l6ZVN0cmluZyArICcgJyArIGZvbnRGYW1pbGllcy5qb2luKCcsJyk7XG4gICAgfTtcblxuICAgIF9jcmVhdGVDbGFzcyhUZXh0U3R5bGUsIFt7XG4gICAgICAgIGtleTogJ2FsaWduJyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYWxpZ247XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KGFsaWduKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlcXVpcmUtanNkb2NcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2FsaWduICE9PSBhbGlnbikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FsaWduID0gYWxpZ247XG4gICAgICAgICAgICAgICAgdGhpcy5zdHlsZUlEKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogSW5kaWNhdGVzIGlmIGxpbmVzIGNhbiBiZSB3cmFwcGVkIHdpdGhpbiB3b3JkcywgaXQgbmVlZHMgd29yZFdyYXAgdG8gYmUgc2V0IHRvIHRydWVcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2JyZWFrV29yZHMnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9icmVha1dvcmRzO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChicmVha1dvcmRzKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlcXVpcmUtanNkb2NcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2JyZWFrV29yZHMgIT09IGJyZWFrV29yZHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9icmVha1dvcmRzID0gYnJlYWtXb3JkcztcbiAgICAgICAgICAgICAgICB0aGlzLnN0eWxlSUQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgYSBkcm9wIHNoYWRvdyBmb3IgdGhlIHRleHRcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2Ryb3BTaGFkb3cnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kcm9wU2hhZG93O1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChkcm9wU2hhZG93KSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlcXVpcmUtanNkb2NcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2Ryb3BTaGFkb3cgIT09IGRyb3BTaGFkb3cpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kcm9wU2hhZG93ID0gZHJvcFNoYWRvdztcbiAgICAgICAgICAgICAgICB0aGlzLnN0eWxlSUQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgYWxwaGEgZm9yIHRoZSBkcm9wIHNoYWRvd1xuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdkcm9wU2hhZG93QWxwaGEnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kcm9wU2hhZG93QWxwaGE7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KGRyb3BTaGFkb3dBbHBoYSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSByZXF1aXJlLWpzZG9jXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9kcm9wU2hhZG93QWxwaGEgIT09IGRyb3BTaGFkb3dBbHBoYSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Ryb3BTaGFkb3dBbHBoYSA9IGRyb3BTaGFkb3dBbHBoYTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0eWxlSUQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgYSBhbmdsZSBvZiB0aGUgZHJvcCBzaGFkb3dcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZHJvcFNoYWRvd0FuZ2xlJyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZHJvcFNoYWRvd0FuZ2xlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChkcm9wU2hhZG93QW5nbGUpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcmVxdWlyZS1qc2RvY1xuICAgICAgICB7XG4gICAgICAgICAgICBpZiAodGhpcy5fZHJvcFNoYWRvd0FuZ2xlICE9PSBkcm9wU2hhZG93QW5nbGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kcm9wU2hhZG93QW5nbGUgPSBkcm9wU2hhZG93QW5nbGU7XG4gICAgICAgICAgICAgICAgdGhpcy5zdHlsZUlEKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IGEgc2hhZG93IGJsdXIgcmFkaXVzXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2Ryb3BTaGFkb3dCbHVyJyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZHJvcFNoYWRvd0JsdXI7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KGRyb3BTaGFkb3dCbHVyKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlcXVpcmUtanNkb2NcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2Ryb3BTaGFkb3dCbHVyICE9PSBkcm9wU2hhZG93Qmx1cikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Ryb3BTaGFkb3dCbHVyID0gZHJvcFNoYWRvd0JsdXI7XG4gICAgICAgICAgICAgICAgdGhpcy5zdHlsZUlEKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBmaWxsIHN0eWxlIHRvIGJlIHVzZWQgb24gdGhlIGRyb3BzaGFkb3cgZS5nICdyZWQnLCAnIzAwRkYwMCdcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfG51bWJlcn1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2Ryb3BTaGFkb3dDb2xvcicsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Ryb3BTaGFkb3dDb2xvcjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoZHJvcFNoYWRvd0NvbG9yKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlcXVpcmUtanNkb2NcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIG91dHB1dENvbG9yID0gZ2V0Q29sb3IoZHJvcFNoYWRvd0NvbG9yKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9kcm9wU2hhZG93Q29sb3IgIT09IG91dHB1dENvbG9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHJvcFNoYWRvd0NvbG9yID0gb3V0cHV0Q29sb3I7XG4gICAgICAgICAgICAgICAgdGhpcy5zdHlsZUlEKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IGEgZGlzdGFuY2Ugb2YgdGhlIGRyb3Agc2hhZG93XG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2Ryb3BTaGFkb3dEaXN0YW5jZScsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Ryb3BTaGFkb3dEaXN0YW5jZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoZHJvcFNoYWRvd0Rpc3RhbmNlKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlcXVpcmUtanNkb2NcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2Ryb3BTaGFkb3dEaXN0YW5jZSAhPT0gZHJvcFNoYWRvd0Rpc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHJvcFNoYWRvd0Rpc3RhbmNlID0gZHJvcFNoYWRvd0Rpc3RhbmNlO1xuICAgICAgICAgICAgICAgIHRoaXMuc3R5bGVJRCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgY2FudmFzIGZpbGxzdHlsZSB0aGF0IHdpbGwgYmUgdXNlZCBvbiB0aGUgdGV4dCBlLmcgJ3JlZCcsICcjMDBGRjAwJy5cbiAgICAgICAgICogQ2FuIGJlIGFuIGFycmF5IHRvIGNyZWF0ZSBhIGdyYWRpZW50IGVnIFsnIzAwMDAwMCcsJyNGRkZGRkYnXVxuICAgICAgICAgKiB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC9maWxsU3R5bGV8TUROfVxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd8c3RyaW5nW118bnVtYmVyfG51bWJlcltdfENhbnZhc0dyYWRpZW50fENhbnZhc1BhdHRlcm59XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdmaWxsJyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZmlsbDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoZmlsbCkgLy8gZXNsaW50LWRpc2FibGUtbGluZSByZXF1aXJlLWpzZG9jXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBvdXRwdXRDb2xvciA9IGdldENvbG9yKGZpbGwpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2ZpbGwgIT09IG91dHB1dENvbG9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZmlsbCA9IG91dHB1dENvbG9yO1xuICAgICAgICAgICAgICAgIHRoaXMuc3R5bGVJRCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGZpbGwgaXMgYW4gYXJyYXkgb2YgY29sb3VycyB0byBjcmVhdGUgYSBncmFkaWVudCwgdGhpcyBjYW4gY2hhbmdlIHRoZSB0eXBlL2RpcmVjdGlvbiBvZiB0aGUgZ3JhZGllbnQuXG4gICAgICAgICAqIFNlZSB7QGxpbmsgUElYSS5URVhUX0dSQURJRU5UfVxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdmaWxsR3JhZGllbnRUeXBlJyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZmlsbEdyYWRpZW50VHlwZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoZmlsbEdyYWRpZW50VHlwZSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSByZXF1aXJlLWpzZG9jXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9maWxsR3JhZGllbnRUeXBlICE9PSBmaWxsR3JhZGllbnRUeXBlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZmlsbEdyYWRpZW50VHlwZSA9IGZpbGxHcmFkaWVudFR5cGU7XG4gICAgICAgICAgICAgICAgdGhpcy5zdHlsZUlEKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgZmlsbCBpcyBhbiBhcnJheSBvZiBjb2xvdXJzIHRvIGNyZWF0ZSBhIGdyYWRpZW50LCB0aGlzIGFycmF5IGNhbiBzZXQgdGhlIHN0b3AgcG9pbnRzXG4gICAgICAgICAqIChudW1iZXJzIGJldHdlZW4gMCBhbmQgMSkgZm9yIHRoZSBjb2xvciwgb3ZlcnJpZGluZyB0aGUgZGVmYXVsdCBiZWhhdmlvdXIgb2YgZXZlbmx5IHNwYWNpbmcgdGhlbS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyW119XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdmaWxsR3JhZGllbnRTdG9wcycsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbGxHcmFkaWVudFN0b3BzO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChmaWxsR3JhZGllbnRTdG9wcykgLy8gZXNsaW50LWRpc2FibGUtbGluZSByZXF1aXJlLWpzZG9jXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICghYXJlQXJyYXlzRXF1YWwodGhpcy5fZmlsbEdyYWRpZW50U3RvcHMsIGZpbGxHcmFkaWVudFN0b3BzKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZpbGxHcmFkaWVudFN0b3BzID0gZmlsbEdyYWRpZW50U3RvcHM7XG4gICAgICAgICAgICAgICAgdGhpcy5zdHlsZUlEKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGZvbnQgZmFtaWx5XG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge3N0cmluZ3xzdHJpbmdbXX1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2ZvbnRGYW1pbHknLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9mb250RmFtaWx5O1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChmb250RmFtaWx5KSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlcXVpcmUtanNkb2NcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHRoaXMuZm9udEZhbWlseSAhPT0gZm9udEZhbWlseSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZvbnRGYW1pbHkgPSBmb250RmFtaWx5O1xuICAgICAgICAgICAgICAgIHRoaXMuc3R5bGVJRCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBmb250IHNpemVcbiAgICAgICAgICogKGFzIGEgbnVtYmVyIGl0IGNvbnZlcnRzIHRvIHB4LCBidXQgYXMgYSBzdHJpbmcsIGVxdWl2YWxlbnRzIGFyZSAnMjZweCcsJzIwcHQnLCcxNjAlJyBvciAnMS42ZW0nKVxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ8c3RyaW5nfVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZm9udFNpemUnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9mb250U2l6ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoZm9udFNpemUpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcmVxdWlyZS1qc2RvY1xuICAgICAgICB7XG4gICAgICAgICAgICBpZiAodGhpcy5fZm9udFNpemUgIT09IGZvbnRTaXplKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZm9udFNpemUgPSBmb250U2l6ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0eWxlSUQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZm9udCBzdHlsZVxuICAgICAgICAgKiAoJ25vcm1hbCcsICdpdGFsaWMnIG9yICdvYmxpcXVlJylcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZm9udFN0eWxlJyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZm9udFN0eWxlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChmb250U3R5bGUpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcmVxdWlyZS1qc2RvY1xuICAgICAgICB7XG4gICAgICAgICAgICBpZiAodGhpcy5fZm9udFN0eWxlICE9PSBmb250U3R5bGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9mb250U3R5bGUgPSBmb250U3R5bGU7XG4gICAgICAgICAgICAgICAgdGhpcy5zdHlsZUlEKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGZvbnQgdmFyaWFudFxuICAgICAgICAgKiAoJ25vcm1hbCcgb3IgJ3NtYWxsLWNhcHMnKVxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdmb250VmFyaWFudCcsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZvbnRWYXJpYW50O1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChmb250VmFyaWFudCkgLy8gZXNsaW50LWRpc2FibGUtbGluZSByZXF1aXJlLWpzZG9jXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9mb250VmFyaWFudCAhPT0gZm9udFZhcmlhbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9mb250VmFyaWFudCA9IGZvbnRWYXJpYW50O1xuICAgICAgICAgICAgICAgIHRoaXMuc3R5bGVJRCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBmb250IHdlaWdodFxuICAgICAgICAgKiAoJ25vcm1hbCcsICdib2xkJywgJ2JvbGRlcicsICdsaWdodGVyJyBhbmQgJzEwMCcsICcyMDAnLCAnMzAwJywgJzQwMCcsICc1MDAnLCAnNjAwJywgJzcwMCcsIDgwMCcgb3IgJzkwMCcpXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge3N0cmluZ31cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2ZvbnRXZWlnaHQnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9mb250V2VpZ2h0O1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChmb250V2VpZ2h0KSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlcXVpcmUtanNkb2NcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2ZvbnRXZWlnaHQgIT09IGZvbnRXZWlnaHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9mb250V2VpZ2h0ID0gZm9udFdlaWdodDtcbiAgICAgICAgICAgICAgICB0aGlzLnN0eWxlSUQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYW1vdW50IG9mIHNwYWNpbmcgYmV0d2VlbiBsZXR0ZXJzLCBkZWZhdWx0IGlzIDBcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnbGV0dGVyU3BhY2luZycsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xldHRlclNwYWNpbmc7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KGxldHRlclNwYWNpbmcpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcmVxdWlyZS1qc2RvY1xuICAgICAgICB7XG4gICAgICAgICAgICBpZiAodGhpcy5fbGV0dGVyU3BhY2luZyAhPT0gbGV0dGVyU3BhY2luZykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xldHRlclNwYWNpbmcgPSBsZXR0ZXJTcGFjaW5nO1xuICAgICAgICAgICAgICAgIHRoaXMuc3R5bGVJRCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBsaW5lIGhlaWdodCwgYSBudW1iZXIgdGhhdCByZXByZXNlbnRzIHRoZSB2ZXJ0aWNhbCBzcGFjZSB0aGF0IGEgbGV0dGVyIHVzZXNcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnbGluZUhlaWdodCcsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xpbmVIZWlnaHQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KGxpbmVIZWlnaHQpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcmVxdWlyZS1qc2RvY1xuICAgICAgICB7XG4gICAgICAgICAgICBpZiAodGhpcy5fbGluZUhlaWdodCAhPT0gbGluZUhlaWdodCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xpbmVIZWlnaHQgPSBsaW5lSGVpZ2h0O1xuICAgICAgICAgICAgICAgIHRoaXMuc3R5bGVJRCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBzcGFjZSBiZXR3ZWVuIGxpbmVzXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2xlYWRpbmcnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sZWFkaW5nO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChsZWFkaW5nKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlcXVpcmUtanNkb2NcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2xlYWRpbmcgIT09IGxlYWRpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sZWFkaW5nID0gbGVhZGluZztcbiAgICAgICAgICAgICAgICB0aGlzLnN0eWxlSUQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbGluZUpvaW4gcHJvcGVydHkgc2V0cyB0aGUgdHlwZSBvZiBjb3JuZXIgY3JlYXRlZCwgaXQgY2FuIHJlc29sdmUgc3Bpa2VkIHRleHQgaXNzdWVzLlxuICAgICAgICAgKiBEZWZhdWx0IGlzICdtaXRlcicgKGNyZWF0ZXMgYSBzaGFycCBjb3JuZXIpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdsaW5lSm9pbicsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xpbmVKb2luO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChsaW5lSm9pbikgLy8gZXNsaW50LWRpc2FibGUtbGluZSByZXF1aXJlLWpzZG9jXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9saW5lSm9pbiAhPT0gbGluZUpvaW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9saW5lSm9pbiA9IGxpbmVKb2luO1xuICAgICAgICAgICAgICAgIHRoaXMuc3R5bGVJRCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBtaXRlciBsaW1pdCB0byB1c2Ugd2hlbiB1c2luZyB0aGUgJ21pdGVyJyBsaW5lSm9pbiBtb2RlXG4gICAgICAgICAqIFRoaXMgY2FuIHJlZHVjZSBvciBpbmNyZWFzZSB0aGUgc3Bpa2luZXNzIG9mIHJlbmRlcmVkIHRleHQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ21pdGVyTGltaXQnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9taXRlckxpbWl0O1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChtaXRlckxpbWl0KSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlcXVpcmUtanNkb2NcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHRoaXMuX21pdGVyTGltaXQgIT09IG1pdGVyTGltaXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9taXRlckxpbWl0ID0gbWl0ZXJMaW1pdDtcbiAgICAgICAgICAgICAgICB0aGlzLnN0eWxlSUQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPY2Nhc2lvbmFsbHkgc29tZSBmb250cyBhcmUgY3JvcHBlZC4gQWRkaW5nIHNvbWUgcGFkZGluZyB3aWxsIHByZXZlbnQgdGhpcyBmcm9tIGhhcHBlbmluZ1xuICAgICAgICAgKiBieSBhZGRpbmcgcGFkZGluZyB0byBhbGwgc2lkZXMgb2YgdGhlIHRleHQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3BhZGRpbmcnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wYWRkaW5nO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChwYWRkaW5nKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlcXVpcmUtanNkb2NcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3BhZGRpbmcgIT09IHBhZGRpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYWRkaW5nID0gcGFkZGluZztcbiAgICAgICAgICAgICAgICB0aGlzLnN0eWxlSUQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGNhbnZhcyBmaWxsc3R5bGUgdGhhdCB3aWxsIGJlIHVzZWQgb24gdGhlIHRleHQgc3Ryb2tlXG4gICAgICAgICAqIGUuZyAnYmx1ZScsICcjRkNGRjAwJ1xuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd8bnVtYmVyfVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnc3Ryb2tlJyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3Ryb2tlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChzdHJva2UpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcmVxdWlyZS1qc2RvY1xuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgb3V0cHV0Q29sb3IgPSBnZXRDb2xvcihzdHJva2UpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3N0cm9rZSAhPT0gb3V0cHV0Q29sb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdHJva2UgPSBvdXRwdXRDb2xvcjtcbiAgICAgICAgICAgICAgICB0aGlzLnN0eWxlSUQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIG51bWJlciB0aGF0IHJlcHJlc2VudHMgdGhlIHRoaWNrbmVzcyBvZiB0aGUgc3Ryb2tlLlxuICAgICAgICAgKiBEZWZhdWx0IGlzIDAgKG5vIHN0cm9rZSlcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnc3Ryb2tlVGhpY2tuZXNzJyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3Ryb2tlVGhpY2tuZXNzO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChzdHJva2VUaGlja25lc3MpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcmVxdWlyZS1qc2RvY1xuICAgICAgICB7XG4gICAgICAgICAgICBpZiAodGhpcy5fc3Ryb2tlVGhpY2tuZXNzICE9PSBzdHJva2VUaGlja25lc3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdHJva2VUaGlja25lc3MgPSBzdHJva2VUaGlja25lc3M7XG4gICAgICAgICAgICAgICAgdGhpcy5zdHlsZUlEKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGJhc2VsaW5lIG9mIHRoZSB0ZXh0IHRoYXQgaXMgcmVuZGVyZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge3N0cmluZ31cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3RleHRCYXNlbGluZScsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RleHRCYXNlbGluZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodGV4dEJhc2VsaW5lKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlcXVpcmUtanNkb2NcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3RleHRCYXNlbGluZSAhPT0gdGV4dEJhc2VsaW5lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGV4dEJhc2VsaW5lID0gdGV4dEJhc2VsaW5lO1xuICAgICAgICAgICAgICAgIHRoaXMuc3R5bGVJRCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRyaW0gdHJhbnNwYXJlbnQgYm9yZGVyc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndHJpbScsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RyaW07XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHRyaW0pIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcmVxdWlyZS1qc2RvY1xuICAgICAgICB7XG4gICAgICAgICAgICBpZiAodGhpcy5fdHJpbSAhPT0gdHJpbSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RyaW0gPSB0cmltO1xuICAgICAgICAgICAgICAgIHRoaXMuc3R5bGVJRCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhvdyBuZXdsaW5lcyBhbmQgc3BhY2VzIHNob3VsZCBiZSBoYW5kbGVkLlxuICAgICAgICAgKiBEZWZhdWx0IGlzICdwcmUnIChwcmVzZXJ2ZSwgcHJlc2VydmUpLlxuICAgICAgICAgKlxuICAgICAgICAgKiAgdmFsdWUgICAgICAgfCBOZXcgbGluZXMgICAgIHwgICBTcGFjZXNcbiAgICAgICAgICogIC0tLSAgICAgICAgIHwgLS0tICAgICAgICAgICB8ICAgLS0tXG4gICAgICAgICAqICdub3JtYWwnICAgICB8IENvbGxhcHNlICAgICAgfCAgIENvbGxhcHNlXG4gICAgICAgICAqICdwcmUnICAgICAgICB8IFByZXNlcnZlICAgICAgfCAgIFByZXNlcnZlXG4gICAgICAgICAqICdwcmUtbGluZScgICB8IFByZXNlcnZlICAgICAgfCAgIENvbGxhcHNlXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge3N0cmluZ31cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3doaXRlU3BhY2UnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93aGl0ZVNwYWNlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh3aGl0ZVNwYWNlKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlcXVpcmUtanNkb2NcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3doaXRlU3BhY2UgIT09IHdoaXRlU3BhY2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl93aGl0ZVNwYWNlID0gd2hpdGVTcGFjZTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0eWxlSUQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmRpY2F0ZXMgaWYgd29yZCB3cmFwIHNob3VsZCBiZSB1c2VkXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICd3b3JkV3JhcCcsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dvcmRXcmFwO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh3b3JkV3JhcCkgLy8gZXNsaW50LWRpc2FibGUtbGluZSByZXF1aXJlLWpzZG9jXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl93b3JkV3JhcCAhPT0gd29yZFdyYXApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl93b3JkV3JhcCA9IHdvcmRXcmFwO1xuICAgICAgICAgICAgICAgIHRoaXMuc3R5bGVJRCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB3aWR0aCBhdCB3aGljaCB0ZXh0IHdpbGwgd3JhcCwgaXQgbmVlZHMgd29yZFdyYXAgdG8gYmUgc2V0IHRvIHRydWVcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnd29yZFdyYXBXaWR0aCcsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dvcmRXcmFwV2lkdGg7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHdvcmRXcmFwV2lkdGgpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcmVxdWlyZS1qc2RvY1xuICAgICAgICB7XG4gICAgICAgICAgICBpZiAodGhpcy5fd29yZFdyYXBXaWR0aCAhPT0gd29yZFdyYXBXaWR0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dvcmRXcmFwV2lkdGggPSB3b3JkV3JhcFdpZHRoO1xuICAgICAgICAgICAgICAgIHRoaXMuc3R5bGVJRCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFRleHRTdHlsZTtcbn0oKTtcblxuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9uIHRvIGNvbnZlcnQgaGV4YWRlY2ltYWwgY29sb3JzIHRvIHN0cmluZ3MsIGFuZCBzaW1wbHkgcmV0dXJuIHRoZSBjb2xvciBpZiBpdCdzIGEgc3RyaW5nLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfG51bWJlcltdfSBjb2xvclxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgY29sb3IgYXMgYSBzdHJpbmcuXG4gKi9cblxuXG5leHBvcnRzLmRlZmF1bHQgPSBUZXh0U3R5bGU7XG5mdW5jdGlvbiBnZXRTaW5nbGVDb2xvcihjb2xvcikge1xuICAgIGlmICh0eXBlb2YgY29sb3IgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiAoMCwgX3V0aWxzLmhleDJzdHJpbmcpKGNvbG9yKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb2xvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKGNvbG9yLmluZGV4T2YoJzB4JykgPT09IDApIHtcbiAgICAgICAgICAgIGNvbG9yID0gY29sb3IucmVwbGFjZSgnMHgnLCAnIycpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbG9yO1xufVxuXG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb24gdG8gY29udmVydCBoZXhhZGVjaW1hbCBjb2xvcnMgdG8gc3RyaW5ncywgYW5kIHNpbXBseSByZXR1cm4gdGhlIGNvbG9yIGlmIGl0J3MgYSBzdHJpbmcuXG4gKiBUaGlzIHZlcnNpb24gY2FuIGFsc28gY29udmVydCBhcnJheSBvZiBjb2xvcnNcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcnxudW1iZXJbXX0gY29sb3JcbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGNvbG9yIGFzIGEgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBnZXRDb2xvcihjb2xvcikge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShjb2xvcikpIHtcbiAgICAgICAgcmV0dXJuIGdldFNpbmdsZUNvbG9yKGNvbG9yKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbG9yLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb2xvcltpXSA9IGdldFNpbmdsZUNvbG9yKGNvbG9yW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb2xvcjtcbiAgICB9XG59XG5cbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbiB0byBjb252ZXJ0IGhleGFkZWNpbWFsIGNvbG9ycyB0byBzdHJpbmdzLCBhbmQgc2ltcGx5IHJldHVybiB0aGUgY29sb3IgaWYgaXQncyBhIHN0cmluZy5cbiAqIFRoaXMgdmVyc2lvbiBjYW4gYWxzbyBjb252ZXJ0IGFycmF5IG9mIGNvbG9yc1xuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5MSBGaXJzdCBhcnJheSB0byBjb21wYXJlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheTIgU2Vjb25kIGFycmF5IHRvIGNvbXBhcmVcbiAqIEByZXR1cm4ge2Jvb2xlYW59IERvIHRoZSBhcnJheXMgY29udGFpbiB0aGUgc2FtZSB2YWx1ZXMgaW4gdGhlIHNhbWUgb3JkZXJcbiAqL1xuZnVuY3Rpb24gYXJlQXJyYXlzRXF1YWwoYXJyYXkxLCBhcnJheTIpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXkxKSB8fCAhQXJyYXkuaXNBcnJheShhcnJheTIpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoYXJyYXkxLmxlbmd0aCAhPT0gYXJyYXkyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheTEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKGFycmF5MVtpXSAhPT0gYXJyYXkyW2ldKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9uIHRvIGVuc3VyZSB0aGF0IG9iamVjdCBwcm9wZXJ0aWVzIGFyZSBjb3BpZWQgYnkgdmFsdWUsIGFuZCBub3QgYnkgcmVmZXJlbmNlXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBUYXJnZXQgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBpbnRvXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFNvdXJjZSBvYmplY3QgZm9yIHRoZSBwcm9wb3J0aWVzIHRvIGNvcHlcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eU9iaiBPYmplY3QgY29udGFpbmluZyBwcm9wZXJ0aWVzIG5hbWVzIHdlIHdhbnQgdG8gbG9vcCBvdmVyXG4gKi9cbmZ1bmN0aW9uIGRlZXBDb3B5UHJvcGVydGllcyh0YXJnZXQsIHNvdXJjZSwgcHJvcGVydHlPYmopIHtcbiAgICBmb3IgKHZhciBwcm9wIGluIHByb3BlcnR5T2JqKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNvdXJjZVtwcm9wXSkpIHtcbiAgICAgICAgICAgIHRhcmdldFtwcm9wXSA9IHNvdXJjZVtwcm9wXS5zbGljZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGFyZ2V0W3Byb3BdID0gc291cmNlW3Byb3BdO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGV4dFN0eWxlLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9CYXNlVGV4dHVyZTIgPSByZXF1aXJlKCcuL0Jhc2VUZXh0dXJlJyk7XG5cbnZhciBfQmFzZVRleHR1cmUzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQmFzZVRleHR1cmUyKTtcblxudmFyIF9zZXR0aW5ncyA9IHJlcXVpcmUoJy4uL3NldHRpbmdzJyk7XG5cbnZhciBfc2V0dGluZ3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc2V0dGluZ3MpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbi8qKlxuICogQSBCYXNlUmVuZGVyVGV4dHVyZSBpcyBhIHNwZWNpYWwgdGV4dHVyZSB0aGF0IGFsbG93cyBhbnkgUGl4aUpTIGRpc3BsYXkgb2JqZWN0IHRvIGJlIHJlbmRlcmVkIHRvIGl0LlxuICpcbiAqIF9fSGludF9fOiBBbGwgRGlzcGxheU9iamVjdHMgKGkuZS4gU3ByaXRlcykgdGhhdCByZW5kZXIgdG8gYSBCYXNlUmVuZGVyVGV4dHVyZSBzaG91bGQgYmUgcHJlbG9hZGVkXG4gKiBvdGhlcndpc2UgYmxhY2sgcmVjdGFuZ2xlcyB3aWxsIGJlIGRyYXduIGluc3RlYWQuXG4gKlxuICogQSBCYXNlUmVuZGVyVGV4dHVyZSB0YWtlcyBhIHNuYXBzaG90IG9mIGFueSBEaXNwbGF5IE9iamVjdCBnaXZlbiB0byBpdHMgcmVuZGVyIG1ldGhvZC4gVGhlIHBvc2l0aW9uXG4gKiBhbmQgcm90YXRpb24gb2YgdGhlIGdpdmVuIERpc3BsYXkgT2JqZWN0cyBpcyBpZ25vcmVkLiBGb3IgZXhhbXBsZTpcbiAqXG4gKiBgYGBqc1xuICogbGV0IHJlbmRlcmVyID0gUElYSS5hdXRvRGV0ZWN0UmVuZGVyZXIoMTAyNCwgMTAyNCk7XG4gKiBsZXQgYmFzZVJlbmRlclRleHR1cmUgPSBuZXcgUElYSS5CYXNlUmVuZGVyVGV4dHVyZSg4MDAsIDYwMCk7XG4gKiBsZXQgcmVuZGVyVGV4dHVyZSA9IG5ldyBQSVhJLlJlbmRlclRleHR1cmUoYmFzZVJlbmRlclRleHR1cmUpO1xuICogbGV0IHNwcml0ZSA9IFBJWEkuU3ByaXRlLmZyb21JbWFnZShcInNwaW5PYmpfMDEucG5nXCIpO1xuICpcbiAqIHNwcml0ZS5wb3NpdGlvbi54ID0gODAwLzI7XG4gKiBzcHJpdGUucG9zaXRpb24ueSA9IDYwMC8yO1xuICogc3ByaXRlLmFuY2hvci54ID0gMC41O1xuICogc3ByaXRlLmFuY2hvci55ID0gMC41O1xuICpcbiAqIHJlbmRlcmVyLnJlbmRlcihzcHJpdGUsIHJlbmRlclRleHR1cmUpO1xuICogYGBgXG4gKlxuICogVGhlIFNwcml0ZSBpbiB0aGlzIGNhc2Ugd2lsbCBiZSByZW5kZXJlZCB1c2luZyBpdHMgbG9jYWwgdHJhbnNmb3JtLiBUbyByZW5kZXIgdGhpcyBzcHJpdGUgYXQgMCwwXG4gKiB5b3UgY2FuIGNsZWFyIHRoZSB0cmFuc2Zvcm1cbiAqXG4gKiBgYGBqc1xuICpcbiAqIHNwcml0ZS5zZXRUcmFuc2Zvcm0oKVxuICpcbiAqIGxldCBiYXNlUmVuZGVyVGV4dHVyZSA9IG5ldyBQSVhJLkJhc2VSZW5kZXJUZXh0dXJlKDEwMCwgMTAwKTtcbiAqIGxldCByZW5kZXJUZXh0dXJlID0gbmV3IFBJWEkuUmVuZGVyVGV4dHVyZShiYXNlUmVuZGVyVGV4dHVyZSk7XG4gKlxuICogcmVuZGVyZXIucmVuZGVyKHNwcml0ZSwgcmVuZGVyVGV4dHVyZSk7ICAvLyBSZW5kZXJzIHRvIGNlbnRlciBvZiBSZW5kZXJUZXh0dXJlXG4gKiBgYGBcbiAqXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIFBJWEkuQmFzZVRleHR1cmVcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKi9cbnZhciBCYXNlUmVuZGVyVGV4dHVyZSA9IGZ1bmN0aW9uIChfQmFzZVRleHR1cmUpIHtcbiAgX2luaGVyaXRzKEJhc2VSZW5kZXJUZXh0dXJlLCBfQmFzZVRleHR1cmUpO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3dpZHRoPTEwMF0gLSBUaGUgd2lkdGggb2YgdGhlIGJhc2UgcmVuZGVyIHRleHR1cmVcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtoZWlnaHQ9MTAwXSAtIFRoZSBoZWlnaHQgb2YgdGhlIGJhc2UgcmVuZGVyIHRleHR1cmVcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtzY2FsZU1vZGU9UElYSS5zZXR0aW5ncy5TQ0FMRV9NT0RFXSAtIFNlZSB7QGxpbmsgUElYSS5TQ0FMRV9NT0RFU30gZm9yIHBvc3NpYmxlIHZhbHVlc1xuICAgKiBAcGFyYW0ge251bWJlcn0gW3Jlc29sdXRpb249MV0gLSBUaGUgcmVzb2x1dGlvbiAvIGRldmljZSBwaXhlbCByYXRpbyBvZiB0aGUgdGV4dHVyZSBiZWluZyBnZW5lcmF0ZWRcbiAgICovXG4gIGZ1bmN0aW9uIEJhc2VSZW5kZXJUZXh0dXJlKCkge1xuICAgIHZhciB3aWR0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMTAwO1xuICAgIHZhciBoZWlnaHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDEwMDtcbiAgICB2YXIgc2NhbGVNb2RlID0gYXJndW1lbnRzWzJdO1xuICAgIHZhciByZXNvbHV0aW9uID0gYXJndW1lbnRzWzNdO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJhc2VSZW5kZXJUZXh0dXJlKTtcblxuICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9CYXNlVGV4dHVyZS5jYWxsKHRoaXMsIG51bGwsIHNjYWxlTW9kZSkpO1xuXG4gICAgX3RoaXMucmVzb2x1dGlvbiA9IHJlc29sdXRpb24gfHwgX3NldHRpbmdzMi5kZWZhdWx0LlJFU09MVVRJT047XG5cbiAgICBfdGhpcy53aWR0aCA9IE1hdGguY2VpbCh3aWR0aCk7XG4gICAgX3RoaXMuaGVpZ2h0ID0gTWF0aC5jZWlsKGhlaWdodCk7XG5cbiAgICBfdGhpcy5yZWFsV2lkdGggPSBfdGhpcy53aWR0aCAqIF90aGlzLnJlc29sdXRpb247XG4gICAgX3RoaXMucmVhbEhlaWdodCA9IF90aGlzLmhlaWdodCAqIF90aGlzLnJlc29sdXRpb247XG5cbiAgICBfdGhpcy5zY2FsZU1vZGUgPSBzY2FsZU1vZGUgIT09IHVuZGVmaW5lZCA/IHNjYWxlTW9kZSA6IF9zZXR0aW5nczIuZGVmYXVsdC5TQ0FMRV9NT0RFO1xuICAgIF90aGlzLmhhc0xvYWRlZCA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBBIG1hcCBvZiByZW5kZXJlciBJRHMgdG8gd2ViZ2wgcmVuZGVyVGFyZ2V0c1xuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbWVtYmVyIHtvYmplY3Q8bnVtYmVyLCBXZWJHTFRleHR1cmU+fVxuICAgICAqL1xuICAgIF90aGlzLl9nbFJlbmRlclRhcmdldHMgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEEgcmVmZXJlbmNlIHRvIHRoZSBjYW52YXMgcmVuZGVyIHRhcmdldCAod2Ugb25seSBuZWVkIG9uZSBhcyB0aGlzIGNhbiBiZSBzaGFyZWQgYWNyb3NzIHJlbmRlcmVycylcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG1lbWJlciB7b2JqZWN0PG51bWJlciwgV2ViR0xUZXh0dXJlPn1cbiAgICAgKi9cbiAgICBfdGhpcy5fY2FudmFzUmVuZGVyVGFyZ2V0ID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgd2lsbCBsZXQgdGhlIHJlbmRlcmVyIGtub3cgaWYgdGhlIHRleHR1cmUgaXMgdmFsaWQuIElmIGl0J3Mgbm90IHRoZW4gaXQgY2Fubm90IGJlIHJlbmRlcmVkLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBfdGhpcy52YWxpZCA9IGZhbHNlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNpemVzIHRoZSBCYXNlUmVuZGVyVGV4dHVyZS5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoIHRvIHJlc2l6ZSB0by5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQgdG8gcmVzaXplIHRvLlxuICAgKi9cblxuXG4gIEJhc2VSZW5kZXJUZXh0dXJlLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbiByZXNpemUod2lkdGgsIGhlaWdodCkge1xuICAgIHdpZHRoID0gTWF0aC5jZWlsKHdpZHRoKTtcbiAgICBoZWlnaHQgPSBNYXRoLmNlaWwoaGVpZ2h0KTtcblxuICAgIGlmICh3aWR0aCA9PT0gdGhpcy53aWR0aCAmJiBoZWlnaHQgPT09IHRoaXMuaGVpZ2h0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy52YWxpZCA9IHdpZHRoID4gMCAmJiBoZWlnaHQgPiAwO1xuXG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgdGhpcy5yZWFsV2lkdGggPSB0aGlzLndpZHRoICogdGhpcy5yZXNvbHV0aW9uO1xuICAgIHRoaXMucmVhbEhlaWdodCA9IHRoaXMuaGVpZ2h0ICogdGhpcy5yZXNvbHV0aW9uO1xuXG4gICAgaWYgKCF0aGlzLnZhbGlkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5lbWl0KCd1cGRhdGUnLCB0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogRGVzdHJveXMgdGhpcyB0ZXh0dXJlXG4gICAqXG4gICAqL1xuXG5cbiAgQmFzZVJlbmRlclRleHR1cmUucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIF9CYXNlVGV4dHVyZS5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMsIHRydWUpO1xuICAgIHRoaXMucmVuZGVyZXIgPSBudWxsO1xuICB9O1xuXG4gIHJldHVybiBCYXNlUmVuZGVyVGV4dHVyZTtcbn0oX0Jhc2VUZXh0dXJlMy5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gQmFzZVJlbmRlclRleHR1cmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CYXNlUmVuZGVyVGV4dHVyZS5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG52YXIgX3NldHRpbmdzID0gcmVxdWlyZSgnLi4vc2V0dGluZ3MnKTtcblxudmFyIF9zZXR0aW5nczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zZXR0aW5ncyk7XG5cbnZhciBfZXZlbnRlbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRlbWl0dGVyMycpO1xuXG52YXIgX2V2ZW50ZW1pdHRlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ldmVudGVtaXR0ZXIpO1xuXG52YXIgX2RldGVybWluZUNyb3NzT3JpZ2luID0gcmVxdWlyZSgnLi4vdXRpbHMvZGV0ZXJtaW5lQ3Jvc3NPcmlnaW4nKTtcblxudmFyIF9kZXRlcm1pbmVDcm9zc09yaWdpbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kZXRlcm1pbmVDcm9zc09yaWdpbik7XG5cbnZhciBfYml0VHdpZGRsZSA9IHJlcXVpcmUoJ2JpdC10d2lkZGxlJyk7XG5cbnZhciBfYml0VHdpZGRsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9iaXRUd2lkZGxlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4vKipcbiAqIEEgdGV4dHVyZSBzdG9yZXMgdGhlIGluZm9ybWF0aW9uIHRoYXQgcmVwcmVzZW50cyBhbiBpbWFnZS4gQWxsIHRleHR1cmVzIGhhdmUgYSBiYXNlIHRleHR1cmUuXG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBFdmVudEVtaXR0ZXJcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKi9cbnZhciBCYXNlVGV4dHVyZSA9IGZ1bmN0aW9uIChfRXZlbnRFbWl0dGVyKSB7XG4gICAgX2luaGVyaXRzKEJhc2VUZXh0dXJlLCBfRXZlbnRFbWl0dGVyKTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudH0gW3NvdXJjZV0gLSB0aGUgc291cmNlIG9iamVjdCBvZiB0aGUgdGV4dHVyZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3NjYWxlTW9kZT1QSVhJLnNldHRpbmdzLlNDQUxFX01PREVdIC0gU2VlIHtAbGluayBQSVhJLlNDQUxFX01PREVTfSBmb3IgcG9zc2libGUgdmFsdWVzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtyZXNvbHV0aW9uPTFdIC0gVGhlIHJlc29sdXRpb24gLyBkZXZpY2UgcGl4ZWwgcmF0aW8gb2YgdGhlIHRleHR1cmVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBCYXNlVGV4dHVyZShzb3VyY2UsIHNjYWxlTW9kZSwgcmVzb2x1dGlvbikge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQmFzZVRleHR1cmUpO1xuXG4gICAgICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9FdmVudEVtaXR0ZXIuY2FsbCh0aGlzKSk7XG5cbiAgICAgICAgX3RoaXMudWlkID0gKDAsIF91dGlscy51aWQpKCk7XG5cbiAgICAgICAgX3RoaXMudG91Y2hlZCA9IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSByZXNvbHV0aW9uIC8gZGV2aWNlIHBpeGVsIHJhdGlvIG9mIHRoZSB0ZXh0dXJlXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMucmVzb2x1dGlvbiA9IHJlc29sdXRpb24gfHwgX3NldHRpbmdzMi5kZWZhdWx0LlJFU09MVVRJT047XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB3aWR0aCBvZiB0aGUgYmFzZSB0ZXh0dXJlIHNldCB3aGVuIHRoZSBpbWFnZSBoYXMgbG9hZGVkXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZWFkb25seVxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy53aWR0aCA9IDEwMDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGhlaWdodCBvZiB0aGUgYmFzZSB0ZXh0dXJlIHNldCB3aGVuIHRoZSBpbWFnZSBoYXMgbG9hZGVkXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZWFkb25seVxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5oZWlnaHQgPSAxMDA7XG5cbiAgICAgICAgLy8gVE9ETyBkb2NzXG4gICAgICAgIC8vIHVzZWQgdG8gc3RvcmUgdGhlIGFjdHVhbCBkaW1lbnNpb25zIG9mIHRoZSBzb3VyY2VcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVzZWQgdG8gc3RvcmUgdGhlIGFjdHVhbCB3aWR0aCBvZiB0aGUgc291cmNlIG9mIHRoaXMgdGV4dHVyZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmVhZG9ubHlcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMucmVhbFdpZHRoID0gMTAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogVXNlZCB0byBzdG9yZSB0aGUgYWN0dWFsIGhlaWdodCBvZiB0aGUgc291cmNlIG9mIHRoaXMgdGV4dHVyZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmVhZG9ubHlcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMucmVhbEhlaWdodCA9IDEwMDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHNjYWxlIG1vZGUgdG8gYXBwbHkgd2hlbiBzY2FsaW5nIHRoaXMgdGV4dHVyZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IFBJWEkuc2V0dGluZ3MuU0NBTEVfTU9ERVxuICAgICAgICAgKiBAc2VlIFBJWEkuU0NBTEVfTU9ERVNcbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLnNjYWxlTW9kZSA9IHNjYWxlTW9kZSAhPT0gdW5kZWZpbmVkID8gc2NhbGVNb2RlIDogX3NldHRpbmdzMi5kZWZhdWx0LlNDQUxFX01PREU7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0byB0cnVlIG9uY2UgdGhlIGJhc2UgdGV4dHVyZSBoYXMgc3VjY2Vzc2Z1bGx5IGxvYWRlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBpcyBuZXZlciB0cnVlIGlmIHRoZSB1bmRlcmx5aW5nIHNvdXJjZSBmYWlscyB0byBsb2FkIG9yIGhhcyBubyB0ZXh0dXJlIGRhdGEuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZWFkb25seVxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuaGFzTG9hZGVkID0gZmFsc2U7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0byB0cnVlIGlmIHRoZSBzb3VyY2UgaXMgY3VycmVudGx5IGxvYWRpbmcuXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIGFuIEltYWdlIHNvdXJjZSBpcyBsb2FkaW5nIHRoZSAnbG9hZGVkJyBvciAnZXJyb3InIGV2ZW50IHdpbGwgYmVcbiAgICAgICAgICogZGlzcGF0Y2hlZCB3aGVuIHRoZSBvcGVyYXRpb24gZW5kcy4gQW4gdW5kZXJ5bGluZyBzb3VyY2UgdGhhdCBpc1xuICAgICAgICAgKiBpbW1lZGlhdGVseS1hdmFpbGFibGUgYnlwYXNzZXMgbG9hZGluZyBlbnRpcmVseS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5pc0xvYWRpbmcgPSBmYWxzZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGltYWdlIHNvdXJjZSB0aGF0IGlzIHVzZWQgdG8gY3JlYXRlIHRoZSB0ZXh0dXJlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUT0RPOiBNYWtlIHRoaXMgYSBzZXR0ZXIgdGhhdCBjYWxscyBsb2FkU291cmNlKCk7XG4gICAgICAgICAqXG4gICAgICAgICAqIEByZWFkb25seVxuICAgICAgICAgKiBAbWVtYmVyIHtIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuc291cmNlID0gbnVsbDsgLy8gc2V0IGluIGxvYWRTb3VyY2UsIGlmIGF0IGFsbFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgaW1hZ2Ugc291cmNlIHRoYXQgaXMgdXNlZCB0byBjcmVhdGUgdGhlIHRleHR1cmUuIFRoaXMgaXMgdXNlZCB0b1xuICAgICAgICAgKiBzdG9yZSB0aGUgb3JpZ2luYWwgU3ZnIHNvdXJjZSB3aGVuIGl0IGlzIHJlcGxhY2VkIHdpdGggYSBjYW52YXMgZWxlbWVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogVE9ETzogQ3VycmVudGx5IG5vdCBpbiB1c2UgYnV0IGNvdWxkIGJlIHVzZWQgd2hlbiByZS1zY2FsaW5nIHN2Zy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICAqIEBtZW1iZXIge0ltYWdlfVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMub3JpZ1NvdXJjZSA9IG51bGw7IC8vIHNldCBpbiBsb2FkU3ZnLCBpZiBhdCBhbGxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVHlwZSBvZiBpbWFnZSBkZWZpbmVkIGluIHNvdXJjZSwgZWcuIGBwbmdgIG9yIGBzdmdgXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZWFkb25seVxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5pbWFnZVR5cGUgPSBudWxsOyAvLyBzZXQgaW4gdXBkYXRlSW1hZ2VUeXBlXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNjYWxlIGZvciBzb3VyY2UgaW1hZ2UuIFVzZWQgd2l0aCBTdmcgaW1hZ2VzIHRvIHNjYWxlIHRoZW0gYmVmb3JlIHJhc3Rlcml6YXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZWFkb25seVxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5zb3VyY2VTY2FsZSA9IDEuMDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udHJvbHMgaWYgUkdCIGNoYW5uZWxzIHNob3VsZCBiZSBwcmUtbXVsdGlwbGllZCBieSBBbHBoYSAgKFdlYkdMIG9ubHkpXG4gICAgICAgICAqIEFsbCBibGVuZCBtb2RlcywgYW5kIHNoYWRlcnMgd3JpdHRlbiBmb3IgZGVmYXVsdCB2YWx1ZS4gQ2hhbmdlIGl0IG9uIHlvdXIgb3duIHJpc2suXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLnByZW11bHRpcGxpZWRBbHBoYSA9IHRydWU7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBpbWFnZSB1cmwgb2YgdGhlIHRleHR1cmVcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuaW1hZ2VVcmwgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgdGV4dHVyZSBpcyBhIHBvd2VyIG9mIHR3bywgdHJ5IHRvIHVzZSBwb3dlciBvZiB0d28gdGV4dHVyZXMgYXMgbXVjaFxuICAgICAgICAgKiBhcyB5b3UgY2FuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5pc1Bvd2VyT2ZUd28gPSBmYWxzZTtcblxuICAgICAgICAvLyB1c2VkIGZvciB3ZWJHTFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZXQgdGhpcyB0byB0cnVlIGlmIGEgbWlwbWFwIG9mIHRoaXMgdGV4dHVyZSBuZWVkcyB0byBiZSBnZW5lcmF0ZWQuIFRoaXMgdmFsdWUgbmVlZHNcbiAgICAgICAgICogdG8gYmUgc2V0IGJlZm9yZSB0aGUgdGV4dHVyZSBpcyB1c2VkXG4gICAgICAgICAqIEFsc28gdGhlIHRleHR1cmUgbXVzdCBiZSBhIHBvd2VyIG9mIHR3byBzaXplIHRvIHdvcmtcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgICAgICogQHNlZSBQSVhJLk1JUE1BUF9URVhUVVJFU1xuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMubWlwbWFwID0gX3NldHRpbmdzMi5kZWZhdWx0Lk1JUE1BUF9URVhUVVJFUztcblxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogV2ViR0wgVGV4dHVyZSB3cmFwIG1vZGVcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAc2VlIFBJWEkuV1JBUF9NT0RFU1xuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMud3JhcE1vZGUgPSBfc2V0dGluZ3MyLmRlZmF1bHQuV1JBUF9NT0RFO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIG1hcCBvZiByZW5kZXJlciBJRHMgdG8gd2ViZ2wgdGV4dHVyZXNcbiAgICAgICAgICpcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQG1lbWJlciB7b2JqZWN0PG51bWJlciwgV2ViR0xUZXh0dXJlPn1cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLl9nbFRleHR1cmVzID0ge307XG5cbiAgICAgICAgX3RoaXMuX2VuYWJsZWQgPSAwO1xuICAgICAgICBfdGhpcy5fdmlydGFsQm91bmRJZCA9IC0xO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0aGUgb2JqZWN0IGhhcyBiZWVuIGRlc3Ryb3llZCB2aWEgZGVzdHJveSgpLiBJZiB0cnVlLCBpdCBzaG91bGQgbm90IGJlIHVzZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEByZWFkb25seVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuX2Rlc3Ryb3llZCA9IGZhbHNlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgaWRzIHVuZGVyIHdoaWNoIHRoaXMgQmFzZVRleHR1cmUgaGFzIGJlZW4gYWRkZWQgdG8gdGhlIGJhc2UgdGV4dHVyZSBjYWNoZS4gVGhpcyBpc1xuICAgICAgICAgKiBhdXRvbWF0aWNhbGx5IHNldCBhcyBsb25nIGFzIEJhc2VUZXh0dXJlLmFkZFRvQ2FjaGUgaXMgdXNlZCwgYnV0IG1heSBub3QgYmUgc2V0IGlmIGFcbiAgICAgICAgICogQmFzZVRleHR1cmUgaXMgYWRkZWQgZGlyZWN0bHkgdG8gdGhlIEJhc2VUZXh0dXJlQ2FjaGUgYXJyYXkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge3N0cmluZ1tdfVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMudGV4dHVyZUNhY2hlSWRzID0gW107XG5cbiAgICAgICAgLy8gaWYgbm8gc291cmNlIHBhc3NlZCBkb24ndCB0cnkgdG8gbG9hZFxuICAgICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgICAgICBfdGhpcy5sb2FkU291cmNlKHNvdXJjZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZWQgd2hlbiBhIG5vdC1pbW1lZGlhdGVseS1hdmFpbGFibGUgc291cmNlIGZpbmlzaGVzIGxvYWRpbmcuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICogQGV2ZW50IFBJWEkuQmFzZVRleHR1cmUjbG9hZGVkXG4gICAgICAgICAqIEBwYXJhbSB7UElYSS5CYXNlVGV4dHVyZX0gYmFzZVRleHR1cmUgLSBSZXNvdXJjZSBsb2FkZWQuXG4gICAgICAgICAqL1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlZCB3aGVuIGEgbm90LWltbWVkaWF0ZWx5LWF2YWlsYWJsZSBzb3VyY2UgZmFpbHMgdG8gbG9hZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKiBAZXZlbnQgUElYSS5CYXNlVGV4dHVyZSNlcnJvclxuICAgICAgICAgKiBAcGFyYW0ge1BJWEkuQmFzZVRleHR1cmV9IGJhc2VUZXh0dXJlIC0gUmVzb3VyY2UgZXJyb3JlZC5cbiAgICAgICAgICovXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVkIHdoZW4gQmFzZVRleHR1cmUgaXMgdXBkYXRlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKiBAZXZlbnQgUElYSS5CYXNlVGV4dHVyZSN1cGRhdGVcbiAgICAgICAgICogQHBhcmFtIHtQSVhJLkJhc2VUZXh0dXJlfSBiYXNlVGV4dHVyZSAtIEluc3RhbmNlIG9mIHRleHR1cmUgYmVpbmcgdXBkYXRlZC5cbiAgICAgICAgICovXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVkIHdoZW4gQmFzZVRleHR1cmUgaXMgZGVzdHJveWVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqIEBldmVudCBQSVhJLkJhc2VUZXh0dXJlI2Rpc3Bvc2VcbiAgICAgICAgICogQHBhcmFtIHtQSVhJLkJhc2VUZXh0dXJlfSBiYXNlVGV4dHVyZSAtIEluc3RhbmNlIG9mIHRleHR1cmUgYmVpbmcgZGVzdHJveWVkLlxuICAgICAgICAgKi9cbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIHRleHR1cmUgb24gYWxsIHRoZSB3ZWJnbCByZW5kZXJlcnMsIHRoaXMgYWxzbyBhc3N1bWVzIHRoZSBzcmMgaGFzIGNoYW5nZWQuXG4gICAgICpcbiAgICAgKiBAZmlyZXMgUElYSS5CYXNlVGV4dHVyZSN1cGRhdGVcbiAgICAgKi9cblxuXG4gICAgQmFzZVRleHR1cmUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICAgICAgLy8gU3ZnIHNpemUgaXMgaGFuZGxlZCBkdXJpbmcgbG9hZFxuICAgICAgICBpZiAodGhpcy5pbWFnZVR5cGUgIT09ICdzdmcnKSB7XG4gICAgICAgICAgICB0aGlzLnJlYWxXaWR0aCA9IHRoaXMuc291cmNlLm5hdHVyYWxXaWR0aCB8fCB0aGlzLnNvdXJjZS52aWRlb1dpZHRoIHx8IHRoaXMuc291cmNlLndpZHRoO1xuICAgICAgICAgICAgdGhpcy5yZWFsSGVpZ2h0ID0gdGhpcy5zb3VyY2UubmF0dXJhbEhlaWdodCB8fCB0aGlzLnNvdXJjZS52aWRlb0hlaWdodCB8fCB0aGlzLnNvdXJjZS5oZWlnaHQ7XG5cbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZURpbWVuc2lvbnMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZW1pdCgndXBkYXRlJywgdGhpcyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBkaW1lbnNpb25zIGZyb20gcmVhbCB2YWx1ZXNcbiAgICAgKi9cblxuXG4gICAgQmFzZVRleHR1cmUucHJvdG90eXBlLl91cGRhdGVEaW1lbnNpb25zID0gZnVuY3Rpb24gX3VwZGF0ZURpbWVuc2lvbnMoKSB7XG4gICAgICAgIHRoaXMud2lkdGggPSB0aGlzLnJlYWxXaWR0aCAvIHRoaXMucmVzb2x1dGlvbjtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLnJlYWxIZWlnaHQgLyB0aGlzLnJlc29sdXRpb247XG5cbiAgICAgICAgdGhpcy5pc1Bvd2VyT2ZUd28gPSBfYml0VHdpZGRsZTIuZGVmYXVsdC5pc1BvdzIodGhpcy5yZWFsV2lkdGgpICYmIF9iaXRUd2lkZGxlMi5kZWZhdWx0LmlzUG93Mih0aGlzLnJlYWxIZWlnaHQpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBMb2FkIGEgc291cmNlLlxuICAgICAqXG4gICAgICogSWYgdGhlIHNvdXJjZSBpcyBub3QtaW1tZWRpYXRlbHktYXZhaWxhYmxlLCBzdWNoIGFzIGFuIGltYWdlIHRoYXQgbmVlZHMgdG8gYmVcbiAgICAgKiBkb3dubG9hZGVkLCB0aGVuIHRoZSAnbG9hZGVkJyBvciAnZXJyb3InIGV2ZW50IHdpbGwgYmUgZGlzcGF0Y2hlZCBpbiB0aGUgZnV0dXJlXG4gICAgICogYW5kIGBoYXNMb2FkZWRgIHdpbGwgcmVtYWluIGZhbHNlIGFmdGVyIHRoaXMgY2FsbC5cbiAgICAgKlxuICAgICAqIFRoZSBsb2dpYyBzdGF0ZSBhZnRlciBjYWxsaW5nIGBsb2FkU291cmNlYCBkaXJlY3RseSBvciBpbmRpcmVjdGx5IChlZy4gYGZyb21JbWFnZWAsIGBuZXcgQmFzZVRleHR1cmVgKSBpczpcbiAgICAgKlxuICAgICAqICAgICBpZiAodGV4dHVyZS5oYXNMb2FkZWQpIHtcbiAgICAgKiAgICAgICAgLy8gdGV4dHVyZSByZWFkeSBmb3IgdXNlXG4gICAgICogICAgIH0gZWxzZSBpZiAodGV4dHVyZS5pc0xvYWRpbmcpIHtcbiAgICAgKiAgICAgICAgLy8gbGlzdGVuIHRvICdsb2FkZWQnIGFuZC9vciAnZXJyb3InIGV2ZW50cyBvbiB0ZXh0dXJlXG4gICAgICogICAgIH0gZWxzZSB7XG4gICAgICogICAgICAgIC8vIG5vdCBsb2FkaW5nLCBub3QgZ29pbmcgdG8gbG9hZCBVTkxFU1MgdGhlIHNvdXJjZSBpcyByZWxvYWRlZFxuICAgICAqICAgICAgICAvLyAoaXQgbWF5IHN0aWxsIG1ha2Ugc2Vuc2UgdG8gbGlzdGVuIHRvIHRoZSBldmVudHMpXG4gICAgICogICAgIH1cbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR9IHNvdXJjZSAtIHRoZSBzb3VyY2Ugb2JqZWN0IG9mIHRoZSB0ZXh0dXJlLlxuICAgICAqL1xuXG5cbiAgICBCYXNlVGV4dHVyZS5wcm90b3R5cGUubG9hZFNvdXJjZSA9IGZ1bmN0aW9uIGxvYWRTb3VyY2Uoc291cmNlKSB7XG4gICAgICAgIHZhciB3YXNMb2FkaW5nID0gdGhpcy5pc0xvYWRpbmc7XG5cbiAgICAgICAgdGhpcy5oYXNMb2FkZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc0xvYWRpbmcgPSBmYWxzZTtcblxuICAgICAgICBpZiAod2FzTG9hZGluZyAmJiB0aGlzLnNvdXJjZSkge1xuICAgICAgICAgICAgdGhpcy5zb3VyY2Uub25sb2FkID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuc291cmNlLm9uZXJyb3IgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGZpcnN0U291cmNlTG9hZGVkID0gIXRoaXMuc291cmNlO1xuXG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuXG4gICAgICAgIC8vIEFwcGx5IHNvdXJjZSBpZiBsb2FkZWQuIE90aGVyd2lzZSBzZXR1cCBhcHByb3ByaWF0ZSBsb2FkaW5nIG1vbml0b3JzLlxuICAgICAgICBpZiAoKHNvdXJjZS5zcmMgJiYgc291cmNlLmNvbXBsZXRlIHx8IHNvdXJjZS5nZXRDb250ZXh0KSAmJiBzb3VyY2Uud2lkdGggJiYgc291cmNlLmhlaWdodCkge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlSW1hZ2VUeXBlKCk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmltYWdlVHlwZSA9PT0gJ3N2ZycpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2FkU3ZnU291cmNlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NvdXJjZUxvYWRlZCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZmlyc3RTb3VyY2VMb2FkZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBzZW5kIGxvYWRlZCBldmVudCBpZiBwcmV2aW91cyBzb3VyY2Ugd2FzIG51bGwgYW5kIHdlIGhhdmUgYmVlbiBwYXNzZWQgYSBwcmUtbG9hZGVkIElNRyBlbGVtZW50XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdsb2FkZWQnLCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghc291cmNlLmdldENvbnRleHQpIHtcbiAgICAgICAgICAgIC8vIEltYWdlIGZhaWwgLyBub3QgcmVhZHlcbiAgICAgICAgICAgIHRoaXMuaXNMb2FkaW5nID0gdHJ1ZTtcblxuICAgICAgICAgICAgdmFyIHNjb3BlID0gdGhpcztcblxuICAgICAgICAgICAgc291cmNlLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzY29wZS5fdXBkYXRlSW1hZ2VUeXBlKCk7XG4gICAgICAgICAgICAgICAgc291cmNlLm9ubG9hZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgc291cmNlLm9uZXJyb3IgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFzY29wZS5pc0xvYWRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHNjb3BlLmlzTG9hZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHNjb3BlLl9zb3VyY2VMb2FkZWQoKTtcblxuICAgICAgICAgICAgICAgIGlmIChzY29wZS5pbWFnZVR5cGUgPT09ICdzdmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjb3BlLl9sb2FkU3ZnU291cmNlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHNjb3BlLmVtaXQoJ2xvYWRlZCcsIHNjb3BlKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHNvdXJjZS5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHNvdXJjZS5vbmxvYWQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHNvdXJjZS5vbmVycm9yID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIGlmICghc2NvcGUuaXNMb2FkaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzY29wZS5pc0xvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBzY29wZS5lbWl0KCdlcnJvcicsIHNjb3BlKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIFBlciBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCN0aGUtaW1nLWVsZW1lbnRcbiAgICAgICAgICAgIC8vICAgXCJUaGUgdmFsdWUgb2YgYGNvbXBsZXRlYCBjYW4gdGh1cyBjaGFuZ2Ugd2hpbGUgYSBzY3JpcHQgaXMgZXhlY3V0aW5nLlwiXG4gICAgICAgICAgICAvLyBTbyBjb21wbGV0ZSBuZWVkcyB0byBiZSByZS1jaGVja2VkIGFmdGVyIHRoZSBjYWxsYmFja3MgaGF2ZSBiZWVuIGFkZGVkLi5cbiAgICAgICAgICAgIC8vIE5PVEU6IGNvbXBsZXRlIHdpbGwgYmUgdHJ1ZSBpZiB0aGUgaW1hZ2UgaGFzIG5vIHNyYyBzbyBiZXN0IHRvIGNoZWNrIGlmIHRoZSBzcmMgaXMgc2V0LlxuICAgICAgICAgICAgaWYgKHNvdXJjZS5jb21wbGV0ZSAmJiBzb3VyY2Uuc3JjKSB7XG4gICAgICAgICAgICAgICAgLy8gLi5hbmQgaWYgd2UncmUgY29tcGxldGUgbm93LCBubyBuZWVkIGZvciBjYWxsYmFja3NcbiAgICAgICAgICAgICAgICBzb3VyY2Uub25sb2FkID0gbnVsbDtcbiAgICAgICAgICAgICAgICBzb3VyY2Uub25lcnJvciA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICBpZiAoc2NvcGUuaW1hZ2VUeXBlID09PSAnc3ZnJykge1xuICAgICAgICAgICAgICAgICAgICBzY29wZS5fbG9hZFN2Z1NvdXJjZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmlzTG9hZGluZyA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZS53aWR0aCAmJiBzb3VyY2UuaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NvdXJjZUxvYWRlZCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIGFueSBwcmV2aW91cyBzdWJzY3JpYmVycyBwb3NzaWJsZVxuICAgICAgICAgICAgICAgICAgICBpZiAod2FzTG9hZGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdsb2FkZWQnLCB0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJZiBhbnkgcHJldmlvdXMgc3Vic2NyaWJlcnMgcG9zc2libGVcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh3YXNMb2FkaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHR5cGUgb2YgdGhlIHNvdXJjZSBpbWFnZS5cbiAgICAgKi9cblxuXG4gICAgQmFzZVRleHR1cmUucHJvdG90eXBlLl91cGRhdGVJbWFnZVR5cGUgPSBmdW5jdGlvbiBfdXBkYXRlSW1hZ2VUeXBlKCkge1xuICAgICAgICBpZiAoIXRoaXMuaW1hZ2VVcmwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkYXRhVXJpID0gKDAsIF91dGlscy5kZWNvbXBvc2VEYXRhVXJpKSh0aGlzLmltYWdlVXJsKTtcbiAgICAgICAgdmFyIGltYWdlVHlwZSA9IHZvaWQgMDtcblxuICAgICAgICBpZiAoZGF0YVVyaSAmJiBkYXRhVXJpLm1lZGlhVHlwZSA9PT0gJ2ltYWdlJykge1xuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIHN1YlR5cGUgdmFsaWRpdHlcbiAgICAgICAgICAgIHZhciBmaXJzdFN1YlR5cGUgPSBkYXRhVXJpLnN1YlR5cGUuc3BsaXQoJysnKVswXTtcblxuICAgICAgICAgICAgaW1hZ2VUeXBlID0gKDAsIF91dGlscy5nZXRVcmxGaWxlRXh0ZW5zaW9uKSgnLicgKyBmaXJzdFN1YlR5cGUpO1xuXG4gICAgICAgICAgICBpZiAoIWltYWdlVHlwZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbWFnZSB0eXBlIGluIGRhdGEgVVJJLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW1hZ2VUeXBlID0gKDAsIF91dGlscy5nZXRVcmxGaWxlRXh0ZW5zaW9uKSh0aGlzLmltYWdlVXJsKTtcblxuICAgICAgICAgICAgaWYgKCFpbWFnZVR5cGUpIHtcbiAgICAgICAgICAgICAgICBpbWFnZVR5cGUgPSAncG5nJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaW1hZ2VUeXBlID0gaW1hZ2VUeXBlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHNvdXJjZWAgaXMgYW4gU1ZHIGltYWdlIGFuZCB3aGV0aGVyIGl0J3MgbG9hZGVkIHZpYSBhIFVSTCBvciBhIGRhdGEgVVJJLiBUaGVuIGNhbGxzXG4gICAgICogYF9sb2FkU3ZnU291cmNlVXNpbmdEYXRhVXJpYCBvciBgX2xvYWRTdmdTb3VyY2VVc2luZ1hocmAuXG4gICAgICovXG5cblxuICAgIEJhc2VUZXh0dXJlLnByb3RvdHlwZS5fbG9hZFN2Z1NvdXJjZSA9IGZ1bmN0aW9uIF9sb2FkU3ZnU291cmNlKCkge1xuICAgICAgICBpZiAodGhpcy5pbWFnZVR5cGUgIT09ICdzdmcnKSB7XG4gICAgICAgICAgICAvLyBEbyBub3RoaW5nIGlmIHNvdXJjZSBpcyBub3Qgc3ZnXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGF0YVVyaSA9ICgwLCBfdXRpbHMuZGVjb21wb3NlRGF0YVVyaSkodGhpcy5pbWFnZVVybCk7XG5cbiAgICAgICAgaWYgKGRhdGFVcmkpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvYWRTdmdTb3VyY2VVc2luZ0RhdGFVcmkoZGF0YVVyaSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBXZSBnb3QgYW4gVVJMLCBzbyB3ZSBuZWVkIHRvIGRvIGFuIFhIUiB0byBjaGVjayB0aGUgc3ZnIHNpemVcbiAgICAgICAgICAgIHRoaXMuX2xvYWRTdmdTb3VyY2VVc2luZ1hocigpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlYWRzIGFuIFNWRyBzdHJpbmcgZnJvbSBkYXRhIFVSSSBhbmQgdGhlbiBjYWxscyBgX2xvYWRTdmdTb3VyY2VVc2luZ1N0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YVVyaSAtIFRoZSBkYXRhIHVyaSB0byBsb2FkIGZyb20uXG4gICAgICovXG5cblxuICAgIEJhc2VUZXh0dXJlLnByb3RvdHlwZS5fbG9hZFN2Z1NvdXJjZVVzaW5nRGF0YVVyaSA9IGZ1bmN0aW9uIF9sb2FkU3ZnU291cmNlVXNpbmdEYXRhVXJpKGRhdGFVcmkpIHtcbiAgICAgICAgdmFyIHN2Z1N0cmluZyA9IHZvaWQgMDtcblxuICAgICAgICBpZiAoZGF0YVVyaS5lbmNvZGluZyA9PT0gJ2Jhc2U2NCcpIHtcbiAgICAgICAgICAgIGlmICghYXRvYikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWW91ciBicm93c2VyIGRvZXNuXFwndCBzdXBwb3J0IGJhc2U2NCBjb252ZXJzaW9ucy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN2Z1N0cmluZyA9IGF0b2IoZGF0YVVyaS5kYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN2Z1N0cmluZyA9IGRhdGFVcmkuZGF0YTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2xvYWRTdmdTb3VyY2VVc2luZ1N0cmluZyhzdmdTdHJpbmcpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBMb2FkcyBhbiBTVkcgc3RyaW5nIGZyb20gYGltYWdlVXJsYCB1c2luZyBYSFIgYW5kIHRoZW4gY2FsbHMgYF9sb2FkU3ZnU291cmNlVXNpbmdTdHJpbmdgLlxuICAgICAqL1xuXG5cbiAgICBCYXNlVGV4dHVyZS5wcm90b3R5cGUuX2xvYWRTdmdTb3VyY2VVc2luZ1hociA9IGZ1bmN0aW9uIF9sb2FkU3ZnU291cmNlVXNpbmdYaHIoKSB7XG4gICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgIHZhciBzdmdYaHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgICAgICAvLyBUaGlzIHRocm93cyBlcnJvciBvbiBJRSwgc28gU1ZHIERvY3VtZW50IGNhbid0IGJlIHVzZWRcbiAgICAgICAgLy8gc3ZnWGhyLnJlc3BvbnNlVHlwZSA9ICdkb2N1bWVudCc7XG5cbiAgICAgICAgLy8gVGhpcyBpcyBub3QgbmVlZGVkIHNpbmNlIHdlIGxvYWQgdGhlIHN2ZyBhcyBzdHJpbmcgKGJyZWFrcyBJRSB0b28pXG4gICAgICAgIC8vIGJ1dCBvdmVycmlkZU1pbWVUeXBlKCkgY2FuIGJlIHVzZWQgdG8gZm9yY2UgdGhlIHJlc3BvbnNlIHRvIGJlIHBhcnNlZCBhcyBYTUxcbiAgICAgICAgLy8gc3ZnWGhyLm92ZXJyaWRlTWltZVR5cGUoJ2ltYWdlL3N2Zyt4bWwnKTtcblxuICAgICAgICBzdmdYaHIub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHN2Z1hoci5yZWFkeVN0YXRlICE9PSBzdmdYaHIuRE9ORSB8fCBzdmdYaHIuc3RhdHVzICE9PSAyMDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBsb2FkIFNWRyB1c2luZyBYSFIuJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF90aGlzMi5fbG9hZFN2Z1NvdXJjZVVzaW5nU3RyaW5nKHN2Z1hoci5yZXNwb25zZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgc3ZnWGhyLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMyLmVtaXQoJ2Vycm9yJywgX3RoaXMyKTtcbiAgICAgICAgfTtcblxuICAgICAgICBzdmdYaHIub3BlbignR0VUJywgdGhpcy5pbWFnZVVybCwgdHJ1ZSk7XG4gICAgICAgIHN2Z1hoci5zZW5kKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIExvYWRzIHRleHR1cmUgdXNpbmcgYW4gU1ZHIHN0cmluZy4gVGhlIG9yaWdpbmFsIFNWRyBJbWFnZSBpcyBzdG9yZWQgYXMgYG9yaWdTb3VyY2VgIGFuZCB0aGVcbiAgICAgKiBjcmVhdGVkIGNhbnZhcyBpcyB0aGUgbmV3IGBzb3VyY2VgLiBUaGUgU1ZHIGlzIHNjYWxlZCB1c2luZyBgc291cmNlU2NhbGVgLiBDYWxsZWQgYnlcbiAgICAgKiBgX2xvYWRTdmdTb3VyY2VVc2luZ1hocmAgb3IgYF9sb2FkU3ZnU291cmNlVXNpbmdEYXRhVXJpYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gc3ZnU3RyaW5nIFNWRyBzb3VyY2UgYXMgc3RyaW5nXG4gICAgICpcbiAgICAgKiBAZmlyZXMgUElYSS5CYXNlVGV4dHVyZSNsb2FkZWRcbiAgICAgKi9cblxuXG4gICAgQmFzZVRleHR1cmUucHJvdG90eXBlLl9sb2FkU3ZnU291cmNlVXNpbmdTdHJpbmcgPSBmdW5jdGlvbiBfbG9hZFN2Z1NvdXJjZVVzaW5nU3RyaW5nKHN2Z1N0cmluZykge1xuICAgICAgICB2YXIgc3ZnU2l6ZSA9ICgwLCBfdXRpbHMuZ2V0U3ZnU2l6ZSkoc3ZnU3RyaW5nKTtcblxuICAgICAgICB2YXIgc3ZnV2lkdGggPSBzdmdTaXplLndpZHRoO1xuICAgICAgICB2YXIgc3ZnSGVpZ2h0ID0gc3ZnU2l6ZS5oZWlnaHQ7XG5cbiAgICAgICAgaWYgKCFzdmdXaWR0aCB8fCAhc3ZnSGVpZ2h0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBTVkcgaW1hZ2UgbXVzdCBoYXZlIHdpZHRoIGFuZCBoZWlnaHQgZGVmaW5lZCAoaW4gcGl4ZWxzKSwgY2FudmFzIEFQSSBuZWVkcyB0aGVtLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2NhbGUgcmVhbFdpZHRoIGFuZCByZWFsSGVpZ2h0XG4gICAgICAgIHRoaXMucmVhbFdpZHRoID0gTWF0aC5yb3VuZChzdmdXaWR0aCAqIHRoaXMuc291cmNlU2NhbGUpO1xuICAgICAgICB0aGlzLnJlYWxIZWlnaHQgPSBNYXRoLnJvdW5kKHN2Z0hlaWdodCAqIHRoaXMuc291cmNlU2NhbGUpO1xuXG4gICAgICAgIHRoaXMuX3VwZGF0ZURpbWVuc2lvbnMoKTtcblxuICAgICAgICAvLyBDcmVhdGUgYSBjYW52YXMgZWxlbWVudFxuICAgICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG5cbiAgICAgICAgY2FudmFzLndpZHRoID0gdGhpcy5yZWFsV2lkdGg7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSB0aGlzLnJlYWxIZWlnaHQ7XG4gICAgICAgIGNhbnZhcy5fcGl4aUlkID0gJ2NhbnZhc18nICsgKDAsIF91dGlscy51aWQpKCk7XG5cbiAgICAgICAgLy8gRHJhdyB0aGUgU3ZnIHRvIHRoZSBjYW52YXNcbiAgICAgICAgY2FudmFzLmdldENvbnRleHQoJzJkJykuZHJhd0ltYWdlKHRoaXMuc291cmNlLCAwLCAwLCBzdmdXaWR0aCwgc3ZnSGVpZ2h0LCAwLCAwLCB0aGlzLnJlYWxXaWR0aCwgdGhpcy5yZWFsSGVpZ2h0KTtcblxuICAgICAgICAvLyBSZXBsYWNlIHRoZSBvcmlnaW5hbCBzb3VyY2UgaW1hZ2Ugd2l0aCB0aGUgY2FudmFzXG4gICAgICAgIHRoaXMub3JpZ1NvdXJjZSA9IHRoaXMuc291cmNlO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IGNhbnZhcztcblxuICAgICAgICAvLyBBZGQgYWxzbyB0aGUgY2FudmFzIGluIGNhY2hlIChkZXN0cm95IGNsZWFycyBieSBgaW1hZ2VVcmxgIGFuZCBgc291cmNlLl9waXhpSWRgKVxuICAgICAgICBCYXNlVGV4dHVyZS5hZGRUb0NhY2hlKHRoaXMsIGNhbnZhcy5fcGl4aUlkKTtcblxuICAgICAgICB0aGlzLmlzTG9hZGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9zb3VyY2VMb2FkZWQoKTtcbiAgICAgICAgdGhpcy5lbWl0KCdsb2FkZWQnLCB0aGlzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVXNlZCBpbnRlcm5hbGx5IHRvIHVwZGF0ZSB0aGUgd2lkdGgsIGhlaWdodCwgYW5kIHNvbWUgb3RoZXIgdHJhY2tpbmcgdmFycyBvbmNlXG4gICAgICogYSBzb3VyY2UgaGFzIHN1Y2Nlc3NmdWxseSBsb2FkZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG5cbiAgICBCYXNlVGV4dHVyZS5wcm90b3R5cGUuX3NvdXJjZUxvYWRlZCA9IGZ1bmN0aW9uIF9zb3VyY2VMb2FkZWQoKSB7XG4gICAgICAgIHRoaXMuaGFzTG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGVzdHJveXMgdGhpcyBiYXNlIHRleHR1cmVcbiAgICAgKlxuICAgICAqL1xuXG5cbiAgICBCYXNlVGV4dHVyZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLmltYWdlVXJsKSB7XG4gICAgICAgICAgICBkZWxldGUgX3V0aWxzLlRleHR1cmVDYWNoZVt0aGlzLmltYWdlVXJsXTtcblxuICAgICAgICAgICAgdGhpcy5pbWFnZVVybCA9IG51bGw7XG5cbiAgICAgICAgICAgIGlmICghbmF2aWdhdG9yLmlzQ29jb29uSlMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNvdXJjZS5zcmMgPSAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc291cmNlID0gbnVsbDtcblxuICAgICAgICB0aGlzLmRpc3Bvc2UoKTtcblxuICAgICAgICBCYXNlVGV4dHVyZS5yZW1vdmVGcm9tQ2FjaGUodGhpcyk7XG4gICAgICAgIHRoaXMudGV4dHVyZUNhY2hlSWRzID0gbnVsbDtcblxuICAgICAgICB0aGlzLl9kZXN0cm95ZWQgPSB0cnVlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGcmVlcyB0aGUgdGV4dHVyZSBmcm9tIFdlYkdMIG1lbW9yeSB3aXRob3V0IGRlc3Ryb3lpbmcgdGhpcyB0ZXh0dXJlIG9iamVjdC5cbiAgICAgKiBUaGlzIG1lYW5zIHlvdSBjYW4gc3RpbGwgdXNlIHRoZSB0ZXh0dXJlIGxhdGVyIHdoaWNoIHdpbGwgdXBsb2FkIGl0IHRvIEdQVVxuICAgICAqIG1lbW9yeSBhZ2Fpbi5cbiAgICAgKlxuICAgICAqIEBmaXJlcyBQSVhJLkJhc2VUZXh0dXJlI2Rpc3Bvc2VcbiAgICAgKi9cblxuXG4gICAgQmFzZVRleHR1cmUucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgICAgICB0aGlzLmVtaXQoJ2Rpc3Bvc2UnLCB0aGlzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyB0aGUgc291cmNlIGltYWdlIG9mIHRoZSB0ZXh0dXJlLlxuICAgICAqIFRoZSBvcmlnaW5hbCBzb3VyY2UgbXVzdCBiZSBhbiBJbWFnZSBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5ld1NyYyAtIHRoZSBwYXRoIG9mIHRoZSBpbWFnZVxuICAgICAqL1xuXG5cbiAgICBCYXNlVGV4dHVyZS5wcm90b3R5cGUudXBkYXRlU291cmNlSW1hZ2UgPSBmdW5jdGlvbiB1cGRhdGVTb3VyY2VJbWFnZShuZXdTcmMpIHtcbiAgICAgICAgdGhpcy5zb3VyY2Uuc3JjID0gbmV3U3JjO1xuXG4gICAgICAgIHRoaXMubG9hZFNvdXJjZSh0aGlzLnNvdXJjZSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgYSBiYXNlIHRleHR1cmUgZnJvbSB0aGUgZ2l2ZW4gaW1hZ2UgdXJsLlxuICAgICAqIElmIHRoZSBpbWFnZSBpcyBub3QgaW4gdGhlIGJhc2UgdGV4dHVyZSBjYWNoZSBpdCB3aWxsIGJlIGNyZWF0ZWQgYW5kIGxvYWRlZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaW1hZ2VVcmwgLSBUaGUgaW1hZ2UgdXJsIG9mIHRoZSB0ZXh0dXJlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbY3Jvc3NvcmlnaW49KGF1dG8pXSAtIFNob3VsZCB1c2UgYW5vbnltb3VzIENPUlM/IERlZmF1bHRzIHRvIHRydWUgaWYgdGhlIFVSTCBpcyBub3QgYSBkYXRhLVVSSS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3NjYWxlTW9kZT1QSVhJLnNldHRpbmdzLlNDQUxFX01PREVdIC0gU2VlIHtAbGluayBQSVhJLlNDQUxFX01PREVTfSBmb3IgcG9zc2libGUgdmFsdWVzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzb3VyY2VTY2FsZT0oYXV0byldIC0gU2NhbGUgZm9yIHRoZSBvcmlnaW5hbCBpbWFnZSwgdXNlZCB3aXRoIFN2ZyBpbWFnZXMuXG4gICAgICogQHJldHVybiB7UElYSS5CYXNlVGV4dHVyZX0gVGhlIG5ldyBiYXNlIHRleHR1cmUuXG4gICAgICovXG5cblxuICAgIEJhc2VUZXh0dXJlLmZyb21JbWFnZSA9IGZ1bmN0aW9uIGZyb21JbWFnZShpbWFnZVVybCwgY3Jvc3NvcmlnaW4sIHNjYWxlTW9kZSwgc291cmNlU2NhbGUpIHtcbiAgICAgICAgdmFyIGJhc2VUZXh0dXJlID0gX3V0aWxzLkJhc2VUZXh0dXJlQ2FjaGVbaW1hZ2VVcmxdO1xuXG4gICAgICAgIGlmICghYmFzZVRleHR1cmUpIHtcbiAgICAgICAgICAgIC8vIG5ldyBJbWFnZSgpIGJyZWFrcyB0ZXggbG9hZGluZyBpbiBzb21lIHZlcnNpb25zIG9mIENocm9tZS5cbiAgICAgICAgICAgIC8vIFNlZSBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MjM4MDcxXG4gICAgICAgICAgICB2YXIgaW1hZ2UgPSBuZXcgSW1hZ2UoKTsgLy8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XG5cbiAgICAgICAgICAgIGlmIChjcm9zc29yaWdpbiA9PT0gdW5kZWZpbmVkICYmIGltYWdlVXJsLmluZGV4T2YoJ2RhdGE6JykgIT09IDApIHtcbiAgICAgICAgICAgICAgICBpbWFnZS5jcm9zc09yaWdpbiA9ICgwLCBfZGV0ZXJtaW5lQ3Jvc3NPcmlnaW4yLmRlZmF1bHQpKGltYWdlVXJsKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY3Jvc3NvcmlnaW4pIHtcbiAgICAgICAgICAgICAgICBpbWFnZS5jcm9zc09yaWdpbiA9IHR5cGVvZiBjcm9zc29yaWdpbiA9PT0gJ3N0cmluZycgPyBjcm9zc29yaWdpbiA6ICdhbm9ueW1vdXMnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBiYXNlVGV4dHVyZSA9IG5ldyBCYXNlVGV4dHVyZShpbWFnZSwgc2NhbGVNb2RlKTtcbiAgICAgICAgICAgIGJhc2VUZXh0dXJlLmltYWdlVXJsID0gaW1hZ2VVcmw7XG5cbiAgICAgICAgICAgIGlmIChzb3VyY2VTY2FsZSkge1xuICAgICAgICAgICAgICAgIGJhc2VUZXh0dXJlLnNvdXJjZVNjYWxlID0gc291cmNlU2NhbGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIGFuIEAyeCBhdCB0aGUgZW5kIG9mIHRoZSB1cmwgd2UgYXJlIGdvaW5nIHRvIGFzc3VtZSBpdHMgYSBoaWdocmVzIGltYWdlXG4gICAgICAgICAgICBiYXNlVGV4dHVyZS5yZXNvbHV0aW9uID0gKDAsIF91dGlscy5nZXRSZXNvbHV0aW9uT2ZVcmwpKGltYWdlVXJsKTtcblxuICAgICAgICAgICAgaW1hZ2Uuc3JjID0gaW1hZ2VVcmw7IC8vIFNldHRpbmcgdGhpcyB0cmlnZ2VycyBsb2FkXG5cbiAgICAgICAgICAgIEJhc2VUZXh0dXJlLmFkZFRvQ2FjaGUoYmFzZVRleHR1cmUsIGltYWdlVXJsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBiYXNlVGV4dHVyZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyBhIGJhc2UgdGV4dHVyZSBmcm9tIHRoZSBnaXZlbiBjYW52YXMgZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXMgLSBUaGUgY2FudmFzIGVsZW1lbnQgc291cmNlIG9mIHRoZSB0ZXh0dXJlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNjYWxlTW9kZSAtIFNlZSB7QGxpbmsgUElYSS5TQ0FMRV9NT0RFU30gZm9yIHBvc3NpYmxlIHZhbHVlc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3JpZ2luPSdjYW52YXMnXSAtIEEgc3RyaW5nIG9yaWdpbiBvZiB3aG8gY3JlYXRlZCB0aGUgYmFzZSB0ZXh0dXJlXG4gICAgICogQHJldHVybiB7UElYSS5CYXNlVGV4dHVyZX0gVGhlIG5ldyBiYXNlIHRleHR1cmUuXG4gICAgICovXG5cblxuICAgIEJhc2VUZXh0dXJlLmZyb21DYW52YXMgPSBmdW5jdGlvbiBmcm9tQ2FudmFzKGNhbnZhcywgc2NhbGVNb2RlKSB7XG4gICAgICAgIHZhciBvcmlnaW4gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6ICdjYW52YXMnO1xuXG4gICAgICAgIGlmICghY2FudmFzLl9waXhpSWQpIHtcbiAgICAgICAgICAgIGNhbnZhcy5fcGl4aUlkID0gb3JpZ2luICsgJ18nICsgKDAsIF91dGlscy51aWQpKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYmFzZVRleHR1cmUgPSBfdXRpbHMuQmFzZVRleHR1cmVDYWNoZVtjYW52YXMuX3BpeGlJZF07XG5cbiAgICAgICAgaWYgKCFiYXNlVGV4dHVyZSkge1xuICAgICAgICAgICAgYmFzZVRleHR1cmUgPSBuZXcgQmFzZVRleHR1cmUoY2FudmFzLCBzY2FsZU1vZGUpO1xuICAgICAgICAgICAgQmFzZVRleHR1cmUuYWRkVG9DYWNoZShiYXNlVGV4dHVyZSwgY2FudmFzLl9waXhpSWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGJhc2VUZXh0dXJlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIGEgYmFzZSB0ZXh0dXJlIGJhc2VkIG9uIHRoZSBzb3VyY2UgeW91IHByb3ZpZGUuXG4gICAgICogVGhlIHNvdXJjZSBjYW4gYmUgLSBpbWFnZSB1cmwsIGltYWdlIGVsZW1lbnQsIGNhbnZhcyBlbGVtZW50LiBJZiB0aGVcbiAgICAgKiBzb3VyY2UgaXMgYW4gaW1hZ2UgdXJsIG9yIGFuIGltYWdlIGVsZW1lbnQgYW5kIG5vdCBpbiB0aGUgYmFzZSB0ZXh0dXJlXG4gICAgICogY2FjaGUsIGl0IHdpbGwgYmUgY3JlYXRlZCBhbmQgbG9hZGVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfEhUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR9IHNvdXJjZSAtIFRoZSBzb3VyY2UgdG8gY3JlYXRlIGJhc2UgdGV4dHVyZSBmcm9tLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc2NhbGVNb2RlPVBJWEkuc2V0dGluZ3MuU0NBTEVfTU9ERV0gLSBTZWUge0BsaW5rIFBJWEkuU0NBTEVfTU9ERVN9IGZvciBwb3NzaWJsZSB2YWx1ZXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3NvdXJjZVNjYWxlPShhdXRvKV0gLSBTY2FsZSBmb3IgdGhlIG9yaWdpbmFsIGltYWdlLCB1c2VkIHdpdGggU3ZnIGltYWdlcy5cbiAgICAgKiBAcmV0dXJuIHtQSVhJLkJhc2VUZXh0dXJlfSBUaGUgbmV3IGJhc2UgdGV4dHVyZS5cbiAgICAgKi9cblxuXG4gICAgQmFzZVRleHR1cmUuZnJvbSA9IGZ1bmN0aW9uIGZyb20oc291cmNlLCBzY2FsZU1vZGUsIHNvdXJjZVNjYWxlKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc291cmNlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIEJhc2VUZXh0dXJlLmZyb21JbWFnZShzb3VyY2UsIHVuZGVmaW5lZCwgc2NhbGVNb2RlLCBzb3VyY2VTY2FsZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc291cmNlIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIGltYWdlVXJsID0gc291cmNlLnNyYztcbiAgICAgICAgICAgIHZhciBiYXNlVGV4dHVyZSA9IF91dGlscy5CYXNlVGV4dHVyZUNhY2hlW2ltYWdlVXJsXTtcblxuICAgICAgICAgICAgaWYgKCFiYXNlVGV4dHVyZSkge1xuICAgICAgICAgICAgICAgIGJhc2VUZXh0dXJlID0gbmV3IEJhc2VUZXh0dXJlKHNvdXJjZSwgc2NhbGVNb2RlKTtcbiAgICAgICAgICAgICAgICBiYXNlVGV4dHVyZS5pbWFnZVVybCA9IGltYWdlVXJsO1xuXG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZVNjYWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGJhc2VUZXh0dXJlLnNvdXJjZVNjYWxlID0gc291cmNlU2NhbGU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgYW4gQDJ4IGF0IHRoZSBlbmQgb2YgdGhlIHVybCB3ZSBhcmUgZ29pbmcgdG8gYXNzdW1lIGl0cyBhIGhpZ2hyZXMgaW1hZ2VcbiAgICAgICAgICAgICAgICBiYXNlVGV4dHVyZS5yZXNvbHV0aW9uID0gKDAsIF91dGlscy5nZXRSZXNvbHV0aW9uT2ZVcmwpKGltYWdlVXJsKTtcblxuICAgICAgICAgICAgICAgIEJhc2VUZXh0dXJlLmFkZFRvQ2FjaGUoYmFzZVRleHR1cmUsIGltYWdlVXJsKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGJhc2VUZXh0dXJlO1xuICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZSBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gQmFzZVRleHR1cmUuZnJvbUNhbnZhcyhzb3VyY2UsIHNjYWxlTW9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBsZXRzIGFzc3VtZSBpdHMgYSBiYXNlIHRleHR1cmUhXG4gICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBCYXNlVGV4dHVyZSB0byB0aGUgZ2xvYmFsIEJhc2VUZXh0dXJlQ2FjaGUuIFRoaXMgY2FjaGUgaXMgc2hhcmVkIGFjcm9zcyB0aGUgd2hvbGUgUElYSSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtQSVhJLkJhc2VUZXh0dXJlfSBiYXNlVGV4dHVyZSAtIFRoZSBCYXNlVGV4dHVyZSB0byBhZGQgdG8gdGhlIGNhY2hlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCAtIFRoZSBpZCB0aGF0IHRoZSBCYXNlVGV4dHVyZSB3aWxsIGJlIHN0b3JlZCBhZ2FpbnN0LlxuICAgICAqL1xuXG5cbiAgICBCYXNlVGV4dHVyZS5hZGRUb0NhY2hlID0gZnVuY3Rpb24gYWRkVG9DYWNoZShiYXNlVGV4dHVyZSwgaWQpIHtcbiAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICBpZiAoYmFzZVRleHR1cmUudGV4dHVyZUNhY2hlSWRzLmluZGV4T2YoaWQpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGJhc2VUZXh0dXJlLnRleHR1cmVDYWNoZUlkcy5wdXNoKGlkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQGlmIERFQlVHXG4gICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG4gICAgICAgICAgICBpZiAoX3V0aWxzLkJhc2VUZXh0dXJlQ2FjaGVbaWRdKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdCYXNlVGV4dHVyZSBhZGRlZCB0byB0aGUgY2FjaGUgd2l0aCBhbiBpZCBbJyArIGlkICsgJ10gdGhhdCBhbHJlYWR5IGhhZCBhbiBlbnRyeScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1jb25zb2xlICovXG4gICAgICAgICAgICAvLyBAZW5kaWZcblxuICAgICAgICAgICAgX3V0aWxzLkJhc2VUZXh0dXJlQ2FjaGVbaWRdID0gYmFzZVRleHR1cmU7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEgQmFzZVRleHR1cmUgZnJvbSB0aGUgZ2xvYmFsIEJhc2VUZXh0dXJlQ2FjaGUuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtzdHJpbmd8UElYSS5CYXNlVGV4dHVyZX0gYmFzZVRleHR1cmUgLSBpZCBvZiBhIEJhc2VUZXh0dXJlIHRvIGJlIHJlbW92ZWQsIG9yIGEgQmFzZVRleHR1cmUgaW5zdGFuY2UgaXRzZWxmLlxuICAgICAqIEByZXR1cm4ge1BJWEkuQmFzZVRleHR1cmV8bnVsbH0gVGhlIEJhc2VUZXh0dXJlIHRoYXQgd2FzIHJlbW92ZWQuXG4gICAgICovXG5cblxuICAgIEJhc2VUZXh0dXJlLnJlbW92ZUZyb21DYWNoZSA9IGZ1bmN0aW9uIHJlbW92ZUZyb21DYWNoZShiYXNlVGV4dHVyZSkge1xuICAgICAgICBpZiAodHlwZW9mIGJhc2VUZXh0dXJlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdmFyIGJhc2VUZXh0dXJlRnJvbUNhY2hlID0gX3V0aWxzLkJhc2VUZXh0dXJlQ2FjaGVbYmFzZVRleHR1cmVdO1xuXG4gICAgICAgICAgICBpZiAoYmFzZVRleHR1cmVGcm9tQ2FjaGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBiYXNlVGV4dHVyZUZyb21DYWNoZS50ZXh0dXJlQ2FjaGVJZHMuaW5kZXhPZihiYXNlVGV4dHVyZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICBiYXNlVGV4dHVyZUZyb21DYWNoZS50ZXh0dXJlQ2FjaGVJZHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBkZWxldGUgX3V0aWxzLkJhc2VUZXh0dXJlQ2FjaGVbYmFzZVRleHR1cmVdO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJhc2VUZXh0dXJlRnJvbUNhY2hlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGJhc2VUZXh0dXJlICYmIGJhc2VUZXh0dXJlLnRleHR1cmVDYWNoZUlkcykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiYXNlVGV4dHVyZS50ZXh0dXJlQ2FjaGVJZHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgX3V0aWxzLkJhc2VUZXh0dXJlQ2FjaGVbYmFzZVRleHR1cmUudGV4dHVyZUNhY2hlSWRzW2ldXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYmFzZVRleHR1cmUudGV4dHVyZUNhY2hlSWRzLmxlbmd0aCA9IDA7XG5cbiAgICAgICAgICAgIHJldHVybiBiYXNlVGV4dHVyZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICByZXR1cm4gQmFzZVRleHR1cmU7XG59KF9ldmVudGVtaXR0ZXIyLmRlZmF1bHQpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBCYXNlVGV4dHVyZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJhc2VUZXh0dXJlLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9CYXNlUmVuZGVyVGV4dHVyZSA9IHJlcXVpcmUoJy4vQmFzZVJlbmRlclRleHR1cmUnKTtcblxudmFyIF9CYXNlUmVuZGVyVGV4dHVyZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9CYXNlUmVuZGVyVGV4dHVyZSk7XG5cbnZhciBfVGV4dHVyZTIgPSByZXF1aXJlKCcuL1RleHR1cmUnKTtcblxudmFyIF9UZXh0dXJlMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1RleHR1cmUyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4vKipcbiAqIEEgUmVuZGVyVGV4dHVyZSBpcyBhIHNwZWNpYWwgdGV4dHVyZSB0aGF0IGFsbG93cyBhbnkgUGl4aUpTIGRpc3BsYXkgb2JqZWN0IHRvIGJlIHJlbmRlcmVkIHRvIGl0LlxuICpcbiAqIF9fSGludF9fOiBBbGwgRGlzcGxheU9iamVjdHMgKGkuZS4gU3ByaXRlcykgdGhhdCByZW5kZXIgdG8gYSBSZW5kZXJUZXh0dXJlIHNob3VsZCBiZSBwcmVsb2FkZWRcbiAqIG90aGVyd2lzZSBibGFjayByZWN0YW5nbGVzIHdpbGwgYmUgZHJhd24gaW5zdGVhZC5cbiAqXG4gKiBBIFJlbmRlclRleHR1cmUgdGFrZXMgYSBzbmFwc2hvdCBvZiBhbnkgRGlzcGxheSBPYmplY3QgZ2l2ZW4gdG8gaXRzIHJlbmRlciBtZXRob2QuIEZvciBleGFtcGxlOlxuICpcbiAqIGBgYGpzXG4gKiBsZXQgcmVuZGVyZXIgPSBQSVhJLmF1dG9EZXRlY3RSZW5kZXJlcigxMDI0LCAxMDI0KTtcbiAqIGxldCByZW5kZXJUZXh0dXJlID0gUElYSS5SZW5kZXJUZXh0dXJlLmNyZWF0ZSg4MDAsIDYwMCk7XG4gKiBsZXQgc3ByaXRlID0gUElYSS5TcHJpdGUuZnJvbUltYWdlKFwic3Bpbk9ial8wMS5wbmdcIik7XG4gKlxuICogc3ByaXRlLnBvc2l0aW9uLnggPSA4MDAvMjtcbiAqIHNwcml0ZS5wb3NpdGlvbi55ID0gNjAwLzI7XG4gKiBzcHJpdGUuYW5jaG9yLnggPSAwLjU7XG4gKiBzcHJpdGUuYW5jaG9yLnkgPSAwLjU7XG4gKlxuICogcmVuZGVyZXIucmVuZGVyKHNwcml0ZSwgcmVuZGVyVGV4dHVyZSk7XG4gKiBgYGBcbiAqXG4gKiBUaGUgU3ByaXRlIGluIHRoaXMgY2FzZSB3aWxsIGJlIHJlbmRlcmVkIHVzaW5nIGl0cyBsb2NhbCB0cmFuc2Zvcm0uIFRvIHJlbmRlciB0aGlzIHNwcml0ZSBhdCAwLDBcbiAqIHlvdSBjYW4gY2xlYXIgdGhlIHRyYW5zZm9ybVxuICpcbiAqIGBgYGpzXG4gKlxuICogc3ByaXRlLnNldFRyYW5zZm9ybSgpXG4gKlxuICogbGV0IHJlbmRlclRleHR1cmUgPSBuZXcgUElYSS5SZW5kZXJUZXh0dXJlLmNyZWF0ZSgxMDAsIDEwMCk7XG4gKlxuICogcmVuZGVyZXIucmVuZGVyKHNwcml0ZSwgcmVuZGVyVGV4dHVyZSk7ICAvLyBSZW5kZXJzIHRvIGNlbnRlciBvZiBSZW5kZXJUZXh0dXJlXG4gKiBgYGBcbiAqXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIFBJWEkuVGV4dHVyZVxuICogQG1lbWJlcm9mIFBJWElcbiAqL1xudmFyIFJlbmRlclRleHR1cmUgPSBmdW5jdGlvbiAoX1RleHR1cmUpIHtcbiAgICBfaW5oZXJpdHMoUmVuZGVyVGV4dHVyZSwgX1RleHR1cmUpO1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtQSVhJLkJhc2VSZW5kZXJUZXh0dXJlfSBiYXNlUmVuZGVyVGV4dHVyZSAtIFRoZSByZW5kZXJlciB1c2VkIGZvciB0aGlzIFJlbmRlclRleHR1cmVcbiAgICAgKiBAcGFyYW0ge1BJWEkuUmVjdGFuZ2xlfSBbZnJhbWVdIC0gVGhlIHJlY3RhbmdsZSBmcmFtZSBvZiB0aGUgdGV4dHVyZSB0byBzaG93XG4gICAgICovXG4gICAgZnVuY3Rpb24gUmVuZGVyVGV4dHVyZShiYXNlUmVuZGVyVGV4dHVyZSwgZnJhbWUpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJlbmRlclRleHR1cmUpO1xuXG4gICAgICAgIC8vIHN1cHBvcnQgZm9yIGxlZ2FjeS4uXG4gICAgICAgIHZhciBfbGVnYWN5UmVuZGVyZXIgPSBudWxsO1xuXG4gICAgICAgIGlmICghKGJhc2VSZW5kZXJUZXh0dXJlIGluc3RhbmNlb2YgX0Jhc2VSZW5kZXJUZXh0dXJlMi5kZWZhdWx0KSkge1xuICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgcHJlZmVyLXJlc3QtcGFyYW1zLCBuby1jb25zb2xlICovXG4gICAgICAgICAgICB2YXIgd2lkdGggPSBhcmd1bWVudHNbMV07XG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gYXJndW1lbnRzWzJdO1xuICAgICAgICAgICAgdmFyIHNjYWxlTW9kZSA9IGFyZ3VtZW50c1szXTtcbiAgICAgICAgICAgIHZhciByZXNvbHV0aW9uID0gYXJndW1lbnRzWzRdO1xuXG4gICAgICAgICAgICAvLyB3ZSBoYXZlIGFuIG9sZCByZW5kZXIgdGV4dHVyZS4uXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1BsZWFzZSB1c2UgUmVuZGVyVGV4dHVyZS5jcmVhdGUoJyArIHdpZHRoICsgJywgJyArIGhlaWdodCArICcpIGluc3RlYWQgb2YgdGhlIGN0b3IgZGlyZWN0bHkuJyk7XG4gICAgICAgICAgICBfbGVnYWN5UmVuZGVyZXIgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIHByZWZlci1yZXN0LXBhcmFtcywgbm8tY29uc29sZSAqL1xuXG4gICAgICAgICAgICBmcmFtZSA9IG51bGw7XG4gICAgICAgICAgICBiYXNlUmVuZGVyVGV4dHVyZSA9IG5ldyBfQmFzZVJlbmRlclRleHR1cmUyLmRlZmF1bHQod2lkdGgsIGhlaWdodCwgc2NhbGVNb2RlLCByZXNvbHV0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYmFzZSB0ZXh0dXJlIG9iamVjdCB0aGF0IHRoaXMgdGV4dHVyZSB1c2VzXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge0Jhc2VUZXh0dXJlfVxuICAgICAgICAgKi9cblxuICAgICAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfVGV4dHVyZS5jYWxsKHRoaXMsIGJhc2VSZW5kZXJUZXh0dXJlLCBmcmFtZSkpO1xuXG4gICAgICAgIF90aGlzLmxlZ2FjeVJlbmRlcmVyID0gX2xlZ2FjeVJlbmRlcmVyO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIHdpbGwgbGV0IHRoZSByZW5kZXJlciBrbm93IGlmIHRoZSB0ZXh0dXJlIGlzIHZhbGlkLiBJZiBpdCdzIG5vdCB0aGVuIGl0IGNhbm5vdCBiZSByZW5kZXJlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLnZhbGlkID0gdHJ1ZTtcblxuICAgICAgICBfdGhpcy5fdXBkYXRlVXZzKCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXNpemVzIHRoZSBSZW5kZXJUZXh0dXJlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoIHRvIHJlc2l6ZSB0by5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodCB0byByZXNpemUgdG8uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBkb05vdFJlc2l6ZUJhc2VUZXh0dXJlIC0gU2hvdWxkIHRoZSBiYXNlVGV4dHVyZS53aWR0aCBhbmQgaGVpZ2h0IHZhbHVlcyBiZSByZXNpemVkIGFzIHdlbGw/XG4gICAgICovXG5cblxuICAgIFJlbmRlclRleHR1cmUucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uIHJlc2l6ZSh3aWR0aCwgaGVpZ2h0LCBkb05vdFJlc2l6ZUJhc2VUZXh0dXJlKSB7XG4gICAgICAgIHdpZHRoID0gTWF0aC5jZWlsKHdpZHRoKTtcbiAgICAgICAgaGVpZ2h0ID0gTWF0aC5jZWlsKGhlaWdodCk7XG5cbiAgICAgICAgLy8gVE9ETyAtIGNvdWxkIGJlIG5vdCByZXF1aXJlZC4uXG4gICAgICAgIHRoaXMudmFsaWQgPSB3aWR0aCA+IDAgJiYgaGVpZ2h0ID4gMDtcblxuICAgICAgICB0aGlzLl9mcmFtZS53aWR0aCA9IHRoaXMub3JpZy53aWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLl9mcmFtZS5oZWlnaHQgPSB0aGlzLm9yaWcuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgICAgIGlmICghZG9Ob3RSZXNpemVCYXNlVGV4dHVyZSkge1xuICAgICAgICAgICAgdGhpcy5iYXNlVGV4dHVyZS5yZXNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl91cGRhdGVVdnMoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQSBzaG9ydCBoYW5kIHdheSBvZiBjcmVhdGluZyBhIHJlbmRlciB0ZXh0dXJlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt3aWR0aD0xMDBdIC0gVGhlIHdpZHRoIG9mIHRoZSByZW5kZXIgdGV4dHVyZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbaGVpZ2h0PTEwMF0gLSBUaGUgaGVpZ2h0IG9mIHRoZSByZW5kZXIgdGV4dHVyZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc2NhbGVNb2RlPVBJWEkuc2V0dGluZ3MuU0NBTEVfTU9ERV0gLSBTZWUge0BsaW5rIFBJWEkuU0NBTEVfTU9ERVN9IGZvciBwb3NzaWJsZSB2YWx1ZXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3Jlc29sdXRpb249MV0gLSBUaGUgcmVzb2x1dGlvbiAvIGRldmljZSBwaXhlbCByYXRpbyBvZiB0aGUgdGV4dHVyZSBiZWluZyBnZW5lcmF0ZWRcbiAgICAgKiBAcmV0dXJuIHtQSVhJLlJlbmRlclRleHR1cmV9IFRoZSBuZXcgcmVuZGVyIHRleHR1cmVcbiAgICAgKi9cblxuXG4gICAgUmVuZGVyVGV4dHVyZS5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUod2lkdGgsIGhlaWdodCwgc2NhbGVNb2RlLCByZXNvbHV0aW9uKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVuZGVyVGV4dHVyZShuZXcgX0Jhc2VSZW5kZXJUZXh0dXJlMi5kZWZhdWx0KHdpZHRoLCBoZWlnaHQsIHNjYWxlTW9kZSwgcmVzb2x1dGlvbikpO1xuICAgIH07XG5cbiAgICByZXR1cm4gUmVuZGVyVGV4dHVyZTtcbn0oX1RleHR1cmUzLmRlZmF1bHQpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBSZW5kZXJUZXh0dXJlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmVuZGVyVGV4dHVyZS5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfID0gcmVxdWlyZSgnLi4vJyk7XG5cbnZhciBfdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vKipcbiAqIFV0aWxpdHkgY2xhc3MgZm9yIG1haW50YWluaW5nIHJlZmVyZW5jZSB0byBhIGNvbGxlY3Rpb25cbiAqIG9mIFRleHR1cmVzIG9uIGEgc2luZ2xlIFNwcml0ZXNoZWV0LlxuICpcbiAqIFRvIGFjY2VzcyBhIHNwcml0ZSBzaGVldCBmcm9tIHlvdXIgY29kZSBwYXNzIGl0cyBKU09OIGRhdGEgZmlsZSB0byBQaXhpJ3MgbG9hZGVyOlxuICpcbiAqIGBgYGpzXG4gKiBQSVhJLmxvYWRlci5hZGQoXCJpbWFnZXMvc3ByaXRlc2hlZXQuanNvblwiKS5sb2FkKHNldHVwKTtcbiAqXG4gKiBmdW5jdGlvbiBzZXR1cCgpIHtcbiAqICAgbGV0IHNoZWV0ID0gUElYSS5sb2FkZXIucmVzb3VyY2VzW1wiaW1hZ2VzL3Nwcml0ZXNoZWV0Lmpzb25cIl0uc3ByaXRlc2hlZXQ7XG4gKiAgIC4uLlxuICogfVxuICogYGBgXG4gKiBXaXRoIHRoZSBgc2hlZXQudGV4dHVyZXNgIHlvdSBjYW4gY3JlYXRlIFNwcml0ZSBvYmplY3RzLGBzaGVldC5hbmltYXRpb25zYCBjYW4gYmUgdXNlZCB0byBjcmVhdGUgYW4gQW5pbWF0ZWRTcHJpdGUuXG4gKlxuICogU3ByaXRlIHNoZWV0cyBjYW4gYmUgcGFja2VkIHVzaW5nIHRvb2xzIGxpa2Uge0BsaW5rIGh0dHBzOi8vY29kZWFuZHdlYi5jb20vdGV4dHVyZXBhY2tlcnxUZXh0dXJlUGFja2VyfSxcbiAqIHtAbGluayBodHRwczovL3JlbmRlcmhqcy5uZXQvc2hvZWJveC98U2hvZWJveH0gb3Ige0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9rcnp5c3p0b2Ytby9zcHJpdGVzaGVldC5qc3xTcHJpdGVzaGVldC5qc30uXG4gKiBEZWZhdWx0IGFuY2hvciBwb2ludHMgKHNlZSB7QGxpbmsgUElYSS5UZXh0dXJlI2RlZmF1bHRBbmNob3J9KSBhbmQgZ3JvdXBpbmcgb2YgYW5pbWF0aW9uIHNwcml0ZXMgYXJlIGN1cnJlbnRseSBvbmx5XG4gKiBzdXBwb3J0ZWQgYnkgVGV4dHVyZVBhY2tlci5cbiAqXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKi9cbnZhciBTcHJpdGVzaGVldCA9IGZ1bmN0aW9uICgpIHtcbiAgICBfY3JlYXRlQ2xhc3MoU3ByaXRlc2hlZXQsIG51bGwsIFt7XG4gICAgICAgIGtleTogJ0JBVENIX1NJWkUnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbWF4aW11bSBudW1iZXIgb2YgVGV4dHVyZXMgdG8gYnVpbGQgcGVyIHByb2Nlc3MuXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDEwMDBcbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIDEwMDA7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtQSVhJLkJhc2VUZXh0dXJlfSBiYXNlVGV4dHVyZSBSZWZlcmVuY2UgdG8gdGhlIHNvdXJjZSBCYXNlVGV4dHVyZSBvYmplY3QuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gU3ByaXRlc2hlZXQgaW1hZ2UgZGF0YS5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtyZXNvbHV0aW9uRmlsZW5hbWVdIC0gVGhlIGZpbGVuYW1lIHRvIGNvbnNpZGVyIHdoZW4gZGV0ZXJtaW5pbmdcbiAgICAgICAgICogICAgICAgIHRoZSByZXNvbHV0aW9uIG9mIHRoZSBzcHJpdGVzaGVldC4gSWYgbm90IHByb3ZpZGVkLCB0aGUgaW1hZ2VVcmwgd2lsbFxuICAgICAgICAgKiAgICAgICAgYmUgdXNlZCBvbiB0aGUgQmFzZVRleHR1cmUuXG4gICAgICAgICAqL1xuXG4gICAgfV0pO1xuXG4gICAgZnVuY3Rpb24gU3ByaXRlc2hlZXQoYmFzZVRleHR1cmUsIGRhdGEpIHtcbiAgICAgICAgdmFyIHJlc29sdXRpb25GaWxlbmFtZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogbnVsbDtcblxuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3ByaXRlc2hlZXQpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWZlcmVuY2UgdG8gdGhzIHNvdXJjZSB0ZXh0dXJlXG4gICAgICAgICAqIEB0eXBlIHtQSVhJLkJhc2VUZXh0dXJlfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5iYXNlVGV4dHVyZSA9IGJhc2VUZXh0dXJlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIG1hcCBjb250YWluaW5nIGFsbCB0ZXh0dXJlcyBvZiB0aGUgc3ByaXRlIHNoZWV0LlxuICAgICAgICAgKiBDYW4gYmUgdXNlZCB0byBjcmVhdGUgYSB7QGxpbmsgUElYSS5TcHJpdGV8U3ByaXRlfTpcbiAgICAgICAgICogYGBganNcbiAgICAgICAgICogbmV3IFBJWEkuU3ByaXRlKHNoZWV0LnRleHR1cmVzW1wiaW1hZ2UucG5nXCJdKTtcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudGV4dHVyZXMgPSB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBtYXAgY29udGFpbmluZyB0aGUgdGV4dHVyZXMgZm9yIGVhY2ggYW5pbWF0aW9uLlxuICAgICAgICAgKiBDYW4gYmUgdXNlZCB0byBjcmVhdGUgYW4ge0BsaW5rIFBJWEkuZXh0cmFzLkFuaW1hdGVkU3ByaXRlfEFuaW1hdGVkU3ByaXRlfTpcbiAgICAgICAgICogYGBganNcbiAgICAgICAgICogbmV3IFBJWEkuZXh0cmFzLkFuaW1hdGVkU3ByaXRlKHNoZWV0LmFuaW1hdGlvbnNbXCJhbmltX25hbWVcIl0pXG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFuaW1hdGlvbnMgPSB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVmZXJlbmNlIHRvIHRoZSBvcmlnaW5hbCBKU09OIGRhdGEuXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcmVzb2x1dGlvbiBvZiB0aGUgc3ByaXRlc2hlZXQuXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlc29sdXRpb24gPSB0aGlzLl91cGRhdGVSZXNvbHV0aW9uKHJlc29sdXRpb25GaWxlbmFtZSB8fCB0aGlzLmJhc2VUZXh0dXJlLmltYWdlVXJsKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogTWFwIG9mIHNwcml0ZXNoZWV0IGZyYW1lcy5cbiAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2ZyYW1lcyA9IHRoaXMuZGF0YS5mcmFtZXM7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbGxlY3Rpb24gb2YgZnJhbWUgbmFtZXMuXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmdbXX1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2ZyYW1lS2V5cyA9IE9iamVjdC5rZXlzKHRoaXMuX2ZyYW1lcyk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEN1cnJlbnQgYmF0Y2ggaW5kZXggYmVpbmcgcHJvY2Vzc2VkLlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fYmF0Y2hJbmRleCA9IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxiYWNrIHdoZW4gcGFyc2UgaXMgY29tcGxldGVkLlxuICAgICAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9jYWxsYmFjayA9IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgdGhlIHJlc29sdXRpb24gZnJvbSB0aGUgZmlsZW5hbWUgb3IgZmFsbGJhY2tcbiAgICAgKiB0byB0aGUgbWV0YS5zY2FsZSBmaWVsZCBvZiB0aGUgSlNPTiBkYXRhLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcmVzb2x1dGlvbkZpbGVuYW1lIC0gVGhlIGZpbGVuYW1lIHRvIHVzZSBmb3IgcmVzb2x2aW5nXG4gICAgICogICAgICAgIHRoZSBkZWZhdWx0IHJlc29sdXRpb24uXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBSZXNvbHV0aW9uIHRvIHVzZSBmb3Igc3ByaXRlc2hlZXQuXG4gICAgICovXG5cblxuICAgIFNwcml0ZXNoZWV0LnByb3RvdHlwZS5fdXBkYXRlUmVzb2x1dGlvbiA9IGZ1bmN0aW9uIF91cGRhdGVSZXNvbHV0aW9uKHJlc29sdXRpb25GaWxlbmFtZSkge1xuICAgICAgICB2YXIgc2NhbGUgPSB0aGlzLmRhdGEubWV0YS5zY2FsZTtcblxuICAgICAgICAvLyBVc2UgYSBkZWZhdWx0VmFsdWUgb2YgYG51bGxgIHRvIGNoZWNrIGlmIGEgdXJsLWJhc2VkIHJlc29sdXRpb24gaXMgc2V0XG4gICAgICAgIHZhciByZXNvbHV0aW9uID0gKDAsIF91dGlscy5nZXRSZXNvbHV0aW9uT2ZVcmwpKHJlc29sdXRpb25GaWxlbmFtZSwgbnVsbCk7XG5cbiAgICAgICAgLy8gTm8gcmVzb2x1dGlvbiBmb3VuZCB2aWEgVVJMXG4gICAgICAgIGlmIChyZXNvbHV0aW9uID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBVc2UgdGhlIHNjYWxlIHZhbHVlIG9yIGRlZmF1bHQgdG8gMVxuICAgICAgICAgICAgcmVzb2x1dGlvbiA9IHNjYWxlICE9PSB1bmRlZmluZWQgPyBwYXJzZUZsb2F0KHNjYWxlKSA6IDE7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGb3Igbm9uLTEgcmVzb2x1dGlvbnMsIHVwZGF0ZSBiYXNlVGV4dHVyZVxuICAgICAgICBpZiAocmVzb2x1dGlvbiAhPT0gMSkge1xuICAgICAgICAgICAgdGhpcy5iYXNlVGV4dHVyZS5yZXNvbHV0aW9uID0gcmVzb2x1dGlvbjtcbiAgICAgICAgICAgIHRoaXMuYmFzZVRleHR1cmUudXBkYXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzb2x1dGlvbjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUGFyc2VyIHNwcml0ZXNoZWV0IGZyb20gbG9hZGVkIGRhdGEuIFRoaXMgaXMgZG9uZSBhc3luY2hyb25vdXNseVxuICAgICAqIHRvIHByZXZlbnQgY3JlYXRpbmcgdG9vIG1hbnkgVGV4dHVyZSB3aXRoaW4gYSBzaW5nbGUgcHJvY2Vzcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gQ2FsbGJhY2sgd2hlbiBjb21wbGV0ZSByZXR1cm5zXG4gICAgICogICAgICAgIGEgbWFwIG9mIHRoZSBUZXh0dXJlcyBmb3IgdGhpcyBzcHJpdGVzaGVldC5cbiAgICAgKi9cblxuXG4gICAgU3ByaXRlc2hlZXQucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5fYmF0Y2hJbmRleCA9IDA7XG4gICAgICAgIHRoaXMuX2NhbGxiYWNrID0gY2FsbGJhY2s7XG5cbiAgICAgICAgaWYgKHRoaXMuX2ZyYW1lS2V5cy5sZW5ndGggPD0gU3ByaXRlc2hlZXQuQkFUQ0hfU0laRSkge1xuICAgICAgICAgICAgdGhpcy5fcHJvY2Vzc0ZyYW1lcygwKTtcbiAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3NBbmltYXRpb25zKCk7XG4gICAgICAgICAgICB0aGlzLl9wYXJzZUNvbXBsZXRlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9uZXh0QmF0Y2goKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIGEgYmF0Y2ggb2YgZnJhbWVzXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbml0aWFsRnJhbWVJbmRleCAtIFRoZSBpbmRleCBvZiBmcmFtZSB0byBzdGFydC5cbiAgICAgKi9cblxuXG4gICAgU3ByaXRlc2hlZXQucHJvdG90eXBlLl9wcm9jZXNzRnJhbWVzID0gZnVuY3Rpb24gX3Byb2Nlc3NGcmFtZXMoaW5pdGlhbEZyYW1lSW5kZXgpIHtcbiAgICAgICAgdmFyIGZyYW1lSW5kZXggPSBpbml0aWFsRnJhbWVJbmRleDtcbiAgICAgICAgdmFyIG1heEZyYW1lcyA9IFNwcml0ZXNoZWV0LkJBVENIX1NJWkU7XG4gICAgICAgIHZhciBzb3VyY2VTY2FsZSA9IHRoaXMuYmFzZVRleHR1cmUuc291cmNlU2NhbGU7XG5cbiAgICAgICAgd2hpbGUgKGZyYW1lSW5kZXggLSBpbml0aWFsRnJhbWVJbmRleCA8IG1heEZyYW1lcyAmJiBmcmFtZUluZGV4IDwgdGhpcy5fZnJhbWVLZXlzLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGkgPSB0aGlzLl9mcmFtZUtleXNbZnJhbWVJbmRleF07XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX2ZyYW1lc1tpXTtcbiAgICAgICAgICAgIHZhciByZWN0ID0gZGF0YS5mcmFtZTtcblxuICAgICAgICAgICAgaWYgKHJlY3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgZnJhbWUgPSBudWxsO1xuICAgICAgICAgICAgICAgIHZhciB0cmltID0gbnVsbDtcbiAgICAgICAgICAgICAgICB2YXIgc291cmNlU2l6ZSA9IGRhdGEudHJpbW1lZCAhPT0gZmFsc2UgJiYgZGF0YS5zb3VyY2VTaXplID8gZGF0YS5zb3VyY2VTaXplIDogZGF0YS5mcmFtZTtcblxuICAgICAgICAgICAgICAgIHZhciBvcmlnID0gbmV3IF8uUmVjdGFuZ2xlKDAsIDAsIE1hdGguZmxvb3Ioc291cmNlU2l6ZS53ICogc291cmNlU2NhbGUpIC8gdGhpcy5yZXNvbHV0aW9uLCBNYXRoLmZsb29yKHNvdXJjZVNpemUuaCAqIHNvdXJjZVNjYWxlKSAvIHRoaXMucmVzb2x1dGlvbik7XG5cbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5yb3RhdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGZyYW1lID0gbmV3IF8uUmVjdGFuZ2xlKE1hdGguZmxvb3IocmVjdC54ICogc291cmNlU2NhbGUpIC8gdGhpcy5yZXNvbHV0aW9uLCBNYXRoLmZsb29yKHJlY3QueSAqIHNvdXJjZVNjYWxlKSAvIHRoaXMucmVzb2x1dGlvbiwgTWF0aC5mbG9vcihyZWN0LmggKiBzb3VyY2VTY2FsZSkgLyB0aGlzLnJlc29sdXRpb24sIE1hdGguZmxvb3IocmVjdC53ICogc291cmNlU2NhbGUpIC8gdGhpcy5yZXNvbHV0aW9uKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmcmFtZSA9IG5ldyBfLlJlY3RhbmdsZShNYXRoLmZsb29yKHJlY3QueCAqIHNvdXJjZVNjYWxlKSAvIHRoaXMucmVzb2x1dGlvbiwgTWF0aC5mbG9vcihyZWN0LnkgKiBzb3VyY2VTY2FsZSkgLyB0aGlzLnJlc29sdXRpb24sIE1hdGguZmxvb3IocmVjdC53ICogc291cmNlU2NhbGUpIC8gdGhpcy5yZXNvbHV0aW9uLCBNYXRoLmZsb29yKHJlY3QuaCAqIHNvdXJjZVNjYWxlKSAvIHRoaXMucmVzb2x1dGlvbik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gIENoZWNrIHRvIHNlZSBpZiB0aGUgc3ByaXRlIGlzIHRyaW1tZWRcbiAgICAgICAgICAgICAgICBpZiAoZGF0YS50cmltbWVkICE9PSBmYWxzZSAmJiBkYXRhLnNwcml0ZVNvdXJjZVNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJpbSA9IG5ldyBfLlJlY3RhbmdsZShNYXRoLmZsb29yKGRhdGEuc3ByaXRlU291cmNlU2l6ZS54ICogc291cmNlU2NhbGUpIC8gdGhpcy5yZXNvbHV0aW9uLCBNYXRoLmZsb29yKGRhdGEuc3ByaXRlU291cmNlU2l6ZS55ICogc291cmNlU2NhbGUpIC8gdGhpcy5yZXNvbHV0aW9uLCBNYXRoLmZsb29yKHJlY3QudyAqIHNvdXJjZVNjYWxlKSAvIHRoaXMucmVzb2x1dGlvbiwgTWF0aC5mbG9vcihyZWN0LmggKiBzb3VyY2VTY2FsZSkgLyB0aGlzLnJlc29sdXRpb24pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMudGV4dHVyZXNbaV0gPSBuZXcgXy5UZXh0dXJlKHRoaXMuYmFzZVRleHR1cmUsIGZyYW1lLCBvcmlnLCB0cmltLCBkYXRhLnJvdGF0ZWQgPyAyIDogMCwgZGF0YS5hbmNob3IpO1xuXG4gICAgICAgICAgICAgICAgLy8gbGV0cyBhbHNvIGFkZCB0aGUgZnJhbWUgdG8gcGl4aSdzIGdsb2JhbCBjYWNoZSBmb3IgZnJvbUZyYW1lIGFuZCBmcm9tSW1hZ2UgZnVuY3Rpb25zXG4gICAgICAgICAgICAgICAgXy5UZXh0dXJlLmFkZFRvQ2FjaGUodGhpcy50ZXh0dXJlc1tpXSwgaSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZyYW1lSW5kZXgrKztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZSBhbmltYXRpb25zIGNvbmZpZ1xuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuXG4gICAgU3ByaXRlc2hlZXQucHJvdG90eXBlLl9wcm9jZXNzQW5pbWF0aW9ucyA9IGZ1bmN0aW9uIF9wcm9jZXNzQW5pbWF0aW9ucygpIHtcbiAgICAgICAgdmFyIGFuaW1hdGlvbnMgPSB0aGlzLmRhdGEuYW5pbWF0aW9ucyB8fCB7fTtcblxuICAgICAgICBmb3IgKHZhciBhbmltTmFtZSBpbiBhbmltYXRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvbnNbYW5pbU5hbWVdID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSBhbmltYXRpb25zW2FuaW1OYW1lXSwgX2lzQXJyYXkgPSBBcnJheS5pc0FycmF5KF9pdGVyYXRvciksIF9pID0gMCwgX2l0ZXJhdG9yID0gX2lzQXJyYXkgPyBfaXRlcmF0b3IgOiBfaXRlcmF0b3JbU3ltYm9sLml0ZXJhdG9yXSgpOzspIHtcbiAgICAgICAgICAgICAgICB2YXIgX3JlZjtcblxuICAgICAgICAgICAgICAgIGlmIChfaXNBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX2kgPj0gX2l0ZXJhdG9yLmxlbmd0aCkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIF9yZWYgPSBfaXRlcmF0b3JbX2krK107XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX2kgPSBfaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoX2kuZG9uZSkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIF9yZWYgPSBfaS52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgZnJhbWVOYW1lID0gX3JlZjtcblxuICAgICAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uc1thbmltTmFtZV0ucHVzaCh0aGlzLnRleHR1cmVzW2ZyYW1lTmFtZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBwYXJzZSBoYXMgY29tcGxldGVkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuXG4gICAgU3ByaXRlc2hlZXQucHJvdG90eXBlLl9wYXJzZUNvbXBsZXRlID0gZnVuY3Rpb24gX3BhcnNlQ29tcGxldGUoKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IHRoaXMuX2NhbGxiYWNrO1xuXG4gICAgICAgIHRoaXMuX2NhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgdGhpcy5fYmF0Y2hJbmRleCA9IDA7XG4gICAgICAgIGNhbGxiYWNrLmNhbGwodGhpcywgdGhpcy50ZXh0dXJlcyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEJlZ2luIHRoZSBuZXh0IGJhdGNoIG9mIHRleHR1cmVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuXG4gICAgU3ByaXRlc2hlZXQucHJvdG90eXBlLl9uZXh0QmF0Y2ggPSBmdW5jdGlvbiBfbmV4dEJhdGNoKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIHRoaXMuX3Byb2Nlc3NGcmFtZXModGhpcy5fYmF0Y2hJbmRleCAqIFNwcml0ZXNoZWV0LkJBVENIX1NJWkUpO1xuICAgICAgICB0aGlzLl9iYXRjaEluZGV4Kys7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLl9iYXRjaEluZGV4ICogU3ByaXRlc2hlZXQuQkFUQ0hfU0laRSA8IF90aGlzLl9mcmFtZUtleXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX25leHRCYXRjaCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fcHJvY2Vzc0FuaW1hdGlvbnMoKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5fcGFyc2VDb21wbGV0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCAwKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGVzdHJveSBTcHJpdGVzaGVldCBhbmQgZG9uJ3QgdXNlIGFmdGVyIHRoaXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtkZXN0cm95QmFzZT1mYWxzZV0gV2hldGhlciB0byBkZXN0cm95IHRoZSBiYXNlIHRleHR1cmUgYXMgd2VsbFxuICAgICAqL1xuXG5cbiAgICBTcHJpdGVzaGVldC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIHZhciBkZXN0cm95QmFzZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZmFsc2U7XG5cbiAgICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLnRleHR1cmVzKSB7XG4gICAgICAgICAgICB0aGlzLnRleHR1cmVzW2ldLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9mcmFtZXMgPSBudWxsO1xuICAgICAgICB0aGlzLl9mcmFtZUtleXMgPSBudWxsO1xuICAgICAgICB0aGlzLmRhdGEgPSBudWxsO1xuICAgICAgICB0aGlzLnRleHR1cmVzID0gbnVsbDtcbiAgICAgICAgaWYgKGRlc3Ryb3lCYXNlKSB7XG4gICAgICAgICAgICB0aGlzLmJhc2VUZXh0dXJlLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJhc2VUZXh0dXJlID0gbnVsbDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFNwcml0ZXNoZWV0O1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBTcHJpdGVzaGVldDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNwcml0ZXNoZWV0LmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9CYXNlVGV4dHVyZSA9IHJlcXVpcmUoJy4vQmFzZVRleHR1cmUnKTtcblxudmFyIF9CYXNlVGV4dHVyZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9CYXNlVGV4dHVyZSk7XG5cbnZhciBfVmlkZW9CYXNlVGV4dHVyZSA9IHJlcXVpcmUoJy4vVmlkZW9CYXNlVGV4dHVyZScpO1xuXG52YXIgX1ZpZGVvQmFzZVRleHR1cmUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVmlkZW9CYXNlVGV4dHVyZSk7XG5cbnZhciBfVGV4dHVyZVV2cyA9IHJlcXVpcmUoJy4vVGV4dHVyZVV2cycpO1xuXG52YXIgX1RleHR1cmVVdnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVGV4dHVyZVV2cyk7XG5cbnZhciBfZXZlbnRlbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRlbWl0dGVyMycpO1xuXG52YXIgX2V2ZW50ZW1pdHRlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ldmVudGVtaXR0ZXIpO1xuXG52YXIgX21hdGggPSByZXF1aXJlKCcuLi9tYXRoJyk7XG5cbnZhciBfdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG52YXIgX3NldHRpbmdzID0gcmVxdWlyZSgnLi4vc2V0dGluZ3MnKTtcblxudmFyIF9zZXR0aW5nczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zZXR0aW5ncyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuLyoqXG4gKiBBIHRleHR1cmUgc3RvcmVzIHRoZSBpbmZvcm1hdGlvbiB0aGF0IHJlcHJlc2VudHMgYW4gaW1hZ2Ugb3IgcGFydCBvZiBhbiBpbWFnZS4gSXQgY2Fubm90IGJlIGFkZGVkXG4gKiB0byB0aGUgZGlzcGxheSBsaXN0IGRpcmVjdGx5LiBJbnN0ZWFkIHVzZSBpdCBhcyB0aGUgdGV4dHVyZSBmb3IgYSBTcHJpdGUuIElmIG5vIGZyYW1lIGlzIHByb3ZpZGVkXG4gKiB0aGVuIHRoZSB3aG9sZSBpbWFnZSBpcyB1c2VkLlxuICpcbiAqIFlvdSBjYW4gZGlyZWN0bHkgY3JlYXRlIGEgdGV4dHVyZSBmcm9tIGFuIGltYWdlIGFuZCB0aGVuIHJldXNlIGl0IG11bHRpcGxlIHRpbWVzIGxpa2UgdGhpcyA6XG4gKlxuICogYGBganNcbiAqIGxldCB0ZXh0dXJlID0gUElYSS5UZXh0dXJlLmZyb21JbWFnZSgnYXNzZXRzL2ltYWdlLnBuZycpO1xuICogbGV0IHNwcml0ZTEgPSBuZXcgUElYSS5TcHJpdGUodGV4dHVyZSk7XG4gKiBsZXQgc3ByaXRlMiA9IG5ldyBQSVhJLlNwcml0ZSh0ZXh0dXJlKTtcbiAqIGBgYFxuICpcbiAqIFRleHR1cmVzIG1hZGUgZnJvbSBTVkdzLCBsb2FkZWQgb3Igbm90LCBjYW5ub3QgYmUgdXNlZCBiZWZvcmUgdGhlIGZpbGUgZmluaXNoZXMgcHJvY2Vzc2luZy5cbiAqIFlvdSBjYW4gY2hlY2sgZm9yIHRoaXMgYnkgY2hlY2tpbmcgdGhlIHNwcml0ZSdzIF90ZXh0dXJlSUQgcHJvcGVydHkuXG4gKiBgYGBqc1xuICogdmFyIHRleHR1cmUgPSBQSVhJLlRleHR1cmUuZnJvbUltYWdlKCdhc3NldHMvaW1hZ2Uuc3ZnJyk7XG4gKiB2YXIgc3ByaXRlMSA9IG5ldyBQSVhJLlNwcml0ZSh0ZXh0dXJlKTtcbiAqIC8vc3ByaXRlMS5fdGV4dHVyZUlEIHNob3VsZCBub3QgYmUgdW5kZWZpbmVkIGlmIHRoZSB0ZXh0dXJlIGhhcyBmaW5pc2hlZCBwcm9jZXNzaW5nIHRoZSBTVkcgZmlsZVxuICogYGBgXG4gKiBZb3UgY2FuIHVzZSBhIHRpY2tlciBvciByQUYgdG8gZW5zdXJlIHlvdXIgc3ByaXRlcyBsb2FkIHRoZSBmaW5pc2hlZCB0ZXh0dXJlcyBhZnRlciBwcm9jZXNzaW5nLiBTZWUgaXNzdWUgIzMwNjguXG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBFdmVudEVtaXR0ZXJcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKi9cbnZhciBUZXh0dXJlID0gZnVuY3Rpb24gKF9FdmVudEVtaXR0ZXIpIHtcbiAgICBfaW5oZXJpdHMoVGV4dHVyZSwgX0V2ZW50RW1pdHRlcik7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1BJWEkuQmFzZVRleHR1cmV9IGJhc2VUZXh0dXJlIC0gVGhlIGJhc2UgdGV4dHVyZSBzb3VyY2UgdG8gY3JlYXRlIHRoZSB0ZXh0dXJlIGZyb21cbiAgICAgKiBAcGFyYW0ge1BJWEkuUmVjdGFuZ2xlfSBbZnJhbWVdIC0gVGhlIHJlY3RhbmdsZSBmcmFtZSBvZiB0aGUgdGV4dHVyZSB0byBzaG93XG4gICAgICogQHBhcmFtIHtQSVhJLlJlY3RhbmdsZX0gW29yaWddIC0gVGhlIGFyZWEgb2Ygb3JpZ2luYWwgdGV4dHVyZVxuICAgICAqIEBwYXJhbSB7UElYSS5SZWN0YW5nbGV9IFt0cmltXSAtIFRyaW1tZWQgcmVjdGFuZ2xlIG9mIG9yaWdpbmFsIHRleHR1cmVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3JvdGF0ZV0gLSBpbmRpY2F0ZXMgaG93IHRoZSB0ZXh0dXJlIHdhcyByb3RhdGVkIGJ5IHRleHR1cmUgcGFja2VyLiBTZWUge0BsaW5rIFBJWEkuR3JvdXBEOH1cbiAgICAgKiBAcGFyYW0ge1BJWEkuUG9pbnR9IFthbmNob3JdIC0gRGVmYXVsdCBhbmNob3IgcG9pbnQgdXNlZCBmb3Igc3ByaXRlIHBsYWNlbWVudCAvIHJvdGF0aW9uXG4gICAgICovXG4gICAgZnVuY3Rpb24gVGV4dHVyZShiYXNlVGV4dHVyZSwgZnJhbWUsIG9yaWcsIHRyaW0sIHJvdGF0ZSwgYW5jaG9yKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUZXh0dXJlKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRG9lcyB0aGlzIFRleHR1cmUgaGF2ZSBhbnkgZnJhbWUgZGF0YSBhc3NpZ25lZCB0byBpdD9cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9FdmVudEVtaXR0ZXIuY2FsbCh0aGlzKSk7XG5cbiAgICAgICAgX3RoaXMubm9GcmFtZSA9IGZhbHNlO1xuXG4gICAgICAgIGlmICghZnJhbWUpIHtcbiAgICAgICAgICAgIF90aGlzLm5vRnJhbWUgPSB0cnVlO1xuICAgICAgICAgICAgZnJhbWUgPSBuZXcgX21hdGguUmVjdGFuZ2xlKDAsIDAsIDEsIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJhc2VUZXh0dXJlIGluc3RhbmNlb2YgVGV4dHVyZSkge1xuICAgICAgICAgICAgYmFzZVRleHR1cmUgPSBiYXNlVGV4dHVyZS5iYXNlVGV4dHVyZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYmFzZSB0ZXh0dXJlIHRoYXQgdGhpcyB0ZXh0dXJlIHVzZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuQmFzZVRleHR1cmV9XG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5iYXNlVGV4dHVyZSA9IGJhc2VUZXh0dXJlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGlzIHRoZSBhcmVhIG9mIHRoZSBCYXNlVGV4dHVyZSBpbWFnZSB0byBhY3R1YWxseSBjb3B5IHRvIHRoZSBDYW52YXMgLyBXZWJHTCB3aGVuIHJlbmRlcmluZyxcbiAgICAgICAgICogaXJyZXNwZWN0aXZlIG9mIHRoZSBhY3R1YWwgZnJhbWUgc2l6ZSBvciBwbGFjZW1lbnQgKHdoaWNoIGNhbiBiZSBpbmZsdWVuY2VkIGJ5IHRyaW1tZWQgdGV4dHVyZSBhdGxhc2VzKVxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLlJlY3RhbmdsZX1cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLl9mcmFtZSA9IGZyYW1lO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGlzIHRoZSB0cmltbWVkIGFyZWEgb2Ygb3JpZ2luYWwgdGV4dHVyZSwgYmVmb3JlIGl0IHdhcyBwdXQgaW4gYXRsYXNcbiAgICAgICAgICogUGxlYXNlIGNhbGwgYF91cGRhdGVVdnMoKWAgYWZ0ZXIgeW91IGNoYW5nZSBjb29yZGluYXRlcyBvZiBgdHJpbWAgbWFudWFsbHkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuUmVjdGFuZ2xlfVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMudHJpbSA9IHRyaW07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgd2lsbCBsZXQgdGhlIHJlbmRlcmVyIGtub3cgaWYgdGhlIHRleHR1cmUgaXMgdmFsaWQuIElmIGl0J3Mgbm90IHRoZW4gaXQgY2Fubm90IGJlIHJlbmRlcmVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMudmFsaWQgPSBmYWxzZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyB3aWxsIGxldCBhIHJlbmRlcmVyIGtub3cgdGhhdCBhIHRleHR1cmUgaGFzIGJlZW4gdXBkYXRlZCAodXNlZCBtYWlubHkgZm9yIHdlYkdMIHV2IHVwZGF0ZXMpXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5yZXF1aXJlc1VwZGF0ZSA9IGZhbHNlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgV2ViR0wgVVYgZGF0YSBjYWNoZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5UZXh0dXJlVXZzfVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuX3V2cyA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgaXMgdGhlIGFyZWEgb2Ygb3JpZ2luYWwgdGV4dHVyZSwgYmVmb3JlIGl0IHdhcyBwdXQgaW4gYXRsYXNcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5SZWN0YW5nbGV9XG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5vcmlnID0gb3JpZyB8fCBmcmFtZTsgLy8gbmV3IFJlY3RhbmdsZSgwLCAwLCAxLCAxKTtcblxuICAgICAgICBfdGhpcy5fcm90YXRlID0gTnVtYmVyKHJvdGF0ZSB8fCAwKTtcblxuICAgICAgICBpZiAocm90YXRlID09PSB0cnVlKSB7XG4gICAgICAgICAgICAvLyB0aGlzIGlzIG9sZCB0ZXh0dXJlcGFja2VyIGxlZ2FjeSwgc29tZSBnYW1lcy9saWJyYXJpZXMgYXJlIHBhc3NpbmcgXCJ0cnVlXCIgZm9yIHJvdGF0ZWQgdGV4dHVyZXNcbiAgICAgICAgICAgIF90aGlzLl9yb3RhdGUgPSAyO1xuICAgICAgICB9IGVsc2UgaWYgKF90aGlzLl9yb3RhdGUgJSAyICE9PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2F0dGVtcHQgdG8gdXNlIGRpYW1vbmQtc2hhcGVkIFVWcy4gSWYgeW91IGFyZSBzdXJlLCBzZXQgcm90YXRpb24gbWFudWFsbHknKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChiYXNlVGV4dHVyZS5oYXNMb2FkZWQpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5ub0ZyYW1lKSB7XG4gICAgICAgICAgICAgICAgZnJhbWUgPSBuZXcgX21hdGguUmVjdGFuZ2xlKDAsIDAsIGJhc2VUZXh0dXJlLndpZHRoLCBiYXNlVGV4dHVyZS5oZWlnaHQpO1xuXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgbm8gZnJhbWUgd2Ugc2hvdWxkIG1vbml0b3IgZm9yIGFueSBiYXNlIHRleHR1cmUgY2hhbmdlcy4uXG4gICAgICAgICAgICAgICAgYmFzZVRleHR1cmUub24oJ3VwZGF0ZScsIF90aGlzLm9uQmFzZVRleHR1cmVVcGRhdGVkLCBfdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5mcmFtZSA9IGZyYW1lO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYmFzZVRleHR1cmUub25jZSgnbG9hZGVkJywgX3RoaXMub25CYXNlVGV4dHVyZUxvYWRlZCwgX3RoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuY2hvciBwb2ludCB0aGF0IGlzIHVzZWQgYXMgZGVmYXVsdCBpZiBzcHJpdGUgaXMgY3JlYXRlZCB3aXRoIHRoaXMgdGV4dHVyZS5cbiAgICAgICAgICogQ2hhbmdpbmcgdGhlIGBkZWZhdWx0QW5jaG9yYCBhdCBhIGxhdGVyIHBvaW50IG9mIHRpbWUgd2lsbCBub3QgdXBkYXRlIFNwcml0ZSdzIGFuY2hvciBwb2ludC5cbiAgICAgICAgICogQG1lbWJlciB7UElYSS5Qb2ludH1cbiAgICAgICAgICogQGRlZmF1bHQgezAsMH1cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLmRlZmF1bHRBbmNob3IgPSBhbmNob3IgPyBuZXcgX21hdGguUG9pbnQoYW5jaG9yLngsIGFuY2hvci55KSA6IG5ldyBfbWF0aC5Qb2ludCgwLCAwKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZWQgd2hlbiB0aGUgdGV4dHVyZSBpcyB1cGRhdGVkLiBUaGlzIGhhcHBlbnMgaWYgdGhlIGZyYW1lIG9yIHRoZSBiYXNlVGV4dHVyZSBpcyB1cGRhdGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXZlbnQgUElYSS5UZXh0dXJlI3VwZGF0ZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqIEBwYXJhbSB7UElYSS5UZXh0dXJlfSB0ZXh0dXJlIC0gSW5zdGFuY2Ugb2YgdGV4dHVyZSBiZWluZyB1cGRhdGVkLlxuICAgICAgICAgKi9cblxuICAgICAgICBfdGhpcy5fdXBkYXRlSUQgPSAwO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb250YWlucyBkYXRhIGZvciB1dnMuIE1heSBjb250YWluIGNsYW1wIHNldHRpbmdzIGFuZCBzb21lIG1hdHJpY2VzLlxuICAgICAgICAgKiBJdHMgYSBiaXQgaGVhdnksIHNvIGJ5IGRlZmF1bHQgdGhhdCBvYmplY3QgaXMgbm90IGNyZWF0ZWQuXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuVGV4dHVyZU1hdHJpeH1cbiAgICAgICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMudHJhbnNmb3JtID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGlkcyB1bmRlciB3aGljaCB0aGlzIFRleHR1cmUgaGFzIGJlZW4gYWRkZWQgdG8gdGhlIHRleHR1cmUgY2FjaGUuIFRoaXMgaXNcbiAgICAgICAgICogYXV0b21hdGljYWxseSBzZXQgYXMgbG9uZyBhcyBUZXh0dXJlLmFkZFRvQ2FjaGUgaXMgdXNlZCwgYnV0IG1heSBub3QgYmUgc2V0IGlmIGFcbiAgICAgICAgICogVGV4dHVyZSBpcyBhZGRlZCBkaXJlY3RseSB0byB0aGUgVGV4dHVyZUNhY2hlIGFycmF5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmdbXX1cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLnRleHR1cmVDYWNoZUlkcyA9IFtdO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGlzIHRleHR1cmUgb24gdGhlIGdwdS5cbiAgICAgKlxuICAgICAqL1xuXG5cbiAgICBUZXh0dXJlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgICAgIHRoaXMuYmFzZVRleHR1cmUudXBkYXRlKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIHRoZSBiYXNlIHRleHR1cmUgaXMgbG9hZGVkXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7UElYSS5CYXNlVGV4dHVyZX0gYmFzZVRleHR1cmUgLSBUaGUgYmFzZSB0ZXh0dXJlLlxuICAgICAqL1xuXG5cbiAgICBUZXh0dXJlLnByb3RvdHlwZS5vbkJhc2VUZXh0dXJlTG9hZGVkID0gZnVuY3Rpb24gb25CYXNlVGV4dHVyZUxvYWRlZChiYXNlVGV4dHVyZSkge1xuICAgICAgICB0aGlzLl91cGRhdGVJRCsrO1xuXG4gICAgICAgIC8vIFRPRE8gdGhpcyBjb2RlIGxvb2tzIGNvbmZ1c2luZy4uIGJvbyB0byBhYnVzaW5nIGdldHRlcnMgYW5kIHNldHRlcnMhXG4gICAgICAgIGlmICh0aGlzLm5vRnJhbWUpIHtcbiAgICAgICAgICAgIHRoaXMuZnJhbWUgPSBuZXcgX21hdGguUmVjdGFuZ2xlKDAsIDAsIGJhc2VUZXh0dXJlLndpZHRoLCBiYXNlVGV4dHVyZS5oZWlnaHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5mcmFtZSA9IHRoaXMuX2ZyYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5iYXNlVGV4dHVyZS5vbigndXBkYXRlJywgdGhpcy5vbkJhc2VUZXh0dXJlVXBkYXRlZCwgdGhpcyk7XG4gICAgICAgIHRoaXMuZW1pdCgndXBkYXRlJywgdGhpcyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIHRoZSBiYXNlIHRleHR1cmUgaXMgdXBkYXRlZFxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1BJWEkuQmFzZVRleHR1cmV9IGJhc2VUZXh0dXJlIC0gVGhlIGJhc2UgdGV4dHVyZS5cbiAgICAgKi9cblxuXG4gICAgVGV4dHVyZS5wcm90b3R5cGUub25CYXNlVGV4dHVyZVVwZGF0ZWQgPSBmdW5jdGlvbiBvbkJhc2VUZXh0dXJlVXBkYXRlZChiYXNlVGV4dHVyZSkge1xuICAgICAgICB0aGlzLl91cGRhdGVJRCsrO1xuXG4gICAgICAgIHRoaXMuX2ZyYW1lLndpZHRoID0gYmFzZVRleHR1cmUud2lkdGg7XG4gICAgICAgIHRoaXMuX2ZyYW1lLmhlaWdodCA9IGJhc2VUZXh0dXJlLmhlaWdodDtcblxuICAgICAgICB0aGlzLmVtaXQoJ3VwZGF0ZScsIHRoaXMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyB0aGlzIHRleHR1cmVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Rlc3Ryb3lCYXNlPWZhbHNlXSBXaGV0aGVyIHRvIGRlc3Ryb3kgdGhlIGJhc2UgdGV4dHVyZSBhcyB3ZWxsXG4gICAgICovXG5cblxuICAgIFRleHR1cmUucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KGRlc3Ryb3lCYXNlKSB7XG4gICAgICAgIGlmICh0aGlzLmJhc2VUZXh0dXJlKSB7XG4gICAgICAgICAgICBpZiAoZGVzdHJveUJhc2UpIHtcbiAgICAgICAgICAgICAgICAvLyBkZWxldGUgdGhlIHRleHR1cmUgaWYgaXQgZXhpc3RzIGluIHRoZSB0ZXh0dXJlIGNhY2hlLi5cbiAgICAgICAgICAgICAgICAvLyB0aGlzIG9ubHkgbmVlZHMgdG8gYmUgcmVtb3ZlZCBpZiB0aGUgYmFzZSB0ZXh0dXJlIGlzIGFjdHVhbGx5IGRlc3Ryb3llZCB0b28uLlxuICAgICAgICAgICAgICAgIGlmIChfdXRpbHMuVGV4dHVyZUNhY2hlW3RoaXMuYmFzZVRleHR1cmUuaW1hZ2VVcmxdKSB7XG4gICAgICAgICAgICAgICAgICAgIFRleHR1cmUucmVtb3ZlRnJvbUNhY2hlKHRoaXMuYmFzZVRleHR1cmUuaW1hZ2VVcmwpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuYmFzZVRleHR1cmUuZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmJhc2VUZXh0dXJlLm9mZigndXBkYXRlJywgdGhpcy5vbkJhc2VUZXh0dXJlVXBkYXRlZCwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLmJhc2VUZXh0dXJlLm9mZignbG9hZGVkJywgdGhpcy5vbkJhc2VUZXh0dXJlTG9hZGVkLCB0aGlzKTtcblxuICAgICAgICAgICAgdGhpcy5iYXNlVGV4dHVyZSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9mcmFtZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3V2cyA9IG51bGw7XG4gICAgICAgIHRoaXMudHJpbSA9IG51bGw7XG4gICAgICAgIHRoaXMub3JpZyA9IG51bGw7XG5cbiAgICAgICAgdGhpcy52YWxpZCA9IGZhbHNlO1xuXG4gICAgICAgIFRleHR1cmUucmVtb3ZlRnJvbUNhY2hlKHRoaXMpO1xuICAgICAgICB0aGlzLnRleHR1cmVDYWNoZUlkcyA9IG51bGw7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgdGV4dHVyZSBvYmplY3QgdGhhdCBhY3RzIHRoZSBzYW1lIGFzIHRoaXMgb25lLlxuICAgICAqXG4gICAgICogQHJldHVybiB7UElYSS5UZXh0dXJlfSBUaGUgbmV3IHRleHR1cmVcbiAgICAgKi9cblxuXG4gICAgVGV4dHVyZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0dXJlKHRoaXMuYmFzZVRleHR1cmUsIHRoaXMuZnJhbWUsIHRoaXMub3JpZywgdGhpcy50cmltLCB0aGlzLnJvdGF0ZSwgdGhpcy5kZWZhdWx0QW5jaG9yKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgaW50ZXJuYWwgV2ViR0wgVVYgY2FjaGUuIFVzZSBpdCBhZnRlciB5b3UgY2hhbmdlIGBmcmFtZWAgb3IgYHRyaW1gIG9mIHRoZSB0ZXh0dXJlLlxuICAgICAqL1xuXG5cbiAgICBUZXh0dXJlLnByb3RvdHlwZS5fdXBkYXRlVXZzID0gZnVuY3Rpb24gX3VwZGF0ZVV2cygpIHtcbiAgICAgICAgaWYgKCF0aGlzLl91dnMpIHtcbiAgICAgICAgICAgIHRoaXMuX3V2cyA9IG5ldyBfVGV4dHVyZVV2czIuZGVmYXVsdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fdXZzLnNldCh0aGlzLl9mcmFtZSwgdGhpcy5iYXNlVGV4dHVyZSwgdGhpcy5yb3RhdGUpO1xuXG4gICAgICAgIHRoaXMuX3VwZGF0ZUlEKys7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgYSBUZXh0dXJlIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBpbWFnZSB1cmwuXG4gICAgICogSWYgdGhlIGltYWdlIGlzIG5vdCBpbiB0aGUgdGV4dHVyZSBjYWNoZSBpdCB3aWxsIGJlICBjcmVhdGVkIGFuZCBsb2FkZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGltYWdlVXJsIC0gVGhlIGltYWdlIHVybCBvZiB0aGUgdGV4dHVyZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Nyb3Nzb3JpZ2luXSAtIFdoZXRoZXIgcmVxdWVzdHMgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgY3Jvc3NvcmlnaW5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3NjYWxlTW9kZT1QSVhJLnNldHRpbmdzLlNDQUxFX01PREVdIC0gU2VlIHtAbGluayBQSVhJLlNDQUxFX01PREVTfSBmb3IgcG9zc2libGUgdmFsdWVzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzb3VyY2VTY2FsZT0oYXV0byldIC0gU2NhbGUgZm9yIHRoZSBvcmlnaW5hbCBpbWFnZSwgdXNlZCB3aXRoIFNWRyBpbWFnZXMuXG4gICAgICogQHJldHVybiB7UElYSS5UZXh0dXJlfSBUaGUgbmV3bHkgY3JlYXRlZCB0ZXh0dXJlXG4gICAgICovXG5cblxuICAgIFRleHR1cmUuZnJvbUltYWdlID0gZnVuY3Rpb24gZnJvbUltYWdlKGltYWdlVXJsLCBjcm9zc29yaWdpbiwgc2NhbGVNb2RlLCBzb3VyY2VTY2FsZSkge1xuICAgICAgICB2YXIgdGV4dHVyZSA9IF91dGlscy5UZXh0dXJlQ2FjaGVbaW1hZ2VVcmxdO1xuXG4gICAgICAgIGlmICghdGV4dHVyZSkge1xuICAgICAgICAgICAgdGV4dHVyZSA9IG5ldyBUZXh0dXJlKF9CYXNlVGV4dHVyZTIuZGVmYXVsdC5mcm9tSW1hZ2UoaW1hZ2VVcmwsIGNyb3Nzb3JpZ2luLCBzY2FsZU1vZGUsIHNvdXJjZVNjYWxlKSk7XG4gICAgICAgICAgICBUZXh0dXJlLmFkZFRvQ2FjaGUodGV4dHVyZSwgaW1hZ2VVcmwpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRleHR1cmU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgYSBzcHJpdGUgdGhhdCB3aWxsIGNvbnRhaW4gYSB0ZXh0dXJlIGZyb20gdGhlIFRleHR1cmVDYWNoZSBiYXNlZCBvbiB0aGUgZnJhbWVJZFxuICAgICAqIFRoZSBmcmFtZSBpZHMgYXJlIGNyZWF0ZWQgd2hlbiBhIFRleHR1cmUgcGFja2VyIGZpbGUgaGFzIGJlZW4gbG9hZGVkXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZyYW1lSWQgLSBUaGUgZnJhbWUgSWQgb2YgdGhlIHRleHR1cmUgaW4gdGhlIGNhY2hlXG4gICAgICogQHJldHVybiB7UElYSS5UZXh0dXJlfSBUaGUgbmV3bHkgY3JlYXRlZCB0ZXh0dXJlXG4gICAgICovXG5cblxuICAgIFRleHR1cmUuZnJvbUZyYW1lID0gZnVuY3Rpb24gZnJvbUZyYW1lKGZyYW1lSWQpIHtcbiAgICAgICAgdmFyIHRleHR1cmUgPSBfdXRpbHMuVGV4dHVyZUNhY2hlW2ZyYW1lSWRdO1xuXG4gICAgICAgIGlmICghdGV4dHVyZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgZnJhbWVJZCBcIicgKyBmcmFtZUlkICsgJ1wiIGRvZXMgbm90IGV4aXN0IGluIHRoZSB0ZXh0dXJlIGNhY2hlJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGV4dHVyZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyBhIG5ldyBUZXh0dXJlIGJhc2VkIG9uIHRoZSBnaXZlbiBjYW52YXMgZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXMgLSBUaGUgY2FudmFzIGVsZW1lbnQgc291cmNlIG9mIHRoZSB0ZXh0dXJlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzY2FsZU1vZGU9UElYSS5zZXR0aW5ncy5TQ0FMRV9NT0RFXSAtIFNlZSB7QGxpbmsgUElYSS5TQ0FMRV9NT0RFU30gZm9yIHBvc3NpYmxlIHZhbHVlc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3JpZ2luPSdjYW52YXMnXSAtIEEgc3RyaW5nIG9yaWdpbiBvZiB3aG8gY3JlYXRlZCB0aGUgYmFzZSB0ZXh0dXJlXG4gICAgICogQHJldHVybiB7UElYSS5UZXh0dXJlfSBUaGUgbmV3bHkgY3JlYXRlZCB0ZXh0dXJlXG4gICAgICovXG5cblxuICAgIFRleHR1cmUuZnJvbUNhbnZhcyA9IGZ1bmN0aW9uIGZyb21DYW52YXMoY2FudmFzLCBzY2FsZU1vZGUpIHtcbiAgICAgICAgdmFyIG9yaWdpbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogJ2NhbnZhcyc7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0dXJlKF9CYXNlVGV4dHVyZTIuZGVmYXVsdC5mcm9tQ2FudmFzKGNhbnZhcywgc2NhbGVNb2RlLCBvcmlnaW4pKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyBhIG5ldyBUZXh0dXJlIGJhc2VkIG9uIHRoZSBnaXZlbiB2aWRlbyBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7SFRNTFZpZGVvRWxlbWVudHxzdHJpbmd9IHZpZGVvIC0gVGhlIFVSTCBvciBhY3R1YWwgZWxlbWVudCBvZiB0aGUgdmlkZW9cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3NjYWxlTW9kZT1QSVhJLnNldHRpbmdzLlNDQUxFX01PREVdIC0gU2VlIHtAbGluayBQSVhJLlNDQUxFX01PREVTfSBmb3IgcG9zc2libGUgdmFsdWVzXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbY3Jvc3NvcmlnaW49KGF1dG8pXSAtIFNob3VsZCB1c2UgYW5vbnltb3VzIENPUlM/IERlZmF1bHRzIHRvIHRydWUgaWYgdGhlIFVSTCBpcyBub3QgYSBkYXRhLVVSSS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFthdXRvUGxheT10cnVlXSAtIFN0YXJ0IHBsYXlpbmcgdmlkZW8gYXMgc29vbiBhcyBpdCBpcyBsb2FkZWRcbiAgICAgKiBAcmV0dXJuIHtQSVhJLlRleHR1cmV9IFRoZSBuZXdseSBjcmVhdGVkIHRleHR1cmVcbiAgICAgKi9cblxuXG4gICAgVGV4dHVyZS5mcm9tVmlkZW8gPSBmdW5jdGlvbiBmcm9tVmlkZW8odmlkZW8sIHNjYWxlTW9kZSwgY3Jvc3NvcmlnaW4sIGF1dG9QbGF5KSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmlkZW8gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gVGV4dHVyZS5mcm9tVmlkZW9VcmwodmlkZW8sIHNjYWxlTW9kZSwgY3Jvc3NvcmlnaW4sIGF1dG9QbGF5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgVGV4dHVyZShfVmlkZW9CYXNlVGV4dHVyZTIuZGVmYXVsdC5mcm9tVmlkZW8odmlkZW8sIHNjYWxlTW9kZSwgYXV0b1BsYXkpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyBhIG5ldyBUZXh0dXJlIGJhc2VkIG9uIHRoZSB2aWRlbyB1cmwuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZpZGVvVXJsIC0gVVJMIG9mIHRoZSB2aWRlb1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc2NhbGVNb2RlPVBJWEkuc2V0dGluZ3MuU0NBTEVfTU9ERV0gLSBTZWUge0BsaW5rIFBJWEkuU0NBTEVfTU9ERVN9IGZvciBwb3NzaWJsZSB2YWx1ZXNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtjcm9zc29yaWdpbj0oYXV0byldIC0gU2hvdWxkIHVzZSBhbm9ueW1vdXMgQ09SUz8gRGVmYXVsdHMgdG8gdHJ1ZSBpZiB0aGUgVVJMIGlzIG5vdCBhIGRhdGEtVVJJLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2F1dG9QbGF5PXRydWVdIC0gU3RhcnQgcGxheWluZyB2aWRlbyBhcyBzb29uIGFzIGl0IGlzIGxvYWRlZFxuICAgICAqIEByZXR1cm4ge1BJWEkuVGV4dHVyZX0gVGhlIG5ld2x5IGNyZWF0ZWQgdGV4dHVyZVxuICAgICAqL1xuXG5cbiAgICBUZXh0dXJlLmZyb21WaWRlb1VybCA9IGZ1bmN0aW9uIGZyb21WaWRlb1VybCh2aWRlb1VybCwgc2NhbGVNb2RlLCBjcm9zc29yaWdpbiwgYXV0b1BsYXkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0dXJlKF9WaWRlb0Jhc2VUZXh0dXJlMi5kZWZhdWx0LmZyb21VcmwodmlkZW9VcmwsIHNjYWxlTW9kZSwgY3Jvc3NvcmlnaW4sIGF1dG9QbGF5KSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgYSBuZXcgVGV4dHVyZSBiYXNlZCBvbiB0aGUgc291cmNlIHlvdSBwcm92aWRlLlxuICAgICAqIFRoZSBzb3VyY2UgY2FuIGJlIC0gZnJhbWUgaWQsIGltYWdlIHVybCwgdmlkZW8gdXJsLCBjYW52YXMgZWxlbWVudCwgdmlkZW8gZWxlbWVudCwgYmFzZSB0ZXh0dXJlXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfEhUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR8SFRNTFZpZGVvRWxlbWVudHxQSVhJLkJhc2VUZXh0dXJlfVxuICAgICAqICAgICAgICBzb3VyY2UgLSBTb3VyY2UgdG8gY3JlYXRlIHRleHR1cmUgZnJvbVxuICAgICAqIEByZXR1cm4ge1BJWEkuVGV4dHVyZX0gVGhlIG5ld2x5IGNyZWF0ZWQgdGV4dHVyZVxuICAgICAqL1xuXG5cbiAgICBUZXh0dXJlLmZyb20gPSBmdW5jdGlvbiBmcm9tKHNvdXJjZSkge1xuICAgICAgICAvLyBUT0RPIGF1dG8gZGV0ZWN0IGNyb3NzIG9yaWdpbi4uXG4gICAgICAgIC8vIFRPRE8gcGFzcyBpbiBzY2FsZSBtb2RlP1xuICAgICAgICBpZiAodHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhciB0ZXh0dXJlID0gX3V0aWxzLlRleHR1cmVDYWNoZVtzb3VyY2VdO1xuXG4gICAgICAgICAgICBpZiAoIXRleHR1cmUpIHtcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiBpdHMgYSB2aWRlby4uXG4gICAgICAgICAgICAgICAgdmFyIGlzVmlkZW8gPSBzb3VyY2UubWF0Y2goL1xcLihtcDR8d2VibXxvZ2d8aDI2NHxhdml8bW92KSQvKSAhPT0gbnVsbDtcblxuICAgICAgICAgICAgICAgIGlmIChpc1ZpZGVvKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBUZXh0dXJlLmZyb21WaWRlb1VybChzb3VyY2UpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBUZXh0dXJlLmZyb21JbWFnZShzb3VyY2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGV4dHVyZTtcbiAgICAgICAgfSBlbHNlIGlmIChzb3VyY2UgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFRleHR1cmUoX0Jhc2VUZXh0dXJlMi5kZWZhdWx0LmZyb20oc291cmNlKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc291cmNlIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBUZXh0dXJlLmZyb21DYW52YXMoc291cmNlLCBfc2V0dGluZ3MyLmRlZmF1bHQuU0NBTEVfTU9ERSwgJ0hUTUxDYW52YXNFbGVtZW50Jyk7XG4gICAgICAgIH0gZWxzZSBpZiAoc291cmNlIGluc3RhbmNlb2YgSFRNTFZpZGVvRWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIFRleHR1cmUuZnJvbVZpZGVvKHNvdXJjZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc291cmNlIGluc3RhbmNlb2YgX0Jhc2VUZXh0dXJlMi5kZWZhdWx0KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFRleHR1cmUoc291cmNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGxldHMgYXNzdW1lIGl0cyBhIHRleHR1cmUhXG4gICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHRleHR1cmUgZnJvbSBhIHNvdXJjZSBhbmQgYWRkIHRvIHRoZSBjYWNoZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR9IHNvdXJjZSAtIFRoZSBpbnB1dCBzb3VyY2UuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGltYWdlVXJsIC0gRmlsZSBuYW1lIG9mIHRleHR1cmUsIGZvciBjYWNoZSBhbmQgcmVzb2x2aW5nIHJlc29sdXRpb24uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtuYW1lXSAtIEh1bWFuIHJlYWRpYmxlIG5hbWUgZm9yIHRoZSB0ZXh0dXJlIGNhY2hlLiBJZiBubyBuYW1lIGlzXG4gICAgICogICAgICAgIHNwZWNpZmllZCwgb25seSBgaW1hZ2VVcmxgIHdpbGwgYmUgdXNlZCBhcyB0aGUgY2FjaGUgSUQuXG4gICAgICogQHJldHVybiB7UElYSS5UZXh0dXJlfSBPdXRwdXQgdGV4dHVyZVxuICAgICAqL1xuXG5cbiAgICBUZXh0dXJlLmZyb21Mb2FkZXIgPSBmdW5jdGlvbiBmcm9tTG9hZGVyKHNvdXJjZSwgaW1hZ2VVcmwsIG5hbWUpIHtcbiAgICAgICAgdmFyIGJhc2VUZXh0dXJlID0gbmV3IF9CYXNlVGV4dHVyZTIuZGVmYXVsdChzb3VyY2UsIHVuZGVmaW5lZCwgKDAsIF91dGlscy5nZXRSZXNvbHV0aW9uT2ZVcmwpKGltYWdlVXJsKSk7XG4gICAgICAgIHZhciB0ZXh0dXJlID0gbmV3IFRleHR1cmUoYmFzZVRleHR1cmUpO1xuXG4gICAgICAgIGJhc2VUZXh0dXJlLmltYWdlVXJsID0gaW1hZ2VVcmw7XG5cbiAgICAgICAgLy8gTm8gbmFtZSwgdXNlIGltYWdlVXJsIGluc3RlYWRcbiAgICAgICAgaWYgKCFuYW1lKSB7XG4gICAgICAgICAgICBuYW1lID0gaW1hZ2VVcmw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBsZXRzIGFsc28gYWRkIHRoZSBmcmFtZSB0byBwaXhpJ3MgZ2xvYmFsIGNhY2hlIGZvciBmcm9tRnJhbWUgYW5kIGZyb21JbWFnZSBmdWNudGlvbnNcbiAgICAgICAgX0Jhc2VUZXh0dXJlMi5kZWZhdWx0LmFkZFRvQ2FjaGUodGV4dHVyZS5iYXNlVGV4dHVyZSwgbmFtZSk7XG4gICAgICAgIFRleHR1cmUuYWRkVG9DYWNoZSh0ZXh0dXJlLCBuYW1lKTtcblxuICAgICAgICAvLyBhbHNvIGFkZCByZWZlcmVuY2VzIGJ5IHVybCBpZiB0aGV5IGFyZSBkaWZmZXJlbnQuXG4gICAgICAgIGlmIChuYW1lICE9PSBpbWFnZVVybCkge1xuICAgICAgICAgICAgX0Jhc2VUZXh0dXJlMi5kZWZhdWx0LmFkZFRvQ2FjaGUodGV4dHVyZS5iYXNlVGV4dHVyZSwgaW1hZ2VVcmwpO1xuICAgICAgICAgICAgVGV4dHVyZS5hZGRUb0NhY2hlKHRleHR1cmUsIGltYWdlVXJsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0ZXh0dXJlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgVGV4dHVyZSB0byB0aGUgZ2xvYmFsIFRleHR1cmVDYWNoZS4gVGhpcyBjYWNoZSBpcyBzaGFyZWQgYWNyb3NzIHRoZSB3aG9sZSBQSVhJIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge1BJWEkuVGV4dHVyZX0gdGV4dHVyZSAtIFRoZSBUZXh0dXJlIHRvIGFkZCB0byB0aGUgY2FjaGUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIC0gVGhlIGlkIHRoYXQgdGhlIFRleHR1cmUgd2lsbCBiZSBzdG9yZWQgYWdhaW5zdC5cbiAgICAgKi9cblxuXG4gICAgVGV4dHVyZS5hZGRUb0NhY2hlID0gZnVuY3Rpb24gYWRkVG9DYWNoZSh0ZXh0dXJlLCBpZCkge1xuICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICAgIGlmICh0ZXh0dXJlLnRleHR1cmVDYWNoZUlkcy5pbmRleE9mKGlkKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0ZXh0dXJlLnRleHR1cmVDYWNoZUlkcy5wdXNoKGlkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQGlmIERFQlVHXG4gICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG4gICAgICAgICAgICBpZiAoX3V0aWxzLlRleHR1cmVDYWNoZVtpZF0pIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1RleHR1cmUgYWRkZWQgdG8gdGhlIGNhY2hlIHdpdGggYW4gaWQgWycgKyBpZCArICddIHRoYXQgYWxyZWFkeSBoYWQgYW4gZW50cnknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tY29uc29sZSAqL1xuICAgICAgICAgICAgLy8gQGVuZGlmXG5cbiAgICAgICAgICAgIF91dGlscy5UZXh0dXJlQ2FjaGVbaWRdID0gdGV4dHVyZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSBUZXh0dXJlIGZyb20gdGhlIGdsb2JhbCBUZXh0dXJlQ2FjaGUuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtzdHJpbmd8UElYSS5UZXh0dXJlfSB0ZXh0dXJlIC0gaWQgb2YgYSBUZXh0dXJlIHRvIGJlIHJlbW92ZWQsIG9yIGEgVGV4dHVyZSBpbnN0YW5jZSBpdHNlbGZcbiAgICAgKiBAcmV0dXJuIHtQSVhJLlRleHR1cmV8bnVsbH0gVGhlIFRleHR1cmUgdGhhdCB3YXMgcmVtb3ZlZFxuICAgICAqL1xuXG5cbiAgICBUZXh0dXJlLnJlbW92ZUZyb21DYWNoZSA9IGZ1bmN0aW9uIHJlbW92ZUZyb21DYWNoZSh0ZXh0dXJlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGV4dHVyZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhciB0ZXh0dXJlRnJvbUNhY2hlID0gX3V0aWxzLlRleHR1cmVDYWNoZVt0ZXh0dXJlXTtcblxuICAgICAgICAgICAgaWYgKHRleHR1cmVGcm9tQ2FjaGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSB0ZXh0dXJlRnJvbUNhY2hlLnRleHR1cmVDYWNoZUlkcy5pbmRleE9mKHRleHR1cmUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dHVyZUZyb21DYWNoZS50ZXh0dXJlQ2FjaGVJZHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBkZWxldGUgX3V0aWxzLlRleHR1cmVDYWNoZVt0ZXh0dXJlXTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0ZXh0dXJlRnJvbUNhY2hlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRleHR1cmUgJiYgdGV4dHVyZS50ZXh0dXJlQ2FjaGVJZHMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGV4dHVyZS50ZXh0dXJlQ2FjaGVJZHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAvLyBDaGVjayB0aGF0IHRleHR1cmUgbWF0Y2hlcyB0aGUgb25lIGJlaW5nIHBhc3NlZCBpbiBiZWZvcmUgZGVsZXRpbmcgaXQgZnJvbSB0aGUgY2FjaGUuXG4gICAgICAgICAgICAgICAgaWYgKF91dGlscy5UZXh0dXJlQ2FjaGVbdGV4dHVyZS50ZXh0dXJlQ2FjaGVJZHNbaV1dID09PSB0ZXh0dXJlKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBfdXRpbHMuVGV4dHVyZUNhY2hlW3RleHR1cmUudGV4dHVyZUNhY2hlSWRzW2ldXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRleHR1cmUudGV4dHVyZUNhY2hlSWRzLmxlbmd0aCA9IDA7XG5cbiAgICAgICAgICAgIHJldHVybiB0ZXh0dXJlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBmcmFtZSBzcGVjaWZpZXMgdGhlIHJlZ2lvbiBvZiB0aGUgYmFzZSB0ZXh0dXJlIHRoYXQgdGhpcyB0ZXh0dXJlIHVzZXMuXG4gICAgICogUGxlYXNlIGNhbGwgYF91cGRhdGVVdnMoKWAgYWZ0ZXIgeW91IGNoYW5nZSBjb29yZGluYXRlcyBvZiBgZnJhbWVgIG1hbnVhbGx5LlxuICAgICAqXG4gICAgICogQG1lbWJlciB7UElYSS5SZWN0YW5nbGV9XG4gICAgICovXG5cblxuICAgIF9jcmVhdGVDbGFzcyhUZXh0dXJlLCBbe1xuICAgICAgICBrZXk6ICdmcmFtZScsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZyYW1lO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChmcmFtZSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSByZXF1aXJlLWpzZG9jXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX2ZyYW1lID0gZnJhbWU7XG5cbiAgICAgICAgICAgIHRoaXMubm9GcmFtZSA9IGZhbHNlO1xuXG4gICAgICAgICAgICB2YXIgeCA9IGZyYW1lLngsXG4gICAgICAgICAgICAgICAgeSA9IGZyYW1lLnksXG4gICAgICAgICAgICAgICAgd2lkdGggPSBmcmFtZS53aWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSBmcmFtZS5oZWlnaHQ7XG5cbiAgICAgICAgICAgIHZhciB4Tm90Rml0ID0geCArIHdpZHRoID4gdGhpcy5iYXNlVGV4dHVyZS53aWR0aDtcbiAgICAgICAgICAgIHZhciB5Tm90Rml0ID0geSArIGhlaWdodCA+IHRoaXMuYmFzZVRleHR1cmUuaGVpZ2h0O1xuXG4gICAgICAgICAgICBpZiAoeE5vdEZpdCB8fCB5Tm90Rml0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlbGF0aW9uc2hpcCA9IHhOb3RGaXQgJiYgeU5vdEZpdCA/ICdhbmQnIDogJ29yJztcbiAgICAgICAgICAgICAgICB2YXIgZXJyb3JYID0gJ1g6ICcgKyB4ICsgJyArICcgKyB3aWR0aCArICcgPSAnICsgKHggKyB3aWR0aCkgKyAnID4gJyArIHRoaXMuYmFzZVRleHR1cmUud2lkdGg7XG4gICAgICAgICAgICAgICAgdmFyIGVycm9yWSA9ICdZOiAnICsgeSArICcgKyAnICsgaGVpZ2h0ICsgJyA9ICcgKyAoeSArIGhlaWdodCkgKyAnID4gJyArIHRoaXMuYmFzZVRleHR1cmUuaGVpZ2h0O1xuXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUZXh0dXJlIEVycm9yOiBmcmFtZSBkb2VzIG5vdCBmaXQgaW5zaWRlIHRoZSBiYXNlIFRleHR1cmUgZGltZW5zaW9uczogJyArIChlcnJvclggKyAnICcgKyByZWxhdGlvbnNoaXAgKyAnICcgKyBlcnJvclkpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gdGhpcy52YWxpZCA9IHdpZHRoICYmIGhlaWdodCAmJiB0aGlzLmJhc2VUZXh0dXJlLnNvdXJjZSAmJiB0aGlzLmJhc2VUZXh0dXJlLmhhc0xvYWRlZDtcbiAgICAgICAgICAgIHRoaXMudmFsaWQgPSB3aWR0aCAmJiBoZWlnaHQgJiYgdGhpcy5iYXNlVGV4dHVyZS5oYXNMb2FkZWQ7XG5cbiAgICAgICAgICAgIGlmICghdGhpcy50cmltICYmICF0aGlzLnJvdGF0ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMub3JpZyA9IGZyYW1lO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy52YWxpZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVV2cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSB0ZXh0dXJlIGlzIHJvdGF0ZWQgaW5zaWRlIHRoZSBhdGxhc1xuICAgICAgICAgKiBzZXQgdG8gMiB0byBjb21wZW5zYXRlIGZvciB0ZXh0dXJlIHBhY2tlciByb3RhdGlvblxuICAgICAgICAgKiBzZXQgdG8gNiB0byBjb21wZW5zYXRlIGZvciBzcGluZSBwYWNrZXIgcm90YXRpb25cbiAgICAgICAgICogY2FuIGJlIHVzZWQgdG8gcm90YXRlIG9yIG1pcnJvciBzcHJpdGVzXG4gICAgICAgICAqIFNlZSB7QGxpbmsgUElYSS5Hcm91cEQ4fSBmb3IgZXhwbGFuYXRpb25cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAncm90YXRlJyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcm90YXRlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChyb3RhdGUpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcmVxdWlyZS1qc2RvY1xuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9yb3RhdGUgPSByb3RhdGU7XG4gICAgICAgICAgICBpZiAodGhpcy52YWxpZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVV2cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB3aWR0aCBvZiB0aGUgVGV4dHVyZSBpbiBwaXhlbHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3dpZHRoJyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcmlnLndpZHRoO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBoZWlnaHQgb2YgdGhlIFRleHR1cmUgaW4gcGl4ZWxzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdoZWlnaHQnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9yaWcuaGVpZ2h0O1xuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFRleHR1cmU7XG59KF9ldmVudGVtaXR0ZXIyLmRlZmF1bHQpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBUZXh0dXJlO1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZVdoaXRlVGV4dHVyZSgpIHtcbiAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG5cbiAgICBjYW52YXMud2lkdGggPSAxMDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gMTA7XG5cbiAgICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgY29udGV4dC5maWxsU3R5bGUgPSAnd2hpdGUnO1xuICAgIGNvbnRleHQuZmlsbFJlY3QoMCwgMCwgMTAsIDEwKTtcblxuICAgIHJldHVybiBuZXcgVGV4dHVyZShuZXcgX0Jhc2VUZXh0dXJlMi5kZWZhdWx0KGNhbnZhcykpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVBbGxIYW5kbGVycyh0ZXgpIHtcbiAgICB0ZXguZGVzdHJveSA9IGZ1bmN0aW9uIF9lbXB0eURlc3Ryb3koKSB7LyogZW1wdHkgKi99O1xuICAgIHRleC5vbiA9IGZ1bmN0aW9uIF9lbXB0eU9uKCkgey8qIGVtcHR5ICovfTtcbiAgICB0ZXgub25jZSA9IGZ1bmN0aW9uIF9lbXB0eU9uY2UoKSB7LyogZW1wdHkgKi99O1xuICAgIHRleC5lbWl0ID0gZnVuY3Rpb24gX2VtcHR5RW1pdCgpIHsvKiBlbXB0eSAqL307XG59XG5cbi8qKlxuICogQW4gZW1wdHkgdGV4dHVyZSwgdXNlZCBvZnRlbiB0byBub3QgaGF2ZSB0byBjcmVhdGUgbXVsdGlwbGUgZW1wdHkgdGV4dHVyZXMuXG4gKiBDYW4gbm90IGJlIGRlc3Ryb3llZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAY29uc3RhbnRcbiAqL1xuVGV4dHVyZS5FTVBUWSA9IG5ldyBUZXh0dXJlKG5ldyBfQmFzZVRleHR1cmUyLmRlZmF1bHQoKSk7XG5yZW1vdmVBbGxIYW5kbGVycyhUZXh0dXJlLkVNUFRZKTtcbnJlbW92ZUFsbEhhbmRsZXJzKFRleHR1cmUuRU1QVFkuYmFzZVRleHR1cmUpO1xuXG4vKipcbiAqIEEgd2hpdGUgdGV4dHVyZSBvZiAxMHgxMCBzaXplLCB1c2VkIGZvciBncmFwaGljcyBhbmQgb3RoZXIgdGhpbmdzXG4gKiBDYW4gbm90IGJlIGRlc3Ryb3llZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAY29uc3RhbnRcbiAqL1xuVGV4dHVyZS5XSElURSA9IGNyZWF0ZVdoaXRlVGV4dHVyZSgpO1xucmVtb3ZlQWxsSGFuZGxlcnMoVGV4dHVyZS5XSElURSk7XG5yZW1vdmVBbGxIYW5kbGVycyhUZXh0dXJlLldISVRFLmJhc2VUZXh0dXJlKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRleHR1cmUuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX01hdHJpeCA9IHJlcXVpcmUoJy4uL21hdGgvTWF0cml4Jyk7XG5cbnZhciBfTWF0cml4MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01hdHJpeCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciB0ZW1wTWF0ID0gbmV3IF9NYXRyaXgyLmRlZmF1bHQoKTtcblxuLyoqXG4gKiBDbGFzcyBjb250cm9scyB1diB0cmFuc2Zvcm0gYW5kIGZyYW1lIGNsYW1wIGZvciB0ZXh0dXJlXG4gKiBDYW4gYmUgdXNlZCBpbiBUZXh0dXJlIFwidHJhbnNmb3JtXCIgZmllbGQsIG9yIHNlcGFyYXRlbHksIHlvdSBjYW4gdXNlIGRpZmZlcmVudCBjbGFtcCBzZXR0aW5ncyBvbiB0aGUgc2FtZSB0ZXh0dXJlLlxuICogSWYgeW91IHdhbnQgdG8gYWRkIHN1cHBvcnQgZm9yIHRleHR1cmUgcmVnaW9uIG9mIGNlcnRhaW4gZmVhdHVyZSBvciBmaWx0ZXIsIHRoYXQncyB3aGF0IHlvdSdyZSBsb29raW5nIGZvci5cbiAqXG4gKiBAc2VlIFBJWEkuVGV4dHVyZVxuICogQHNlZSBQSVhJLm1lc2guTWVzaFxuICogQHNlZSBQSVhJLmV4dHJhcy5UaWxpbmdTcHJpdGVcbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIFBJWElcbiAqL1xuXG52YXIgVGV4dHVyZU1hdHJpeCA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5UZXh0dXJlfSB0ZXh0dXJlIG9ic2VydmVkIHRleHR1cmVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2NsYW1wTWFyZ2luXSBDaGFuZ2VzIGZyYW1lIGNsYW1waW5nLCAwLjUgYnkgZGVmYXVsdC4gVXNlIC0wLjUgZm9yIGV4dHJhIGJvcmRlci5cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBUZXh0dXJlTWF0cml4KHRleHR1cmUsIGNsYW1wTWFyZ2luKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUZXh0dXJlTWF0cml4KTtcblxuICAgICAgICB0aGlzLl90ZXh0dXJlID0gdGV4dHVyZTtcblxuICAgICAgICB0aGlzLm1hcENvb3JkID0gbmV3IF9NYXRyaXgyLmRlZmF1bHQoKTtcblxuICAgICAgICB0aGlzLnVDbGFtcEZyYW1lID0gbmV3IEZsb2F0MzJBcnJheSg0KTtcblxuICAgICAgICB0aGlzLnVDbGFtcE9mZnNldCA9IG5ldyBGbG9hdDMyQXJyYXkoMik7XG5cbiAgICAgICAgdGhpcy5fbGFzdFRleHR1cmVJRCA9IC0xO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGFuZ2VzIGZyYW1lIGNsYW1waW5nXG4gICAgICAgICAqIFdvcmtzIHdpdGggVGlsaW5nU3ByaXRlIGFuZCBNZXNoXG4gICAgICAgICAqIENoYW5nZSB0byAxLjUgaWYgeW91IHRleHR1cmUgaGFzIHJlcGVhdGVkIHJpZ2h0IGFuZCBib3R0b20gbGluZXMsIHRoYXQgbGVhZHMgdG8gc21vb3RoZXIgYm9yZGVyc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAZGVmYXVsdCAwXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2xhbXBPZmZzZXQgPSAwO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGFuZ2VzIGZyYW1lIGNsYW1waW5nXG4gICAgICAgICAqIFdvcmtzIHdpdGggVGlsaW5nU3ByaXRlIGFuZCBNZXNoXG4gICAgICAgICAqIENoYW5nZSB0byAtMC41IHRvIGFkZCBhIHBpeGVsIHRvIHRoZSBlZGdlLCByZWNvbW1lbmRlZCBmb3IgdHJhbnNwYXJlbnQgdHJpbW1lZCB0ZXh0dXJlcyBpbiBhdGxhc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAZGVmYXVsdCAwLjVcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jbGFtcE1hcmdpbiA9IHR5cGVvZiBjbGFtcE1hcmdpbiA9PT0gJ3VuZGVmaW5lZCcgPyAwLjUgOiBjbGFtcE1hcmdpbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB0ZXh0dXJlIHByb3BlcnR5XG4gICAgICogQG1lbWJlciB7UElYSS5UZXh0dXJlfVxuICAgICAqL1xuXG5cbiAgICAvKipcbiAgICAgKiBNdWx0aXBsaWVzIHV2cyBhcnJheSB0byB0cmFuc2Zvcm1cbiAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gdXZzIG1lc2ggdXZzXG4gICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl9IFtvdXQ9dXZzXSBvdXRwdXRcbiAgICAgKiBAcmV0dXJucyB7RmxvYXQzMkFycmF5fSBvdXRwdXRcbiAgICAgKi9cbiAgICBUZXh0dXJlTWF0cml4LnByb3RvdHlwZS5tdWx0aXBseVV2cyA9IGZ1bmN0aW9uIG11bHRpcGx5VXZzKHV2cywgb3V0KSB7XG4gICAgICAgIGlmIChvdXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb3V0ID0gdXZzO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1hdCA9IHRoaXMubWFwQ29vcmQ7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1dnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgIHZhciB4ID0gdXZzW2ldO1xuICAgICAgICAgICAgdmFyIHkgPSB1dnNbaSArIDFdO1xuXG4gICAgICAgICAgICBvdXRbaV0gPSB4ICogbWF0LmEgKyB5ICogbWF0LmMgKyBtYXQudHg7XG4gICAgICAgICAgICBvdXRbaSArIDFdID0geCAqIG1hdC5iICsgeSAqIG1hdC5kICsgbWF0LnR5O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogdXBkYXRlcyBtYXRyaWNlcyBpZiB0ZXh0dXJlIHdhcyBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtib29sZWFufSBmb3JjZVVwZGF0ZSBpZiB0cnVlLCBtYXRyaWNlcyB3aWxsIGJlIHVwZGF0ZWQgYW55IGNhc2VcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gd2hldGhlciBvciBub3QgaXQgd2FzIHVwZGF0ZWRcbiAgICAgKi9cblxuXG4gICAgVGV4dHVyZU1hdHJpeC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKGZvcmNlVXBkYXRlKSB7XG4gICAgICAgIHZhciB0ZXggPSB0aGlzLl90ZXh0dXJlO1xuXG4gICAgICAgIGlmICghdGV4IHx8ICF0ZXgudmFsaWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZm9yY2VVcGRhdGUgJiYgdGhpcy5fbGFzdFRleHR1cmVJRCA9PT0gdGV4Ll91cGRhdGVJRCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbGFzdFRleHR1cmVJRCA9IHRleC5fdXBkYXRlSUQ7XG5cbiAgICAgICAgdmFyIHV2cyA9IHRleC5fdXZzO1xuXG4gICAgICAgIHRoaXMubWFwQ29vcmQuc2V0KHV2cy54MSAtIHV2cy54MCwgdXZzLnkxIC0gdXZzLnkwLCB1dnMueDMgLSB1dnMueDAsIHV2cy55MyAtIHV2cy55MCwgdXZzLngwLCB1dnMueTApO1xuXG4gICAgICAgIHZhciBvcmlnID0gdGV4Lm9yaWc7XG4gICAgICAgIHZhciB0cmltID0gdGV4LnRyaW07XG5cbiAgICAgICAgaWYgKHRyaW0pIHtcbiAgICAgICAgICAgIHRlbXBNYXQuc2V0KG9yaWcud2lkdGggLyB0cmltLndpZHRoLCAwLCAwLCBvcmlnLmhlaWdodCAvIHRyaW0uaGVpZ2h0LCAtdHJpbS54IC8gdHJpbS53aWR0aCwgLXRyaW0ueSAvIHRyaW0uaGVpZ2h0KTtcbiAgICAgICAgICAgIHRoaXMubWFwQ29vcmQuYXBwZW5kKHRlbXBNYXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRleEJhc2UgPSB0ZXguYmFzZVRleHR1cmU7XG4gICAgICAgIHZhciBmcmFtZSA9IHRoaXMudUNsYW1wRnJhbWU7XG4gICAgICAgIHZhciBtYXJnaW4gPSB0aGlzLmNsYW1wTWFyZ2luIC8gdGV4QmFzZS5yZXNvbHV0aW9uO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5jbGFtcE9mZnNldDtcblxuICAgICAgICBmcmFtZVswXSA9ICh0ZXguX2ZyYW1lLnggKyBtYXJnaW4gKyBvZmZzZXQpIC8gdGV4QmFzZS53aWR0aDtcbiAgICAgICAgZnJhbWVbMV0gPSAodGV4Ll9mcmFtZS55ICsgbWFyZ2luICsgb2Zmc2V0KSAvIHRleEJhc2UuaGVpZ2h0O1xuICAgICAgICBmcmFtZVsyXSA9ICh0ZXguX2ZyYW1lLnggKyB0ZXguX2ZyYW1lLndpZHRoIC0gbWFyZ2luICsgb2Zmc2V0KSAvIHRleEJhc2Uud2lkdGg7XG4gICAgICAgIGZyYW1lWzNdID0gKHRleC5fZnJhbWUueSArIHRleC5fZnJhbWUuaGVpZ2h0IC0gbWFyZ2luICsgb2Zmc2V0KSAvIHRleEJhc2UuaGVpZ2h0O1xuICAgICAgICB0aGlzLnVDbGFtcE9mZnNldFswXSA9IG9mZnNldCAvIHRleEJhc2UucmVhbFdpZHRoO1xuICAgICAgICB0aGlzLnVDbGFtcE9mZnNldFsxXSA9IG9mZnNldCAvIHRleEJhc2UucmVhbEhlaWdodDtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgX2NyZWF0ZUNsYXNzKFRleHR1cmVNYXRyaXgsIFt7XG4gICAgICAgIGtleTogJ3RleHR1cmUnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90ZXh0dXJlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSByZXF1aXJlLWpzZG9jXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX3RleHR1cmUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuX2xhc3RUZXh0dXJlSUQgPSAtMTtcbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBUZXh0dXJlTWF0cml4O1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBUZXh0dXJlTWF0cml4O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGV4dHVyZU1hdHJpeC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfR3JvdXBEID0gcmVxdWlyZSgnLi4vbWF0aC9Hcm91cEQ4Jyk7XG5cbnZhciBfR3JvdXBEMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0dyb3VwRCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8qKlxuICogQSBzdGFuZGFyZCBvYmplY3QgdG8gc3RvcmUgdGhlIFV2cyBvZiBhIHRleHR1cmVcbiAqXG4gKiBAY2xhc3NcbiAqIEBwcml2YXRlXG4gKiBAbWVtYmVyb2YgUElYSVxuICovXG52YXIgVGV4dHVyZVV2cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFRleHR1cmVVdnMoKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUZXh0dXJlVXZzKTtcblxuICAgICAgICB0aGlzLngwID0gMDtcbiAgICAgICAgdGhpcy55MCA9IDA7XG5cbiAgICAgICAgdGhpcy54MSA9IDE7XG4gICAgICAgIHRoaXMueTEgPSAwO1xuXG4gICAgICAgIHRoaXMueDIgPSAxO1xuICAgICAgICB0aGlzLnkyID0gMTtcblxuICAgICAgICB0aGlzLngzID0gMDtcbiAgICAgICAgdGhpcy55MyA9IDE7XG5cbiAgICAgICAgdGhpcy51dnNVaW50MzIgPSBuZXcgVWludDMyQXJyYXkoNCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdGV4dHVyZSBVdnMgYmFzZWQgb24gdGhlIGdpdmVuIGZyYW1lIGluZm9ybWF0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1BJWEkuUmVjdGFuZ2xlfSBmcmFtZSAtIFRoZSBmcmFtZSBvZiB0aGUgdGV4dHVyZVxuICAgICAqIEBwYXJhbSB7UElYSS5SZWN0YW5nbGV9IGJhc2VGcmFtZSAtIFRoZSBiYXNlIGZyYW1lIG9mIHRoZSB0ZXh0dXJlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJvdGF0ZSAtIFJvdGF0aW9uIG9mIGZyYW1lLCBzZWUge0BsaW5rIFBJWEkuR3JvdXBEOH1cbiAgICAgKi9cblxuXG4gICAgVGV4dHVyZVV2cy5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gc2V0KGZyYW1lLCBiYXNlRnJhbWUsIHJvdGF0ZSkge1xuICAgICAgICB2YXIgdHcgPSBiYXNlRnJhbWUud2lkdGg7XG4gICAgICAgIHZhciB0aCA9IGJhc2VGcmFtZS5oZWlnaHQ7XG5cbiAgICAgICAgaWYgKHJvdGF0ZSkge1xuICAgICAgICAgICAgLy8gd2lkdGggYW5kIGhlaWdodCBkaXYgMiBkaXYgYmFzZUZyYW1lIHNpemVcbiAgICAgICAgICAgIHZhciB3MiA9IGZyYW1lLndpZHRoIC8gMiAvIHR3O1xuICAgICAgICAgICAgdmFyIGgyID0gZnJhbWUuaGVpZ2h0IC8gMiAvIHRoO1xuXG4gICAgICAgICAgICAvLyBjb29yZGluYXRlcyBvZiBjZW50ZXJcbiAgICAgICAgICAgIHZhciBjWCA9IGZyYW1lLnggLyB0dyArIHcyO1xuICAgICAgICAgICAgdmFyIGNZID0gZnJhbWUueSAvIHRoICsgaDI7XG5cbiAgICAgICAgICAgIHJvdGF0ZSA9IF9Hcm91cEQyLmRlZmF1bHQuYWRkKHJvdGF0ZSwgX0dyb3VwRDIuZGVmYXVsdC5OVyk7IC8vIE5XIGlzIHRvcC1sZWZ0IGNvcm5lclxuICAgICAgICAgICAgdGhpcy54MCA9IGNYICsgdzIgKiBfR3JvdXBEMi5kZWZhdWx0LnVYKHJvdGF0ZSk7XG4gICAgICAgICAgICB0aGlzLnkwID0gY1kgKyBoMiAqIF9Hcm91cEQyLmRlZmF1bHQudVkocm90YXRlKTtcblxuICAgICAgICAgICAgcm90YXRlID0gX0dyb3VwRDIuZGVmYXVsdC5hZGQocm90YXRlLCAyKTsgLy8gcm90YXRlIDkwIGRlZ3JlZXMgY2xvY2t3aXNlXG4gICAgICAgICAgICB0aGlzLngxID0gY1ggKyB3MiAqIF9Hcm91cEQyLmRlZmF1bHQudVgocm90YXRlKTtcbiAgICAgICAgICAgIHRoaXMueTEgPSBjWSArIGgyICogX0dyb3VwRDIuZGVmYXVsdC51WShyb3RhdGUpO1xuXG4gICAgICAgICAgICByb3RhdGUgPSBfR3JvdXBEMi5kZWZhdWx0LmFkZChyb3RhdGUsIDIpO1xuICAgICAgICAgICAgdGhpcy54MiA9IGNYICsgdzIgKiBfR3JvdXBEMi5kZWZhdWx0LnVYKHJvdGF0ZSk7XG4gICAgICAgICAgICB0aGlzLnkyID0gY1kgKyBoMiAqIF9Hcm91cEQyLmRlZmF1bHQudVkocm90YXRlKTtcblxuICAgICAgICAgICAgcm90YXRlID0gX0dyb3VwRDIuZGVmYXVsdC5hZGQocm90YXRlLCAyKTtcbiAgICAgICAgICAgIHRoaXMueDMgPSBjWCArIHcyICogX0dyb3VwRDIuZGVmYXVsdC51WChyb3RhdGUpO1xuICAgICAgICAgICAgdGhpcy55MyA9IGNZICsgaDIgKiBfR3JvdXBEMi5kZWZhdWx0LnVZKHJvdGF0ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLngwID0gZnJhbWUueCAvIHR3O1xuICAgICAgICAgICAgdGhpcy55MCA9IGZyYW1lLnkgLyB0aDtcblxuICAgICAgICAgICAgdGhpcy54MSA9IChmcmFtZS54ICsgZnJhbWUud2lkdGgpIC8gdHc7XG4gICAgICAgICAgICB0aGlzLnkxID0gZnJhbWUueSAvIHRoO1xuXG4gICAgICAgICAgICB0aGlzLngyID0gKGZyYW1lLnggKyBmcmFtZS53aWR0aCkgLyB0dztcbiAgICAgICAgICAgIHRoaXMueTIgPSAoZnJhbWUueSArIGZyYW1lLmhlaWdodCkgLyB0aDtcblxuICAgICAgICAgICAgdGhpcy54MyA9IGZyYW1lLnggLyB0dztcbiAgICAgICAgICAgIHRoaXMueTMgPSAoZnJhbWUueSArIGZyYW1lLmhlaWdodCkgLyB0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudXZzVWludDMyWzBdID0gKE1hdGgucm91bmQodGhpcy55MCAqIDY1NTM1KSAmIDB4RkZGRikgPDwgMTYgfCBNYXRoLnJvdW5kKHRoaXMueDAgKiA2NTUzNSkgJiAweEZGRkY7XG4gICAgICAgIHRoaXMudXZzVWludDMyWzFdID0gKE1hdGgucm91bmQodGhpcy55MSAqIDY1NTM1KSAmIDB4RkZGRikgPDwgMTYgfCBNYXRoLnJvdW5kKHRoaXMueDEgKiA2NTUzNSkgJiAweEZGRkY7XG4gICAgICAgIHRoaXMudXZzVWludDMyWzJdID0gKE1hdGgucm91bmQodGhpcy55MiAqIDY1NTM1KSAmIDB4RkZGRikgPDwgMTYgfCBNYXRoLnJvdW5kKHRoaXMueDIgKiA2NTUzNSkgJiAweEZGRkY7XG4gICAgICAgIHRoaXMudXZzVWludDMyWzNdID0gKE1hdGgucm91bmQodGhpcy55MyAqIDY1NTM1KSAmIDB4RkZGRikgPDwgMTYgfCBNYXRoLnJvdW5kKHRoaXMueDMgKiA2NTUzNSkgJiAweEZGRkY7XG4gICAgfTtcblxuICAgIHJldHVybiBUZXh0dXJlVXZzO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBUZXh0dXJlVXZzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGV4dHVyZVV2cy5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfQmFzZVRleHR1cmUyID0gcmVxdWlyZSgnLi9CYXNlVGV4dHVyZScpO1xuXG52YXIgX0Jhc2VUZXh0dXJlMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Jhc2VUZXh0dXJlMik7XG5cbnZhciBfdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG52YXIgX3RpY2tlciA9IHJlcXVpcmUoJy4uL3RpY2tlcicpO1xuXG52YXIgX2NvbnN0ID0gcmVxdWlyZSgnLi4vY29uc3QnKTtcblxudmFyIF9kZXRlcm1pbmVDcm9zc09yaWdpbiA9IHJlcXVpcmUoJy4uL3V0aWxzL2RldGVybWluZUNyb3NzT3JpZ2luJyk7XG5cbnZhciBfZGV0ZXJtaW5lQ3Jvc3NPcmlnaW4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGV0ZXJtaW5lQ3Jvc3NPcmlnaW4pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbi8qKlxuICogQSB0ZXh0dXJlIG9mIGEgW3BsYXlpbmddIFZpZGVvLlxuICpcbiAqIFZpZGVvIGJhc2UgdGV4dHVyZXMgbWltaWMgUGl4aUpTIEJhc2VUZXh0dXJlLmZyb20uLi4uIG1ldGhvZCBpbiB0aGVpciBjcmVhdGlvbiBwcm9jZXNzLlxuICpcbiAqIFRoaXMgY2FuIGJlIHVzZWQgaW4gc2V2ZXJhbCB3YXlzLCBzdWNoIGFzOlxuICpcbiAqIGBgYGpzXG4gKiBsZXQgdGV4dHVyZSA9IFBJWEkuVmlkZW9CYXNlVGV4dHVyZS5mcm9tVXJsKCdodHRwOi8vbXlkb21haW4uY29tL3ZpZGVvLm1wNCcpO1xuICpcbiAqIGxldCB0ZXh0dXJlID0gUElYSS5WaWRlb0Jhc2VUZXh0dXJlLmZyb21VcmwoeyBzcmM6ICdodHRwOi8vbXlkb21haW4uY29tL3ZpZGVvLm1wNCcsIG1pbWU6ICd2aWRlby9tcDQnIH0pO1xuICpcbiAqIGxldCB0ZXh0dXJlID0gUElYSS5WaWRlb0Jhc2VUZXh0dXJlLmZyb21VcmxzKFsnL3ZpZGVvLndlYm0nLCAnL3ZpZGVvLm1wNCddKTtcbiAqXG4gKiBsZXQgdGV4dHVyZSA9IFBJWEkuVmlkZW9CYXNlVGV4dHVyZS5mcm9tVXJscyhbXG4gKiAgICAgeyBzcmM6ICcvdmlkZW8ud2VibScsIG1pbWU6ICd2aWRlby93ZWJtJyB9LFxuICogICAgIHsgc3JjOiAnL3ZpZGVvLm1wNCcsIG1pbWU6ICd2aWRlby9tcDQnIH1cbiAqIF0pO1xuICogYGBgXG4gKlxuICogU2VlIHRoZSBbXCJkZXVzXCIgZGVtb10oaHR0cDovL3d3dy5nb29kYm95ZGlnaXRhbC5jb20vcGl4aWpzL2V4YW1wbGVzL2RldXMvKS5cbiAqXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIFBJWEkuQmFzZVRleHR1cmVcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKi9cbnZhciBWaWRlb0Jhc2VUZXh0dXJlID0gZnVuY3Rpb24gKF9CYXNlVGV4dHVyZSkge1xuICAgIF9pbmhlcml0cyhWaWRlb0Jhc2VUZXh0dXJlLCBfQmFzZVRleHR1cmUpO1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtIVE1MVmlkZW9FbGVtZW50fSBzb3VyY2UgLSBWaWRlbyBzb3VyY2VcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3NjYWxlTW9kZT1QSVhJLnNldHRpbmdzLlNDQUxFX01PREVdIC0gU2VlIHtAbGluayBQSVhJLlNDQUxFX01PREVTfSBmb3IgcG9zc2libGUgdmFsdWVzXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbYXV0b1BsYXk9dHJ1ZV0gLSBTdGFydCBwbGF5aW5nIHZpZGVvIGFzIHNvb24gYXMgaXQgaXMgbG9hZGVkXG4gICAgICovXG4gICAgZnVuY3Rpb24gVmlkZW9CYXNlVGV4dHVyZShzb3VyY2UsIHNjYWxlTW9kZSkge1xuICAgICAgICB2YXIgYXV0b1BsYXkgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHRydWU7XG5cbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFZpZGVvQmFzZVRleHR1cmUpO1xuXG4gICAgICAgIGlmICghc291cmNlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHZpZGVvIHNvdXJjZSBlbGVtZW50IHNwZWNpZmllZC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGhvb2sgaW4gaGVyZSB0byBjaGVjayBpZiB2aWRlbyBpcyBhbHJlYWR5IGF2YWlsYWJsZS5cbiAgICAgICAgLy8gQmFzZVRleHR1cmUgbG9va3MgZm9yIGEgc291cmNlLmNvbXBsZXRlIGJvb2xlYW4sIHBsdXMgd2lkdGggJiBoZWlnaHQuXG5cbiAgICAgICAgaWYgKChzb3VyY2UucmVhZHlTdGF0ZSA9PT0gc291cmNlLkhBVkVfRU5PVUdIX0RBVEEgfHwgc291cmNlLnJlYWR5U3RhdGUgPT09IHNvdXJjZS5IQVZFX0ZVVFVSRV9EQVRBKSAmJiBzb3VyY2Uud2lkdGggJiYgc291cmNlLmhlaWdodCkge1xuICAgICAgICAgICAgc291cmNlLmNvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9CYXNlVGV4dHVyZS5jYWxsKHRoaXMsIHNvdXJjZSwgc2NhbGVNb2RlKSk7XG5cbiAgICAgICAgX3RoaXMud2lkdGggPSBzb3VyY2UudmlkZW9XaWR0aDtcbiAgICAgICAgX3RoaXMuaGVpZ2h0ID0gc291cmNlLnZpZGVvSGVpZ2h0O1xuXG4gICAgICAgIF90aGlzLl9hdXRvVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgX3RoaXMuX2lzQXV0b1VwZGF0aW5nID0gZmFsc2U7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZW4gc2V0IHRvIHRydWUgd2lsbCBhdXRvbWF0aWNhbGx5IHBsYXkgdmlkZW9zIHVzZWQgYnkgdGhpcyB0ZXh0dXJlIG9uY2VcbiAgICAgICAgICogdGhleSBhcmUgbG9hZGVkLiBJZiBmYWxzZSwgaXQgd2lsbCBub3QgbW9kaWZ5IHRoZSBwbGF5aW5nIHN0YXRlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5hdXRvUGxheSA9IGF1dG9QbGF5O1xuXG4gICAgICAgIF90aGlzLnVwZGF0ZSA9IF90aGlzLnVwZGF0ZS5iaW5kKF90aGlzKTtcbiAgICAgICAgX3RoaXMuX29uQ2FuUGxheSA9IF90aGlzLl9vbkNhblBsYXkuYmluZChfdGhpcyk7XG5cbiAgICAgICAgc291cmNlLmFkZEV2ZW50TGlzdGVuZXIoJ3BsYXknLCBfdGhpcy5fb25QbGF5U3RhcnQuYmluZChfdGhpcykpO1xuICAgICAgICBzb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcigncGF1c2UnLCBfdGhpcy5fb25QbGF5U3RvcC5iaW5kKF90aGlzKSk7XG4gICAgICAgIF90aGlzLmhhc0xvYWRlZCA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5fX2xvYWRlZCA9IGZhbHNlO1xuXG4gICAgICAgIGlmICghX3RoaXMuX2lzU291cmNlUmVhZHkoKSkge1xuICAgICAgICAgICAgc291cmNlLmFkZEV2ZW50TGlzdGVuZXIoJ2NhbnBsYXknLCBfdGhpcy5fb25DYW5QbGF5KTtcbiAgICAgICAgICAgIHNvdXJjZS5hZGRFdmVudExpc3RlbmVyKCdjYW5wbGF5dGhyb3VnaCcsIF90aGlzLl9vbkNhblBsYXkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX3RoaXMuX29uQ2FuUGxheSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHVuZGVybHlpbmcgc291cmNlIGlzIHBsYXlpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgcGxheWluZy5cbiAgICAgKi9cblxuXG4gICAgVmlkZW9CYXNlVGV4dHVyZS5wcm90b3R5cGUuX2lzU291cmNlUGxheWluZyA9IGZ1bmN0aW9uIF9pc1NvdXJjZVBsYXlpbmcoKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSB0aGlzLnNvdXJjZTtcblxuICAgICAgICByZXR1cm4gc291cmNlLmN1cnJlbnRUaW1lID4gMCAmJiBzb3VyY2UucGF1c2VkID09PSBmYWxzZSAmJiBzb3VyY2UuZW5kZWQgPT09IGZhbHNlICYmIHNvdXJjZS5yZWFkeVN0YXRlID4gMjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSB1bmRlcmx5aW5nIHNvdXJjZSBpcyByZWFkeSBmb3IgcGxheWluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiByZWFkeS5cbiAgICAgKi9cblxuXG4gICAgVmlkZW9CYXNlVGV4dHVyZS5wcm90b3R5cGUuX2lzU291cmNlUmVhZHkgPSBmdW5jdGlvbiBfaXNTb3VyY2VSZWFkeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnJlYWR5U3RhdGUgPT09IDMgfHwgdGhpcy5zb3VyY2UucmVhZHlTdGF0ZSA9PT0gNDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUnVucyB0aGUgdXBkYXRlIGxvb3Agd2hlbiB0aGUgdmlkZW8gaXMgcmVhZHkgdG8gcGxheVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuXG4gICAgVmlkZW9CYXNlVGV4dHVyZS5wcm90b3R5cGUuX29uUGxheVN0YXJ0ID0gZnVuY3Rpb24gX29uUGxheVN0YXJ0KCkge1xuICAgICAgICAvLyBKdXN0IGluIGNhc2UgdGhlIHZpZGVvIGhhcyBub3QgcmVjZWl2ZWQgaXRzIGNhbiBwbGF5IGV2ZW4geWV0Li5cbiAgICAgICAgaWYgKCF0aGlzLmhhc0xvYWRlZCkge1xuICAgICAgICAgICAgdGhpcy5fb25DYW5QbGF5KCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuX2lzQXV0b1VwZGF0aW5nICYmIHRoaXMuYXV0b1VwZGF0ZSkge1xuICAgICAgICAgICAgX3RpY2tlci5zaGFyZWQuYWRkKHRoaXMudXBkYXRlLCB0aGlzLCBfY29uc3QuVVBEQVRFX1BSSU9SSVRZLkhJR0gpO1xuICAgICAgICAgICAgdGhpcy5faXNBdXRvVXBkYXRpbmcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEZpcmVkIHdoZW4gYSBwYXVzZSBldmVudCBpcyB0cmlnZ2VyZWQsIHN0b3BzIHRoZSB1cGRhdGUgbG9vcFxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuXG4gICAgVmlkZW9CYXNlVGV4dHVyZS5wcm90b3R5cGUuX29uUGxheVN0b3AgPSBmdW5jdGlvbiBfb25QbGF5U3RvcCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzQXV0b1VwZGF0aW5nKSB7XG4gICAgICAgICAgICBfdGlja2VyLnNoYXJlZC5yZW1vdmUodGhpcy51cGRhdGUsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5faXNBdXRvVXBkYXRpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGaXJlZCB3aGVuIHRoZSB2aWRlbyBpcyBsb2FkZWQgYW5kIHJlYWR5IHRvIHBsYXlcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cblxuICAgIFZpZGVvQmFzZVRleHR1cmUucHJvdG90eXBlLl9vbkNhblBsYXkgPSBmdW5jdGlvbiBfb25DYW5QbGF5KCkge1xuICAgICAgICB0aGlzLmhhc0xvYWRlZCA9IHRydWU7XG5cbiAgICAgICAgaWYgKHRoaXMuc291cmNlKSB7XG4gICAgICAgICAgICB0aGlzLnNvdXJjZS5yZW1vdmVFdmVudExpc3RlbmVyKCdjYW5wbGF5JywgdGhpcy5fb25DYW5QbGF5KTtcbiAgICAgICAgICAgIHRoaXMuc291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NhbnBsYXl0aHJvdWdoJywgdGhpcy5fb25DYW5QbGF5KTtcblxuICAgICAgICAgICAgdGhpcy53aWR0aCA9IHRoaXMuc291cmNlLnZpZGVvV2lkdGg7XG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IHRoaXMuc291cmNlLnZpZGVvSGVpZ2h0O1xuXG4gICAgICAgICAgICAvLyBwcmV2ZW50IG11bHRpcGxlIGxvYWRlZCBkaXNwYXRjaGVzLi5cbiAgICAgICAgICAgIGlmICghdGhpcy5fX2xvYWRlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX19sb2FkZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnbG9hZGVkJywgdGhpcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9pc1NvdXJjZVBsYXlpbmcoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX29uUGxheVN0YXJ0KCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuYXV0b1BsYXkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNvdXJjZS5wbGF5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGVzdHJveXMgdGhpcyB0ZXh0dXJlXG4gICAgICpcbiAgICAgKi9cblxuXG4gICAgVmlkZW9CYXNlVGV4dHVyZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc0F1dG9VcGRhdGluZykge1xuICAgICAgICAgICAgX3RpY2tlci5zaGFyZWQucmVtb3ZlKHRoaXMudXBkYXRlLCB0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnNvdXJjZSAmJiB0aGlzLnNvdXJjZS5fcGl4aUlkKSB7XG4gICAgICAgICAgICBfQmFzZVRleHR1cmUzLmRlZmF1bHQucmVtb3ZlRnJvbUNhY2hlKHRoaXMuc291cmNlLl9waXhpSWQpO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuc291cmNlLl9waXhpSWQ7XG5cbiAgICAgICAgICAgIHRoaXMuc291cmNlLnBhdXNlKCk7XG4gICAgICAgICAgICB0aGlzLnNvdXJjZS5zcmMgPSAnJztcbiAgICAgICAgICAgIHRoaXMuc291cmNlLmxvYWQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9CYXNlVGV4dHVyZS5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBNaW1pYyBQaXhpSlMgQmFzZVRleHR1cmUuZnJvbS4uLi4gbWV0aG9kLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7SFRNTFZpZGVvRWxlbWVudH0gdmlkZW8gLSBWaWRlbyB0byBjcmVhdGUgdGV4dHVyZSBmcm9tXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzY2FsZU1vZGU9UElYSS5zZXR0aW5ncy5TQ0FMRV9NT0RFXSAtIFNlZSB7QGxpbmsgUElYSS5TQ0FMRV9NT0RFU30gZm9yIHBvc3NpYmxlIHZhbHVlc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2F1dG9QbGF5PXRydWVdIC0gU3RhcnQgcGxheWluZyB2aWRlbyBhcyBzb29uIGFzIGl0IGlzIGxvYWRlZFxuICAgICAqIEByZXR1cm4ge1BJWEkuVmlkZW9CYXNlVGV4dHVyZX0gTmV3bHkgY3JlYXRlZCBWaWRlb0Jhc2VUZXh0dXJlXG4gICAgICovXG5cblxuICAgIFZpZGVvQmFzZVRleHR1cmUuZnJvbVZpZGVvID0gZnVuY3Rpb24gZnJvbVZpZGVvKHZpZGVvLCBzY2FsZU1vZGUsIGF1dG9QbGF5KSB7XG4gICAgICAgIGlmICghdmlkZW8uX3BpeGlJZCkge1xuICAgICAgICAgICAgdmlkZW8uX3BpeGlJZCA9ICd2aWRlb18nICsgKDAsIF91dGlscy51aWQpKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYmFzZVRleHR1cmUgPSBfdXRpbHMuQmFzZVRleHR1cmVDYWNoZVt2aWRlby5fcGl4aUlkXTtcblxuICAgICAgICBpZiAoIWJhc2VUZXh0dXJlKSB7XG4gICAgICAgICAgICBiYXNlVGV4dHVyZSA9IG5ldyBWaWRlb0Jhc2VUZXh0dXJlKHZpZGVvLCBzY2FsZU1vZGUsIGF1dG9QbGF5KTtcbiAgICAgICAgICAgIF9CYXNlVGV4dHVyZTMuZGVmYXVsdC5hZGRUb0NhY2hlKGJhc2VUZXh0dXJlLCB2aWRlby5fcGl4aUlkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBiYXNlVGV4dHVyZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyBhIG5ldyBCYXNlVGV4dHVyZSBiYXNlZCBvbiB0aGUgZ2l2ZW4gdmlkZW8gZWxlbWVudC5cbiAgICAgKiBUaGlzIEJhc2VUZXh0dXJlIGNhbiB0aGVuIGJlIHVzZWQgdG8gY3JlYXRlIGEgdGV4dHVyZVxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdHxzdHJpbmdbXXxvYmplY3RbXX0gdmlkZW9TcmMgLSBUaGUgVVJMKHMpIGZvciB0aGUgdmlkZW8uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFt2aWRlb1NyYy5zcmNdIC0gT25lIG9mIHRoZSBzb3VyY2UgdXJscyBmb3IgdGhlIHZpZGVvXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFt2aWRlb1NyYy5taW1lXSAtIFRoZSBtaW1ldHlwZSBvZiB0aGUgdmlkZW8gKGUuZy4gJ3ZpZGVvL21wNCcpLiBJZiBub3Qgc3BlY2lmaWVkXG4gICAgICogIHRoZSB1cmwncyBleHRlbnNpb24gd2lsbCBiZSB1c2VkIGFzIHRoZSBzZWNvbmQgcGFydCBvZiB0aGUgbWltZSB0eXBlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsZU1vZGUgLSBTZWUge0BsaW5rIFBJWEkuU0NBTEVfTU9ERVN9IGZvciBwb3NzaWJsZSB2YWx1ZXNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtjcm9zc29yaWdpbj0oYXV0byldIC0gU2hvdWxkIHVzZSBhbm9ueW1vdXMgQ09SUz8gRGVmYXVsdHMgdG8gdHJ1ZSBpZiB0aGUgVVJMIGlzIG5vdCBhIGRhdGEtVVJJLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2F1dG9QbGF5PXRydWVdIC0gU3RhcnQgcGxheWluZyB2aWRlbyBhcyBzb29uIGFzIGl0IGlzIGxvYWRlZFxuICAgICAqIEByZXR1cm4ge1BJWEkuVmlkZW9CYXNlVGV4dHVyZX0gTmV3bHkgY3JlYXRlZCBWaWRlb0Jhc2VUZXh0dXJlXG4gICAgICovXG5cblxuICAgIFZpZGVvQmFzZVRleHR1cmUuZnJvbVVybCA9IGZ1bmN0aW9uIGZyb21VcmwodmlkZW9TcmMsIHNjYWxlTW9kZSwgY3Jvc3NvcmlnaW4sIGF1dG9QbGF5KSB7XG4gICAgICAgIHZhciB2aWRlbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3ZpZGVvJyk7XG5cbiAgICAgICAgdmlkZW8uc2V0QXR0cmlidXRlKCd3ZWJraXQtcGxheXNpbmxpbmUnLCAnJyk7XG4gICAgICAgIHZpZGVvLnNldEF0dHJpYnV0ZSgncGxheXNpbmxpbmUnLCAnJyk7XG5cbiAgICAgICAgdmFyIHVybCA9IEFycmF5LmlzQXJyYXkodmlkZW9TcmMpID8gdmlkZW9TcmNbMF0uc3JjIHx8IHZpZGVvU3JjWzBdIDogdmlkZW9TcmMuc3JjIHx8IHZpZGVvU3JjO1xuXG4gICAgICAgIGlmIChjcm9zc29yaWdpbiA9PT0gdW5kZWZpbmVkICYmIHVybC5pbmRleE9mKCdkYXRhOicpICE9PSAwKSB7XG4gICAgICAgICAgICB2aWRlby5jcm9zc09yaWdpbiA9ICgwLCBfZGV0ZXJtaW5lQ3Jvc3NPcmlnaW4yLmRlZmF1bHQpKHVybCk7XG4gICAgICAgIH0gZWxzZSBpZiAoY3Jvc3NvcmlnaW4pIHtcbiAgICAgICAgICAgIHZpZGVvLmNyb3NzT3JpZ2luID0gdHlwZW9mIGNyb3Nzb3JpZ2luID09PSAnc3RyaW5nJyA/IGNyb3Nzb3JpZ2luIDogJ2Fub255bW91cyc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhcnJheSBvZiBvYmplY3RzIG9yIHN0cmluZ3NcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmlkZW9TcmMpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZpZGVvU3JjLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmlkZW8uYXBwZW5kQ2hpbGQoY3JlYXRlU291cmNlKHZpZGVvU3JjW2ldLnNyYyB8fCB2aWRlb1NyY1tpXSwgdmlkZW9TcmNbaV0ubWltZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHNpbmdsZSBvYmplY3Qgb3Igc3RyaW5nXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZpZGVvLmFwcGVuZENoaWxkKGNyZWF0ZVNvdXJjZSh1cmwsIHZpZGVvU3JjLm1pbWUpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB2aWRlby5sb2FkKCk7XG5cbiAgICAgICAgcmV0dXJuIFZpZGVvQmFzZVRleHR1cmUuZnJvbVZpZGVvKHZpZGVvLCBzY2FsZU1vZGUsIGF1dG9QbGF5KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2hvdWxkIHRoZSBiYXNlIHRleHR1cmUgYXV0b21hdGljYWxseSB1cGRhdGUgaXRzZWxmLCBzZXQgdG8gdHJ1ZSBieSBkZWZhdWx0XG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAqL1xuXG5cbiAgICBfY3JlYXRlQ2xhc3MoVmlkZW9CYXNlVGV4dHVyZSwgW3tcbiAgICAgICAga2V5OiAnYXV0b1VwZGF0ZScsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2F1dG9VcGRhdGU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlcXVpcmUtanNkb2NcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLl9hdXRvVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYXV0b1VwZGF0ZSA9IHZhbHVlO1xuXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9hdXRvVXBkYXRlICYmIHRoaXMuX2lzQXV0b1VwZGF0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aWNrZXIuc2hhcmVkLnJlbW92ZSh0aGlzLnVwZGF0ZSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2lzQXV0b1VwZGF0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9hdXRvVXBkYXRlICYmICF0aGlzLl9pc0F1dG9VcGRhdGluZykge1xuICAgICAgICAgICAgICAgICAgICBfdGlja2VyLnNoYXJlZC5hZGQodGhpcy51cGRhdGUsIHRoaXMsIF9jb25zdC5VUERBVEVfUFJJT1JJVFkuSElHSCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2lzQXV0b1VwZGF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gVmlkZW9CYXNlVGV4dHVyZTtcbn0oX0Jhc2VUZXh0dXJlMy5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gVmlkZW9CYXNlVGV4dHVyZTtcblxuXG5WaWRlb0Jhc2VUZXh0dXJlLmZyb21VcmxzID0gVmlkZW9CYXNlVGV4dHVyZS5mcm9tVXJsO1xuXG5mdW5jdGlvbiBjcmVhdGVTb3VyY2UocGF0aCwgdHlwZSkge1xuICAgIGlmICghdHlwZSkge1xuICAgICAgICB2YXIgcHVyZVBhdGggPSBwYXRoLnNwbGl0KCc/Jykuc2hpZnQoKS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgIHR5cGUgPSAndmlkZW8vJyArIHB1cmVQYXRoLnN1YnN0cihwdXJlUGF0aC5sYXN0SW5kZXhPZignLicpICsgMSk7XG4gICAgfVxuXG4gICAgdmFyIHNvdXJjZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NvdXJjZScpO1xuXG4gICAgc291cmNlLnNyYyA9IHBhdGg7XG4gICAgc291cmNlLnR5cGUgPSB0eXBlO1xuXG4gICAgcmV0dXJuIHNvdXJjZTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVZpZGVvQmFzZVRleHR1cmUuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX3NldHRpbmdzID0gcmVxdWlyZSgnLi4vc2V0dGluZ3MnKTtcblxudmFyIF9zZXR0aW5nczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zZXR0aW5ncyk7XG5cbnZhciBfY29uc3QgPSByZXF1aXJlKCcuLi9jb25zdCcpO1xuXG52YXIgX1RpY2tlckxpc3RlbmVyID0gcmVxdWlyZSgnLi9UaWNrZXJMaXN0ZW5lcicpO1xuXG52YXIgX1RpY2tlckxpc3RlbmVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1RpY2tlckxpc3RlbmVyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuLyoqXG4gKiBBIFRpY2tlciBjbGFzcyB0aGF0IHJ1bnMgYW4gdXBkYXRlIGxvb3AgdGhhdCBvdGhlciBvYmplY3RzIGxpc3RlbiB0by5cbiAqIFRoaXMgY2xhc3MgaXMgY29tcG9zZWQgYXJvdW5kIGxpc3RlbmVyc1xuICogbWVhbnQgZm9yIGV4ZWN1dGlvbiBvbiB0aGUgbmV4dCByZXF1ZXN0ZWQgYW5pbWF0aW9uIGZyYW1lLlxuICogQW5pbWF0aW9uIGZyYW1lcyBhcmUgcmVxdWVzdGVkIG9ubHkgd2hlbiBuZWNlc3NhcnksXG4gKiBlLmcuIFdoZW4gdGhlIHRpY2tlciBpcyBzdGFydGVkIGFuZCB0aGUgZW1pdHRlciBoYXMgbGlzdGVuZXJzLlxuICpcbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIFBJWEkudGlja2VyXG4gKi9cbnZhciBUaWNrZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBUaWNrZXIoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRpY2tlcik7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBmaXJzdCBsaXN0ZW5lci4gQWxsIG5ldyBsaXN0ZW5lcnMgYWRkZWQgYXJlIGNoYWluZWQgb24gdGhpcy5cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUge1RpY2tlckxpc3RlbmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5faGVhZCA9IG5ldyBfVGlja2VyTGlzdGVuZXIyLmRlZmF1bHQobnVsbCwgbnVsbCwgSW5maW5pdHkpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnRlcm5hbCBjdXJyZW50IGZyYW1lIHJlcXVlc3QgSURcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3JlcXVlc3RJZCA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEludGVybmFsIHZhbHVlIG1hbmFnZWQgYnkgbWluRlBTIHByb3BlcnR5IHNldHRlciBhbmQgZ2V0dGVyLlxuICAgICAgICAgKiBUaGlzIGlzIHRoZSBtYXhpbXVtIGFsbG93ZWQgbWlsbGlzZWNvbmRzIGJldHdlZW4gdXBkYXRlcy5cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX21heEVsYXBzZWRNUyA9IDEwMDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciBvciBub3QgdGhpcyB0aWNrZXIgc2hvdWxkIGludm9rZSB0aGUgbWV0aG9kXG4gICAgICAgICAqIHtAbGluayBQSVhJLnRpY2tlci5UaWNrZXIjc3RhcnR9IGF1dG9tYXRpY2FsbHlcbiAgICAgICAgICogd2hlbiBhIGxpc3RlbmVyIGlzIGFkZGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hdXRvU3RhcnQgPSBmYWxzZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2NhbGFyIHRpbWUgdmFsdWUgZnJvbSBsYXN0IGZyYW1lIHRvIHRoaXMgZnJhbWUuXG4gICAgICAgICAqIFRoaXMgdmFsdWUgaXMgY2FwcGVkIGJ5IHNldHRpbmcge0BsaW5rIFBJWEkudGlja2VyLlRpY2tlciNtaW5GUFN9XG4gICAgICAgICAqIGFuZCBpcyBzY2FsZWQgd2l0aCB7QGxpbmsgUElYSS50aWNrZXIuVGlja2VyI3NwZWVkfS5cbiAgICAgICAgICogKipOb3RlOioqIFRoZSBjYXAgbWF5IGJlIGV4Y2VlZGVkIGJ5IHNjYWxpbmcuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kZWx0YVRpbWUgPSAxO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaW1lIGVsYXBzZWQgaW4gbWlsbGlzZWNvbmRzIGZyb20gbGFzdCBmcmFtZSB0byB0aGlzIGZyYW1lLlxuICAgICAgICAgKiBPcHBvc2VkIHRvIHdoYXQgdGhlIHNjYWxhciB7QGxpbmsgUElYSS50aWNrZXIuVGlja2VyI2RlbHRhVGltZX1cbiAgICAgICAgICogaXMgYmFzZWQsIHRoaXMgdmFsdWUgaXMgbmVpdGhlciBjYXBwZWQgbm9yIHNjYWxlZC5cbiAgICAgICAgICogSWYgdGhlIHBsYXRmb3JtIHN1cHBvcnRzIERPTUhpZ2hSZXNUaW1lU3RhbXAsXG4gICAgICAgICAqIHRoaXMgdmFsdWUgd2lsbCBoYXZlIGEgcHJlY2lzaW9uIG9mIDEgwrVzLlxuICAgICAgICAgKiBEZWZhdWx0cyB0byB0YXJnZXQgZnJhbWUgdGltZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDE2LjY2XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmVsYXBzZWRNUyA9IDEgLyBfc2V0dGluZ3MyLmRlZmF1bHQuVEFSR0VUX0ZQTVM7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBsYXN0IHRpbWUge0BsaW5rIFBJWEkudGlja2VyLlRpY2tlciN1cGRhdGV9IHdhcyBpbnZva2VkLlxuICAgICAgICAgKiBUaGlzIHZhbHVlIGlzIGFsc28gcmVzZXQgaW50ZXJuYWxseSBvdXRzaWRlIG9mIGludm9raW5nXG4gICAgICAgICAqIHVwZGF0ZSwgYnV0IG9ubHkgd2hlbiBhIG5ldyBhbmltYXRpb24gZnJhbWUgaXMgcmVxdWVzdGVkLlxuICAgICAgICAgKiBJZiB0aGUgcGxhdGZvcm0gc3VwcG9ydHMgRE9NSGlnaFJlc1RpbWVTdGFtcCxcbiAgICAgICAgICogdGhpcyB2YWx1ZSB3aWxsIGhhdmUgYSBwcmVjaXNpb24gb2YgMSDCtXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgLTFcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGFzdFRpbWUgPSAtMTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRmFjdG9yIG9mIGN1cnJlbnQge0BsaW5rIFBJWEkudGlja2VyLlRpY2tlciNkZWx0YVRpbWV9LlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiAvLyBTY2FsZXMgdGlja2VyLmRlbHRhVGltZSB0byB3aGF0IHdvdWxkIGJlXG4gICAgICAgICAqIC8vIHRoZSBlcXVpdmFsZW50IG9mIGFwcHJveGltYXRlbHkgMTIwIEZQU1xuICAgICAgICAgKiB0aWNrZXIuc3BlZWQgPSAyO1xuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDFcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3BlZWQgPSAxO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGlzIHRpY2tlciBoYXMgYmVlbiBzdGFydGVkLlxuICAgICAgICAgKiBgdHJ1ZWAgaWYge0BsaW5rIFBJWEkudGlja2VyLlRpY2tlciNzdGFydH0gaGFzIGJlZW4gY2FsbGVkLlxuICAgICAgICAgKiBgZmFsc2VgIGlmIHtAbGluayBQSVhJLnRpY2tlci5UaWNrZXIjc3RvcH0gaGFzIGJlZW4gY2FsbGVkLlxuICAgICAgICAgKiBXaGlsZSBgZmFsc2VgLCB0aGlzIHZhbHVlIG1heSBjaGFuZ2UgdG8gYHRydWVgIGluIHRoZVxuICAgICAgICAgKiBldmVudCBvZiB7QGxpbmsgUElYSS50aWNrZXIuVGlja2VyI2F1dG9TdGFydH0gYmVpbmcgYHRydWVgXG4gICAgICAgICAqIGFuZCBhIGxpc3RlbmVyIGlzIGFkZGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEludGVybmFsIHRpY2sgbWV0aG9kIGJvdW5kIHRvIHRpY2tlciBpbnN0YW5jZS5cbiAgICAgICAgICogVGhpcyBpcyBiZWNhdXNlIGluIGVhcmx5IDIwMTUsIEZ1bmN0aW9uLmJpbmRcbiAgICAgICAgICogaXMgc3RpbGwgNjAlIHNsb3dlciBpbiBoaWdoIHBlcmZvcm1hbmNlIHNjZW5hcmlvcy5cbiAgICAgICAgICogQWxzbyBzZXBhcmF0aW5nIGZyYW1lIHJlcXVlc3RzIGZyb20gdXBkYXRlIG1ldGhvZFxuICAgICAgICAgKiBzbyBsaXN0ZW5lcnMgbWF5IGJlIGNhbGxlZCBhdCBhbnkgdGltZSBhbmQgd2l0aFxuICAgICAgICAgKiBhbnkgYW5pbWF0aW9uIEFQSSwganVzdCBpbnZva2UgdGlja2VyLnVwZGF0ZSh0aW1lKS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWUgLSBUaW1lIHNpbmNlIGxhc3QgdGljay5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3RpY2sgPSBmdW5jdGlvbiAodGltZSkge1xuICAgICAgICAgICAgX3RoaXMuX3JlcXVlc3RJZCA9IG51bGw7XG5cbiAgICAgICAgICAgIGlmIChfdGhpcy5zdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgLy8gSW52b2tlIGxpc3RlbmVycyBub3dcbiAgICAgICAgICAgICAgICBfdGhpcy51cGRhdGUodGltZSk7XG4gICAgICAgICAgICAgICAgLy8gTGlzdGVuZXIgc2lkZSBlZmZlY3RzIG1heSBoYXZlIG1vZGlmaWVkIHRpY2tlciBzdGF0ZS5cbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuc3RhcnRlZCAmJiBfdGhpcy5fcmVxdWVzdElkID09PSBudWxsICYmIF90aGlzLl9oZWFkLm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3JlcXVlc3RJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShfdGhpcy5fdGljayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbmRpdGlvbmFsbHkgcmVxdWVzdHMgYSBuZXcgYW5pbWF0aW9uIGZyYW1lLlxuICAgICAqIElmIGEgZnJhbWUgaGFzIG5vdCBhbHJlYWR5IGJlZW4gcmVxdWVzdGVkLCBhbmQgaWYgdGhlIGludGVybmFsXG4gICAgICogZW1pdHRlciBoYXMgbGlzdGVuZXJzLCBhIG5ldyBmcmFtZSBpcyByZXF1ZXN0ZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG5cbiAgICBUaWNrZXIucHJvdG90eXBlLl9yZXF1ZXN0SWZOZWVkZWQgPSBmdW5jdGlvbiBfcmVxdWVzdElmTmVlZGVkKCkge1xuICAgICAgICBpZiAodGhpcy5fcmVxdWVzdElkID09PSBudWxsICYmIHRoaXMuX2hlYWQubmV4dCkge1xuICAgICAgICAgICAgLy8gZW5zdXJlIGNhbGxiYWNrcyBnZXQgY29ycmVjdCBkZWx0YVxuICAgICAgICAgICAgdGhpcy5sYXN0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAgICAgdGhpcy5fcmVxdWVzdElkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuX3RpY2spO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvbmRpdGlvbmFsbHkgY2FuY2VscyBhIHBlbmRpbmcgYW5pbWF0aW9uIGZyYW1lLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuXG4gICAgVGlja2VyLnByb3RvdHlwZS5fY2FuY2VsSWZOZWVkZWQgPSBmdW5jdGlvbiBfY2FuY2VsSWZOZWVkZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9yZXF1ZXN0SWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuX3JlcXVlc3RJZCk7XG4gICAgICAgICAgICB0aGlzLl9yZXF1ZXN0SWQgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvbmRpdGlvbmFsbHkgcmVxdWVzdHMgYSBuZXcgYW5pbWF0aW9uIGZyYW1lLlxuICAgICAqIElmIHRoZSB0aWNrZXIgaGFzIGJlZW4gc3RhcnRlZCBpdCBjaGVja3MgaWYgYSBmcmFtZSBoYXMgbm90IGFscmVhZHlcbiAgICAgKiBiZWVuIHJlcXVlc3RlZCwgYW5kIGlmIHRoZSBpbnRlcm5hbCBlbWl0dGVyIGhhcyBsaXN0ZW5lcnMuIElmIHRoZXNlXG4gICAgICogY29uZGl0aW9ucyBhcmUgbWV0LCBhIG5ldyBmcmFtZSBpcyByZXF1ZXN0ZWQuIElmIHRoZSB0aWNrZXIgaGFzIG5vdFxuICAgICAqIGJlZW4gc3RhcnRlZCwgYnV0IGF1dG9TdGFydCBpcyBgdHJ1ZWAsIHRoZW4gdGhlIHRpY2tlciBzdGFydHMgbm93LFxuICAgICAqIGFuZCBjb250aW51ZXMgd2l0aCB0aGUgcHJldmlvdXMgY29uZGl0aW9ucyB0byByZXF1ZXN0IGEgbmV3IGZyYW1lLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuXG4gICAgVGlja2VyLnByb3RvdHlwZS5fc3RhcnRJZlBvc3NpYmxlID0gZnVuY3Rpb24gX3N0YXJ0SWZQb3NzaWJsZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhcnRlZCkge1xuICAgICAgICAgICAgdGhpcy5fcmVxdWVzdElmTmVlZGVkKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5hdXRvU3RhcnQpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnQoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciBhIGhhbmRsZXIgZm9yIHRpY2sgZXZlbnRzLiBDYWxscyBjb250aW51b3VzbHkgdW5sZXNzXG4gICAgICogaXQgaXMgcmVtb3ZlZCBvciB0aGUgdGlja2VyIGlzIHN0b3BwZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIFRoZSBsaXN0ZW5lciBmdW5jdGlvbiB0byBiZSBhZGRlZCBmb3IgdXBkYXRlc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb250ZXh0XSAtIFRoZSBsaXN0ZW5lciBjb250ZXh0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwcmlvcml0eT1QSVhJLlVQREFURV9QUklPUklUWS5OT1JNQUxdIC0gVGhlIHByaW9yaXR5IGZvciBlbWl0dGluZ1xuICAgICAqIEByZXR1cm5zIHtQSVhJLnRpY2tlci5UaWNrZXJ9IFRoaXMgaW5zdGFuY2Ugb2YgYSB0aWNrZXJcbiAgICAgKi9cblxuXG4gICAgVGlja2VyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQoZm4sIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIHByaW9yaXR5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBfY29uc3QuVVBEQVRFX1BSSU9SSVRZLk5PUk1BTDtcblxuICAgICAgICByZXR1cm4gdGhpcy5fYWRkTGlzdGVuZXIobmV3IF9UaWNrZXJMaXN0ZW5lcjIuZGVmYXVsdChmbiwgY29udGV4dCwgcHJpb3JpdHkpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQWRkIGEgaGFuZGxlciBmb3IgdGhlIHRpY2sgZXZlbnQgd2hpY2ggaXMgb25seSBleGVjdXRlIG9uY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIFRoZSBsaXN0ZW5lciBmdW5jdGlvbiB0byBiZSBhZGRlZCBmb3Igb25lIHVwZGF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb250ZXh0XSAtIFRoZSBsaXN0ZW5lciBjb250ZXh0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwcmlvcml0eT1QSVhJLlVQREFURV9QUklPUklUWS5OT1JNQUxdIC0gVGhlIHByaW9yaXR5IGZvciBlbWl0dGluZ1xuICAgICAqIEByZXR1cm5zIHtQSVhJLnRpY2tlci5UaWNrZXJ9IFRoaXMgaW5zdGFuY2Ugb2YgYSB0aWNrZXJcbiAgICAgKi9cblxuXG4gICAgVGlja2VyLnByb3RvdHlwZS5hZGRPbmNlID0gZnVuY3Rpb24gYWRkT25jZShmbiwgY29udGV4dCkge1xuICAgICAgICB2YXIgcHJpb3JpdHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IF9jb25zdC5VUERBVEVfUFJJT1JJVFkuTk9STUFMO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRMaXN0ZW5lcihuZXcgX1RpY2tlckxpc3RlbmVyMi5kZWZhdWx0KGZuLCBjb250ZXh0LCBwcmlvcml0eSwgdHJ1ZSkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbGx5IGFkZHMgdGhlIGV2ZW50IGhhbmRsZXIgc28gdGhhdCBpdCBjYW4gYmUgc29ydGVkIGJ5IHByaW9yaXR5LlxuICAgICAqIFByaW9yaXR5IGFsbG93cyBjZXJ0YWluIGhhbmRsZXIgKHVzZXIsIEFuaW1hdGVkU3ByaXRlLCBJbnRlcmFjdGlvbikgdG8gYmUgcnVuXG4gICAgICogYmVmb3JlIHRoZSByZW5kZXJpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7VGlja2VyTGlzdGVuZXJ9IGxpc3RlbmVyIC0gQ3VycmVudCBsaXN0ZW5lciBiZWluZyBhZGRlZC5cbiAgICAgKiBAcmV0dXJucyB7UElYSS50aWNrZXIuVGlja2VyfSBUaGlzIGluc3RhbmNlIG9mIGEgdGlja2VyXG4gICAgICovXG5cblxuICAgIFRpY2tlci5wcm90b3R5cGUuX2FkZExpc3RlbmVyID0gZnVuY3Rpb24gX2FkZExpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgICAgIC8vIEZvciBhdHRhY2hpbmcgdG8gaGVhZFxuICAgICAgICB2YXIgY3VycmVudCA9IHRoaXMuX2hlYWQubmV4dDtcbiAgICAgICAgdmFyIHByZXZpb3VzID0gdGhpcy5faGVhZDtcblxuICAgICAgICAvLyBBZGQgdGhlIGZpcnN0IGl0ZW1cbiAgICAgICAgaWYgKCFjdXJyZW50KSB7XG4gICAgICAgICAgICBsaXN0ZW5lci5jb25uZWN0KHByZXZpb3VzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEdvIGZyb20gaGlnaGVzdCB0byBsb3dlc3QgcHJpb3JpdHlcbiAgICAgICAgICAgIHdoaWxlIChjdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKGxpc3RlbmVyLnByaW9yaXR5ID4gY3VycmVudC5wcmlvcml0eSkge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lci5jb25uZWN0KHByZXZpb3VzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByZXZpb3VzID0gY3VycmVudDtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBOb3QgeWV0IGNvbm5lY3RlZFxuICAgICAgICAgICAgaWYgKCFsaXN0ZW5lci5wcmV2aW91cykge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyLmNvbm5lY3QocHJldmlvdXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fc3RhcnRJZlBvc3NpYmxlKCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYW55IGhhbmRsZXJzIG1hdGNoaW5nIHRoZSBmdW5jdGlvbiBhbmQgY29udGV4dCBwYXJhbWV0ZXJzLlxuICAgICAqIElmIG5vIGhhbmRsZXJzIGFyZSBsZWZ0IGFmdGVyIHJlbW92aW5nLCB0aGVuIGl0IGNhbmNlbHMgdGhlIGFuaW1hdGlvbiBmcmFtZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uIHRvIGJlIHJlbW92ZWRcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29udGV4dF0gLSBUaGUgbGlzdGVuZXIgY29udGV4dCB0byBiZSByZW1vdmVkXG4gICAgICogQHJldHVybnMge1BJWEkudGlja2VyLlRpY2tlcn0gVGhpcyBpbnN0YW5jZSBvZiBhIHRpY2tlclxuICAgICAqL1xuXG5cbiAgICBUaWNrZXIucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZShmbiwgY29udGV4dCkge1xuICAgICAgICB2YXIgbGlzdGVuZXIgPSB0aGlzLl9oZWFkLm5leHQ7XG5cbiAgICAgICAgd2hpbGUgKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICAvLyBXZSBmb3VuZCBhIG1hdGNoLCBsZXRzIHJlbW92ZSBpdFxuICAgICAgICAgICAgLy8gbm8gYnJlYWsgdG8gZGVsZXRlIGFsbCBwb3NzaWJsZSBtYXRjaGVzXG4gICAgICAgICAgICAvLyBpbmNhc2UgYSBsaXN0ZW5lciB3YXMgYWRkZWQgMisgdGltZXNcbiAgICAgICAgICAgIGlmIChsaXN0ZW5lci5tYXRjaChmbiwgY29udGV4dCkpIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lciA9IGxpc3RlbmVyLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXIgPSBsaXN0ZW5lci5uZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl9oZWFkLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMuX2NhbmNlbElmTmVlZGVkKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU3RhcnRzIHRoZSB0aWNrZXIuIElmIHRoZSB0aWNrZXIgaGFzIGxpc3RlbmVyc1xuICAgICAqIGEgbmV3IGFuaW1hdGlvbiBmcmFtZSBpcyByZXF1ZXN0ZWQgYXQgdGhpcyBwb2ludC5cbiAgICAgKi9cblxuXG4gICAgVGlja2VyLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgICAgICBpZiAoIXRoaXMuc3RhcnRlZCkge1xuICAgICAgICAgICAgdGhpcy5zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX3JlcXVlc3RJZk5lZWRlZCgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFN0b3BzIHRoZSB0aWNrZXIuIElmIHRoZSB0aWNrZXIgaGFzIHJlcXVlc3RlZFxuICAgICAqIGFuIGFuaW1hdGlvbiBmcmFtZSBpdCBpcyBjYW5jZWxlZCBhdCB0aGlzIHBvaW50LlxuICAgICAqL1xuXG5cbiAgICBUaWNrZXIucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgICBpZiAodGhpcy5zdGFydGVkKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2NhbmNlbElmTmVlZGVkKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGVzdHJveSB0aGUgdGlja2VyIGFuZCBkb24ndCB1c2UgYWZ0ZXIgdGhpcy4gQ2FsbGluZ1xuICAgICAqIHRoaXMgbWV0aG9kIHJlbW92ZXMgYWxsIHJlZmVyZW5jZXMgdG8gaW50ZXJuYWwgZXZlbnRzLlxuICAgICAqL1xuXG5cbiAgICBUaWNrZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnN0b3AoKTtcblxuICAgICAgICB2YXIgbGlzdGVuZXIgPSB0aGlzLl9oZWFkLm5leHQ7XG5cbiAgICAgICAgd2hpbGUgKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBsaXN0ZW5lciA9IGxpc3RlbmVyLmRlc3Ryb3kodHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9oZWFkLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5faGVhZCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJzIGFuIHVwZGF0ZS4gQW4gdXBkYXRlIGVudGFpbHMgc2V0dGluZyB0aGVcbiAgICAgKiBjdXJyZW50IHtAbGluayBQSVhJLnRpY2tlci5UaWNrZXIjZWxhcHNlZE1TfSxcbiAgICAgKiB0aGUgY3VycmVudCB7QGxpbmsgUElYSS50aWNrZXIuVGlja2VyI2RlbHRhVGltZX0sXG4gICAgICogaW52b2tpbmcgYWxsIGxpc3RlbmVycyB3aXRoIGN1cnJlbnQgZGVsdGFUaW1lLFxuICAgICAqIGFuZCB0aGVuIGZpbmFsbHkgc2V0dGluZyB7QGxpbmsgUElYSS50aWNrZXIuVGlja2VyI2xhc3RUaW1lfVxuICAgICAqIHdpdGggdGhlIHZhbHVlIG9mIGN1cnJlbnRUaW1lIHRoYXQgd2FzIHByb3ZpZGVkLlxuICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgYmUgY2FsbGVkIGF1dG9tYXRpY2FsbHkgYnkgYW5pbWF0aW9uXG4gICAgICogZnJhbWUgY2FsbGJhY2tzIGlmIHRoZSB0aWNrZXIgaW5zdGFuY2UgaGFzIGJlZW4gc3RhcnRlZFxuICAgICAqIGFuZCBsaXN0ZW5lcnMgYXJlIGFkZGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtjdXJyZW50VGltZT1wZXJmb3JtYW5jZS5ub3coKV0gLSB0aGUgY3VycmVudCB0aW1lIG9mIGV4ZWN1dGlvblxuICAgICAqL1xuXG5cbiAgICBUaWNrZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRUaW1lID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBwZXJmb3JtYW5jZS5ub3coKTtcblxuICAgICAgICB2YXIgZWxhcHNlZE1TID0gdm9pZCAwO1xuXG4gICAgICAgIC8vIElmIHRoZSBkaWZmZXJlbmNlIGluIHRpbWUgaXMgemVybyBvciBuZWdhdGl2ZSwgd2UgaWdub3JlIG1vc3Qgb2YgdGhlIHdvcmsgZG9uZSBoZXJlLlxuICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyB2YWxpZCBkaWZmZXJlbmNlLCB0aGVuIHNob3VsZCBiZSBubyByZWFzb24gdG8gbGV0IGFueW9uZSBrbm93IGFib3V0IGl0LlxuICAgICAgICAvLyBBIHplcm8gZGVsdGEsIGlzIGV4YWN0bHkgdGhhdCwgbm90aGluZyBzaG91bGQgdXBkYXRlLlxuICAgICAgICAvL1xuICAgICAgICAvLyBUaGUgZGlmZmVyZW5jZSBpbiB0aW1lIGNhbiBiZSBuZWdhdGl2ZSwgYW5kIG5vIHRoaXMgZG9lcyBub3QgbWVhbiB0aW1lIHRyYXZlbGluZy5cbiAgICAgICAgLy8gVGhpcyBjYW4gYmUgdGhlIHJlc3VsdCBvZiBhIHJhY2UgY29uZGl0aW9uIGJldHdlZW4gd2hlbiBhbiBhbmltYXRpb24gZnJhbWUgaXMgcmVxdWVzdGVkXG4gICAgICAgIC8vIG9uIHRoZSBjdXJyZW50IEphdmFTY3JpcHQgZW5naW5lIGV2ZW50IGxvb3AsIGFuZCB3aGVuIHRoZSB0aWNrZXIncyBzdGFydCBtZXRob2QgaXMgaW52b2tlZFxuICAgICAgICAvLyAod2hpY2ggaW52b2tlcyB0aGUgaW50ZXJuYWwgX3JlcXVlc3RJZk5lZWRlZCBtZXRob2QpLiBJZiBhIGZyYW1lIGlzIHJlcXVlc3RlZCBiZWZvcmVcbiAgICAgICAgLy8gX3JlcXVlc3RJZk5lZWRlZCBpcyBpbnZva2VkLCB0aGVuIHRoZSBjYWxsYmFjayBmb3IgdGhlIGFuaW1hdGlvbiBmcmFtZSB0aGUgdGlja2VyIHJlcXVlc3RzLFxuICAgICAgICAvLyBjYW4gcmVjZWl2ZSBhIHRpbWUgYXJndW1lbnQgdGhhdCBjYW4gYmUgbGVzcyB0aGFuIHRoZSBsYXN0VGltZSB2YWx1ZSB0aGF0IHdhcyBzZXQgd2l0aGluXG4gICAgICAgIC8vIF9yZXF1ZXN0SWZOZWVkZWQuIFRoaXMgZGlmZmVyZW5jZSBpcyBpbiBtaWNyb3NlY29uZHMsIGJ1dCB0aGlzIGlzIGVub3VnaCB0byBjYXVzZSBwcm9ibGVtcy5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gVGhpcyBjaGVjayBjb3ZlcnMgdGhpcyBicm93c2VyIGVuZ2luZSB0aW1pbmcgaXNzdWUsIGFzIHdlbGwgYXMgaWYgY29uc3VtZXJzIHBhc3MgYW4gaW52YWxpZFxuICAgICAgICAvLyBjdXJyZW50VGltZSB2YWx1ZS4gVGhpcyBtYXkgaGFwcGVuIGlmIGNvbnN1bWVycyBvcHQtb3V0IG9mIHRoZSBhdXRvU3RhcnQsIGFuZCB1cGRhdGUgdGhlbXNlbHZlcy5cblxuICAgICAgICBpZiAoY3VycmVudFRpbWUgPiB0aGlzLmxhc3RUaW1lKSB7XG4gICAgICAgICAgICAvLyBTYXZlIHVuY2FwcGVkIGVsYXBzZWRNUyBmb3IgbWVhc3VyZW1lbnRcbiAgICAgICAgICAgIGVsYXBzZWRNUyA9IHRoaXMuZWxhcHNlZE1TID0gY3VycmVudFRpbWUgLSB0aGlzLmxhc3RUaW1lO1xuXG4gICAgICAgICAgICAvLyBjYXAgdGhlIG1pbGxpc2Vjb25kcyBlbGFwc2VkIHVzZWQgZm9yIGRlbHRhVGltZVxuICAgICAgICAgICAgaWYgKGVsYXBzZWRNUyA+IHRoaXMuX21heEVsYXBzZWRNUykge1xuICAgICAgICAgICAgICAgIGVsYXBzZWRNUyA9IHRoaXMuX21heEVsYXBzZWRNUztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5kZWx0YVRpbWUgPSBlbGFwc2VkTVMgKiBfc2V0dGluZ3MyLmRlZmF1bHQuVEFSR0VUX0ZQTVMgKiB0aGlzLnNwZWVkO1xuXG4gICAgICAgICAgICAvLyBDYWNoZSBhIGxvY2FsIHJlZmVyZW5jZSwgaW4tY2FzZSB0aWNrZXIgaXMgZGVzdHJveWVkXG4gICAgICAgICAgICAvLyBkdXJpbmcgdGhlIGVtaXQsIHdlIGNhbiBzdGlsbCBjaGVjayBmb3IgaGVhZC5uZXh0XG4gICAgICAgICAgICB2YXIgaGVhZCA9IHRoaXMuX2hlYWQ7XG5cbiAgICAgICAgICAgIC8vIEludm9rZSBsaXN0ZW5lcnMgYWRkZWQgdG8gaW50ZXJuYWwgZW1pdHRlclxuICAgICAgICAgICAgdmFyIGxpc3RlbmVyID0gaGVhZC5uZXh0O1xuXG4gICAgICAgICAgICB3aGlsZSAobGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lciA9IGxpc3RlbmVyLmVtaXQodGhpcy5kZWx0YVRpbWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWhlYWQubmV4dCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhbmNlbElmTmVlZGVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRlbHRhVGltZSA9IHRoaXMuZWxhcHNlZE1TID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubGFzdFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZyYW1lcyBwZXIgc2Vjb25kIGF0IHdoaWNoIHRoaXMgdGlja2VyIGlzIHJ1bm5pbmcuXG4gICAgICogVGhlIGRlZmF1bHQgaXMgYXBwcm94aW1hdGVseSA2MCBpbiBtb3N0IG1vZGVybiBicm93c2Vycy5cbiAgICAgKiAqKk5vdGU6KiogVGhpcyBkb2VzIG5vdCBmYWN0b3IgaW4gdGhlIHZhbHVlIG9mXG4gICAgICoge0BsaW5rIFBJWEkudGlja2VyLlRpY2tlciNzcGVlZH0sIHdoaWNoIGlzIHNwZWNpZmljXG4gICAgICogdG8gc2NhbGluZyB7QGxpbmsgUElYSS50aWNrZXIuVGlja2VyI2RlbHRhVGltZX0uXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG5cblxuICAgIF9jcmVhdGVDbGFzcyhUaWNrZXIsIFt7XG4gICAgICAgIGtleTogJ0ZQUycsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIDEwMDAgLyB0aGlzLmVsYXBzZWRNUztcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYW5hZ2VzIHRoZSBtYXhpbXVtIGFtb3VudCBvZiBtaWxsaXNlY29uZHMgYWxsb3dlZCB0b1xuICAgICAgICAgKiBlbGFwc2UgYmV0d2VlbiBpbnZva2luZyB7QGxpbmsgUElYSS50aWNrZXIuVGlja2VyI3VwZGF0ZX0uXG4gICAgICAgICAqIFRoaXMgdmFsdWUgaXMgdXNlZCB0byBjYXAge0BsaW5rIFBJWEkudGlja2VyLlRpY2tlciNkZWx0YVRpbWV9LFxuICAgICAgICAgKiBidXQgZG9lcyBub3QgZWZmZWN0IHRoZSBtZWFzdXJlZCB2YWx1ZSBvZiB7QGxpbmsgUElYSS50aWNrZXIuVGlja2VyI0ZQU30uXG4gICAgICAgICAqIFdoZW4gc2V0dGluZyB0aGlzIHByb3BlcnR5IGl0IGlzIGNsYW1wZWQgdG8gYSB2YWx1ZSBiZXR3ZWVuXG4gICAgICAgICAqIGAwYCBhbmQgYFBJWEkuc2V0dGluZ3MuVEFSR0VUX0ZQTVMgKiAxMDAwYC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAxMFxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnbWluRlBTJyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gMTAwMCAvIHRoaXMuX21heEVsYXBzZWRNUztcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoZnBzKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlcXVpcmUtanNkb2NcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gQ2xhbXA6IDAgdG8gVEFSR0VUX0ZQTVNcbiAgICAgICAgICAgIHZhciBtaW5GUE1TID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgZnBzKSAvIDEwMDAsIF9zZXR0aW5nczIuZGVmYXVsdC5UQVJHRVRfRlBNUyk7XG5cbiAgICAgICAgICAgIHRoaXMuX21heEVsYXBzZWRNUyA9IDEgLyBtaW5GUE1TO1xuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFRpY2tlcjtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gVGlja2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGlja2VyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vKipcbiAqIEludGVybmFsIGNsYXNzIGZvciBoYW5kbGluZyB0aGUgcHJpb3JpdHkgc29ydGluZyBvZiB0aWNrZXIgaGFuZGxlcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIFBJWEkudGlja2VyXG4gKi9cbnZhciBUaWNrZXJMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSBUaGUgbGlzdGVuZXIgZnVuY3Rpb24gdG8gYmUgYWRkZWQgZm9yIG9uZSB1cGRhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29udGV4dD1udWxsXSAtIFRoZSBsaXN0ZW5lciBjb250ZXh0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwcmlvcml0eT0wXSAtIFRoZSBwcmlvcml0eSBmb3IgZW1pdHRpbmdcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvbmNlPWZhbHNlXSAtIElmIHRoZSBoYW5kbGVyIHNob3VsZCBmaXJlIG9uY2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBUaWNrZXJMaXN0ZW5lcihmbikge1xuICAgICAgICB2YXIgY29udGV4dCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbnVsbDtcbiAgICAgICAgdmFyIHByaW9yaXR5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAwO1xuICAgICAgICB2YXIgb25jZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogZmFsc2U7XG5cbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRpY2tlckxpc3RlbmVyKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGhhbmRsZXIgZnVuY3Rpb24gdG8gZXhlY3V0ZS5cbiAgICAgICAgICogQG1lbWJlciB7RnVuY3Rpb259XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZuID0gZm47XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjYWxsaW5nIHRvIGV4ZWN1dGUuXG4gICAgICAgICAqIEBtZW1iZXIge0Z1bmN0aW9ufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGN1cnJlbnQgcHJpb3JpdHkuXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucHJpb3JpdHkgPSBwcmlvcml0eTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdGhpcyBzaG91bGQgb25seSBleGVjdXRlIG9uY2UuXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uY2UgPSBvbmNlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbmV4dCBpdGVtIGluIGNoYWluLlxuICAgICAgICAgKiBAbWVtYmVyIHtUaWNrZXJMaXN0ZW5lcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubmV4dCA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBwcmV2aW91cyBpdGVtIGluIGNoYWluLlxuICAgICAgICAgKiBAbWVtYmVyIHtUaWNrZXJMaXN0ZW5lcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucHJldmlvdXMgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBgdHJ1ZWAgaWYgdGhpcyBsaXN0ZW5lciBoYXMgYmVlbiBkZXN0cm95ZWQgYWxyZWFkeS5cbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2Rlc3Ryb3llZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNpbXBsZSBjb21wYXJlIGZ1bmN0aW9uIHRvIGZpZ3VyZSBvdXQgaWYgYSBmdW5jdGlvbiBhbmQgY29udGV4dCBtYXRjaC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uIHRvIGJlIGFkZGVkIGZvciBvbmUgdXBkYXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29udGV4dCAtIFRoZSBsaXN0ZW5lciBjb250ZXh0XG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSBsaXN0ZW5lciBtYXRjaCB0aGUgYXJndW1lbnRzXG4gICAgICovXG5cblxuICAgIFRpY2tlckxpc3RlbmVyLnByb3RvdHlwZS5tYXRjaCA9IGZ1bmN0aW9uIG1hdGNoKGZuLCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnRleHQgPSBjb250ZXh0IHx8IG51bGw7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZm4gPT09IGZuICYmIHRoaXMuY29udGV4dCA9PT0gY29udGV4dDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRW1pdCBieSBjYWxsaW5nIHRoZSBjdXJyZW50IGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZWx0YVRpbWUgLSB0aW1lIHNpbmNlIHRoZSBsYXN0IGVtaXQuXG4gICAgICogQHJldHVybiB7VGlja2VyTGlzdGVuZXJ9IE5leHQgdGlja2VyXG4gICAgICovXG5cblxuICAgIFRpY2tlckxpc3RlbmVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdChkZWx0YVRpbWUpIHtcbiAgICAgICAgaWYgKHRoaXMuZm4pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZuLmNhbGwodGhpcy5jb250ZXh0LCBkZWx0YVRpbWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZuKGRlbHRhVGltZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVkaXJlY3QgPSB0aGlzLm5leHQ7XG5cbiAgICAgICAgaWYgKHRoaXMub25jZSkge1xuICAgICAgICAgICAgdGhpcy5kZXN0cm95KHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU29mdC1kZXN0cm95aW5nIHNob3VsZCByZW1vdmVcbiAgICAgICAgLy8gdGhlIG5leHQgcmVmZXJlbmNlXG4gICAgICAgIGlmICh0aGlzLl9kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVkaXJlY3Q7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvbm5lY3QgdG8gdGhlIGxpc3QuXG4gICAgICogQHBhcmFtIHtUaWNrZXJMaXN0ZW5lcn0gcHJldmlvdXMgLSBJbnB1dCBub2RlLCBwcmV2aW91cyBsaXN0ZW5lclxuICAgICAqL1xuXG5cbiAgICBUaWNrZXJMaXN0ZW5lci5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uIGNvbm5lY3QocHJldmlvdXMpIHtcbiAgICAgICAgdGhpcy5wcmV2aW91cyA9IHByZXZpb3VzO1xuICAgICAgICBpZiAocHJldmlvdXMubmV4dCkge1xuICAgICAgICAgICAgcHJldmlvdXMubmV4dC5wcmV2aW91cyA9IHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5uZXh0ID0gcHJldmlvdXMubmV4dDtcbiAgICAgICAgcHJldmlvdXMubmV4dCA9IHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERlc3Ryb3kgYW5kIGRvbid0IHVzZSBhZnRlciB0aGlzLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2hhcmQgPSBmYWxzZV0gYHRydWVgIHRvIHJlbW92ZSB0aGUgYG5leHRgIHJlZmVyZW5jZSwgdGhpc1xuICAgICAqICAgICAgICBpcyBjb25zaWRlcmVkIGEgaGFyZCBkZXN0cm95LiBTb2Z0IGRlc3Ryb3kgbWFpbnRhaW5zIHRoZSBuZXh0IHJlZmVyZW5jZS5cbiAgICAgKiBAcmV0dXJuIHtUaWNrZXJMaXN0ZW5lcn0gVGhlIGxpc3RlbmVyIHRvIHJlZGlyZWN0IHdoaWxlIGVtaXR0aW5nIG9yIHJlbW92aW5nLlxuICAgICAqL1xuXG5cbiAgICBUaWNrZXJMaXN0ZW5lci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIHZhciBoYXJkID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcblxuICAgICAgICB0aGlzLl9kZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmZuID0gbnVsbDtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gbnVsbDtcblxuICAgICAgICAvLyBEaXNjb25uZWN0LCBob29rIHVwIG5leHQgYW5kIHByZXZpb3VzXG4gICAgICAgIGlmICh0aGlzLnByZXZpb3VzKSB7XG4gICAgICAgICAgICB0aGlzLnByZXZpb3VzLm5leHQgPSB0aGlzLm5leHQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQucHJldmlvdXMgPSB0aGlzLnByZXZpb3VzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVkaXJlY3QgdG8gdGhlIG5leHQgaXRlbVxuICAgICAgICB2YXIgcmVkaXJlY3QgPSB0aGlzLm5leHQ7XG5cbiAgICAgICAgLy8gUmVtb3ZlIHJlZmVyZW5jZXNcbiAgICAgICAgdGhpcy5uZXh0ID0gaGFyZCA/IG51bGwgOiByZWRpcmVjdDtcbiAgICAgICAgdGhpcy5wcmV2aW91cyA9IG51bGw7XG5cbiAgICAgICAgcmV0dXJuIHJlZGlyZWN0O1xuICAgIH07XG5cbiAgICByZXR1cm4gVGlja2VyTGlzdGVuZXI7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFRpY2tlckxpc3RlbmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGlja2VyTGlzdGVuZXIuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5UaWNrZXIgPSBleHBvcnRzLnNoYXJlZCA9IHVuZGVmaW5lZDtcblxudmFyIF9UaWNrZXIgPSByZXF1aXJlKCcuL1RpY2tlcicpO1xuXG52YXIgX1RpY2tlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9UaWNrZXIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKipcbiAqIFRoZSBzaGFyZWQgdGlja2VyIGluc3RhbmNlIHVzZWQgYnkge0BsaW5rIFBJWEkuZXh0cmFzLkFuaW1hdGVkU3ByaXRlfS5cbiAqIGFuZCBieSB7QGxpbmsgUElYSS5pbnRlcmFjdGlvbi5JbnRlcmFjdGlvbk1hbmFnZXJ9LlxuICogVGhlIHByb3BlcnR5IHtAbGluayBQSVhJLnRpY2tlci5UaWNrZXIjYXV0b1N0YXJ0fSBpcyBzZXQgdG8gYHRydWVgXG4gKiBmb3IgdGhpcyBpbnN0YW5jZS4gUGxlYXNlIGZvbGxvdyB0aGUgZXhhbXBsZXMgZm9yIHVzYWdlLCBpbmNsdWRpbmdcbiAqIGhvdyB0byBvcHQtb3V0IG9mIGF1dG8tc3RhcnRpbmcgdGhlIHNoYXJlZCB0aWNrZXIuXG4gKlxuICogQGV4YW1wbGVcbiAqIGxldCB0aWNrZXIgPSBQSVhJLnRpY2tlci5zaGFyZWQ7XG4gKiAvLyBTZXQgdGhpcyB0byBwcmV2ZW50IHN0YXJ0aW5nIHRoaXMgdGlja2VyIHdoZW4gbGlzdGVuZXJzIGFyZSBhZGRlZC5cbiAqIC8vIEJ5IGRlZmF1bHQgdGhpcyBpcyB0cnVlIG9ubHkgZm9yIHRoZSBQSVhJLnRpY2tlci5zaGFyZWQgaW5zdGFuY2UuXG4gKiB0aWNrZXIuYXV0b1N0YXJ0ID0gZmFsc2U7XG4gKiAvLyBGWUksIGNhbGwgdGhpcyB0byBlbnN1cmUgdGhlIHRpY2tlciBpcyBzdG9wcGVkLiBJdCBzaG91bGQgYmUgc3RvcHBlZFxuICogLy8gaWYgeW91IGhhdmUgbm90IGF0dGVtcHRlZCB0byByZW5kZXIgYW55dGhpbmcgeWV0LlxuICogdGlja2VyLnN0b3AoKTtcbiAqIC8vIENhbGwgdGhpcyB3aGVuIHlvdSBhcmUgcmVhZHkgZm9yIGEgcnVubmluZyBzaGFyZWQgdGlja2VyLlxuICogdGlja2VyLnN0YXJ0KCk7XG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFlvdSBtYXkgdXNlIHRoZSBzaGFyZWQgdGlja2VyIHRvIHJlbmRlci4uLlxuICogbGV0IHJlbmRlcmVyID0gUElYSS5hdXRvRGV0ZWN0UmVuZGVyZXIoODAwLCA2MDApO1xuICogbGV0IHN0YWdlID0gbmV3IFBJWEkuQ29udGFpbmVyKCk7XG4gKiBsZXQgaW50ZXJhY3Rpb25NYW5hZ2VyID0gUElYSS5pbnRlcmFjdGlvbi5JbnRlcmFjdGlvbk1hbmFnZXIocmVuZGVyZXIpO1xuICogZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChyZW5kZXJlci52aWV3KTtcbiAqIHRpY2tlci5hZGQoZnVuY3Rpb24gKHRpbWUpIHtcbiAqICAgICByZW5kZXJlci5yZW5kZXIoc3RhZ2UpO1xuICogfSk7XG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIE9yIHlvdSBjYW4ganVzdCB1cGRhdGUgaXQgbWFudWFsbHkuXG4gKiB0aWNrZXIuYXV0b1N0YXJ0ID0gZmFsc2U7XG4gKiB0aWNrZXIuc3RvcCgpO1xuICogZnVuY3Rpb24gYW5pbWF0ZSh0aW1lKSB7XG4gKiAgICAgdGlja2VyLnVwZGF0ZSh0aW1lKTtcbiAqICAgICByZW5kZXJlci5yZW5kZXIoc3RhZ2UpO1xuICogICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRlKTtcbiAqIH1cbiAqIGFuaW1hdGUocGVyZm9ybWFuY2Uubm93KCkpO1xuICpcbiAqIEB0eXBlIHtQSVhJLnRpY2tlci5UaWNrZXJ9XG4gKiBAbWVtYmVyb2YgUElYSS50aWNrZXJcbiAqL1xudmFyIHNoYXJlZCA9IG5ldyBfVGlja2VyMi5kZWZhdWx0KCk7XG5cbnNoYXJlZC5hdXRvU3RhcnQgPSB0cnVlO1xuc2hhcmVkLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIHByb3RlY3QgZGVzdHJveWluZyBzaGFyZWQgdGlja2VyXG4gIC8vIHRoaXMgaXMgdXNlZCBieSBvdGhlciBpbnRlcm5hbCBzeXN0ZW1zXG4gIC8vIGxpa2UgQW5pbWF0ZWRTcHJpdGUgYW5kIEludGVyYWN0aW9uTWFuYWdlclxufTtcblxuLyoqXG4gKiBUaGlzIG5hbWVzcGFjZSBjb250YWlucyBhbiBBUEkgZm9yIGludGVyYWN0aW5nIHdpdGggUElYSSdzIGludGVybmFsIGdsb2JhbCB1cGRhdGUgbG9vcC5cbiAqXG4gKiBUaGlzIHRpY2tlciBpcyB1c2VkIGZvciByZW5kZXJpbmcsIHtAbGluayBQSVhJLmV4dHJhcy5BbmltYXRlZFNwcml0ZSBBbmltYXRlZFNwcml0ZX0sXG4gKiB7QGxpbmsgUElYSS5pbnRlcmFjdGlvbi5JbnRlcmFjdGlvbk1hbmFnZXIgSW50ZXJhY3Rpb25NYW5hZ2VyfSBhbmQgbWFueSBvdGhlciB0aW1lLWJhc2VkIFBJWEkgc3lzdGVtcy5cbiAqIEBleGFtcGxlXG4gKiBjb25zdCB0aWNrZXIgPSBuZXcgUElYSS50aWNrZXIuVGlja2VyKCk7XG4gKiB0aWNrZXIuc3RvcCgpO1xuICogdGlja2VyLmFkZCgoZGVsdGFUaW1lKSA9PiB7XG4gKiAgIC8vIGRvIHNvbWV0aGluZyBldmVyeSBmcmFtZVxuICogfSk7XG4gKiB0aWNrZXIuc3RhcnQoKTtcbiAqIEBuYW1lc3BhY2UgUElYSS50aWNrZXJcbiAqL1xuZXhwb3J0cy5zaGFyZWQgPSBzaGFyZWQ7XG5leHBvcnRzLlRpY2tlciA9IF9UaWNrZXIyLmRlZmF1bHQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuZGVmYXVsdCA9IGNhblVwbG9hZFNhbWVCdWZmZXI7XG5mdW5jdGlvbiBjYW5VcGxvYWRTYW1lQnVmZmVyKCkge1xuXHQvLyBVcGxvYWRpbmcgdGhlIHNhbWUgYnVmZmVyIG11bHRpcGxlIHRpbWVzIGluIGEgc2luZ2xlIGZyYW1lIGNhbiBjYXVzZSBwZXJmIGlzc3Vlcy5cblx0Ly8gQXBwYXJlbnQgb24gSU9TIHNvIG9ubHkgY2hlY2sgZm9yIHRoYXQgYXQgdGhlIG1vbWVudFxuXHQvLyB0aGlzIGNoZWNrIG1heSBiZWNvbWUgbW9yZSBjb21wbGV4IGlmIHRoaXMgaXNzdWUgcG9wcyB1cCBlbHNld2hlcmUuXG5cdHZhciBpb3MgPSAhIW5hdmlnYXRvci5wbGF0Zm9ybSAmJiAvaVBhZHxpUGhvbmV8aVBvZC8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pO1xuXG5cdHJldHVybiAhaW9zO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2FuVXBsb2FkU2FtZUJ1ZmZlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuZGVmYXVsdCA9IGNyZWF0ZUluZGljZXNGb3JRdWFkcztcbi8qKlxuICogR2VuZXJpYyBNYXNrIFN0YWNrIGRhdGEgc3RydWN0dXJlXG4gKlxuICogQG1lbWJlcm9mIFBJWElcbiAqIEBmdW5jdGlvbiBjcmVhdGVJbmRpY2VzRm9yUXVhZHNcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gc2l6ZSAtIE51bWJlciBvZiBxdWFkc1xuICogQHJldHVybiB7VWludDE2QXJyYXl9IGluZGljZXNcbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5kaWNlc0ZvclF1YWRzKHNpemUpIHtcbiAgICAvLyB0aGUgdG90YWwgbnVtYmVyIG9mIGluZGljZXMgaW4gb3VyIGFycmF5LCB0aGVyZSBhcmUgNiBwb2ludHMgcGVyIHF1YWQuXG5cbiAgICB2YXIgdG90YWxJbmRpY2VzID0gc2l6ZSAqIDY7XG5cbiAgICB2YXIgaW5kaWNlcyA9IG5ldyBVaW50MTZBcnJheSh0b3RhbEluZGljZXMpO1xuXG4gICAgLy8gZmlsbCB0aGUgaW5kaWNlcyB3aXRoIHRoZSBxdWFkcyB0byBkcmF3XG4gICAgZm9yICh2YXIgaSA9IDAsIGogPSAwOyBpIDwgdG90YWxJbmRpY2VzOyBpICs9IDYsIGogKz0gNCkge1xuICAgICAgICBpbmRpY2VzW2kgKyAwXSA9IGogKyAwO1xuICAgICAgICBpbmRpY2VzW2kgKyAxXSA9IGogKyAxO1xuICAgICAgICBpbmRpY2VzW2kgKyAyXSA9IGogKyAyO1xuICAgICAgICBpbmRpY2VzW2kgKyAzXSA9IGogKyAwO1xuICAgICAgICBpbmRpY2VzW2kgKyA0XSA9IGogKyAyO1xuICAgICAgICBpbmRpY2VzW2kgKyA1XSA9IGogKyAzO1xuICAgIH1cblxuICAgIHJldHVybiBpbmRpY2VzO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3JlYXRlSW5kaWNlc0ZvclF1YWRzLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRldGVybWluZUNyb3NzT3JpZ2luO1xuXG52YXIgX3VybDIgPSByZXF1aXJlKCd1cmwnKTtcblxudmFyIF91cmwzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdXJsMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciB0ZW1wQW5jaG9yID0gdm9pZCAwO1xuXG4vKipcbiAqIFNldHMgdGhlIGBjcm9zc09yaWdpbmAgcHJvcGVydHkgZm9yIHRoaXMgcmVzb3VyY2UgYmFzZWQgb24gaWYgdGhlIHVybFxuICogZm9yIHRoaXMgcmVzb3VyY2UgaXMgY3Jvc3Mtb3JpZ2luLiBJZiBjcm9zc09yaWdpbiB3YXMgbWFudWFsbHkgc2V0LCB0aGlzXG4gKiBmdW5jdGlvbiBkb2VzIG5vdGhpbmcuXG4gKiBOaXBwZWQgZnJvbSB0aGUgcmVzb3VyY2UgbG9hZGVyIVxuICpcbiAqIEBpZ25vcmVcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgLSBUaGUgdXJsIHRvIHRlc3QuXG4gKiBAcGFyYW0ge29iamVjdH0gW2xvYz13aW5kb3cubG9jYXRpb25dIC0gVGhlIGxvY2F0aW9uIG9iamVjdCB0byB0ZXN0IGFnYWluc3QuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBjcm9zc09yaWdpbiB2YWx1ZSB0byB1c2UgKG9yIGVtcHR5IHN0cmluZyBmb3Igbm9uZSkuXG4gKi9cbmZ1bmN0aW9uIGRldGVybWluZUNyb3NzT3JpZ2luKHVybCkge1xuICAgIHZhciBsb2MgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHdpbmRvdy5sb2NhdGlvbjtcblxuICAgIC8vIGRhdGE6IGFuZCBqYXZhc2NyaXB0OiB1cmxzIGFyZSBjb25zaWRlcmVkIHNhbWUtb3JpZ2luXG4gICAgaWYgKHVybC5pbmRleE9mKCdkYXRhOicpID09PSAwKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICAvLyBkZWZhdWx0IGlzIHdpbmRvdy5sb2NhdGlvblxuICAgIGxvYyA9IGxvYyB8fCB3aW5kb3cubG9jYXRpb247XG5cbiAgICBpZiAoIXRlbXBBbmNob3IpIHtcbiAgICAgICAgdGVtcEFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICB9XG5cbiAgICAvLyBsZXQgdGhlIGJyb3dzZXIgZGV0ZXJtaW5lIHRoZSBmdWxsIGhyZWYgZm9yIHRoZSB1cmwgb2YgdGhpcyByZXNvdXJjZSBhbmQgdGhlblxuICAgIC8vIHBhcnNlIHdpdGggdGhlIG5vZGUgdXJsIGxpYiwgd2UgY2FuJ3QgdXNlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBhbmNob3IgZWxlbWVudFxuICAgIC8vIGJlY2F1c2UgdGhleSBkb24ndCB3b3JrIGluIElFOSA6KFxuICAgIHRlbXBBbmNob3IuaHJlZiA9IHVybDtcbiAgICB1cmwgPSBfdXJsMy5kZWZhdWx0LnBhcnNlKHRlbXBBbmNob3IuaHJlZik7XG5cbiAgICB2YXIgc2FtZVBvcnQgPSAhdXJsLnBvcnQgJiYgbG9jLnBvcnQgPT09ICcnIHx8IHVybC5wb3J0ID09PSBsb2MucG9ydDtcblxuICAgIC8vIGlmIGNyb3NzIG9yaWdpblxuICAgIGlmICh1cmwuaG9zdG5hbWUgIT09IGxvYy5ob3N0bmFtZSB8fCAhc2FtZVBvcnQgfHwgdXJsLnByb3RvY29sICE9PSBsb2MucHJvdG9jb2wpIHtcbiAgICAgICAgcmV0dXJuICdhbm9ueW1vdXMnO1xuICAgIH1cblxuICAgIHJldHVybiAnJztcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRldGVybWluZUNyb3NzT3JpZ2luLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMucHJlbXVsdGlwbHlCbGVuZE1vZGUgPSBleHBvcnRzLkJhc2VUZXh0dXJlQ2FjaGUgPSBleHBvcnRzLlRleHR1cmVDYWNoZSA9IGV4cG9ydHMuZWFyY3V0ID0gZXhwb3J0cy5taXhpbnMgPSBleHBvcnRzLnBsdWdpblRhcmdldCA9IGV4cG9ydHMuRXZlbnRFbWl0dGVyID0gZXhwb3J0cy5yZW1vdmVJdGVtcyA9IGV4cG9ydHMuaXNNb2JpbGUgPSB1bmRlZmluZWQ7XG5leHBvcnRzLnVpZCA9IHVpZDtcbmV4cG9ydHMuaGV4MnJnYiA9IGhleDJyZ2I7XG5leHBvcnRzLmhleDJzdHJpbmcgPSBoZXgyc3RyaW5nO1xuZXhwb3J0cy5yZ2IyaGV4ID0gcmdiMmhleDtcbmV4cG9ydHMuZ2V0UmVzb2x1dGlvbk9mVXJsID0gZ2V0UmVzb2x1dGlvbk9mVXJsO1xuZXhwb3J0cy5kZWNvbXBvc2VEYXRhVXJpID0gZGVjb21wb3NlRGF0YVVyaTtcbmV4cG9ydHMuZ2V0VXJsRmlsZUV4dGVuc2lvbiA9IGdldFVybEZpbGVFeHRlbnNpb247XG5leHBvcnRzLmdldFN2Z1NpemUgPSBnZXRTdmdTaXplO1xuZXhwb3J0cy5za2lwSGVsbG8gPSBza2lwSGVsbG87XG5leHBvcnRzLnNheUhlbGxvID0gc2F5SGVsbG87XG5leHBvcnRzLmlzV2ViR0xTdXBwb3J0ZWQgPSBpc1dlYkdMU3VwcG9ydGVkO1xuZXhwb3J0cy5zaWduID0gc2lnbjtcbmV4cG9ydHMuZGVzdHJveVRleHR1cmVDYWNoZSA9IGRlc3Ryb3lUZXh0dXJlQ2FjaGU7XG5leHBvcnRzLmNsZWFyVGV4dHVyZUNhY2hlID0gY2xlYXJUZXh0dXJlQ2FjaGU7XG5leHBvcnRzLmNvcnJlY3RCbGVuZE1vZGUgPSBjb3JyZWN0QmxlbmRNb2RlO1xuZXhwb3J0cy5wcmVtdWx0aXBseVRpbnQgPSBwcmVtdWx0aXBseVRpbnQ7XG5leHBvcnRzLnByZW11bHRpcGx5UmdiYSA9IHByZW11bHRpcGx5UmdiYTtcbmV4cG9ydHMucHJlbXVsdGlwbHlUaW50VG9SZ2JhID0gcHJlbXVsdGlwbHlUaW50VG9SZ2JhO1xuXG52YXIgX2NvbnN0ID0gcmVxdWlyZSgnLi4vY29uc3QnKTtcblxudmFyIF9zZXR0aW5ncyA9IHJlcXVpcmUoJy4uL3NldHRpbmdzJyk7XG5cbnZhciBfc2V0dGluZ3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc2V0dGluZ3MpO1xuXG52YXIgX2V2ZW50ZW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50ZW1pdHRlcjMnKTtcblxudmFyIF9ldmVudGVtaXR0ZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZXZlbnRlbWl0dGVyKTtcblxudmFyIF9wbHVnaW5UYXJnZXQgPSByZXF1aXJlKCcuL3BsdWdpblRhcmdldCcpO1xuXG52YXIgX3BsdWdpblRhcmdldDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wbHVnaW5UYXJnZXQpO1xuXG52YXIgX21peGluID0gcmVxdWlyZSgnLi9taXhpbicpO1xuXG52YXIgbWl4aW5zID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX21peGluKTtcblxudmFyIF9pc21vYmlsZWpzID0gcmVxdWlyZSgnaXNtb2JpbGVqcycpO1xuXG52YXIgaXNNb2JpbGUgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfaXNtb2JpbGVqcyk7XG5cbnZhciBfcmVtb3ZlQXJyYXlJdGVtcyA9IHJlcXVpcmUoJ3JlbW92ZS1hcnJheS1pdGVtcycpO1xuXG52YXIgX3JlbW92ZUFycmF5SXRlbXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVtb3ZlQXJyYXlJdGVtcyk7XG5cbnZhciBfbWFwUHJlbXVsdGlwbGllZEJsZW5kTW9kZXMgPSByZXF1aXJlKCcuL21hcFByZW11bHRpcGxpZWRCbGVuZE1vZGVzJyk7XG5cbnZhciBfbWFwUHJlbXVsdGlwbGllZEJsZW5kTW9kZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbWFwUHJlbXVsdGlwbGllZEJsZW5kTW9kZXMpO1xuXG52YXIgX2VhcmN1dCA9IHJlcXVpcmUoJ2VhcmN1dCcpO1xuXG52YXIgX2VhcmN1dDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9lYXJjdXQpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgbmV4dFVpZCA9IDA7XG52YXIgc2FpZEhlbGxvID0gZmFsc2U7XG5cbi8qKlxuICogR2VuZXJhbGl6ZWQgY29udmVuaWVuY2UgdXRpbGl0aWVzIGZvciBQSVhJLlxuICogQGV4YW1wbGVcbiAqIC8vIEV4dGVuZCBQSVhJJ3MgaW50ZXJuYWwgRXZlbnQgRW1pdHRlci5cbiAqIGNsYXNzIE15RW1pdHRlciBleHRlbmRzIFBJWEkudXRpbHMuRXZlbnRFbWl0dGVyIHtcbiAqICAgY29uc3RydWN0b3IoKSB7XG4gKiAgICAgIHN1cGVyKCk7XG4gKiAgICAgIGNvbnNvbGUubG9nKFwiRW1pdHRlciBjcmVhdGVkIVwiKTtcbiAqICAgfVxuICogfVxuICpcbiAqIC8vIEdldCBpbmZvIG9uIGN1cnJlbnQgZGV2aWNlXG4gKiBjb25zb2xlLmxvZyhQSVhJLnV0aWxzLmlzTW9iaWxlKTtcbiAqXG4gKiAvLyBDb252ZXJ0IGhleCBjb2xvciB0byBzdHJpbmdcbiAqIGNvbnNvbGUubG9nKFBJWEkudXRpbHMuaGV4MnN0cmluZygweGZmMDBmZikpOyAvLyByZXR1cm5zOiBcIiNmZjAwZmZcIlxuICogQG5hbWVzcGFjZSBQSVhJLnV0aWxzXG4gKi9cbmV4cG9ydHMuaXNNb2JpbGUgPSBpc01vYmlsZTtcbmV4cG9ydHMucmVtb3ZlSXRlbXMgPSBfcmVtb3ZlQXJyYXlJdGVtczIuZGVmYXVsdDtcbmV4cG9ydHMuRXZlbnRFbWl0dGVyID0gX2V2ZW50ZW1pdHRlcjIuZGVmYXVsdDtcbmV4cG9ydHMucGx1Z2luVGFyZ2V0ID0gX3BsdWdpblRhcmdldDIuZGVmYXVsdDtcbmV4cG9ydHMubWl4aW5zID0gbWl4aW5zO1xuZXhwb3J0cy5lYXJjdXQgPSBfZWFyY3V0Mi5kZWZhdWx0O1xuXG4vKipcbiAqIEdldHMgdGhlIG5leHQgdW5pcXVlIGlkZW50aWZpZXJcbiAqXG4gKiBAbWVtYmVyb2YgUElYSS51dGlsc1xuICogQGZ1bmN0aW9uIHVpZFxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbmV4dCB1bmlxdWUgaWRlbnRpZmllciB0byB1c2UuXG4gKi9cblxuZnVuY3Rpb24gdWlkKCkge1xuICAgIHJldHVybiArK25leHRVaWQ7XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBoZXggY29sb3IgbnVtYmVyIHRvIGFuIFtSLCBHLCBCXSBhcnJheVxuICpcbiAqIEBtZW1iZXJvZiBQSVhJLnV0aWxzXG4gKiBAZnVuY3Rpb24gaGV4MnJnYlxuICogQHBhcmFtIHtudW1iZXJ9IGhleCAtIFRoZSBudW1iZXIgdG8gY29udmVydFxuICogQHBhcmFtICB7bnVtYmVyW119IFtvdXQ9W11dIElmIHN1cHBsaWVkLCB0aGlzIGFycmF5IHdpbGwgYmUgdXNlZCByYXRoZXIgdGhhbiByZXR1cm5pbmcgYSBuZXcgb25lXG4gKiBAcmV0dXJuIHtudW1iZXJbXX0gQW4gYXJyYXkgcmVwcmVzZW50aW5nIHRoZSBbUiwgRywgQl0gb2YgdGhlIGNvbG9yLlxuICovXG5mdW5jdGlvbiBoZXgycmdiKGhleCwgb3V0KSB7XG4gICAgb3V0ID0gb3V0IHx8IFtdO1xuXG4gICAgb3V0WzBdID0gKGhleCA+PiAxNiAmIDB4RkYpIC8gMjU1O1xuICAgIG91dFsxXSA9IChoZXggPj4gOCAmIDB4RkYpIC8gMjU1O1xuICAgIG91dFsyXSA9IChoZXggJiAweEZGKSAvIDI1NTtcblxuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBoZXggY29sb3IgbnVtYmVyIHRvIGEgc3RyaW5nLlxuICpcbiAqIEBtZW1iZXJvZiBQSVhJLnV0aWxzXG4gKiBAZnVuY3Rpb24gaGV4MnN0cmluZ1xuICogQHBhcmFtIHtudW1iZXJ9IGhleCAtIE51bWJlciBpbiBoZXhcbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHN0cmluZyBjb2xvci5cbiAqL1xuZnVuY3Rpb24gaGV4MnN0cmluZyhoZXgpIHtcbiAgICBoZXggPSBoZXgudG9TdHJpbmcoMTYpO1xuICAgIGhleCA9ICcwMDAwMDAnLnN1YnN0cigwLCA2IC0gaGV4Lmxlbmd0aCkgKyBoZXg7XG5cbiAgICByZXR1cm4gJyMnICsgaGV4O1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgY29sb3IgYXMgYW4gW1IsIEcsIEJdIGFycmF5IHRvIGEgaGV4IG51bWJlclxuICpcbiAqIEBtZW1iZXJvZiBQSVhJLnV0aWxzXG4gKiBAZnVuY3Rpb24gcmdiMmhleFxuICogQHBhcmFtIHtudW1iZXJbXX0gcmdiIC0gcmdiIGFycmF5XG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBjb2xvciBudW1iZXJcbiAqL1xuZnVuY3Rpb24gcmdiMmhleChyZ2IpIHtcbiAgICByZXR1cm4gKHJnYlswXSAqIDI1NSA8PCAxNikgKyAocmdiWzFdICogMjU1IDw8IDgpICsgKHJnYlsyXSAqIDI1NSB8IDApO1xufVxuXG4vKipcbiAqIGdldCB0aGUgcmVzb2x1dGlvbiAvIGRldmljZSBwaXhlbCByYXRpbyBvZiBhbiBhc3NldCBieSBsb29raW5nIGZvciB0aGUgcHJlZml4XG4gKiB1c2VkIGJ5IHNwcml0ZXNoZWV0cyBhbmQgaW1hZ2UgdXJsc1xuICpcbiAqIEBtZW1iZXJvZiBQSVhJLnV0aWxzXG4gKiBAZnVuY3Rpb24gZ2V0UmVzb2x1dGlvbk9mVXJsXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIC0gdGhlIGltYWdlIHBhdGhcbiAqIEBwYXJhbSB7bnVtYmVyfSBbZGVmYXVsdFZhbHVlPTFdIC0gdGhlIGRlZmF1bHRWYWx1ZSBpZiBubyBmaWxlbmFtZSBwcmVmaXggaXMgc2V0LlxuICogQHJldHVybiB7bnVtYmVyfSByZXNvbHV0aW9uIC8gZGV2aWNlIHBpeGVsIHJhdGlvIG9mIGFuIGFzc2V0XG4gKi9cbmZ1bmN0aW9uIGdldFJlc29sdXRpb25PZlVybCh1cmwsIGRlZmF1bHRWYWx1ZSkge1xuICAgIHZhciByZXNvbHV0aW9uID0gX3NldHRpbmdzMi5kZWZhdWx0LlJFVElOQV9QUkVGSVguZXhlYyh1cmwpO1xuXG4gICAgaWYgKHJlc29sdXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQocmVzb2x1dGlvblsxXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkID8gZGVmYXVsdFZhbHVlIDogMTtcbn1cblxuLyoqXG4gKiBUeXBlZGVmIGZvciBkZWNvbXBvc2VEYXRhVXJpIHJldHVybiBvYmplY3QuXG4gKlxuICogQHR5cGVkZWYge29iamVjdH0gUElYSS51dGlsc35EZWNvbXBvc2VkRGF0YVVyaVxuICogQHByb3BlcnR5IHttZWRpYVR5cGV9IE1lZGlhIHR5cGUsIGVnLiBgaW1hZ2VgXG4gKiBAcHJvcGVydHkge3N1YlR5cGV9IFN1YiB0eXBlLCBlZy4gYHBuZ2BcbiAqIEBwcm9wZXJ0eSB7ZW5jb2Rpbmd9IERhdGEgZW5jb2RpbmcsIGVnLiBgYmFzZTY0YFxuICogQHByb3BlcnR5IHtkYXRhfSBUaGUgYWN0dWFsIGRhdGFcbiAqL1xuXG4vKipcbiAqIFNwbGl0IGEgZGF0YSBVUkkgaW50byBjb21wb25lbnRzLiBSZXR1cm5zIHVuZGVmaW5lZCBpZlxuICogcGFyYW1ldGVyIGBkYXRhVXJpYCBpcyBub3QgYSB2YWxpZCBkYXRhIFVSSS5cbiAqXG4gKiBAbWVtYmVyb2YgUElYSS51dGlsc1xuICogQGZ1bmN0aW9uIGRlY29tcG9zZURhdGFVcmlcbiAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhVXJpIC0gdGhlIGRhdGEgVVJJIHRvIGNoZWNrXG4gKiBAcmV0dXJuIHtQSVhJLnV0aWxzfkRlY29tcG9zZWREYXRhVXJpfHVuZGVmaW5lZH0gVGhlIGRlY29tcG9zZWQgZGF0YSB1cmkgb3IgdW5kZWZpbmVkXG4gKi9cbmZ1bmN0aW9uIGRlY29tcG9zZURhdGFVcmkoZGF0YVVyaSkge1xuICAgIHZhciBkYXRhVXJpTWF0Y2ggPSBfY29uc3QuREFUQV9VUkkuZXhlYyhkYXRhVXJpKTtcblxuICAgIGlmIChkYXRhVXJpTWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1lZGlhVHlwZTogZGF0YVVyaU1hdGNoWzFdID8gZGF0YVVyaU1hdGNoWzFdLnRvTG93ZXJDYXNlKCkgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBzdWJUeXBlOiBkYXRhVXJpTWF0Y2hbMl0gPyBkYXRhVXJpTWF0Y2hbMl0udG9Mb3dlckNhc2UoKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNoYXJzZXQ6IGRhdGFVcmlNYXRjaFszXSA/IGRhdGFVcmlNYXRjaFszXS50b0xvd2VyQ2FzZSgpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZW5jb2Rpbmc6IGRhdGFVcmlNYXRjaFs0XSA/IGRhdGFVcmlNYXRjaFs0XS50b0xvd2VyQ2FzZSgpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZGF0YTogZGF0YVVyaU1hdGNoWzVdXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBHZXQgdHlwZSBvZiB0aGUgaW1hZ2UgYnkgcmVnZXhwIGZvciBleHRlbnNpb24uIFJldHVybnMgdW5kZWZpbmVkIGZvciB1bmtub3duIGV4dGVuc2lvbnMuXG4gKlxuICogQG1lbWJlcm9mIFBJWEkudXRpbHNcbiAqIEBmdW5jdGlvbiBnZXRVcmxGaWxlRXh0ZW5zaW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIC0gdGhlIGltYWdlIHBhdGhcbiAqIEByZXR1cm4ge3N0cmluZ3x1bmRlZmluZWR9IGltYWdlIGV4dGVuc2lvblxuICovXG5mdW5jdGlvbiBnZXRVcmxGaWxlRXh0ZW5zaW9uKHVybCkge1xuICAgIHZhciBleHRlbnNpb24gPSBfY29uc3QuVVJMX0ZJTEVfRVhURU5TSU9OLmV4ZWModXJsKTtcblxuICAgIGlmIChleHRlbnNpb24pIHtcbiAgICAgICAgcmV0dXJuIGV4dGVuc2lvblsxXS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogVHlwZWRlZiBmb3IgU2l6ZSBvYmplY3QuXG4gKlxuICogQHR5cGVkZWYge29iamVjdH0gUElYSS51dGlsc35TaXplXG4gKiBAcHJvcGVydHkge3dpZHRofSBXaWR0aCBjb21wb25lbnRcbiAqIEBwcm9wZXJ0eSB7aGVpZ2h0fSBIZWlnaHQgY29tcG9uZW50XG4gKi9cblxuLyoqXG4gKiBHZXQgc2l6ZSBmcm9tIGFuIHN2ZyBzdHJpbmcgdXNpbmcgcmVnZXhwLlxuICpcbiAqIEBtZW1iZXJvZiBQSVhJLnV0aWxzXG4gKiBAZnVuY3Rpb24gZ2V0U3ZnU2l6ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN2Z1N0cmluZyAtIGEgc2VyaWFsaXplZCBzdmcgZWxlbWVudFxuICogQHJldHVybiB7UElYSS51dGlsc35TaXplfHVuZGVmaW5lZH0gaW1hZ2UgZXh0ZW5zaW9uXG4gKi9cbmZ1bmN0aW9uIGdldFN2Z1NpemUoc3ZnU3RyaW5nKSB7XG4gICAgdmFyIHNpemVNYXRjaCA9IF9jb25zdC5TVkdfU0laRS5leGVjKHN2Z1N0cmluZyk7XG4gICAgdmFyIHNpemUgPSB7fTtcblxuICAgIGlmIChzaXplTWF0Y2gpIHtcbiAgICAgICAgc2l6ZVtzaXplTWF0Y2hbMV1dID0gTWF0aC5yb3VuZChwYXJzZUZsb2F0KHNpemVNYXRjaFszXSkpO1xuICAgICAgICBzaXplW3NpemVNYXRjaFs1XV0gPSBNYXRoLnJvdW5kKHBhcnNlRmxvYXQoc2l6ZU1hdGNoWzddKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNpemU7XG59XG5cbi8qKlxuICogU2tpcHMgdGhlIGhlbGxvIG1lc3NhZ2Ugb2YgcmVuZGVyZXJzIHRoYXQgYXJlIGNyZWF0ZWQgYWZ0ZXIgdGhpcyBpcyBydW4uXG4gKlxuICogQGZ1bmN0aW9uIHNraXBIZWxsb1xuICogQG1lbWJlcm9mIFBJWEkudXRpbHNcbiAqL1xuZnVuY3Rpb24gc2tpcEhlbGxvKCkge1xuICAgIHNhaWRIZWxsbyA9IHRydWU7XG59XG5cbi8qKlxuICogTG9ncyBvdXQgdGhlIHZlcnNpb24gYW5kIHJlbmRlcmVyIGluZm9ybWF0aW9uIGZvciB0aGlzIHJ1bm5pbmcgaW5zdGFuY2Ugb2YgUElYSS5cbiAqIElmIHlvdSBkb24ndCB3YW50IHRvIHNlZSB0aGlzIG1lc3NhZ2UgeW91IGNhbiBydW4gYFBJWEkudXRpbHMuc2tpcEhlbGxvKClgIGJlZm9yZVxuICogY3JlYXRpbmcgeW91ciByZW5kZXJlci4gS2VlcCBpbiBtaW5kIHRoYXQgZG9pbmcgdGhhdCB3aWxsIGZvcmV2ZXIgbWFrZXMgeW91IGEgamVyayBmYWNlLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBmdW5jdGlvbiBzYXlIZWxsb1xuICogQG1lbWJlcm9mIFBJWEkudXRpbHNcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gVGhlIHN0cmluZyByZW5kZXJlciB0eXBlIHRvIGxvZy5cbiAqL1xuZnVuY3Rpb24gc2F5SGVsbG8odHlwZSkge1xuICAgIGlmIChzYWlkSGVsbG8pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkuaW5kZXhPZignY2hyb21lJykgPiAtMSkge1xuICAgICAgICB2YXIgYXJncyA9IFsnXFxuICVjICVjICVjIFBpeGlKUyAnICsgX2NvbnN0LlZFUlNJT04gKyAnIC0gXFx1MjczMCAnICsgdHlwZSArICcgXFx1MjczMCAgJWMgICVjICBodHRwOi8vd3d3LnBpeGlqcy5jb20vICAlYyAlYyBcXHUyNjY1JWNcXHUyNjY1JWNcXHUyNjY1IFxcblxcbicsICdiYWNrZ3JvdW5kOiAjZmY2NmE1OyBwYWRkaW5nOjVweCAwOycsICdiYWNrZ3JvdW5kOiAjZmY2NmE1OyBwYWRkaW5nOjVweCAwOycsICdjb2xvcjogI2ZmNjZhNTsgYmFja2dyb3VuZDogIzAzMDMwNzsgcGFkZGluZzo1cHggMDsnLCAnYmFja2dyb3VuZDogI2ZmNjZhNTsgcGFkZGluZzo1cHggMDsnLCAnYmFja2dyb3VuZDogI2ZmYzNkYzsgcGFkZGluZzo1cHggMDsnLCAnYmFja2dyb3VuZDogI2ZmNjZhNTsgcGFkZGluZzo1cHggMDsnLCAnY29sb3I6ICNmZjI0MjQ7IGJhY2tncm91bmQ6ICNmZmY7IHBhZGRpbmc6NXB4IDA7JywgJ2NvbG9yOiAjZmYyNDI0OyBiYWNrZ3JvdW5kOiAjZmZmOyBwYWRkaW5nOjVweCAwOycsICdjb2xvcjogI2ZmMjQyNDsgYmFja2dyb3VuZDogI2ZmZjsgcGFkZGluZzo1cHggMDsnXTtcblxuICAgICAgICB3aW5kb3cuY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJncyk7XG4gICAgfSBlbHNlIGlmICh3aW5kb3cuY29uc29sZSkge1xuICAgICAgICB3aW5kb3cuY29uc29sZS5sb2coJ1BpeGlKUyAnICsgX2NvbnN0LlZFUlNJT04gKyAnIC0gJyArIHR5cGUgKyAnIC0gaHR0cDovL3d3dy5waXhpanMuY29tLycpO1xuICAgIH1cblxuICAgIHNhaWRIZWxsbyA9IHRydWU7XG59XG5cbi8qKlxuICogSGVscGVyIGZvciBjaGVja2luZyBmb3Igd2ViZ2wgc3VwcG9ydFxuICpcbiAqIEBtZW1iZXJvZiBQSVhJLnV0aWxzXG4gKiBAZnVuY3Rpb24gaXNXZWJHTFN1cHBvcnRlZFxuICogQHJldHVybiB7Ym9vbGVhbn0gaXMgd2ViZ2wgc3VwcG9ydGVkXG4gKi9cbmZ1bmN0aW9uIGlzV2ViR0xTdXBwb3J0ZWQoKSB7XG4gICAgdmFyIGNvbnRleHRPcHRpb25zID0geyBzdGVuY2lsOiB0cnVlLCBmYWlsSWZNYWpvclBlcmZvcm1hbmNlQ2F2ZWF0OiB0cnVlIH07XG5cbiAgICB0cnkge1xuICAgICAgICBpZiAoIXdpbmRvdy5XZWJHTFJlbmRlcmluZ0NvbnRleHQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgdmFyIGdsID0gY2FudmFzLmdldENvbnRleHQoJ3dlYmdsJywgY29udGV4dE9wdGlvbnMpIHx8IGNhbnZhcy5nZXRDb250ZXh0KCdleHBlcmltZW50YWwtd2ViZ2wnLCBjb250ZXh0T3B0aW9ucyk7XG5cbiAgICAgICAgdmFyIHN1Y2Nlc3MgPSAhIShnbCAmJiBnbC5nZXRDb250ZXh0QXR0cmlidXRlcygpLnN0ZW5jaWwpO1xuXG4gICAgICAgIGlmIChnbCkge1xuICAgICAgICAgICAgdmFyIGxvc2VDb250ZXh0ID0gZ2wuZ2V0RXh0ZW5zaW9uKCdXRUJHTF9sb3NlX2NvbnRleHQnKTtcblxuICAgICAgICAgICAgaWYgKGxvc2VDb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgbG9zZUNvbnRleHQubG9zZUNvbnRleHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGdsID0gbnVsbDtcblxuICAgICAgICByZXR1cm4gc3VjY2VzcztcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbi8qKlxuICogUmV0dXJucyBzaWduIG9mIG51bWJlclxuICpcbiAqIEBtZW1iZXJvZiBQSVhJLnV0aWxzXG4gKiBAZnVuY3Rpb24gc2lnblxuICogQHBhcmFtIHtudW1iZXJ9IG4gLSB0aGUgbnVtYmVyIHRvIGNoZWNrIHRoZSBzaWduIG9mXG4gKiBAcmV0dXJucyB7bnVtYmVyfSAwIGlmIGBuYCBpcyAwLCAtMSBpZiBgbmAgaXMgbmVnYXRpdmUsIDEgaWYgYG5gIGlzIHBvc2l0aXZlXG4gKi9cbmZ1bmN0aW9uIHNpZ24obikge1xuICAgIGlmIChuID09PSAwKSByZXR1cm4gMDtcblxuICAgIHJldHVybiBuIDwgMCA/IC0xIDogMTtcbn1cblxuLyoqXG4gKiBAdG9kbyBEZXNjcmliZSBwcm9wZXJ0eSB1c2FnZVxuICpcbiAqIEBtZW1iZXJvZiBQSVhJLnV0aWxzXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgVGV4dHVyZUNhY2hlID0gZXhwb3J0cy5UZXh0dXJlQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4vKipcbiAqIEB0b2RvIERlc2NyaWJlIHByb3BlcnR5IHVzYWdlXG4gKlxuICogQG1lbWJlcm9mIFBJWEkudXRpbHNcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBCYXNlVGV4dHVyZUNhY2hlID0gZXhwb3J0cy5CYXNlVGV4dHVyZUNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuLyoqXG4gKiBEZXN0cm95cyBhbGwgdGV4dHVyZSBpbiB0aGUgY2FjaGVcbiAqXG4gKiBAbWVtYmVyb2YgUElYSS51dGlsc1xuICogQGZ1bmN0aW9uIGRlc3Ryb3lUZXh0dXJlQ2FjaGVcbiAqL1xuZnVuY3Rpb24gZGVzdHJveVRleHR1cmVDYWNoZSgpIHtcbiAgICB2YXIga2V5ID0gdm9pZCAwO1xuXG4gICAgZm9yIChrZXkgaW4gVGV4dHVyZUNhY2hlKSB7XG4gICAgICAgIFRleHR1cmVDYWNoZVtrZXldLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgZm9yIChrZXkgaW4gQmFzZVRleHR1cmVDYWNoZSkge1xuICAgICAgICBCYXNlVGV4dHVyZUNhY2hlW2tleV0uZGVzdHJveSgpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCB0ZXh0dXJlcyBmcm9tIGNhY2hlLCBidXQgZG9lcyBub3QgZGVzdHJveSB0aGVtXG4gKlxuICogQG1lbWJlcm9mIFBJWEkudXRpbHNcbiAqIEBmdW5jdGlvbiBjbGVhclRleHR1cmVDYWNoZVxuICovXG5mdW5jdGlvbiBjbGVhclRleHR1cmVDYWNoZSgpIHtcbiAgICB2YXIga2V5ID0gdm9pZCAwO1xuXG4gICAgZm9yIChrZXkgaW4gVGV4dHVyZUNhY2hlKSB7XG4gICAgICAgIGRlbGV0ZSBUZXh0dXJlQ2FjaGVba2V5XTtcbiAgICB9XG4gICAgZm9yIChrZXkgaW4gQmFzZVRleHR1cmVDYWNoZSkge1xuICAgICAgICBkZWxldGUgQmFzZVRleHR1cmVDYWNoZVtrZXldO1xuICAgIH1cbn1cblxuLyoqXG4gKiBtYXBzIHByZW11bHRpcGx5IGZsYWcgYW5kIGJsZW5kTW9kZSB0byBhZGp1c3RlZCBibGVuZE1vZGVcbiAqIEBtZW1iZXJvZiBQSVhJLnV0aWxzXG4gKiBAY29uc3QgcHJlbXVsdGlwbHlCbGVuZE1vZGVcbiAqIEB0eXBlIHtBcnJheTxudW1iZXJbXT59XG4gKi9cbnZhciBwcmVtdWx0aXBseUJsZW5kTW9kZSA9IGV4cG9ydHMucHJlbXVsdGlwbHlCbGVuZE1vZGUgPSAoMCwgX21hcFByZW11bHRpcGxpZWRCbGVuZE1vZGVzMi5kZWZhdWx0KSgpO1xuXG4vKipcbiAqIGNoYW5nZXMgYmxlbmRNb2RlIGFjY29yZGluZyB0byB0ZXh0dXJlIGZvcm1hdFxuICpcbiAqIEBtZW1iZXJvZiBQSVhJLnV0aWxzXG4gKiBAZnVuY3Rpb24gY29ycmVjdEJsZW5kTW9kZVxuICogQHBhcmFtIHtudW1iZXJ9IGJsZW5kTW9kZSBzdXBwb3NlZCBibGVuZCBtb2RlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHByZW11bHRpcGxpZWQgIHdoZXRoZXIgc291cmNlIGlzIHByZW11bHRpcGxpZWRcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHRydWUgYmxlbmQgbW9kZSBmb3IgdGhpcyB0ZXh0dXJlXG4gKi9cbmZ1bmN0aW9uIGNvcnJlY3RCbGVuZE1vZGUoYmxlbmRNb2RlLCBwcmVtdWx0aXBsaWVkKSB7XG4gICAgcmV0dXJuIHByZW11bHRpcGx5QmxlbmRNb2RlW3ByZW11bHRpcGxpZWQgPyAxIDogMF1bYmxlbmRNb2RlXTtcbn1cblxuLyoqXG4gKiBwcmVtdWx0aXBsaWVzIHRpbnRcbiAqXG4gKiBAbWVtYmVyb2YgUElYSS51dGlsc1xuICogQHBhcmFtIHtudW1iZXJ9IHRpbnQgaW50ZWdldCBSR0JcbiAqIEBwYXJhbSB7bnVtYmVyfSBhbHBoYSBmbG9hdGluZyBwb2ludCBhbHBoYSAoMC4wLTEuMClcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHRpbnQgbXVsdGlwbGllZCBieSBhbHBoYVxuICovXG5mdW5jdGlvbiBwcmVtdWx0aXBseVRpbnQodGludCwgYWxwaGEpIHtcbiAgICBpZiAoYWxwaGEgPT09IDEuMCkge1xuICAgICAgICByZXR1cm4gKGFscGhhICogMjU1IDw8IDI0KSArIHRpbnQ7XG4gICAgfVxuICAgIGlmIChhbHBoYSA9PT0gMC4wKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICB2YXIgUiA9IHRpbnQgPj4gMTYgJiAweEZGO1xuICAgIHZhciBHID0gdGludCA+PiA4ICYgMHhGRjtcbiAgICB2YXIgQiA9IHRpbnQgJiAweEZGO1xuXG4gICAgUiA9IFIgKiBhbHBoYSArIDAuNSB8IDA7XG4gICAgRyA9IEcgKiBhbHBoYSArIDAuNSB8IDA7XG4gICAgQiA9IEIgKiBhbHBoYSArIDAuNSB8IDA7XG5cbiAgICByZXR1cm4gKGFscGhhICogMjU1IDw8IDI0KSArIChSIDw8IDE2KSArIChHIDw8IDgpICsgQjtcbn1cblxuLyoqXG4gKiBjb21iaW5lcyByZ2IgYW5kIGFscGhhIHRvIG91dCBhcnJheVxuICpcbiAqIEBtZW1iZXJvZiBQSVhJLnV0aWxzXG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxudW1iZXJbXX0gcmdiIGlucHV0IHJnYlxuICogQHBhcmFtIHtudW1iZXJ9IGFscGhhIGFscGhhIHBhcmFtXG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gW291dF0gb3V0cHV0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtwcmVtdWx0aXBseT10cnVlXSBkbyBwcmVtdWx0aXBseSBpdFxuICogQHJldHVybnMge0Zsb2F0MzJBcnJheX0gdmVjNCByZ2JhXG4gKi9cbmZ1bmN0aW9uIHByZW11bHRpcGx5UmdiYShyZ2IsIGFscGhhLCBvdXQsIHByZW11bHRpcGx5KSB7XG4gICAgb3V0ID0gb3V0IHx8IG5ldyBGbG9hdDMyQXJyYXkoNCk7XG4gICAgaWYgKHByZW11bHRpcGx5IHx8IHByZW11bHRpcGx5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3V0WzBdID0gcmdiWzBdICogYWxwaGE7XG4gICAgICAgIG91dFsxXSA9IHJnYlsxXSAqIGFscGhhO1xuICAgICAgICBvdXRbMl0gPSByZ2JbMl0gKiBhbHBoYTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvdXRbMF0gPSByZ2JbMF07XG4gICAgICAgIG91dFsxXSA9IHJnYlsxXTtcbiAgICAgICAgb3V0WzJdID0gcmdiWzJdO1xuICAgIH1cbiAgICBvdXRbM10gPSBhbHBoYTtcblxuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogY29udmVydHMgaW50ZWdlciB0aW50IGFuZCBmbG9hdCBhbHBoYSB0byB2ZWM0IGZvcm0sIHByZW11bHRpcGxpZXMgYnkgZGVmYXVsdFxuICpcbiAqIEBtZW1iZXJvZiBQSVhJLnV0aWxzXG4gKiBAcGFyYW0ge251bWJlcn0gdGludCBpbnB1dCB0aW50XG4gKiBAcGFyYW0ge251bWJlcn0gYWxwaGEgYWxwaGEgcGFyYW1cbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSBbb3V0XSBvdXRwdXRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3ByZW11bHRpcGx5PXRydWVdIGRvIHByZW11bHRpcGx5IGl0XG4gKiBAcmV0dXJucyB7RmxvYXQzMkFycmF5fSB2ZWM0IHJnYmFcbiAqL1xuZnVuY3Rpb24gcHJlbXVsdGlwbHlUaW50VG9SZ2JhKHRpbnQsIGFscGhhLCBvdXQsIHByZW11bHRpcGx5KSB7XG4gICAgb3V0ID0gb3V0IHx8IG5ldyBGbG9hdDMyQXJyYXkoNCk7XG4gICAgb3V0WzBdID0gKHRpbnQgPj4gMTYgJiAweEZGKSAvIDI1NS4wO1xuICAgIG91dFsxXSA9ICh0aW50ID4+IDggJiAweEZGKSAvIDI1NS4wO1xuICAgIG91dFsyXSA9ICh0aW50ICYgMHhGRikgLyAyNTUuMDtcbiAgICBpZiAocHJlbXVsdGlwbHkgfHwgcHJlbXVsdGlwbHkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvdXRbMF0gKj0gYWxwaGE7XG4gICAgICAgIG91dFsxXSAqPSBhbHBoYTtcbiAgICAgICAgb3V0WzJdICo9IGFscGhhO1xuICAgIH1cbiAgICBvdXRbM10gPSBhbHBoYTtcblxuICAgIHJldHVybiBvdXQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmRlZmF1bHQgPSBtYXBQcmVtdWx0aXBsaWVkQmxlbmRNb2RlcztcblxudmFyIF9jb25zdCA9IHJlcXVpcmUoJy4uL2NvbnN0Jyk7XG5cbi8qKlxuICogQ29ycmVjdHMgUGl4aUpTIGJsZW5kLCB0YWtlcyBwcmVtdWx0aXBsaWVkIGFscGhhIGludG8gYWNjb3VudFxuICpcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKiBAZnVuY3Rpb24gbWFwUHJlbXVsdGlwbGllZEJsZW5kTW9kZXNcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcltdPn0gW2FycmF5XSAtIFRoZSBhcnJheSB0byBvdXRwdXQgaW50by5cbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcltdPn0gTWFwcGVkIG1vZGVzLlxuICovXG5cbmZ1bmN0aW9uIG1hcFByZW11bHRpcGxpZWRCbGVuZE1vZGVzKCkge1xuICAgIHZhciBwbSA9IFtdO1xuICAgIHZhciBucG0gPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzI7IGkrKykge1xuICAgICAgICBwbVtpXSA9IGk7XG4gICAgICAgIG5wbVtpXSA9IGk7XG4gICAgfVxuXG4gICAgcG1bX2NvbnN0LkJMRU5EX01PREVTLk5PUk1BTF9OUE1dID0gX2NvbnN0LkJMRU5EX01PREVTLk5PUk1BTDtcbiAgICBwbVtfY29uc3QuQkxFTkRfTU9ERVMuQUREX05QTV0gPSBfY29uc3QuQkxFTkRfTU9ERVMuQUREO1xuICAgIHBtW19jb25zdC5CTEVORF9NT0RFUy5TQ1JFRU5fTlBNXSA9IF9jb25zdC5CTEVORF9NT0RFUy5TQ1JFRU47XG5cbiAgICBucG1bX2NvbnN0LkJMRU5EX01PREVTLk5PUk1BTF0gPSBfY29uc3QuQkxFTkRfTU9ERVMuTk9STUFMX05QTTtcbiAgICBucG1bX2NvbnN0LkJMRU5EX01PREVTLkFERF0gPSBfY29uc3QuQkxFTkRfTU9ERVMuQUREX05QTTtcbiAgICBucG1bX2NvbnN0LkJMRU5EX01PREVTLlNDUkVFTl0gPSBfY29uc3QuQkxFTkRfTU9ERVMuU0NSRUVOX05QTTtcblxuICAgIHZhciBhcnJheSA9IFtdO1xuXG4gICAgYXJyYXkucHVzaChucG0pO1xuICAgIGFycmF5LnB1c2gocG0pO1xuXG4gICAgcmV0dXJuIGFycmF5O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFwUHJlbXVsdGlwbGllZEJsZW5kTW9kZXMuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5kZWZhdWx0ID0gbWF4UmVjb21tZW5kZWRUZXh0dXJlcztcblxudmFyIF9pc21vYmlsZWpzID0gcmVxdWlyZSgnaXNtb2JpbGVqcycpO1xuXG52YXIgX2lzbW9iaWxlanMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaXNtb2JpbGVqcyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIG1heFJlY29tbWVuZGVkVGV4dHVyZXMobWF4KSB7XG4gICAgaWYgKF9pc21vYmlsZWpzMi5kZWZhdWx0LnRhYmxldCB8fCBfaXNtb2JpbGVqczIuZGVmYXVsdC5waG9uZSkge1xuICAgICAgICAvLyBjaGVjayBpZiB0aGUgcmVzIGlzIGlwaG9uZSA2IG9yIGhpZ2hlci4uXG4gICAgICAgIHJldHVybiA0O1xuICAgIH1cblxuICAgIC8vIGRlc2t0b3Agc2hvdWxkIGJlIG9rXG4gICAgcmV0dXJuIG1heDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1heFJlY29tbWVuZGVkVGV4dHVyZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLm1peGluID0gbWl4aW47XG5leHBvcnRzLmRlbGF5TWl4aW4gPSBkZWxheU1peGluO1xuZXhwb3J0cy5wZXJmb3JtTWl4aW5zID0gcGVyZm9ybU1peGlucztcbi8qKlxuICogTWl4ZXMgYWxsIGVudW1lcmFibGUgcHJvcGVydGllcyBhbmQgbWV0aG9kcyBmcm9tIGEgc291cmNlIG9iamVjdCB0byBhIHRhcmdldCBvYmplY3QuXG4gKlxuICogQG1lbWJlcm9mIFBJWEkudXRpbHMubWl4aW5zXG4gKiBAZnVuY3Rpb24gbWl4aW5cbiAqIEBwYXJhbSB7b2JqZWN0fSB0YXJnZXQgVGhlIHByb3RvdHlwZSBvciBpbnN0YW5jZSB0aGF0IHByb3BlcnRpZXMgYW5kIG1ldGhvZHMgc2hvdWxkIGJlIGFkZGVkIHRvLlxuICogQHBhcmFtIHtvYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9mIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMgdG8gbWl4IGluLlxuICovXG5mdW5jdGlvbiBtaXhpbih0YXJnZXQsIHNvdXJjZSkge1xuICAgIGlmICghdGFyZ2V0IHx8ICFzb3VyY2UpIHJldHVybjtcbiAgICAvLyBpbiBFUzgvRVMyMDE3LCB0aGlzIHdvdWxkIGJlIHJlYWxseSBlYXN5OlxuICAgIC8vIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7XG5cbiAgICAvLyBnZXQgYWxsIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IGtleXNcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG5cbiAgICAvLyBsb29wIHRocm91Z2ggcHJvcGVydGllc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgcHJvcGVydHlOYW1lID0ga2V5c1tpXTtcblxuICAgICAgICAvLyBTZXQgdGhlIHByb3BlcnR5IHVzaW5nIHRoZSBwcm9wZXJ0eSBkZXNjcmlwdG9yIC0gdGhpcyB3b3JrcyBmb3IgYWNjZXNzb3JzIGFuZCBub3JtYWwgdmFsdWUgcHJvcGVydGllc1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eU5hbWUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBwcm9wZXJ0eU5hbWUpKTtcbiAgICB9XG59XG5cbnZhciBtaXhpbnMgPSBbXTtcblxuLyoqXG4gKiBRdWV1ZXMgYSBtaXhpbiB0byBiZSBoYW5kbGVkIHRvd2FyZHMgdGhlIGVuZCBvZiB0aGUgaW5pdGlhbGl6YXRpb24gb2YgUElYSSwgc28gdGhhdCBkZXByZWNhdGlvblxuICogY2FuIHRha2UgZWZmZWN0LlxuICpcbiAqIEBtZW1iZXJvZiBQSVhJLnV0aWxzLm1peGluc1xuICogQGZ1bmN0aW9uIGRlbGF5TWl4aW5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge29iamVjdH0gdGFyZ2V0IFRoZSBwcm90b3R5cGUgb3IgaW5zdGFuY2UgdGhhdCBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzIHNob3VsZCBiZSBhZGRlZCB0by5cbiAqIEBwYXJhbSB7b2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvZiBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzIHRvIG1peCBpbi5cbiAqL1xuZnVuY3Rpb24gZGVsYXlNaXhpbih0YXJnZXQsIHNvdXJjZSkge1xuICAgIG1peGlucy5wdXNoKHRhcmdldCwgc291cmNlKTtcbn1cblxuLyoqXG4gKiBIYW5kbGVzIGFsbCBtaXhpbnMgcXVldWVkIHZpYSBkZWxheU1peGluKCkuXG4gKlxuICogQG1lbWJlcm9mIFBJWEkudXRpbHMubWl4aW5zXG4gKiBAZnVuY3Rpb24gcGVyZm9ybU1peGluc1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcGVyZm9ybU1peGlucygpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1peGlucy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICBtaXhpbihtaXhpbnNbaV0sIG1peGluc1tpICsgMV0pO1xuICAgIH1cbiAgICBtaXhpbnMubGVuZ3RoID0gMDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1peGluLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuLyoqXG4gKiBNaXhpbnMgZnVuY3Rpb25hbGl0eSB0byBtYWtlIGFuIG9iamVjdCBoYXZlIFwicGx1Z2luc1wiLlxuICpcbiAqIEBleGFtcGxlXG4gKiAgICAgIGZ1bmN0aW9uIE15T2JqZWN0KCkge31cbiAqXG4gKiAgICAgIHBsdWdpblRhcmdldC5taXhpbihNeU9iamVjdCk7XG4gKlxuICogQG1peGluXG4gKiBAbWVtYmVyb2YgUElYSS51dGlsc1xuICogQHBhcmFtIHtvYmplY3R9IG9iaiAtIFRoZSBvYmplY3QgdG8gbWl4IGludG8uXG4gKi9cbmZ1bmN0aW9uIHBsdWdpblRhcmdldChvYmopIHtcbiAgICBvYmouX19wbHVnaW5zID0ge307XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgcGx1Z2luIHRvIGFuIG9iamVjdFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBsdWdpbk5hbWUgLSBUaGUgZXZlbnRzIHRoYXQgc2hvdWxkIGJlIGxpc3RlZC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdG9yIC0gVGhlIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIGZvciB0aGUgcGx1Z2luLlxuICAgICAqL1xuICAgIG9iai5yZWdpc3RlclBsdWdpbiA9IGZ1bmN0aW9uIHJlZ2lzdGVyUGx1Z2luKHBsdWdpbk5hbWUsIGN0b3IpIHtcbiAgICAgICAgb2JqLl9fcGx1Z2luc1twbHVnaW5OYW1lXSA9IGN0b3I7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEluc3RhbnRpYXRlcyBhbGwgdGhlIHBsdWdpbnMgb2YgdGhpcyBvYmplY3RcbiAgICAgKlxuICAgICAqL1xuICAgIG9iai5wcm90b3R5cGUuaW5pdFBsdWdpbnMgPSBmdW5jdGlvbiBpbml0UGx1Z2lucygpIHtcbiAgICAgICAgdGhpcy5wbHVnaW5zID0gdGhpcy5wbHVnaW5zIHx8IHt9O1xuXG4gICAgICAgIGZvciAodmFyIG8gaW4gb2JqLl9fcGx1Z2lucykge1xuICAgICAgICAgICAgdGhpcy5wbHVnaW5zW29dID0gbmV3IG9iai5fX3BsdWdpbnNbb10odGhpcyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgdGhlIHBsdWdpbnMgb2YgdGhpcyBvYmplY3RcbiAgICAgKlxuICAgICAqL1xuICAgIG9iai5wcm90b3R5cGUuZGVzdHJveVBsdWdpbnMgPSBmdW5jdGlvbiBkZXN0cm95UGx1Z2lucygpIHtcbiAgICAgICAgZm9yICh2YXIgbyBpbiB0aGlzLnBsdWdpbnMpIHtcbiAgICAgICAgICAgIHRoaXMucGx1Z2luc1tvXS5kZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLnBsdWdpbnNbb10gPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wbHVnaW5zID0gbnVsbDtcbiAgICB9O1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gICAgLyoqXG4gICAgICogTWl4ZXMgaW4gdGhlIHByb3BlcnRpZXMgb2YgdGhlIHBsdWdpblRhcmdldCBpbnRvIGFub3RoZXIgb2JqZWN0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb2JqIC0gVGhlIG9iaiB0byBtaXggaW50b1xuICAgICAqL1xuICAgIG1peGluOiBmdW5jdGlvbiBtaXhpbihvYmopIHtcbiAgICAgICAgcGx1Z2luVGFyZ2V0KG9iaik7XG4gICAgfVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBsdWdpblRhcmdldC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmRlZmF1bHQgPSB0cmltQ2FudmFzO1xuLyoqXG4gKiBUcmltIHRyYW5zcGFyZW50IGJvcmRlcnMgZnJvbSBhIGNhbnZhc1xuICpcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKiBAZnVuY3Rpb24gdHJpbUNhbnZhc1xuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhcyAtIHRoZSBjYW52YXMgdG8gdHJpbVxuICogQHJldHVybnMge29iamVjdH0gVHJpbSBkYXRhXG4gKi9cbmZ1bmN0aW9uIHRyaW1DYW52YXMoY2FudmFzKSB7XG4gICAgLy8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vcmVteS83ODQ1MDhcblxuICAgIHZhciB3aWR0aCA9IGNhbnZhcy53aWR0aDtcbiAgICB2YXIgaGVpZ2h0ID0gY2FudmFzLmhlaWdodDtcblxuICAgIHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgdmFyIGltYWdlRGF0YSA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgIHZhciBwaXhlbHMgPSBpbWFnZURhdGEuZGF0YTtcbiAgICB2YXIgbGVuID0gcGl4ZWxzLmxlbmd0aDtcblxuICAgIHZhciBib3VuZCA9IHtcbiAgICAgICAgdG9wOiBudWxsLFxuICAgICAgICBsZWZ0OiBudWxsLFxuICAgICAgICByaWdodDogbnVsbCxcbiAgICAgICAgYm90dG9tOiBudWxsXG4gICAgfTtcbiAgICB2YXIgZGF0YSA9IG51bGw7XG4gICAgdmFyIGkgPSB2b2lkIDA7XG4gICAgdmFyIHggPSB2b2lkIDA7XG4gICAgdmFyIHkgPSB2b2lkIDA7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICAgICAgaWYgKHBpeGVsc1tpICsgM10gIT09IDApIHtcbiAgICAgICAgICAgIHggPSBpIC8gNCAlIHdpZHRoO1xuICAgICAgICAgICAgeSA9IH5+KGkgLyA0IC8gd2lkdGgpO1xuXG4gICAgICAgICAgICBpZiAoYm91bmQudG9wID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYm91bmQudG9wID0geTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGJvdW5kLmxlZnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBib3VuZC5sZWZ0ID0geDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoeCA8IGJvdW5kLmxlZnQpIHtcbiAgICAgICAgICAgICAgICBib3VuZC5sZWZ0ID0geDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGJvdW5kLnJpZ2h0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYm91bmQucmlnaHQgPSB4ICsgMTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYm91bmQucmlnaHQgPCB4KSB7XG4gICAgICAgICAgICAgICAgYm91bmQucmlnaHQgPSB4ICsgMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGJvdW5kLmJvdHRvbSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGJvdW5kLmJvdHRvbSA9IHk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGJvdW5kLmJvdHRvbSA8IHkpIHtcbiAgICAgICAgICAgICAgICBib3VuZC5ib3R0b20gPSB5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGJvdW5kLnRvcCAhPT0gbnVsbCkge1xuICAgICAgICB3aWR0aCA9IGJvdW5kLnJpZ2h0IC0gYm91bmQubGVmdDtcbiAgICAgICAgaGVpZ2h0ID0gYm91bmQuYm90dG9tIC0gYm91bmQudG9wICsgMTtcbiAgICAgICAgZGF0YSA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKGJvdW5kLmxlZnQsIGJvdW5kLnRvcCwgd2lkdGgsIGhlaWdodCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgZGF0YTogZGF0YVxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmltQ2FudmFzLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlcHJlY2F0aW9uO1xuLy8gcHJvdmlkZSBtZXRob2QgdG8gZ2l2ZSBhIHN0YWNrIHRyYWNrIGZvciB3YXJuaW5nc1xuLy8gdXNlZnVsIGZvciB0cmFja2luZy1kb3duIHdoZXJlIGRlcHJlY2F0ZWQgbWV0aG9kcy9wcm9wZXJ0aWVzL2NsYXNzZXNcbi8vIGFyZSBiZWluZyB1c2VkIHdpdGhpbiB0aGUgY29kZVxuXG4vLyBBIG1hcCBvZiB3YXJuaW5nIG1lc3NhZ2VzIGFscmVhZHkgZmlyZWRcbnZhciB3YXJuaW5ncyA9IHt9O1xuXG4vLyBwcm92aWRlIG1ldGhvZCB0byBnaXZlIGEgc3RhY2sgdHJhY2sgZm9yIHdhcm5pbmdzXG4vLyB1c2VmdWwgZm9yIHRyYWNraW5nLWRvd24gd2hlcmUgZGVwcmVjYXRlZCBtZXRob2RzL3Byb3BlcnRpZXMvY2xhc3Nlc1xuLy8gYXJlIGJlaW5nIHVzZWQgd2l0aGluIHRoZSBjb2RlXG5mdW5jdGlvbiB3YXJuKG1zZykge1xuICAgIC8vIElnbm9yZSBkdXBsaWNhdFxuICAgIGlmICh3YXJuaW5nc1ttc2ddKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG4gICAgdmFyIHN0YWNrID0gbmV3IEVycm9yKCkuc3RhY2s7XG5cbiAgICAvLyBIYW5kbGUgSUUgPCAxMCBhbmQgU2FmYXJpIDwgNlxuICAgIGlmICh0eXBlb2Ygc3RhY2sgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignRGVwcmVjYXRpb24gV2FybmluZzogJywgbXNnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBjaG9wIG9mZiB0aGUgc3RhY2sgdHJhY2Ugd2hpY2ggaW5jbHVkZXMgcGl4aS5qcyBpbnRlcm5hbCBjYWxsc1xuICAgICAgICBzdGFjayA9IHN0YWNrLnNwbGl0KCdcXG4nKS5zcGxpY2UoMykuam9pbignXFxuJyk7XG5cbiAgICAgICAgaWYgKGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQoJyVjRGVwcmVjYXRpb24gV2FybmluZzogJWMlcycsICdjb2xvcjojNjE0MTA4O2JhY2tncm91bmQ6I2ZmZmJlNicsICdmb250LXdlaWdodDpub3JtYWw7Y29sb3I6IzYxNDEwODtiYWNrZ3JvdW5kOiNmZmZiZTYnLCBtc2cpO1xuICAgICAgICAgICAgY29uc29sZS53YXJuKHN0YWNrKTtcbiAgICAgICAgICAgIGNvbnNvbGUuZ3JvdXBFbmQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignRGVwcmVjYXRpb24gV2FybmluZzogJywgbXNnKTtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihzdGFjayk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1jb25zb2xlICovXG5cbiAgICB3YXJuaW5nc1ttc2ddID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gZGVwcmVjYXRpb24oY29yZSkge1xuICAgIHZhciBtZXNoID0gY29yZS5tZXNoLFxuICAgICAgICBwYXJ0aWNsZXMgPSBjb3JlLnBhcnRpY2xlcyxcbiAgICAgICAgZXh0cmFzID0gY29yZS5leHRyYXMsXG4gICAgICAgIGZpbHRlcnMgPSBjb3JlLmZpbHRlcnMsXG4gICAgICAgIHByZXBhcmUgPSBjb3JlLnByZXBhcmUsXG4gICAgICAgIGxvYWRlcnMgPSBjb3JlLmxvYWRlcnMsXG4gICAgICAgIGludGVyYWN0aW9uID0gY29yZS5pbnRlcmFjdGlvbjtcblxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29yZSwge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAY2xhc3NcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQG5hbWUgU3ByaXRlQmF0Y2hcbiAgICAgICAgICogQG1lbWJlcm9mIFBJWElcbiAgICAgICAgICogQHNlZSBQSVhJLlBhcnRpY2xlQ29udGFpbmVyXG4gICAgICAgICAqIEB0aHJvd3Mge1JlZmVyZW5jZUVycm9yfSBTcHJpdGVCYXRjaCBkb2VzIG5vdCBleGlzdCBhbnkgbW9yZSwgcGxlYXNlIHVzZSB0aGUgbmV3IFBhcnRpY2xlQ29udGFpbmVyIGluc3RlYWQuXG4gICAgICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMy4wLjBcbiAgICAgICAgICovXG4gICAgICAgIFNwcml0ZUJhdGNoOiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoJ1Nwcml0ZUJhdGNoIGRvZXMgbm90IGV4aXN0IGFueSBtb3JlLCAnICsgJ3BsZWFzZSB1c2UgdGhlIG5ldyBQYXJ0aWNsZUNvbnRhaW5lciBpbnN0ZWFkLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAY2xhc3NcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQG5hbWUgQXNzZXRMb2FkZXJcbiAgICAgICAgICogQG1lbWJlcm9mIFBJWElcbiAgICAgICAgICogQHNlZSBQSVhJLmxvYWRlcnMuTG9hZGVyXG4gICAgICAgICAqIEB0aHJvd3Mge1JlZmVyZW5jZUVycm9yfSBUaGUgbG9hZGVyIHN5c3RlbSB3YXMgb3ZlcmhhdWxlZCBpbiBQaXhpSlMgdjMsXG4gICAgICAgICAqIHBsZWFzZSBzZWUgdGhlIG5ldyBQSVhJLmxvYWRlcnMuTG9hZGVyIGNsYXNzLlxuICAgICAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDMuMC4wXG4gICAgICAgICAqL1xuICAgICAgICBBc3NldExvYWRlcjoge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKCdUaGUgbG9hZGVyIHN5c3RlbSB3YXMgb3ZlcmhhdWxlZCBpbiBQaXhpSlMgdjMsICcgKyAncGxlYXNlIHNlZSB0aGUgbmV3IFBJWEkubG9hZGVycy5Mb2FkZXIgY2xhc3MuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBjbGFzc1xuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAbmFtZSBTdGFnZVxuICAgICAgICAgKiBAbWVtYmVyb2YgUElYSVxuICAgICAgICAgKiBAc2VlIFBJWEkuQ29udGFpbmVyXG4gICAgICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMy4wLjBcbiAgICAgICAgICovXG4gICAgICAgIFN0YWdlOiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICB3YXJuKCdZb3UgZG8gbm90IG5lZWQgdG8gdXNlIGEgUElYSSBTdGFnZSBhbnkgbW9yZSwgeW91IGNhbiBzaW1wbHkgcmVuZGVyIGFueSBjb250YWluZXIuJyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gY29yZS5Db250YWluZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBjbGFzc1xuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAbmFtZSBEaXNwbGF5T2JqZWN0Q29udGFpbmVyXG4gICAgICAgICAqIEBtZW1iZXJvZiBQSVhJXG4gICAgICAgICAqIEBzZWUgUElYSS5Db250YWluZXJcbiAgICAgICAgICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAzLjAuMFxuICAgICAgICAgKi9cbiAgICAgICAgRGlzcGxheU9iamVjdENvbnRhaW5lcjoge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgd2FybignRGlzcGxheU9iamVjdENvbnRhaW5lciBoYXMgYmVlbiBzaG9ydGVuZWQgdG8gQ29udGFpbmVyLCBwbGVhc2UgdXNlIENvbnRhaW5lciBmcm9tIG5vdyBvbi4nKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBjb3JlLkNvbnRhaW5lcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQGNsYXNzXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBuYW1lIFN0cmlwXG4gICAgICAgICAqIEBtZW1iZXJvZiBQSVhJXG4gICAgICAgICAqIEBzZWUgUElYSS5tZXNoLk1lc2hcbiAgICAgICAgICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAzLjAuMFxuICAgICAgICAgKi9cbiAgICAgICAgU3RyaXA6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHdhcm4oJ1RoZSBTdHJpcCBjbGFzcyBoYXMgYmVlbiByZW5hbWVkIHRvIE1lc2ggYW5kIG1vdmVkIHRvIG1lc2guTWVzaCwgcGxlYXNlIHVzZSBtZXNoLk1lc2ggZnJvbSBub3cgb24uJyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbWVzaC5NZXNoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAY2xhc3NcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQG5hbWUgUm9wZVxuICAgICAgICAgKiBAbWVtYmVyb2YgUElYSVxuICAgICAgICAgKiBAc2VlIFBJWEkubWVzaC5Sb3BlXG4gICAgICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMy4wLjBcbiAgICAgICAgICovXG4gICAgICAgIFJvcGU6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHdhcm4oJ1RoZSBSb3BlIGNsYXNzIGhhcyBiZWVuIG1vdmVkIHRvIG1lc2guUm9wZSwgcGxlYXNlIHVzZSBtZXNoLlJvcGUgZnJvbSBub3cgb24uJyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbWVzaC5Sb3BlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAY2xhc3NcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQG5hbWUgUGFydGljbGVDb250YWluZXJcbiAgICAgICAgICogQG1lbWJlcm9mIFBJWElcbiAgICAgICAgICogQHNlZSBQSVhJLnBhcnRpY2xlcy5QYXJ0aWNsZUNvbnRhaW5lclxuICAgICAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDQuMC4wXG4gICAgICAgICAqL1xuICAgICAgICBQYXJ0aWNsZUNvbnRhaW5lcjoge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgd2FybignVGhlIFBhcnRpY2xlQ29udGFpbmVyIGNsYXNzIGhhcyBiZWVuIG1vdmVkIHRvIHBhcnRpY2xlcy5QYXJ0aWNsZUNvbnRhaW5lciwgJyArICdwbGVhc2UgdXNlIHBhcnRpY2xlcy5QYXJ0aWNsZUNvbnRhaW5lciBmcm9tIG5vdyBvbi4nKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0aWNsZXMuUGFydGljbGVDb250YWluZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBjbGFzc1xuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAbmFtZSBNb3ZpZUNsaXBcbiAgICAgICAgICogQG1lbWJlcm9mIFBJWElcbiAgICAgICAgICogQHNlZSBQSVhJLmV4dHJhcy5Nb3ZpZUNsaXBcbiAgICAgICAgICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAzLjAuMFxuICAgICAgICAgKi9cbiAgICAgICAgTW92aWVDbGlwOiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICB3YXJuKCdUaGUgTW92aWVDbGlwIGNsYXNzIGhhcyBiZWVuIG1vdmVkIHRvIGV4dHJhcy5BbmltYXRlZFNwcml0ZSwgcGxlYXNlIHVzZSBleHRyYXMuQW5pbWF0ZWRTcHJpdGUuJyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZXh0cmFzLkFuaW1hdGVkU3ByaXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAY2xhc3NcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQG5hbWUgVGlsaW5nU3ByaXRlXG4gICAgICAgICAqIEBtZW1iZXJvZiBQSVhJXG4gICAgICAgICAqIEBzZWUgUElYSS5leHRyYXMuVGlsaW5nU3ByaXRlXG4gICAgICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMy4wLjBcbiAgICAgICAgICovXG4gICAgICAgIFRpbGluZ1Nwcml0ZToge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgd2FybignVGhlIFRpbGluZ1Nwcml0ZSBjbGFzcyBoYXMgYmVlbiBtb3ZlZCB0byBleHRyYXMuVGlsaW5nU3ByaXRlLCAnICsgJ3BsZWFzZSB1c2UgZXh0cmFzLlRpbGluZ1Nwcml0ZSBmcm9tIG5vdyBvbi4nKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBleHRyYXMuVGlsaW5nU3ByaXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAY2xhc3NcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQG5hbWUgQml0bWFwVGV4dFxuICAgICAgICAgKiBAbWVtYmVyb2YgUElYSVxuICAgICAgICAgKiBAc2VlIFBJWEkuZXh0cmFzLkJpdG1hcFRleHRcbiAgICAgICAgICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAzLjAuMFxuICAgICAgICAgKi9cbiAgICAgICAgQml0bWFwVGV4dDoge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgd2FybignVGhlIEJpdG1hcFRleHQgY2xhc3MgaGFzIGJlZW4gbW92ZWQgdG8gZXh0cmFzLkJpdG1hcFRleHQsICcgKyAncGxlYXNlIHVzZSBleHRyYXMuQml0bWFwVGV4dCBmcm9tIG5vdyBvbi4nKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBleHRyYXMuQml0bWFwVGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQGNsYXNzXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBuYW1lIGJsZW5kTW9kZXNcbiAgICAgICAgICogQG1lbWJlcm9mIFBJWElcbiAgICAgICAgICogQHNlZSBQSVhJLkJMRU5EX01PREVTXG4gICAgICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMy4wLjBcbiAgICAgICAgICovXG4gICAgICAgIGJsZW5kTW9kZXM6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHdhcm4oJ1RoZSBibGVuZE1vZGVzIGhhcyBiZWVuIG1vdmVkIHRvIEJMRU5EX01PREVTLCBwbGVhc2UgdXNlIEJMRU5EX01PREVTIGZyb20gbm93IG9uLicpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvcmUuQkxFTkRfTU9ERVM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBjbGFzc1xuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAbmFtZSBzY2FsZU1vZGVzXG4gICAgICAgICAqIEBtZW1iZXJvZiBQSVhJXG4gICAgICAgICAqIEBzZWUgUElYSS5TQ0FMRV9NT0RFU1xuICAgICAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDMuMC4wXG4gICAgICAgICAqL1xuICAgICAgICBzY2FsZU1vZGVzOiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICB3YXJuKCdUaGUgc2NhbGVNb2RlcyBoYXMgYmVlbiBtb3ZlZCB0byBTQ0FMRV9NT0RFUywgcGxlYXNlIHVzZSBTQ0FMRV9NT0RFUyBmcm9tIG5vdyBvbi4nKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBjb3JlLlNDQUxFX01PREVTO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAY2xhc3NcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQG5hbWUgQmFzZVRleHR1cmVDYWNoZVxuICAgICAgICAgKiBAbWVtYmVyb2YgUElYSVxuICAgICAgICAgKiBAc2VlIFBJWEkudXRpbHMuQmFzZVRleHR1cmVDYWNoZVxuICAgICAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDMuMC4wXG4gICAgICAgICAqL1xuICAgICAgICBCYXNlVGV4dHVyZUNhY2hlOiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICB3YXJuKCdUaGUgQmFzZVRleHR1cmVDYWNoZSBjbGFzcyBoYXMgYmVlbiBtb3ZlZCB0byB1dGlscy5CYXNlVGV4dHVyZUNhY2hlLCAnICsgJ3BsZWFzZSB1c2UgdXRpbHMuQmFzZVRleHR1cmVDYWNoZSBmcm9tIG5vdyBvbi4nKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBjb3JlLnV0aWxzLkJhc2VUZXh0dXJlQ2FjaGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBjbGFzc1xuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAbmFtZSBUZXh0dXJlQ2FjaGVcbiAgICAgICAgICogQG1lbWJlcm9mIFBJWElcbiAgICAgICAgICogQHNlZSBQSVhJLnV0aWxzLlRleHR1cmVDYWNoZVxuICAgICAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDMuMC4wXG4gICAgICAgICAqL1xuICAgICAgICBUZXh0dXJlQ2FjaGU6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHdhcm4oJ1RoZSBUZXh0dXJlQ2FjaGUgY2xhc3MgaGFzIGJlZW4gbW92ZWQgdG8gdXRpbHMuVGV4dHVyZUNhY2hlLCAnICsgJ3BsZWFzZSB1c2UgdXRpbHMuVGV4dHVyZUNhY2hlIGZyb20gbm93IG9uLicpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvcmUudXRpbHMuVGV4dHVyZUNhY2hlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbmFtZXNwYWNlXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBuYW1lIG1hdGhcbiAgICAgICAgICogQG1lbWJlcm9mIFBJWElcbiAgICAgICAgICogQHNlZSBQSVhJXG4gICAgICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMy4wLjZcbiAgICAgICAgICovXG4gICAgICAgIG1hdGg6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHdhcm4oJ1RoZSBtYXRoIG5hbWVzcGFjZSBpcyBkZXByZWNhdGVkLCBwbGVhc2UgYWNjZXNzIG1lbWJlcnMgYWxyZWFkeSBhY2Nlc3NpYmxlIG9uIFBJWEkuJyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gY29yZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQGNsYXNzXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBuYW1lIFBJWEkuQWJzdHJhY3RGaWx0ZXJcbiAgICAgICAgICogQHNlZSBQSVhJLkZpbHRlclxuICAgICAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDMuMC42XG4gICAgICAgICAqL1xuICAgICAgICBBYnN0cmFjdEZpbHRlcjoge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgd2FybignQXN0cmFjdEZpbHRlciBoYXMgYmVlbiByZW5hbWVkIHRvIEZpbHRlciwgcGxlYXNlIHVzZSBQSVhJLkZpbHRlcicpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvcmUuRmlsdGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAY2xhc3NcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQG5hbWUgUElYSS5UcmFuc2Zvcm1NYW51YWxcbiAgICAgICAgICogQHNlZSBQSVhJLlRyYW5zZm9ybUJhc2VcbiAgICAgICAgICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiA0LjAuMFxuICAgICAgICAgKi9cbiAgICAgICAgVHJhbnNmb3JtTWFudWFsOiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICB3YXJuKCdUcmFuc2Zvcm1NYW51YWwgaGFzIGJlZW4gcmVuYW1lZCB0byBUcmFuc2Zvcm1CYXNlLCBwbGVhc2UgdXBkYXRlIHlvdXIgcGl4aS1zcGluZScpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvcmUuVHJhbnNmb3JtQmFzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAY29uc3RhbnRcbiAgICAgICAgICogQG5hbWUgUElYSS5UQVJHRVRfRlBNU1xuICAgICAgICAgKiBAc2VlIFBJWEkuc2V0dGluZ3MuVEFSR0VUX0ZQTVNcbiAgICAgICAgICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiA0LjIuMFxuICAgICAgICAgKi9cbiAgICAgICAgVEFSR0VUX0ZQTVM6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHdhcm4oJ1BJWEkuVEFSR0VUX0ZQTVMgaGFzIGJlZW4gZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBQSVhJLnNldHRpbmdzLlRBUkdFVF9GUE1TJyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gY29yZS5zZXR0aW5ncy5UQVJHRVRfRlBNUztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHdhcm4oJ1BJWEkuVEFSR0VUX0ZQTVMgaGFzIGJlZW4gZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBQSVhJLnNldHRpbmdzLlRBUkdFVF9GUE1TJyk7XG5cbiAgICAgICAgICAgICAgICBjb3JlLnNldHRpbmdzLlRBUkdFVF9GUE1TID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQGNvbnN0YW50XG4gICAgICAgICAqIEBuYW1lIFBJWEkuRklMVEVSX1JFU09MVVRJT05cbiAgICAgICAgICogQHNlZSBQSVhJLnNldHRpbmdzLkZJTFRFUl9SRVNPTFVUSU9OXG4gICAgICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gNC4yLjBcbiAgICAgICAgICovXG4gICAgICAgIEZJTFRFUl9SRVNPTFVUSU9OOiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICB3YXJuKCdQSVhJLkZJTFRFUl9SRVNPTFVUSU9OIGhhcyBiZWVuIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgUElYSS5zZXR0aW5ncy5GSUxURVJfUkVTT0xVVElPTicpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvcmUuc2V0dGluZ3MuRklMVEVSX1JFU09MVVRJT047XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgICAgICAgICB3YXJuKCdQSVhJLkZJTFRFUl9SRVNPTFVUSU9OIGhhcyBiZWVuIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgUElYSS5zZXR0aW5ncy5GSUxURVJfUkVTT0xVVElPTicpO1xuXG4gICAgICAgICAgICAgICAgY29yZS5zZXR0aW5ncy5GSUxURVJfUkVTT0xVVElPTiA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBjb25zdGFudFxuICAgICAgICAgKiBAbmFtZSBQSVhJLlJFU09MVVRJT05cbiAgICAgICAgICogQHNlZSBQSVhJLnNldHRpbmdzLlJFU09MVVRJT05cbiAgICAgICAgICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiA0LjIuMFxuICAgICAgICAgKi9cbiAgICAgICAgUkVTT0xVVElPTjoge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgd2FybignUElYSS5SRVNPTFVUSU9OIGhhcyBiZWVuIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgUElYSS5zZXR0aW5ncy5SRVNPTFVUSU9OJyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gY29yZS5zZXR0aW5ncy5SRVNPTFVUSU9OO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgd2FybignUElYSS5SRVNPTFVUSU9OIGhhcyBiZWVuIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgUElYSS5zZXR0aW5ncy5SRVNPTFVUSU9OJyk7XG5cbiAgICAgICAgICAgICAgICBjb3JlLnNldHRpbmdzLlJFU09MVVRJT04gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAY29uc3RhbnRcbiAgICAgICAgICogQG5hbWUgUElYSS5NSVBNQVBfVEVYVFVSRVNcbiAgICAgICAgICogQHNlZSBQSVhJLnNldHRpbmdzLk1JUE1BUF9URVhUVVJFU1xuICAgICAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDQuMi4wXG4gICAgICAgICAqL1xuICAgICAgICBNSVBNQVBfVEVYVFVSRVM6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHdhcm4oJ1BJWEkuTUlQTUFQX1RFWFRVUkVTIGhhcyBiZWVuIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgUElYSS5zZXR0aW5ncy5NSVBNQVBfVEVYVFVSRVMnKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBjb3JlLnNldHRpbmdzLk1JUE1BUF9URVhUVVJFUztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHdhcm4oJ1BJWEkuTUlQTUFQX1RFWFRVUkVTIGhhcyBiZWVuIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgUElYSS5zZXR0aW5ncy5NSVBNQVBfVEVYVFVSRVMnKTtcblxuICAgICAgICAgICAgICAgIGNvcmUuc2V0dGluZ3MuTUlQTUFQX1RFWFRVUkVTID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQGNvbnN0YW50XG4gICAgICAgICAqIEBuYW1lIFBJWEkuU1BSSVRFX0JBVENIX1NJWkVcbiAgICAgICAgICogQHNlZSBQSVhJLnNldHRpbmdzLlNQUklURV9CQVRDSF9TSVpFXG4gICAgICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gNC4yLjBcbiAgICAgICAgICovXG4gICAgICAgIFNQUklURV9CQVRDSF9TSVpFOiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICB3YXJuKCdQSVhJLlNQUklURV9CQVRDSF9TSVpFIGhhcyBiZWVuIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgUElYSS5zZXR0aW5ncy5TUFJJVEVfQkFUQ0hfU0laRScpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvcmUuc2V0dGluZ3MuU1BSSVRFX0JBVENIX1NJWkU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgICAgICAgICB3YXJuKCdQSVhJLlNQUklURV9CQVRDSF9TSVpFIGhhcyBiZWVuIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgUElYSS5zZXR0aW5ncy5TUFJJVEVfQkFUQ0hfU0laRScpO1xuXG4gICAgICAgICAgICAgICAgY29yZS5zZXR0aW5ncy5TUFJJVEVfQkFUQ0hfU0laRSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBjb25zdGFudFxuICAgICAgICAgKiBAbmFtZSBQSVhJLlNQUklURV9NQVhfVEVYVFVSRVNcbiAgICAgICAgICogQHNlZSBQSVhJLnNldHRpbmdzLlNQUklURV9NQVhfVEVYVFVSRVNcbiAgICAgICAgICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiA0LjIuMFxuICAgICAgICAgKi9cbiAgICAgICAgU1BSSVRFX01BWF9URVhUVVJFUzoge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgd2FybignUElYSS5TUFJJVEVfTUFYX1RFWFRVUkVTIGhhcyBiZWVuIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgUElYSS5zZXR0aW5ncy5TUFJJVEVfTUFYX1RFWFRVUkVTJyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gY29yZS5zZXR0aW5ncy5TUFJJVEVfTUFYX1RFWFRVUkVTO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgd2FybignUElYSS5TUFJJVEVfTUFYX1RFWFRVUkVTIGhhcyBiZWVuIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgUElYSS5zZXR0aW5ncy5TUFJJVEVfTUFYX1RFWFRVUkVTJyk7XG5cbiAgICAgICAgICAgICAgICBjb3JlLnNldHRpbmdzLlNQUklURV9NQVhfVEVYVFVSRVMgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAY29uc3RhbnRcbiAgICAgICAgICogQG5hbWUgUElYSS5SRVRJTkFfUFJFRklYXG4gICAgICAgICAqIEBzZWUgUElYSS5zZXR0aW5ncy5SRVRJTkFfUFJFRklYXG4gICAgICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gNC4yLjBcbiAgICAgICAgICovXG4gICAgICAgIFJFVElOQV9QUkVGSVg6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHdhcm4oJ1BJWEkuUkVUSU5BX1BSRUZJWCBoYXMgYmVlbiBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIFBJWEkuc2V0dGluZ3MuUkVUSU5BX1BSRUZJWCcpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvcmUuc2V0dGluZ3MuUkVUSU5BX1BSRUZJWDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHdhcm4oJ1BJWEkuUkVUSU5BX1BSRUZJWCBoYXMgYmVlbiBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIFBJWEkuc2V0dGluZ3MuUkVUSU5BX1BSRUZJWCcpO1xuXG4gICAgICAgICAgICAgICAgY29yZS5zZXR0aW5ncy5SRVRJTkFfUFJFRklYID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQGNvbnN0YW50XG4gICAgICAgICAqIEBuYW1lIFBJWEkuREVGQVVMVF9SRU5ERVJfT1BUSU9OU1xuICAgICAgICAgKiBAc2VlIFBJWEkuc2V0dGluZ3MuUkVOREVSX09QVElPTlNcbiAgICAgICAgICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiA0LjIuMFxuICAgICAgICAgKi9cbiAgICAgICAgREVGQVVMVF9SRU5ERVJfT1BUSU9OUzoge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgd2FybignUElYSS5ERUZBVUxUX1JFTkRFUl9PUFRJT05TIGhhcyBiZWVuIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgUElYSS5zZXR0aW5ncy5ERUZBVUxUX1JFTkRFUl9PUFRJT05TJyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gY29yZS5zZXR0aW5ncy5SRU5ERVJfT1BUSU9OUztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gTW92ZSB0aGUgZGVmYXVsdCBwcm9wZXJ0aWVzIHRvIHNldHRpbmdzXG4gICAgdmFyIGRlZmF1bHRzID0gW3sgcGFyZW50OiAnVFJBTlNGT1JNX01PREUnLCB0YXJnZXQ6ICdUUkFOU0ZPUk1fTU9ERScgfSwgeyBwYXJlbnQ6ICdHQ19NT0RFUycsIHRhcmdldDogJ0dDX01PREUnIH0sIHsgcGFyZW50OiAnV1JBUF9NT0RFUycsIHRhcmdldDogJ1dSQVBfTU9ERScgfSwgeyBwYXJlbnQ6ICdTQ0FMRV9NT0RFUycsIHRhcmdldDogJ1NDQUxFX01PREUnIH0sIHsgcGFyZW50OiAnUFJFQ0lTSU9OJywgdGFyZ2V0OiAnUFJFQ0lTSU9OX0ZSQUdNRU5UJyB9XTtcblxuICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKGkpIHtcbiAgICAgICAgdmFyIGRlcHJlY2F0aW9uID0gZGVmYXVsdHNbaV07XG5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvcmVbZGVwcmVjYXRpb24ucGFyZW50XSwgJ0RFRkFVTFQnLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICB3YXJuKCdQSVhJLicgKyBkZXByZWNhdGlvbi5wYXJlbnQgKyAnLkRFRkFVTFQgaGFzIGJlZW4gZGVwcmVjYXRlZCwgJyArICgncGxlYXNlIHVzZSBQSVhJLnNldHRpbmdzLicgKyBkZXByZWNhdGlvbi50YXJnZXQpKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBjb3JlLnNldHRpbmdzW2RlcHJlY2F0aW9uLnRhcmdldF07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgICAgICAgICB3YXJuKCdQSVhJLicgKyBkZXByZWNhdGlvbi5wYXJlbnQgKyAnLkRFRkFVTFQgaGFzIGJlZW4gZGVwcmVjYXRlZCwgJyArICgncGxlYXNlIHVzZSBQSVhJLnNldHRpbmdzLicgKyBkZXByZWNhdGlvbi50YXJnZXQpKTtcblxuICAgICAgICAgICAgICAgIGNvcmUuc2V0dGluZ3NbZGVwcmVjYXRpb24udGFyZ2V0XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWZhdWx0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBfbG9vcChpKTtcbiAgICB9XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb3JlLnNldHRpbmdzLCB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQG5hbWUgUFJFQ0lTSU9OXG4gICAgICAgICAqIEBtZW1iZXJvZiBQSVhJLnNldHRpbmdzXG4gICAgICAgICAqIEBzZWUgUElYSS5QUkVDSVNJT05cbiAgICAgICAgICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiA0LjQuMFxuICAgICAgICAgKi9cbiAgICAgICAgUFJFQ0lTSU9OOiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICB3YXJuKCdQSVhJLnNldHRpbmdzLlBSRUNJU0lPTiBoYXMgYmVlbiBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIFBJWEkuc2V0dGluZ3MuUFJFQ0lTSU9OX0ZSQUdNRU5UJyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gY29yZS5zZXR0aW5ncy5QUkVDSVNJT05fRlJBR01FTlQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgICAgICAgICB3YXJuKCdQSVhJLnNldHRpbmdzLlBSRUNJU0lPTiBoYXMgYmVlbiBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIFBJWEkuc2V0dGluZ3MuUFJFQ0lTSU9OX0ZSQUdNRU5UJyk7XG5cbiAgICAgICAgICAgICAgICBjb3JlLnNldHRpbmdzLlBSRUNJU0lPTl9GUkFHTUVOVCA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoZXh0cmFzLkFuaW1hdGVkU3ByaXRlKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGV4dHJhcywge1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBjbGFzc1xuICAgICAgICAgICAgICogQG5hbWUgTW92aWVDbGlwXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2YgUElYSS5leHRyYXNcbiAgICAgICAgICAgICAqIEBzZWUgUElYSS5leHRyYXMuQW5pbWF0ZWRTcHJpdGVcbiAgICAgICAgICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gNC4yLjBcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgTW92aWVDbGlwOiB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgIHdhcm4oJ1RoZSBNb3ZpZUNsaXAgY2xhc3MgaGFzIGJlZW4gcmVuYW1lZCB0byBBbmltYXRlZFNwcml0ZSwgcGxlYXNlIHVzZSBBbmltYXRlZFNwcml0ZSBmcm9tIG5vdyBvbi4nKTtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXh0cmFzLkFuaW1hdGVkU3ByaXRlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGV4dHJhcykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhleHRyYXMsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQGNsYXNzXG4gICAgICAgICAgICAgKiBAbmFtZSBUZXh0dXJlVHJhbnNmb3JtXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2YgUElYSS5leHRyYXNcbiAgICAgICAgICAgICAqIEBzZWUgUElYSS5UZXh0dXJlTWF0cml4XG4gICAgICAgICAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDQuNi4wXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFRleHR1cmVUcmFuc2Zvcm06IHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgd2FybignVGhlIFRleHR1cmVUcmFuc2Zvcm0gY2xhc3MgaGFzIGJlZW4gcmVuYW1lZCB0byBUZXh0dXJlTWF0cml4LCAnICsgJ3BsZWFzZSB1c2UgUElYSS5UZXh0dXJlTWF0cml4IGZyb20gbm93IG9uLicpO1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb3JlLlRleHR1cmVNYXRyaXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBjb3JlLkRpc3BsYXlPYmplY3QucHJvdG90eXBlLmdlbmVyYXRlVGV4dHVyZSA9IGZ1bmN0aW9uIGdlbmVyYXRlVGV4dHVyZShyZW5kZXJlciwgc2NhbGVNb2RlLCByZXNvbHV0aW9uKSB7XG4gICAgICAgIHdhcm4oJ2dlbmVyYXRlVGV4dHVyZSBoYXMgbW92ZWQgdG8gdGhlIHJlbmRlcmVyLCBwbGVhc2UgdXNlIHJlbmRlcmVyLmdlbmVyYXRlVGV4dHVyZShkaXNwbGF5T2JqZWN0KScpO1xuXG4gICAgICAgIHJldHVybiByZW5kZXJlci5nZW5lcmF0ZVRleHR1cmUodGhpcywgc2NhbGVNb2RlLCByZXNvbHV0aW9uKTtcbiAgICB9O1xuXG4gICAgY29yZS5HcmFwaGljcy5wcm90b3R5cGUuZ2VuZXJhdGVUZXh0dXJlID0gZnVuY3Rpb24gZ2VuZXJhdGVUZXh0dXJlKHNjYWxlTW9kZSwgcmVzb2x1dGlvbikge1xuICAgICAgICB3YXJuKCdncmFwaGljcyBnZW5lcmF0ZSB0ZXh0dXJlIGhhcyBtb3ZlZCB0byB0aGUgcmVuZGVyZXIuICcgKyAnT3IgdG8gcmVuZGVyIGEgZ3JhcGhpY3MgdG8gYSB0ZXh0dXJlIHVzaW5nIGNhbnZhcyBwbGVhc2UgdXNlIGdlbmVyYXRlQ2FudmFzVGV4dHVyZScpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRlQ2FudmFzVGV4dHVyZShzY2FsZU1vZGUsIHJlc29sdXRpb24pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG5hbWUgUElYSS5Hcm91cEQ4LmlzU3dhcFdpZHRoSGVpZ2h0XG4gICAgICogQHNlZSBQSVhJLkdyb3VwRDguaXNWZXJ0aWNhbFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByb3RhdGlvbiAtIFRoZSBudW1iZXIgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSBkaXJlY3Rpb24gaXMgdmVydGljYWxcbiAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDQuNi4wXG4gICAgICovXG4gICAgY29yZS5Hcm91cEQ4LmlzU3dhcFdpZHRoSGVpZ2h0ID0gZnVuY3Rpb24gaXNTd2FwV2lkdGhIZWlnaHQocm90YXRpb24pIHtcbiAgICAgICAgd2FybignR3JvdXBEOC5pc1N3YXBXaWR0aEhlaWdodCB3YXMgcmVuYW1lZCB0byBHcm91cEQ4LmlzVmVydGljYWwnKTtcblxuICAgICAgICByZXR1cm4gY29yZS5Hcm91cEQ4LmlzVmVydGljYWwocm90YXRpb24pO1xuICAgIH07XG5cbiAgICBjb3JlLlJlbmRlclRleHR1cmUucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcihkaXNwbGF5T2JqZWN0LCBtYXRyaXgsIGNsZWFyLCB1cGRhdGVUcmFuc2Zvcm0pIHtcbiAgICAgICAgdGhpcy5sZWdhY3lSZW5kZXJlci5yZW5kZXIoZGlzcGxheU9iamVjdCwgdGhpcywgY2xlYXIsIG1hdHJpeCwgIXVwZGF0ZVRyYW5zZm9ybSk7XG4gICAgICAgIHdhcm4oJ1JlbmRlclRleHR1cmUucmVuZGVyIGlzIG5vdyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIHJlbmRlcmVyLnJlbmRlcihkaXNwbGF5T2JqZWN0LCByZW5kZXJUZXh0dXJlKScpO1xuICAgIH07XG5cbiAgICBjb3JlLlJlbmRlclRleHR1cmUucHJvdG90eXBlLmdldEltYWdlID0gZnVuY3Rpb24gZ2V0SW1hZ2UodGFyZ2V0KSB7XG4gICAgICAgIHdhcm4oJ1JlbmRlclRleHR1cmUuZ2V0SW1hZ2UgaXMgbm93IGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgcmVuZGVyZXIuZXh0cmFjdC5pbWFnZSh0YXJnZXQpJyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMubGVnYWN5UmVuZGVyZXIuZXh0cmFjdC5pbWFnZSh0YXJnZXQpO1xuICAgIH07XG5cbiAgICBjb3JlLlJlbmRlclRleHR1cmUucHJvdG90eXBlLmdldEJhc2U2NCA9IGZ1bmN0aW9uIGdldEJhc2U2NCh0YXJnZXQpIHtcbiAgICAgICAgd2FybignUmVuZGVyVGV4dHVyZS5nZXRCYXNlNjQgaXMgbm93IGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgcmVuZGVyZXIuZXh0cmFjdC5iYXNlNjQodGFyZ2V0KScpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmxlZ2FjeVJlbmRlcmVyLmV4dHJhY3QuYmFzZTY0KHRhcmdldCk7XG4gICAgfTtcblxuICAgIGNvcmUuUmVuZGVyVGV4dHVyZS5wcm90b3R5cGUuZ2V0Q2FudmFzID0gZnVuY3Rpb24gZ2V0Q2FudmFzKHRhcmdldCkge1xuICAgICAgICB3YXJuKCdSZW5kZXJUZXh0dXJlLmdldENhbnZhcyBpcyBub3cgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSByZW5kZXJlci5leHRyYWN0LmNhbnZhcyh0YXJnZXQpJyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMubGVnYWN5UmVuZGVyZXIuZXh0cmFjdC5jYW52YXModGFyZ2V0KTtcbiAgICB9O1xuXG4gICAgY29yZS5SZW5kZXJUZXh0dXJlLnByb3RvdHlwZS5nZXRQaXhlbHMgPSBmdW5jdGlvbiBnZXRQaXhlbHModGFyZ2V0KSB7XG4gICAgICAgIHdhcm4oJ1JlbmRlclRleHR1cmUuZ2V0UGl4ZWxzIGlzIG5vdyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIHJlbmRlcmVyLmV4dHJhY3QucGl4ZWxzKHRhcmdldCknKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5sZWdhY3lSZW5kZXJlci5waXhlbHModGFyZ2V0KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgUElYSS5TcHJpdGUjc2V0VGV4dHVyZVxuICAgICAqIEBzZWUgUElYSS5TcHJpdGUjdGV4dHVyZVxuICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMy4wLjBcbiAgICAgKiBAcGFyYW0ge1BJWEkuVGV4dHVyZX0gdGV4dHVyZSAtIFRoZSB0ZXh0dXJlIHRvIHNldCB0by5cbiAgICAgKi9cbiAgICBjb3JlLlNwcml0ZS5wcm90b3R5cGUuc2V0VGV4dHVyZSA9IGZ1bmN0aW9uIHNldFRleHR1cmUodGV4dHVyZSkge1xuICAgICAgICB0aGlzLnRleHR1cmUgPSB0ZXh0dXJlO1xuICAgICAgICB3YXJuKCdzZXRUZXh0dXJlIGlzIG5vdyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIHRoZSB0ZXh0dXJlIHByb3BlcnR5LCBlLmcgOiBzcHJpdGUudGV4dHVyZSA9IHRleHR1cmU7Jyk7XG4gICAgfTtcblxuICAgIGlmIChleHRyYXMuQml0bWFwVGV4dCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbmFtZSBQSVhJLmV4dHJhcy5CaXRtYXBUZXh0I3NldFRleHRcbiAgICAgICAgICogQHNlZSBQSVhJLmV4dHJhcy5CaXRtYXBUZXh0I3RleHRcbiAgICAgICAgICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAzLjAuMFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIFRoZSB0ZXh0IHRvIHNldCB0by5cbiAgICAgICAgICovXG4gICAgICAgIGV4dHJhcy5CaXRtYXBUZXh0LnByb3RvdHlwZS5zZXRUZXh0ID0gZnVuY3Rpb24gc2V0VGV4dCh0ZXh0KSB7XG4gICAgICAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgICAgICAgICAgd2Fybignc2V0VGV4dCBpcyBub3cgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSB0aGUgdGV4dCBwcm9wZXJ0eSwgZS5nIDogbXlCaXRtYXBUZXh0LnRleHQgPSBcXCdteSB0ZXh0XFwnOycpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbmFtZSBQSVhJLlRleHQjc2V0VGV4dFxuICAgICAqIEBzZWUgUElYSS5UZXh0I3RleHRcbiAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDMuMC4wXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSBUaGUgdGV4dCB0byBzZXQgdG8uXG4gICAgICovXG4gICAgY29yZS5UZXh0LnByb3RvdHlwZS5zZXRUZXh0ID0gZnVuY3Rpb24gc2V0VGV4dCh0ZXh0KSB7XG4gICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgICAgIHdhcm4oJ3NldFRleHQgaXMgbm93IGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgdGhlIHRleHQgcHJvcGVydHksIGUuZyA6IG15VGV4dC50ZXh0ID0gXFwnbXkgdGV4dFxcJzsnKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgYXNjZW50LCBkZXNjZW50IGFuZCBmb250U2l6ZSBvZiBhIGdpdmVuIGZvbnRTdHlsZVxuICAgICAqXG4gICAgICogQG5hbWUgUElYSS5UZXh0LmNhbGN1bGF0ZUZvbnRQcm9wZXJ0aWVzXG4gICAgICogQHNlZSBQSVhJLlRleHRNZXRyaWNzLm1lYXN1cmVGb250XG4gICAgICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiA0LjUuMFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmb250IC0gU3RyaW5nIHJlcHJlc2VudGluZyB0aGUgc3R5bGUgb2YgdGhlIGZvbnRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEZvbnQgcHJvcGVydGllcyBvYmplY3RcbiAgICAgKi9cbiAgICBjb3JlLlRleHQuY2FsY3VsYXRlRm9udFByb3BlcnRpZXMgPSBmdW5jdGlvbiBjYWxjdWxhdGVGb250UHJvcGVydGllcyhmb250KSB7XG4gICAgICAgIHdhcm4oJ1RleHQuY2FsY3VsYXRlRm9udFByb3BlcnRpZXMgaXMgbm93IGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgdGhlIFRleHRNZXRyaWNzLm1lYXN1cmVGb250Jyk7XG5cbiAgICAgICAgcmV0dXJuIGNvcmUuVGV4dE1ldHJpY3MubWVhc3VyZUZvbnQoZm9udCk7XG4gICAgfTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvcmUuVGV4dCwge1xuICAgICAgICBmb250UHJvcGVydGllc0NhY2hlOiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICB3YXJuKCdUZXh0LmZvbnRQcm9wZXJ0aWVzQ2FjaGUgaXMgZGVwcmVjYXRlZCcpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvcmUuVGV4dE1ldHJpY3MuX2ZvbnRzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBmb250UHJvcGVydGllc0NhbnZhczoge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgd2FybignVGV4dC5mb250UHJvcGVydGllc0NhbnZhcyBpcyBkZXByZWNhdGVkJyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gY29yZS5UZXh0TWV0cmljcy5fY2FudmFzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBmb250UHJvcGVydGllc0NvbnRleHQ6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHdhcm4oJ1RleHQuZm9udFByb3BlcnRpZXNDb250ZXh0IGlzIGRlcHJlY2F0ZWQnKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBjb3JlLlRleHRNZXRyaWNzLl9jb250ZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG5hbWUgUElYSS5UZXh0I3NldFN0eWxlXG4gICAgICogQHNlZSBQSVhJLlRleHQjc3R5bGVcbiAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDMuMC4wXG4gICAgICogQHBhcmFtIHsqfSBzdHlsZSAtIFRoZSBzdHlsZSB0byBzZXQgdG8uXG4gICAgICovXG4gICAgY29yZS5UZXh0LnByb3RvdHlwZS5zZXRTdHlsZSA9IGZ1bmN0aW9uIHNldFN0eWxlKHN0eWxlKSB7XG4gICAgICAgIHRoaXMuc3R5bGUgPSBzdHlsZTtcbiAgICAgICAgd2Fybignc2V0U3R5bGUgaXMgbm93IGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgdGhlIHN0eWxlIHByb3BlcnR5LCBlLmcgOiBteVRleHQuc3R5bGUgPSBzdHlsZTsnKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBuYW1lIFBJWEkuVGV4dCNkZXRlcm1pbmVGb250UHJvcGVydGllc1xuICAgICAqIEBzZWUgUElYSS5UZXh0I21lYXN1cmVGb250UHJvcGVydGllc1xuICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gNC4yLjBcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmb250U3R5bGUgLSBTdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBzdHlsZSBvZiB0aGUgZm9udFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gRm9udCBwcm9wZXJ0aWVzIG9iamVjdFxuICAgICAqL1xuICAgIGNvcmUuVGV4dC5wcm90b3R5cGUuZGV0ZXJtaW5lRm9udFByb3BlcnRpZXMgPSBmdW5jdGlvbiBkZXRlcm1pbmVGb250UHJvcGVydGllcyhmb250U3R5bGUpIHtcbiAgICAgICAgd2FybignZGV0ZXJtaW5lRm9udFByb3BlcnRpZXMgaXMgbm93IGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgVGV4dE1ldHJpY3MubWVhc3VyZUZvbnQgbWV0aG9kJyk7XG5cbiAgICAgICAgcmV0dXJuIGNvcmUuVGV4dE1ldHJpY3MubWVhc3VyZUZvbnQoZm9udFN0eWxlKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBuYW1lIFBJWEkuVGV4dC5nZXRGb250U3R5bGVcbiAgICAgKiBAc2VlIFBJWEkuVGV4dE1ldHJpY3MuZ2V0Rm9udFN0eWxlXG4gICAgICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiA0LjUuMFxuICAgICAqIEBwYXJhbSB7UElYSS5UZXh0U3R5bGV9IHN0eWxlIC0gVGhlIHN0eWxlIHRvIHVzZS5cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IEZvbnQgc3RyaW5nXG4gICAgICovXG4gICAgY29yZS5UZXh0LmdldEZvbnRTdHlsZSA9IGZ1bmN0aW9uIGdldEZvbnRTdHlsZShzdHlsZSkge1xuICAgICAgICB3YXJuKCdnZXRGb250U3R5bGUgaXMgbm93IGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgVGV4dFN0eWxlLnRvRm9udFN0cmluZygpIGluc3RlYWQnKTtcblxuICAgICAgICBzdHlsZSA9IHN0eWxlIHx8IHt9O1xuXG4gICAgICAgIGlmICghKHN0eWxlIGluc3RhbmNlb2YgY29yZS5UZXh0U3R5bGUpKSB7XG4gICAgICAgICAgICBzdHlsZSA9IG5ldyBjb3JlLlRleHRTdHlsZShzdHlsZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3R5bGUudG9Gb250U3RyaW5nKCk7XG4gICAgfTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvcmUuVGV4dFN0eWxlLnByb3RvdHlwZSwge1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IGFsbCBwcm9wZXJ0aWVzIG9mIGEgZm9udCBhcyBhIHNpbmdsZSBzdHJpbmdcbiAgICAgICAgICpcbiAgICAgICAgICogQG5hbWUgUElYSS5UZXh0U3R5bGUjZm9udFxuICAgICAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDQuMC4wXG4gICAgICAgICAqL1xuICAgICAgICBmb250OiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICB3YXJuKCd0ZXh0IHN0eWxlIHByb3BlcnR5IFxcJ2ZvbnRcXCcgaXMgbm93IGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgdGhlICcgKyAnXFwnZm9udEZhbWlseVxcJywgXFwnZm9udFNpemVcXCcsIFxcJ2ZvbnRTdHlsZVxcJywgXFwnZm9udFZhcmlhbnRcXCcgYW5kIFxcJ2ZvbnRXZWlnaHRcXCcgcHJvcGVydGllcyBmcm9tIG5vdyBvbicpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGZvbnRTaXplU3RyaW5nID0gdHlwZW9mIHRoaXMuX2ZvbnRTaXplID09PSAnbnVtYmVyJyA/IHRoaXMuX2ZvbnRTaXplICsgJ3B4JyA6IHRoaXMuX2ZvbnRTaXplO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZvbnRTdHlsZSArICcgJyArIHRoaXMuX2ZvbnRWYXJpYW50ICsgJyAnICsgdGhpcy5fZm9udFdlaWdodCArICcgJyArIGZvbnRTaXplU3RyaW5nICsgJyAnICsgdGhpcy5fZm9udEZhbWlseTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChmb250KSB7XG4gICAgICAgICAgICAgICAgd2FybigndGV4dCBzdHlsZSBwcm9wZXJ0eSBcXCdmb250XFwnIGlzIG5vdyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIHRoZSAnICsgJ1xcJ2ZvbnRGYW1pbHlcXCcsXFwnZm9udFNpemVcXCcsZm9udFN0eWxlXFwnLFxcJ2ZvbnRWYXJpYW50XFwnIGFuZCBcXCdmb250V2VpZ2h0XFwnIHByb3BlcnRpZXMgZnJvbSBub3cgb24nKTtcblxuICAgICAgICAgICAgICAgIC8vIGNhbiB3b3JrIG91dCBmb250U3R5bGUgZnJvbSBzZWFyY2ggb2Ygd2hvbGUgc3RyaW5nXG4gICAgICAgICAgICAgICAgaWYgKGZvbnQuaW5kZXhPZignaXRhbGljJykgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZvbnRTdHlsZSA9ICdpdGFsaWMnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZm9udC5pbmRleE9mKCdvYmxpcXVlJykgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9mb250U3R5bGUgPSAnb2JsaXF1ZSc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZm9udFN0eWxlID0gJ25vcm1hbCc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gY2FuIHdvcmsgb3V0IGZvbnRWYXJpYW50IGZyb20gc2VhcmNoIG9mIHdob2xlIHN0cmluZ1xuICAgICAgICAgICAgICAgIGlmIChmb250LmluZGV4T2YoJ3NtYWxsLWNhcHMnKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZvbnRWYXJpYW50ID0gJ3NtYWxsLWNhcHMnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZvbnRWYXJpYW50ID0gJ25vcm1hbCc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gZm9udFdlaWdodCBhbmQgZm9udEZhbWlseSBhcmUgdHJpY2tlciB0byBmaW5kLCBidXQgaXQncyBlYXNpZXIgdG8gZmluZCB0aGUgZm9udFNpemUgZHVlIHRvIGl0J3MgdW5pdHNcbiAgICAgICAgICAgICAgICB2YXIgc3BsaXRzID0gZm9udC5zcGxpdCgnICcpO1xuICAgICAgICAgICAgICAgIHZhciBmb250U2l6ZUluZGV4ID0gLTE7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9mb250U2l6ZSA9IDI2O1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3BsaXRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzcGxpdHNbaV0ubWF0Y2goLyhweHxwdHxlbXwlKS8pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb250U2l6ZUluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZvbnRTaXplID0gc3BsaXRzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyB3ZSBjYW4gbm93IHNlYXJjaCBmb3IgZm9udFdlaWdodCBhcyB3ZSBrbm93IGl0IG11c3Qgb2NjdXIgYmVmb3JlIHRoZSBmb250U2l6ZVxuICAgICAgICAgICAgICAgIHRoaXMuX2ZvbnRXZWlnaHQgPSAnbm9ybWFsJztcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgZm9udFNpemVJbmRleDsgKytfaSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3BsaXRzW19pXS5tYXRjaCgvKGJvbGR8Ym9sZGVyfGxpZ2h0ZXJ8MTAwfDIwMHwzMDB8NDAwfDUwMHw2MDB8NzAwfDgwMHw5MDApLykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZvbnRXZWlnaHQgPSBzcGxpdHNbX2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBhbmQgZmluYWxseSBqb2luIGV2ZXJ5dGhpbmcgdG9nZXRoZXIgYWZ0ZXIgdGhlIGZvbnRTaXplIGluIGNhc2UgdGhlIGZvbnQgZmFtaWx5IGhhcyBtdWx0aXBsZSB3b3Jkc1xuICAgICAgICAgICAgICAgIGlmIChmb250U2l6ZUluZGV4ID4gLTEgJiYgZm9udFNpemVJbmRleCA8IHNwbGl0cy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZvbnRGYW1pbHkgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kyID0gZm9udFNpemVJbmRleCArIDE7IF9pMiA8IHNwbGl0cy5sZW5ndGg7ICsrX2kyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9mb250RmFtaWx5ICs9IHNwbGl0c1tfaTJdICsgJyAnO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZm9udEZhbWlseSA9IHRoaXMuX2ZvbnRGYW1pbHkuc2xpY2UoMCwgLTEpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZvbnRGYW1pbHkgPSAnQXJpYWwnO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuc3R5bGVJRCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG5hbWUgUElYSS5UZXh0dXJlI3NldEZyYW1lXG4gICAgICogQHNlZSBQSVhJLlRleHR1cmUjc2V0RnJhbWVcbiAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDMuMC4wXG4gICAgICogQHBhcmFtIHtQSVhJLlJlY3RhbmdsZX0gZnJhbWUgLSBUaGUgZnJhbWUgdG8gc2V0LlxuICAgICAqL1xuICAgIGNvcmUuVGV4dHVyZS5wcm90b3R5cGUuc2V0RnJhbWUgPSBmdW5jdGlvbiBzZXRGcmFtZShmcmFtZSkge1xuICAgICAgICB0aGlzLmZyYW1lID0gZnJhbWU7XG4gICAgICAgIHdhcm4oJ3NldEZyYW1lIGlzIG5vdyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIHRoZSBmcmFtZSBwcm9wZXJ0eSwgZS5nOiBteVRleHR1cmUuZnJhbWUgPSBmcmFtZTsnKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBuYW1lIFBJWEkuVGV4dHVyZS5hZGRUZXh0dXJlVG9DYWNoZVxuICAgICAqIEBzZWUgUElYSS5UZXh0dXJlLmFkZFRvQ2FjaGVcbiAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSA0LjUuMFxuICAgICAqIEBwYXJhbSB7UElYSS5UZXh0dXJlfSB0ZXh0dXJlIC0gVGhlIFRleHR1cmUgdG8gYWRkIHRvIHRoZSBjYWNoZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgLSBUaGUgaWQgdGhhdCB0aGUgdGV4dHVyZSB3aWxsIGJlIHN0b3JlZCBhZ2FpbnN0LlxuICAgICAqL1xuICAgIGNvcmUuVGV4dHVyZS5hZGRUZXh0dXJlVG9DYWNoZSA9IGZ1bmN0aW9uIGFkZFRleHR1cmVUb0NhY2hlKHRleHR1cmUsIGlkKSB7XG4gICAgICAgIGNvcmUuVGV4dHVyZS5hZGRUb0NhY2hlKHRleHR1cmUsIGlkKTtcbiAgICAgICAgd2FybignVGV4dHVyZS5hZGRUZXh0dXJlVG9DYWNoZSBpcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIFRleHR1cmUuYWRkVG9DYWNoZSBmcm9tIG5vdyBvbi4nKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBuYW1lIFBJWEkuVGV4dHVyZS5yZW1vdmVUZXh0dXJlRnJvbUNhY2hlXG4gICAgICogQHNlZSBQSVhJLlRleHR1cmUucmVtb3ZlRnJvbUNhY2hlXG4gICAgICogQGRlcHJlY2F0ZWQgc2luY2UgNC41LjBcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgLSBUaGUgaWQgb2YgdGhlIHRleHR1cmUgdG8gYmUgcmVtb3ZlZFxuICAgICAqIEByZXR1cm4ge1BJWEkuVGV4dHVyZXxudWxsfSBUaGUgdGV4dHVyZSB0aGF0IHdhcyByZW1vdmVkXG4gICAgICovXG4gICAgY29yZS5UZXh0dXJlLnJlbW92ZVRleHR1cmVGcm9tQ2FjaGUgPSBmdW5jdGlvbiByZW1vdmVUZXh0dXJlRnJvbUNhY2hlKGlkKSB7XG4gICAgICAgIHdhcm4oJ1RleHR1cmUucmVtb3ZlVGV4dHVyZUZyb21DYWNoZSBpcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIFRleHR1cmUucmVtb3ZlRnJvbUNhY2hlIGZyb20gbm93IG9uLiAnICsgJ0JlIGF3YXJlIHRoYXQgVGV4dHVyZS5yZW1vdmVGcm9tQ2FjaGUgZG9lcyBub3QgYXV0b21hdGljYWxseSBpdHMgQmFzZVRleHR1cmUgZnJvbSB0aGUgQmFzZVRleHR1cmVDYWNoZS4gJyArICdGb3IgdGhhdCwgdXNlIEJhc2VUZXh0dXJlLnJlbW92ZUZyb21DYWNoZScpO1xuXG4gICAgICAgIGNvcmUuQmFzZVRleHR1cmUucmVtb3ZlRnJvbUNhY2hlKGlkKTtcblxuICAgICAgICByZXR1cm4gY29yZS5UZXh0dXJlLnJlbW92ZUZyb21DYWNoZShpZCk7XG4gICAgfTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGZpbHRlcnMsIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQGNsYXNzXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBuYW1lIFBJWEkuZmlsdGVycy5BYnN0cmFjdEZpbHRlclxuICAgICAgICAgKiBAc2VlIFBJWEkuQWJzdHJhY3RGaWx0ZXJcbiAgICAgICAgICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAzLjAuNlxuICAgICAgICAgKi9cbiAgICAgICAgQWJzdHJhY3RGaWx0ZXI6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHdhcm4oJ0FzdHJhY3RGaWx0ZXIgaGFzIGJlZW4gcmVuYW1lZCB0byBGaWx0ZXIsIHBsZWFzZSB1c2UgUElYSS5GaWx0ZXInKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBjb3JlLkFic3RyYWN0RmlsdGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAY2xhc3NcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQG5hbWUgUElYSS5maWx0ZXJzLlNwcml0ZU1hc2tGaWx0ZXJcbiAgICAgICAgICogQHNlZSBQSVhJLlNwcml0ZU1hc2tGaWx0ZXJcbiAgICAgICAgICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAzLjAuNlxuICAgICAgICAgKi9cbiAgICAgICAgU3ByaXRlTWFza0ZpbHRlcjoge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgd2FybignZmlsdGVycy5TcHJpdGVNYXNrRmlsdGVyIGlzIGFuIHVuZG9jdW1lbnRlZCBhbGlhcywgcGxlYXNlIHVzZSBTcHJpdGVNYXNrRmlsdGVyIGZyb20gbm93IG9uLicpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvcmUuU3ByaXRlTWFza0ZpbHRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQGNsYXNzXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBuYW1lIFBJWEkuZmlsdGVycy5Wb2lkRmlsdGVyXG4gICAgICAgICAqIEBzZWUgUElYSS5maWx0ZXJzLkFscGhhRmlsdGVyXG4gICAgICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gNC41LjdcbiAgICAgICAgICovXG4gICAgICAgIFZvaWRGaWx0ZXI6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHdhcm4oJ1ZvaWRGaWx0ZXIgaGFzIGJlZW4gcmVuYW1lZCB0byBBbHBoYUZpbHRlciwgcGxlYXNlIHVzZSBQSVhJLmZpbHRlcnMuQWxwaGFGaWx0ZXInKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBmaWx0ZXJzLkFscGhhRmlsdGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG5hbWUgUElYSS51dGlscy51dWlkXG4gICAgICogQHNlZSBQSVhJLnV0aWxzLnVpZFxuICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMy4wLjZcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSB1aWRcbiAgICAgKi9cbiAgICBjb3JlLnV0aWxzLnV1aWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdhcm4oJ3V0aWxzLnV1aWQoKSBpcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIHV0aWxzLnVpZCgpIGZyb20gbm93IG9uLicpO1xuXG4gICAgICAgIHJldHVybiBjb3JlLnV0aWxzLnVpZCgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG5hbWUgUElYSS51dGlscy5jYW5Vc2VOZXdDYW52YXNCbGVuZE1vZGVzXG4gICAgICogQHNlZSBQSVhJLkNhbnZhc1RpbnRlclxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gQ2FuIHVzZSBibGVuZCBtb2Rlcy5cbiAgICAgKi9cbiAgICBjb3JlLnV0aWxzLmNhblVzZU5ld0NhbnZhc0JsZW5kTW9kZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdhcm4oJ3V0aWxzLmNhblVzZU5ld0NhbnZhc0JsZW5kTW9kZXMoKSBpcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIENhbnZhc1RpbnRlci5jYW5Vc2VNdWx0aXBseSBmcm9tIG5vdyBvbicpO1xuXG4gICAgICAgIHJldHVybiBjb3JlLkNhbnZhc1RpbnRlci5jYW5Vc2VNdWx0aXBseTtcbiAgICB9O1xuXG4gICAgdmFyIHNhaWRIZWxsbyA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBQSVhJLnV0aWxzLl9zYWlkSGVsbG9cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAc2VlIFBJWEkudXRpbHMuc2tpcEhlbGxvXG4gICAgICogQGRlcHJlY2F0ZWQgc2luY2UgNC4xLjBcbiAgICAgKi9cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29yZS51dGlscywgJ19zYWlkSGVsbG8nLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KGJvb2wpIHtcbiAgICAgICAgICAgIGlmIChib29sKSB7XG4gICAgICAgICAgICAgICAgd2FybignUElYSS51dGlscy5fc2FpZEhlbGxvIGlzIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgUElYSS51dGlscy5za2lwSGVsbG8oKScpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2tpcEhlbGxvKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzYWlkSGVsbG8gPSBib29sO1xuICAgICAgICB9LFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiBzYWlkSGVsbG87XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChwcmVwYXJlLkJhc2VQcmVwYXJlKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBuYW1lIFBJWEkucHJlcGFyZS5CYXNlUHJlcGFyZSNyZWdpc3RlclxuICAgICAgICAgKiBAc2VlIFBJWEkucHJlcGFyZS5CYXNlUHJlcGFyZSNyZWdpc3RlckZpbmRIb29rXG4gICAgICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gNC40LjJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2FkZEhvb2tdIC0gRnVuY3Rpb24gY2FsbCB0aGF0IHRha2VzIHR3byBwYXJhbWV0ZXJzOiBgaXRlbToqLCBxdWV1ZTpBcnJheWBcbiAgICAgICAgICogICAgICAgIGZ1bmN0aW9uIG11c3QgcmV0dXJuIGB0cnVlYCBpZiBpdCB3YXMgYWJsZSB0byBhZGQgaXRlbSB0byB0aGUgcXVldWUuXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFt1cGxvYWRIb29rXSAtIEZ1bmN0aW9uIGNhbGwgdGhhdCB0YWtlcyB0d28gcGFyYW1ldGVyczogYHByZXBhcmU6Q2FudmFzUHJlcGFyZSwgaXRlbToqYCBhbmRcbiAgICAgICAgICogICAgICAgIGZ1bmN0aW9uIG11c3QgcmV0dXJuIGB0cnVlYCBpZiBpdCB3YXMgYWJsZSB0byBoYW5kbGUgdXBsb2FkIG9mIGl0ZW0uXG4gICAgICAgICAqIEByZXR1cm4ge1BJWEkuQmFzZVByZXBhcmV9IEluc3RhbmNlIG9mIHBsdWdpbiBmb3IgY2hhaW5pbmcuXG4gICAgICAgICAqL1xuICAgICAgICBwcmVwYXJlLkJhc2VQcmVwYXJlLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIHJlZ2lzdGVyKGFkZEhvb2ssIHVwbG9hZEhvb2spIHtcbiAgICAgICAgICAgIHdhcm4oJ3JlbmRlcmVyLnBsdWdpbnMucHJlcGFyZS5yZWdpc3RlciBpcyBub3cgZGVwcmVjYXRlZCwgJyArICdwbGVhc2UgdXNlIHJlbmRlcmVyLnBsdWdpbnMucHJlcGFyZS5yZWdpc3RlckZpbmRIb29rICYgcmVuZGVyZXIucGx1Z2lucy5wcmVwYXJlLnJlZ2lzdGVyVXBsb2FkSG9vaycpO1xuXG4gICAgICAgICAgICBpZiAoYWRkSG9vaykge1xuICAgICAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJGaW5kSG9vayhhZGRIb29rKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHVwbG9hZEhvb2spIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZ2lzdGVyVXBsb2FkSG9vayh1cGxvYWRIb29rKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKHByZXBhcmUuY2FudmFzKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbnVtYmVyIG9mIGdyYXBoaWNzIG9yIHRleHR1cmVzIHRvIHVwbG9hZCB0byB0aGUgR1BVLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbmFtZSBQSVhJLnByZXBhcmUuY2FudmFzLlVQTE9BRFNfUEVSX0ZSQU1FXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICogQHNlZSBQSVhJLnByZXBhcmUuQmFzZVByZXBhcmUubGltaXRlclxuICAgICAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSA0LjIuMFxuICAgICAgICAgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByZXBhcmUuY2FudmFzLCAnVVBMT0FEU19QRVJfRlJBTUUnLCB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCgpIHtcbiAgICAgICAgICAgICAgICB3YXJuKCdQSVhJLkNhbnZhc1ByZXBhcmUuVVBMT0FEU19QRVJfRlJBTUUgaGFzIGJlZW4gcmVtb3ZlZC4gUGxlYXNlIHNldCAnICsgJ3JlbmRlcmVyLnBsdWdpbnMucHJlcGFyZS5saW1pdGVyLm1heEl0ZW1zUGVyRnJhbWUgb24geW91ciByZW5kZXJlcicpO1xuICAgICAgICAgICAgICAgIC8vIGJlY2F1c2Ugd2UgZG9uJ3QgaGF2ZSBhIHJlZmVyZW5jZSB0byB0aGUgcmVuZGVyZXIsIHdlIGNhbid0IGFjdHVhbGx5IHNldFxuICAgICAgICAgICAgICAgIC8vIHRoZSB1cGxvYWRzIHBlciBmcmFtZSwgc28gd2UnbGwgaGF2ZSB0byBzdGljayB3aXRoIHRoZSB3YXJuaW5nLlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHdhcm4oJ1BJWEkuQ2FudmFzUHJlcGFyZS5VUExPQURTX1BFUl9GUkFNRSBoYXMgYmVlbiByZW1vdmVkLiBQbGVhc2UgdXNlICcgKyAncmVuZGVyZXIucGx1Z2lucy5wcmVwYXJlLmxpbWl0ZXInKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChwcmVwYXJlLndlYmdsKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbnVtYmVyIG9mIGdyYXBoaWNzIG9yIHRleHR1cmVzIHRvIHVwbG9hZCB0byB0aGUgR1BVLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbmFtZSBQSVhJLnByZXBhcmUud2ViZ2wuVVBMT0FEU19QRVJfRlJBTUVcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKiBAc2VlIFBJWEkucHJlcGFyZS5CYXNlUHJlcGFyZS5saW1pdGVyXG4gICAgICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIDQuMi4wXG4gICAgICAgICAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJlcGFyZS53ZWJnbCwgJ1VQTE9BRFNfUEVSX0ZSQU1FJywge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoKSB7XG4gICAgICAgICAgICAgICAgd2FybignUElYSS5XZWJHTFByZXBhcmUuVVBMT0FEU19QRVJfRlJBTUUgaGFzIGJlZW4gcmVtb3ZlZC4gUGxlYXNlIHNldCAnICsgJ3JlbmRlcmVyLnBsdWdpbnMucHJlcGFyZS5saW1pdGVyLm1heEl0ZW1zUGVyRnJhbWUgb24geW91ciByZW5kZXJlcicpO1xuICAgICAgICAgICAgICAgIC8vIGJlY2F1c2Ugd2UgZG9uJ3QgaGF2ZSBhIHJlZmVyZW5jZSB0byB0aGUgcmVuZGVyZXIsIHdlIGNhbid0IGFjdHVhbGx5IHNldFxuICAgICAgICAgICAgICAgIC8vIHRoZSB1cGxvYWRzIHBlciBmcmFtZSwgc28gd2UnbGwgaGF2ZSB0byBzdGljayB3aXRoIHRoZSB3YXJuaW5nLlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHdhcm4oJ1BJWEkuV2ViR0xQcmVwYXJlLlVQTE9BRFNfUEVSX0ZSQU1FIGhhcyBiZWVuIHJlbW92ZWQuIFBsZWFzZSB1c2UgJyArICdyZW5kZXJlci5wbHVnaW5zLnByZXBhcmUubGltaXRlcicpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGxvYWRlcnMuTG9hZGVyKSB7XG4gICAgICAgIHZhciBSZXNvdXJjZSA9IGxvYWRlcnMuUmVzb3VyY2U7XG4gICAgICAgIHZhciBMb2FkZXIgPSBsb2FkZXJzLkxvYWRlcjtcblxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhSZXNvdXJjZS5wcm90b3R5cGUsIHtcbiAgICAgICAgICAgIGlzSnNvbjoge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICB3YXJuKCdUaGUgaXNKc29uIHByb3BlcnR5IGlzIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgYHJlc291cmNlLnR5cGUgPT09IFJlc291cmNlLlRZUEUuSlNPTmAuJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gUmVzb3VyY2UuVFlQRS5KU09OO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpc1htbDoge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICB3YXJuKCdUaGUgaXNYbWwgcHJvcGVydHkgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBgcmVzb3VyY2UudHlwZSA9PT0gUmVzb3VyY2UuVFlQRS5YTUxgLicpO1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT09IFJlc291cmNlLlRZUEUuWE1MO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpc0ltYWdlOiB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgIHdhcm4oJ1RoZSBpc0ltYWdlIHByb3BlcnR5IGlzIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgYHJlc291cmNlLnR5cGUgPT09IFJlc291cmNlLlRZUEUuSU1BR0VgLicpO1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT09IFJlc291cmNlLlRZUEUuSU1BR0U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlzQXVkaW86IHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgd2FybignVGhlIGlzQXVkaW8gcHJvcGVydHkgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBgcmVzb3VyY2UudHlwZSA9PT0gUmVzb3VyY2UuVFlQRS5BVURJT2AuJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gUmVzb3VyY2UuVFlQRS5BVURJTztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXNWaWRlbzoge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICB3YXJuKCdUaGUgaXNWaWRlbyBwcm9wZXJ0eSBpcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIGByZXNvdXJjZS50eXBlID09PSBSZXNvdXJjZS5UWVBFLlZJREVPYC4nKTtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50eXBlID09PSBSZXNvdXJjZS5UWVBFLlZJREVPO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTG9hZGVyLnByb3RvdHlwZSwge1xuICAgICAgICAgICAgYmVmb3JlOiB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgIHdhcm4oJ1RoZSBiZWZvcmUoKSBtZXRob2QgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBwcmUoKS4nKTtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wcmU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFmdGVyOiB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgIHdhcm4oJ1RoZSBhZnRlcigpIG1ldGhvZCBpcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIHVzZSgpLicpO1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnVzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChpbnRlcmFjdGlvbi5pbnRlcmFjdGl2ZVRhcmdldCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG5hbWUgUElYSS5pbnRlcmFjdGlvbi5pbnRlcmFjdGl2ZVRhcmdldCNkZWZhdWx0Q3Vyc29yXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICogQHNlZSBQSVhJLmludGVyYWN0aW9uLmludGVyYWN0aXZlVGFyZ2V0I2N1cnNvclxuICAgICAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSA0LjMuMFxuICAgICAgICAgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGludGVyYWN0aW9uLmludGVyYWN0aXZlVGFyZ2V0LCAnZGVmYXVsdEN1cnNvcicsIHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgd2FybignUHJvcGVydHkgZGVmYXVsdEN1cnNvciBoYXMgYmVlbiByZXBsYWNlZCB3aXRoIFxcJ2N1cnNvclxcJy4gJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJzb3IgPSB2YWx1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICB3YXJuKCdQcm9wZXJ0eSBkZWZhdWx0Q3Vyc29yIGhhcyBiZWVuIHJlcGxhY2VkIHdpdGggXFwnY3Vyc29yXFwnLiAnKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmN1cnNvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGludGVyYWN0aW9uLkludGVyYWN0aW9uTWFuYWdlcikge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG5hbWUgUElYSS5pbnRlcmFjdGlvbi5JbnRlcmFjdGlvbk1hbmFnZXIjZGVmYXVsdEN1cnNvclN0eWxlXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICogQHNlZSBQSVhJLmludGVyYWN0aW9uLkludGVyYWN0aW9uTWFuYWdlciNjdXJzb3JTdHlsZXNcbiAgICAgICAgICogQGRlcHJlY2F0ZWQgc2luY2UgNC4zLjBcbiAgICAgICAgICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpbnRlcmFjdGlvbi5JbnRlcmFjdGlvbk1hbmFnZXIsICdkZWZhdWx0Q3Vyc29yU3R5bGUnLCB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHdhcm4oJ1Byb3BlcnR5IGRlZmF1bHRDdXJzb3JTdHlsZSBoYXMgYmVlbiByZXBsYWNlZCB3aXRoIFxcJ2N1cnNvclN0eWxlcy5kZWZhdWx0XFwnLiAnKTtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnNvclN0eWxlcy5kZWZhdWx0ID0gdmFsdWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgd2FybignUHJvcGVydHkgZGVmYXVsdEN1cnNvclN0eWxlIGhhcyBiZWVuIHJlcGxhY2VkIHdpdGggXFwnY3Vyc29yU3R5bGVzLmRlZmF1bHRcXCcuICcpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3Vyc29yU3R5bGVzLmRlZmF1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbmFtZSBQSVhJLmludGVyYWN0aW9uLkludGVyYWN0aW9uTWFuYWdlciNjdXJyZW50Q3Vyc29yU3R5bGVcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKiBAc2VlIFBJWEkuaW50ZXJhY3Rpb24uSW50ZXJhY3Rpb25NYW5hZ2VyI2N1cnNvclN0eWxlc1xuICAgICAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSA0LjMuMFxuICAgICAgICAgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGludGVyYWN0aW9uLkludGVyYWN0aW9uTWFuYWdlciwgJ2N1cnJlbnRDdXJzb3JTdHlsZScsIHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgd2FybignUHJvcGVydHkgY3VycmVudEN1cnNvclN0eWxlIGhhcyBiZWVuIHJlbW92ZWQuJyArICdTZWUgdGhlIGN1cnJlbnRDdXJzb3JNb2RlIHByb3BlcnR5LCB3aGljaCB3b3JrcyBkaWZmZXJlbnRseS4nKTtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRDdXJzb3JNb2RlID0gdmFsdWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgd2FybignUHJvcGVydHkgY3VycmVudEN1cnNvclN0eWxlIGhhcyBiZWVuIHJlbW92ZWQuJyArICdTZWUgdGhlIGN1cnJlbnRDdXJzb3JNb2RlIHByb3BlcnR5LCB3aGljaCB3b3JrcyBkaWZmZXJlbnRseS4nKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRDdXJzb3JNb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZXByZWNhdGlvbi5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfY29yZSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUnKTtcblxudmFyIGNvcmUgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfY29yZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBURU1QX1JFQ1QgPSBuZXcgY29yZS5SZWN0YW5nbGUoKTtcblxuLyoqXG4gKiBUaGUgZXh0cmFjdCBtYW5hZ2VyIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgdG8gZXhwb3J0IGNvbnRlbnQgZnJvbSB0aGUgcmVuZGVyZXJzLlxuICpcbiAqIEFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MgaXMgYXV0b21hdGljYWxseSBjcmVhdGVkIGJ5IGRlZmF1bHQsIGFuZCBjYW4gYmUgZm91bmQgYXQgcmVuZGVyZXIucGx1Z2lucy5leHRyYWN0XG4gKlxuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgUElYSS5leHRyYWN0XG4gKi9cblxudmFyIENhbnZhc0V4dHJhY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtQSVhJLkNhbnZhc1JlbmRlcmVyfSByZW5kZXJlciAtIEEgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IHJlbmRlcmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ2FudmFzRXh0cmFjdChyZW5kZXJlcikge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2FudmFzRXh0cmFjdCk7XG5cbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29sbGVjdGlvbiBvZiBtZXRob2RzIGZvciBleHRyYWN0aW5nIGRhdGEgKGltYWdlLCBwaXhlbHMsIGV0Yy4pIGZyb20gYSBkaXNwbGF5IG9iamVjdCBvciByZW5kZXIgdGV4dHVyZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLmV4dHJhY3QuQ2FudmFzRXh0cmFjdH0gZXh0cmFjdFxuICAgICAgICAgKiBAbWVtYmVyb2YgUElYSS5DYW52YXNSZW5kZXJlciNcbiAgICAgICAgICogQHNlZSBQSVhJLmV4dHJhY3QuQ2FudmFzRXh0cmFjdFxuICAgICAgICAgKi9cbiAgICAgICAgcmVuZGVyZXIuZXh0cmFjdCA9IHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2lsbCByZXR1cm4gYSBIVE1MIEltYWdlIG9mIHRoZSB0YXJnZXRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5EaXNwbGF5T2JqZWN0fFBJWEkuUmVuZGVyVGV4dHVyZX0gdGFyZ2V0IC0gQSBkaXNwbGF5T2JqZWN0IG9yIHJlbmRlclRleHR1cmVcbiAgICAgKiAgdG8gY29udmVydC4gSWYgbGVmdCBlbXB0eSB3aWxsIHVzZSB1c2UgdGhlIG1haW4gcmVuZGVyZXJcbiAgICAgKiBAcmV0dXJuIHtIVE1MSW1hZ2VFbGVtZW50fSBIVE1MIEltYWdlIG9mIHRoZSB0YXJnZXRcbiAgICAgKi9cblxuXG4gICAgQ2FudmFzRXh0cmFjdC5wcm90b3R5cGUuaW1hZ2UgPSBmdW5jdGlvbiBpbWFnZSh0YXJnZXQpIHtcbiAgICAgICAgdmFyIGltYWdlID0gbmV3IEltYWdlKCk7XG5cbiAgICAgICAgaW1hZ2Uuc3JjID0gdGhpcy5iYXNlNjQodGFyZ2V0KTtcblxuICAgICAgICByZXR1cm4gaW1hZ2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFdpbGwgcmV0dXJuIGEgYSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcgb2YgdGhpcyB0YXJnZXQuIEl0IHdvcmtzIGJ5IGNhbGxpbmdcbiAgICAgKiAgYENhbnZhc0V4dHJhY3QuZ2V0Q2FudmFzYCBhbmQgdGhlbiBydW5uaW5nIHRvRGF0YVVSTCBvbiB0aGF0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLkRpc3BsYXlPYmplY3R8UElYSS5SZW5kZXJUZXh0dXJlfSB0YXJnZXQgLSBBIGRpc3BsYXlPYmplY3Qgb3IgcmVuZGVyVGV4dHVyZVxuICAgICAqICB0byBjb252ZXJ0LiBJZiBsZWZ0IGVtcHR5IHdpbGwgdXNlIHVzZSB0aGUgbWFpbiByZW5kZXJlclxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gQSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcgb2YgdGhlIHRleHR1cmUuXG4gICAgICovXG5cblxuICAgIENhbnZhc0V4dHJhY3QucHJvdG90eXBlLmJhc2U2NCA9IGZ1bmN0aW9uIGJhc2U2NCh0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FudmFzKHRhcmdldCkudG9EYXRhVVJMKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBDYW52YXMgZWxlbWVudCwgcmVuZGVycyB0aGlzIHRhcmdldCB0byBpdCBhbmQgdGhlbiByZXR1cm5zIGl0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLkRpc3BsYXlPYmplY3R8UElYSS5SZW5kZXJUZXh0dXJlfSB0YXJnZXQgLSBBIGRpc3BsYXlPYmplY3Qgb3IgcmVuZGVyVGV4dHVyZVxuICAgICAqICB0byBjb252ZXJ0LiBJZiBsZWZ0IGVtcHR5IHdpbGwgdXNlIHVzZSB0aGUgbWFpbiByZW5kZXJlclxuICAgICAqIEByZXR1cm4ge0hUTUxDYW52YXNFbGVtZW50fSBBIENhbnZhcyBlbGVtZW50IHdpdGggdGhlIHRleHR1cmUgcmVuZGVyZWQgb24uXG4gICAgICovXG5cblxuICAgIENhbnZhc0V4dHJhY3QucHJvdG90eXBlLmNhbnZhcyA9IGZ1bmN0aW9uIGNhbnZhcyh0YXJnZXQpIHtcbiAgICAgICAgdmFyIHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcjtcbiAgICAgICAgdmFyIGNvbnRleHQgPSB2b2lkIDA7XG4gICAgICAgIHZhciByZXNvbHV0aW9uID0gdm9pZCAwO1xuICAgICAgICB2YXIgZnJhbWUgPSB2b2lkIDA7XG4gICAgICAgIHZhciByZW5kZXJUZXh0dXJlID0gdm9pZCAwO1xuXG4gICAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBjb3JlLlJlbmRlclRleHR1cmUpIHtcbiAgICAgICAgICAgICAgICByZW5kZXJUZXh0dXJlID0gdGFyZ2V0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZW5kZXJUZXh0dXJlID0gcmVuZGVyZXIuZ2VuZXJhdGVUZXh0dXJlKHRhcmdldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVuZGVyVGV4dHVyZSkge1xuICAgICAgICAgICAgY29udGV4dCA9IHJlbmRlclRleHR1cmUuYmFzZVRleHR1cmUuX2NhbnZhc1JlbmRlclRhcmdldC5jb250ZXh0O1xuICAgICAgICAgICAgcmVzb2x1dGlvbiA9IHJlbmRlclRleHR1cmUuYmFzZVRleHR1cmUuX2NhbnZhc1JlbmRlclRhcmdldC5yZXNvbHV0aW9uO1xuICAgICAgICAgICAgZnJhbWUgPSByZW5kZXJUZXh0dXJlLmZyYW1lO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29udGV4dCA9IHJlbmRlcmVyLnJvb3RDb250ZXh0O1xuICAgICAgICAgICAgcmVzb2x1dGlvbiA9IHJlbmRlcmVyLnJlc29sdXRpb247XG4gICAgICAgICAgICBmcmFtZSA9IFRFTVBfUkVDVDtcbiAgICAgICAgICAgIGZyYW1lLndpZHRoID0gdGhpcy5yZW5kZXJlci53aWR0aDtcbiAgICAgICAgICAgIGZyYW1lLmhlaWdodCA9IHRoaXMucmVuZGVyZXIuaGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHdpZHRoID0gZnJhbWUud2lkdGggKiByZXNvbHV0aW9uO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gZnJhbWUuaGVpZ2h0ICogcmVzb2x1dGlvbjtcblxuICAgICAgICB2YXIgY2FudmFzQnVmZmVyID0gbmV3IGNvcmUuQ2FudmFzUmVuZGVyVGFyZ2V0KHdpZHRoLCBoZWlnaHQsIDEpO1xuICAgICAgICB2YXIgY2FudmFzRGF0YSA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKGZyYW1lLnggKiByZXNvbHV0aW9uLCBmcmFtZS55ICogcmVzb2x1dGlvbiwgd2lkdGgsIGhlaWdodCk7XG5cbiAgICAgICAgY2FudmFzQnVmZmVyLmNvbnRleHQucHV0SW1hZ2VEYXRhKGNhbnZhc0RhdGEsIDAsIDApO1xuXG4gICAgICAgIC8vIHNlbmQgdGhlIGNhbnZhcyBiYWNrLi5cbiAgICAgICAgcmV0dXJuIGNhbnZhc0J1ZmZlci5jYW52YXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFdpbGwgcmV0dXJuIGEgb25lLWRpbWVuc2lvbmFsIGFycmF5IGNvbnRhaW5pbmcgdGhlIHBpeGVsIGRhdGEgb2YgdGhlIGVudGlyZSB0ZXh0dXJlIGluIFJHQkFcbiAgICAgKiBvcmRlciwgd2l0aCBpbnRlZ2VyIHZhbHVlcyBiZXR3ZWVuIDAgYW5kIDI1NSAoaW5jbHVkZWQpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLkRpc3BsYXlPYmplY3R8UElYSS5SZW5kZXJUZXh0dXJlfSB0YXJnZXQgLSBBIGRpc3BsYXlPYmplY3Qgb3IgcmVuZGVyVGV4dHVyZVxuICAgICAqICB0byBjb252ZXJ0LiBJZiBsZWZ0IGVtcHR5IHdpbGwgdXNlIHVzZSB0aGUgbWFpbiByZW5kZXJlclxuICAgICAqIEByZXR1cm4ge1VpbnQ4Q2xhbXBlZEFycmF5fSBPbmUtZGltZW5zaW9uYWwgYXJyYXkgY29udGFpbmluZyB0aGUgcGl4ZWwgZGF0YSBvZiB0aGUgZW50aXJlIHRleHR1cmVcbiAgICAgKi9cblxuXG4gICAgQ2FudmFzRXh0cmFjdC5wcm90b3R5cGUucGl4ZWxzID0gZnVuY3Rpb24gcGl4ZWxzKHRhcmdldCkge1xuICAgICAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyO1xuICAgICAgICB2YXIgY29udGV4dCA9IHZvaWQgMDtcbiAgICAgICAgdmFyIHJlc29sdXRpb24gPSB2b2lkIDA7XG4gICAgICAgIHZhciBmcmFtZSA9IHZvaWQgMDtcbiAgICAgICAgdmFyIHJlbmRlclRleHR1cmUgPSB2b2lkIDA7XG5cbiAgICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICAgICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIGNvcmUuUmVuZGVyVGV4dHVyZSkge1xuICAgICAgICAgICAgICAgIHJlbmRlclRleHR1cmUgPSB0YXJnZXQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlbmRlclRleHR1cmUgPSByZW5kZXJlci5nZW5lcmF0ZVRleHR1cmUodGFyZ2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZW5kZXJUZXh0dXJlKSB7XG4gICAgICAgICAgICBjb250ZXh0ID0gcmVuZGVyVGV4dHVyZS5iYXNlVGV4dHVyZS5fY2FudmFzUmVuZGVyVGFyZ2V0LmNvbnRleHQ7XG4gICAgICAgICAgICByZXNvbHV0aW9uID0gcmVuZGVyVGV4dHVyZS5iYXNlVGV4dHVyZS5fY2FudmFzUmVuZGVyVGFyZ2V0LnJlc29sdXRpb247XG4gICAgICAgICAgICBmcmFtZSA9IHJlbmRlclRleHR1cmUuZnJhbWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250ZXh0ID0gcmVuZGVyZXIucm9vdENvbnRleHQ7XG5cbiAgICAgICAgICAgIGZyYW1lID0gVEVNUF9SRUNUO1xuICAgICAgICAgICAgZnJhbWUud2lkdGggPSByZW5kZXJlci53aWR0aDtcbiAgICAgICAgICAgIGZyYW1lLmhlaWdodCA9IHJlbmRlcmVyLmhlaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCBmcmFtZS53aWR0aCAqIHJlc29sdXRpb24sIGZyYW1lLmhlaWdodCAqIHJlc29sdXRpb24pLmRhdGE7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIHRoZSBleHRyYWN0XG4gICAgICpcbiAgICAgKi9cblxuXG4gICAgQ2FudmFzRXh0cmFjdC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuZXh0cmFjdCA9IG51bGw7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSBudWxsO1xuICAgIH07XG5cbiAgICByZXR1cm4gQ2FudmFzRXh0cmFjdDtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gQ2FudmFzRXh0cmFjdDtcblxuXG5jb3JlLkNhbnZhc1JlbmRlcmVyLnJlZ2lzdGVyUGx1Z2luKCdleHRyYWN0JywgQ2FudmFzRXh0cmFjdCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DYW52YXNFeHRyYWN0LmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9XZWJHTEV4dHJhY3QgPSByZXF1aXJlKCcuL3dlYmdsL1dlYkdMRXh0cmFjdCcpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ3dlYmdsJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfV2ViR0xFeHRyYWN0KS5kZWZhdWx0O1xuICB9XG59KTtcblxudmFyIF9DYW52YXNFeHRyYWN0ID0gcmVxdWlyZSgnLi9jYW52YXMvQ2FudmFzRXh0cmFjdCcpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2NhbnZhcycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0NhbnZhc0V4dHJhY3QpLmRlZmF1bHQ7XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2NvcmUgPSByZXF1aXJlKCcuLi8uLi9jb3JlJyk7XG5cbnZhciBjb3JlID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX2NvcmUpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgVEVNUF9SRUNUID0gbmV3IGNvcmUuUmVjdGFuZ2xlKCk7XG52YXIgQllURVNfUEVSX1BJWEVMID0gNDtcblxuLyoqXG4gKiBUaGUgZXh0cmFjdCBtYW5hZ2VyIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgdG8gZXhwb3J0IGNvbnRlbnQgZnJvbSB0aGUgcmVuZGVyZXJzLlxuICpcbiAqIEFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MgaXMgYXV0b21hdGljYWxseSBjcmVhdGVkIGJ5IGRlZmF1bHQsIGFuZCBjYW4gYmUgZm91bmQgYXQgcmVuZGVyZXIucGx1Z2lucy5leHRyYWN0XG4gKlxuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgUElYSS5leHRyYWN0XG4gKi9cblxudmFyIFdlYkdMRXh0cmFjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1BJWEkuV2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBBIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudCByZW5kZXJlclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFdlYkdMRXh0cmFjdChyZW5kZXJlcikge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgV2ViR0xFeHRyYWN0KTtcblxuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb2xsZWN0aW9uIG9mIG1ldGhvZHMgZm9yIGV4dHJhY3RpbmcgZGF0YSAoaW1hZ2UsIHBpeGVscywgZXRjLikgZnJvbSBhIGRpc3BsYXkgb2JqZWN0IG9yIHJlbmRlciB0ZXh0dXJlXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuZXh0cmFjdC5XZWJHTEV4dHJhY3R9IGV4dHJhY3RcbiAgICAgICAgICogQG1lbWJlcm9mIFBJWEkuV2ViR0xSZW5kZXJlciNcbiAgICAgICAgICogQHNlZSBQSVhJLmV4dHJhY3QuV2ViR0xFeHRyYWN0XG4gICAgICAgICAqL1xuICAgICAgICByZW5kZXJlci5leHRyYWN0ID0gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXaWxsIHJldHVybiBhIEhUTUwgSW1hZ2Ugb2YgdGhlIHRhcmdldFxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLkRpc3BsYXlPYmplY3R8UElYSS5SZW5kZXJUZXh0dXJlfSB0YXJnZXQgLSBBIGRpc3BsYXlPYmplY3Qgb3IgcmVuZGVyVGV4dHVyZVxuICAgICAqICB0byBjb252ZXJ0LiBJZiBsZWZ0IGVtcHR5IHdpbGwgdXNlIHVzZSB0aGUgbWFpbiByZW5kZXJlclxuICAgICAqIEByZXR1cm4ge0hUTUxJbWFnZUVsZW1lbnR9IEhUTUwgSW1hZ2Ugb2YgdGhlIHRhcmdldFxuICAgICAqL1xuXG5cbiAgICBXZWJHTEV4dHJhY3QucHJvdG90eXBlLmltYWdlID0gZnVuY3Rpb24gaW1hZ2UodGFyZ2V0KSB7XG4gICAgICAgIHZhciBpbWFnZSA9IG5ldyBJbWFnZSgpO1xuXG4gICAgICAgIGltYWdlLnNyYyA9IHRoaXMuYmFzZTY0KHRhcmdldCk7XG5cbiAgICAgICAgcmV0dXJuIGltYWdlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBXaWxsIHJldHVybiBhIGEgYmFzZTY0IGVuY29kZWQgc3RyaW5nIG9mIHRoaXMgdGFyZ2V0LiBJdCB3b3JrcyBieSBjYWxsaW5nXG4gICAgICogIGBXZWJHTEV4dHJhY3QuZ2V0Q2FudmFzYCBhbmQgdGhlbiBydW5uaW5nIHRvRGF0YVVSTCBvbiB0aGF0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLkRpc3BsYXlPYmplY3R8UElYSS5SZW5kZXJUZXh0dXJlfSB0YXJnZXQgLSBBIGRpc3BsYXlPYmplY3Qgb3IgcmVuZGVyVGV4dHVyZVxuICAgICAqICB0byBjb252ZXJ0LiBJZiBsZWZ0IGVtcHR5IHdpbGwgdXNlIHVzZSB0aGUgbWFpbiByZW5kZXJlclxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gQSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcgb2YgdGhlIHRleHR1cmUuXG4gICAgICovXG5cblxuICAgIFdlYkdMRXh0cmFjdC5wcm90b3R5cGUuYmFzZTY0ID0gZnVuY3Rpb24gYmFzZTY0KHRhcmdldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYW52YXModGFyZ2V0KS50b0RhdGFVUkwoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIENhbnZhcyBlbGVtZW50LCByZW5kZXJzIHRoaXMgdGFyZ2V0IHRvIGl0IGFuZCB0aGVuIHJldHVybnMgaXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuRGlzcGxheU9iamVjdHxQSVhJLlJlbmRlclRleHR1cmV9IHRhcmdldCAtIEEgZGlzcGxheU9iamVjdCBvciByZW5kZXJUZXh0dXJlXG4gICAgICogIHRvIGNvbnZlcnQuIElmIGxlZnQgZW1wdHkgd2lsbCB1c2UgdXNlIHRoZSBtYWluIHJlbmRlcmVyXG4gICAgICogQHJldHVybiB7SFRNTENhbnZhc0VsZW1lbnR9IEEgQ2FudmFzIGVsZW1lbnQgd2l0aCB0aGUgdGV4dHVyZSByZW5kZXJlZCBvbi5cbiAgICAgKi9cblxuXG4gICAgV2ViR0xFeHRyYWN0LnByb3RvdHlwZS5jYW52YXMgPSBmdW5jdGlvbiBjYW52YXModGFyZ2V0KSB7XG4gICAgICAgIHZhciByZW5kZXJlciA9IHRoaXMucmVuZGVyZXI7XG4gICAgICAgIHZhciB0ZXh0dXJlQnVmZmVyID0gdm9pZCAwO1xuICAgICAgICB2YXIgcmVzb2x1dGlvbiA9IHZvaWQgMDtcbiAgICAgICAgdmFyIGZyYW1lID0gdm9pZCAwO1xuICAgICAgICB2YXIgZmxpcFkgPSBmYWxzZTtcbiAgICAgICAgdmFyIHJlbmRlclRleHR1cmUgPSB2b2lkIDA7XG4gICAgICAgIHZhciBnZW5lcmF0ZWQgPSBmYWxzZTtcblxuICAgICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgICAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgY29yZS5SZW5kZXJUZXh0dXJlKSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyVGV4dHVyZSA9IHRhcmdldDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyVGV4dHVyZSA9IHRoaXMucmVuZGVyZXIuZ2VuZXJhdGVUZXh0dXJlKHRhcmdldCk7XG4gICAgICAgICAgICAgICAgZ2VuZXJhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZW5kZXJUZXh0dXJlKSB7XG4gICAgICAgICAgICB0ZXh0dXJlQnVmZmVyID0gcmVuZGVyVGV4dHVyZS5iYXNlVGV4dHVyZS5fZ2xSZW5kZXJUYXJnZXRzW3RoaXMucmVuZGVyZXIuQ09OVEVYVF9VSURdO1xuICAgICAgICAgICAgcmVzb2x1dGlvbiA9IHRleHR1cmVCdWZmZXIucmVzb2x1dGlvbjtcbiAgICAgICAgICAgIGZyYW1lID0gcmVuZGVyVGV4dHVyZS5mcmFtZTtcbiAgICAgICAgICAgIGZsaXBZID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ZXh0dXJlQnVmZmVyID0gdGhpcy5yZW5kZXJlci5yb290UmVuZGVyVGFyZ2V0O1xuICAgICAgICAgICAgcmVzb2x1dGlvbiA9IHRleHR1cmVCdWZmZXIucmVzb2x1dGlvbjtcbiAgICAgICAgICAgIGZsaXBZID0gdHJ1ZTtcblxuICAgICAgICAgICAgZnJhbWUgPSBURU1QX1JFQ1Q7XG4gICAgICAgICAgICBmcmFtZS53aWR0aCA9IHRleHR1cmVCdWZmZXIuc2l6ZS53aWR0aDtcbiAgICAgICAgICAgIGZyYW1lLmhlaWdodCA9IHRleHR1cmVCdWZmZXIuc2l6ZS5oZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgd2lkdGggPSBmcmFtZS53aWR0aCAqIHJlc29sdXRpb247XG4gICAgICAgIHZhciBoZWlnaHQgPSBmcmFtZS5oZWlnaHQgKiByZXNvbHV0aW9uO1xuXG4gICAgICAgIHZhciBjYW52YXNCdWZmZXIgPSBuZXcgY29yZS5DYW52YXNSZW5kZXJUYXJnZXQod2lkdGgsIGhlaWdodCwgMSk7XG5cbiAgICAgICAgaWYgKHRleHR1cmVCdWZmZXIpIHtcbiAgICAgICAgICAgIC8vIGJpbmQgdGhlIGJ1ZmZlclxuICAgICAgICAgICAgcmVuZGVyZXIuYmluZFJlbmRlclRhcmdldCh0ZXh0dXJlQnVmZmVyKTtcblxuICAgICAgICAgICAgLy8gc2V0IHVwIGFuIGFycmF5IG9mIHBpeGVsc1xuICAgICAgICAgICAgdmFyIHdlYmdsUGl4ZWxzID0gbmV3IFVpbnQ4QXJyYXkoQllURVNfUEVSX1BJWEVMICogd2lkdGggKiBoZWlnaHQpO1xuXG4gICAgICAgICAgICAvLyByZWFkIHBpeGVscyB0byB0aGUgYXJyYXlcbiAgICAgICAgICAgIHZhciBnbCA9IHJlbmRlcmVyLmdsO1xuXG4gICAgICAgICAgICBnbC5yZWFkUGl4ZWxzKGZyYW1lLnggKiByZXNvbHV0aW9uLCBmcmFtZS55ICogcmVzb2x1dGlvbiwgd2lkdGgsIGhlaWdodCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgd2ViZ2xQaXhlbHMpO1xuXG4gICAgICAgICAgICAvLyBhZGQgdGhlIHBpeGVscyB0byB0aGUgY2FudmFzXG4gICAgICAgICAgICB2YXIgY2FudmFzRGF0YSA9IGNhbnZhc0J1ZmZlci5jb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcblxuICAgICAgICAgICAgY2FudmFzRGF0YS5kYXRhLnNldCh3ZWJnbFBpeGVscyk7XG5cbiAgICAgICAgICAgIGNhbnZhc0J1ZmZlci5jb250ZXh0LnB1dEltYWdlRGF0YShjYW52YXNEYXRhLCAwLCAwKTtcblxuICAgICAgICAgICAgLy8gcHVsbGluZyBwaXhlbHNcbiAgICAgICAgICAgIGlmIChmbGlwWSkge1xuICAgICAgICAgICAgICAgIGNhbnZhc0J1ZmZlci5jb250ZXh0LnNjYWxlKDEsIC0xKTtcbiAgICAgICAgICAgICAgICBjYW52YXNCdWZmZXIuY29udGV4dC5kcmF3SW1hZ2UoY2FudmFzQnVmZmVyLmNhbnZhcywgMCwgLWhlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZ2VuZXJhdGVkKSB7XG4gICAgICAgICAgICByZW5kZXJUZXh0dXJlLmRlc3Ryb3kodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2VuZCB0aGUgY2FudmFzIGJhY2suLlxuXG4gICAgICAgIHJldHVybiBjYW52YXNCdWZmZXIuY2FudmFzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBXaWxsIHJldHVybiBhIG9uZS1kaW1lbnNpb25hbCBhcnJheSBjb250YWluaW5nIHRoZSBwaXhlbCBkYXRhIG9mIHRoZSBlbnRpcmUgdGV4dHVyZSBpbiBSR0JBXG4gICAgICogb3JkZXIsIHdpdGggaW50ZWdlciB2YWx1ZXMgYmV0d2VlbiAwIGFuZCAyNTUgKGluY2x1ZGVkKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5EaXNwbGF5T2JqZWN0fFBJWEkuUmVuZGVyVGV4dHVyZX0gdGFyZ2V0IC0gQSBkaXNwbGF5T2JqZWN0IG9yIHJlbmRlclRleHR1cmVcbiAgICAgKiAgdG8gY29udmVydC4gSWYgbGVmdCBlbXB0eSB3aWxsIHVzZSB1c2UgdGhlIG1haW4gcmVuZGVyZXJcbiAgICAgKiBAcmV0dXJuIHtVaW50OENsYW1wZWRBcnJheX0gT25lLWRpbWVuc2lvbmFsIGFycmF5IGNvbnRhaW5pbmcgdGhlIHBpeGVsIGRhdGEgb2YgdGhlIGVudGlyZSB0ZXh0dXJlXG4gICAgICovXG5cblxuICAgIFdlYkdMRXh0cmFjdC5wcm90b3R5cGUucGl4ZWxzID0gZnVuY3Rpb24gcGl4ZWxzKHRhcmdldCkge1xuICAgICAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyO1xuICAgICAgICB2YXIgdGV4dHVyZUJ1ZmZlciA9IHZvaWQgMDtcbiAgICAgICAgdmFyIHJlc29sdXRpb24gPSB2b2lkIDA7XG4gICAgICAgIHZhciBmcmFtZSA9IHZvaWQgMDtcbiAgICAgICAgdmFyIHJlbmRlclRleHR1cmUgPSB2b2lkIDA7XG4gICAgICAgIHZhciBnZW5lcmF0ZWQgPSBmYWxzZTtcblxuICAgICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgICAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgY29yZS5SZW5kZXJUZXh0dXJlKSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyVGV4dHVyZSA9IHRhcmdldDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyVGV4dHVyZSA9IHRoaXMucmVuZGVyZXIuZ2VuZXJhdGVUZXh0dXJlKHRhcmdldCk7XG4gICAgICAgICAgICAgICAgZ2VuZXJhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZW5kZXJUZXh0dXJlKSB7XG4gICAgICAgICAgICB0ZXh0dXJlQnVmZmVyID0gcmVuZGVyVGV4dHVyZS5iYXNlVGV4dHVyZS5fZ2xSZW5kZXJUYXJnZXRzW3RoaXMucmVuZGVyZXIuQ09OVEVYVF9VSURdO1xuICAgICAgICAgICAgcmVzb2x1dGlvbiA9IHRleHR1cmVCdWZmZXIucmVzb2x1dGlvbjtcbiAgICAgICAgICAgIGZyYW1lID0gcmVuZGVyVGV4dHVyZS5mcmFtZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRleHR1cmVCdWZmZXIgPSB0aGlzLnJlbmRlcmVyLnJvb3RSZW5kZXJUYXJnZXQ7XG4gICAgICAgICAgICByZXNvbHV0aW9uID0gdGV4dHVyZUJ1ZmZlci5yZXNvbHV0aW9uO1xuXG4gICAgICAgICAgICBmcmFtZSA9IFRFTVBfUkVDVDtcbiAgICAgICAgICAgIGZyYW1lLndpZHRoID0gdGV4dHVyZUJ1ZmZlci5zaXplLndpZHRoO1xuICAgICAgICAgICAgZnJhbWUuaGVpZ2h0ID0gdGV4dHVyZUJ1ZmZlci5zaXplLmhlaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB3aWR0aCA9IGZyYW1lLndpZHRoICogcmVzb2x1dGlvbjtcbiAgICAgICAgdmFyIGhlaWdodCA9IGZyYW1lLmhlaWdodCAqIHJlc29sdXRpb247XG5cbiAgICAgICAgdmFyIHdlYmdsUGl4ZWxzID0gbmV3IFVpbnQ4QXJyYXkoQllURVNfUEVSX1BJWEVMICogd2lkdGggKiBoZWlnaHQpO1xuXG4gICAgICAgIGlmICh0ZXh0dXJlQnVmZmVyKSB7XG4gICAgICAgICAgICAvLyBiaW5kIHRoZSBidWZmZXJcbiAgICAgICAgICAgIHJlbmRlcmVyLmJpbmRSZW5kZXJUYXJnZXQodGV4dHVyZUJ1ZmZlcik7XG4gICAgICAgICAgICAvLyByZWFkIHBpeGVscyB0byB0aGUgYXJyYXlcbiAgICAgICAgICAgIHZhciBnbCA9IHJlbmRlcmVyLmdsO1xuXG4gICAgICAgICAgICBnbC5yZWFkUGl4ZWxzKGZyYW1lLnggKiByZXNvbHV0aW9uLCBmcmFtZS55ICogcmVzb2x1dGlvbiwgd2lkdGgsIGhlaWdodCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgd2ViZ2xQaXhlbHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGdlbmVyYXRlZCkge1xuICAgICAgICAgICAgcmVuZGVyVGV4dHVyZS5kZXN0cm95KHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHdlYmdsUGl4ZWxzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyB0aGUgZXh0cmFjdFxuICAgICAqXG4gICAgICovXG5cblxuICAgIFdlYkdMRXh0cmFjdC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuZXh0cmFjdCA9IG51bGw7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSBudWxsO1xuICAgIH07XG5cbiAgICByZXR1cm4gV2ViR0xFeHRyYWN0O1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBXZWJHTEV4dHJhY3Q7XG5cblxuY29yZS5XZWJHTFJlbmRlcmVyLnJlZ2lzdGVyUGx1Z2luKCdleHRyYWN0JywgV2ViR0xFeHRyYWN0KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVdlYkdMRXh0cmFjdC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfY29yZSA9IHJlcXVpcmUoJy4uL2NvcmUnKTtcblxudmFyIGNvcmUgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfY29yZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuLyoqXG4gKiBAdHlwZWRlZiBQSVhJLmV4dHJhcy5BbmltYXRlZFNwcml0ZX5GcmFtZU9iamVjdFxuICogQHR5cGUge29iamVjdH1cbiAqIEBwcm9wZXJ0eSB7UElYSS5UZXh0dXJlfSB0ZXh0dXJlIC0gVGhlIHtAbGluayBQSVhJLlRleHR1cmV9IG9mIHRoZSBmcmFtZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHRpbWUgLSB0aGUgZHVyYXRpb24gb2YgdGhlIGZyYW1lIGluIG1zXG4gKi9cblxuLyoqXG4gKiBBbiBBbmltYXRlZFNwcml0ZSBpcyBhIHNpbXBsZSB3YXkgdG8gZGlzcGxheSBhbiBhbmltYXRpb24gZGVwaWN0ZWQgYnkgYSBsaXN0IG9mIHRleHR1cmVzLlxuICpcbiAqIGBgYGpzXG4gKiBsZXQgYWxpZW5JbWFnZXMgPSBbXCJpbWFnZV9zZXF1ZW5jZV8wMS5wbmdcIixcImltYWdlX3NlcXVlbmNlXzAyLnBuZ1wiLFwiaW1hZ2Vfc2VxdWVuY2VfMDMucG5nXCIsXCJpbWFnZV9zZXF1ZW5jZV8wNC5wbmdcIl07XG4gKiBsZXQgdGV4dHVyZUFycmF5ID0gW107XG4gKlxuICogZm9yIChsZXQgaT0wOyBpIDwgNDsgaSsrKVxuICoge1xuICogICAgICBsZXQgdGV4dHVyZSA9IFBJWEkuVGV4dHVyZS5mcm9tSW1hZ2UoYWxpZW5JbWFnZXNbaV0pO1xuICogICAgICB0ZXh0dXJlQXJyYXkucHVzaCh0ZXh0dXJlKTtcbiAqIH07XG4gKlxuICogbGV0IGFuaW1hdGVkU3ByaXRlID0gbmV3IFBJWEkuZXh0cmFzLkFuaW1hdGVkU3ByaXRlKHRleHR1cmVBcnJheSk7XG4gKiBgYGBcbiAqXG4gKiBUaGUgbW9yZSBlZmZpY2llbnQgYW5kIHNpbXBsZXIgd2F5IHRvIGNyZWF0ZSBhbiBhbmltYXRlZCBzcHJpdGUgaXMgdXNpbmcgYSB7QGxpbmsgUElYSS5TcHJpdGVzaGVldH1cbiAqIGNvbnRhaW5pbmcgdGhlIGFuaW1hdGlvbiBkZWZpbml0aW9uczpcbiAqXG4gKiBgYGBqc1xuICogUElYSS5sb2FkZXIuYWRkKFwiYXNzZXRzL3Nwcml0ZXNoZWV0Lmpzb25cIikubG9hZChzZXR1cCk7XG4gKlxuICogZnVuY3Rpb24gc2V0dXAoKSB7XG4gKiAgIGxldCBzaGVldCA9IFBJWEkubG9hZGVyLnJlc291cmNlc1tcImFzc2V0cy9zcHJpdGVzaGVldC5qc29uXCJdLnNwcml0ZXNoZWV0O1xuICogICBhbmltYXRlZFNwcml0ZSA9IG5ldyBQSVhJLmV4dHJhcy5BbmltYXRlZFNwcml0ZShzaGVldC5hbmltYXRpb25zW1wiaW1hZ2Vfc2VxdWVuY2VcIl0pO1xuICogICAuLi5cbiAqIH1cbiAqIGBgYFxuICpcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgUElYSS5TcHJpdGVcbiAqIEBtZW1iZXJvZiBQSVhJLmV4dHJhc1xuICovXG52YXIgQW5pbWF0ZWRTcHJpdGUgPSBmdW5jdGlvbiAoX2NvcmUkU3ByaXRlKSB7XG4gICAgX2luaGVyaXRzKEFuaW1hdGVkU3ByaXRlLCBfY29yZSRTcHJpdGUpO1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtQSVhJLlRleHR1cmVbXXxQSVhJLmV4dHJhcy5BbmltYXRlZFNwcml0ZX5GcmFtZU9iamVjdFtdfSB0ZXh0dXJlcyAtIGFuIGFycmF5IG9mIHtAbGluayBQSVhJLlRleHR1cmV9IG9yIGZyYW1lXG4gICAgICogIG9iamVjdHMgdGhhdCBtYWtlIHVwIHRoZSBhbmltYXRpb25cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFthdXRvVXBkYXRlPXRydWVdIC0gV2hldGhlciB0byB1c2UgUElYSS50aWNrZXIuc2hhcmVkIHRvIGF1dG8gdXBkYXRlIGFuaW1hdGlvbiB0aW1lLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEFuaW1hdGVkU3ByaXRlKHRleHR1cmVzLCBhdXRvVXBkYXRlKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBbmltYXRlZFNwcml0ZSk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfY29yZSRTcHJpdGUuY2FsbCh0aGlzLCB0ZXh0dXJlc1swXSBpbnN0YW5jZW9mIGNvcmUuVGV4dHVyZSA/IHRleHR1cmVzWzBdIDogdGV4dHVyZXNbMF0udGV4dHVyZSkpO1xuXG4gICAgICAgIF90aGlzLl90ZXh0dXJlcyA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5fZHVyYXRpb25zID0gbnVsbDtcblxuICAgICAgICBfdGhpcy50ZXh0dXJlcyA9IHRleHR1cmVzO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBgdHJ1ZWAgdXNlcyBQSVhJLnRpY2tlci5zaGFyZWQgdG8gYXV0byB1cGRhdGUgYW5pbWF0aW9uIHRpbWUuXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5fYXV0b1VwZGF0ZSA9IGF1dG9VcGRhdGUgIT09IGZhbHNlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgc3BlZWQgdGhhdCB0aGUgQW5pbWF0ZWRTcHJpdGUgd2lsbCBwbGF5IGF0LiBIaWdoZXIgaXMgZmFzdGVyLCBsb3dlciBpcyBzbG93ZXJcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAxXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5hbmltYXRpb25TcGVlZCA9IDE7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSBhbmltYXRlIHNwcml0ZSByZXBlYXRzIGFmdGVyIHBsYXlpbmcuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLmxvb3AgPSB0cnVlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGUgYW5jaG9yIHRvIFtUZXh0dXJlJ3MgZGVmYXVsdEFuY2hvcl17QGxpbmsgUElYSS5UZXh0dXJlI2RlZmF1bHRBbmNob3J9IHdoZW4gZnJhbWUgY2hhbmdlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogVXNlZnVsIHdpdGggW3Nwcml0ZSBzaGVldCBhbmltYXRpb25zXXtAbGluayBQSVhJLlNwcml0ZXNoZWV0I2FuaW1hdGlvbnN9IGNyZWF0ZWQgd2l0aCB0b29scy5cbiAgICAgICAgICogQ2hhbmdpbmcgYW5jaG9yIGZvciBlYWNoIGZyYW1lIGFsbG93cyB0byBwaW4gc3ByaXRlIG9yaWdpbiB0byBjZXJ0YWluIG1vdmluZyBmZWF0dXJlXG4gICAgICAgICAqIG9mIHRoZSBmcmFtZSAoZS5nLiBsZWZ0IGZvb3QpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBOb3RlOiBFbmFibGluZyB0aGlzIHdpbGwgb3ZlcnJpZGUgYW55IHByZXZpb3VzbHkgc2V0IGBhbmNob3JgIG9uIGVhY2ggZnJhbWUgY2hhbmdlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMudXBkYXRlQW5jaG9yID0gZmFsc2U7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZ1bmN0aW9uIHRvIGNhbGwgd2hlbiBhIEFuaW1hdGVkU3ByaXRlIGZpbmlzaGVzIHBsYXlpbmdcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7RnVuY3Rpb259XG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5vbkNvbXBsZXRlID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRnVuY3Rpb24gdG8gY2FsbCB3aGVuIGEgQW5pbWF0ZWRTcHJpdGUgY2hhbmdlcyB3aGljaCB0ZXh0dXJlIGlzIGJlaW5nIHJlbmRlcmVkXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge0Z1bmN0aW9ufVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMub25GcmFtZUNoYW5nZSA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICogRnVuY3Rpb24gdG8gY2FsbCB3aGVuICdsb29wJyBpcyB0cnVlLCBhbmQgYW4gQW5pbWF0ZWRTcHJpdGUgaXMgcGxheWVkIGFuZCBsb29wcyBhcm91bmQgdG8gc3RhcnQgYWdhaW5cbiAgICAgICAgKlxuICAgICAgICAqIEBtZW1iZXIge0Z1bmN0aW9ufVxuICAgICAgICAqL1xuICAgICAgICBfdGhpcy5vbkxvb3AgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbGFwc2VkIHRpbWUgc2luY2UgYW5pbWF0aW9uIGhhcyBiZWVuIHN0YXJ0ZWQsIHVzZWQgaW50ZXJuYWxseSB0byBkaXNwbGF5IGN1cnJlbnQgdGV4dHVyZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5fY3VycmVudFRpbWUgPSAwO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmRpY2F0ZXMgaWYgdGhlIEFuaW1hdGVkU3ByaXRlIGlzIGN1cnJlbnRseSBwbGF5aW5nXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICAgICAqIEByZWFkb25seVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMucGxheWluZyA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RvcHMgdGhlIEFuaW1hdGVkU3ByaXRlXG4gICAgICpcbiAgICAgKi9cblxuXG4gICAgQW5pbWF0ZWRTcHJpdGUucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgICBpZiAoIXRoaXMucGxheWluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wbGF5aW5nID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLl9hdXRvVXBkYXRlKSB7XG4gICAgICAgICAgICBjb3JlLnRpY2tlci5zaGFyZWQucmVtb3ZlKHRoaXMudXBkYXRlLCB0aGlzKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBQbGF5cyB0aGUgQW5pbWF0ZWRTcHJpdGVcbiAgICAgKlxuICAgICAqL1xuXG5cbiAgICBBbmltYXRlZFNwcml0ZS5wcm90b3R5cGUucGxheSA9IGZ1bmN0aW9uIHBsYXkoKSB7XG4gICAgICAgIGlmICh0aGlzLnBsYXlpbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucGxheWluZyA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLl9hdXRvVXBkYXRlKSB7XG4gICAgICAgICAgICBjb3JlLnRpY2tlci5zaGFyZWQuYWRkKHRoaXMudXBkYXRlLCB0aGlzLCBjb3JlLlVQREFURV9QUklPUklUWS5ISUdIKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTdG9wcyB0aGUgQW5pbWF0ZWRTcHJpdGUgYW5kIGdvZXMgdG8gYSBzcGVjaWZpYyBmcmFtZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGZyYW1lTnVtYmVyIC0gZnJhbWUgaW5kZXggdG8gc3RvcCBhdFxuICAgICAqL1xuXG5cbiAgICBBbmltYXRlZFNwcml0ZS5wcm90b3R5cGUuZ290b0FuZFN0b3AgPSBmdW5jdGlvbiBnb3RvQW5kU3RvcChmcmFtZU51bWJlcikge1xuICAgICAgICB0aGlzLnN0b3AoKTtcblxuICAgICAgICB2YXIgcHJldmlvdXNGcmFtZSA9IHRoaXMuY3VycmVudEZyYW1lO1xuXG4gICAgICAgIHRoaXMuX2N1cnJlbnRUaW1lID0gZnJhbWVOdW1iZXI7XG5cbiAgICAgICAgaWYgKHByZXZpb3VzRnJhbWUgIT09IHRoaXMuY3VycmVudEZyYW1lKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVRleHR1cmUoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHb2VzIHRvIGEgc3BlY2lmaWMgZnJhbWUgYW5kIGJlZ2lucyBwbGF5aW5nIHRoZSBBbmltYXRlZFNwcml0ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGZyYW1lTnVtYmVyIC0gZnJhbWUgaW5kZXggdG8gc3RhcnQgYXRcbiAgICAgKi9cblxuXG4gICAgQW5pbWF0ZWRTcHJpdGUucHJvdG90eXBlLmdvdG9BbmRQbGF5ID0gZnVuY3Rpb24gZ290b0FuZFBsYXkoZnJhbWVOdW1iZXIpIHtcbiAgICAgICAgdmFyIHByZXZpb3VzRnJhbWUgPSB0aGlzLmN1cnJlbnRGcmFtZTtcblxuICAgICAgICB0aGlzLl9jdXJyZW50VGltZSA9IGZyYW1lTnVtYmVyO1xuXG4gICAgICAgIGlmIChwcmV2aW91c0ZyYW1lICE9PSB0aGlzLmN1cnJlbnRGcmFtZSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVUZXh0dXJlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnBsYXkoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgb2JqZWN0IHRyYW5zZm9ybSBmb3IgcmVuZGVyaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGVsdGFUaW1lIC0gVGltZSBzaW5jZSBsYXN0IHRpY2suXG4gICAgICovXG5cblxuICAgIEFuaW1hdGVkU3ByaXRlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoZGVsdGFUaW1lKSB7XG4gICAgICAgIHZhciBlbGFwc2VkID0gdGhpcy5hbmltYXRpb25TcGVlZCAqIGRlbHRhVGltZTtcbiAgICAgICAgdmFyIHByZXZpb3VzRnJhbWUgPSB0aGlzLmN1cnJlbnRGcmFtZTtcblxuICAgICAgICBpZiAodGhpcy5fZHVyYXRpb25zICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgbGFnID0gdGhpcy5fY3VycmVudFRpbWUgJSAxICogdGhpcy5fZHVyYXRpb25zW3RoaXMuY3VycmVudEZyYW1lXTtcblxuICAgICAgICAgICAgbGFnICs9IGVsYXBzZWQgLyA2MCAqIDEwMDA7XG5cbiAgICAgICAgICAgIHdoaWxlIChsYWcgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudFRpbWUtLTtcbiAgICAgICAgICAgICAgICBsYWcgKz0gdGhpcy5fZHVyYXRpb25zW3RoaXMuY3VycmVudEZyYW1lXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHNpZ24gPSBNYXRoLnNpZ24odGhpcy5hbmltYXRpb25TcGVlZCAqIGRlbHRhVGltZSk7XG5cbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRUaW1lID0gTWF0aC5mbG9vcih0aGlzLl9jdXJyZW50VGltZSk7XG5cbiAgICAgICAgICAgIHdoaWxlIChsYWcgPj0gdGhpcy5fZHVyYXRpb25zW3RoaXMuY3VycmVudEZyYW1lXSkge1xuICAgICAgICAgICAgICAgIGxhZyAtPSB0aGlzLl9kdXJhdGlvbnNbdGhpcy5jdXJyZW50RnJhbWVdICogc2lnbjtcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50VGltZSArPSBzaWduO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50VGltZSArPSBsYWcgLyB0aGlzLl9kdXJhdGlvbnNbdGhpcy5jdXJyZW50RnJhbWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudFRpbWUgKz0gZWxhcHNlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9jdXJyZW50VGltZSA8IDAgJiYgIXRoaXMubG9vcCkge1xuICAgICAgICAgICAgdGhpcy5nb3RvQW5kU3RvcCgwKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMub25Db21wbGV0ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMub25Db21wbGV0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2N1cnJlbnRUaW1lID49IHRoaXMuX3RleHR1cmVzLmxlbmd0aCAmJiAhdGhpcy5sb29wKSB7XG4gICAgICAgICAgICB0aGlzLmdvdG9BbmRTdG9wKHRoaXMuX3RleHR1cmVzLmxlbmd0aCAtIDEpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5vbkNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkNvbXBsZXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAocHJldmlvdXNGcmFtZSAhPT0gdGhpcy5jdXJyZW50RnJhbWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmxvb3AgJiYgdGhpcy5vbkxvb3ApIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hbmltYXRpb25TcGVlZCA+IDAgJiYgdGhpcy5jdXJyZW50RnJhbWUgPCBwcmV2aW91c0ZyYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25Mb29wKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmFuaW1hdGlvblNwZWVkIDwgMCAmJiB0aGlzLmN1cnJlbnRGcmFtZSA+IHByZXZpb3VzRnJhbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkxvb3AoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMudXBkYXRlVGV4dHVyZSgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGRpc3BsYXllZCB0ZXh0dXJlIHRvIG1hdGNoIHRoZSBjdXJyZW50IGZyYW1lIGluZGV4XG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG5cbiAgICBBbmltYXRlZFNwcml0ZS5wcm90b3R5cGUudXBkYXRlVGV4dHVyZSA9IGZ1bmN0aW9uIHVwZGF0ZVRleHR1cmUoKSB7XG4gICAgICAgIHRoaXMuX3RleHR1cmUgPSB0aGlzLl90ZXh0dXJlc1t0aGlzLmN1cnJlbnRGcmFtZV07XG4gICAgICAgIHRoaXMuX3RleHR1cmVJRCA9IC0xO1xuICAgICAgICB0aGlzLmNhY2hlZFRpbnQgPSAweEZGRkZGRjtcblxuICAgICAgICBpZiAodGhpcy51cGRhdGVBbmNob3IpIHtcbiAgICAgICAgICAgIHRoaXMuX2FuY2hvci5jb3B5KHRoaXMuX3RleHR1cmUuZGVmYXVsdEFuY2hvcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5vbkZyYW1lQ2hhbmdlKSB7XG4gICAgICAgICAgICB0aGlzLm9uRnJhbWVDaGFuZ2UodGhpcy5jdXJyZW50RnJhbWUpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFN0b3BzIHRoZSBBbmltYXRlZFNwcml0ZSBhbmQgZGVzdHJveXMgaXRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fGJvb2xlYW59IFtvcHRpb25zXSAtIE9wdGlvbnMgcGFyYW1ldGVyLiBBIGJvb2xlYW4gd2lsbCBhY3QgYXMgaWYgYWxsIG9wdGlvbnNcbiAgICAgKiAgaGF2ZSBiZWVuIHNldCB0byB0aGF0IHZhbHVlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jaGlsZHJlbj1mYWxzZV0gLSBpZiBzZXQgdG8gdHJ1ZSwgYWxsIHRoZSBjaGlsZHJlbiB3aWxsIGhhdmUgdGhlaXIgZGVzdHJveVxuICAgICAqICAgICAgbWV0aG9kIGNhbGxlZCBhcyB3ZWxsLiAnb3B0aW9ucycgd2lsbCBiZSBwYXNzZWQgb24gdG8gdGhvc2UgY2FsbHMuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50ZXh0dXJlPWZhbHNlXSAtIFNob3VsZCBpdCBkZXN0cm95IHRoZSBjdXJyZW50IHRleHR1cmUgb2YgdGhlIHNwcml0ZSBhcyB3ZWxsXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5iYXNlVGV4dHVyZT1mYWxzZV0gLSBTaG91bGQgaXQgZGVzdHJveSB0aGUgYmFzZSB0ZXh0dXJlIG9mIHRoZSBzcHJpdGUgYXMgd2VsbFxuICAgICAqL1xuXG5cbiAgICBBbmltYXRlZFNwcml0ZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3kob3B0aW9ucykge1xuICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgX2NvcmUkU3ByaXRlLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEEgc2hvcnQgaGFuZCB3YXkgb2YgY3JlYXRpbmcgYSBtb3ZpZWNsaXAgZnJvbSBhbiBhcnJheSBvZiBmcmFtZSBpZHNcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBmcmFtZXMgLSBUaGUgYXJyYXkgb2YgZnJhbWVzIGlkcyB0aGUgbW92aWVjbGlwIHdpbGwgdXNlIGFzIGl0cyB0ZXh0dXJlIGZyYW1lc1xuICAgICAqIEByZXR1cm4ge0FuaW1hdGVkU3ByaXRlfSBUaGUgbmV3IGFuaW1hdGVkIHNwcml0ZSB3aXRoIHRoZSBzcGVjaWZpZWQgZnJhbWVzLlxuICAgICAqL1xuXG5cbiAgICBBbmltYXRlZFNwcml0ZS5mcm9tRnJhbWVzID0gZnVuY3Rpb24gZnJvbUZyYW1lcyhmcmFtZXMpIHtcbiAgICAgICAgdmFyIHRleHR1cmVzID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmcmFtZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHRleHR1cmVzLnB1c2goY29yZS5UZXh0dXJlLmZyb21GcmFtZShmcmFtZXNbaV0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgQW5pbWF0ZWRTcHJpdGUodGV4dHVyZXMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBIHNob3J0IGhhbmQgd2F5IG9mIGNyZWF0aW5nIGEgbW92aWVjbGlwIGZyb20gYW4gYXJyYXkgb2YgaW1hZ2UgaWRzXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gaW1hZ2VzIC0gdGhlIGFycmF5IG9mIGltYWdlIHVybHMgdGhlIG1vdmllY2xpcCB3aWxsIHVzZSBhcyBpdHMgdGV4dHVyZSBmcmFtZXNcbiAgICAgKiBAcmV0dXJuIHtBbmltYXRlZFNwcml0ZX0gVGhlIG5ldyBhbmltYXRlIHNwcml0ZSB3aXRoIHRoZSBzcGVjaWZpZWQgaW1hZ2VzIGFzIGZyYW1lcy5cbiAgICAgKi9cblxuXG4gICAgQW5pbWF0ZWRTcHJpdGUuZnJvbUltYWdlcyA9IGZ1bmN0aW9uIGZyb21JbWFnZXMoaW1hZ2VzKSB7XG4gICAgICAgIHZhciB0ZXh0dXJlcyA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW1hZ2VzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB0ZXh0dXJlcy5wdXNoKGNvcmUuVGV4dHVyZS5mcm9tSW1hZ2UoaW1hZ2VzW2ldKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IEFuaW1hdGVkU3ByaXRlKHRleHR1cmVzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogdG90YWxGcmFtZXMgaXMgdGhlIHRvdGFsIG51bWJlciBvZiBmcmFtZXMgaW4gdGhlIEFuaW1hdGVkU3ByaXRlLiBUaGlzIGlzIHRoZSBzYW1lIGFzIG51bWJlciBvZiB0ZXh0dXJlc1xuICAgICAqIGFzc2lnbmVkIHRvIHRoZSBBbmltYXRlZFNwcml0ZS5cbiAgICAgKlxuICAgICAqIEByZWFkb25seVxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG5cblxuICAgIF9jcmVhdGVDbGFzcyhBbmltYXRlZFNwcml0ZSwgW3tcbiAgICAgICAga2V5OiAndG90YWxGcmFtZXMnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90ZXh0dXJlcy5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGFycmF5IG9mIHRleHR1cmVzIHVzZWQgZm9yIHRoaXMgQW5pbWF0ZWRTcHJpdGVcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5UZXh0dXJlW119XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICd0ZXh0dXJlcycsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RleHR1cmVzO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSByZXF1aXJlLWpzZG9jXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZVswXSBpbnN0YW5jZW9mIGNvcmUuVGV4dHVyZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RleHR1cmVzID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHVyYXRpb25zID0gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGV4dHVyZXMgPSBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9kdXJhdGlvbnMgPSBbXTtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGV4dHVyZXMucHVzaCh2YWx1ZVtpXS50ZXh0dXJlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHVyYXRpb25zLnB1c2godmFsdWVbaV0udGltZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5nb3RvQW5kU3RvcCgwKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVGV4dHVyZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICogVGhlIEFuaW1hdGVkU3ByaXRlcyBjdXJyZW50IGZyYW1lIGluZGV4XG4gICAgICAgICpcbiAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2N1cnJlbnRGcmFtZScsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRGcmFtZSA9IE1hdGguZmxvb3IodGhpcy5fY3VycmVudFRpbWUpICUgdGhpcy5fdGV4dHVyZXMubGVuZ3RoO1xuXG4gICAgICAgICAgICBpZiAoY3VycmVudEZyYW1lIDwgMCkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRGcmFtZSArPSB0aGlzLl90ZXh0dXJlcy5sZW5ndGg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50RnJhbWU7XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gQW5pbWF0ZWRTcHJpdGU7XG59KGNvcmUuU3ByaXRlKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gQW5pbWF0ZWRTcHJpdGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BbmltYXRlZFNwcml0ZS5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfY29yZSA9IHJlcXVpcmUoJy4uL2NvcmUnKTtcblxudmFyIGNvcmUgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfY29yZSk7XG5cbnZhciBfT2JzZXJ2YWJsZVBvaW50ID0gcmVxdWlyZSgnLi4vY29yZS9tYXRoL09ic2VydmFibGVQb2ludCcpO1xuXG52YXIgX09ic2VydmFibGVQb2ludDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9PYnNlcnZhYmxlUG9pbnQpO1xuXG52YXIgX3V0aWxzID0gcmVxdWlyZSgnLi4vY29yZS91dGlscycpO1xuXG52YXIgX3NldHRpbmdzID0gcmVxdWlyZSgnLi4vY29yZS9zZXR0aW5ncycpO1xuXG52YXIgX3NldHRpbmdzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NldHRpbmdzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4vKipcbiAqIEEgQml0bWFwVGV4dCBvYmplY3Qgd2lsbCBjcmVhdGUgYSBsaW5lIG9yIG11bHRpcGxlIGxpbmVzIG9mIHRleHQgdXNpbmcgYml0bWFwIGZvbnQuIFRvXG4gKiBzcGxpdCBhIGxpbmUgeW91IGNhbiB1c2UgJ1xcbicsICdcXHInIG9yICdcXHJcXG4nIGluIHlvdXIgc3RyaW5nLiBZb3UgY2FuIGdlbmVyYXRlIHRoZSBmbnQgZmlsZXMgdXNpbmc6XG4gKlxuICogQSBCaXRtYXBUZXh0IGNhbiBvbmx5IGJlIGNyZWF0ZWQgd2hlbiB0aGUgZm9udCBpcyBsb2FkZWRcbiAqXG4gKiBgYGBqc1xuICogLy8gaW4gdGhpcyBjYXNlIHRoZSBmb250IGlzIGluIGEgZmlsZSBjYWxsZWQgJ2Rlc3lyZWwuZm50J1xuICogbGV0IGJpdG1hcFRleHQgPSBuZXcgUElYSS5leHRyYXMuQml0bWFwVGV4dChcInRleHQgdXNpbmcgYSBmYW5jeSBmb250IVwiLCB7Zm9udDogXCIzNXB4IERlc3lyZWxcIiwgYWxpZ246IFwicmlnaHRcIn0pO1xuICogYGBgXG4gKlxuICogaHR0cDovL3d3dy5hbmdlbGNvZGUuY29tL3Byb2R1Y3RzL2JtZm9udC8gZm9yIHdpbmRvd3Mgb3JcbiAqIGh0dHA6Ly93d3cuYm1nbHlwaC5jb20vIGZvciBtYWMuXG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQSVhJLkNvbnRhaW5lclxuICogQG1lbWJlcm9mIFBJWEkuZXh0cmFzXG4gKi9cbnZhciBCaXRtYXBUZXh0ID0gZnVuY3Rpb24gKF9jb3JlJENvbnRhaW5lcikge1xuICAgIF9pbmhlcml0cyhCaXRtYXBUZXh0LCBfY29yZSRDb250YWluZXIpO1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSBUaGUgY29weSB0aGF0IHlvdSB3b3VsZCBsaWtlIHRoZSB0ZXh0IHRvIGRpc3BsYXlcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc3R5bGUgLSBUaGUgc3R5bGUgcGFyYW1ldGVyc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gc3R5bGUuZm9udCAtIFRoZSBmb250IGRlc2NyaXB0b3IgZm9yIHRoZSBvYmplY3QsIGNhbiBiZSBwYXNzZWQgYXMgYSBzdHJpbmcgb2YgZm9ybVxuICAgICAqICAgICAgXCIyNHB4IEZvbnROYW1lXCIgb3IgXCJGb250TmFtZVwiIG9yIGFzIGFuIG9iamVjdCB3aXRoIGV4cGxpY2l0IG5hbWUvc2l6ZSBwcm9wZXJ0aWVzLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3R5bGUuZm9udC5uYW1lXSAtIFRoZSBiaXRtYXAgZm9udCBpZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3R5bGUuZm9udC5zaXplXSAtIFRoZSBzaXplIG9mIHRoZSBmb250IGluIHBpeGVscywgZS5nLiAyNFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3R5bGUuYWxpZ249J2xlZnQnXSAtIEFsaWdubWVudCBmb3IgbXVsdGlsaW5lIHRleHQgKCdsZWZ0JywgJ2NlbnRlcicgb3IgJ3JpZ2h0JyksIGRvZXMgbm90IGFmZmVjdFxuICAgICAqICAgICAgc2luZ2xlIGxpbmUgdGV4dFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3R5bGUudGludD0weEZGRkZGRl0gLSBUaGUgdGludCBjb2xvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEJpdG1hcFRleHQodGV4dCkge1xuICAgICAgICB2YXIgc3R5bGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCaXRtYXBUZXh0KTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUHJpdmF0ZSB0cmFja2VyIGZvciB0aGUgd2lkdGggb2YgdGhlIG92ZXJhbGwgdGV4dFxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfY29yZSRDb250YWluZXIuY2FsbCh0aGlzKSk7XG5cbiAgICAgICAgX3RoaXMuX3RleHRXaWR0aCA9IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByaXZhdGUgdHJhY2tlciBmb3IgdGhlIGhlaWdodCBvZiB0aGUgb3ZlcmFsbCB0ZXh0XG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLl90ZXh0SGVpZ2h0ID0gMDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUHJpdmF0ZSB0cmFja2VyIGZvciB0aGUgbGV0dGVyIHNwcml0ZSBwb29sLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLlNwcml0ZVtdfVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuX2dseXBocyA9IFtdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcml2YXRlIHRyYWNrZXIgZm9yIHRoZSBjdXJyZW50IHN0eWxlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtvYmplY3R9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5fZm9udCA9IHtcbiAgICAgICAgICAgIHRpbnQ6IHN0eWxlLnRpbnQgIT09IHVuZGVmaW5lZCA/IHN0eWxlLnRpbnQgOiAweEZGRkZGRixcbiAgICAgICAgICAgIGFsaWduOiBzdHlsZS5hbGlnbiB8fCAnbGVmdCcsXG4gICAgICAgICAgICBuYW1lOiBudWxsLFxuICAgICAgICAgICAgc2l6ZTogMFxuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcml2YXRlIHRyYWNrZXIgZm9yIHRoZSBjdXJyZW50IGZvbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge29iamVjdH1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLmZvbnQgPSBzdHlsZS5mb250OyAvLyBydW4gZm9udCBzZXR0ZXJcblxuICAgICAgICAvKipcbiAgICAgICAgICogUHJpdmF0ZSB0cmFja2VyIGZvciB0aGUgY3VycmVudCB0ZXh0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5fdGV4dCA9IHRleHQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBtYXggd2lkdGggb2YgdGhpcyBiaXRtYXAgdGV4dCBpbiBwaXhlbHMuIElmIHRoZSB0ZXh0IHByb3ZpZGVkIGlzIGxvbmdlciB0aGFuIHRoZVxuICAgICAgICAgKiB2YWx1ZSBwcm92aWRlZCwgbGluZSBicmVha3Mgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGluc2VydGVkIGluIHRoZSBsYXN0IHdoaXRlc3BhY2UuXG4gICAgICAgICAqIERpc2FibGUgYnkgc2V0dGluZyB2YWx1ZSB0byAwXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLl9tYXhXaWR0aCA9IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBtYXggbGluZSBoZWlnaHQuIFRoaXMgaXMgdXNlZnVsIHdoZW4gdHJ5aW5nIHRvIHVzZSB0aGUgdG90YWwgaGVpZ2h0IG9mIHRoZSBUZXh0LFxuICAgICAgICAgKiBpZTogd2hlbiB0cnlpbmcgdG8gdmVydGljYWxseSBhbGlnbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuX21heExpbmVIZWlnaHQgPSAwO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMZXR0ZXIgc3BhY2luZy4gVGhpcyBpcyB1c2VmdWwgZm9yIHNldHRpbmcgdGhlIHNwYWNlIGJldHdlZW4gY2hhcmFjdGVycy5cbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuX2xldHRlclNwYWNpbmcgPSAwO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUZXh0IGFuY2hvci4gcmVhZC1vbmx5XG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuT2JzZXJ2YWJsZVBvaW50fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuX2FuY2hvciA9IG5ldyBfT2JzZXJ2YWJsZVBvaW50Mi5kZWZhdWx0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgfSwgX3RoaXMsIDAsIDApO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGlydHkgc3RhdGUgb2YgdGhpcyBvYmplY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5kaXJ0eSA9IGZhbHNlO1xuXG4gICAgICAgIF90aGlzLnVwZGF0ZVRleHQoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgdGV4dCBhbmQgdXBkYXRlcyBpdCB3aGVuIG5lZWRlZFxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuXG4gICAgQml0bWFwVGV4dC5wcm90b3R5cGUudXBkYXRlVGV4dCA9IGZ1bmN0aW9uIHVwZGF0ZVRleHQoKSB7XG4gICAgICAgIHZhciBkYXRhID0gQml0bWFwVGV4dC5mb250c1t0aGlzLl9mb250Lm5hbWVdO1xuICAgICAgICB2YXIgc2NhbGUgPSB0aGlzLl9mb250LnNpemUgLyBkYXRhLnNpemU7XG4gICAgICAgIHZhciBwb3MgPSBuZXcgY29yZS5Qb2ludCgpO1xuICAgICAgICB2YXIgY2hhcnMgPSBbXTtcbiAgICAgICAgdmFyIGxpbmVXaWR0aHMgPSBbXTtcbiAgICAgICAgdmFyIHRleHQgPSB0aGlzLnRleHQucmVwbGFjZSgvKD86XFxyXFxufFxccikvZywgJ1xcbicpO1xuICAgICAgICB2YXIgdGV4dExlbmd0aCA9IHRleHQubGVuZ3RoO1xuICAgICAgICB2YXIgbWF4V2lkdGggPSB0aGlzLl9tYXhXaWR0aCAqIGRhdGEuc2l6ZSAvIHRoaXMuX2ZvbnQuc2l6ZTtcblxuICAgICAgICB2YXIgcHJldkNoYXJDb2RlID0gbnVsbDtcbiAgICAgICAgdmFyIGxhc3RMaW5lV2lkdGggPSAwO1xuICAgICAgICB2YXIgbWF4TGluZVdpZHRoID0gMDtcbiAgICAgICAgdmFyIGxpbmUgPSAwO1xuICAgICAgICB2YXIgbGFzdEJyZWFrUG9zID0gLTE7XG4gICAgICAgIHZhciBsYXN0QnJlYWtXaWR0aCA9IDA7XG4gICAgICAgIHZhciBzcGFjZXNSZW1vdmVkID0gMDtcbiAgICAgICAgdmFyIG1heExpbmVIZWlnaHQgPSAwO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGV4dExlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2hhckNvZGUgPSB0ZXh0LmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICB2YXIgY2hhciA9IHRleHQuY2hhckF0KGkpO1xuXG4gICAgICAgICAgICBpZiAoLyg/OlxccykvLnRlc3QoY2hhcikpIHtcbiAgICAgICAgICAgICAgICBsYXN0QnJlYWtQb3MgPSBpO1xuICAgICAgICAgICAgICAgIGxhc3RCcmVha1dpZHRoID0gbGFzdExpbmVXaWR0aDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNoYXIgPT09ICdcXHInIHx8IGNoYXIgPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgbGluZVdpZHRocy5wdXNoKGxhc3RMaW5lV2lkdGgpO1xuICAgICAgICAgICAgICAgIG1heExpbmVXaWR0aCA9IE1hdGgubWF4KG1heExpbmVXaWR0aCwgbGFzdExpbmVXaWR0aCk7XG4gICAgICAgICAgICAgICAgKytsaW5lO1xuICAgICAgICAgICAgICAgICsrc3BhY2VzUmVtb3ZlZDtcblxuICAgICAgICAgICAgICAgIHBvcy54ID0gMDtcbiAgICAgICAgICAgICAgICBwb3MueSArPSBkYXRhLmxpbmVIZWlnaHQ7XG4gICAgICAgICAgICAgICAgcHJldkNoYXJDb2RlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGNoYXJEYXRhID0gZGF0YS5jaGFyc1tjaGFyQ29kZV07XG5cbiAgICAgICAgICAgIGlmICghY2hhckRhdGEpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHByZXZDaGFyQ29kZSAmJiBjaGFyRGF0YS5rZXJuaW5nW3ByZXZDaGFyQ29kZV0pIHtcbiAgICAgICAgICAgICAgICBwb3MueCArPSBjaGFyRGF0YS5rZXJuaW5nW3ByZXZDaGFyQ29kZV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNoYXJzLnB1c2goe1xuICAgICAgICAgICAgICAgIHRleHR1cmU6IGNoYXJEYXRhLnRleHR1cmUsXG4gICAgICAgICAgICAgICAgbGluZTogbGluZSxcbiAgICAgICAgICAgICAgICBjaGFyQ29kZTogY2hhckNvZGUsXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IG5ldyBjb3JlLlBvaW50KHBvcy54ICsgY2hhckRhdGEueE9mZnNldCArIHRoaXMuX2xldHRlclNwYWNpbmcgLyAyLCBwb3MueSArIGNoYXJEYXRhLnlPZmZzZXQpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHBvcy54ICs9IGNoYXJEYXRhLnhBZHZhbmNlICsgdGhpcy5fbGV0dGVyU3BhY2luZztcbiAgICAgICAgICAgIGxhc3RMaW5lV2lkdGggPSBwb3MueDtcbiAgICAgICAgICAgIG1heExpbmVIZWlnaHQgPSBNYXRoLm1heChtYXhMaW5lSGVpZ2h0LCBjaGFyRGF0YS55T2Zmc2V0ICsgY2hhckRhdGEudGV4dHVyZS5oZWlnaHQpO1xuICAgICAgICAgICAgcHJldkNoYXJDb2RlID0gY2hhckNvZGU7XG5cbiAgICAgICAgICAgIGlmIChsYXN0QnJlYWtQb3MgIT09IC0xICYmIG1heFdpZHRoID4gMCAmJiBwb3MueCA+IG1heFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgKytzcGFjZXNSZW1vdmVkO1xuICAgICAgICAgICAgICAgIGNvcmUudXRpbHMucmVtb3ZlSXRlbXMoY2hhcnMsIDEgKyBsYXN0QnJlYWtQb3MgLSBzcGFjZXNSZW1vdmVkLCAxICsgaSAtIGxhc3RCcmVha1Bvcyk7XG4gICAgICAgICAgICAgICAgaSA9IGxhc3RCcmVha1BvcztcbiAgICAgICAgICAgICAgICBsYXN0QnJlYWtQb3MgPSAtMTtcblxuICAgICAgICAgICAgICAgIGxpbmVXaWR0aHMucHVzaChsYXN0QnJlYWtXaWR0aCk7XG4gICAgICAgICAgICAgICAgbWF4TGluZVdpZHRoID0gTWF0aC5tYXgobWF4TGluZVdpZHRoLCBsYXN0QnJlYWtXaWR0aCk7XG4gICAgICAgICAgICAgICAgbGluZSsrO1xuXG4gICAgICAgICAgICAgICAgcG9zLnggPSAwO1xuICAgICAgICAgICAgICAgIHBvcy55ICs9IGRhdGEubGluZUhlaWdodDtcbiAgICAgICAgICAgICAgICBwcmV2Q2hhckNvZGUgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxhc3RDaGFyID0gdGV4dC5jaGFyQXQodGV4dC5sZW5ndGggLSAxKTtcblxuICAgICAgICBpZiAobGFzdENoYXIgIT09ICdcXHInICYmIGxhc3RDaGFyICE9PSAnXFxuJykge1xuICAgICAgICAgICAgaWYgKC8oPzpcXHMpLy50ZXN0KGxhc3RDaGFyKSkge1xuICAgICAgICAgICAgICAgIGxhc3RMaW5lV2lkdGggPSBsYXN0QnJlYWtXaWR0aDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGluZVdpZHRocy5wdXNoKGxhc3RMaW5lV2lkdGgpO1xuICAgICAgICAgICAgbWF4TGluZVdpZHRoID0gTWF0aC5tYXgobWF4TGluZVdpZHRoLCBsYXN0TGluZVdpZHRoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsaW5lQWxpZ25PZmZzZXRzID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8PSBsaW5lOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgYWxpZ25PZmZzZXQgPSAwO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fZm9udC5hbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgICAgICAgIGFsaWduT2Zmc2V0ID0gbWF4TGluZVdpZHRoIC0gbGluZVdpZHRoc1tfaV07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2ZvbnQuYWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgICAgICAgYWxpZ25PZmZzZXQgPSAobWF4TGluZVdpZHRoIC0gbGluZVdpZHRoc1tfaV0pIC8gMjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGluZUFsaWduT2Zmc2V0cy5wdXNoKGFsaWduT2Zmc2V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsZW5DaGFycyA9IGNoYXJzLmxlbmd0aDtcbiAgICAgICAgdmFyIHRpbnQgPSB0aGlzLnRpbnQ7XG5cbiAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgbGVuQ2hhcnM7IF9pMisrKSB7XG4gICAgICAgICAgICB2YXIgYyA9IHRoaXMuX2dseXBoc1tfaTJdOyAvLyBnZXQgdGhlIG5leHQgZ2x5cGggc3ByaXRlXG5cbiAgICAgICAgICAgIGlmIChjKSB7XG4gICAgICAgICAgICAgICAgYy50ZXh0dXJlID0gY2hhcnNbX2kyXS50ZXh0dXJlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjID0gbmV3IGNvcmUuU3ByaXRlKGNoYXJzW19pMl0udGV4dHVyZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZ2x5cGhzLnB1c2goYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGMucG9zaXRpb24ueCA9IChjaGFyc1tfaTJdLnBvc2l0aW9uLnggKyBsaW5lQWxpZ25PZmZzZXRzW2NoYXJzW19pMl0ubGluZV0pICogc2NhbGU7XG4gICAgICAgICAgICBjLnBvc2l0aW9uLnkgPSBjaGFyc1tfaTJdLnBvc2l0aW9uLnkgKiBzY2FsZTtcbiAgICAgICAgICAgIGMuc2NhbGUueCA9IGMuc2NhbGUueSA9IHNjYWxlO1xuICAgICAgICAgICAgYy50aW50ID0gdGludDtcblxuICAgICAgICAgICAgaWYgKCFjLnBhcmVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkQ2hpbGQoYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZW1vdmUgdW5uZWNlc3NhcnkgY2hpbGRyZW4uXG4gICAgICAgIGZvciAodmFyIF9pMyA9IGxlbkNoYXJzOyBfaTMgPCB0aGlzLl9nbHlwaHMubGVuZ3RoOyArK19pMykge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVDaGlsZCh0aGlzLl9nbHlwaHNbX2kzXSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl90ZXh0V2lkdGggPSBtYXhMaW5lV2lkdGggKiBzY2FsZTtcbiAgICAgICAgdGhpcy5fdGV4dEhlaWdodCA9IChwb3MueSArIGRhdGEubGluZUhlaWdodCkgKiBzY2FsZTtcblxuICAgICAgICAvLyBhcHBseSBhbmNob3JcbiAgICAgICAgaWYgKHRoaXMuYW5jaG9yLnggIT09IDAgfHwgdGhpcy5hbmNob3IueSAhPT0gMCkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2k0ID0gMDsgX2k0IDwgbGVuQ2hhcnM7IF9pNCsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZ2x5cGhzW19pNF0ueCAtPSB0aGlzLl90ZXh0V2lkdGggKiB0aGlzLmFuY2hvci54O1xuICAgICAgICAgICAgICAgIHRoaXMuX2dseXBoc1tfaTRdLnkgLT0gdGhpcy5fdGV4dEhlaWdodCAqIHRoaXMuYW5jaG9yLnk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbWF4TGluZUhlaWdodCA9IG1heExpbmVIZWlnaHQgKiBzY2FsZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgdHJhbnNmb3JtIG9mIHRoaXMgb2JqZWN0XG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG5cbiAgICBCaXRtYXBUZXh0LnByb3RvdHlwZS51cGRhdGVUcmFuc2Zvcm0gPSBmdW5jdGlvbiB1cGRhdGVUcmFuc2Zvcm0oKSB7XG4gICAgICAgIHRoaXMudmFsaWRhdGUoKTtcbiAgICAgICAgdGhpcy5jb250YWluZXJVcGRhdGVUcmFuc2Zvcm0oKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVmFsaWRhdGVzIHRleHQgYmVmb3JlIGNhbGxpbmcgcGFyZW50J3MgZ2V0TG9jYWxCb3VuZHNcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1BJWEkuUmVjdGFuZ2xlfSBUaGUgcmVjdGFuZ3VsYXIgYm91bmRpbmcgYXJlYVxuICAgICAqL1xuXG5cbiAgICBCaXRtYXBUZXh0LnByb3RvdHlwZS5nZXRMb2NhbEJvdW5kcyA9IGZ1bmN0aW9uIGdldExvY2FsQm91bmRzKCkge1xuICAgICAgICB0aGlzLnZhbGlkYXRlKCk7XG5cbiAgICAgICAgcmV0dXJuIF9jb3JlJENvbnRhaW5lci5wcm90b3R5cGUuZ2V0TG9jYWxCb3VuZHMuY2FsbCh0aGlzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0ZXh0IHdoZW4gbmVlZGVkXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG5cbiAgICBCaXRtYXBUZXh0LnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uIHZhbGlkYXRlKCkge1xuICAgICAgICBpZiAodGhpcy5kaXJ0eSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVUZXh0KCk7XG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIHRpbnQgb2YgdGhlIEJpdG1hcFRleHQgb2JqZWN0XG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICovXG5cblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGEgYml0bWFwIGZvbnQgd2l0aCBkYXRhIGFuZCBhIHRleHR1cmUuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtYTUxEb2N1bWVudH0geG1sIC0gVGhlIFhNTCBkb2N1bWVudCBkYXRhLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsIFBJWEkuVGV4dHVyZT58UElYSS5UZXh0dXJlfFBJWEkuVGV4dHVyZVtdfSB0ZXh0dXJlcyAtIExpc3Qgb2YgdGV4dHVyZXMgZm9yIGVhY2ggcGFnZS5cbiAgICAgKiAgSWYgcHJvdmlkaW5nIGFuIG9iamVjdCwgdGhlIGtleSBpcyB0aGUgYDxwYWdlPmAgZWxlbWVudCdzIGBmaWxlYCBhdHRyaWJ1dGUgaW4gdGhlIEZOVCBmaWxlLlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gUmVzdWx0IGZvbnQgb2JqZWN0IHdpdGggZm9udCwgc2l6ZSwgbGluZUhlaWdodCBhbmQgY2hhciBmaWVsZHMuXG4gICAgICovXG4gICAgQml0bWFwVGV4dC5yZWdpc3RlckZvbnQgPSBmdW5jdGlvbiByZWdpc3RlckZvbnQoeG1sLCB0ZXh0dXJlcykge1xuICAgICAgICB2YXIgZGF0YSA9IHt9O1xuICAgICAgICB2YXIgaW5mbyA9IHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaW5mbycpWzBdO1xuICAgICAgICB2YXIgY29tbW9uID0geG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdjb21tb24nKVswXTtcbiAgICAgICAgdmFyIHBhZ2VzID0geG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdwYWdlJyk7XG4gICAgICAgIHZhciByZXMgPSAoMCwgX3V0aWxzLmdldFJlc29sdXRpb25PZlVybCkocGFnZXNbMF0uZ2V0QXR0cmlidXRlKCdmaWxlJyksIF9zZXR0aW5nczIuZGVmYXVsdC5SRVNPTFVUSU9OKTtcbiAgICAgICAgdmFyIHBhZ2VzVGV4dHVyZXMgPSB7fTtcblxuICAgICAgICBkYXRhLmZvbnQgPSBpbmZvLmdldEF0dHJpYnV0ZSgnZmFjZScpO1xuICAgICAgICBkYXRhLnNpemUgPSBwYXJzZUludChpbmZvLmdldEF0dHJpYnV0ZSgnc2l6ZScpLCAxMCk7XG4gICAgICAgIGRhdGEubGluZUhlaWdodCA9IHBhcnNlSW50KGNvbW1vbi5nZXRBdHRyaWJ1dGUoJ2xpbmVIZWlnaHQnKSwgMTApIC8gcmVzO1xuICAgICAgICBkYXRhLmNoYXJzID0ge307XG5cbiAgICAgICAgLy8gU2luZ2xlIHRleHR1cmUsIGNvbnZlcnQgdG8gbGlzdFxuICAgICAgICBpZiAodGV4dHVyZXMgaW5zdGFuY2VvZiBjb3JlLlRleHR1cmUpIHtcbiAgICAgICAgICAgIHRleHR1cmVzID0gW3RleHR1cmVzXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENvbnZlcnQgdGhlIGlucHV0IFRleHR1cmUsIFRleHR1cmVzIG9yIG9iamVjdFxuICAgICAgICAvLyBpbnRvIGEgcGFnZSBUZXh0dXJlIGxvb2t1cCBieSBcImlkXCJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYWdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGlkID0gcGFnZXNbaV0uZ2V0QXR0cmlidXRlKCdpZCcpO1xuICAgICAgICAgICAgdmFyIGZpbGUgPSBwYWdlc1tpXS5nZXRBdHRyaWJ1dGUoJ2ZpbGUnKTtcblxuICAgICAgICAgICAgcGFnZXNUZXh0dXJlc1tpZF0gPSB0ZXh0dXJlcyBpbnN0YW5jZW9mIEFycmF5ID8gdGV4dHVyZXNbaV0gOiB0ZXh0dXJlc1tmaWxlXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHBhcnNlIGxldHRlcnNcbiAgICAgICAgdmFyIGxldHRlcnMgPSB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2NoYXInKTtcblxuICAgICAgICBmb3IgKHZhciBfaTUgPSAwOyBfaTUgPCBsZXR0ZXJzLmxlbmd0aDsgX2k1KyspIHtcbiAgICAgICAgICAgIHZhciBsZXR0ZXIgPSBsZXR0ZXJzW19pNV07XG4gICAgICAgICAgICB2YXIgY2hhckNvZGUgPSBwYXJzZUludChsZXR0ZXIuZ2V0QXR0cmlidXRlKCdpZCcpLCAxMCk7XG4gICAgICAgICAgICB2YXIgcGFnZSA9IGxldHRlci5nZXRBdHRyaWJ1dGUoJ3BhZ2UnKSB8fCAwO1xuICAgICAgICAgICAgdmFyIHRleHR1cmVSZWN0ID0gbmV3IGNvcmUuUmVjdGFuZ2xlKHBhcnNlSW50KGxldHRlci5nZXRBdHRyaWJ1dGUoJ3gnKSwgMTApIC8gcmVzICsgcGFnZXNUZXh0dXJlc1twYWdlXS5mcmFtZS54IC8gcmVzLCBwYXJzZUludChsZXR0ZXIuZ2V0QXR0cmlidXRlKCd5JyksIDEwKSAvIHJlcyArIHBhZ2VzVGV4dHVyZXNbcGFnZV0uZnJhbWUueSAvIHJlcywgcGFyc2VJbnQobGV0dGVyLmdldEF0dHJpYnV0ZSgnd2lkdGgnKSwgMTApIC8gcmVzLCBwYXJzZUludChsZXR0ZXIuZ2V0QXR0cmlidXRlKCdoZWlnaHQnKSwgMTApIC8gcmVzKTtcblxuICAgICAgICAgICAgZGF0YS5jaGFyc1tjaGFyQ29kZV0gPSB7XG4gICAgICAgICAgICAgICAgeE9mZnNldDogcGFyc2VJbnQobGV0dGVyLmdldEF0dHJpYnV0ZSgneG9mZnNldCcpLCAxMCkgLyByZXMsXG4gICAgICAgICAgICAgICAgeU9mZnNldDogcGFyc2VJbnQobGV0dGVyLmdldEF0dHJpYnV0ZSgneW9mZnNldCcpLCAxMCkgLyByZXMsXG4gICAgICAgICAgICAgICAgeEFkdmFuY2U6IHBhcnNlSW50KGxldHRlci5nZXRBdHRyaWJ1dGUoJ3hhZHZhbmNlJyksIDEwKSAvIHJlcyxcbiAgICAgICAgICAgICAgICBrZXJuaW5nOiB7fSxcbiAgICAgICAgICAgICAgICB0ZXh0dXJlOiBuZXcgY29yZS5UZXh0dXJlKHBhZ2VzVGV4dHVyZXNbcGFnZV0uYmFzZVRleHR1cmUsIHRleHR1cmVSZWN0KSxcbiAgICAgICAgICAgICAgICBwYWdlOiBwYWdlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcGFyc2Uga2VybmluZ3NcbiAgICAgICAgdmFyIGtlcm5pbmdzID0geG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdrZXJuaW5nJyk7XG5cbiAgICAgICAgZm9yICh2YXIgX2k2ID0gMDsgX2k2IDwga2VybmluZ3MubGVuZ3RoOyBfaTYrKykge1xuICAgICAgICAgICAgdmFyIGtlcm5pbmcgPSBrZXJuaW5nc1tfaTZdO1xuICAgICAgICAgICAgdmFyIGZpcnN0ID0gcGFyc2VJbnQoa2VybmluZy5nZXRBdHRyaWJ1dGUoJ2ZpcnN0JyksIDEwKSAvIHJlcztcbiAgICAgICAgICAgIHZhciBzZWNvbmQgPSBwYXJzZUludChrZXJuaW5nLmdldEF0dHJpYnV0ZSgnc2Vjb25kJyksIDEwKSAvIHJlcztcbiAgICAgICAgICAgIHZhciBhbW91bnQgPSBwYXJzZUludChrZXJuaW5nLmdldEF0dHJpYnV0ZSgnYW1vdW50JyksIDEwKSAvIHJlcztcblxuICAgICAgICAgICAgaWYgKGRhdGEuY2hhcnNbc2Vjb25kXSkge1xuICAgICAgICAgICAgICAgIGRhdGEuY2hhcnNbc2Vjb25kXS5rZXJuaW5nW2ZpcnN0XSA9IGFtb3VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEknbSBsZWF2aW5nIHRoaXMgYXMgYSB0ZW1wb3JhcnkgZml4IHNvIHdlIGNhbiB0ZXN0IHRoZSBiaXRtYXAgZm9udHMgaW4gdjNcbiAgICAgICAgLy8gYnV0IGl0J3MgdmVyeSBsaWtlbHkgdG8gY2hhbmdlXG4gICAgICAgIEJpdG1hcFRleHQuZm9udHNbZGF0YS5mb250XSA9IGRhdGE7XG5cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfTtcblxuICAgIF9jcmVhdGVDbGFzcyhCaXRtYXBUZXh0LCBbe1xuICAgICAgICBrZXk6ICd0aW50JyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZm9udC50aW50O1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSByZXF1aXJlLWpzZG9jXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX2ZvbnQudGludCA9IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgdmFsdWUgPj0gMCA/IHZhbHVlIDogMHhGRkZGRkY7XG5cbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBhbGlnbm1lbnQgb2YgdGhlIEJpdG1hcFRleHQgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge3N0cmluZ31cbiAgICAgICAgICogQGRlZmF1bHQgJ2xlZnQnXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdhbGlnbicsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZvbnQuYWxpZ247XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlcXVpcmUtanNkb2NcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fZm9udC5hbGlnbiA9IHZhbHVlIHx8ICdsZWZ0JztcblxuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGFuY2hvciBzZXRzIHRoZSBvcmlnaW4gcG9pbnQgb2YgdGhlIHRleHQuXG4gICAgICAgICAqIFRoZSBkZWZhdWx0IGlzIDAsMCB0aGlzIG1lYW5zIHRoZSB0ZXh0J3Mgb3JpZ2luIGlzIHRoZSB0b3AgbGVmdFxuICAgICAgICAgKiBTZXR0aW5nIHRoZSBhbmNob3IgdG8gMC41LDAuNSBtZWFucyB0aGUgdGV4dCdzIG9yaWdpbiBpcyBjZW50ZXJlZFxuICAgICAgICAgKiBTZXR0aW5nIHRoZSBhbmNob3IgdG8gMSwxIHdvdWxkIG1lYW4gdGhlIHRleHQncyBvcmlnaW4gcG9pbnQgd2lsbCBiZSB0aGUgYm90dG9tIHJpZ2h0IGNvcm5lclxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLlBvaW50IHwgbnVtYmVyfVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnYW5jaG9yJyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYW5jaG9yO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSByZXF1aXJlLWpzZG9jXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYW5jaG9yLnNldCh2YWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FuY2hvci5jb3B5KHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZm9udCBkZXNjcmlwdG9yIG9mIHRoZSBCaXRtYXBUZXh0IG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd8b2JqZWN0fVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZm9udCcsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZvbnQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlcXVpcmUtanNkb2NcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnNwbGl0KCcgJyk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9mb250Lm5hbWUgPSB2YWx1ZS5sZW5ndGggPT09IDEgPyB2YWx1ZVswXSA6IHZhbHVlLnNsaWNlKDEpLmpvaW4oJyAnKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9mb250LnNpemUgPSB2YWx1ZS5sZW5ndGggPj0gMiA/IHBhcnNlSW50KHZhbHVlWzBdLCAxMCkgOiBCaXRtYXBUZXh0LmZvbnRzW3RoaXMuX2ZvbnQubmFtZV0uc2l6ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZm9udC5uYW1lID0gdmFsdWUubmFtZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9mb250LnNpemUgPSB0eXBlb2YgdmFsdWUuc2l6ZSA9PT0gJ251bWJlcicgPyB2YWx1ZS5zaXplIDogcGFyc2VJbnQodmFsdWUuc2l6ZSwgMTApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdGV4dCBvZiB0aGUgQml0bWFwVGV4dCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndGV4dCcsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RleHQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlcXVpcmUtanNkb2NcbiAgICAgICAge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b1N0cmluZygpIHx8ICcgJztcbiAgICAgICAgICAgIGlmICh0aGlzLl90ZXh0ID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3RleHQgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBtYXggd2lkdGggb2YgdGhpcyBiaXRtYXAgdGV4dCBpbiBwaXhlbHMuIElmIHRoZSB0ZXh0IHByb3ZpZGVkIGlzIGxvbmdlciB0aGFuIHRoZVxuICAgICAgICAgKiB2YWx1ZSBwcm92aWRlZCwgbGluZSBicmVha3Mgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGluc2VydGVkIGluIHRoZSBsYXN0IHdoaXRlc3BhY2UuXG4gICAgICAgICAqIERpc2FibGUgYnkgc2V0dGluZyB2YWx1ZSB0byAwXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ21heFdpZHRoJyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbWF4V2lkdGg7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlcXVpcmUtanNkb2NcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHRoaXMuX21heFdpZHRoID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX21heFdpZHRoID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbWF4IGxpbmUgaGVpZ2h0LiBUaGlzIGlzIHVzZWZ1bCB3aGVuIHRyeWluZyB0byB1c2UgdGhlIHRvdGFsIGhlaWdodCBvZiB0aGUgVGV4dCxcbiAgICAgICAgICogaWU6IHdoZW4gdHJ5aW5nIHRvIHZlcnRpY2FsbHkgYWxpZ24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdtYXhMaW5lSGVpZ2h0JyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRlKCk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tYXhMaW5lSGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB3aWR0aCBvZiB0aGUgb3ZlcmFsbCB0ZXh0LCBkaWZmZXJlbnQgZnJvbSBmb250U2l6ZSxcbiAgICAgICAgICogd2hpY2ggaXMgZGVmaW5lZCBpbiB0aGUgc3R5bGUgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICd0ZXh0V2lkdGgnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHRoaXMudmFsaWRhdGUoKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RleHRXaWR0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGRpdGlvbmFsIHNwYWNlIGJldHdlZW4gY2hhcmFjdGVycy5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnbGV0dGVyU3BhY2luZycsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xldHRlclNwYWNpbmc7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlcXVpcmUtanNkb2NcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2xldHRlclNwYWNpbmcgIT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGV0dGVyU3BhY2luZyA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBoZWlnaHQgb2YgdGhlIG92ZXJhbGwgdGV4dCwgZGlmZmVyZW50IGZyb20gZm9udFNpemUsXG4gICAgICAgICAqIHdoaWNoIGlzIGRlZmluZWQgaW4gdGhlIHN0eWxlIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEByZWFkb25seVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndGV4dEhlaWdodCcsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgdGhpcy52YWxpZGF0ZSgpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGV4dEhlaWdodDtcbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBCaXRtYXBUZXh0O1xufShjb3JlLkNvbnRhaW5lcik7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEJpdG1hcFRleHQ7XG5cblxuQml0bWFwVGV4dC5mb250cyA9IHt9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Qml0bWFwVGV4dC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfY29yZSA9IHJlcXVpcmUoJy4uL2NvcmUnKTtcblxudmFyIGNvcmUgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfY29yZSk7XG5cbnZhciBfQ2FudmFzVGludGVyID0gcmVxdWlyZSgnLi4vY29yZS9zcHJpdGVzL2NhbnZhcy9DYW52YXNUaW50ZXInKTtcblxudmFyIF9DYW52YXNUaW50ZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQ2FudmFzVGludGVyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgdGVtcFBvaW50ID0gbmV3IGNvcmUuUG9pbnQoKTtcblxuLyoqXG4gKiBBIHRpbGluZyBzcHJpdGUgaXMgYSBmYXN0IHdheSBvZiByZW5kZXJpbmcgYSB0aWxpbmcgaW1hZ2VcbiAqXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIFBJWEkuU3ByaXRlXG4gKiBAbWVtYmVyb2YgUElYSS5leHRyYXNcbiAqL1xuXG52YXIgVGlsaW5nU3ByaXRlID0gZnVuY3Rpb24gKF9jb3JlJFNwcml0ZSkge1xuICAgIF9pbmhlcml0cyhUaWxpbmdTcHJpdGUsIF9jb3JlJFNwcml0ZSk7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1BJWEkuVGV4dHVyZX0gdGV4dHVyZSAtIHRoZSB0ZXh0dXJlIG9mIHRoZSB0aWxpbmcgc3ByaXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt3aWR0aD0xMDBdIC0gdGhlIHdpZHRoIG9mIHRoZSB0aWxpbmcgc3ByaXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtoZWlnaHQ9MTAwXSAtIHRoZSBoZWlnaHQgb2YgdGhlIHRpbGluZyBzcHJpdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBUaWxpbmdTcHJpdGUodGV4dHVyZSkge1xuICAgICAgICB2YXIgd2lkdGggPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDEwMDtcbiAgICAgICAgdmFyIGhlaWdodCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMTAwO1xuXG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUaWxpbmdTcHJpdGUpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaWxlIHRyYW5zZm9ybVxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLlRyYW5zZm9ybVN0YXRpY31cbiAgICAgICAgICovXG4gICAgICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9jb3JlJFNwcml0ZS5jYWxsKHRoaXMsIHRleHR1cmUpKTtcblxuICAgICAgICBfdGhpcy50aWxlVHJhbnNmb3JtID0gbmV3IGNvcmUuVHJhbnNmb3JtU3RhdGljKCk7XG5cbiAgICAgICAgLy8gLy8vIHByaXZhdGVcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHdpdGggb2YgdGhlIHRpbGluZyBzcHJpdGVcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuX3dpZHRoID0gd2lkdGg7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBoZWlnaHQgb2YgdGhlIHRpbGluZyBzcHJpdGVcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuX2hlaWdodCA9IGhlaWdodDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FudmFzIHBhdHRlcm5cbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge0NhbnZhc1BhdHRlcm59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5fY2FudmFzUGF0dGVybiA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHRyYW5zZm9ybSB0aGF0IGlzIGFwcGxpZWQgdG8gVVYgdG8gZ2V0IHRoZSB0ZXh0dXJlIGNvb3Jkc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLlRleHR1cmVNYXRyaXh9XG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy51dlRyYW5zZm9ybSA9IHRleHR1cmUudHJhbnNmb3JtIHx8IG5ldyBjb3JlLlRleHR1cmVNYXRyaXgodGV4dHVyZSk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBsdWdpbiB0aGF0IGlzIHJlc3BvbnNpYmxlIGZvciByZW5kZXJpbmcgdGhpcyBlbGVtZW50LlxuICAgICAgICAgKiBBbGxvd3MgdG8gY3VzdG9taXplIHRoZSByZW5kZXJpbmcgcHJvY2VzcyB3aXRob3V0IG92ZXJyaWRpbmcgJ19yZW5kZXJXZWJHTCcgbWV0aG9kLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9XG4gICAgICAgICAqIEBkZWZhdWx0ICd0aWxpbmdTcHJpdGUnXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5wbHVnaW5OYW1lID0gJ3RpbGluZ1Nwcml0ZSc7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgb3Igbm90IGFuY2hvciBhZmZlY3RzIHV2c1xuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMudXZSZXNwZWN0QW5jaG9yID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyBmcmFtZSBjbGFtcGluZyBpbiBjb3JyZXNwb25kaW5nIHRleHR1cmVUcmFuc2Zvcm0sIHNob3J0Y3V0XG4gICAgICogQ2hhbmdlIHRvIC0wLjUgdG8gYWRkIGEgcGl4ZWwgdG8gdGhlIGVkZ2UsIHJlY29tbWVuZGVkIGZvciB0cmFuc3BhcmVudCB0cmltbWVkIHRleHR1cmVzIGluIGF0bGFzXG4gICAgICpcbiAgICAgKiBAZGVmYXVsdCAwLjVcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICovXG5cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgVGlsaW5nU3ByaXRlLnByb3RvdHlwZS5fb25UZXh0dXJlVXBkYXRlID0gZnVuY3Rpb24gX29uVGV4dHVyZVVwZGF0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMudXZUcmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIHRoaXMudXZUcmFuc2Zvcm0udGV4dHVyZSA9IHRoaXMuX3RleHR1cmU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYWNoZWRUaW50ID0gMHhGRkZGRkY7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgdGhlIG9iamVjdCB1c2luZyB0aGUgV2ViR0wgcmVuZGVyZXJcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtQSVhJLldlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyXG4gICAgICovXG5cblxuICAgIFRpbGluZ1Nwcml0ZS5wcm90b3R5cGUuX3JlbmRlcldlYkdMID0gZnVuY3Rpb24gX3JlbmRlcldlYkdMKHJlbmRlcmVyKSB7XG4gICAgICAgIC8vIHR3ZWFrIG91ciB0ZXh0dXJlIHRlbXBvcmFyaWx5Li5cbiAgICAgICAgdmFyIHRleHR1cmUgPSB0aGlzLl90ZXh0dXJlO1xuXG4gICAgICAgIGlmICghdGV4dHVyZSB8fCAhdGV4dHVyZS52YWxpZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50aWxlVHJhbnNmb3JtLnVwZGF0ZUxvY2FsVHJhbnNmb3JtKCk7XG4gICAgICAgIHRoaXMudXZUcmFuc2Zvcm0udXBkYXRlKCk7XG5cbiAgICAgICAgcmVuZGVyZXIuc2V0T2JqZWN0UmVuZGVyZXIocmVuZGVyZXIucGx1Z2luc1t0aGlzLnBsdWdpbk5hbWVdKTtcbiAgICAgICAgcmVuZGVyZXIucGx1Z2luc1t0aGlzLnBsdWdpbk5hbWVdLnJlbmRlcih0aGlzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0aGUgb2JqZWN0IHVzaW5nIHRoZSBDYW52YXMgcmVuZGVyZXJcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtQSVhJLkNhbnZhc1JlbmRlcmVyfSByZW5kZXJlciAtIGEgcmVmZXJlbmNlIHRvIHRoZSBjYW52YXMgcmVuZGVyZXJcbiAgICAgKi9cblxuXG4gICAgVGlsaW5nU3ByaXRlLnByb3RvdHlwZS5fcmVuZGVyQ2FudmFzID0gZnVuY3Rpb24gX3JlbmRlckNhbnZhcyhyZW5kZXJlcikge1xuICAgICAgICB2YXIgdGV4dHVyZSA9IHRoaXMuX3RleHR1cmU7XG5cbiAgICAgICAgaWYgKCF0ZXh0dXJlLmJhc2VUZXh0dXJlLmhhc0xvYWRlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvbnRleHQgPSByZW5kZXJlci5jb250ZXh0O1xuICAgICAgICB2YXIgdHJhbnNmb3JtID0gdGhpcy53b3JsZFRyYW5zZm9ybTtcbiAgICAgICAgdmFyIHJlc29sdXRpb24gPSByZW5kZXJlci5yZXNvbHV0aW9uO1xuICAgICAgICB2YXIgaXNUZXh0dXJlUm90YXRlZCA9IHRleHR1cmUucm90YXRlID09PSAyO1xuICAgICAgICB2YXIgYmFzZVRleHR1cmUgPSB0ZXh0dXJlLmJhc2VUZXh0dXJlO1xuICAgICAgICB2YXIgYmFzZVRleHR1cmVSZXNvbHV0aW9uID0gYmFzZVRleHR1cmUucmVzb2x1dGlvbjtcbiAgICAgICAgdmFyIG1vZFggPSB0aGlzLnRpbGVQb3NpdGlvbi54IC8gdGhpcy50aWxlU2NhbGUueCAlIHRleHR1cmUub3JpZy53aWR0aCAqIGJhc2VUZXh0dXJlUmVzb2x1dGlvbjtcbiAgICAgICAgdmFyIG1vZFkgPSB0aGlzLnRpbGVQb3NpdGlvbi55IC8gdGhpcy50aWxlU2NhbGUueSAlIHRleHR1cmUub3JpZy5oZWlnaHQgKiBiYXNlVGV4dHVyZVJlc29sdXRpb247XG5cbiAgICAgICAgLy8gY3JlYXRlIGEgbmljZSBzaGlueSBwYXR0ZXJuIVxuICAgICAgICBpZiAodGhpcy5fdGV4dHVyZUlEICE9PSB0aGlzLl90ZXh0dXJlLl91cGRhdGVJRCB8fCB0aGlzLmNhY2hlZFRpbnQgIT09IHRoaXMudGludCkge1xuICAgICAgICAgICAgdGhpcy5fdGV4dHVyZUlEID0gdGhpcy5fdGV4dHVyZS5fdXBkYXRlSUQ7XG4gICAgICAgICAgICAvLyBjdXQgYW4gb2JqZWN0IGZyb20gYSBzcHJpdGVzaGVldC4uXG4gICAgICAgICAgICB2YXIgdGVtcENhbnZhcyA9IG5ldyBjb3JlLkNhbnZhc1JlbmRlclRhcmdldCh0ZXh0dXJlLm9yaWcud2lkdGgsIHRleHR1cmUub3JpZy5oZWlnaHQsIGJhc2VUZXh0dXJlUmVzb2x1dGlvbik7XG5cbiAgICAgICAgICAgIC8vIFRpbnQgdGhlIHRpbGluZyBzcHJpdGVcbiAgICAgICAgICAgIGlmICh0aGlzLnRpbnQgIT09IDB4RkZGRkZGKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50aW50ZWRUZXh0dXJlID0gX0NhbnZhc1RpbnRlcjIuZGVmYXVsdC5nZXRUaW50ZWRUZXh0dXJlKHRoaXMsIHRoaXMudGludCk7XG4gICAgICAgICAgICAgICAgdGVtcENhbnZhcy5jb250ZXh0LmRyYXdJbWFnZSh0aGlzLnRpbnRlZFRleHR1cmUsIDAsIDApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgc3ggPSB0ZXh0dXJlLl9mcmFtZS54ICogYmFzZVRleHR1cmVSZXNvbHV0aW9uO1xuICAgICAgICAgICAgICAgIHZhciBzeSA9IHRleHR1cmUuX2ZyYW1lLnkgKiBiYXNlVGV4dHVyZVJlc29sdXRpb247XG4gICAgICAgICAgICAgICAgdmFyIHNXaWR0aCA9IHRleHR1cmUuX2ZyYW1lLndpZHRoICogYmFzZVRleHR1cmVSZXNvbHV0aW9uO1xuICAgICAgICAgICAgICAgIHZhciBzSGVpZ2h0ID0gdGV4dHVyZS5fZnJhbWUuaGVpZ2h0ICogYmFzZVRleHR1cmVSZXNvbHV0aW9uO1xuICAgICAgICAgICAgICAgIHZhciBkV2lkdGggPSAodGV4dHVyZS50cmltID8gdGV4dHVyZS50cmltLndpZHRoIDogdGV4dHVyZS5vcmlnLndpZHRoKSAqIGJhc2VUZXh0dXJlUmVzb2x1dGlvbjtcbiAgICAgICAgICAgICAgICB2YXIgZEhlaWdodCA9ICh0ZXh0dXJlLnRyaW0gPyB0ZXh0dXJlLnRyaW0uaGVpZ2h0IDogdGV4dHVyZS5vcmlnLmhlaWdodCkgKiBiYXNlVGV4dHVyZVJlc29sdXRpb247XG4gICAgICAgICAgICAgICAgdmFyIGR4ID0gKHRleHR1cmUudHJpbSA/IHRleHR1cmUudHJpbS54IDogMCkgKiBiYXNlVGV4dHVyZVJlc29sdXRpb247XG4gICAgICAgICAgICAgICAgdmFyIGR5ID0gKHRleHR1cmUudHJpbSA/IHRleHR1cmUudHJpbS55IDogMCkgKiBiYXNlVGV4dHVyZVJlc29sdXRpb247XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNUZXh0dXJlUm90YXRlZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBBcHBseSByb3RhdGlvbiBhbmQgdHJhbnNmb3JtXG4gICAgICAgICAgICAgICAgICAgIHRlbXBDYW52YXMuY29udGV4dC5yb3RhdGUoLU1hdGguUEkgLyAyKTtcbiAgICAgICAgICAgICAgICAgICAgdGVtcENhbnZhcy5jb250ZXh0LnRyYW5zbGF0ZSgtZEhlaWdodCwgMCk7XG4gICAgICAgICAgICAgICAgICAgIHRlbXBDYW52YXMuY29udGV4dC5kcmF3SW1hZ2UoYmFzZVRleHR1cmUuc291cmNlLCBzeCwgc3ksIHNXaWR0aCwgc0hlaWdodCwgLWR5LCBkeCwgZEhlaWdodCwgZFdpZHRoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0ZW1wQ2FudmFzLmNvbnRleHQuZHJhd0ltYWdlKGJhc2VUZXh0dXJlLnNvdXJjZSwgc3gsIHN5LCBzV2lkdGgsIHNIZWlnaHQsIGR4LCBkeSwgZFdpZHRoLCBkSGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuY2FjaGVkVGludCA9IHRoaXMudGludDtcbiAgICAgICAgICAgIHRoaXMuX2NhbnZhc1BhdHRlcm4gPSB0ZW1wQ2FudmFzLmNvbnRleHQuY3JlYXRlUGF0dGVybih0ZW1wQ2FudmFzLmNhbnZhcywgJ3JlcGVhdCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2V0IGNvbnRleHQgc3RhdGUuLlxuICAgICAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gdGhpcy53b3JsZEFscGhhO1xuICAgICAgICBjb250ZXh0LnNldFRyYW5zZm9ybSh0cmFuc2Zvcm0uYSAqIHJlc29sdXRpb24sIHRyYW5zZm9ybS5iICogcmVzb2x1dGlvbiwgdHJhbnNmb3JtLmMgKiByZXNvbHV0aW9uLCB0cmFuc2Zvcm0uZCAqIHJlc29sdXRpb24sIHRyYW5zZm9ybS50eCAqIHJlc29sdXRpb24sIHRyYW5zZm9ybS50eSAqIHJlc29sdXRpb24pO1xuXG4gICAgICAgIHJlbmRlcmVyLnNldEJsZW5kTW9kZSh0aGlzLmJsZW5kTW9kZSk7XG5cbiAgICAgICAgLy8gZmlsbCB0aGUgcGF0dGVybiFcbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSB0aGlzLl9jYW52YXNQYXR0ZXJuO1xuXG4gICAgICAgIC8vIFRPRE8gLSB0aGlzIHNob3VsZCBiZSByb2xsZWQgaW50byB0aGUgc2V0VHJhbnNmb3JtIGFib3ZlLi5cbiAgICAgICAgY29udGV4dC5zY2FsZSh0aGlzLnRpbGVTY2FsZS54IC8gYmFzZVRleHR1cmVSZXNvbHV0aW9uLCB0aGlzLnRpbGVTY2FsZS55IC8gYmFzZVRleHR1cmVSZXNvbHV0aW9uKTtcblxuICAgICAgICB2YXIgYW5jaG9yWCA9IHRoaXMuYW5jaG9yLnggKiAtdGhpcy5fd2lkdGggKiBiYXNlVGV4dHVyZVJlc29sdXRpb247XG4gICAgICAgIHZhciBhbmNob3JZID0gdGhpcy5hbmNob3IueSAqIC10aGlzLl9oZWlnaHQgKiBiYXNlVGV4dHVyZVJlc29sdXRpb247XG5cbiAgICAgICAgaWYgKHRoaXMudXZSZXNwZWN0QW5jaG9yKSB7XG4gICAgICAgICAgICBjb250ZXh0LnRyYW5zbGF0ZShtb2RYLCBtb2RZKTtcblxuICAgICAgICAgICAgY29udGV4dC5maWxsUmVjdCgtbW9kWCArIGFuY2hvclgsIC1tb2RZICsgYW5jaG9yWSwgdGhpcy5fd2lkdGggLyB0aGlzLnRpbGVTY2FsZS54ICogYmFzZVRleHR1cmVSZXNvbHV0aW9uLCB0aGlzLl9oZWlnaHQgLyB0aGlzLnRpbGVTY2FsZS55ICogYmFzZVRleHR1cmVSZXNvbHV0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRleHQudHJhbnNsYXRlKG1vZFggKyBhbmNob3JYLCBtb2RZICsgYW5jaG9yWSk7XG5cbiAgICAgICAgICAgIGNvbnRleHQuZmlsbFJlY3QoLW1vZFgsIC1tb2RZLCB0aGlzLl93aWR0aCAvIHRoaXMudGlsZVNjYWxlLnggKiBiYXNlVGV4dHVyZVJlc29sdXRpb24sIHRoaXMuX2hlaWdodCAvIHRoaXMudGlsZVNjYWxlLnkgKiBiYXNlVGV4dHVyZVJlc29sdXRpb24pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGJvdW5kcyBvZiB0aGUgdGlsaW5nIHNwcml0ZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cblxuICAgIFRpbGluZ1Nwcml0ZS5wcm90b3R5cGUuX2NhbGN1bGF0ZUJvdW5kcyA9IGZ1bmN0aW9uIF9jYWxjdWxhdGVCb3VuZHMoKSB7XG4gICAgICAgIHZhciBtaW5YID0gdGhpcy5fd2lkdGggKiAtdGhpcy5fYW5jaG9yLl94O1xuICAgICAgICB2YXIgbWluWSA9IHRoaXMuX2hlaWdodCAqIC10aGlzLl9hbmNob3IuX3k7XG4gICAgICAgIHZhciBtYXhYID0gdGhpcy5fd2lkdGggKiAoMSAtIHRoaXMuX2FuY2hvci5feCk7XG4gICAgICAgIHZhciBtYXhZID0gdGhpcy5faGVpZ2h0ICogKDEgLSB0aGlzLl9hbmNob3IuX3kpO1xuXG4gICAgICAgIHRoaXMuX2JvdW5kcy5hZGRGcmFtZSh0aGlzLnRyYW5zZm9ybSwgbWluWCwgbWluWSwgbWF4WCwgbWF4WSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGxvY2FsIGJvdW5kcyBvZiB0aGUgc3ByaXRlIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5SZWN0YW5nbGV9IHJlY3QgLSBUaGUgb3V0cHV0IHJlY3RhbmdsZS5cbiAgICAgKiBAcmV0dXJuIHtQSVhJLlJlY3RhbmdsZX0gVGhlIGJvdW5kcy5cbiAgICAgKi9cblxuXG4gICAgVGlsaW5nU3ByaXRlLnByb3RvdHlwZS5nZXRMb2NhbEJvdW5kcyA9IGZ1bmN0aW9uIGdldExvY2FsQm91bmRzKHJlY3QpIHtcbiAgICAgICAgLy8gd2UgY2FuIGRvIGEgZmFzdCBsb2NhbCBib3VuZHMgaWYgdGhlIHNwcml0ZSBoYXMgbm8gY2hpbGRyZW4hXG4gICAgICAgIGlmICh0aGlzLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5fYm91bmRzLm1pblggPSB0aGlzLl93aWR0aCAqIC10aGlzLl9hbmNob3IuX3g7XG4gICAgICAgICAgICB0aGlzLl9ib3VuZHMubWluWSA9IHRoaXMuX2hlaWdodCAqIC10aGlzLl9hbmNob3IuX3k7XG4gICAgICAgICAgICB0aGlzLl9ib3VuZHMubWF4WCA9IHRoaXMuX3dpZHRoICogKDEgLSB0aGlzLl9hbmNob3IuX3gpO1xuICAgICAgICAgICAgdGhpcy5fYm91bmRzLm1heFkgPSB0aGlzLl9oZWlnaHQgKiAoMSAtIHRoaXMuX2FuY2hvci5feSk7XG5cbiAgICAgICAgICAgIGlmICghcmVjdCkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fbG9jYWxCb3VuZHNSZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvY2FsQm91bmRzUmVjdCA9IG5ldyBjb3JlLlJlY3RhbmdsZSgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJlY3QgPSB0aGlzLl9sb2NhbEJvdW5kc1JlY3Q7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ib3VuZHMuZ2V0UmVjdGFuZ2xlKHJlY3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIF9jb3JlJFNwcml0ZS5wcm90b3R5cGUuZ2V0TG9jYWxCb3VuZHMuY2FsbCh0aGlzLCByZWN0KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGEgcG9pbnQgaXMgaW5zaWRlIHRoaXMgdGlsaW5nIHNwcml0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5Qb2ludH0gcG9pbnQgLSB0aGUgcG9pbnQgdG8gY2hlY2tcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgc3ByaXRlIGNvbnRhaW5zIHRoZSBwb2ludC5cbiAgICAgKi9cblxuXG4gICAgVGlsaW5nU3ByaXRlLnByb3RvdHlwZS5jb250YWluc1BvaW50ID0gZnVuY3Rpb24gY29udGFpbnNQb2ludChwb2ludCkge1xuICAgICAgICB0aGlzLndvcmxkVHJhbnNmb3JtLmFwcGx5SW52ZXJzZShwb2ludCwgdGVtcFBvaW50KTtcblxuICAgICAgICB2YXIgd2lkdGggPSB0aGlzLl93aWR0aDtcbiAgICAgICAgdmFyIGhlaWdodCA9IHRoaXMuX2hlaWdodDtcbiAgICAgICAgdmFyIHgxID0gLXdpZHRoICogdGhpcy5hbmNob3IuX3g7XG5cbiAgICAgICAgaWYgKHRlbXBQb2ludC54ID49IHgxICYmIHRlbXBQb2ludC54IDwgeDEgKyB3aWR0aCkge1xuICAgICAgICAgICAgdmFyIHkxID0gLWhlaWdodCAqIHRoaXMuYW5jaG9yLl95O1xuXG4gICAgICAgICAgICBpZiAodGVtcFBvaW50LnkgPj0geTEgJiYgdGVtcFBvaW50LnkgPCB5MSArIGhlaWdodCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyB0aGlzIHNwcml0ZSBhbmQgb3B0aW9uYWxseSBpdHMgdGV4dHVyZSBhbmQgY2hpbGRyZW5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fGJvb2xlYW59IFtvcHRpb25zXSAtIE9wdGlvbnMgcGFyYW1ldGVyLiBBIGJvb2xlYW4gd2lsbCBhY3QgYXMgaWYgYWxsIG9wdGlvbnNcbiAgICAgKiAgaGF2ZSBiZWVuIHNldCB0byB0aGF0IHZhbHVlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jaGlsZHJlbj1mYWxzZV0gLSBpZiBzZXQgdG8gdHJ1ZSwgYWxsIHRoZSBjaGlsZHJlbiB3aWxsIGhhdmUgdGhlaXIgZGVzdHJveVxuICAgICAqICAgICAgbWV0aG9kIGNhbGxlZCBhcyB3ZWxsLiAnb3B0aW9ucycgd2lsbCBiZSBwYXNzZWQgb24gdG8gdGhvc2UgY2FsbHMuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50ZXh0dXJlPWZhbHNlXSAtIFNob3VsZCBpdCBkZXN0cm95IHRoZSBjdXJyZW50IHRleHR1cmUgb2YgdGhlIHNwcml0ZSBhcyB3ZWxsXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5iYXNlVGV4dHVyZT1mYWxzZV0gLSBTaG91bGQgaXQgZGVzdHJveSB0aGUgYmFzZSB0ZXh0dXJlIG9mIHRoZSBzcHJpdGUgYXMgd2VsbFxuICAgICAqL1xuXG5cbiAgICBUaWxpbmdTcHJpdGUucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KG9wdGlvbnMpIHtcbiAgICAgICAgX2NvcmUkU3ByaXRlLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgICAgICAgdGhpcy50aWxlVHJhbnNmb3JtID0gbnVsbDtcbiAgICAgICAgdGhpcy51dlRyYW5zZm9ybSA9IG51bGw7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgYSBuZXcgdGlsaW5nIHNwcml0ZSBiYXNlZCBvbiB0aGUgc291cmNlIHlvdSBwcm92aWRlLlxuICAgICAqIFRoZSBzb3VyY2UgY2FuIGJlIC0gZnJhbWUgaWQsIGltYWdlIHVybCwgdmlkZW8gdXJsLCBjYW52YXMgZWxlbWVudCwgdmlkZW8gZWxlbWVudCwgYmFzZSB0ZXh0dXJlXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfFBJWEkuQmFzZVRleHR1cmV8SFRNTENhbnZhc0VsZW1lbnR8SFRNTFZpZGVvRWxlbWVudH0gc291cmNlIC0gU291cmNlIHRvIGNyZWF0ZSB0ZXh0dXJlIGZyb21cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSB0aGUgd2lkdGggb2YgdGhlIHRpbGluZyBzcHJpdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IC0gdGhlIGhlaWdodCBvZiB0aGUgdGlsaW5nIHNwcml0ZVxuICAgICAqIEByZXR1cm4ge1BJWEkuVGV4dHVyZX0gVGhlIG5ld2x5IGNyZWF0ZWQgdGV4dHVyZVxuICAgICAqL1xuXG5cbiAgICBUaWxpbmdTcHJpdGUuZnJvbSA9IGZ1bmN0aW9uIGZyb20oc291cmNlLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiBuZXcgVGlsaW5nU3ByaXRlKGNvcmUuVGV4dHVyZS5mcm9tKHNvdXJjZSksIHdpZHRoLCBoZWlnaHQpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIGEgdGlsaW5nIHNwcml0ZSB0aGF0IHdpbGwgdXNlIGEgdGV4dHVyZSBmcm9tIHRoZSBUZXh0dXJlQ2FjaGUgYmFzZWQgb24gdGhlIGZyYW1lSWRcbiAgICAgKiBUaGUgZnJhbWUgaWRzIGFyZSBjcmVhdGVkIHdoZW4gYSBUZXh0dXJlIHBhY2tlciBmaWxlIGhhcyBiZWVuIGxvYWRlZFxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmcmFtZUlkIC0gVGhlIGZyYW1lIElkIG9mIHRoZSB0ZXh0dXJlIGluIHRoZSBjYWNoZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAtIHRoZSB3aWR0aCBvZiB0aGUgdGlsaW5nIHNwcml0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgLSB0aGUgaGVpZ2h0IG9mIHRoZSB0aWxpbmcgc3ByaXRlXG4gICAgICogQHJldHVybiB7UElYSS5leHRyYXMuVGlsaW5nU3ByaXRlfSBBIG5ldyBUaWxpbmdTcHJpdGUgdXNpbmcgYSB0ZXh0dXJlIGZyb20gdGhlIHRleHR1cmUgY2FjaGUgbWF0Y2hpbmcgdGhlIGZyYW1lSWRcbiAgICAgKi9cblxuXG4gICAgVGlsaW5nU3ByaXRlLmZyb21GcmFtZSA9IGZ1bmN0aW9uIGZyb21GcmFtZShmcmFtZUlkLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHZhciB0ZXh0dXJlID0gY29yZS51dGlscy5UZXh0dXJlQ2FjaGVbZnJhbWVJZF07XG5cbiAgICAgICAgaWYgKCF0ZXh0dXJlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBmcmFtZUlkIFwiJyArIGZyYW1lSWQgKyAnXCIgZG9lcyBub3QgZXhpc3QgaW4gdGhlIHRleHR1cmUgY2FjaGUgJyArIHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBUaWxpbmdTcHJpdGUodGV4dHVyZSwgd2lkdGgsIGhlaWdodCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgYSBzcHJpdGUgdGhhdCB3aWxsIGNvbnRhaW4gYSB0ZXh0dXJlIGJhc2VkIG9uIGFuIGltYWdlIHVybFxuICAgICAqIElmIHRoZSBpbWFnZSBpcyBub3QgaW4gdGhlIHRleHR1cmUgY2FjaGUgaXQgd2lsbCBiZSBsb2FkZWRcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaW1hZ2VJZCAtIFRoZSBpbWFnZSB1cmwgb2YgdGhlIHRleHR1cmVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSB0aGUgd2lkdGggb2YgdGhlIHRpbGluZyBzcHJpdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IC0gdGhlIGhlaWdodCBvZiB0aGUgdGlsaW5nIHNwcml0ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Nyb3Nzb3JpZ2luXSAtIGlmIHlvdSB3YW50IHRvIHNwZWNpZnkgdGhlIGNyb3NzLW9yaWdpbiBwYXJhbWV0ZXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3NjYWxlTW9kZT1QSVhJLnNldHRpbmdzLlNDQUxFX01PREVdIC0gaWYgeW91IHdhbnQgdG8gc3BlY2lmeSB0aGUgc2NhbGUgbW9kZSxcbiAgICAgKiAgc2VlIHtAbGluayBQSVhJLlNDQUxFX01PREVTfSBmb3IgcG9zc2libGUgdmFsdWVzXG4gICAgICogQHJldHVybiB7UElYSS5leHRyYXMuVGlsaW5nU3ByaXRlfSBBIG5ldyBUaWxpbmdTcHJpdGUgdXNpbmcgYSB0ZXh0dXJlIGZyb20gdGhlIHRleHR1cmUgY2FjaGUgbWF0Y2hpbmcgdGhlIGltYWdlIGlkXG4gICAgICovXG5cblxuICAgIFRpbGluZ1Nwcml0ZS5mcm9tSW1hZ2UgPSBmdW5jdGlvbiBmcm9tSW1hZ2UoaW1hZ2VJZCwgd2lkdGgsIGhlaWdodCwgY3Jvc3NvcmlnaW4sIHNjYWxlTW9kZSkge1xuICAgICAgICByZXR1cm4gbmV3IFRpbGluZ1Nwcml0ZShjb3JlLlRleHR1cmUuZnJvbUltYWdlKGltYWdlSWQsIGNyb3Nzb3JpZ2luLCBzY2FsZU1vZGUpLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIHdpZHRoIG9mIHRoZSBzcHJpdGUsIHNldHRpbmcgdGhpcyB3aWxsIGFjdHVhbGx5IG1vZGlmeSB0aGUgc2NhbGUgdG8gYWNoaWV2ZSB0aGUgdmFsdWUgc2V0XG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICovXG5cblxuICAgIF9jcmVhdGVDbGFzcyhUaWxpbmdTcHJpdGUsIFt7XG4gICAgICAgIGtleTogJ2NsYW1wTWFyZ2luJyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy51dlRyYW5zZm9ybS5jbGFtcE1hcmdpbjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcmVxdWlyZS1qc2RvY1xuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnV2VHJhbnNmb3JtLmNsYW1wTWFyZ2luID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLnV2VHJhbnNmb3JtLnVwZGF0ZSh0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgc2NhbGluZyBvZiB0aGUgaW1hZ2UgdGhhdCBpcyBiZWluZyB0aWxlZFxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLk9ic2VydmFibGVQb2ludH1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3RpbGVTY2FsZScsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGlsZVRyYW5zZm9ybS5zY2FsZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcmVxdWlyZS1qc2RvY1xuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnRpbGVUcmFuc2Zvcm0uc2NhbGUuY29weSh2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG9mZnNldCBvZiB0aGUgaW1hZ2UgdGhhdCBpcyBiZWluZyB0aWxlZFxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLk9ic2VydmFibGVQb2ludH1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3RpbGVQb3NpdGlvbicsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGlsZVRyYW5zZm9ybS5wb3NpdGlvbjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcmVxdWlyZS1qc2RvY1xuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnRpbGVUcmFuc2Zvcm0ucG9zaXRpb24uY29weSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3dpZHRoJyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2lkdGg7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlcXVpcmUtanNkb2NcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fd2lkdGggPSB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgaGVpZ2h0IG9mIHRoZSBUaWxpbmdTcHJpdGUsIHNldHRpbmcgdGhpcyB3aWxsIGFjdHVhbGx5IG1vZGlmeSB0aGUgc2NhbGUgdG8gYWNoaWV2ZSB0aGUgdmFsdWUgc2V0XG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2hlaWdodCcsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hlaWdodDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcmVxdWlyZS1qc2RvY1xuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9oZWlnaHQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBUaWxpbmdTcHJpdGU7XG59KGNvcmUuU3ByaXRlKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gVGlsaW5nU3ByaXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGlsaW5nU3ByaXRlLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxudmFyIF9jb3JlID0gcmVxdWlyZSgnLi4vY29yZScpO1xuXG52YXIgY29yZSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9jb3JlKTtcblxudmFyIF9UZXh0dXJlID0gcmVxdWlyZSgnLi4vY29yZS90ZXh0dXJlcy9UZXh0dXJlJyk7XG5cbnZhciBfVGV4dHVyZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9UZXh0dXJlKTtcblxudmFyIF9CYXNlVGV4dHVyZSA9IHJlcXVpcmUoJy4uL2NvcmUvdGV4dHVyZXMvQmFzZVRleHR1cmUnKTtcblxudmFyIF9CYXNlVGV4dHVyZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9CYXNlVGV4dHVyZSk7XG5cbnZhciBfdXRpbHMgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBEaXNwbGF5T2JqZWN0ID0gY29yZS5EaXNwbGF5T2JqZWN0O1xudmFyIF90ZW1wTWF0cml4ID0gbmV3IGNvcmUuTWF0cml4KCk7XG5cbkRpc3BsYXlPYmplY3QucHJvdG90eXBlLl9jYWNoZUFzQml0bWFwID0gZmFsc2U7XG5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZS5fY2FjaGVEYXRhID0gZmFsc2U7XG5cbi8vIGZpZ3VyZWQgdGhlcmVzIG5vIHBvaW50IGFkZGluZyBBTEwgdGhlIGV4dHJhIHZhcmlhYmxlcyB0byBwcm90b3R5cGUuXG4vLyB0aGlzIG1vZGVsIGNhbiBob2xkIHRoZSBpbmZvcm1hdGlvbiBuZWVkZWQuIFRoaXMgY2FuIGFsc28gYmUgZ2VuZXJhdGVkIG9uIGRlbWFuZCBhc1xuLy8gbW9zdCBvYmplY3RzIGFyZSBub3QgY2FjaGVkIGFzIGJpdG1hcHMuXG4vKipcbiAqIEBjbGFzc1xuICogQGlnbm9yZVxuICovXG5cbnZhciBDYWNoZURhdGEgPVxuLyoqXG4gKlxuICovXG5mdW5jdGlvbiBDYWNoZURhdGEoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENhY2hlRGF0YSk7XG5cbiAgICB0aGlzLnRleHR1cmVDYWNoZUlkID0gbnVsbDtcblxuICAgIHRoaXMub3JpZ2luYWxSZW5kZXJXZWJHTCA9IG51bGw7XG4gICAgdGhpcy5vcmlnaW5hbFJlbmRlckNhbnZhcyA9IG51bGw7XG4gICAgdGhpcy5vcmlnaW5hbENhbGN1bGF0ZUJvdW5kcyA9IG51bGw7XG4gICAgdGhpcy5vcmlnaW5hbEdldExvY2FsQm91bmRzID0gbnVsbDtcblxuICAgIHRoaXMub3JpZ2luYWxVcGRhdGVUcmFuc2Zvcm0gPSBudWxsO1xuICAgIHRoaXMub3JpZ2luYWxIaXRUZXN0ID0gbnVsbDtcbiAgICB0aGlzLm9yaWdpbmFsRGVzdHJveSA9IG51bGw7XG4gICAgdGhpcy5vcmlnaW5hbE1hc2sgPSBudWxsO1xuICAgIHRoaXMub3JpZ2luYWxGaWx0ZXJBcmVhID0gbnVsbDtcbiAgICB0aGlzLnNwcml0ZSA9IG51bGw7XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhEaXNwbGF5T2JqZWN0LnByb3RvdHlwZSwge1xuICAgIC8qKlxuICAgICAqIFNldCB0aGlzIHRvIHRydWUgaWYgeW91IHdhbnQgdGhpcyBkaXNwbGF5IG9iamVjdCB0byBiZSBjYWNoZWQgYXMgYSBiaXRtYXAuXG4gICAgICogVGhpcyBiYXNpY2FsbHkgdGFrZXMgYSBzbmFwIHNob3Qgb2YgdGhlIGRpc3BsYXkgb2JqZWN0IGFzIGl0IGlzIGF0IHRoYXQgbW9tZW50LiBJdCBjYW5cbiAgICAgKiBwcm92aWRlIGEgcGVyZm9ybWFuY2UgYmVuZWZpdCBmb3IgY29tcGxleCBzdGF0aWMgZGlzcGxheU9iamVjdHMuXG4gICAgICogVG8gcmVtb3ZlIHNpbXBseSBzZXQgdGhpcyBwcm9wZXJ0eSB0byAnZmFsc2UnXG4gICAgICpcbiAgICAgKiBJTVBPUlRBTlQgR09UQ0hBIC0gbWFrZSBzdXJlIHRoYXQgYWxsIHlvdXIgdGV4dHVyZXMgYXJlIHByZWxvYWRlZCBCRUZPUkUgc2V0dGluZyB0aGlzIHByb3BlcnR5IHRvIHRydWVcbiAgICAgKiBhcyBpdCB3aWxsIHRha2UgYSBzbmFwc2hvdCBvZiB3aGF0IGlzIGN1cnJlbnRseSB0aGVyZS4gSWYgdGhlIHRleHR1cmVzIGhhdmUgbm90IGxvYWRlZCB0aGVuIHRoZXkgd2lsbCBub3QgYXBwZWFyLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgKiBAbWVtYmVyb2YgUElYSS5EaXNwbGF5T2JqZWN0I1xuICAgICAqL1xuICAgIGNhY2hlQXNCaXRtYXA6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVBc0JpdG1hcDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jYWNoZUFzQml0bWFwID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fY2FjaGVBc0JpdG1hcCA9IHZhbHVlO1xuXG4gICAgICAgICAgICB2YXIgZGF0YSA9IHZvaWQgMDtcblxuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9jYWNoZURhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FjaGVEYXRhID0gbmV3IENhY2hlRGF0YSgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRhdGEgPSB0aGlzLl9jYWNoZURhdGE7XG5cbiAgICAgICAgICAgICAgICBkYXRhLm9yaWdpbmFsUmVuZGVyV2ViR0wgPSB0aGlzLnJlbmRlcldlYkdMO1xuICAgICAgICAgICAgICAgIGRhdGEub3JpZ2luYWxSZW5kZXJDYW52YXMgPSB0aGlzLnJlbmRlckNhbnZhcztcblxuICAgICAgICAgICAgICAgIGRhdGEub3JpZ2luYWxVcGRhdGVUcmFuc2Zvcm0gPSB0aGlzLnVwZGF0ZVRyYW5zZm9ybTtcbiAgICAgICAgICAgICAgICBkYXRhLm9yaWdpbmFsQ2FsY3VsYXRlQm91bmRzID0gdGhpcy5jYWxjdWxhdGVCb3VuZHM7XG4gICAgICAgICAgICAgICAgZGF0YS5vcmlnaW5hbEdldExvY2FsQm91bmRzID0gdGhpcy5nZXRMb2NhbEJvdW5kcztcblxuICAgICAgICAgICAgICAgIGRhdGEub3JpZ2luYWxEZXN0cm95ID0gdGhpcy5kZXN0cm95O1xuXG4gICAgICAgICAgICAgICAgZGF0YS5vcmlnaW5hbENvbnRhaW5zUG9pbnQgPSB0aGlzLmNvbnRhaW5zUG9pbnQ7XG5cbiAgICAgICAgICAgICAgICBkYXRhLm9yaWdpbmFsTWFzayA9IHRoaXMuX21hc2s7XG4gICAgICAgICAgICAgICAgZGF0YS5vcmlnaW5hbEZpbHRlckFyZWEgPSB0aGlzLmZpbHRlckFyZWE7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcldlYkdMID0gdGhpcy5fcmVuZGVyQ2FjaGVkV2ViR0w7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJDYW52YXMgPSB0aGlzLl9yZW5kZXJDYWNoZWRDYW52YXM7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmRlc3Ryb3kgPSB0aGlzLl9jYWNoZUFzQml0bWFwRGVzdHJveTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IHRoaXMuX2NhY2hlRGF0YTtcblxuICAgICAgICAgICAgICAgIGlmIChkYXRhLnNwcml0ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZXN0cm95Q2FjaGVkRGlzcGxheU9iamVjdCgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyV2ViR0wgPSBkYXRhLm9yaWdpbmFsUmVuZGVyV2ViR0w7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJDYW52YXMgPSBkYXRhLm9yaWdpbmFsUmVuZGVyQ2FudmFzO1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsY3VsYXRlQm91bmRzID0gZGF0YS5vcmlnaW5hbENhbGN1bGF0ZUJvdW5kcztcbiAgICAgICAgICAgICAgICB0aGlzLmdldExvY2FsQm91bmRzID0gZGF0YS5vcmlnaW5hbEdldExvY2FsQm91bmRzO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5kZXN0cm95ID0gZGF0YS5vcmlnaW5hbERlc3Ryb3k7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVRyYW5zZm9ybSA9IGRhdGEub3JpZ2luYWxVcGRhdGVUcmFuc2Zvcm07XG4gICAgICAgICAgICAgICAgdGhpcy5jb250YWluc1BvaW50ID0gZGF0YS5vcmlnaW5hbENvbnRhaW5zUG9pbnQ7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9tYXNrID0gZGF0YS5vcmlnaW5hbE1hc2s7XG4gICAgICAgICAgICAgICAgdGhpcy5maWx0ZXJBcmVhID0gZGF0YS5vcmlnaW5hbEZpbHRlckFyZWE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuLyoqXG4gKiBSZW5kZXJzIGEgY2FjaGVkIHZlcnNpb24gb2YgdGhlIHNwcml0ZSB3aXRoIFdlYkdMXG4gKlxuICogQHByaXZhdGVcbiAqIEBtZW1iZXJvZiBQSVhJLkRpc3BsYXlPYmplY3QjXG4gKiBAcGFyYW0ge1BJWEkuV2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSB0aGUgV2ViR0wgcmVuZGVyZXJcbiAqL1xuRGlzcGxheU9iamVjdC5wcm90b3R5cGUuX3JlbmRlckNhY2hlZFdlYkdMID0gZnVuY3Rpb24gX3JlbmRlckNhY2hlZFdlYkdMKHJlbmRlcmVyKSB7XG4gICAgaWYgKCF0aGlzLnZpc2libGUgfHwgdGhpcy53b3JsZEFscGhhIDw9IDAgfHwgIXRoaXMucmVuZGVyYWJsZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5faW5pdENhY2hlZERpc3BsYXlPYmplY3QocmVuZGVyZXIpO1xuXG4gICAgdGhpcy5fY2FjaGVEYXRhLnNwcml0ZS50cmFuc2Zvcm0uX3dvcmxkSUQgPSB0aGlzLnRyYW5zZm9ybS5fd29ybGRJRDtcbiAgICB0aGlzLl9jYWNoZURhdGEuc3ByaXRlLndvcmxkQWxwaGEgPSB0aGlzLndvcmxkQWxwaGE7XG4gICAgdGhpcy5fY2FjaGVEYXRhLnNwcml0ZS5fcmVuZGVyV2ViR0wocmVuZGVyZXIpO1xufTtcblxuLyoqXG4gKiBQcmVwYXJlcyB0aGUgV2ViR0wgcmVuZGVyZXIgdG8gY2FjaGUgdGhlIHNwcml0ZVxuICpcbiAqIEBwcml2YXRlXG4gKiBAbWVtYmVyb2YgUElYSS5EaXNwbGF5T2JqZWN0I1xuICogQHBhcmFtIHtQSVhJLldlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gdGhlIFdlYkdMIHJlbmRlcmVyXG4gKi9cbkRpc3BsYXlPYmplY3QucHJvdG90eXBlLl9pbml0Q2FjaGVkRGlzcGxheU9iamVjdCA9IGZ1bmN0aW9uIF9pbml0Q2FjaGVkRGlzcGxheU9iamVjdChyZW5kZXJlcikge1xuICAgIGlmICh0aGlzLl9jYWNoZURhdGEgJiYgdGhpcy5fY2FjaGVEYXRhLnNwcml0ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gbWFrZSBzdXJlIGFscGhhIGlzIHNldCB0byAxIG90aGVyd2lzZSBpdCB3aWxsIGdldCByZW5kZXJlZCBhcyBpbnZpc2libGUhXG4gICAgdmFyIGNhY2hlQWxwaGEgPSB0aGlzLmFscGhhO1xuXG4gICAgdGhpcy5hbHBoYSA9IDE7XG5cbiAgICAvLyBmaXJzdCB3ZSBmbHVzaCBhbnl0aGluZyBsZWZ0IGluIHRoZSByZW5kZXJlciAob3RoZXJ3aXNlIGl0IHdvdWxkIGdldCByZW5kZXJlZCB0byB0aGUgY2FjaGVkIHRleHR1cmUpXG4gICAgcmVuZGVyZXIuY3VycmVudFJlbmRlcmVyLmZsdXNoKCk7XG4gICAgLy8gdGhpcy5maWx0ZXJzPSBbXTtcblxuICAgIC8vIG5leHQgd2UgZmluZCB0aGUgZGltZW5zaW9ucyBvZiB0aGUgdW50cmFuc2Zvcm1lZCBvYmplY3RcbiAgICAvLyB0aGlzIGZ1bmN0aW9uIGFsc28gY2FsbHMgdXBkYXRldHJhbnNmb3JtIG9uIGFsbCBpdHMgY2hpbGRyZW4gYXMgcGFydCBvZiB0aGUgbWVhc3VyaW5nLlxuICAgIC8vIFRoaXMgbWVhbnMgd2UgZG9uJ3QgbmVlZCB0byB1cGRhdGUgdGhlIHRyYW5zZm9ybSBhZ2FpbiBpbiB0aGlzIGZ1bmN0aW9uXG4gICAgLy8gVE9ETyBwYXNzIGFuIG9iamVjdCB0byBjbG9uZSB0b28/IHNhdmVzIGhhdmluZyB0byBjcmVhdGUgYSBuZXcgb25lIGVhY2ggdGltZSFcbiAgICB2YXIgYm91bmRzID0gdGhpcy5nZXRMb2NhbEJvdW5kcygpLmNsb25lKCk7XG5cbiAgICAvLyBhZGQgc29tZSBwYWRkaW5nIVxuICAgIGlmICh0aGlzLl9maWx0ZXJzICYmIHRoaXMuX2ZpbHRlcnMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBwYWRkaW5nID0gdGhpcy5fZmlsdGVyc1swXS5wYWRkaW5nO1xuXG4gICAgICAgIGJvdW5kcy5wYWQocGFkZGluZyk7XG4gICAgfVxuXG4gICAgYm91bmRzLmNlaWwoY29yZS5zZXR0aW5ncy5SRVNPTFVUSU9OKTtcblxuICAgIC8vIGZvciBub3cgd2UgY2FjaGUgdGhlIGN1cnJlbnQgcmVuZGVyVGFyZ2V0IHRoYXQgdGhlIHdlYkdMIHJlbmRlcmVyIGlzIGN1cnJlbnRseSB1c2luZy5cbiAgICAvLyB0aGlzIGNvdWxkIGJlIG1vcmUgZWxlZ2VudC4uXG4gICAgdmFyIGNhY2hlZFJlbmRlclRhcmdldCA9IHJlbmRlcmVyLl9hY3RpdmVSZW5kZXJUYXJnZXQ7XG4gICAgLy8gV2UgYWxzbyBzdG9yZSB0aGUgZmlsdGVyIHN0YWNrIC0gSSB3aWxsIGRlZmluaXRlbHkgbG9vayB0byBjaGFuZ2UgaG93IHRoaXMgd29ya3MgYSBsaXR0bGUgbGF0ZXIgZG93biB0aGUgbGluZS5cbiAgICB2YXIgc3RhY2sgPSByZW5kZXJlci5maWx0ZXJNYW5hZ2VyLmZpbHRlclN0YWNrO1xuXG4gICAgLy8gdGhpcyByZW5kZXJUZXh0dXJlIHdpbGwgYmUgdXNlZCB0byBzdG9yZSB0aGUgY2FjaGVkIERpc3BsYXlPYmplY3RcblxuICAgIHZhciByZW5kZXJUZXh0dXJlID0gY29yZS5SZW5kZXJUZXh0dXJlLmNyZWF0ZShib3VuZHMud2lkdGgsIGJvdW5kcy5oZWlnaHQpO1xuXG4gICAgdmFyIHRleHR1cmVDYWNoZUlkID0gJ2NhY2hlQXNCaXRtYXBfJyArICgwLCBfdXRpbHMudWlkKSgpO1xuXG4gICAgdGhpcy5fY2FjaGVEYXRhLnRleHR1cmVDYWNoZUlkID0gdGV4dHVyZUNhY2hlSWQ7XG5cbiAgICBfQmFzZVRleHR1cmUyLmRlZmF1bHQuYWRkVG9DYWNoZShyZW5kZXJUZXh0dXJlLmJhc2VUZXh0dXJlLCB0ZXh0dXJlQ2FjaGVJZCk7XG4gICAgX1RleHR1cmUyLmRlZmF1bHQuYWRkVG9DYWNoZShyZW5kZXJUZXh0dXJlLCB0ZXh0dXJlQ2FjaGVJZCk7XG5cbiAgICAvLyBuZWVkIHRvIHNldCAvL1xuICAgIHZhciBtID0gX3RlbXBNYXRyaXg7XG5cbiAgICBtLnR4ID0gLWJvdW5kcy54O1xuICAgIG0udHkgPSAtYm91bmRzLnk7XG5cbiAgICAvLyByZXNldFxuICAgIHRoaXMudHJhbnNmb3JtLndvcmxkVHJhbnNmb3JtLmlkZW50aXR5KCk7XG5cbiAgICAvLyBzZXQgYWxsIHByb3BlcnRpZXMgdG8gdGhlcmUgb3JpZ2luYWwgc28gd2UgY2FuIHJlbmRlciB0byBhIHRleHR1cmVcbiAgICB0aGlzLnJlbmRlcldlYkdMID0gdGhpcy5fY2FjaGVEYXRhLm9yaWdpbmFsUmVuZGVyV2ViR0w7XG5cbiAgICByZW5kZXJlci5yZW5kZXIodGhpcywgcmVuZGVyVGV4dHVyZSwgdHJ1ZSwgbSwgdHJ1ZSk7XG4gICAgLy8gbm93IHJlc3RvcmUgdGhlIHN0YXRlIGJlIHNldHRpbmcgdGhlIG5ldyBwcm9wZXJ0aWVzXG5cbiAgICByZW5kZXJlci5iaW5kUmVuZGVyVGFyZ2V0KGNhY2hlZFJlbmRlclRhcmdldCk7XG5cbiAgICByZW5kZXJlci5maWx0ZXJNYW5hZ2VyLmZpbHRlclN0YWNrID0gc3RhY2s7XG5cbiAgICB0aGlzLnJlbmRlcldlYkdMID0gdGhpcy5fcmVuZGVyQ2FjaGVkV2ViR0w7XG4gICAgLy8gdGhlIHJlc3QgaXMgdGhlIHNhbWUgYXMgZm9yIENhbnZhc1xuICAgIHRoaXMudXBkYXRlVHJhbnNmb3JtID0gdGhpcy5kaXNwbGF5T2JqZWN0VXBkYXRlVHJhbnNmb3JtO1xuICAgIHRoaXMuY2FsY3VsYXRlQm91bmRzID0gdGhpcy5fY2FsY3VsYXRlQ2FjaGVkQm91bmRzO1xuICAgIHRoaXMuZ2V0TG9jYWxCb3VuZHMgPSB0aGlzLl9nZXRDYWNoZWRMb2NhbEJvdW5kcztcblxuICAgIHRoaXMuX21hc2sgPSBudWxsO1xuICAgIHRoaXMuZmlsdGVyQXJlYSA9IG51bGw7XG5cbiAgICAvLyBjcmVhdGUgb3VyIGNhY2hlZCBzcHJpdGVcbiAgICB2YXIgY2FjaGVkU3ByaXRlID0gbmV3IGNvcmUuU3ByaXRlKHJlbmRlclRleHR1cmUpO1xuXG4gICAgY2FjaGVkU3ByaXRlLnRyYW5zZm9ybS53b3JsZFRyYW5zZm9ybSA9IHRoaXMudHJhbnNmb3JtLndvcmxkVHJhbnNmb3JtO1xuICAgIGNhY2hlZFNwcml0ZS5hbmNob3IueCA9IC0oYm91bmRzLnggLyBib3VuZHMud2lkdGgpO1xuICAgIGNhY2hlZFNwcml0ZS5hbmNob3IueSA9IC0oYm91bmRzLnkgLyBib3VuZHMuaGVpZ2h0KTtcbiAgICBjYWNoZWRTcHJpdGUuYWxwaGEgPSBjYWNoZUFscGhhO1xuICAgIGNhY2hlZFNwcml0ZS5fYm91bmRzID0gdGhpcy5fYm91bmRzO1xuXG4gICAgdGhpcy5fY2FjaGVEYXRhLnNwcml0ZSA9IGNhY2hlZFNwcml0ZTtcblxuICAgIHRoaXMudHJhbnNmb3JtLl9wYXJlbnRJRCA9IC0xO1xuICAgIC8vIHJlc3RvcmUgdGhlIHRyYW5zZm9ybSBvZiB0aGUgY2FjaGVkIHNwcml0ZSB0byBhdm9pZCB0aGUgbmFzdHkgZmxpY2tlci4uXG4gICAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgICAgICB0aGlzLnBhcmVudCA9IHJlbmRlcmVyLl90ZW1wRGlzcGxheU9iamVjdFBhcmVudDtcbiAgICAgICAgdGhpcy51cGRhdGVUcmFuc2Zvcm0oKTtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudXBkYXRlVHJhbnNmb3JtKCk7XG4gICAgfVxuXG4gICAgLy8gbWFwIHRoZSBoaXQgdGVzdC4uXG4gICAgdGhpcy5jb250YWluc1BvaW50ID0gY2FjaGVkU3ByaXRlLmNvbnRhaW5zUG9pbnQuYmluZChjYWNoZWRTcHJpdGUpO1xufTtcblxuLyoqXG4gKiBSZW5kZXJzIGEgY2FjaGVkIHZlcnNpb24gb2YgdGhlIHNwcml0ZSB3aXRoIGNhbnZhc1xuICpcbiAqIEBwcml2YXRlXG4gKiBAbWVtYmVyb2YgUElYSS5EaXNwbGF5T2JqZWN0I1xuICogQHBhcmFtIHtQSVhJLldlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gdGhlIFdlYkdMIHJlbmRlcmVyXG4gKi9cbkRpc3BsYXlPYmplY3QucHJvdG90eXBlLl9yZW5kZXJDYWNoZWRDYW52YXMgPSBmdW5jdGlvbiBfcmVuZGVyQ2FjaGVkQ2FudmFzKHJlbmRlcmVyKSB7XG4gICAgaWYgKCF0aGlzLnZpc2libGUgfHwgdGhpcy53b3JsZEFscGhhIDw9IDAgfHwgIXRoaXMucmVuZGVyYWJsZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5faW5pdENhY2hlZERpc3BsYXlPYmplY3RDYW52YXMocmVuZGVyZXIpO1xuXG4gICAgdGhpcy5fY2FjaGVEYXRhLnNwcml0ZS53b3JsZEFscGhhID0gdGhpcy53b3JsZEFscGhhO1xuICAgIHRoaXMuX2NhY2hlRGF0YS5zcHJpdGUuX3JlbmRlckNhbnZhcyhyZW5kZXJlcik7XG59O1xuXG4vLyBUT0RPIHRoaXMgY2FuIGJlIHRoZSBzYW1lIGFzIHRoZSB3ZWJHTCB2ZXJpc29uLi4gd2lsbCBuZWVkIHRvIGRvIGEgbGl0dGxlIHR3ZWFraW5nIGZpcnN0IHRob3VnaC4uXG4vKipcbiAqIFByZXBhcmVzIHRoZSBDYW52YXMgcmVuZGVyZXIgdG8gY2FjaGUgdGhlIHNwcml0ZVxuICpcbiAqIEBwcml2YXRlXG4gKiBAbWVtYmVyb2YgUElYSS5EaXNwbGF5T2JqZWN0I1xuICogQHBhcmFtIHtQSVhJLldlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gdGhlIFdlYkdMIHJlbmRlcmVyXG4gKi9cbkRpc3BsYXlPYmplY3QucHJvdG90eXBlLl9pbml0Q2FjaGVkRGlzcGxheU9iamVjdENhbnZhcyA9IGZ1bmN0aW9uIF9pbml0Q2FjaGVkRGlzcGxheU9iamVjdENhbnZhcyhyZW5kZXJlcikge1xuICAgIGlmICh0aGlzLl9jYWNoZURhdGEgJiYgdGhpcy5fY2FjaGVEYXRhLnNwcml0ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gZ2V0IGJvdW5kcyBhY3R1YWxseSB0cmFuc2Zvcm1zIHRoZSBvYmplY3QgZm9yIHVzIGFscmVhZHkhXG4gICAgdmFyIGJvdW5kcyA9IHRoaXMuZ2V0TG9jYWxCb3VuZHMoKTtcblxuICAgIHZhciBjYWNoZUFscGhhID0gdGhpcy5hbHBoYTtcblxuICAgIHRoaXMuYWxwaGEgPSAxO1xuXG4gICAgdmFyIGNhY2hlZFJlbmRlclRhcmdldCA9IHJlbmRlcmVyLmNvbnRleHQ7XG5cbiAgICBib3VuZHMuY2VpbChjb3JlLnNldHRpbmdzLlJFU09MVVRJT04pO1xuXG4gICAgdmFyIHJlbmRlclRleHR1cmUgPSBjb3JlLlJlbmRlclRleHR1cmUuY3JlYXRlKGJvdW5kcy53aWR0aCwgYm91bmRzLmhlaWdodCk7XG5cbiAgICB2YXIgdGV4dHVyZUNhY2hlSWQgPSAnY2FjaGVBc0JpdG1hcF8nICsgKDAsIF91dGlscy51aWQpKCk7XG5cbiAgICB0aGlzLl9jYWNoZURhdGEudGV4dHVyZUNhY2hlSWQgPSB0ZXh0dXJlQ2FjaGVJZDtcblxuICAgIF9CYXNlVGV4dHVyZTIuZGVmYXVsdC5hZGRUb0NhY2hlKHJlbmRlclRleHR1cmUuYmFzZVRleHR1cmUsIHRleHR1cmVDYWNoZUlkKTtcbiAgICBfVGV4dHVyZTIuZGVmYXVsdC5hZGRUb0NhY2hlKHJlbmRlclRleHR1cmUsIHRleHR1cmVDYWNoZUlkKTtcblxuICAgIC8vIG5lZWQgdG8gc2V0IC8vXG4gICAgdmFyIG0gPSBfdGVtcE1hdHJpeDtcblxuICAgIHRoaXMudHJhbnNmb3JtLmxvY2FsVHJhbnNmb3JtLmNvcHkobSk7XG4gICAgbS5pbnZlcnQoKTtcblxuICAgIG0udHggLT0gYm91bmRzLng7XG4gICAgbS50eSAtPSBib3VuZHMueTtcblxuICAgIC8vIG0uYXBwZW5kKHRoaXMudHJhbnNmb3JtLndvcmxkVHJhbnNmb3JtLilcbiAgICAvLyBzZXQgYWxsIHByb3BlcnRpZXMgdG8gdGhlcmUgb3JpZ2luYWwgc28gd2UgY2FuIHJlbmRlciB0byBhIHRleHR1cmVcbiAgICB0aGlzLnJlbmRlckNhbnZhcyA9IHRoaXMuX2NhY2hlRGF0YS5vcmlnaW5hbFJlbmRlckNhbnZhcztcblxuICAgIC8vIHJlbmRlclRleHR1cmUucmVuZGVyKHRoaXMsIG0sIHRydWUpO1xuICAgIHJlbmRlcmVyLnJlbmRlcih0aGlzLCByZW5kZXJUZXh0dXJlLCB0cnVlLCBtLCBmYWxzZSk7XG5cbiAgICAvLyBub3cgcmVzdG9yZSB0aGUgc3RhdGUgYmUgc2V0dGluZyB0aGUgbmV3IHByb3BlcnRpZXNcbiAgICByZW5kZXJlci5jb250ZXh0ID0gY2FjaGVkUmVuZGVyVGFyZ2V0O1xuXG4gICAgdGhpcy5yZW5kZXJDYW52YXMgPSB0aGlzLl9yZW5kZXJDYWNoZWRDYW52YXM7XG4gICAgLy8gdGhlIHJlc3QgaXMgdGhlIHNhbWUgYXMgZm9yIFdlYkdMXG4gICAgdGhpcy51cGRhdGVUcmFuc2Zvcm0gPSB0aGlzLmRpc3BsYXlPYmplY3RVcGRhdGVUcmFuc2Zvcm07XG4gICAgdGhpcy5jYWxjdWxhdGVCb3VuZHMgPSB0aGlzLl9jYWxjdWxhdGVDYWNoZWRCb3VuZHM7XG4gICAgdGhpcy5nZXRMb2NhbEJvdW5kcyA9IHRoaXMuX2dldENhY2hlZExvY2FsQm91bmRzO1xuXG4gICAgdGhpcy5fbWFzayA9IG51bGw7XG4gICAgdGhpcy5maWx0ZXJBcmVhID0gbnVsbDtcblxuICAgIC8vIGNyZWF0ZSBvdXIgY2FjaGVkIHNwcml0ZVxuICAgIHZhciBjYWNoZWRTcHJpdGUgPSBuZXcgY29yZS5TcHJpdGUocmVuZGVyVGV4dHVyZSk7XG5cbiAgICBjYWNoZWRTcHJpdGUudHJhbnNmb3JtLndvcmxkVHJhbnNmb3JtID0gdGhpcy50cmFuc2Zvcm0ud29ybGRUcmFuc2Zvcm07XG4gICAgY2FjaGVkU3ByaXRlLmFuY2hvci54ID0gLShib3VuZHMueCAvIGJvdW5kcy53aWR0aCk7XG4gICAgY2FjaGVkU3ByaXRlLmFuY2hvci55ID0gLShib3VuZHMueSAvIGJvdW5kcy5oZWlnaHQpO1xuICAgIGNhY2hlZFNwcml0ZS5hbHBoYSA9IGNhY2hlQWxwaGE7XG4gICAgY2FjaGVkU3ByaXRlLl9ib3VuZHMgPSB0aGlzLl9ib3VuZHM7XG5cbiAgICB0aGlzLl9jYWNoZURhdGEuc3ByaXRlID0gY2FjaGVkU3ByaXRlO1xuXG4gICAgdGhpcy50cmFuc2Zvcm0uX3BhcmVudElEID0gLTE7XG4gICAgLy8gcmVzdG9yZSB0aGUgdHJhbnNmb3JtIG9mIHRoZSBjYWNoZWQgc3ByaXRlIHRvIGF2b2lkIHRoZSBuYXN0eSBmbGlja2VyLi5cbiAgICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcmVuZGVyZXIuX3RlbXBEaXNwbGF5T2JqZWN0UGFyZW50O1xuICAgICAgICB0aGlzLnVwZGF0ZVRyYW5zZm9ybSgpO1xuICAgICAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy51cGRhdGVUcmFuc2Zvcm0oKTtcbiAgICB9XG5cbiAgICAvLyBtYXAgdGhlIGhpdCB0ZXN0Li5cbiAgICB0aGlzLmNvbnRhaW5zUG9pbnQgPSBjYWNoZWRTcHJpdGUuY29udGFpbnNQb2ludC5iaW5kKGNhY2hlZFNwcml0ZSk7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGJvdW5kcyBvZiB0aGUgY2FjaGVkIHNwcml0ZVxuICpcbiAqIEBwcml2YXRlXG4gKi9cbkRpc3BsYXlPYmplY3QucHJvdG90eXBlLl9jYWxjdWxhdGVDYWNoZWRCb3VuZHMgPSBmdW5jdGlvbiBfY2FsY3VsYXRlQ2FjaGVkQm91bmRzKCkge1xuICAgIHRoaXMuX2JvdW5kcy5jbGVhcigpO1xuICAgIHRoaXMuX2NhY2hlRGF0YS5zcHJpdGUudHJhbnNmb3JtLl93b3JsZElEID0gdGhpcy50cmFuc2Zvcm0uX3dvcmxkSUQ7XG4gICAgdGhpcy5fY2FjaGVEYXRhLnNwcml0ZS5fY2FsY3VsYXRlQm91bmRzKCk7XG4gICAgdGhpcy5fbGFzdEJvdW5kc0lEID0gdGhpcy5fYm91bmRzSUQ7XG59O1xuXG4vKipcbiAqIEdldHMgdGhlIGJvdW5kcyBvZiB0aGUgY2FjaGVkIHNwcml0ZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHJldHVybiB7UmVjdGFuZ2xlfSBUaGUgbG9jYWwgYm91bmRzLlxuICovXG5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZS5fZ2V0Q2FjaGVkTG9jYWxCb3VuZHMgPSBmdW5jdGlvbiBfZ2V0Q2FjaGVkTG9jYWxCb3VuZHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlRGF0YS5zcHJpdGUuZ2V0TG9jYWxCb3VuZHMoKTtcbn07XG5cbi8qKlxuICogRGVzdHJveXMgdGhlIGNhY2hlZCBzcHJpdGUuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuRGlzcGxheU9iamVjdC5wcm90b3R5cGUuX2Rlc3Ryb3lDYWNoZWREaXNwbGF5T2JqZWN0ID0gZnVuY3Rpb24gX2Rlc3Ryb3lDYWNoZWREaXNwbGF5T2JqZWN0KCkge1xuICAgIHRoaXMuX2NhY2hlRGF0YS5zcHJpdGUuX3RleHR1cmUuZGVzdHJveSh0cnVlKTtcbiAgICB0aGlzLl9jYWNoZURhdGEuc3ByaXRlID0gbnVsbDtcblxuICAgIF9CYXNlVGV4dHVyZTIuZGVmYXVsdC5yZW1vdmVGcm9tQ2FjaGUodGhpcy5fY2FjaGVEYXRhLnRleHR1cmVDYWNoZUlkKTtcbiAgICBfVGV4dHVyZTIuZGVmYXVsdC5yZW1vdmVGcm9tQ2FjaGUodGhpcy5fY2FjaGVEYXRhLnRleHR1cmVDYWNoZUlkKTtcblxuICAgIHRoaXMuX2NhY2hlRGF0YS50ZXh0dXJlQ2FjaGVJZCA9IG51bGw7XG59O1xuXG4vKipcbiAqIERlc3Ryb3lzIHRoZSBjYWNoZWQgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge29iamVjdHxib29sZWFufSBbb3B0aW9uc10gLSBPcHRpb25zIHBhcmFtZXRlci4gQSBib29sZWFuIHdpbGwgYWN0IGFzIGlmIGFsbCBvcHRpb25zXG4gKiAgaGF2ZSBiZWVuIHNldCB0byB0aGF0IHZhbHVlLlxuICogIFVzZWQgd2hlbiBkZXN0cm95aW5nIGNvbnRhaW5lcnMsIHNlZSB0aGUgQ29udGFpbmVyLmRlc3Ryb3kgbWV0aG9kLlxuICovXG5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZS5fY2FjaGVBc0JpdG1hcERlc3Ryb3kgPSBmdW5jdGlvbiBfY2FjaGVBc0JpdG1hcERlc3Ryb3kob3B0aW9ucykge1xuICAgIHRoaXMuY2FjaGVBc0JpdG1hcCA9IGZhbHNlO1xuICAgIHRoaXMuZGVzdHJveShvcHRpb25zKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jYWNoZUFzQml0bWFwLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxudmFyIF9jb3JlID0gcmVxdWlyZSgnLi4vY29yZScpO1xuXG52YXIgY29yZSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9jb3JlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuLyoqXG4gKiBUaGUgaW5zdGFuY2UgbmFtZSBvZiB0aGUgb2JqZWN0LlxuICpcbiAqIEBtZW1iZXJvZiBQSVhJLkRpc3BsYXlPYmplY3QjXG4gKiBAbWVtYmVyIHtzdHJpbmd9IG5hbWVcbiAqL1xuY29yZS5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZS5uYW1lID0gbnVsbDtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBkaXNwbGF5IG9iamVjdCBpbiB0aGUgY29udGFpbmVyXG4gKlxuICogQG1ldGhvZCBnZXRDaGlsZEJ5TmFtZVxuICogQG1lbWJlcm9mIFBJWEkuQ29udGFpbmVyI1xuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBpbnN0YW5jZSBuYW1lXG4gKiBAcmV0dXJuIHtQSVhJLkRpc3BsYXlPYmplY3R9IFRoZSBjaGlsZCB3aXRoIHRoZSBzcGVjaWZpZWQgbmFtZS5cbiAqL1xuY29yZS5Db250YWluZXIucHJvdG90eXBlLmdldENoaWxkQnlOYW1lID0gZnVuY3Rpb24gZ2V0Q2hpbGRCeU5hbWUobmFtZSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAodGhpcy5jaGlsZHJlbltpXS5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbltpXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldENoaWxkQnlOYW1lLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxudmFyIF9jb3JlID0gcmVxdWlyZSgnLi4vY29yZScpO1xuXG52YXIgY29yZSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9jb3JlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBnbG9iYWwgcG9zaXRpb24gb2YgdGhlIGRpc3BsYXlPYmplY3QuIERvZXMgbm90IGRlcGVuZCBvbiBvYmplY3Qgc2NhbGUsIHJvdGF0aW9uIGFuZCBwaXZvdC5cbiAqXG4gKiBAbWV0aG9kIGdldEdsb2JhbFBvc2l0aW9uXG4gKiBAbWVtYmVyb2YgUElYSS5EaXNwbGF5T2JqZWN0I1xuICogQHBhcmFtIHtQb2ludH0gcG9pbnQgLSB0aGUgcG9pbnQgdG8gd3JpdGUgdGhlIGdsb2JhbCB2YWx1ZSB0by4gSWYgbnVsbCBhIG5ldyBwb2ludCB3aWxsIGJlIHJldHVybmVkXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNraXBVcGRhdGUgLSBzZXR0aW5nIHRvIHRydWUgd2lsbCBzdG9wIHRoZSB0cmFuc2Zvcm1zIG9mIHRoZSBzY2VuZSBncmFwaCBmcm9tXG4gKiAgYmVpbmcgdXBkYXRlZC4gVGhpcyBtZWFucyB0aGUgY2FsY3VsYXRpb24gcmV0dXJuZWQgTUFZIGJlIG91dCBvZiBkYXRlIEJVVCB3aWxsIGdpdmUgeW91IGFcbiAqICBuaWNlIHBlcmZvcm1hbmNlIGJvb3N0XG4gKiBAcmV0dXJuIHtQb2ludH0gVGhlIHVwZGF0ZWQgcG9pbnRcbiAqL1xuY29yZS5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZS5nZXRHbG9iYWxQb3NpdGlvbiA9IGZ1bmN0aW9uIGdldEdsb2JhbFBvc2l0aW9uKCkge1xuICAgIHZhciBwb2ludCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogbmV3IGNvcmUuUG9pbnQoKTtcbiAgICB2YXIgc2tpcFVwZGF0ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG5cbiAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQudG9HbG9iYWwodGhpcy5wb3NpdGlvbiwgcG9pbnQsIHNraXBVcGRhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHBvaW50LnggPSB0aGlzLnBvc2l0aW9uLng7XG4gICAgICAgIHBvaW50LnkgPSB0aGlzLnBvc2l0aW9uLnk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBvaW50O1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldEdsb2JhbFBvc2l0aW9uLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuQml0bWFwVGV4dCA9IGV4cG9ydHMuVGlsaW5nU3ByaXRlUmVuZGVyZXIgPSBleHBvcnRzLlRpbGluZ1Nwcml0ZSA9IGV4cG9ydHMuQW5pbWF0ZWRTcHJpdGUgPSB1bmRlZmluZWQ7XG5cbnZhciBfQW5pbWF0ZWRTcHJpdGUgPSByZXF1aXJlKCcuL0FuaW1hdGVkU3ByaXRlJyk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnQW5pbWF0ZWRTcHJpdGUnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9BbmltYXRlZFNwcml0ZSkuZGVmYXVsdDtcbiAgfVxufSk7XG5cbnZhciBfVGlsaW5nU3ByaXRlID0gcmVxdWlyZSgnLi9UaWxpbmdTcHJpdGUnKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdUaWxpbmdTcHJpdGUnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9UaWxpbmdTcHJpdGUpLmRlZmF1bHQ7XG4gIH1cbn0pO1xuXG52YXIgX1RpbGluZ1Nwcml0ZVJlbmRlcmVyID0gcmVxdWlyZSgnLi93ZWJnbC9UaWxpbmdTcHJpdGVSZW5kZXJlcicpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ1RpbGluZ1Nwcml0ZVJlbmRlcmVyJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVGlsaW5nU3ByaXRlUmVuZGVyZXIpLmRlZmF1bHQ7XG4gIH1cbn0pO1xuXG52YXIgX0JpdG1hcFRleHQgPSByZXF1aXJlKCcuL0JpdG1hcFRleHQnKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdCaXRtYXBUZXh0Jywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQml0bWFwVGV4dCkuZGVmYXVsdDtcbiAgfVxufSk7XG5cbnJlcXVpcmUoJy4vY2FjaGVBc0JpdG1hcCcpO1xuXG5yZXF1aXJlKCcuL2dldENoaWxkQnlOYW1lJyk7XG5cbnJlcXVpcmUoJy4vZ2V0R2xvYmFsUG9zaXRpb24nKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLy8gaW1wb3J0ZWQgZm9yIHNpZGUgZWZmZWN0IG9mIGV4dGVuZGluZyB0aGUgcHJvdG90eXBlIG9ubHksIGNvbnRhaW5zIG5vIGV4cG9ydHNcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9jb3JlID0gcmVxdWlyZSgnLi4vLi4vY29yZScpO1xuXG52YXIgY29yZSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9jb3JlKTtcblxudmFyIF9jb25zdCA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvY29uc3QnKTtcblxudmFyIF9wYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciB0ZW1wTWF0ID0gbmV3IGNvcmUuTWF0cml4KCk7XG5cbi8qKlxuICogV2ViR0wgcmVuZGVyZXIgcGx1Z2luIGZvciB0aWxpbmcgc3ByaXRlc1xuICpcbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIFBJWEkuZXh0cmFzXG4gKiBAZXh0ZW5kcyBQSVhJLk9iamVjdFJlbmRlcmVyXG4gKi9cblxudmFyIFRpbGluZ1Nwcml0ZVJlbmRlcmVyID0gZnVuY3Rpb24gKF9jb3JlJE9iamVjdFJlbmRlcmVyKSB7XG4gICAgX2luaGVyaXRzKFRpbGluZ1Nwcml0ZVJlbmRlcmVyLCBfY29yZSRPYmplY3RSZW5kZXJlcik7XG5cbiAgICAvKipcbiAgICAgKiBjb25zdHJ1Y3RvciBmb3IgcmVuZGVyZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgVGhlIHJlbmRlcmVyIHRoaXMgdGlsaW5nIGF3ZXNvbWVuZXNzIHdvcmtzIGZvci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBUaWxpbmdTcHJpdGVSZW5kZXJlcihyZW5kZXJlcikge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVGlsaW5nU3ByaXRlUmVuZGVyZXIpO1xuXG4gICAgICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9jb3JlJE9iamVjdFJlbmRlcmVyLmNhbGwodGhpcywgcmVuZGVyZXIpKTtcblxuICAgICAgICBfdGhpcy5zaGFkZXIgPSBudWxsO1xuICAgICAgICBfdGhpcy5zaW1wbGVTaGFkZXIgPSBudWxsO1xuICAgICAgICBfdGhpcy5xdWFkID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdXAgdGhlIHJlbmRlcmVyIGNvbnRleHQgYW5kIG5lY2Vzc2FyeSBidWZmZXJzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuXG4gICAgVGlsaW5nU3ByaXRlUmVuZGVyZXIucHJvdG90eXBlLm9uQ29udGV4dENoYW5nZSA9IGZ1bmN0aW9uIG9uQ29udGV4dENoYW5nZSgpIHtcbiAgICAgICAgdmFyIGdsID0gdGhpcy5yZW5kZXJlci5nbDtcblxuICAgICAgICB0aGlzLnNoYWRlciA9IG5ldyBjb3JlLlNoYWRlcihnbCwgJ2F0dHJpYnV0ZSB2ZWMyIGFWZXJ0ZXhQb3NpdGlvbjtcXG5hdHRyaWJ1dGUgdmVjMiBhVGV4dHVyZUNvb3JkO1xcblxcbnVuaWZvcm0gbWF0MyBwcm9qZWN0aW9uTWF0cml4O1xcbnVuaWZvcm0gbWF0MyB0cmFuc2xhdGlvbk1hdHJpeDtcXG51bmlmb3JtIG1hdDMgdVRyYW5zZm9ybTtcXG5cXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG5cXG52b2lkIG1haW4odm9pZClcXG57XFxuICAgIGdsX1Bvc2l0aW9uID0gdmVjNCgocHJvamVjdGlvbk1hdHJpeCAqIHRyYW5zbGF0aW9uTWF0cml4ICogdmVjMyhhVmVydGV4UG9zaXRpb24sIDEuMCkpLnh5LCAwLjAsIDEuMCk7XFxuXFxuICAgIHZUZXh0dXJlQ29vcmQgPSAodVRyYW5zZm9ybSAqIHZlYzMoYVRleHR1cmVDb29yZCwgMS4wKSkueHk7XFxufVxcbicsICd2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG5cXG51bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcXG51bmlmb3JtIHZlYzQgdUNvbG9yO1xcbnVuaWZvcm0gbWF0MyB1TWFwQ29vcmQ7XFxudW5pZm9ybSB2ZWM0IHVDbGFtcEZyYW1lO1xcbnVuaWZvcm0gdmVjMiB1Q2xhbXBPZmZzZXQ7XFxuXFxudm9pZCBtYWluKHZvaWQpXFxue1xcbiAgICB2ZWMyIGNvb3JkID0gbW9kKHZUZXh0dXJlQ29vcmQgLSB1Q2xhbXBPZmZzZXQsIHZlYzIoMS4wLCAxLjApKSArIHVDbGFtcE9mZnNldDtcXG4gICAgY29vcmQgPSAodU1hcENvb3JkICogdmVjMyhjb29yZCwgMS4wKSkueHk7XFxuICAgIGNvb3JkID0gY2xhbXAoY29vcmQsIHVDbGFtcEZyYW1lLnh5LCB1Q2xhbXBGcmFtZS56dyk7XFxuXFxuICAgIHZlYzQgc2FtcGxlID0gdGV4dHVyZTJEKHVTYW1wbGVyLCBjb29yZCk7XFxuICAgIGdsX0ZyYWdDb2xvciA9IHNhbXBsZSAqIHVDb2xvcjtcXG59XFxuJyk7XG4gICAgICAgIHRoaXMuc2ltcGxlU2hhZGVyID0gbmV3IGNvcmUuU2hhZGVyKGdsLCAnYXR0cmlidXRlIHZlYzIgYVZlcnRleFBvc2l0aW9uO1xcbmF0dHJpYnV0ZSB2ZWMyIGFUZXh0dXJlQ29vcmQ7XFxuXFxudW5pZm9ybSBtYXQzIHByb2plY3Rpb25NYXRyaXg7XFxudW5pZm9ybSBtYXQzIHRyYW5zbGF0aW9uTWF0cml4O1xcbnVuaWZvcm0gbWF0MyB1VHJhbnNmb3JtO1xcblxcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcblxcbnZvaWQgbWFpbih2b2lkKVxcbntcXG4gICAgZ2xfUG9zaXRpb24gPSB2ZWM0KChwcm9qZWN0aW9uTWF0cml4ICogdHJhbnNsYXRpb25NYXRyaXggKiB2ZWMzKGFWZXJ0ZXhQb3NpdGlvbiwgMS4wKSkueHksIDAuMCwgMS4wKTtcXG5cXG4gICAgdlRleHR1cmVDb29yZCA9ICh1VHJhbnNmb3JtICogdmVjMyhhVGV4dHVyZUNvb3JkLCAxLjApKS54eTtcXG59XFxuJywgJ3ZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcblxcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xcbnVuaWZvcm0gdmVjNCB1Q29sb3I7XFxuXFxudm9pZCBtYWluKHZvaWQpXFxue1xcbiAgICB2ZWM0IHNhbXBsZSA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCk7XFxuICAgIGdsX0ZyYWdDb2xvciA9IHNhbXBsZSAqIHVDb2xvcjtcXG59XFxuJyk7XG5cbiAgICAgICAgdGhpcy5yZW5kZXJlci5iaW5kVmFvKG51bGwpO1xuICAgICAgICB0aGlzLnF1YWQgPSBuZXcgY29yZS5RdWFkKGdsLCB0aGlzLnJlbmRlcmVyLnN0YXRlLmF0dHJpYlN0YXRlKTtcbiAgICAgICAgdGhpcy5xdWFkLmluaXRWYW8odGhpcy5zaGFkZXIpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5leHRyYXMuVGlsaW5nU3ByaXRlfSB0cyB0aWxpbmdTcHJpdGUgdG8gYmUgcmVuZGVyZWRcbiAgICAgKi9cblxuXG4gICAgVGlsaW5nU3ByaXRlUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcih0cykge1xuICAgICAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyO1xuICAgICAgICB2YXIgcXVhZCA9IHRoaXMucXVhZDtcblxuICAgICAgICByZW5kZXJlci5iaW5kVmFvKHF1YWQudmFvKTtcblxuICAgICAgICB2YXIgdmVydGljZXMgPSBxdWFkLnZlcnRpY2VzO1xuXG4gICAgICAgIHZlcnRpY2VzWzBdID0gdmVydGljZXNbNl0gPSB0cy5fd2lkdGggKiAtdHMuYW5jaG9yLng7XG4gICAgICAgIHZlcnRpY2VzWzFdID0gdmVydGljZXNbM10gPSB0cy5faGVpZ2h0ICogLXRzLmFuY2hvci55O1xuXG4gICAgICAgIHZlcnRpY2VzWzJdID0gdmVydGljZXNbNF0gPSB0cy5fd2lkdGggKiAoMS4wIC0gdHMuYW5jaG9yLngpO1xuICAgICAgICB2ZXJ0aWNlc1s1XSA9IHZlcnRpY2VzWzddID0gdHMuX2hlaWdodCAqICgxLjAgLSB0cy5hbmNob3IueSk7XG5cbiAgICAgICAgaWYgKHRzLnV2UmVzcGVjdEFuY2hvcikge1xuICAgICAgICAgICAgdmVydGljZXMgPSBxdWFkLnV2cztcblxuICAgICAgICAgICAgdmVydGljZXNbMF0gPSB2ZXJ0aWNlc1s2XSA9IC10cy5hbmNob3IueDtcbiAgICAgICAgICAgIHZlcnRpY2VzWzFdID0gdmVydGljZXNbM10gPSAtdHMuYW5jaG9yLnk7XG5cbiAgICAgICAgICAgIHZlcnRpY2VzWzJdID0gdmVydGljZXNbNF0gPSAxLjAgLSB0cy5hbmNob3IueDtcbiAgICAgICAgICAgIHZlcnRpY2VzWzVdID0gdmVydGljZXNbN10gPSAxLjAgLSB0cy5hbmNob3IueTtcbiAgICAgICAgfVxuXG4gICAgICAgIHF1YWQudXBsb2FkKCk7XG5cbiAgICAgICAgdmFyIHRleCA9IHRzLl90ZXh0dXJlO1xuICAgICAgICB2YXIgYmFzZVRleCA9IHRleC5iYXNlVGV4dHVyZTtcbiAgICAgICAgdmFyIGx0ID0gdHMudGlsZVRyYW5zZm9ybS5sb2NhbFRyYW5zZm9ybTtcbiAgICAgICAgdmFyIHV2ID0gdHMudXZUcmFuc2Zvcm07XG4gICAgICAgIHZhciBpc1NpbXBsZSA9IGJhc2VUZXguaXNQb3dlck9mVHdvICYmIHRleC5mcmFtZS53aWR0aCA9PT0gYmFzZVRleC53aWR0aCAmJiB0ZXguZnJhbWUuaGVpZ2h0ID09PSBiYXNlVGV4LmhlaWdodDtcblxuICAgICAgICAvLyBhdXRvLCBmb3JjZSByZXBlYXQgd3JhcE1vZGUgZm9yIGJpZyB0aWxpbmcgdGV4dHVyZXNcbiAgICAgICAgaWYgKGlzU2ltcGxlKSB7XG4gICAgICAgICAgICBpZiAoIWJhc2VUZXguX2dsVGV4dHVyZXNbcmVuZGVyZXIuQ09OVEVYVF9VSURdKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJhc2VUZXgud3JhcE1vZGUgPT09IF9jb25zdC5XUkFQX01PREVTLkNMQU1QKSB7XG4gICAgICAgICAgICAgICAgICAgIGJhc2VUZXgud3JhcE1vZGUgPSBfY29uc3QuV1JBUF9NT0RFUy5SRVBFQVQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpc1NpbXBsZSA9IGJhc2VUZXgud3JhcE1vZGUgIT09IF9jb25zdC5XUkFQX01PREVTLkNMQU1QO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNoYWRlciA9IGlzU2ltcGxlID8gdGhpcy5zaW1wbGVTaGFkZXIgOiB0aGlzLnNoYWRlcjtcblxuICAgICAgICByZW5kZXJlci5iaW5kU2hhZGVyKHNoYWRlcik7XG5cbiAgICAgICAgdmFyIHcgPSB0ZXgud2lkdGg7XG4gICAgICAgIHZhciBoID0gdGV4LmhlaWdodDtcbiAgICAgICAgdmFyIFcgPSB0cy5fd2lkdGg7XG4gICAgICAgIHZhciBIID0gdHMuX2hlaWdodDtcblxuICAgICAgICB0ZW1wTWF0LnNldChsdC5hICogdyAvIFcsIGx0LmIgKiB3IC8gSCwgbHQuYyAqIGggLyBXLCBsdC5kICogaCAvIEgsIGx0LnR4IC8gVywgbHQudHkgLyBIKTtcblxuICAgICAgICAvLyB0aGF0IHBhcnQgaXMgdGhlIHNhbWUgYXMgYWJvdmU6XG4gICAgICAgIC8vIHRlbXBNYXQuaWRlbnRpdHkoKTtcbiAgICAgICAgLy8gdGVtcE1hdC5zY2FsZSh0ZXgud2lkdGgsIHRleC5oZWlnaHQpO1xuICAgICAgICAvLyB0ZW1wTWF0LnByZXBlbmQobHQpO1xuICAgICAgICAvLyB0ZW1wTWF0LnNjYWxlKDEuMCAvIHRzLl93aWR0aCwgMS4wIC8gdHMuX2hlaWdodCk7XG5cbiAgICAgICAgdGVtcE1hdC5pbnZlcnQoKTtcbiAgICAgICAgaWYgKGlzU2ltcGxlKSB7XG4gICAgICAgICAgICB0ZW1wTWF0LnByZXBlbmQodXYubWFwQ29vcmQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2hhZGVyLnVuaWZvcm1zLnVNYXBDb29yZCA9IHV2Lm1hcENvb3JkLnRvQXJyYXkodHJ1ZSk7XG4gICAgICAgICAgICBzaGFkZXIudW5pZm9ybXMudUNsYW1wRnJhbWUgPSB1di51Q2xhbXBGcmFtZTtcbiAgICAgICAgICAgIHNoYWRlci51bmlmb3Jtcy51Q2xhbXBPZmZzZXQgPSB1di51Q2xhbXBPZmZzZXQ7XG4gICAgICAgIH1cblxuICAgICAgICBzaGFkZXIudW5pZm9ybXMudVRyYW5zZm9ybSA9IHRlbXBNYXQudG9BcnJheSh0cnVlKTtcbiAgICAgICAgc2hhZGVyLnVuaWZvcm1zLnVDb2xvciA9IGNvcmUudXRpbHMucHJlbXVsdGlwbHlUaW50VG9SZ2JhKHRzLnRpbnQsIHRzLndvcmxkQWxwaGEsIHNoYWRlci51bmlmb3Jtcy51Q29sb3IsIGJhc2VUZXgucHJlbXVsdGlwbGllZEFscGhhKTtcbiAgICAgICAgc2hhZGVyLnVuaWZvcm1zLnRyYW5zbGF0aW9uTWF0cml4ID0gdHMudHJhbnNmb3JtLndvcmxkVHJhbnNmb3JtLnRvQXJyYXkodHJ1ZSk7XG5cbiAgICAgICAgc2hhZGVyLnVuaWZvcm1zLnVTYW1wbGVyID0gcmVuZGVyZXIuYmluZFRleHR1cmUodGV4KTtcblxuICAgICAgICByZW5kZXJlci5zZXRCbGVuZE1vZGUoY29yZS51dGlscy5jb3JyZWN0QmxlbmRNb2RlKHRzLmJsZW5kTW9kZSwgYmFzZVRleC5wcmVtdWx0aXBsaWVkQWxwaGEpKTtcblxuICAgICAgICBxdWFkLnZhby5kcmF3KHRoaXMucmVuZGVyZXIuZ2wuVFJJQU5HTEVTLCA2LCAwKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFRpbGluZ1Nwcml0ZVJlbmRlcmVyO1xufShjb3JlLk9iamVjdFJlbmRlcmVyKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gVGlsaW5nU3ByaXRlUmVuZGVyZXI7XG5cblxuY29yZS5XZWJHTFJlbmRlcmVyLnJlZ2lzdGVyUGx1Z2luKCd0aWxpbmdTcHJpdGUnLCBUaWxpbmdTcHJpdGVSZW5kZXJlcik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UaWxpbmdTcHJpdGVSZW5kZXJlci5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfY29yZSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUnKTtcblxudmFyIGNvcmUgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfY29yZSk7XG5cbnZhciBfcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4vKipcbiAqIFNpbXBsZXN0IGZpbHRlciAtIGFwcGxpZXMgYWxwaGFcbiAqXG4gKiBVc2UgdGhpcyBpbnN0ZWFkIG9mIENvbnRhaW5lcidzIGFscGhhIHByb3BlcnR5IHRvIGF2b2lkIHZpc3VhbCBsYXllcmluZyBvZiBpbmRpdmlkdWFsIGVsZW1lbnRzLlxuICogQWxwaGFGaWx0ZXIgYXBwbGllcyBhbHBoYSBldmVubHkgYWNyb3NzIHRoZSBlbnRpcmUgZGlzcGxheSBvYmplY3QgYW5kIGFueSBvcGFxdWUgZWxlbWVudHMgaXQgY29udGFpbnMuXG4gKiBJZiBlbGVtZW50cyBhcmUgbm90IG9wYXF1ZSwgdGhleSB3aWxsIGJsZW5kIHdpdGggZWFjaCBvdGhlciBhbnl3YXkuXG4gKlxuICogVmVyeSBoYW5keSBpZiB5b3Ugd2FudCB0byB1c2UgY29tbW9uIGZlYXR1cmVzIG9mIGFsbCBmaWx0ZXJzOlxuICpcbiAqIDEuIEFzc2lnbiBhIGJsZW5kTW9kZSB0byB0aGlzIGZpbHRlciwgYmxlbmQgYWxsIGVsZW1lbnRzIGluc2lkZSBkaXNwbGF5IG9iamVjdCB3aXRoIGJhY2tncm91bmQuXG4gKlxuICogMi4gVG8gdXNlIGNsaXBwaW5nIGluIGRpc3BsYXkgY29vcmRpbmF0ZXMsIGFzc2lnbiBhIGZpbHRlckFyZWEgdG8gdGhlIHNhbWUgY29udGFpbmVyIHRoYXQgaGFzIHRoaXMgZmlsdGVyLlxuICpcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgUElYSS5GaWx0ZXJcbiAqIEBtZW1iZXJvZiBQSVhJLmZpbHRlcnNcbiAqL1xudmFyIEFscGhhRmlsdGVyID0gZnVuY3Rpb24gKF9jb3JlJEZpbHRlcikge1xuICAgIF9pbmhlcml0cyhBbHBoYUZpbHRlciwgX2NvcmUkRmlsdGVyKTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYWxwaGE9MV0gQW1vdW50IG9mIGFscGhhIGZyb20gMCB0byAxLCB3aGVyZSAwIGlzIHRyYW5zcGFyZW50XG4gICAgICovXG4gICAgZnVuY3Rpb24gQWxwaGFGaWx0ZXIoKSB7XG4gICAgICAgIHZhciBhbHBoYSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMS4wO1xuXG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBbHBoYUZpbHRlcik7XG5cbiAgICAgICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2NvcmUkRmlsdGVyLmNhbGwodGhpcyxcbiAgICAgICAgLy8gdmVydGV4IHNoYWRlclxuICAgICAgICAnYXR0cmlidXRlIHZlYzIgYVZlcnRleFBvc2l0aW9uO1xcbmF0dHJpYnV0ZSB2ZWMyIGFUZXh0dXJlQ29vcmQ7XFxuXFxudW5pZm9ybSBtYXQzIHByb2plY3Rpb25NYXRyaXg7XFxuXFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxuXFxudm9pZCBtYWluKHZvaWQpXFxue1xcbiAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoKHByb2plY3Rpb25NYXRyaXggKiB2ZWMzKGFWZXJ0ZXhQb3NpdGlvbiwgMS4wKSkueHksIDAuMCwgMS4wKTtcXG4gICAgdlRleHR1cmVDb29yZCA9IGFUZXh0dXJlQ29vcmQ7XFxufScsXG4gICAgICAgIC8vIGZyYWdtZW50IHNoYWRlclxuICAgICAgICAndmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxuXFxudW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XFxudW5pZm9ybSBmbG9hdCB1QWxwaGE7XFxuXFxudm9pZCBtYWluKHZvaWQpXFxue1xcbiAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCkgKiB1QWxwaGE7XFxufVxcbicpKTtcblxuICAgICAgICBfdGhpcy5hbHBoYSA9IGFscGhhO1xuICAgICAgICBfdGhpcy5nbFNoYWRlcktleSA9ICdhbHBoYSc7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb2VmZmljaWVudCBmb3IgYWxwaGEgbXVsdGlwbGljYXRpb25cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAxXG4gICAgICovXG5cblxuICAgIF9jcmVhdGVDbGFzcyhBbHBoYUZpbHRlciwgW3tcbiAgICAgICAga2V5OiAnYWxwaGEnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLnVBbHBoYTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcmVxdWlyZS1qc2RvY1xuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnVuaWZvcm1zLnVBbHBoYSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEFscGhhRmlsdGVyO1xufShjb3JlLkZpbHRlcik7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEFscGhhRmlsdGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QWxwaGFGaWx0ZXIuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2NvcmUgPSByZXF1aXJlKCcuLi8uLi9jb3JlJyk7XG5cbnZhciBjb3JlID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX2NvcmUpO1xuXG52YXIgX0JsdXJYRmlsdGVyID0gcmVxdWlyZSgnLi9CbHVyWEZpbHRlcicpO1xuXG52YXIgX0JsdXJYRmlsdGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0JsdXJYRmlsdGVyKTtcblxudmFyIF9CbHVyWUZpbHRlciA9IHJlcXVpcmUoJy4vQmx1cllGaWx0ZXInKTtcblxudmFyIF9CbHVyWUZpbHRlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9CbHVyWUZpbHRlcik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuLyoqXG4gKiBUaGUgQmx1ckZpbHRlciBhcHBsaWVzIGEgR2F1c3NpYW4gYmx1ciB0byBhbiBvYmplY3QuXG4gKiBUaGUgc3RyZW5ndGggb2YgdGhlIGJsdXIgY2FuIGJlIHNldCBmb3IgeC0gYW5kIHktYXhpcyBzZXBhcmF0ZWx5LlxuICpcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgUElYSS5GaWx0ZXJcbiAqIEBtZW1iZXJvZiBQSVhJLmZpbHRlcnNcbiAqL1xudmFyIEJsdXJGaWx0ZXIgPSBmdW5jdGlvbiAoX2NvcmUkRmlsdGVyKSB7XG4gICAgX2luaGVyaXRzKEJsdXJGaWx0ZXIsIF9jb3JlJEZpbHRlcik7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RyZW5ndGggLSBUaGUgc3RyZW5ndGggb2YgdGhlIGJsdXIgZmlsdGVyLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBxdWFsaXR5IC0gVGhlIHF1YWxpdHkgb2YgdGhlIGJsdXIgZmlsdGVyLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uIC0gVGhlIHJlc29sdXRpb24gb2YgdGhlIGJsdXIgZmlsdGVyLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBba2VybmVsU2l6ZT01XSAtIFRoZSBrZXJuZWxTaXplIG9mIHRoZSBibHVyIGZpbHRlci5PcHRpb25zOiA1LCA3LCA5LCAxMSwgMTMsIDE1LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEJsdXJGaWx0ZXIoc3RyZW5ndGgsIHF1YWxpdHksIHJlc29sdXRpb24sIGtlcm5lbFNpemUpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJsdXJGaWx0ZXIpO1xuXG4gICAgICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9jb3JlJEZpbHRlci5jYWxsKHRoaXMpKTtcblxuICAgICAgICBfdGhpcy5ibHVyWEZpbHRlciA9IG5ldyBfQmx1clhGaWx0ZXIyLmRlZmF1bHQoc3RyZW5ndGgsIHF1YWxpdHksIHJlc29sdXRpb24sIGtlcm5lbFNpemUpO1xuICAgICAgICBfdGhpcy5ibHVyWUZpbHRlciA9IG5ldyBfQmx1cllGaWx0ZXIyLmRlZmF1bHQoc3RyZW5ndGgsIHF1YWxpdHksIHJlc29sdXRpb24sIGtlcm5lbFNpemUpO1xuXG4gICAgICAgIF90aGlzLnBhZGRpbmcgPSAwO1xuICAgICAgICBfdGhpcy5yZXNvbHV0aW9uID0gcmVzb2x1dGlvbiB8fCBjb3JlLnNldHRpbmdzLlJFU09MVVRJT047XG4gICAgICAgIF90aGlzLnF1YWxpdHkgPSBxdWFsaXR5IHx8IDQ7XG4gICAgICAgIF90aGlzLmJsdXIgPSBzdHJlbmd0aCB8fCA4O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXBwbGllcyB0aGUgZmlsdGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLkZpbHRlck1hbmFnZXJ9IGZpbHRlck1hbmFnZXIgLSBUaGUgbWFuYWdlci5cbiAgICAgKiBAcGFyYW0ge1BJWEkuUmVuZGVyVGFyZ2V0fSBpbnB1dCAtIFRoZSBpbnB1dCB0YXJnZXQuXG4gICAgICogQHBhcmFtIHtQSVhJLlJlbmRlclRhcmdldH0gb3V0cHV0IC0gVGhlIG91dHB1dCB0YXJnZXQuXG4gICAgICovXG5cblxuICAgIEJsdXJGaWx0ZXIucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24gYXBwbHkoZmlsdGVyTWFuYWdlciwgaW5wdXQsIG91dHB1dCkge1xuICAgICAgICB2YXIgcmVuZGVyVGFyZ2V0ID0gZmlsdGVyTWFuYWdlci5nZXRSZW5kZXJUYXJnZXQodHJ1ZSk7XG5cbiAgICAgICAgdGhpcy5ibHVyWEZpbHRlci5hcHBseShmaWx0ZXJNYW5hZ2VyLCBpbnB1dCwgcmVuZGVyVGFyZ2V0LCB0cnVlKTtcbiAgICAgICAgdGhpcy5ibHVyWUZpbHRlci5hcHBseShmaWx0ZXJNYW5hZ2VyLCByZW5kZXJUYXJnZXQsIG91dHB1dCwgZmFsc2UpO1xuXG4gICAgICAgIGZpbHRlck1hbmFnZXIucmV0dXJuUmVuZGVyVGFyZ2V0KHJlbmRlclRhcmdldCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHN0cmVuZ3RoIG9mIGJvdGggdGhlIGJsdXJYIGFuZCBibHVyWSBwcm9wZXJ0aWVzIHNpbXVsdGFuZW91c2x5XG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMlxuICAgICAqL1xuXG5cbiAgICBfY3JlYXRlQ2xhc3MoQmx1ckZpbHRlciwgW3tcbiAgICAgICAga2V5OiAnYmx1cicsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmx1clhGaWx0ZXIuYmx1cjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcmVxdWlyZS1qc2RvY1xuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmJsdXJYRmlsdGVyLmJsdXIgPSB0aGlzLmJsdXJZRmlsdGVyLmJsdXIgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMucGFkZGluZyA9IE1hdGgubWF4KE1hdGguYWJzKHRoaXMuYmx1clhGaWx0ZXIuc3RyZW5ndGgpLCBNYXRoLmFicyh0aGlzLmJsdXJZRmlsdGVyLnN0cmVuZ3RoKSkgKiAyO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIG51bWJlciBvZiBwYXNzZXMgZm9yIGJsdXIuIE1vcmUgcGFzc2VzIG1lYW5zIGhpZ2hlciBxdWFpbGl0eSBibHVyaW5nLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDFcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3F1YWxpdHknLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJsdXJYRmlsdGVyLnF1YWxpdHk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlcXVpcmUtanNkb2NcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5ibHVyWEZpbHRlci5xdWFsaXR5ID0gdGhpcy5ibHVyWUZpbHRlci5xdWFsaXR5ID0gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgc3RyZW5ndGggb2YgdGhlIGJsdXJYIHByb3BlcnR5XG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnYmx1clgnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJsdXJYRmlsdGVyLmJsdXI7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlcXVpcmUtanNkb2NcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5ibHVyWEZpbHRlci5ibHVyID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLnBhZGRpbmcgPSBNYXRoLm1heChNYXRoLmFicyh0aGlzLmJsdXJYRmlsdGVyLnN0cmVuZ3RoKSwgTWF0aC5hYnModGhpcy5ibHVyWUZpbHRlci5zdHJlbmd0aCkpICogMjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSBzdHJlbmd0aCBvZiB0aGUgYmx1clkgcHJvcGVydHlcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAyXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdibHVyWScsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmx1cllGaWx0ZXIuYmx1cjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcmVxdWlyZS1qc2RvY1xuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmJsdXJZRmlsdGVyLmJsdXIgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMucGFkZGluZyA9IE1hdGgubWF4KE1hdGguYWJzKHRoaXMuYmx1clhGaWx0ZXIuc3RyZW5ndGgpLCBNYXRoLmFicyh0aGlzLmJsdXJZRmlsdGVyLnN0cmVuZ3RoKSkgKiAyO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIGJsZW5kbW9kZSBvZiB0aGUgZmlsdGVyXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgUElYSS5CTEVORF9NT0RFUy5OT1JNQUxcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2JsZW5kTW9kZScsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmx1cllGaWx0ZXIuX2JsZW5kTW9kZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcmVxdWlyZS1qc2RvY1xuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmJsdXJZRmlsdGVyLl9ibGVuZE1vZGUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBCbHVyRmlsdGVyO1xufShjb3JlLkZpbHRlcik7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEJsdXJGaWx0ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CbHVyRmlsdGVyLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9jb3JlID0gcmVxdWlyZSgnLi4vLi4vY29yZScpO1xuXG52YXIgY29yZSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9jb3JlKTtcblxudmFyIF9nZW5lcmF0ZUJsdXJWZXJ0U291cmNlID0gcmVxdWlyZSgnLi9nZW5lcmF0ZUJsdXJWZXJ0U291cmNlJyk7XG5cbnZhciBfZ2VuZXJhdGVCbHVyVmVydFNvdXJjZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZW5lcmF0ZUJsdXJWZXJ0U291cmNlKTtcblxudmFyIF9nZW5lcmF0ZUJsdXJGcmFnU291cmNlID0gcmVxdWlyZSgnLi9nZW5lcmF0ZUJsdXJGcmFnU291cmNlJyk7XG5cbnZhciBfZ2VuZXJhdGVCbHVyRnJhZ1NvdXJjZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZW5lcmF0ZUJsdXJGcmFnU291cmNlKTtcblxudmFyIF9nZXRNYXhCbHVyS2VybmVsU2l6ZSA9IHJlcXVpcmUoJy4vZ2V0TWF4Qmx1cktlcm5lbFNpemUnKTtcblxudmFyIF9nZXRNYXhCbHVyS2VybmVsU2l6ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRNYXhCbHVyS2VybmVsU2l6ZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuLyoqXG4gKiBUaGUgQmx1clhGaWx0ZXIgYXBwbGllcyBhIGhvcml6b250YWwgR2F1c3NpYW4gYmx1ciB0byBhbiBvYmplY3QuXG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQSVhJLkZpbHRlclxuICogQG1lbWJlcm9mIFBJWEkuZmlsdGVyc1xuICovXG52YXIgQmx1clhGaWx0ZXIgPSBmdW5jdGlvbiAoX2NvcmUkRmlsdGVyKSB7XG4gICAgX2luaGVyaXRzKEJsdXJYRmlsdGVyLCBfY29yZSRGaWx0ZXIpO1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0cmVuZ3RoIC0gVGhlIHN0cmVuZ3RoIG9mIHRoZSBibHVyIGZpbHRlci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcXVhbGl0eSAtIFRoZSBxdWFsaXR5IG9mIHRoZSBibHVyIGZpbHRlci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiAtIFRoZSByZXNvbHV0aW9uIG9mIHRoZSBibHVyIGZpbHRlci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2tlcm5lbFNpemU9NV0gLSBUaGUga2VybmVsU2l6ZSBvZiB0aGUgYmx1ciBmaWx0ZXIuT3B0aW9uczogNSwgNywgOSwgMTEsIDEzLCAxNS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBCbHVyWEZpbHRlcihzdHJlbmd0aCwgcXVhbGl0eSwgcmVzb2x1dGlvbiwga2VybmVsU2l6ZSkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQmx1clhGaWx0ZXIpO1xuXG4gICAgICAgIGtlcm5lbFNpemUgPSBrZXJuZWxTaXplIHx8IDU7XG4gICAgICAgIHZhciB2ZXJ0U3JjID0gKDAsIF9nZW5lcmF0ZUJsdXJWZXJ0U291cmNlMi5kZWZhdWx0KShrZXJuZWxTaXplLCB0cnVlKTtcbiAgICAgICAgdmFyIGZyYWdTcmMgPSAoMCwgX2dlbmVyYXRlQmx1ckZyYWdTb3VyY2UyLmRlZmF1bHQpKGtlcm5lbFNpemUpO1xuXG4gICAgICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9jb3JlJEZpbHRlci5jYWxsKHRoaXMsXG4gICAgICAgIC8vIHZlcnRleCBzaGFkZXJcbiAgICAgICAgdmVydFNyYyxcbiAgICAgICAgLy8gZnJhZ21lbnQgc2hhZGVyXG4gICAgICAgIGZyYWdTcmMpKTtcblxuICAgICAgICBfdGhpcy5yZXNvbHV0aW9uID0gcmVzb2x1dGlvbiB8fCBjb3JlLnNldHRpbmdzLlJFU09MVVRJT047XG5cbiAgICAgICAgX3RoaXMuX3F1YWxpdHkgPSAwO1xuXG4gICAgICAgIF90aGlzLnF1YWxpdHkgPSBxdWFsaXR5IHx8IDQ7XG4gICAgICAgIF90aGlzLnN0cmVuZ3RoID0gc3RyZW5ndGggfHwgODtcblxuICAgICAgICBfdGhpcy5maXJzdFJ1biA9IHRydWU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIHRoZSBmaWx0ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuRmlsdGVyTWFuYWdlcn0gZmlsdGVyTWFuYWdlciAtIFRoZSBtYW5hZ2VyLlxuICAgICAqIEBwYXJhbSB7UElYSS5SZW5kZXJUYXJnZXR9IGlucHV0IC0gVGhlIGlucHV0IHRhcmdldC5cbiAgICAgKiBAcGFyYW0ge1BJWEkuUmVuZGVyVGFyZ2V0fSBvdXRwdXQgLSBUaGUgb3V0cHV0IHRhcmdldC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNsZWFyIC0gU2hvdWxkIHRoZSBvdXRwdXQgYmUgY2xlYXJlZCBiZWZvcmUgcmVuZGVyaW5nP1xuICAgICAqL1xuXG5cbiAgICBCbHVyWEZpbHRlci5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiBhcHBseShmaWx0ZXJNYW5hZ2VyLCBpbnB1dCwgb3V0cHV0LCBjbGVhcikge1xuICAgICAgICBpZiAodGhpcy5maXJzdFJ1bikge1xuICAgICAgICAgICAgdmFyIGdsID0gZmlsdGVyTWFuYWdlci5yZW5kZXJlci5nbDtcbiAgICAgICAgICAgIHZhciBrZXJuZWxTaXplID0gKDAsIF9nZXRNYXhCbHVyS2VybmVsU2l6ZTIuZGVmYXVsdCkoZ2wpO1xuXG4gICAgICAgICAgICB0aGlzLnZlcnRleFNyYyA9ICgwLCBfZ2VuZXJhdGVCbHVyVmVydFNvdXJjZTIuZGVmYXVsdCkoa2VybmVsU2l6ZSwgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLmZyYWdtZW50U3JjID0gKDAsIF9nZW5lcmF0ZUJsdXJGcmFnU291cmNlMi5kZWZhdWx0KShrZXJuZWxTaXplKTtcblxuICAgICAgICAgICAgdGhpcy5maXJzdFJ1biA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy51bmlmb3Jtcy5zdHJlbmd0aCA9IDEgLyBvdXRwdXQuc2l6ZS53aWR0aCAqIChvdXRwdXQuc2l6ZS53aWR0aCAvIGlucHV0LnNpemUud2lkdGgpO1xuXG4gICAgICAgIC8vIHNjcmVlbiBzcGFjZSFcbiAgICAgICAgdGhpcy51bmlmb3Jtcy5zdHJlbmd0aCAqPSB0aGlzLnN0cmVuZ3RoO1xuICAgICAgICB0aGlzLnVuaWZvcm1zLnN0cmVuZ3RoIC89IHRoaXMucGFzc2VzOyAvLyAvIHRoaXMucGFzc2VzLy9NYXRoLnBvdygxLCB0aGlzLnBhc3Nlcyk7XG5cbiAgICAgICAgaWYgKHRoaXMucGFzc2VzID09PSAxKSB7XG4gICAgICAgICAgICBmaWx0ZXJNYW5hZ2VyLmFwcGx5RmlsdGVyKHRoaXMsIGlucHV0LCBvdXRwdXQsIGNsZWFyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciByZW5kZXJUYXJnZXQgPSBmaWx0ZXJNYW5hZ2VyLmdldFJlbmRlclRhcmdldCh0cnVlKTtcbiAgICAgICAgICAgIHZhciBmbGlwID0gaW5wdXQ7XG4gICAgICAgICAgICB2YXIgZmxvcCA9IHJlbmRlclRhcmdldDtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBhc3NlcyAtIDE7IGkrKykge1xuICAgICAgICAgICAgICAgIGZpbHRlck1hbmFnZXIuYXBwbHlGaWx0ZXIodGhpcywgZmxpcCwgZmxvcCwgdHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICB2YXIgdGVtcCA9IGZsb3A7XG5cbiAgICAgICAgICAgICAgICBmbG9wID0gZmxpcDtcbiAgICAgICAgICAgICAgICBmbGlwID0gdGVtcDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZmlsdGVyTWFuYWdlci5hcHBseUZpbHRlcih0aGlzLCBmbGlwLCBvdXRwdXQsIGNsZWFyKTtcblxuICAgICAgICAgICAgZmlsdGVyTWFuYWdlci5yZXR1cm5SZW5kZXJUYXJnZXQocmVuZGVyVGFyZ2V0KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBzdHJlbmd0aCBvZiBib3RoIHRoZSBibHVyLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDE2XG4gICAgICovXG5cblxuICAgIF9jcmVhdGVDbGFzcyhCbHVyWEZpbHRlciwgW3tcbiAgICAgICAga2V5OiAnYmx1cicsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyZW5ndGg7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlcXVpcmUtanNkb2NcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5wYWRkaW5nID0gTWF0aC5hYnModmFsdWUpICogMjtcbiAgICAgICAgICAgIHRoaXMuc3RyZW5ndGggPSB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAqIFNldHMgdGhlIHF1YWxpdHkgb2YgdGhlIGJsdXIgYnkgbW9kaWZ5aW5nIHRoZSBudW1iZXIgb2YgcGFzc2VzLiBNb3JlIHBhc3NlcyBtZWFucyBoaWdoZXJcbiAgICAgICAgKiBxdWFpbGl0eSBibHVyaW5nIGJ1dCB0aGUgbG93ZXIgdGhlIHBlcmZvcm1hbmNlLlxuICAgICAgICAqXG4gICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAqIEBkZWZhdWx0IDRcbiAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAncXVhbGl0eScsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3F1YWxpdHk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlcXVpcmUtanNkb2NcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fcXVhbGl0eSA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5wYXNzZXMgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBCbHVyWEZpbHRlcjtcbn0oY29yZS5GaWx0ZXIpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBCbHVyWEZpbHRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJsdXJYRmlsdGVyLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9jb3JlID0gcmVxdWlyZSgnLi4vLi4vY29yZScpO1xuXG52YXIgY29yZSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9jb3JlKTtcblxudmFyIF9nZW5lcmF0ZUJsdXJWZXJ0U291cmNlID0gcmVxdWlyZSgnLi9nZW5lcmF0ZUJsdXJWZXJ0U291cmNlJyk7XG5cbnZhciBfZ2VuZXJhdGVCbHVyVmVydFNvdXJjZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZW5lcmF0ZUJsdXJWZXJ0U291cmNlKTtcblxudmFyIF9nZW5lcmF0ZUJsdXJGcmFnU291cmNlID0gcmVxdWlyZSgnLi9nZW5lcmF0ZUJsdXJGcmFnU291cmNlJyk7XG5cbnZhciBfZ2VuZXJhdGVCbHVyRnJhZ1NvdXJjZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZW5lcmF0ZUJsdXJGcmFnU291cmNlKTtcblxudmFyIF9nZXRNYXhCbHVyS2VybmVsU2l6ZSA9IHJlcXVpcmUoJy4vZ2V0TWF4Qmx1cktlcm5lbFNpemUnKTtcblxudmFyIF9nZXRNYXhCbHVyS2VybmVsU2l6ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRNYXhCbHVyS2VybmVsU2l6ZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuLyoqXG4gKiBUaGUgQmx1cllGaWx0ZXIgYXBwbGllcyBhIGhvcml6b250YWwgR2F1c3NpYW4gYmx1ciB0byBhbiBvYmplY3QuXG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQSVhJLkZpbHRlclxuICogQG1lbWJlcm9mIFBJWEkuZmlsdGVyc1xuICovXG52YXIgQmx1cllGaWx0ZXIgPSBmdW5jdGlvbiAoX2NvcmUkRmlsdGVyKSB7XG4gICAgX2luaGVyaXRzKEJsdXJZRmlsdGVyLCBfY29yZSRGaWx0ZXIpO1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0cmVuZ3RoIC0gVGhlIHN0cmVuZ3RoIG9mIHRoZSBibHVyIGZpbHRlci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcXVhbGl0eSAtIFRoZSBxdWFsaXR5IG9mIHRoZSBibHVyIGZpbHRlci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiAtIFRoZSByZXNvbHV0aW9uIG9mIHRoZSBibHVyIGZpbHRlci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2tlcm5lbFNpemU9NV0gLSBUaGUga2VybmVsU2l6ZSBvZiB0aGUgYmx1ciBmaWx0ZXIuT3B0aW9uczogNSwgNywgOSwgMTEsIDEzLCAxNS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBCbHVyWUZpbHRlcihzdHJlbmd0aCwgcXVhbGl0eSwgcmVzb2x1dGlvbiwga2VybmVsU2l6ZSkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQmx1cllGaWx0ZXIpO1xuXG4gICAgICAgIGtlcm5lbFNpemUgPSBrZXJuZWxTaXplIHx8IDU7XG4gICAgICAgIHZhciB2ZXJ0U3JjID0gKDAsIF9nZW5lcmF0ZUJsdXJWZXJ0U291cmNlMi5kZWZhdWx0KShrZXJuZWxTaXplLCBmYWxzZSk7XG4gICAgICAgIHZhciBmcmFnU3JjID0gKDAsIF9nZW5lcmF0ZUJsdXJGcmFnU291cmNlMi5kZWZhdWx0KShrZXJuZWxTaXplKTtcblxuICAgICAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfY29yZSRGaWx0ZXIuY2FsbCh0aGlzLFxuICAgICAgICAvLyB2ZXJ0ZXggc2hhZGVyXG4gICAgICAgIHZlcnRTcmMsXG4gICAgICAgIC8vIGZyYWdtZW50IHNoYWRlclxuICAgICAgICBmcmFnU3JjKSk7XG5cbiAgICAgICAgX3RoaXMucmVzb2x1dGlvbiA9IHJlc29sdXRpb24gfHwgY29yZS5zZXR0aW5ncy5SRVNPTFVUSU9OO1xuXG4gICAgICAgIF90aGlzLl9xdWFsaXR5ID0gMDtcblxuICAgICAgICBfdGhpcy5xdWFsaXR5ID0gcXVhbGl0eSB8fCA0O1xuICAgICAgICBfdGhpcy5zdHJlbmd0aCA9IHN0cmVuZ3RoIHx8IDg7XG5cbiAgICAgICAgX3RoaXMuZmlyc3RSdW4gPSB0cnVlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXBwbGllcyB0aGUgZmlsdGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLkZpbHRlck1hbmFnZXJ9IGZpbHRlck1hbmFnZXIgLSBUaGUgbWFuYWdlci5cbiAgICAgKiBAcGFyYW0ge1BJWEkuUmVuZGVyVGFyZ2V0fSBpbnB1dCAtIFRoZSBpbnB1dCB0YXJnZXQuXG4gICAgICogQHBhcmFtIHtQSVhJLlJlbmRlclRhcmdldH0gb3V0cHV0IC0gVGhlIG91dHB1dCB0YXJnZXQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBjbGVhciAtIFNob3VsZCB0aGUgb3V0cHV0IGJlIGNsZWFyZWQgYmVmb3JlIHJlbmRlcmluZz9cbiAgICAgKi9cblxuXG4gICAgQmx1cllGaWx0ZXIucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24gYXBwbHkoZmlsdGVyTWFuYWdlciwgaW5wdXQsIG91dHB1dCwgY2xlYXIpIHtcbiAgICAgICAgaWYgKHRoaXMuZmlyc3RSdW4pIHtcbiAgICAgICAgICAgIHZhciBnbCA9IGZpbHRlck1hbmFnZXIucmVuZGVyZXIuZ2w7XG4gICAgICAgICAgICB2YXIga2VybmVsU2l6ZSA9ICgwLCBfZ2V0TWF4Qmx1cktlcm5lbFNpemUyLmRlZmF1bHQpKGdsKTtcblxuICAgICAgICAgICAgdGhpcy52ZXJ0ZXhTcmMgPSAoMCwgX2dlbmVyYXRlQmx1clZlcnRTb3VyY2UyLmRlZmF1bHQpKGtlcm5lbFNpemUsIGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMuZnJhZ21lbnRTcmMgPSAoMCwgX2dlbmVyYXRlQmx1ckZyYWdTb3VyY2UyLmRlZmF1bHQpKGtlcm5lbFNpemUpO1xuXG4gICAgICAgICAgICB0aGlzLmZpcnN0UnVuID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnVuaWZvcm1zLnN0cmVuZ3RoID0gMSAvIG91dHB1dC5zaXplLmhlaWdodCAqIChvdXRwdXQuc2l6ZS5oZWlnaHQgLyBpbnB1dC5zaXplLmhlaWdodCk7XG5cbiAgICAgICAgdGhpcy51bmlmb3Jtcy5zdHJlbmd0aCAqPSB0aGlzLnN0cmVuZ3RoO1xuICAgICAgICB0aGlzLnVuaWZvcm1zLnN0cmVuZ3RoIC89IHRoaXMucGFzc2VzO1xuXG4gICAgICAgIGlmICh0aGlzLnBhc3NlcyA9PT0gMSkge1xuICAgICAgICAgICAgZmlsdGVyTWFuYWdlci5hcHBseUZpbHRlcih0aGlzLCBpbnB1dCwgb3V0cHV0LCBjbGVhcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcmVuZGVyVGFyZ2V0ID0gZmlsdGVyTWFuYWdlci5nZXRSZW5kZXJUYXJnZXQodHJ1ZSk7XG4gICAgICAgICAgICB2YXIgZmxpcCA9IGlucHV0O1xuICAgICAgICAgICAgdmFyIGZsb3AgPSByZW5kZXJUYXJnZXQ7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wYXNzZXMgLSAxOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXJNYW5hZ2VyLmFwcGx5RmlsdGVyKHRoaXMsIGZsaXAsIGZsb3AsIHRydWUpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHRlbXAgPSBmbG9wO1xuXG4gICAgICAgICAgICAgICAgZmxvcCA9IGZsaXA7XG4gICAgICAgICAgICAgICAgZmxpcCA9IHRlbXA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZpbHRlck1hbmFnZXIuYXBwbHlGaWx0ZXIodGhpcywgZmxpcCwgb3V0cHV0LCBjbGVhcik7XG5cbiAgICAgICAgICAgIGZpbHRlck1hbmFnZXIucmV0dXJuUmVuZGVyVGFyZ2V0KHJlbmRlclRhcmdldCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgc3RyZW5ndGggb2YgYm90aCB0aGUgYmx1ci5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAyXG4gICAgICovXG5cblxuICAgIF9jcmVhdGVDbGFzcyhCbHVyWUZpbHRlciwgW3tcbiAgICAgICAga2V5OiAnYmx1cicsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyZW5ndGg7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlcXVpcmUtanNkb2NcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5wYWRkaW5nID0gTWF0aC5hYnModmFsdWUpICogMjtcbiAgICAgICAgICAgIHRoaXMuc3RyZW5ndGggPSB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSBxdWFsaXR5IG9mIHRoZSBibHVyIGJ5IG1vZGlmeWluZyB0aGUgbnVtYmVyIG9mIHBhc3Nlcy4gTW9yZSBwYXNzZXMgbWVhbnMgaGlnaGVyXG4gICAgICAgICAqIHF1YWlsaXR5IGJsdXJpbmcgYnV0IHRoZSBsb3dlciB0aGUgcGVyZm9ybWFuY2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgNFxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAncXVhbGl0eScsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3F1YWxpdHk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlcXVpcmUtanNkb2NcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fcXVhbGl0eSA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5wYXNzZXMgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBCbHVyWUZpbHRlcjtcbn0oY29yZS5GaWx0ZXIpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBCbHVyWUZpbHRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJsdXJZRmlsdGVyLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuZGVmYXVsdCA9IGdlbmVyYXRlRnJhZ0JsdXJTb3VyY2U7XG52YXIgR0FVU1NJQU5fVkFMVUVTID0ge1xuICAgIDU6IFswLjE1MzM4OCwgMC4yMjE0NjEsIDAuMjUwMzAxXSxcbiAgICA3OiBbMC4wNzEzMDMsIDAuMTMxNTE0LCAwLjE4OTg3OSwgMC4yMTQ2MDddLFxuICAgIDk6IFswLjAyODUzMiwgMC4wNjcyMzQsIDAuMTI0MDA5LCAwLjE3OTA0NCwgMC4yMDIzNl0sXG4gICAgMTE6IFswLjAwOTMsIDAuMDI4MDAyLCAwLjA2NTk4NCwgMC4xMjE3MDMsIDAuMTc1NzEzLCAwLjE5ODU5Nl0sXG4gICAgMTM6IFswLjAwMjQwNiwgMC4wMDkyNTUsIDAuMDI3ODY3LCAwLjA2NTY2NiwgMC4xMjExMTcsIDAuMTc0ODY4LCAwLjE5NzY0MV0sXG4gICAgMTU6IFswLjAwMDQ4OSwgMC4wMDI0MDMsIDAuMDA5MjQ2LCAwLjAyNzg0LCAwLjA2NTYwMiwgMC4xMjA5OTksIDAuMTc0Njk3LCAwLjE5NzQ0OF1cbn07XG5cbnZhciBmcmFnVGVtcGxhdGUgPSBbJ3ZhcnlpbmcgdmVjMiB2Qmx1clRleENvb3Jkc1slc2l6ZSVdOycsICd1bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjsnLCAndm9pZCBtYWluKHZvaWQpJywgJ3snLCAnICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoMC4wKTsnLCAnICAgICVibHVyJScsICd9J10uam9pbignXFxuJyk7XG5cbmZ1bmN0aW9uIGdlbmVyYXRlRnJhZ0JsdXJTb3VyY2Uoa2VybmVsU2l6ZSkge1xuICAgIHZhciBrZXJuZWwgPSBHQVVTU0lBTl9WQUxVRVNba2VybmVsU2l6ZV07XG4gICAgdmFyIGhhbGZMZW5ndGggPSBrZXJuZWwubGVuZ3RoO1xuXG4gICAgdmFyIGZyYWdTb3VyY2UgPSBmcmFnVGVtcGxhdGU7XG5cbiAgICB2YXIgYmx1ckxvb3AgPSAnJztcbiAgICB2YXIgdGVtcGxhdGUgPSAnZ2xfRnJhZ0NvbG9yICs9IHRleHR1cmUyRCh1U2FtcGxlciwgdkJsdXJUZXhDb29yZHNbJWluZGV4JV0pICogJXZhbHVlJTsnO1xuICAgIHZhciB2YWx1ZSA9IHZvaWQgMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2VybmVsU2l6ZTsgaSsrKSB7XG4gICAgICAgIHZhciBibHVyID0gdGVtcGxhdGUucmVwbGFjZSgnJWluZGV4JScsIGkpO1xuXG4gICAgICAgIHZhbHVlID0gaTtcblxuICAgICAgICBpZiAoaSA+PSBoYWxmTGVuZ3RoKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGtlcm5lbFNpemUgLSBpIC0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJsdXIgPSBibHVyLnJlcGxhY2UoJyV2YWx1ZSUnLCBrZXJuZWxbdmFsdWVdKTtcblxuICAgICAgICBibHVyTG9vcCArPSBibHVyO1xuICAgICAgICBibHVyTG9vcCArPSAnXFxuJztcbiAgICB9XG5cbiAgICBmcmFnU291cmNlID0gZnJhZ1NvdXJjZS5yZXBsYWNlKCclYmx1ciUnLCBibHVyTG9vcCk7XG4gICAgZnJhZ1NvdXJjZSA9IGZyYWdTb3VyY2UucmVwbGFjZSgnJXNpemUlJywga2VybmVsU2l6ZSk7XG5cbiAgICByZXR1cm4gZnJhZ1NvdXJjZTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdlbmVyYXRlQmx1ckZyYWdTb3VyY2UuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5kZWZhdWx0ID0gZ2VuZXJhdGVWZXJ0Qmx1clNvdXJjZTtcbnZhciB2ZXJ0VGVtcGxhdGUgPSBbJ2F0dHJpYnV0ZSB2ZWMyIGFWZXJ0ZXhQb3NpdGlvbjsnLCAnYXR0cmlidXRlIHZlYzIgYVRleHR1cmVDb29yZDsnLCAndW5pZm9ybSBmbG9hdCBzdHJlbmd0aDsnLCAndW5pZm9ybSBtYXQzIHByb2plY3Rpb25NYXRyaXg7JywgJ3ZhcnlpbmcgdmVjMiB2Qmx1clRleENvb3Jkc1slc2l6ZSVdOycsICd2b2lkIG1haW4odm9pZCknLCAneycsICdnbF9Qb3NpdGlvbiA9IHZlYzQoKHByb2plY3Rpb25NYXRyaXggKiB2ZWMzKChhVmVydGV4UG9zaXRpb24pLCAxLjApKS54eSwgMC4wLCAxLjApOycsICclYmx1ciUnLCAnfSddLmpvaW4oJ1xcbicpO1xuXG5mdW5jdGlvbiBnZW5lcmF0ZVZlcnRCbHVyU291cmNlKGtlcm5lbFNpemUsIHgpIHtcbiAgICB2YXIgaGFsZkxlbmd0aCA9IE1hdGguY2VpbChrZXJuZWxTaXplIC8gMik7XG5cbiAgICB2YXIgdmVydFNvdXJjZSA9IHZlcnRUZW1wbGF0ZTtcblxuICAgIHZhciBibHVyTG9vcCA9ICcnO1xuICAgIHZhciB0ZW1wbGF0ZSA9IHZvaWQgMDtcbiAgICAvLyBsZXQgdmFsdWU7XG5cbiAgICBpZiAoeCkge1xuICAgICAgICB0ZW1wbGF0ZSA9ICd2Qmx1clRleENvb3Jkc1slaW5kZXglXSA9IGFUZXh0dXJlQ29vcmQgKyB2ZWMyKCVzYW1wbGVJbmRleCUgKiBzdHJlbmd0aCwgMC4wKTsnO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRlbXBsYXRlID0gJ3ZCbHVyVGV4Q29vcmRzWyVpbmRleCVdID0gYVRleHR1cmVDb29yZCArIHZlYzIoMC4wLCAlc2FtcGxlSW5kZXglICogc3RyZW5ndGgpOyc7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXJuZWxTaXplOyBpKyspIHtcbiAgICAgICAgdmFyIGJsdXIgPSB0ZW1wbGF0ZS5yZXBsYWNlKCclaW5kZXglJywgaSk7XG5cbiAgICAgICAgLy8gdmFsdWUgPSBpO1xuXG4gICAgICAgIC8vIGlmKGkgPj0gaGFsZkxlbmd0aClcbiAgICAgICAgLy8ge1xuICAgICAgICAvLyAgICAgdmFsdWUgPSBrZXJuZWxTaXplIC0gaSAtIDE7XG4gICAgICAgIC8vIH1cblxuICAgICAgICBibHVyID0gYmx1ci5yZXBsYWNlKCclc2FtcGxlSW5kZXglJywgaSAtIChoYWxmTGVuZ3RoIC0gMSkgKyAnLjAnKTtcblxuICAgICAgICBibHVyTG9vcCArPSBibHVyO1xuICAgICAgICBibHVyTG9vcCArPSAnXFxuJztcbiAgICB9XG5cbiAgICB2ZXJ0U291cmNlID0gdmVydFNvdXJjZS5yZXBsYWNlKCclYmx1ciUnLCBibHVyTG9vcCk7XG4gICAgdmVydFNvdXJjZSA9IHZlcnRTb3VyY2UucmVwbGFjZSgnJXNpemUlJywga2VybmVsU2l6ZSk7XG5cbiAgICByZXR1cm4gdmVydFNvdXJjZTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdlbmVyYXRlQmx1clZlcnRTb3VyY2UuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmRlZmF1bHQgPSBnZXRNYXhLZXJuZWxTaXplO1xuZnVuY3Rpb24gZ2V0TWF4S2VybmVsU2l6ZShnbCkge1xuICAgIHZhciBtYXhWYXJ5aW5ncyA9IGdsLmdldFBhcmFtZXRlcihnbC5NQVhfVkFSWUlOR19WRUNUT1JTKTtcbiAgICB2YXIga2VybmVsU2l6ZSA9IDE1O1xuXG4gICAgd2hpbGUgKGtlcm5lbFNpemUgPiBtYXhWYXJ5aW5ncykge1xuICAgICAgICBrZXJuZWxTaXplIC09IDI7XG4gICAgfVxuXG4gICAgcmV0dXJuIGtlcm5lbFNpemU7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXRNYXhCbHVyS2VybmVsU2l6ZS5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfY29yZSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUnKTtcblxudmFyIGNvcmUgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfY29yZSk7XG5cbnZhciBfcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4vKipcbiAqIFRoZSBDb2xvck1hdHJpeEZpbHRlciBjbGFzcyBsZXRzIHlvdSBhcHBseSBhIDV4NCBtYXRyaXggdHJhbnNmb3JtYXRpb24gb24gdGhlIFJHQkFcbiAqIGNvbG9yIGFuZCBhbHBoYSB2YWx1ZXMgb2YgZXZlcnkgcGl4ZWwgb24geW91ciBkaXNwbGF5T2JqZWN0IHRvIHByb2R1Y2UgYSByZXN1bHRcbiAqIHdpdGggYSBuZXcgc2V0IG9mIFJHQkEgY29sb3IgYW5kIGFscGhhIHZhbHVlcy4gSXQncyBwcmV0dHkgcG93ZXJmdWwhXG4gKlxuICogYGBganNcbiAqICBsZXQgY29sb3JNYXRyaXggPSBuZXcgUElYSS5maWx0ZXJzLkNvbG9yTWF0cml4RmlsdGVyKCk7XG4gKiAgY29udGFpbmVyLmZpbHRlcnMgPSBbY29sb3JNYXRyaXhdO1xuICogIGNvbG9yTWF0cml4LmNvbnRyYXN0KDIpO1xuICogYGBgXG4gKiBAYXV0aG9yIENsw6ltZW50IENoZW5lYmF1bHQgPGNsZW1lbnRAZ29vZGJveWRpZ2l0YWwuY29tPlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQSVhJLkZpbHRlclxuICogQG1lbWJlcm9mIFBJWEkuZmlsdGVyc1xuICovXG52YXIgQ29sb3JNYXRyaXhGaWx0ZXIgPSBmdW5jdGlvbiAoX2NvcmUkRmlsdGVyKSB7XG4gICAgX2luaGVyaXRzKENvbG9yTWF0cml4RmlsdGVyLCBfY29yZSRGaWx0ZXIpO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBDb2xvck1hdHJpeEZpbHRlcigpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvbG9yTWF0cml4RmlsdGVyKTtcblxuICAgICAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfY29yZSRGaWx0ZXIuY2FsbCh0aGlzLFxuICAgICAgICAvLyB2ZXJ0ZXggc2hhZGVyXG4gICAgICAgICdhdHRyaWJ1dGUgdmVjMiBhVmVydGV4UG9zaXRpb247XFxuYXR0cmlidXRlIHZlYzIgYVRleHR1cmVDb29yZDtcXG5cXG51bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDtcXG5cXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG5cXG52b2lkIG1haW4odm9pZClcXG57XFxuICAgIGdsX1Bvc2l0aW9uID0gdmVjNCgocHJvamVjdGlvbk1hdHJpeCAqIHZlYzMoYVZlcnRleFBvc2l0aW9uLCAxLjApKS54eSwgMC4wLCAxLjApO1xcbiAgICB2VGV4dHVyZUNvb3JkID0gYVRleHR1cmVDb29yZDtcXG59JyxcbiAgICAgICAgLy8gZnJhZ21lbnQgc2hhZGVyXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG51bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcXG51bmlmb3JtIGZsb2F0IG1bMjBdO1xcbnVuaWZvcm0gZmxvYXQgdUFscGhhO1xcblxcbnZvaWQgbWFpbih2b2lkKVxcbntcXG4gICAgdmVjNCBjID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkKTtcXG5cXG4gICAgaWYgKHVBbHBoYSA9PSAwLjApIHtcXG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IGM7XFxuICAgICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgLy8gVW4tcHJlbXVsdGlwbHkgYWxwaGEgYmVmb3JlIGFwcGx5aW5nIHRoZSBjb2xvciBtYXRyaXguIFNlZSBpc3N1ZSAjMzUzOS5cXG4gICAgaWYgKGMuYSA+IDAuMCkge1xcbiAgICAgIGMucmdiIC89IGMuYTtcXG4gICAgfVxcblxcbiAgICB2ZWM0IHJlc3VsdDtcXG5cXG4gICAgcmVzdWx0LnIgPSAobVswXSAqIGMucik7XFxuICAgICAgICByZXN1bHQuciArPSAobVsxXSAqIGMuZyk7XFxuICAgICAgICByZXN1bHQuciArPSAobVsyXSAqIGMuYik7XFxuICAgICAgICByZXN1bHQuciArPSAobVszXSAqIGMuYSk7XFxuICAgICAgICByZXN1bHQuciArPSBtWzRdO1xcblxcbiAgICByZXN1bHQuZyA9IChtWzVdICogYy5yKTtcXG4gICAgICAgIHJlc3VsdC5nICs9IChtWzZdICogYy5nKTtcXG4gICAgICAgIHJlc3VsdC5nICs9IChtWzddICogYy5iKTtcXG4gICAgICAgIHJlc3VsdC5nICs9IChtWzhdICogYy5hKTtcXG4gICAgICAgIHJlc3VsdC5nICs9IG1bOV07XFxuXFxuICAgIHJlc3VsdC5iID0gKG1bMTBdICogYy5yKTtcXG4gICAgICAgcmVzdWx0LmIgKz0gKG1bMTFdICogYy5nKTtcXG4gICAgICAgcmVzdWx0LmIgKz0gKG1bMTJdICogYy5iKTtcXG4gICAgICAgcmVzdWx0LmIgKz0gKG1bMTNdICogYy5hKTtcXG4gICAgICAgcmVzdWx0LmIgKz0gbVsxNF07XFxuXFxuICAgIHJlc3VsdC5hID0gKG1bMTVdICogYy5yKTtcXG4gICAgICAgcmVzdWx0LmEgKz0gKG1bMTZdICogYy5nKTtcXG4gICAgICAgcmVzdWx0LmEgKz0gKG1bMTddICogYy5iKTtcXG4gICAgICAgcmVzdWx0LmEgKz0gKG1bMThdICogYy5hKTtcXG4gICAgICAgcmVzdWx0LmEgKz0gbVsxOV07XFxuXFxuICAgIHZlYzMgcmdiID0gbWl4KGMucmdiLCByZXN1bHQucmdiLCB1QWxwaGEpO1xcblxcbiAgICAvLyBQcmVtdWx0aXBseSBhbHBoYSBhZ2Fpbi5cXG4gICAgcmdiICo9IHJlc3VsdC5hO1xcblxcbiAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHJnYiwgcmVzdWx0LmEpO1xcbn1cXG4nKSk7XG5cbiAgICAgICAgX3RoaXMudW5pZm9ybXMubSA9IFsxLCAwLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAwLCAxLCAwXTtcblxuICAgICAgICBfdGhpcy5hbHBoYSA9IDE7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm1zIGN1cnJlbnQgbWF0cml4IGFuZCBzZXQgdGhlIG5ldyBvbmVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IG1hdHJpeCAtIDV4NCBtYXRyaXhcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG11bHRpcGx5IC0gaWYgdHJ1ZSwgY3VycmVudCBtYXRyaXggYW5kIG1hdHJpeCBhcmUgbXVsdGlwbGllZC4gSWYgZmFsc2UsXG4gICAgICogIGp1c3Qgc2V0IHRoZSBjdXJyZW50IG1hdHJpeCB3aXRoIEBwYXJhbSBtYXRyaXhcbiAgICAgKi9cblxuXG4gICAgQ29sb3JNYXRyaXhGaWx0ZXIucHJvdG90eXBlLl9sb2FkTWF0cml4ID0gZnVuY3Rpb24gX2xvYWRNYXRyaXgobWF0cml4KSB7XG4gICAgICAgIHZhciBtdWx0aXBseSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG5cbiAgICAgICAgdmFyIG5ld01hdHJpeCA9IG1hdHJpeDtcblxuICAgICAgICBpZiAobXVsdGlwbHkpIHtcbiAgICAgICAgICAgIHRoaXMuX211bHRpcGx5KG5ld01hdHJpeCwgdGhpcy51bmlmb3Jtcy5tLCBtYXRyaXgpO1xuICAgICAgICAgICAgbmV3TWF0cml4ID0gdGhpcy5fY29sb3JNYXRyaXgobmV3TWF0cml4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNldCB0aGUgbmV3IG1hdHJpeFxuICAgICAgICB0aGlzLnVuaWZvcm1zLm0gPSBuZXdNYXRyaXg7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIE11bHRpcGxpZXMgdHdvIG1hdDUnc1xuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBvdXQgLSA1eDQgbWF0cml4IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gYSAtIDV4NCBtYXRyaXggdGhlIGZpcnN0IG9wZXJhbmRcbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBiIC0gNXg0IG1hdHJpeCB0aGUgc2Vjb25kIG9wZXJhbmRcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyW119IDV4NCBtYXRyaXhcbiAgICAgKi9cblxuXG4gICAgQ29sb3JNYXRyaXhGaWx0ZXIucHJvdG90eXBlLl9tdWx0aXBseSA9IGZ1bmN0aW9uIF9tdWx0aXBseShvdXQsIGEsIGIpIHtcbiAgICAgICAgLy8gUmVkIENoYW5uZWxcbiAgICAgICAgb3V0WzBdID0gYVswXSAqIGJbMF0gKyBhWzFdICogYls1XSArIGFbMl0gKiBiWzEwXSArIGFbM10gKiBiWzE1XTtcbiAgICAgICAgb3V0WzFdID0gYVswXSAqIGJbMV0gKyBhWzFdICogYls2XSArIGFbMl0gKiBiWzExXSArIGFbM10gKiBiWzE2XTtcbiAgICAgICAgb3V0WzJdID0gYVswXSAqIGJbMl0gKyBhWzFdICogYls3XSArIGFbMl0gKiBiWzEyXSArIGFbM10gKiBiWzE3XTtcbiAgICAgICAgb3V0WzNdID0gYVswXSAqIGJbM10gKyBhWzFdICogYls4XSArIGFbMl0gKiBiWzEzXSArIGFbM10gKiBiWzE4XTtcbiAgICAgICAgb3V0WzRdID0gYVswXSAqIGJbNF0gKyBhWzFdICogYls5XSArIGFbMl0gKiBiWzE0XSArIGFbM10gKiBiWzE5XSArIGFbNF07XG5cbiAgICAgICAgLy8gR3JlZW4gQ2hhbm5lbFxuICAgICAgICBvdXRbNV0gPSBhWzVdICogYlswXSArIGFbNl0gKiBiWzVdICsgYVs3XSAqIGJbMTBdICsgYVs4XSAqIGJbMTVdO1xuICAgICAgICBvdXRbNl0gPSBhWzVdICogYlsxXSArIGFbNl0gKiBiWzZdICsgYVs3XSAqIGJbMTFdICsgYVs4XSAqIGJbMTZdO1xuICAgICAgICBvdXRbN10gPSBhWzVdICogYlsyXSArIGFbNl0gKiBiWzddICsgYVs3XSAqIGJbMTJdICsgYVs4XSAqIGJbMTddO1xuICAgICAgICBvdXRbOF0gPSBhWzVdICogYlszXSArIGFbNl0gKiBiWzhdICsgYVs3XSAqIGJbMTNdICsgYVs4XSAqIGJbMThdO1xuICAgICAgICBvdXRbOV0gPSBhWzVdICogYls0XSArIGFbNl0gKiBiWzldICsgYVs3XSAqIGJbMTRdICsgYVs4XSAqIGJbMTldICsgYVs5XTtcblxuICAgICAgICAvLyBCbHVlIENoYW5uZWxcbiAgICAgICAgb3V0WzEwXSA9IGFbMTBdICogYlswXSArIGFbMTFdICogYls1XSArIGFbMTJdICogYlsxMF0gKyBhWzEzXSAqIGJbMTVdO1xuICAgICAgICBvdXRbMTFdID0gYVsxMF0gKiBiWzFdICsgYVsxMV0gKiBiWzZdICsgYVsxMl0gKiBiWzExXSArIGFbMTNdICogYlsxNl07XG4gICAgICAgIG91dFsxMl0gPSBhWzEwXSAqIGJbMl0gKyBhWzExXSAqIGJbN10gKyBhWzEyXSAqIGJbMTJdICsgYVsxM10gKiBiWzE3XTtcbiAgICAgICAgb3V0WzEzXSA9IGFbMTBdICogYlszXSArIGFbMTFdICogYls4XSArIGFbMTJdICogYlsxM10gKyBhWzEzXSAqIGJbMThdO1xuICAgICAgICBvdXRbMTRdID0gYVsxMF0gKiBiWzRdICsgYVsxMV0gKiBiWzldICsgYVsxMl0gKiBiWzE0XSArIGFbMTNdICogYlsxOV0gKyBhWzE0XTtcblxuICAgICAgICAvLyBBbHBoYSBDaGFubmVsXG4gICAgICAgIG91dFsxNV0gPSBhWzE1XSAqIGJbMF0gKyBhWzE2XSAqIGJbNV0gKyBhWzE3XSAqIGJbMTBdICsgYVsxOF0gKiBiWzE1XTtcbiAgICAgICAgb3V0WzE2XSA9IGFbMTVdICogYlsxXSArIGFbMTZdICogYls2XSArIGFbMTddICogYlsxMV0gKyBhWzE4XSAqIGJbMTZdO1xuICAgICAgICBvdXRbMTddID0gYVsxNV0gKiBiWzJdICsgYVsxNl0gKiBiWzddICsgYVsxN10gKiBiWzEyXSArIGFbMThdICogYlsxN107XG4gICAgICAgIG91dFsxOF0gPSBhWzE1XSAqIGJbM10gKyBhWzE2XSAqIGJbOF0gKyBhWzE3XSAqIGJbMTNdICsgYVsxOF0gKiBiWzE4XTtcbiAgICAgICAgb3V0WzE5XSA9IGFbMTVdICogYls0XSArIGFbMTZdICogYls5XSArIGFbMTddICogYlsxNF0gKyBhWzE4XSAqIGJbMTldICsgYVsxOV07XG5cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgRmxvYXQzMiBBcnJheSBhbmQgbm9ybWFsaXplIHRoZSBvZmZzZXQgY29tcG9uZW50IHRvIDAtMVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBtYXRyaXggLSA1eDQgbWF0cml4XG4gICAgICogQHJldHVybiB7bnVtYmVyW119IDV4NCBtYXRyaXggd2l0aCBhbGwgdmFsdWVzIGJldHdlZW4gMC0xXG4gICAgICovXG5cblxuICAgIENvbG9yTWF0cml4RmlsdGVyLnByb3RvdHlwZS5fY29sb3JNYXRyaXggPSBmdW5jdGlvbiBfY29sb3JNYXRyaXgobWF0cml4KSB7XG4gICAgICAgIC8vIENyZWF0ZSBhIEZsb2F0MzIgQXJyYXkgYW5kIG5vcm1hbGl6ZSB0aGUgb2Zmc2V0IGNvbXBvbmVudCB0byAwLTFcbiAgICAgICAgdmFyIG0gPSBuZXcgRmxvYXQzMkFycmF5KG1hdHJpeCk7XG5cbiAgICAgICAgbVs0XSAvPSAyNTU7XG4gICAgICAgIG1bOV0gLz0gMjU1O1xuICAgICAgICBtWzE0XSAvPSAyNTU7XG4gICAgICAgIG1bMTldIC89IDI1NTtcblxuICAgICAgICByZXR1cm4gbTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQWRqdXN0cyBicmlnaHRuZXNzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYiAtIHZhbHVlIG9mIHRoZSBicmlndGhuZXNzICgwLTEsIHdoZXJlIDAgaXMgYmxhY2spXG4gICAgICogQHBhcmFtIHtib29sZWFufSBtdWx0aXBseSAtIGlmIHRydWUsIGN1cnJlbnQgbWF0cml4IGFuZCBtYXRyaXggYXJlIG11bHRpcGxpZWQuIElmIGZhbHNlLFxuICAgICAqICBqdXN0IHNldCB0aGUgY3VycmVudCBtYXRyaXggd2l0aCBAcGFyYW0gbWF0cml4XG4gICAgICovXG5cblxuICAgIENvbG9yTWF0cml4RmlsdGVyLnByb3RvdHlwZS5icmlnaHRuZXNzID0gZnVuY3Rpb24gYnJpZ2h0bmVzcyhiLCBtdWx0aXBseSkge1xuICAgICAgICB2YXIgbWF0cml4ID0gW2IsIDAsIDAsIDAsIDAsIDAsIGIsIDAsIDAsIDAsIDAsIDAsIGIsIDAsIDAsIDAsIDAsIDAsIDEsIDBdO1xuXG4gICAgICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgbWF0cmljZXMgaW4gZ3JleSBzY2FsZXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsZSAtIHZhbHVlIG9mIHRoZSBncmV5ICgwLTEsIHdoZXJlIDAgaXMgYmxhY2spXG4gICAgICogQHBhcmFtIHtib29sZWFufSBtdWx0aXBseSAtIGlmIHRydWUsIGN1cnJlbnQgbWF0cml4IGFuZCBtYXRyaXggYXJlIG11bHRpcGxpZWQuIElmIGZhbHNlLFxuICAgICAqICBqdXN0IHNldCB0aGUgY3VycmVudCBtYXRyaXggd2l0aCBAcGFyYW0gbWF0cml4XG4gICAgICovXG5cblxuICAgIENvbG9yTWF0cml4RmlsdGVyLnByb3RvdHlwZS5ncmV5c2NhbGUgPSBmdW5jdGlvbiBncmV5c2NhbGUoc2NhbGUsIG11bHRpcGx5KSB7XG4gICAgICAgIHZhciBtYXRyaXggPSBbc2NhbGUsIHNjYWxlLCBzY2FsZSwgMCwgMCwgc2NhbGUsIHNjYWxlLCBzY2FsZSwgMCwgMCwgc2NhbGUsIHNjYWxlLCBzY2FsZSwgMCwgMCwgMCwgMCwgMCwgMSwgMF07XG5cbiAgICAgICAgdGhpcy5fbG9hZE1hdHJpeChtYXRyaXgsIG11bHRpcGx5KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBibGFjayBhbmQgd2hpdGUgbWF0cmljZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gbXVsdGlwbHkgLSBpZiB0cnVlLCBjdXJyZW50IG1hdHJpeCBhbmQgbWF0cml4IGFyZSBtdWx0aXBsaWVkLiBJZiBmYWxzZSxcbiAgICAgKiAganVzdCBzZXQgdGhlIGN1cnJlbnQgbWF0cml4IHdpdGggQHBhcmFtIG1hdHJpeFxuICAgICAqL1xuXG5cbiAgICBDb2xvck1hdHJpeEZpbHRlci5wcm90b3R5cGUuYmxhY2tBbmRXaGl0ZSA9IGZ1bmN0aW9uIGJsYWNrQW5kV2hpdGUobXVsdGlwbHkpIHtcbiAgICAgICAgdmFyIG1hdHJpeCA9IFswLjMsIDAuNiwgMC4xLCAwLCAwLCAwLjMsIDAuNiwgMC4xLCAwLCAwLCAwLjMsIDAuNiwgMC4xLCAwLCAwLCAwLCAwLCAwLCAxLCAwXTtcblxuICAgICAgICB0aGlzLl9sb2FkTWF0cml4KG1hdHJpeCwgbXVsdGlwbHkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGh1ZSBwcm9wZXJ0eSBvZiB0aGUgY29sb3JcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByb3RhdGlvbiAtIGluIGRlZ3JlZXNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG11bHRpcGx5IC0gaWYgdHJ1ZSwgY3VycmVudCBtYXRyaXggYW5kIG1hdHJpeCBhcmUgbXVsdGlwbGllZC4gSWYgZmFsc2UsXG4gICAgICogIGp1c3Qgc2V0IHRoZSBjdXJyZW50IG1hdHJpeCB3aXRoIEBwYXJhbSBtYXRyaXhcbiAgICAgKi9cblxuXG4gICAgQ29sb3JNYXRyaXhGaWx0ZXIucHJvdG90eXBlLmh1ZSA9IGZ1bmN0aW9uIGh1ZShyb3RhdGlvbiwgbXVsdGlwbHkpIHtcbiAgICAgICAgcm90YXRpb24gPSAocm90YXRpb24gfHwgMCkgLyAxODAgKiBNYXRoLlBJO1xuXG4gICAgICAgIHZhciBjb3NSID0gTWF0aC5jb3Mocm90YXRpb24pO1xuICAgICAgICB2YXIgc2luUiA9IE1hdGguc2luKHJvdGF0aW9uKTtcbiAgICAgICAgdmFyIHNxcnQgPSBNYXRoLnNxcnQ7XG5cbiAgICAgICAgLyogYSBnb29kIGFwcHJveGltYXRpb24gZm9yIGh1ZSByb3RhdGlvblxuICAgICAgICAgVGhpcyBtYXRyaXggaXMgZmFyIGJldHRlciB0aGFuIHRoZSB2ZXJzaW9ucyB3aXRoIG1hZ2ljIGx1bWluYW5jZSBjb25zdGFudHNcbiAgICAgICAgIGZvcm1lcmx5IHVzZWQgaGVyZSwgYnV0IGFsc28gdXNlZCBpbiB0aGUgc3RhcmxpbmcgZnJhbWV3b3JrIChmbGFzaCkgYW5kIGtub3duIGZyb20gdGhpc1xuICAgICAgICAgb2xkIHBhcnQgb2YgdGhlIGludGVybmV0OiBxdWFzaW1vbmRvLmNvbS9hcmNoaXZlcy8wMDA1NjUucGhwXG4gICAgICAgICAgVGhpcyBuZXcgbWF0cml4IGlzIGJhc2VkIG9uIHJnYiBjdWJlIHJvdGF0aW9uIGluIHNwYWNlLiBMb29rIGhlcmUgZm9yIGEgbW9yZSBkZXNjcmlwdGl2ZVxuICAgICAgICAgaW1wbGVtZW50YXRpb24gYXMgYSBzaGFkZXIgbm90IGEgZ2VuZXJhbCBtYXRyaXg6XG4gICAgICAgICBodHRwczovL2dpdGh1Yi5jb20vZXZhbncvZ2xmeC5qcy9ibG9iLzU4ODQxYzIzOTE5YmQ1OTc4N2VmZmMwMzMzYTQ4OTdiNDM4MzU0MTIvc3JjL2ZpbHRlcnMvYWRqdXN0L2h1ZXNhdHVyYXRpb24uanNcbiAgICAgICAgICBUaGlzIGlzIHRoZSBzb3VyY2UgZm9yIHRoZSBjb2RlOlxuICAgICAgICAgc2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvODUwNzg4NS9zaGlmdC1odWUtb2YtYW4tcmdiLWNvbG9yLzg1MTA3NTEjODUxMDc1MVxuICAgICAgICAgKi9cblxuICAgICAgICB2YXIgdyA9IDEgLyAzO1xuICAgICAgICB2YXIgc3FyVyA9IHNxcnQodyk7IC8vIHdlaWdodCBpc1xuXG4gICAgICAgIHZhciBhMDAgPSBjb3NSICsgKDEuMCAtIGNvc1IpICogdztcbiAgICAgICAgdmFyIGEwMSA9IHcgKiAoMS4wIC0gY29zUikgLSBzcXJXICogc2luUjtcbiAgICAgICAgdmFyIGEwMiA9IHcgKiAoMS4wIC0gY29zUikgKyBzcXJXICogc2luUjtcblxuICAgICAgICB2YXIgYTEwID0gdyAqICgxLjAgLSBjb3NSKSArIHNxclcgKiBzaW5SO1xuICAgICAgICB2YXIgYTExID0gY29zUiArIHcgKiAoMS4wIC0gY29zUik7XG4gICAgICAgIHZhciBhMTIgPSB3ICogKDEuMCAtIGNvc1IpIC0gc3FyVyAqIHNpblI7XG5cbiAgICAgICAgdmFyIGEyMCA9IHcgKiAoMS4wIC0gY29zUikgLSBzcXJXICogc2luUjtcbiAgICAgICAgdmFyIGEyMSA9IHcgKiAoMS4wIC0gY29zUikgKyBzcXJXICogc2luUjtcbiAgICAgICAgdmFyIGEyMiA9IGNvc1IgKyB3ICogKDEuMCAtIGNvc1IpO1xuXG4gICAgICAgIHZhciBtYXRyaXggPSBbYTAwLCBhMDEsIGEwMiwgMCwgMCwgYTEwLCBhMTEsIGExMiwgMCwgMCwgYTIwLCBhMjEsIGEyMiwgMCwgMCwgMCwgMCwgMCwgMSwgMF07XG5cbiAgICAgICAgdGhpcy5fbG9hZE1hdHJpeChtYXRyaXgsIG11bHRpcGx5KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBjb250cmFzdCBtYXRyaXgsIGluY3JlYXNlIHRoZSBzZXBhcmF0aW9uIGJldHdlZW4gZGFyayBhbmQgYnJpZ2h0XG4gICAgICogSW5jcmVhc2UgY29udHJhc3QgOiBzaGFkb3dzIGRhcmtlciBhbmQgaGlnaGxpZ2h0cyBicmlnaHRlclxuICAgICAqIERlY3JlYXNlIGNvbnRyYXN0IDogYnJpbmcgdGhlIHNoYWRvd3MgdXAgYW5kIHRoZSBoaWdobGlnaHRzIGRvd25cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbW91bnQgLSB2YWx1ZSBvZiB0aGUgY29udHJhc3QgKDAtMSlcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG11bHRpcGx5IC0gaWYgdHJ1ZSwgY3VycmVudCBtYXRyaXggYW5kIG1hdHJpeCBhcmUgbXVsdGlwbGllZC4gSWYgZmFsc2UsXG4gICAgICogIGp1c3Qgc2V0IHRoZSBjdXJyZW50IG1hdHJpeCB3aXRoIEBwYXJhbSBtYXRyaXhcbiAgICAgKi9cblxuXG4gICAgQ29sb3JNYXRyaXhGaWx0ZXIucHJvdG90eXBlLmNvbnRyYXN0ID0gZnVuY3Rpb24gY29udHJhc3QoYW1vdW50LCBtdWx0aXBseSkge1xuICAgICAgICB2YXIgdiA9IChhbW91bnQgfHwgMCkgKyAxO1xuICAgICAgICB2YXIgbyA9IC0wLjUgKiAodiAtIDEpO1xuXG4gICAgICAgIHZhciBtYXRyaXggPSBbdiwgMCwgMCwgMCwgbywgMCwgdiwgMCwgMCwgbywgMCwgMCwgdiwgMCwgbywgMCwgMCwgMCwgMSwgMF07XG5cbiAgICAgICAgdGhpcy5fbG9hZE1hdHJpeChtYXRyaXgsIG11bHRpcGx5KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBzYXR1cmF0aW9uIG1hdHJpeCwgaW5jcmVhc2UgdGhlIHNlcGFyYXRpb24gYmV0d2VlbiBjb2xvcnNcbiAgICAgKiBJbmNyZWFzZSBzYXR1cmF0aW9uIDogaW5jcmVhc2UgY29udHJhc3QsIGJyaWdodG5lc3MsIGFuZCBzaGFycG5lc3NcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbW91bnQgLSBUaGUgc2F0dXJhdGlvbiBhbW91bnQgKDAtMSlcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG11bHRpcGx5IC0gaWYgdHJ1ZSwgY3VycmVudCBtYXRyaXggYW5kIG1hdHJpeCBhcmUgbXVsdGlwbGllZC4gSWYgZmFsc2UsXG4gICAgICogIGp1c3Qgc2V0IHRoZSBjdXJyZW50IG1hdHJpeCB3aXRoIEBwYXJhbSBtYXRyaXhcbiAgICAgKi9cblxuXG4gICAgQ29sb3JNYXRyaXhGaWx0ZXIucHJvdG90eXBlLnNhdHVyYXRlID0gZnVuY3Rpb24gc2F0dXJhdGUoKSB7XG4gICAgICAgIHZhciBhbW91bnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG4gICAgICAgIHZhciBtdWx0aXBseSA9IGFyZ3VtZW50c1sxXTtcblxuICAgICAgICB2YXIgeCA9IGFtb3VudCAqIDIgLyAzICsgMTtcbiAgICAgICAgdmFyIHkgPSAoeCAtIDEpICogLTAuNTtcblxuICAgICAgICB2YXIgbWF0cml4ID0gW3gsIHksIHksIDAsIDAsIHksIHgsIHksIDAsIDAsIHksIHksIHgsIDAsIDAsIDAsIDAsIDAsIDEsIDBdO1xuXG4gICAgICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERlc2F0dXJhdGUgaW1hZ2UgKHJlbW92ZSBjb2xvcilcbiAgICAgKlxuICAgICAqIENhbGwgdGhlIHNhdHVyYXRlIGZ1bmN0aW9uXG4gICAgICpcbiAgICAgKi9cblxuXG4gICAgQ29sb3JNYXRyaXhGaWx0ZXIucHJvdG90eXBlLmRlc2F0dXJhdGUgPSBmdW5jdGlvbiBkZXNhdHVyYXRlKCkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIHtcbiAgICAgICAgdGhpcy5zYXR1cmF0ZSgtMSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIE5lZ2F0aXZlIGltYWdlIChpbnZlcnNlIG9mIGNsYXNzaWMgcmdiIG1hdHJpeClcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gbXVsdGlwbHkgLSBpZiB0cnVlLCBjdXJyZW50IG1hdHJpeCBhbmQgbWF0cml4IGFyZSBtdWx0aXBsaWVkLiBJZiBmYWxzZSxcbiAgICAgKiAganVzdCBzZXQgdGhlIGN1cnJlbnQgbWF0cml4IHdpdGggQHBhcmFtIG1hdHJpeFxuICAgICAqL1xuXG5cbiAgICBDb2xvck1hdHJpeEZpbHRlci5wcm90b3R5cGUubmVnYXRpdmUgPSBmdW5jdGlvbiBuZWdhdGl2ZShtdWx0aXBseSkge1xuICAgICAgICB2YXIgbWF0cml4ID0gWy0xLCAwLCAwLCAxLCAwLCAwLCAtMSwgMCwgMSwgMCwgMCwgMCwgLTEsIDEsIDAsIDAsIDAsIDAsIDEsIDBdO1xuXG4gICAgICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNlcGlhIGltYWdlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG11bHRpcGx5IC0gaWYgdHJ1ZSwgY3VycmVudCBtYXRyaXggYW5kIG1hdHJpeCBhcmUgbXVsdGlwbGllZC4gSWYgZmFsc2UsXG4gICAgICogIGp1c3Qgc2V0IHRoZSBjdXJyZW50IG1hdHJpeCB3aXRoIEBwYXJhbSBtYXRyaXhcbiAgICAgKi9cblxuXG4gICAgQ29sb3JNYXRyaXhGaWx0ZXIucHJvdG90eXBlLnNlcGlhID0gZnVuY3Rpb24gc2VwaWEobXVsdGlwbHkpIHtcbiAgICAgICAgdmFyIG1hdHJpeCA9IFswLjM5MywgMC43Njg5OTk5LCAwLjE4ODk5OTk5LCAwLCAwLCAwLjM0OSwgMC42ODU5OTk5LCAwLjE2Nzk5OTk5LCAwLCAwLCAwLjI3MiwgMC41MzM5OTk5LCAwLjEzMDk5OTk5LCAwLCAwLCAwLCAwLCAwLCAxLCAwXTtcblxuICAgICAgICB0aGlzLl9sb2FkTWF0cml4KG1hdHJpeCwgbXVsdGlwbHkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDb2xvciBtb3Rpb24gcGljdHVyZSBwcm9jZXNzIGludmVudGVkIGluIDE5MTYgKHRoYW5rcyBEb21pbmljIFN6YWJsZXdza2kpXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG11bHRpcGx5IC0gaWYgdHJ1ZSwgY3VycmVudCBtYXRyaXggYW5kIG1hdHJpeCBhcmUgbXVsdGlwbGllZC4gSWYgZmFsc2UsXG4gICAgICogIGp1c3Qgc2V0IHRoZSBjdXJyZW50IG1hdHJpeCB3aXRoIEBwYXJhbSBtYXRyaXhcbiAgICAgKi9cblxuXG4gICAgQ29sb3JNYXRyaXhGaWx0ZXIucHJvdG90eXBlLnRlY2huaWNvbG9yID0gZnVuY3Rpb24gdGVjaG5pY29sb3IobXVsdGlwbHkpIHtcbiAgICAgICAgdmFyIG1hdHJpeCA9IFsxLjkxMjUyNzc4OTE0NTYwODMsIC0wLjg1NDUzNDQ5NzY5NTE2NDUsIC0wLjA5MTU1NTA4NDgyNzU1NTg1LCAwLCAxMS43OTM2MDM0MzQzNzczMzcsIC0wLjMwODc4MzMzODU5MjgwOTcsIDEuNzY1ODkwODU1NTQ1ODQyOCwgLTAuMTA2MDE3NDMwNzQ3MjIyNDUsIDAsIC03MC4zNTIwNTE2MTQ2MTM5OCwgLTAuMjMxMTAzMzc3NTQ4NjE2LCAtMC43NTAxODk5MTk3NDQwMjEyLCAxLjg0NzU5NzgxNjEwODE4OSwgMCwgMzAuOTUwOTQwODY5NDkxMTM4LCAwLCAwLCAwLCAxLCAwXTtcblxuICAgICAgICB0aGlzLl9sb2FkTWF0cml4KG1hdHJpeCwgbXVsdGlwbHkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBQb2xhcm9pZCBmaWx0ZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gbXVsdGlwbHkgLSBpZiB0cnVlLCBjdXJyZW50IG1hdHJpeCBhbmQgbWF0cml4IGFyZSBtdWx0aXBsaWVkLiBJZiBmYWxzZSxcbiAgICAgKiAganVzdCBzZXQgdGhlIGN1cnJlbnQgbWF0cml4IHdpdGggQHBhcmFtIG1hdHJpeFxuICAgICAqL1xuXG5cbiAgICBDb2xvck1hdHJpeEZpbHRlci5wcm90b3R5cGUucG9sYXJvaWQgPSBmdW5jdGlvbiBwb2xhcm9pZChtdWx0aXBseSkge1xuICAgICAgICB2YXIgbWF0cml4ID0gWzEuNDM4LCAtMC4wNjIsIC0wLjA2MiwgMCwgMCwgLTAuMTIyLCAxLjM3OCwgLTAuMTIyLCAwLCAwLCAtMC4wMTYsIC0wLjAxNiwgMS40ODMsIDAsIDAsIDAsIDAsIDAsIDEsIDBdO1xuXG4gICAgICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEZpbHRlciB3aG8gdHJhbnNmb3JtcyA6IFJlZCAtPiBCbHVlIGFuZCBCbHVlIC0+IFJlZFxuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sZWFufSBtdWx0aXBseSAtIGlmIHRydWUsIGN1cnJlbnQgbWF0cml4IGFuZCBtYXRyaXggYXJlIG11bHRpcGxpZWQuIElmIGZhbHNlLFxuICAgICAqICBqdXN0IHNldCB0aGUgY3VycmVudCBtYXRyaXggd2l0aCBAcGFyYW0gbWF0cml4XG4gICAgICovXG5cblxuICAgIENvbG9yTWF0cml4RmlsdGVyLnByb3RvdHlwZS50b0JHUiA9IGZ1bmN0aW9uIHRvQkdSKG11bHRpcGx5KSB7XG4gICAgICAgIHZhciBtYXRyaXggPSBbMCwgMCwgMSwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMSwgMF07XG5cbiAgICAgICAgdGhpcy5fbG9hZE1hdHJpeChtYXRyaXgsIG11bHRpcGx5KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ29sb3IgcmV2ZXJzYWwgZmlsbSBpbnRyb2R1Y2VkIGJ5IEVhc3RtYW4gS29kYWsgaW4gMTkzNS4gKHRoYW5rcyBEb21pbmljIFN6YWJsZXdza2kpXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG11bHRpcGx5IC0gaWYgdHJ1ZSwgY3VycmVudCBtYXRyaXggYW5kIG1hdHJpeCBhcmUgbXVsdGlwbGllZC4gSWYgZmFsc2UsXG4gICAgICogIGp1c3Qgc2V0IHRoZSBjdXJyZW50IG1hdHJpeCB3aXRoIEBwYXJhbSBtYXRyaXhcbiAgICAgKi9cblxuXG4gICAgQ29sb3JNYXRyaXhGaWx0ZXIucHJvdG90eXBlLmtvZGFjaHJvbWUgPSBmdW5jdGlvbiBrb2RhY2hyb21lKG11bHRpcGx5KSB7XG4gICAgICAgIHZhciBtYXRyaXggPSBbMS4xMjg1NTgyMzk2NTkzNTI1LCAtMC4zOTY3MzgyMjgzNjAxMzQ4LCAtMC4wMzk5MjU1OTE3MjkyMTc5MywgMCwgNjMuNzI5NTg3NjIxOTY1MDIsIC0wLjE2NDA0MzM5OTYyMjQ0NjE2LCAxLjA4MzUyNTE1NjYyOTEzMDQsIC0wLjA1NDk4ODA1MTE1NjMzMTMyLCAwLCAyNC43MzI0MDc4OTY3MDYyMDMsIC0wLjE2Nzg2MDEwNzA2MTU1NzYzLCAtMC41NjAzNDE2Mjc3Njk1MjQ4LCAxLjYwMTQ4NTA3NjE5NjQ5NDMsIDAsIDM1LjYyOTgyODA3NDYwOTQ2LCAwLCAwLCAwLCAxLCAwXTtcblxuICAgICAgICB0aGlzLl9sb2FkTWF0cml4KG1hdHJpeCwgbXVsdGlwbHkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBCcm93biBkZWxpY2lvdXMgYnJvd25pIGZpbHRlciAodGhhbmtzIERvbWluaWMgU3phYmxld3NraSlcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gbXVsdGlwbHkgLSBpZiB0cnVlLCBjdXJyZW50IG1hdHJpeCBhbmQgbWF0cml4IGFyZSBtdWx0aXBsaWVkLiBJZiBmYWxzZSxcbiAgICAgKiAganVzdCBzZXQgdGhlIGN1cnJlbnQgbWF0cml4IHdpdGggQHBhcmFtIG1hdHJpeFxuICAgICAqL1xuXG5cbiAgICBDb2xvck1hdHJpeEZpbHRlci5wcm90b3R5cGUuYnJvd25pID0gZnVuY3Rpb24gYnJvd25pKG11bHRpcGx5KSB7XG4gICAgICAgIHZhciBtYXRyaXggPSBbMC41OTk3MDIzNDk4MTU5NzE1LCAwLjM0NTUzMjQzMDQ4MzkxMjYzLCAtMC4yNzA4Mjk4Njc0NTM4MDQyLCAwLCA0Ny40MzE5Mjg1NTYwMDg3MywgLTAuMDM3NzAzMjQ5ODM3NzgzMTU3LCAwLjg2MDk1Nzc1ODc5OTI2NDEsIDAuMTUwNTk1NTIzODg0NTk5MTMsIDAsIC0zNi45Njg0MTQ5ODMxOTEyNywgMC4yNDExMzYzNTEyODE1MzMzNSwgLTAuMDc0NDEwMzc5MDg0MjI0OTIsIDAuNDQ5NzIxODIwNjQ4NzcxNTMsIDAsIC03LjU2MjA3NTI3NzU5MTI4MywgMCwgMCwgMCwgMSwgMF07XG5cbiAgICAgICAgdGhpcy5fbG9hZE1hdHJpeChtYXRyaXgsIG11bHRpcGx5KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVmludGFnZSBmaWx0ZXIgKHRoYW5rcyBEb21pbmljIFN6YWJsZXdza2kpXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG11bHRpcGx5IC0gaWYgdHJ1ZSwgY3VycmVudCBtYXRyaXggYW5kIG1hdHJpeCBhcmUgbXVsdGlwbGllZC4gSWYgZmFsc2UsXG4gICAgICogIGp1c3Qgc2V0IHRoZSBjdXJyZW50IG1hdHJpeCB3aXRoIEBwYXJhbSBtYXRyaXhcbiAgICAgKi9cblxuXG4gICAgQ29sb3JNYXRyaXhGaWx0ZXIucHJvdG90eXBlLnZpbnRhZ2UgPSBmdW5jdGlvbiB2aW50YWdlKG11bHRpcGx5KSB7XG4gICAgICAgIHZhciBtYXRyaXggPSBbMC42Mjc5MzQ1NjM1NjA1OTk0LCAwLjMyMDIxODM0MjA4MTkzNjcsIC0wLjAzOTY1NDA4MjExMzEyNDUzLCAwLCA5LjY1MTI4NTgzNTI5NDEyMywgMC4wMjU3ODM5NzcwNDgwODg2OCwgMC42NDQxMTg4NjQ0Mzc0NzcxLCAwLjAzMjU5MTI3NjE2MTQ5Mjk0LCAwLCA3LjQ2MjgyOTE3NjQ3MDU5MSwgMC4wNDY2MDU1NTU2NzgyNzE5LCAtMC4wODUxMjMyOTg3MjQ3ODkxLCAwLjUyNDE2NDgwMTg3MDA0NjUsIDAsIDUuMTU5MTkwNTg4MjM1Mjk2LCAwLCAwLCAwLCAxLCAwXTtcblxuICAgICAgICB0aGlzLl9sb2FkTWF0cml4KG1hdHJpeCwgbXVsdGlwbHkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBXZSBkb24ndCBrbm93IGV4YWN0bHkgd2hhdCBpdCBkb2VzLCBraW5kIG9mIGdyYWRpZW50IG1hcCwgYnV0IGZ1bm55IHRvIHBsYXkgd2l0aCFcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZXNhdHVyYXRpb24gLSBUb25lIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdG9uZWQgLSBUb25lIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGlnaHRDb2xvciAtIFRvbmUgdmFsdWVzLCBleGFtcGxlOiBgMHhGRkU1ODBgXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRhcmtDb2xvciAtIFRvbmUgdmFsdWVzLCBleGFtcGxlOiBgMHhGRkU1ODBgXG4gICAgICogQHBhcmFtIHtib29sZWFufSBtdWx0aXBseSAtIGlmIHRydWUsIGN1cnJlbnQgbWF0cml4IGFuZCBtYXRyaXggYXJlIG11bHRpcGxpZWQuIElmIGZhbHNlLFxuICAgICAqICBqdXN0IHNldCB0aGUgY3VycmVudCBtYXRyaXggd2l0aCBAcGFyYW0gbWF0cml4XG4gICAgICovXG5cblxuICAgIENvbG9yTWF0cml4RmlsdGVyLnByb3RvdHlwZS5jb2xvclRvbmUgPSBmdW5jdGlvbiBjb2xvclRvbmUoZGVzYXR1cmF0aW9uLCB0b25lZCwgbGlnaHRDb2xvciwgZGFya0NvbG9yLCBtdWx0aXBseSkge1xuICAgICAgICBkZXNhdHVyYXRpb24gPSBkZXNhdHVyYXRpb24gfHwgMC4yO1xuICAgICAgICB0b25lZCA9IHRvbmVkIHx8IDAuMTU7XG4gICAgICAgIGxpZ2h0Q29sb3IgPSBsaWdodENvbG9yIHx8IDB4RkZFNTgwO1xuICAgICAgICBkYXJrQ29sb3IgPSBkYXJrQ29sb3IgfHwgMHgzMzgwMDA7XG5cbiAgICAgICAgdmFyIGxSID0gKGxpZ2h0Q29sb3IgPj4gMTYgJiAweEZGKSAvIDI1NTtcbiAgICAgICAgdmFyIGxHID0gKGxpZ2h0Q29sb3IgPj4gOCAmIDB4RkYpIC8gMjU1O1xuICAgICAgICB2YXIgbEIgPSAobGlnaHRDb2xvciAmIDB4RkYpIC8gMjU1O1xuXG4gICAgICAgIHZhciBkUiA9IChkYXJrQ29sb3IgPj4gMTYgJiAweEZGKSAvIDI1NTtcbiAgICAgICAgdmFyIGRHID0gKGRhcmtDb2xvciA+PiA4ICYgMHhGRikgLyAyNTU7XG4gICAgICAgIHZhciBkQiA9IChkYXJrQ29sb3IgJiAweEZGKSAvIDI1NTtcblxuICAgICAgICB2YXIgbWF0cml4ID0gWzAuMywgMC41OSwgMC4xMSwgMCwgMCwgbFIsIGxHLCBsQiwgZGVzYXR1cmF0aW9uLCAwLCBkUiwgZEcsIGRCLCB0b25lZCwgMCwgbFIgLSBkUiwgbEcgLSBkRywgbEIgLSBkQiwgMCwgMF07XG5cbiAgICAgICAgdGhpcy5fbG9hZE1hdHJpeChtYXRyaXgsIG11bHRpcGx5KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTmlnaHQgZWZmZWN0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW50ZW5zaXR5IC0gVGhlIGludGVuc2l0eSBvZiB0aGUgbmlnaHQgZWZmZWN0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gbXVsdGlwbHkgLSBpZiB0cnVlLCBjdXJyZW50IG1hdHJpeCBhbmQgbWF0cml4IGFyZSBtdWx0aXBsaWVkLiBJZiBmYWxzZSxcbiAgICAgKiAganVzdCBzZXQgdGhlIGN1cnJlbnQgbWF0cml4IHdpdGggQHBhcmFtIG1hdHJpeFxuICAgICAqL1xuXG5cbiAgICBDb2xvck1hdHJpeEZpbHRlci5wcm90b3R5cGUubmlnaHQgPSBmdW5jdGlvbiBuaWdodChpbnRlbnNpdHksIG11bHRpcGx5KSB7XG4gICAgICAgIGludGVuc2l0eSA9IGludGVuc2l0eSB8fCAwLjE7XG4gICAgICAgIHZhciBtYXRyaXggPSBbaW50ZW5zaXR5ICogLTIuMCwgLWludGVuc2l0eSwgMCwgMCwgMCwgLWludGVuc2l0eSwgMCwgaW50ZW5zaXR5LCAwLCAwLCAwLCBpbnRlbnNpdHksIGludGVuc2l0eSAqIDIuMCwgMCwgMCwgMCwgMCwgMCwgMSwgMF07XG5cbiAgICAgICAgdGhpcy5fbG9hZE1hdHJpeChtYXRyaXgsIG11bHRpcGx5KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUHJlZGF0b3IgZWZmZWN0XG4gICAgICpcbiAgICAgKiBFcmFzZSB0aGUgY3VycmVudCBtYXRyaXggYnkgc2V0dGluZyBhIG5ldyBpbmRlcGVudCBvbmVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbW91bnQgLSBob3cgbXVjaCB0aGUgcHJlZGF0b3IgZmVlbHMgaGlzIGZ1dHVyZSB2aWN0aW1cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG11bHRpcGx5IC0gaWYgdHJ1ZSwgY3VycmVudCBtYXRyaXggYW5kIG1hdHJpeCBhcmUgbXVsdGlwbGllZC4gSWYgZmFsc2UsXG4gICAgICogIGp1c3Qgc2V0IHRoZSBjdXJyZW50IG1hdHJpeCB3aXRoIEBwYXJhbSBtYXRyaXhcbiAgICAgKi9cblxuXG4gICAgQ29sb3JNYXRyaXhGaWx0ZXIucHJvdG90eXBlLnByZWRhdG9yID0gZnVuY3Rpb24gcHJlZGF0b3IoYW1vdW50LCBtdWx0aXBseSkge1xuICAgICAgICB2YXIgbWF0cml4ID0gW1xuICAgICAgICAvLyByb3cgMVxuICAgICAgICAxMS4yMjQxMzA2MzA0OTMxNjQgKiBhbW91bnQsIC00Ljc5NDQ4Njk5OTUxMTcxOSAqIGFtb3VudCwgLTIuODc0NjExODU0NTUzMjIyNyAqIGFtb3VudCwgMCAqIGFtb3VudCwgMC40MDM0MjQzODIyMDk3Nzc4MyAqIGFtb3VudCxcbiAgICAgICAgLy8gcm93IDJcbiAgICAgICAgLTMuNjMzMDY5NzUzNjQ2ODUwNiAqIGFtb3VudCwgOS4xOTMxNTcxOTYwNDQ5MjIgKiBhbW91bnQsIC0yLjk1MTgxMDgzNjc5MTk5MiAqIGFtb3VudCwgMCAqIGFtb3VudCwgLTEuMzE2MTM1MDQ4ODY2MjcyICogYW1vdW50LFxuICAgICAgICAvLyByb3cgM1xuICAgICAgICAtMy4yMTg0MTk3OTAyNjc5NDQzICogYW1vdW50LCAtNC4yMzc1MDMwNTE3NTc4MTI1ICogYW1vdW50LCA3LjQ3NjQ0ODA1OTA4MjAzMSAqIGFtb3VudCwgMCAqIGFtb3VudCwgMC44MDQ0NDU5MjIzNzQ3MjUzICogYW1vdW50LFxuICAgICAgICAvLyByb3cgNFxuICAgICAgICAwLCAwLCAwLCAxLCAwXTtcblxuICAgICAgICB0aGlzLl9sb2FkTWF0cml4KG1hdHJpeCwgbXVsdGlwbHkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBMU0QgZWZmZWN0XG4gICAgICpcbiAgICAgKiBNdWx0aXBseSB0aGUgY3VycmVudCBtYXRyaXhcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gbXVsdGlwbHkgLSBpZiB0cnVlLCBjdXJyZW50IG1hdHJpeCBhbmQgbWF0cml4IGFyZSBtdWx0aXBsaWVkLiBJZiBmYWxzZSxcbiAgICAgKiAganVzdCBzZXQgdGhlIGN1cnJlbnQgbWF0cml4IHdpdGggQHBhcmFtIG1hdHJpeFxuICAgICAqL1xuXG5cbiAgICBDb2xvck1hdHJpeEZpbHRlci5wcm90b3R5cGUubHNkID0gZnVuY3Rpb24gbHNkKG11bHRpcGx5KSB7XG4gICAgICAgIHZhciBtYXRyaXggPSBbMiwgLTAuNCwgMC41LCAwLCAwLCAtMC41LCAyLCAtMC40LCAwLCAwLCAtMC40LCAtMC41LCAzLCAwLCAwLCAwLCAwLCAwLCAxLCAwXTtcblxuICAgICAgICB0aGlzLl9sb2FkTWF0cml4KG1hdHJpeCwgbXVsdGlwbHkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBFcmFzZSB0aGUgY3VycmVudCBtYXRyaXggYnkgc2V0dGluZyB0aGUgZGVmYXVsdCBvbmVcbiAgICAgKlxuICAgICAqL1xuXG5cbiAgICBDb2xvck1hdHJpeEZpbHRlci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgICAgdmFyIG1hdHJpeCA9IFsxLCAwLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAwLCAxLCAwXTtcblxuICAgICAgICB0aGlzLl9sb2FkTWF0cml4KG1hdHJpeCwgZmFsc2UpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbWF0cml4IG9mIHRoZSBjb2xvciBtYXRyaXggZmlsdGVyXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJbXX1cbiAgICAgKiBAZGVmYXVsdCBbMSwgMCwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMCwgMSwgMF1cbiAgICAgKi9cblxuXG4gICAgX2NyZWF0ZUNsYXNzKENvbG9yTWF0cml4RmlsdGVyLCBbe1xuICAgICAgICBrZXk6ICdtYXRyaXgnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLm07XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlcXVpcmUtanNkb2NcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy51bmlmb3Jtcy5tID0gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG9wYWNpdHkgdmFsdWUgdG8gdXNlIHdoZW4gbWl4aW5nIHRoZSBvcmlnaW5hbCBhbmQgcmVzdWx0YW50IGNvbG9ycy5cbiAgICAgICAgICpcbiAgICAgICAgICogV2hlbiB0aGUgdmFsdWUgaXMgMCwgdGhlIG9yaWdpbmFsIGNvbG9yIGlzIHVzZWQgd2l0aG91dCBtb2RpZmljYXRpb24uXG4gICAgICAgICAqIFdoZW4gdGhlIHZhbHVlIGlzIDEsIHRoZSByZXN1bHQgY29sb3IgaXMgdXNlZC5cbiAgICAgICAgICogV2hlbiBpbiB0aGUgcmFuZ2UgKDAsIDEpIHRoZSBjb2xvciBpcyBpbnRlcnBvbGF0ZWQgYmV0d2VlbiB0aGUgb3JpZ2luYWwgYW5kIHJlc3VsdCBieSB0aGlzIGFtb3VudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAxXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdhbHBoYScsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5pZm9ybXMudUFscGhhO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSByZXF1aXJlLWpzZG9jXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMudW5pZm9ybXMudUFscGhhID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gQ29sb3JNYXRyaXhGaWx0ZXI7XG59KGNvcmUuRmlsdGVyKTtcblxuLy8gQW1lcmljYW5pemVkIGFsaWFzXG5cblxuZXhwb3J0cy5kZWZhdWx0ID0gQ29sb3JNYXRyaXhGaWx0ZXI7XG5Db2xvck1hdHJpeEZpbHRlci5wcm90b3R5cGUuZ3JheXNjYWxlID0gQ29sb3JNYXRyaXhGaWx0ZXIucHJvdG90eXBlLmdyZXlzY2FsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNvbG9yTWF0cml4RmlsdGVyLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9jb3JlID0gcmVxdWlyZSgnLi4vLi4vY29yZScpO1xuXG52YXIgY29yZSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9jb3JlKTtcblxudmFyIF9wYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbi8qKlxuICogVGhlIERpc3BsYWNlbWVudEZpbHRlciBjbGFzcyB1c2VzIHRoZSBwaXhlbCB2YWx1ZXMgZnJvbSB0aGUgc3BlY2lmaWVkIHRleHR1cmVcbiAqIChjYWxsZWQgdGhlIGRpc3BsYWNlbWVudCBtYXApIHRvIHBlcmZvcm0gYSBkaXNwbGFjZW1lbnQgb2YgYW4gb2JqZWN0LiBZb3UgY2FuXG4gKiB1c2UgdGhpcyBmaWx0ZXIgdG8gYXBwbHkgYWxsIG1hbm9yIG9mIGNyYXp5IHdhcnBpbmcgZWZmZWN0cy4gQ3VycmVudGx5IHRoZSByXG4gKiBwcm9wZXJ0eSBvZiB0aGUgdGV4dHVyZSBpcyB1c2VkIHRvIG9mZnNldCB0aGUgeCBhbmQgdGhlIGcgcHJvcGVydHkgb2YgdGhlIHRleHR1cmVcbiAqIGlzIHVzZWQgdG8gb2Zmc2V0IHRoZSB5LlxuICpcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgUElYSS5GaWx0ZXJcbiAqIEBtZW1iZXJvZiBQSVhJLmZpbHRlcnNcbiAqL1xudmFyIERpc3BsYWNlbWVudEZpbHRlciA9IGZ1bmN0aW9uIChfY29yZSRGaWx0ZXIpIHtcbiAgICBfaW5oZXJpdHMoRGlzcGxhY2VtZW50RmlsdGVyLCBfY29yZSRGaWx0ZXIpO1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtQSVhJLlNwcml0ZX0gc3ByaXRlIC0gVGhlIHNwcml0ZSB1c2VkIGZvciB0aGUgZGlzcGxhY2VtZW50IG1hcC4gKG1ha2Ugc3VyZSBpdHMgYWRkZWQgdG8gdGhlIHNjZW5lISlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2NhbGUgLSBUaGUgc2NhbGUgb2YgdGhlIGRpc3BsYWNlbWVudFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIERpc3BsYWNlbWVudEZpbHRlcihzcHJpdGUsIHNjYWxlKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEaXNwbGFjZW1lbnRGaWx0ZXIpO1xuXG4gICAgICAgIHZhciBtYXNrTWF0cml4ID0gbmV3IGNvcmUuTWF0cml4KCk7XG5cbiAgICAgICAgc3ByaXRlLnJlbmRlcmFibGUgPSBmYWxzZTtcblxuICAgICAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfY29yZSRGaWx0ZXIuY2FsbCh0aGlzLFxuICAgICAgICAvLyB2ZXJ0ZXggc2hhZGVyXG4gICAgICAgICdhdHRyaWJ1dGUgdmVjMiBhVmVydGV4UG9zaXRpb247XFxuYXR0cmlidXRlIHZlYzIgYVRleHR1cmVDb29yZDtcXG5cXG51bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDtcXG51bmlmb3JtIG1hdDMgZmlsdGVyTWF0cml4O1xcblxcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcbnZhcnlpbmcgdmVjMiB2RmlsdGVyQ29vcmQ7XFxuXFxudm9pZCBtYWluKHZvaWQpXFxue1xcbiAgIGdsX1Bvc2l0aW9uID0gdmVjNCgocHJvamVjdGlvbk1hdHJpeCAqIHZlYzMoYVZlcnRleFBvc2l0aW9uLCAxLjApKS54eSwgMC4wLCAxLjApO1xcbiAgIHZGaWx0ZXJDb29yZCA9ICggZmlsdGVyTWF0cml4ICogdmVjMyggYVRleHR1cmVDb29yZCwgMS4wKSAgKS54eTtcXG4gICB2VGV4dHVyZUNvb3JkID0gYVRleHR1cmVDb29yZDtcXG59JyxcbiAgICAgICAgLy8gZnJhZ21lbnQgc2hhZGVyXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdkZpbHRlckNvb3JkO1xcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcblxcbnVuaWZvcm0gdmVjMiBzY2FsZTtcXG5cXG51bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcXG51bmlmb3JtIHNhbXBsZXIyRCBtYXBTYW1wbGVyO1xcblxcbnVuaWZvcm0gdmVjNCBmaWx0ZXJBcmVhO1xcbnVuaWZvcm0gdmVjNCBmaWx0ZXJDbGFtcDtcXG5cXG52b2lkIG1haW4odm9pZClcXG57XFxuICB2ZWM0IG1hcCA9ICB0ZXh0dXJlMkQobWFwU2FtcGxlciwgdkZpbHRlckNvb3JkKTtcXG5cXG4gIG1hcCAtPSAwLjU7XFxuICBtYXAueHkgKj0gc2NhbGUgLyBmaWx0ZXJBcmVhLnh5O1xcblxcbiAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyLCBjbGFtcCh2ZWMyKHZUZXh0dXJlQ29vcmQueCArIG1hcC54LCB2VGV4dHVyZUNvb3JkLnkgKyBtYXAueSksIGZpbHRlckNsYW1wLnh5LCBmaWx0ZXJDbGFtcC56dykpO1xcbn1cXG4nKSk7XG5cbiAgICAgICAgX3RoaXMubWFza1Nwcml0ZSA9IHNwcml0ZTtcbiAgICAgICAgX3RoaXMubWFza01hdHJpeCA9IG1hc2tNYXRyaXg7XG5cbiAgICAgICAgX3RoaXMudW5pZm9ybXMubWFwU2FtcGxlciA9IHNwcml0ZS5fdGV4dHVyZTtcbiAgICAgICAgX3RoaXMudW5pZm9ybXMuZmlsdGVyTWF0cml4ID0gbWFza01hdHJpeDtcbiAgICAgICAgX3RoaXMudW5pZm9ybXMuc2NhbGUgPSB7IHg6IDEsIHk6IDEgfTtcblxuICAgICAgICBpZiAoc2NhbGUgPT09IG51bGwgfHwgc2NhbGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc2NhbGUgPSAyMDtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzLnNjYWxlID0gbmV3IGNvcmUuUG9pbnQoc2NhbGUsIHNjYWxlKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgdGhlIGZpbHRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5GaWx0ZXJNYW5hZ2VyfSBmaWx0ZXJNYW5hZ2VyIC0gVGhlIG1hbmFnZXIuXG4gICAgICogQHBhcmFtIHtQSVhJLlJlbmRlclRhcmdldH0gaW5wdXQgLSBUaGUgaW5wdXQgdGFyZ2V0LlxuICAgICAqIEBwYXJhbSB7UElYSS5SZW5kZXJUYXJnZXR9IG91dHB1dCAtIFRoZSBvdXRwdXQgdGFyZ2V0LlxuICAgICAqL1xuXG5cbiAgICBEaXNwbGFjZW1lbnRGaWx0ZXIucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24gYXBwbHkoZmlsdGVyTWFuYWdlciwgaW5wdXQsIG91dHB1dCkge1xuICAgICAgICB0aGlzLnVuaWZvcm1zLmZpbHRlck1hdHJpeCA9IGZpbHRlck1hbmFnZXIuY2FsY3VsYXRlU3ByaXRlTWF0cml4KHRoaXMubWFza01hdHJpeCwgdGhpcy5tYXNrU3ByaXRlKTtcbiAgICAgICAgdGhpcy51bmlmb3Jtcy5zY2FsZS54ID0gdGhpcy5zY2FsZS54O1xuICAgICAgICB0aGlzLnVuaWZvcm1zLnNjYWxlLnkgPSB0aGlzLnNjYWxlLnk7XG5cbiAgICAgICAgLy8gZHJhdyB0aGUgZmlsdGVyLi4uXG4gICAgICAgIGZpbHRlck1hbmFnZXIuYXBwbHlGaWx0ZXIodGhpcywgaW5wdXQsIG91dHB1dCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB0ZXh0dXJlIHVzZWQgZm9yIHRoZSBkaXNwbGFjZW1lbnQgbWFwLiBNdXN0IGJlIHBvd2VyIG9mIDIgc2l6ZWQgdGV4dHVyZS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge1BJWEkuVGV4dHVyZX1cbiAgICAgKi9cblxuXG4gICAgX2NyZWF0ZUNsYXNzKERpc3BsYWNlbWVudEZpbHRlciwgW3tcbiAgICAgICAga2V5OiAnbWFwJyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5tYXBTYW1wbGVyO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSByZXF1aXJlLWpzZG9jXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMudW5pZm9ybXMubWFwU2FtcGxlciA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIERpc3BsYWNlbWVudEZpbHRlcjtcbn0oY29yZS5GaWx0ZXIpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBEaXNwbGFjZW1lbnRGaWx0ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1EaXNwbGFjZW1lbnRGaWx0ZXIuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2NvcmUgPSByZXF1aXJlKCcuLi8uLi9jb3JlJyk7XG5cbnZhciBjb3JlID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX2NvcmUpO1xuXG52YXIgX3BhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuLyoqXG4gKlxuICogQmFzaWMgRlhBQSBpbXBsZW1lbnRhdGlvbiBiYXNlZCBvbiB0aGUgY29kZSBvbiBnZWVrczNkLmNvbSB3aXRoIHRoZVxuICogbW9kaWZpY2F0aW9uIHRoYXQgdGhlIHRleHR1cmUyRExvZCBzdHVmZiB3YXMgcmVtb3ZlZCBzaW5jZSBpdCdzXG4gKiB1bnN1cHBvcnRlZCBieSBXZWJHTC5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9taXRzdWhpa28vd2ViZ2wtbWVpbmNyYWZ0XG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQSVhJLkZpbHRlclxuICogQG1lbWJlcm9mIFBJWEkuZmlsdGVyc1xuICpcbiAqL1xudmFyIEZYQUFGaWx0ZXIgPSBmdW5jdGlvbiAoX2NvcmUkRmlsdGVyKSB7XG4gICAgX2luaGVyaXRzKEZYQUFGaWx0ZXIsIF9jb3JlJEZpbHRlcik7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEZYQUFGaWx0ZXIoKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBGWEFBRmlsdGVyKTtcblxuICAgICAgICAvLyBUT0RPIC0gbmVlZHMgd29ya1xuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2NvcmUkRmlsdGVyLmNhbGwodGhpcyxcbiAgICAgICAgLy8gdmVydGV4IHNoYWRlclxuICAgICAgICAnXFxuYXR0cmlidXRlIHZlYzIgYVZlcnRleFBvc2l0aW9uO1xcbmF0dHJpYnV0ZSB2ZWMyIGFUZXh0dXJlQ29vcmQ7XFxuXFxudW5pZm9ybSBtYXQzIHByb2plY3Rpb25NYXRyaXg7XFxuXFxudmFyeWluZyB2ZWMyIHZfcmdiTlc7XFxudmFyeWluZyB2ZWMyIHZfcmdiTkU7XFxudmFyeWluZyB2ZWMyIHZfcmdiU1c7XFxudmFyeWluZyB2ZWMyIHZfcmdiU0U7XFxudmFyeWluZyB2ZWMyIHZfcmdiTTtcXG5cXG51bmlmb3JtIHZlYzQgZmlsdGVyQXJlYTtcXG5cXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG5cXG52ZWMyIG1hcENvb3JkKCB2ZWMyIGNvb3JkIClcXG57XFxuICAgIGNvb3JkICo9IGZpbHRlckFyZWEueHk7XFxuICAgIGNvb3JkICs9IGZpbHRlckFyZWEuenc7XFxuXFxuICAgIHJldHVybiBjb29yZDtcXG59XFxuXFxudmVjMiB1bm1hcENvb3JkKCB2ZWMyIGNvb3JkIClcXG57XFxuICAgIGNvb3JkIC09IGZpbHRlckFyZWEuenc7XFxuICAgIGNvb3JkIC89IGZpbHRlckFyZWEueHk7XFxuXFxuICAgIHJldHVybiBjb29yZDtcXG59XFxuXFxudm9pZCB0ZXhjb29yZHModmVjMiBmcmFnQ29vcmQsIHZlYzIgcmVzb2x1dGlvbixcXG4gICAgICAgICAgICAgICBvdXQgdmVjMiB2X3JnYk5XLCBvdXQgdmVjMiB2X3JnYk5FLFxcbiAgICAgICAgICAgICAgIG91dCB2ZWMyIHZfcmdiU1csIG91dCB2ZWMyIHZfcmdiU0UsXFxuICAgICAgICAgICAgICAgb3V0IHZlYzIgdl9yZ2JNKSB7XFxuICAgIHZlYzIgaW52ZXJzZVZQID0gMS4wIC8gcmVzb2x1dGlvbi54eTtcXG4gICAgdl9yZ2JOVyA9IChmcmFnQ29vcmQgKyB2ZWMyKC0xLjAsIC0xLjApKSAqIGludmVyc2VWUDtcXG4gICAgdl9yZ2JORSA9IChmcmFnQ29vcmQgKyB2ZWMyKDEuMCwgLTEuMCkpICogaW52ZXJzZVZQO1xcbiAgICB2X3JnYlNXID0gKGZyYWdDb29yZCArIHZlYzIoLTEuMCwgMS4wKSkgKiBpbnZlcnNlVlA7XFxuICAgIHZfcmdiU0UgPSAoZnJhZ0Nvb3JkICsgdmVjMigxLjAsIDEuMCkpICogaW52ZXJzZVZQO1xcbiAgICB2X3JnYk0gPSB2ZWMyKGZyYWdDb29yZCAqIGludmVyc2VWUCk7XFxufVxcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuXFxuICAgZ2xfUG9zaXRpb24gPSB2ZWM0KChwcm9qZWN0aW9uTWF0cml4ICogdmVjMyhhVmVydGV4UG9zaXRpb24sIDEuMCkpLnh5LCAwLjAsIDEuMCk7XFxuXFxuICAgdlRleHR1cmVDb29yZCA9IGFUZXh0dXJlQ29vcmQ7XFxuXFxuICAgdmVjMiBmcmFnQ29vcmQgPSB2VGV4dHVyZUNvb3JkICogZmlsdGVyQXJlYS54eTtcXG5cXG4gICB0ZXhjb29yZHMoZnJhZ0Nvb3JkLCBmaWx0ZXJBcmVhLnh5LCB2X3JnYk5XLCB2X3JnYk5FLCB2X3JnYlNXLCB2X3JnYlNFLCB2X3JnYk0pO1xcbn0nLFxuICAgICAgICAvLyBmcmFnbWVudCBzaGFkZXJcbiAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2X3JnYk5XO1xcbnZhcnlpbmcgdmVjMiB2X3JnYk5FO1xcbnZhcnlpbmcgdmVjMiB2X3JnYlNXO1xcbnZhcnlpbmcgdmVjMiB2X3JnYlNFO1xcbnZhcnlpbmcgdmVjMiB2X3JnYk07XFxuXFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxudW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XFxudW5pZm9ybSB2ZWM0IGZpbHRlckFyZWE7XFxuXFxuLyoqXFxuIEJhc2ljIEZYQUEgaW1wbGVtZW50YXRpb24gYmFzZWQgb24gdGhlIGNvZGUgb24gZ2Vla3MzZC5jb20gd2l0aCB0aGVcXG4gbW9kaWZpY2F0aW9uIHRoYXQgdGhlIHRleHR1cmUyRExvZCBzdHVmZiB3YXMgcmVtb3ZlZCBzaW5jZSBpdFxcJ3NcXG4gdW5zdXBwb3J0ZWQgYnkgV2ViR0wuXFxuIFxcbiAtLVxcbiBcXG4gRnJvbTpcXG4gaHR0cHM6Ly9naXRodWIuY29tL21pdHN1aGlrby93ZWJnbC1tZWluY3JhZnRcXG4gXFxuIENvcHlyaWdodCAoYykgMjAxMSBieSBBcm1pbiBSb25hY2hlci5cXG4gXFxuIFNvbWUgcmlnaHRzIHJlc2VydmVkLlxcbiBcXG4gUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XFxuIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmVcXG4gbWV0OlxcbiBcXG4gKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxcbiBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXFxuIFxcbiAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmVcXG4gY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcXG4gZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkXFxuIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cXG4gXFxuICogVGhlIG5hbWVzIG9mIHRoZSBjb250cmlidXRvcnMgbWF5IG5vdCBiZSB1c2VkIHRvIGVuZG9yc2Ugb3JcXG4gcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljXFxuIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cXG4gXFxuIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlNcXG4gXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxcbiBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1JcXG4gQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFRcXG4gT1dORVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsXFxuIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1RcXG4gTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsXFxuIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWVxcbiBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXFxuIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRVxcbiBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxcbiAqL1xcblxcbiNpZm5kZWYgRlhBQV9SRURVQ0VfTUlOXFxuI2RlZmluZSBGWEFBX1JFRFVDRV9NSU4gICAoMS4wLyAxMjguMClcXG4jZW5kaWZcXG4jaWZuZGVmIEZYQUFfUkVEVUNFX01VTFxcbiNkZWZpbmUgRlhBQV9SRURVQ0VfTVVMICAgKDEuMCAvIDguMClcXG4jZW5kaWZcXG4jaWZuZGVmIEZYQUFfU1BBTl9NQVhcXG4jZGVmaW5lIEZYQUFfU1BBTl9NQVggICAgIDguMFxcbiNlbmRpZlxcblxcbi8vb3B0aW1pemVkIHZlcnNpb24gZm9yIG1vYmlsZSwgd2hlcmUgZGVwZW5kZW50XFxuLy90ZXh0dXJlIHJlYWRzIGNhbiBiZSBhIGJvdHRsZW5lY2tcXG52ZWM0IGZ4YWEoc2FtcGxlcjJEIHRleCwgdmVjMiBmcmFnQ29vcmQsIHZlYzIgcmVzb2x1dGlvbixcXG4gICAgICAgICAgdmVjMiB2X3JnYk5XLCB2ZWMyIHZfcmdiTkUsXFxuICAgICAgICAgIHZlYzIgdl9yZ2JTVywgdmVjMiB2X3JnYlNFLFxcbiAgICAgICAgICB2ZWMyIHZfcmdiTSkge1xcbiAgICB2ZWM0IGNvbG9yO1xcbiAgICBtZWRpdW1wIHZlYzIgaW52ZXJzZVZQID0gdmVjMigxLjAgLyByZXNvbHV0aW9uLngsIDEuMCAvIHJlc29sdXRpb24ueSk7XFxuICAgIHZlYzMgcmdiTlcgPSB0ZXh0dXJlMkQodGV4LCB2X3JnYk5XKS54eXo7XFxuICAgIHZlYzMgcmdiTkUgPSB0ZXh0dXJlMkQodGV4LCB2X3JnYk5FKS54eXo7XFxuICAgIHZlYzMgcmdiU1cgPSB0ZXh0dXJlMkQodGV4LCB2X3JnYlNXKS54eXo7XFxuICAgIHZlYzMgcmdiU0UgPSB0ZXh0dXJlMkQodGV4LCB2X3JnYlNFKS54eXo7XFxuICAgIHZlYzQgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodGV4LCB2X3JnYk0pO1xcbiAgICB2ZWMzIHJnYk0gID0gdGV4Q29sb3IueHl6O1xcbiAgICB2ZWMzIGx1bWEgPSB2ZWMzKDAuMjk5LCAwLjU4NywgMC4xMTQpO1xcbiAgICBmbG9hdCBsdW1hTlcgPSBkb3QocmdiTlcsIGx1bWEpO1xcbiAgICBmbG9hdCBsdW1hTkUgPSBkb3QocmdiTkUsIGx1bWEpO1xcbiAgICBmbG9hdCBsdW1hU1cgPSBkb3QocmdiU1csIGx1bWEpO1xcbiAgICBmbG9hdCBsdW1hU0UgPSBkb3QocmdiU0UsIGx1bWEpO1xcbiAgICBmbG9hdCBsdW1hTSAgPSBkb3QocmdiTSwgIGx1bWEpO1xcbiAgICBmbG9hdCBsdW1hTWluID0gbWluKGx1bWFNLCBtaW4obWluKGx1bWFOVywgbHVtYU5FKSwgbWluKGx1bWFTVywgbHVtYVNFKSkpO1xcbiAgICBmbG9hdCBsdW1hTWF4ID0gbWF4KGx1bWFNLCBtYXgobWF4KGx1bWFOVywgbHVtYU5FKSwgbWF4KGx1bWFTVywgbHVtYVNFKSkpO1xcbiAgICBcXG4gICAgbWVkaXVtcCB2ZWMyIGRpcjtcXG4gICAgZGlyLnggPSAtKChsdW1hTlcgKyBsdW1hTkUpIC0gKGx1bWFTVyArIGx1bWFTRSkpO1xcbiAgICBkaXIueSA9ICAoKGx1bWFOVyArIGx1bWFTVykgLSAobHVtYU5FICsgbHVtYVNFKSk7XFxuICAgIFxcbiAgICBmbG9hdCBkaXJSZWR1Y2UgPSBtYXgoKGx1bWFOVyArIGx1bWFORSArIGx1bWFTVyArIGx1bWFTRSkgKlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKDAuMjUgKiBGWEFBX1JFRFVDRV9NVUwpLCBGWEFBX1JFRFVDRV9NSU4pO1xcbiAgICBcXG4gICAgZmxvYXQgcmNwRGlyTWluID0gMS4wIC8gKG1pbihhYnMoZGlyLngpLCBhYnMoZGlyLnkpKSArIGRpclJlZHVjZSk7XFxuICAgIGRpciA9IG1pbih2ZWMyKEZYQUFfU1BBTl9NQVgsIEZYQUFfU1BBTl9NQVgpLFxcbiAgICAgICAgICAgICAgbWF4KHZlYzIoLUZYQUFfU1BBTl9NQVgsIC1GWEFBX1NQQU5fTUFYKSxcXG4gICAgICAgICAgICAgICAgICBkaXIgKiByY3BEaXJNaW4pKSAqIGludmVyc2VWUDtcXG4gICAgXFxuICAgIHZlYzMgcmdiQSA9IDAuNSAqIChcXG4gICAgICAgICAgICAgICAgICAgICAgIHRleHR1cmUyRCh0ZXgsIGZyYWdDb29yZCAqIGludmVyc2VWUCArIGRpciAqICgxLjAgLyAzLjAgLSAwLjUpKS54eXogK1xcbiAgICAgICAgICAgICAgICAgICAgICAgdGV4dHVyZTJEKHRleCwgZnJhZ0Nvb3JkICogaW52ZXJzZVZQICsgZGlyICogKDIuMCAvIDMuMCAtIDAuNSkpLnh5eik7XFxuICAgIHZlYzMgcmdiQiA9IHJnYkEgKiAwLjUgKyAwLjI1ICogKFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlMkQodGV4LCBmcmFnQ29vcmQgKiBpbnZlcnNlVlAgKyBkaXIgKiAtMC41KS54eXogK1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlMkQodGV4LCBmcmFnQ29vcmQgKiBpbnZlcnNlVlAgKyBkaXIgKiAwLjUpLnh5eik7XFxuICAgIFxcbiAgICBmbG9hdCBsdW1hQiA9IGRvdChyZ2JCLCBsdW1hKTtcXG4gICAgaWYgKChsdW1hQiA8IGx1bWFNaW4pIHx8IChsdW1hQiA+IGx1bWFNYXgpKVxcbiAgICAgICAgY29sb3IgPSB2ZWM0KHJnYkEsIHRleENvbG9yLmEpO1xcbiAgICBlbHNlXFxuICAgICAgICBjb2xvciA9IHZlYzQocmdiQiwgdGV4Q29sb3IuYSk7XFxuICAgIHJldHVybiBjb2xvcjtcXG59XFxuXFxudm9pZCBtYWluKCkge1xcblxcbiAgICAgIHZlYzIgZnJhZ0Nvb3JkID0gdlRleHR1cmVDb29yZCAqIGZpbHRlckFyZWEueHk7XFxuXFxuICAgICAgdmVjNCBjb2xvcjtcXG5cXG4gICAgY29sb3IgPSBmeGFhKHVTYW1wbGVyLCBmcmFnQ29vcmQsIGZpbHRlckFyZWEueHksIHZfcmdiTlcsIHZfcmdiTkUsIHZfcmdiU1csIHZfcmdiU0UsIHZfcmdiTSk7XFxuXFxuICAgICAgZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxufVxcbicpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gRlhBQUZpbHRlcjtcbn0oY29yZS5GaWx0ZXIpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBGWEFBRmlsdGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RlhBQUZpbHRlci5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfRlhBQUZpbHRlciA9IHJlcXVpcmUoJy4vZnhhYS9GWEFBRmlsdGVyJyk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnRlhBQUZpbHRlcicsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0ZYQUFGaWx0ZXIpLmRlZmF1bHQ7XG4gIH1cbn0pO1xuXG52YXIgX05vaXNlRmlsdGVyID0gcmVxdWlyZSgnLi9ub2lzZS9Ob2lzZUZpbHRlcicpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ05vaXNlRmlsdGVyJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTm9pc2VGaWx0ZXIpLmRlZmF1bHQ7XG4gIH1cbn0pO1xuXG52YXIgX0Rpc3BsYWNlbWVudEZpbHRlciA9IHJlcXVpcmUoJy4vZGlzcGxhY2VtZW50L0Rpc3BsYWNlbWVudEZpbHRlcicpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ0Rpc3BsYWNlbWVudEZpbHRlcicsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Rpc3BsYWNlbWVudEZpbHRlcikuZGVmYXVsdDtcbiAgfVxufSk7XG5cbnZhciBfQmx1ckZpbHRlciA9IHJlcXVpcmUoJy4vYmx1ci9CbHVyRmlsdGVyJyk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnQmx1ckZpbHRlcicsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0JsdXJGaWx0ZXIpLmRlZmF1bHQ7XG4gIH1cbn0pO1xuXG52YXIgX0JsdXJYRmlsdGVyID0gcmVxdWlyZSgnLi9ibHVyL0JsdXJYRmlsdGVyJyk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnQmx1clhGaWx0ZXInLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9CbHVyWEZpbHRlcikuZGVmYXVsdDtcbiAgfVxufSk7XG5cbnZhciBfQmx1cllGaWx0ZXIgPSByZXF1aXJlKCcuL2JsdXIvQmx1cllGaWx0ZXInKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdCbHVyWUZpbHRlcicsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0JsdXJZRmlsdGVyKS5kZWZhdWx0O1xuICB9XG59KTtcblxudmFyIF9Db2xvck1hdHJpeEZpbHRlciA9IHJlcXVpcmUoJy4vY29sb3JtYXRyaXgvQ29sb3JNYXRyaXhGaWx0ZXInKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdDb2xvck1hdHJpeEZpbHRlcicsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0NvbG9yTWF0cml4RmlsdGVyKS5kZWZhdWx0O1xuICB9XG59KTtcblxudmFyIF9BbHBoYUZpbHRlciA9IHJlcXVpcmUoJy4vYWxwaGEvQWxwaGFGaWx0ZXInKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdBbHBoYUZpbHRlcicsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0FscGhhRmlsdGVyKS5kZWZhdWx0O1xuICB9XG59KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9jb3JlID0gcmVxdWlyZSgnLi4vLi4vY29yZScpO1xuXG52YXIgY29yZSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9jb3JlKTtcblxudmFyIF9wYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbi8qKlxuICogQGF1dGhvciBWaWNvIEB2aWNvY290ZWFcbiAqIG9yaWdpbmFsIGZpbHRlcjogaHR0cHM6Ly9naXRodWIuY29tL2V2YW53L2dsZnguanMvYmxvYi9tYXN0ZXIvc3JjL2ZpbHRlcnMvYWRqdXN0L25vaXNlLmpzXG4gKi9cblxuLyoqXG4gKiBBIE5vaXNlIGVmZmVjdCBmaWx0ZXIuXG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQSVhJLkZpbHRlclxuICogQG1lbWJlcm9mIFBJWEkuZmlsdGVyc1xuICovXG52YXIgTm9pc2VGaWx0ZXIgPSBmdW5jdGlvbiAoX2NvcmUkRmlsdGVyKSB7XG4gICAgX2luaGVyaXRzKE5vaXNlRmlsdGVyLCBfY29yZSRGaWx0ZXIpO1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG5vaXNlIC0gVGhlIG5vaXNlIGludGVuc2l0eSwgc2hvdWxkIGJlIGEgbm9ybWFsaXplZCB2YWx1ZSBpbiB0aGUgcmFuZ2UgWzAsIDFdLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzZWVkIC0gQSByYW5kb20gc2VlZCBmb3IgdGhlIG5vaXNlIGdlbmVyYXRpb24uIERlZmF1bHQgaXMgYE1hdGgucmFuZG9tKClgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE5vaXNlRmlsdGVyKCkge1xuICAgICAgICB2YXIgbm9pc2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDAuNTtcbiAgICAgICAgdmFyIHNlZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IE1hdGgucmFuZG9tKCk7XG5cbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE5vaXNlRmlsdGVyKTtcblxuICAgICAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfY29yZSRGaWx0ZXIuY2FsbCh0aGlzLFxuICAgICAgICAvLyB2ZXJ0ZXggc2hhZGVyXG4gICAgICAgICdhdHRyaWJ1dGUgdmVjMiBhVmVydGV4UG9zaXRpb247XFxuYXR0cmlidXRlIHZlYzIgYVRleHR1cmVDb29yZDtcXG5cXG51bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDtcXG5cXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG5cXG52b2lkIG1haW4odm9pZClcXG57XFxuICAgIGdsX1Bvc2l0aW9uID0gdmVjNCgocHJvamVjdGlvbk1hdHJpeCAqIHZlYzMoYVZlcnRleFBvc2l0aW9uLCAxLjApKS54eSwgMC4wLCAxLjApO1xcbiAgICB2VGV4dHVyZUNvb3JkID0gYVRleHR1cmVDb29yZDtcXG59JyxcbiAgICAgICAgLy8gZnJhZ21lbnQgc2hhZGVyXG4gICAgICAgICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuXFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxudmFyeWluZyB2ZWM0IHZDb2xvcjtcXG5cXG51bmlmb3JtIGZsb2F0IHVOb2lzZTtcXG51bmlmb3JtIGZsb2F0IHVTZWVkO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xcblxcbmZsb2F0IHJhbmQodmVjMiBjbylcXG57XFxuICAgIHJldHVybiBmcmFjdChzaW4oZG90KGNvLnh5LCB2ZWMyKDEyLjk4OTgsIDc4LjIzMykpKSAqIDQzNzU4LjU0NTMpO1xcbn1cXG5cXG52b2lkIG1haW4oKVxcbntcXG4gICAgdmVjNCBjb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCk7XFxuICAgIGZsb2F0IHJhbmRvbVZhbHVlID0gcmFuZChnbF9GcmFnQ29vcmQueHkgKiB1U2VlZCk7XFxuICAgIGZsb2F0IGRpZmYgPSAocmFuZG9tVmFsdWUgLSAwLjUpICogdU5vaXNlO1xcblxcbiAgICAvLyBVbi1wcmVtdWx0aXBseSBhbHBoYSBiZWZvcmUgYXBwbHlpbmcgdGhlIGNvbG9yIG1hdHJpeC4gU2VlIGlzc3VlICMzNTM5LlxcbiAgICBpZiAoY29sb3IuYSA+IDAuMCkge1xcbiAgICAgICAgY29sb3IucmdiIC89IGNvbG9yLmE7XFxuICAgIH1cXG5cXG4gICAgY29sb3IuciArPSBkaWZmO1xcbiAgICBjb2xvci5nICs9IGRpZmY7XFxuICAgIGNvbG9yLmIgKz0gZGlmZjtcXG5cXG4gICAgLy8gUHJlbXVsdGlwbHkgYWxwaGEgYWdhaW4uXFxuICAgIGNvbG9yLnJnYiAqPSBjb2xvci5hO1xcblxcbiAgICBnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG59XFxuJykpO1xuXG4gICAgICAgIF90aGlzLm5vaXNlID0gbm9pc2U7XG4gICAgICAgIF90aGlzLnNlZWQgPSBzZWVkO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGFtb3VudCBvZiBub2lzZSB0byBhcHBseSwgdGhpcyB2YWx1ZSBzaG91bGQgYmUgaW4gdGhlIHJhbmdlICgwLCAxXS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwLjVcbiAgICAgKi9cblxuXG4gICAgX2NyZWF0ZUNsYXNzKE5vaXNlRmlsdGVyLCBbe1xuICAgICAgICBrZXk6ICdub2lzZScsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5pZm9ybXMudU5vaXNlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSByZXF1aXJlLWpzZG9jXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMudW5pZm9ybXMudU5vaXNlID0gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBzZWVkIHZhbHVlIHRvIGFwcGx5IHRvIHRoZSByYW5kb20gbm9pc2UgZ2VuZXJhdGlvbi4gYE1hdGgucmFuZG9tKClgIGlzIGEgZ29vZCB2YWx1ZSB0byB1c2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3NlZWQnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLnVTZWVkO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSByZXF1aXJlLWpzZG9jXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMudW5pZm9ybXMudVNlZWQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBOb2lzZUZpbHRlcjtcbn0oY29yZS5GaWx0ZXIpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBOb2lzZUZpbHRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU5vaXNlRmlsdGVyLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMubG9hZGVyID0gZXhwb3J0cy5wcmVwYXJlID0gZXhwb3J0cy5wYXJ0aWNsZXMgPSBleHBvcnRzLm1lc2ggPSBleHBvcnRzLmxvYWRlcnMgPSBleHBvcnRzLmludGVyYWN0aW9uID0gZXhwb3J0cy5maWx0ZXJzID0gZXhwb3J0cy5leHRyYXMgPSBleHBvcnRzLmV4dHJhY3QgPSBleHBvcnRzLmFjY2Vzc2liaWxpdHkgPSB1bmRlZmluZWQ7XG5cbnZhciBfcG9seWZpbGwgPSByZXF1aXJlKCcuL3BvbHlmaWxsJyk7XG5cbk9iamVjdC5rZXlzKF9wb2x5ZmlsbCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3BvbHlmaWxsW2tleV07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pO1xuXG52YXIgX2NvcmUgPSByZXF1aXJlKCcuL2NvcmUnKTtcblxuT2JqZWN0LmtleXMoX2NvcmUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIF9jb3JlW2tleV07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pO1xuXG52YXIgX2RlcHJlY2F0aW9uID0gcmVxdWlyZSgnLi9kZXByZWNhdGlvbicpO1xuXG52YXIgX2RlcHJlY2F0aW9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RlcHJlY2F0aW9uKTtcblxudmFyIF9hY2Nlc3NpYmlsaXR5ID0gcmVxdWlyZSgnLi9hY2Nlc3NpYmlsaXR5Jyk7XG5cbnZhciBhY2Nlc3NpYmlsaXR5ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX2FjY2Vzc2liaWxpdHkpO1xuXG52YXIgX2V4dHJhY3QgPSByZXF1aXJlKCcuL2V4dHJhY3QnKTtcblxudmFyIGV4dHJhY3QgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfZXh0cmFjdCk7XG5cbnZhciBfZXh0cmFzID0gcmVxdWlyZSgnLi9leHRyYXMnKTtcblxudmFyIGV4dHJhcyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9leHRyYXMpO1xuXG52YXIgX2ZpbHRlcnMgPSByZXF1aXJlKCcuL2ZpbHRlcnMnKTtcblxudmFyIGZpbHRlcnMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfZmlsdGVycyk7XG5cbnZhciBfaW50ZXJhY3Rpb24gPSByZXF1aXJlKCcuL2ludGVyYWN0aW9uJyk7XG5cbnZhciBpbnRlcmFjdGlvbiA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9pbnRlcmFjdGlvbik7XG5cbnZhciBfbG9hZGVycyA9IHJlcXVpcmUoJy4vbG9hZGVycycpO1xuXG52YXIgbG9hZGVycyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9sb2FkZXJzKTtcblxudmFyIF9tZXNoID0gcmVxdWlyZSgnLi9tZXNoJyk7XG5cbnZhciBtZXNoID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX21lc2gpO1xuXG52YXIgX3BhcnRpY2xlcyA9IHJlcXVpcmUoJy4vcGFydGljbGVzJyk7XG5cbnZhciBwYXJ0aWNsZXMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfcGFydGljbGVzKTtcblxudmFyIF9wcmVwYXJlID0gcmVxdWlyZSgnLi9wcmVwYXJlJyk7XG5cbnZhciBwcmVwYXJlID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX3ByZXBhcmUpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vLyBleHBvcnQgY29yZVxuX2NvcmUudXRpbHMubWl4aW5zLnBlcmZvcm1NaXhpbnMoKTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIFBJWEkubG9hZGVycy5zaGFyZWR9LlxuICogQG5hbWUgbG9hZGVyXG4gKiBAbWVtYmVyb2YgUElYSVxuICogQHR5cGUge1BJWEkubG9hZGVyLkxvYWRlcn1cbiAqL1xuXG5cbi8vIGhhbmRsZSBtaXhpbnMgbm93LCBhZnRlciBhbGwgY29kZSBoYXMgYmVlbiBhZGRlZCwgaW5jbHVkaW5nIGRlcHJlY2F0aW9uXG5cblxuLy8gZXhwb3J0IGxpYnNcbi8vIGltcG9ydCBwb2x5ZmlsbHMuIERvbmUgYXMgYW4gZXhwb3J0IHRvIG1ha2Ugc3VyZSBwb2x5ZmlsbHMgYXJlIGltcG9ydGVkIGZpcnN0XG52YXIgbG9hZGVyID0gbG9hZGVycy5zaGFyZWQgfHwgbnVsbDtcblxuZXhwb3J0cy5hY2Nlc3NpYmlsaXR5ID0gYWNjZXNzaWJpbGl0eTtcbmV4cG9ydHMuZXh0cmFjdCA9IGV4dHJhY3Q7XG5leHBvcnRzLmV4dHJhcyA9IGV4dHJhcztcbmV4cG9ydHMuZmlsdGVycyA9IGZpbHRlcnM7XG5leHBvcnRzLmludGVyYWN0aW9uID0gaW50ZXJhY3Rpb247XG5leHBvcnRzLmxvYWRlcnMgPSBsb2FkZXJzO1xuZXhwb3J0cy5tZXNoID0gbWVzaDtcbmV4cG9ydHMucGFydGljbGVzID0gcGFydGljbGVzO1xuZXhwb3J0cy5wcmVwYXJlID0gcHJlcGFyZTtcbmV4cG9ydHMubG9hZGVyID0gbG9hZGVyO1xuXG4vLyBBcHBseSB0aGUgZGVwcmVjYXRpb25zXG5cbmlmICh0eXBlb2YgX2RlcHJlY2F0aW9uMi5kZWZhdWx0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgKDAsIF9kZXByZWNhdGlvbjIuZGVmYXVsdCkoZXhwb3J0cyk7XG59XG5cbi8vIEFsd2F5cyBleHBvcnQgUGl4aUpTIGdsb2JhbGx5LlxuZ2xvYmFsLlBJWEkgPSBleHBvcnRzOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfY29yZSA9IHJlcXVpcmUoJy4uL2NvcmUnKTtcblxudmFyIGNvcmUgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfY29yZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8qKlxuICogSG9sZHMgYWxsIGluZm9ybWF0aW9uIHJlbGF0ZWQgdG8gYW4gSW50ZXJhY3Rpb24gZXZlbnRcbiAqXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQSVhJLmludGVyYWN0aW9uXG4gKi9cbnZhciBJbnRlcmFjdGlvbkRhdGEgPSBmdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKlxuICAgKi9cbiAgZnVuY3Rpb24gSW50ZXJhY3Rpb25EYXRhKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbnRlcmFjdGlvbkRhdGEpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBwb2ludCBzdG9yZXMgdGhlIGdsb2JhbCBjb29yZHMgb2Ygd2hlcmUgdGhlIHRvdWNoL21vdXNlIGV2ZW50IGhhcHBlbmVkXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtQSVhJLlBvaW50fVxuICAgICAqL1xuICAgIHRoaXMuZ2xvYmFsID0gbmV3IGNvcmUuUG9pbnQoKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB0YXJnZXQgRGlzcGxheU9iamVjdCB0aGF0IHdhcyBpbnRlcmFjdGVkIHdpdGhcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge1BJWEkuRGlzcGxheU9iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLnRhcmdldCA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHBhc3NlZCB0byBhbiBldmVudCBoYW5kbGVyLCB0aGlzIHdpbGwgYmUgdGhlIG9yaWdpbmFsIERPTSBFdmVudCB0aGF0IHdhcyBjYXB0dXJlZFxuICAgICAqXG4gICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTW91c2VFdmVudFxuICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1RvdWNoRXZlbnRcbiAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Qb2ludGVyRXZlbnRcbiAgICAgKiBAbWVtYmVyIHtNb3VzZUV2ZW50fFRvdWNoRXZlbnR8UG9pbnRlckV2ZW50fVxuICAgICAqL1xuICAgIHRoaXMub3JpZ2luYWxFdmVudCA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhpcyBpbnRlcmFjdGlvblxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuaWRlbnRpZmllciA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciBvciBub3QgdGhlIHBvaW50ZXIgZGV2aWNlIHRoYXQgY3JlYXRlZCB0aGUgZXZlbnQgaXMgdGhlIHByaW1hcnkgcG9pbnRlci5cbiAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Qb2ludGVyRXZlbnQvaXNQcmltYXJ5XG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5pc1ByaW1hcnkgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGljaCBidXR0b24gd2FzIHByZXNzZWQgb24gdGhlIG1vdXNlIG9yIHBvaW50ZXIgZGV2aWNlIHRvIHRyaWdnZXIgdGhlIGV2ZW50LlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL01vdXNlRXZlbnQvYnV0dG9uXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmJ1dHRvbiA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hpY2ggYnV0dG9ucyBhcmUgcHJlc3NlZCBvbiB0aGUgbW91c2Ugb3IgcG9pbnRlciBkZXZpY2Ugd2hlbiB0aGUgZXZlbnQgaXMgdHJpZ2dlcmVkLlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL01vdXNlRXZlbnQvYnV0dG9uc1xuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5idXR0b25zID0gMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSB3aWR0aCBvZiB0aGUgcG9pbnRlcidzIGNvbnRhY3QgYWxvbmcgdGhlIHgtYXhpcywgbWVhc3VyZWQgaW4gQ1NTIHBpeGVscy5cbiAgICAgKiByYWRpdXNYIG9mIFRvdWNoRXZlbnRzIHdpbGwgYmUgcmVwcmVzZW50ZWQgYnkgdGhpcyB2YWx1ZS5cbiAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Qb2ludGVyRXZlbnQvd2lkdGhcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMud2lkdGggPSAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGhlaWdodCBvZiB0aGUgcG9pbnRlcidzIGNvbnRhY3QgYWxvbmcgdGhlIHktYXhpcywgbWVhc3VyZWQgaW4gQ1NTIHBpeGVscy5cbiAgICAgKiByYWRpdXNZIG9mIFRvdWNoRXZlbnRzIHdpbGwgYmUgcmVwcmVzZW50ZWQgYnkgdGhpcyB2YWx1ZS5cbiAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Qb2ludGVyRXZlbnQvaGVpZ2h0XG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmhlaWdodCA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYW5nbGUsIGluIGRlZ3JlZXMsIGJldHdlZW4gdGhlIHBvaW50ZXIgZGV2aWNlIGFuZCB0aGUgc2NyZWVuLlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1BvaW50ZXJFdmVudC90aWx0WFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy50aWx0WCA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYW5nbGUsIGluIGRlZ3JlZXMsIGJldHdlZW4gdGhlIHBvaW50ZXIgZGV2aWNlIGFuZCB0aGUgc2NyZWVuLlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1BvaW50ZXJFdmVudC90aWx0WVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy50aWx0WSA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBvZiBwb2ludGVyIHRoYXQgdHJpZ2dlcmVkIHRoZSBldmVudC5cbiAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Qb2ludGVyRXZlbnQvcG9pbnRlclR5cGVcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMucG9pbnRlclR5cGUgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogUHJlc3N1cmUgYXBwbGllZCBieSB0aGUgcG9pbnRpbmcgZGV2aWNlIGR1cmluZyB0aGUgZXZlbnQuIEEgVG91Y2gncyBmb3JjZSBwcm9wZXJ0eVxuICAgICAqIHdpbGwgYmUgcmVwcmVzZW50ZWQgYnkgdGhpcyB2YWx1ZS5cbiAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Qb2ludGVyRXZlbnQvcHJlc3N1cmVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucHJlc3N1cmUgPSAwO1xuXG4gICAgLyoqXG4gICAgICogRnJvbSBUb3VjaEV2ZW50cyAobm90IFBvaW50ZXJFdmVudHMgdHJpZ2dlcmVkIGJ5IHRvdWNoZXMpLCB0aGUgcm90YXRpb25BbmdsZSBvZiB0aGUgVG91Y2guXG4gICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvVG91Y2gvcm90YXRpb25BbmdsZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5yb3RhdGlvbkFuZ2xlID0gMDtcblxuICAgIC8qKlxuICAgICAqIFR3aXN0IG9mIGEgc3R5bHVzIHBvaW50ZXIuXG4gICAgICogQHNlZSBodHRwczovL3czYy5naXRodWIuaW8vcG9pbnRlcmV2ZW50cy8jcG9pbnRlcmV2ZW50LWludGVyZmFjZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy50d2lzdCA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBCYXJyZWwgcHJlc3N1cmUgb24gYSBzdHlsdXMgcG9pbnRlci5cbiAgICAgKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9wb2ludGVyZXZlbnRzLyNwb2ludGVyZXZlbnQtaW50ZXJmYWNlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnRhbmdlbnRpYWxQcmVzc3VyZSA9IDA7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSBwb2ludGVyLiBJdCB3aWxsIGJlIHRoZSBzYW1lIGFzIGBpZGVudGlmaWVyYC5cbiAgICogQHJlYWRvbmx5XG4gICAqIEBtZW1iZXIge251bWJlcn1cbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvUG9pbnRlckV2ZW50L3BvaW50ZXJJZFxuICAgKi9cblxuXG4gIC8qKlxuICAgKiBUaGlzIHdpbGwgcmV0dXJuIHRoZSBsb2NhbCBjb29yZGluYXRlcyBvZiB0aGUgc3BlY2lmaWVkIGRpc3BsYXlPYmplY3QgZm9yIHRoaXMgSW50ZXJhY3Rpb25EYXRhXG4gICAqXG4gICAqIEBwYXJhbSB7UElYSS5EaXNwbGF5T2JqZWN0fSBkaXNwbGF5T2JqZWN0IC0gVGhlIERpc3BsYXlPYmplY3QgdGhhdCB5b3Ugd291bGQgbGlrZSB0aGUgbG9jYWxcbiAgICogIGNvb3JkcyBvZmZcbiAgICogQHBhcmFtIHtQSVhJLlBvaW50fSBbcG9pbnRdIC0gQSBQb2ludCBvYmplY3QgaW4gd2hpY2ggdG8gc3RvcmUgdGhlIHZhbHVlLCBvcHRpb25hbCAob3RoZXJ3aXNlXG4gICAqICB3aWxsIGNyZWF0ZSBhIG5ldyBwb2ludClcbiAgICogQHBhcmFtIHtQSVhJLlBvaW50fSBbZ2xvYmFsUG9zXSAtIEEgUG9pbnQgb2JqZWN0IGNvbnRhaW5pbmcgeW91ciBjdXN0b20gZ2xvYmFsIGNvb3Jkcywgb3B0aW9uYWxcbiAgICogIChvdGhlcndpc2Ugd2lsbCB1c2UgdGhlIGN1cnJlbnQgZ2xvYmFsIGNvb3JkcylcbiAgICogQHJldHVybiB7UElYSS5Qb2ludH0gQSBwb2ludCBjb250YWluaW5nIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgSW50ZXJhY3Rpb25EYXRhIHBvc2l0aW9uIHJlbGF0aXZlXG4gICAqICB0byB0aGUgRGlzcGxheU9iamVjdFxuICAgKi9cbiAgSW50ZXJhY3Rpb25EYXRhLnByb3RvdHlwZS5nZXRMb2NhbFBvc2l0aW9uID0gZnVuY3Rpb24gZ2V0TG9jYWxQb3NpdGlvbihkaXNwbGF5T2JqZWN0LCBwb2ludCwgZ2xvYmFsUG9zKSB7XG4gICAgcmV0dXJuIGRpc3BsYXlPYmplY3Qud29ybGRUcmFuc2Zvcm0uYXBwbHlJbnZlcnNlKGdsb2JhbFBvcyB8fCB0aGlzLmdsb2JhbCwgcG9pbnQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDb3BpZXMgcHJvcGVydGllcyBmcm9tIG5vcm1hbGl6ZWQgZXZlbnQgZGF0YS5cbiAgICpcbiAgICogQHBhcmFtIHtUb3VjaHxNb3VzZUV2ZW50fFBvaW50ZXJFdmVudH0gZXZlbnQgVGhlIG5vcm1hbGl6ZWQgZXZlbnQgZGF0YVxuICAgKi9cblxuXG4gIEludGVyYWN0aW9uRGF0YS5wcm90b3R5cGUuY29weUV2ZW50ID0gZnVuY3Rpb24gY29weUV2ZW50KGV2ZW50KSB7XG4gICAgLy8gaXNQcmltYXJ5IHNob3VsZCBvbmx5IGNoYW5nZSBvbiB0b3VjaHN0YXJ0L3BvaW50ZXJkb3duLCBzbyB3ZSBkb24ndCB3YW50IHRvIG92ZXJ3cml0ZVxuICAgIC8vIGl0IHdpdGggXCJmYWxzZVwiIG9uIGxhdGVyIGV2ZW50cyB3aGVuIG91ciBzaGltIGZvciBpdCBvbiB0b3VjaCBldmVudHMgbWlnaHQgbm90IGJlXG4gICAgLy8gYWNjdXJhdGVcbiAgICBpZiAoZXZlbnQuaXNQcmltYXJ5KSB7XG4gICAgICB0aGlzLmlzUHJpbWFyeSA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuYnV0dG9uID0gZXZlbnQuYnV0dG9uO1xuICAgIC8vIGV2ZW50LmJ1dHRvbnMgaXMgbm90IGF2YWlsYWJsZSBpbiBhbGwgYnJvd3NlcnMgKGllLiBTYWZhcmkpLCBidXQgaXQgZG9lcyBoYXZlIGEgbm9uLXN0YW5kYXJkXG4gICAgLy8gZXZlbnQud2hpY2ggcHJvcGVydHkgaW5zdGVhZCwgd2hpY2ggY29udmV5cyB0aGUgc2FtZSBpbmZvcm1hdGlvbi5cbiAgICB0aGlzLmJ1dHRvbnMgPSBOdW1iZXIuaXNJbnRlZ2VyKGV2ZW50LmJ1dHRvbnMpID8gZXZlbnQuYnV0dG9ucyA6IGV2ZW50LndoaWNoO1xuICAgIHRoaXMud2lkdGggPSBldmVudC53aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGV2ZW50LmhlaWdodDtcbiAgICB0aGlzLnRpbHRYID0gZXZlbnQudGlsdFg7XG4gICAgdGhpcy50aWx0WSA9IGV2ZW50LnRpbHRZO1xuICAgIHRoaXMucG9pbnRlclR5cGUgPSBldmVudC5wb2ludGVyVHlwZTtcbiAgICB0aGlzLnByZXNzdXJlID0gZXZlbnQucHJlc3N1cmU7XG4gICAgdGhpcy5yb3RhdGlvbkFuZ2xlID0gZXZlbnQucm90YXRpb25BbmdsZTtcbiAgICB0aGlzLnR3aXN0ID0gZXZlbnQudHdpc3QgfHwgMDtcbiAgICB0aGlzLnRhbmdlbnRpYWxQcmVzc3VyZSA9IGV2ZW50LnRhbmdlbnRpYWxQcmVzc3VyZSB8fCAwO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXNldHMgdGhlIGRhdGEgZm9yIHBvb2xpbmcuXG4gICAqL1xuXG5cbiAgSW50ZXJhY3Rpb25EYXRhLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIC8vIGlzUHJpbWFyeSBpcyB0aGUgb25seSBwcm9wZXJ0eSB0aGF0IHdlIHJlYWxseSBuZWVkIHRvIHJlc2V0IC0gZXZlcnl0aGluZyBlbHNlIGlzXG4gICAgLy8gZ3VhcmFudGVlZCB0byBiZSBvdmVyd3JpdHRlblxuICAgIHRoaXMuaXNQcmltYXJ5ID0gZmFsc2U7XG4gIH07XG5cbiAgX2NyZWF0ZUNsYXNzKEludGVyYWN0aW9uRGF0YSwgW3tcbiAgICBrZXk6ICdwb2ludGVySWQnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuaWRlbnRpZmllcjtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gSW50ZXJhY3Rpb25EYXRhO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBJbnRlcmFjdGlvbkRhdGE7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1JbnRlcmFjdGlvbkRhdGEuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8qKlxuICogRXZlbnQgY2xhc3MgdGhhdCBtaW1pY3MgbmF0aXZlIERPTSBldmVudHMuXG4gKlxuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgUElYSS5pbnRlcmFjdGlvblxuICovXG52YXIgSW50ZXJhY3Rpb25FdmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqXG4gICAqL1xuICBmdW5jdGlvbiBJbnRlcmFjdGlvbkV2ZW50KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbnRlcmFjdGlvbkV2ZW50KTtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhpcyBldmVudCB3aWxsIGNvbnRpbnVlIHByb3BhZ2F0aW5nIGluIHRoZSB0cmVlXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuc3RvcHBlZCA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG9iamVjdCB3aGljaCBjYXVzZWQgdGhpcyBldmVudCB0byBiZSBkaXNwYXRjaGVkLlxuICAgICAqIEZvciBsaXN0ZW5lciBjYWxsYmFjayBzZWUge0BsaW5rIFBJWEkuaW50ZXJhY3Rpb24uSW50ZXJhY3Rpb25FdmVudC5jdXJyZW50VGFyZ2V0fS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge1BJWEkuRGlzcGxheU9iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLnRhcmdldCA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb2JqZWN0IHdob3NlIGV2ZW50IGxpc3RlbmVy4oCZcyBjYWxsYmFjayBpcyBjdXJyZW50bHkgYmVpbmcgaW52b2tlZC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge1BJWEkuRGlzcGxheU9iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLmN1cnJlbnRUYXJnZXQgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVHlwZSBvZiB0aGUgZXZlbnRcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnR5cGUgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogSW50ZXJhY3Rpb25EYXRhIHJlbGF0ZWQgdG8gdGhpcyBldmVudFxuICAgICAqXG4gICAgICogQG1lbWJlciB7UElYSS5pbnRlcmFjdGlvbi5JbnRlcmFjdGlvbkRhdGF9XG4gICAgICovXG4gICAgdGhpcy5kYXRhID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcmV2ZW50cyBldmVudCBmcm9tIHJlYWNoaW5nIGFueSBvYmplY3RzIG90aGVyIHRoYW4gdGhlIGN1cnJlbnQgb2JqZWN0LlxuICAgKlxuICAgKi9cblxuXG4gIEludGVyYWN0aW9uRXZlbnQucHJvdG90eXBlLnN0b3BQcm9wYWdhdGlvbiA9IGZ1bmN0aW9uIHN0b3BQcm9wYWdhdGlvbigpIHtcbiAgICB0aGlzLnN0b3BwZWQgPSB0cnVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXNldHMgdGhlIGV2ZW50LlxuICAgKi9cblxuXG4gIEludGVyYWN0aW9uRXZlbnQucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgdGhpcy5zdG9wcGVkID0gZmFsc2U7XG4gICAgdGhpcy5jdXJyZW50VGFyZ2V0ID0gbnVsbDtcbiAgICB0aGlzLnRhcmdldCA9IG51bGw7XG4gIH07XG5cbiAgcmV0dXJuIEludGVyYWN0aW9uRXZlbnQ7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEludGVyYWN0aW9uRXZlbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1JbnRlcmFjdGlvbkV2ZW50LmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgX2NvcmUgPSByZXF1aXJlKCcuLi9jb3JlJyk7XG5cbnZhciBjb3JlID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX2NvcmUpO1xuXG52YXIgX0ludGVyYWN0aW9uRGF0YSA9IHJlcXVpcmUoJy4vSW50ZXJhY3Rpb25EYXRhJyk7XG5cbnZhciBfSW50ZXJhY3Rpb25EYXRhMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0ludGVyYWN0aW9uRGF0YSk7XG5cbnZhciBfSW50ZXJhY3Rpb25FdmVudCA9IHJlcXVpcmUoJy4vSW50ZXJhY3Rpb25FdmVudCcpO1xuXG52YXIgX0ludGVyYWN0aW9uRXZlbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfSW50ZXJhY3Rpb25FdmVudCk7XG5cbnZhciBfSW50ZXJhY3Rpb25UcmFja2luZ0RhdGEgPSByZXF1aXJlKCcuL0ludGVyYWN0aW9uVHJhY2tpbmdEYXRhJyk7XG5cbnZhciBfSW50ZXJhY3Rpb25UcmFja2luZ0RhdGEyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfSW50ZXJhY3Rpb25UcmFja2luZ0RhdGEpO1xuXG52YXIgX2V2ZW50ZW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50ZW1pdHRlcjMnKTtcblxudmFyIF9ldmVudGVtaXR0ZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZXZlbnRlbWl0dGVyKTtcblxudmFyIF9pbnRlcmFjdGl2ZVRhcmdldCA9IHJlcXVpcmUoJy4vaW50ZXJhY3RpdmVUYXJnZXQnKTtcblxudmFyIF9pbnRlcmFjdGl2ZVRhcmdldDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbnRlcmFjdGl2ZVRhcmdldCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuLy8gTWl4IGludGVyYWN0aXZlVGFyZ2V0IGludG8gY29yZS5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZSwgYWZ0ZXIgZGVwcmVjYXRpb24gaGFzIGJlZW4gaGFuZGxlZFxuY29yZS51dGlscy5taXhpbnMuZGVsYXlNaXhpbihjb3JlLkRpc3BsYXlPYmplY3QucHJvdG90eXBlLCBfaW50ZXJhY3RpdmVUYXJnZXQyLmRlZmF1bHQpO1xuXG52YXIgTU9VU0VfUE9JTlRFUl9JRCA9IDE7XG5cbi8vIGhlbHBlcnMgZm9yIGhpdFRlc3QoKSAtIG9ubHkgdXNlZCBpbnNpZGUgaGl0VGVzdCgpXG52YXIgaGl0VGVzdEV2ZW50ID0ge1xuICAgIHRhcmdldDogbnVsbCxcbiAgICBkYXRhOiB7XG4gICAgICAgIGdsb2JhbDogbnVsbFxuICAgIH1cbn07XG5cbi8qKlxuICogVGhlIGludGVyYWN0aW9uIG1hbmFnZXIgZGVhbHMgd2l0aCBtb3VzZSwgdG91Y2ggYW5kIHBvaW50ZXIgZXZlbnRzLiBBbnkgRGlzcGxheU9iamVjdCBjYW4gYmUgaW50ZXJhY3RpdmVcbiAqIGlmIGl0cyBpbnRlcmFjdGl2ZSBwYXJhbWV0ZXIgaXMgc2V0IHRvIHRydWVcbiAqIFRoaXMgbWFuYWdlciBhbHNvIHN1cHBvcnRzIG11bHRpdG91Y2guXG4gKlxuICogQW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcyBpcyBhdXRvbWF0aWNhbGx5IGNyZWF0ZWQgYnkgZGVmYXVsdCwgYW5kIGNhbiBiZSBmb3VuZCBhdCByZW5kZXJlci5wbHVnaW5zLmludGVyYWN0aW9uXG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBFdmVudEVtaXR0ZXJcbiAqIEBtZW1iZXJvZiBQSVhJLmludGVyYWN0aW9uXG4gKi9cblxudmFyIEludGVyYWN0aW9uTWFuYWdlciA9IGZ1bmN0aW9uIChfRXZlbnRFbWl0dGVyKSB7XG4gICAgX2luaGVyaXRzKEludGVyYWN0aW9uTWFuYWdlciwgX0V2ZW50RW1pdHRlcik7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1BJWEkuQ2FudmFzUmVuZGVyZXJ8UElYSS5XZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIEEgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IHJlbmRlcmVyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAtIFRoZSBvcHRpb25zIGZvciB0aGUgbWFuYWdlci5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmF1dG9QcmV2ZW50RGVmYXVsdD10cnVlXSAtIFNob3VsZCB0aGUgbWFuYWdlciBhdXRvbWF0aWNhbGx5IHByZXZlbnQgZGVmYXVsdCBicm93c2VyIGFjdGlvbnMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmludGVyYWN0aW9uRnJlcXVlbmN5PTEwXSAtIEZyZXF1ZW5jeSBpbmNyZWFzZXMgdGhlIGludGVyYWN0aW9uIGV2ZW50cyB3aWxsIGJlIGNoZWNrZWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gSW50ZXJhY3Rpb25NYW5hZ2VyKHJlbmRlcmVyLCBvcHRpb25zKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbnRlcmFjdGlvbk1hbmFnZXIpO1xuXG4gICAgICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9FdmVudEVtaXR0ZXIuY2FsbCh0aGlzKSk7XG5cbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSByZW5kZXJlciB0aGlzIGludGVyYWN0aW9uIG1hbmFnZXIgd29ya3MgZm9yLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLlN5c3RlbVJlbmRlcmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2hvdWxkIGRlZmF1bHQgYnJvd3NlciBhY3Rpb25zIGF1dG9tYXRpY2FsbHkgYmUgcHJldmVudGVkLlxuICAgICAgICAgKiBEb2VzIG5vdCBhcHBseSB0byBwb2ludGVyIGV2ZW50cyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICAgICAgICogcHJldmVudERlZmF1bHQgb24gcG9pbnRlciBldmVudHMgc3RvcHMgbW91c2UgZXZlbnRzIGZyb20gZmlyaW5nXG4gICAgICAgICAqIFRodXMsIGZvciBldmVyeSBwb2ludGVyIGV2ZW50LCB0aGVyZSB3aWxsIGFsd2F5cyBiZSBlaXRoZXIgYSBtb3VzZSBvZiB0b3VjaCBldmVudCBhbG9uZ3NpZGUgaXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLmF1dG9QcmV2ZW50RGVmYXVsdCA9IG9wdGlvbnMuYXV0b1ByZXZlbnREZWZhdWx0ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmF1dG9QcmV2ZW50RGVmYXVsdCA6IHRydWU7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZyZXF1ZW5jeSBpbiBtaWxsaXNlY29uZHMgdGhhdCB0aGUgbW91c2Vtb3ZlLCBtb3Zlb3ZlciAmIG1vdXNlb3V0IGludGVyYWN0aW9uIGV2ZW50cyB3aWxsIGJlIGNoZWNrZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMTBcbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLmludGVyYWN0aW9uRnJlcXVlbmN5ID0gb3B0aW9ucy5pbnRlcmFjdGlvbkZyZXF1ZW5jeSB8fCAxMDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG1vdXNlIGRhdGFcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5pbnRlcmFjdGlvbi5JbnRlcmFjdGlvbkRhdGF9XG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5tb3VzZSA9IG5ldyBfSW50ZXJhY3Rpb25EYXRhMi5kZWZhdWx0KCk7XG4gICAgICAgIF90aGlzLm1vdXNlLmlkZW50aWZpZXIgPSBNT1VTRV9QT0lOVEVSX0lEO1xuXG4gICAgICAgIC8vIHNldHRpbmcgdGhlIG1vdXNlIHRvIHN0YXJ0IG9mZiBmYXIgb2ZmIHNjcmVlbiB3aWxsIG1lYW4gdGhhdCBtb3VzZSBvdmVyIGRvZXNcbiAgICAgICAgLy8gIG5vdCBnZXQgY2FsbGVkIGJlZm9yZSB3ZSBldmVuIG1vdmUgdGhlIG1vdXNlLlxuICAgICAgICBfdGhpcy5tb3VzZS5nbG9iYWwuc2V0KC05OTk5OTkpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBY3RpdmVseSB0cmFja2VkIEludGVyYWN0aW9uRGF0YVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3QuPG51bWJlcixQSVhJLmludGVyYXRpb24uSW50ZXJhY3Rpb25EYXRhPn1cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLmFjdGl2ZUludGVyYWN0aW9uRGF0YSA9IHt9O1xuICAgICAgICBfdGhpcy5hY3RpdmVJbnRlcmFjdGlvbkRhdGFbTU9VU0VfUE9JTlRFUl9JRF0gPSBfdGhpcy5tb3VzZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUG9vbCBvZiB1bnVzZWQgSW50ZXJhY3Rpb25EYXRhXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuaW50ZXJhdGlvbi5JbnRlcmFjdGlvbkRhdGFbXX1cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLmludGVyYWN0aW9uRGF0YVBvb2wgPSBbXTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQW4gZXZlbnQgZGF0YSBvYmplY3QgdG8gaGFuZGxlIGFsbCB0aGUgZXZlbnQgdHJhY2tpbmcvZGlzcGF0Y2hpbmdcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7b2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuZXZlbnREYXRhID0gbmV3IF9JbnRlcmFjdGlvbkV2ZW50Mi5kZWZhdWx0KCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBET00gZWxlbWVudCB0byBiaW5kIHRvLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAbWVtYmVyIHtIVE1MRWxlbWVudH1cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudCA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgcHJvcGVydHkgZGV0ZXJtaW5lcyBpZiBtb3VzZW1vdmUgYW5kIHRvdWNobW92ZSBldmVudHMgYXJlIGZpcmVkIG9ubHkgd2hlbiB0aGUgY3Vyc29yXG4gICAgICAgICAqIGlzIG92ZXIgdGhlIG9iamVjdC5cbiAgICAgICAgICogU2V0dGluZyB0byB0cnVlIHdpbGwgbWFrZSB0aGluZ3Mgd29yayBtb3JlIGluIGxpbmUgd2l0aCBob3cgdGhlIERPTSB2ZXJpc29uIHdvcmtzLlxuICAgICAgICAgKiBTZXR0aW5nIHRvIGZhbHNlIGNhbiBtYWtlIHRoaW5ncyBlYXNpZXIgZm9yIHRoaW5ncyBsaWtlIGRyYWdnaW5nXG4gICAgICAgICAqIEl0IGlzIGN1cnJlbnRseSBzZXQgdG8gZmFsc2UgYXMgdGhpcyBpcyBob3cgUGl4aUpTIHVzZWQgdG8gd29yay4gVGhpcyB3aWxsIGJlIHNldCB0byB0cnVlIGluXG4gICAgICAgICAqIGZ1dHVyZSB2ZXJzaW9ucyBvZiBwaXhpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMubW92ZVdoZW5JbnNpZGUgPSBmYWxzZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSGF2ZSBldmVudHMgYmVlbiBhdHRhY2hlZCB0byB0aGUgZG9tIGVsZW1lbnQ/XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5ldmVudHNBZGRlZCA9IGZhbHNlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJcyB0aGUgbW91c2UgaG92ZXJpbmcgb3ZlciB0aGUgcmVuZGVyZXI/XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5tb3VzZU92ZXJSZW5kZXJlciA9IGZhbHNlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEb2VzIHRoZSBkZXZpY2Ugc3VwcG9ydCB0b3VjaCBldmVudHNcbiAgICAgICAgICogaHR0cHM6Ly93d3cudzMub3JnL1RSL3RvdWNoLWV2ZW50cy9cbiAgICAgICAgICpcbiAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5zdXBwb3J0c1RvdWNoRXZlbnRzID0gJ29udG91Y2hzdGFydCcgaW4gd2luZG93O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEb2VzIHRoZSBkZXZpY2Ugc3VwcG9ydCBwb2ludGVyIGV2ZW50c1xuICAgICAgICAgKiBodHRwczovL3d3dy53My5vcmcvU3VibWlzc2lvbi9wb2ludGVyLWV2ZW50cy9cbiAgICAgICAgICpcbiAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5zdXBwb3J0c1BvaW50ZXJFdmVudHMgPSAhIXdpbmRvdy5Qb2ludGVyRXZlbnQ7XG5cbiAgICAgICAgLy8gdGhpcyB3aWxsIG1ha2UgaXQgc28gdGhhdCB5b3UgZG9uJ3QgaGF2ZSB0byBjYWxsIGJpbmQgYWxsIHRoZSB0aW1lXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBtZW1iZXIge0Z1bmN0aW9ufVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMub25Qb2ludGVyVXAgPSBfdGhpcy5vblBvaW50ZXJVcC5iaW5kKF90aGlzKTtcbiAgICAgICAgX3RoaXMucHJvY2Vzc1BvaW50ZXJVcCA9IF90aGlzLnByb2Nlc3NQb2ludGVyVXAuYmluZChfdGhpcyk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBtZW1iZXIge0Z1bmN0aW9ufVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMub25Qb2ludGVyQ2FuY2VsID0gX3RoaXMub25Qb2ludGVyQ2FuY2VsLmJpbmQoX3RoaXMpO1xuICAgICAgICBfdGhpcy5wcm9jZXNzUG9pbnRlckNhbmNlbCA9IF90aGlzLnByb2Nlc3NQb2ludGVyQ2FuY2VsLmJpbmQoX3RoaXMpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAbWVtYmVyIHtGdW5jdGlvbn1cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLm9uUG9pbnRlckRvd24gPSBfdGhpcy5vblBvaW50ZXJEb3duLmJpbmQoX3RoaXMpO1xuICAgICAgICBfdGhpcy5wcm9jZXNzUG9pbnRlckRvd24gPSBfdGhpcy5wcm9jZXNzUG9pbnRlckRvd24uYmluZChfdGhpcyk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBtZW1iZXIge0Z1bmN0aW9ufVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMub25Qb2ludGVyTW92ZSA9IF90aGlzLm9uUG9pbnRlck1vdmUuYmluZChfdGhpcyk7XG4gICAgICAgIF90aGlzLnByb2Nlc3NQb2ludGVyTW92ZSA9IF90aGlzLnByb2Nlc3NQb2ludGVyTW92ZS5iaW5kKF90aGlzKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQG1lbWJlciB7RnVuY3Rpb259XG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5vblBvaW50ZXJPdXQgPSBfdGhpcy5vblBvaW50ZXJPdXQuYmluZChfdGhpcyk7XG4gICAgICAgIF90aGlzLnByb2Nlc3NQb2ludGVyT3Zlck91dCA9IF90aGlzLnByb2Nlc3NQb2ludGVyT3Zlck91dC5iaW5kKF90aGlzKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQG1lbWJlciB7RnVuY3Rpb259XG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5vblBvaW50ZXJPdmVyID0gX3RoaXMub25Qb2ludGVyT3Zlci5iaW5kKF90aGlzKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGljdGlvbmFyeSBvZiBob3cgZGlmZmVyZW50IGN1cnNvciBtb2RlcyBhcmUgaGFuZGxlZC4gU3RyaW5ncyBhcmUgaGFuZGxlZCBhcyBDU1MgY3Vyc29yXG4gICAgICAgICAqIHZhbHVlcywgb2JqZWN0cyBhcmUgaGFuZGxlZCBhcyBkaWN0aW9uYXJpZXMgb2YgQ1NTIHZhbHVlcyBmb3IgaW50ZXJhY3Rpb25ET01FbGVtZW50LFxuICAgICAgICAgKiBhbmQgZnVuY3Rpb25zIGFyZSBjYWxsZWQgaW5zdGVhZCBvZiBjaGFuZ2luZyB0aGUgQ1NTLlxuICAgICAgICAgKiBEZWZhdWx0IENTUyBjdXJzb3IgdmFsdWVzIGFyZSBwcm92aWRlZCBmb3IgJ2RlZmF1bHQnIGFuZCAncG9pbnRlcicgbW9kZXMuXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdC48c3RyaW5nLCAoc3RyaW5nfEZ1bmN0aW9ufE9iamVjdC48c3RyaW5nLCBzdHJpbmc+KT59XG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5jdXJzb3JTdHlsZXMgPSB7XG4gICAgICAgICAgICBkZWZhdWx0OiAnaW5oZXJpdCcsXG4gICAgICAgICAgICBwb2ludGVyOiAncG9pbnRlcidcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG1vZGUgb2YgdGhlIGN1cnNvciB0aGF0IGlzIGJlaW5nIHVzZWQuXG4gICAgICAgICAqIFRoZSB2YWx1ZSBvZiB0aGlzIGlzIGEga2V5IGZyb20gdGhlIGN1cnNvclN0eWxlcyBkaWN0aW9uYXJ5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5jdXJyZW50Q3Vyc29yTW9kZSA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEludGVybmFsIGNhY2hlZCBsZXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBtZW1iZXIge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLmN1cnNvciA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEludGVybmFsIGNhY2hlZCBsZXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuUG9pbnR9XG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5fdGVtcFBvaW50ID0gbmV3IGNvcmUuUG9pbnQoKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGN1cnJlbnQgcmVzb2x1dGlvbiAvIGRldmljZSBwaXhlbCByYXRpby5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAxXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5yZXNvbHV0aW9uID0gMTtcblxuICAgICAgICBfdGhpcy5zZXRUYXJnZXRFbGVtZW50KF90aGlzLnJlbmRlcmVyLnZpZXcsIF90aGlzLnJlbmRlcmVyLnJlc29sdXRpb24pO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlZCB3aGVuIGEgcG9pbnRlciBkZXZpY2UgYnV0dG9uICh1c3VhbGx5IGEgbW91c2UgbGVmdC1idXR0b24pIGlzIHByZXNzZWQgb24gdGhlIGRpc3BsYXlcbiAgICAgICAgICogb2JqZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXZlbnQgUElYSS5pbnRlcmFjdGlvbi5JbnRlcmFjdGlvbk1hbmFnZXIjbW91c2Vkb3duXG4gICAgICAgICAqIEBwYXJhbSB7UElYSS5pbnRlcmFjdGlvbi5JbnRlcmFjdGlvbkV2ZW50fSBldmVudCAtIEludGVyYWN0aW9uIGV2ZW50XG4gICAgICAgICAqL1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlZCB3aGVuIGEgcG9pbnRlciBkZXZpY2Ugc2Vjb25kYXJ5IGJ1dHRvbiAodXN1YWxseSBhIG1vdXNlIHJpZ2h0LWJ1dHRvbikgaXMgcHJlc3NlZFxuICAgICAgICAgKiBvbiB0aGUgZGlzcGxheSBvYmplY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBldmVudCBQSVhJLmludGVyYWN0aW9uLkludGVyYWN0aW9uTWFuYWdlciNyaWdodGRvd25cbiAgICAgICAgICogQHBhcmFtIHtQSVhJLmludGVyYWN0aW9uLkludGVyYWN0aW9uRXZlbnR9IGV2ZW50IC0gSW50ZXJhY3Rpb24gZXZlbnRcbiAgICAgICAgICovXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVkIHdoZW4gYSBwb2ludGVyIGRldmljZSBidXR0b24gKHVzdWFsbHkgYSBtb3VzZSBsZWZ0LWJ1dHRvbikgaXMgcmVsZWFzZWQgb3ZlciB0aGUgZGlzcGxheVxuICAgICAgICAgKiBvYmplY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBldmVudCBQSVhJLmludGVyYWN0aW9uLkludGVyYWN0aW9uTWFuYWdlciNtb3VzZXVwXG4gICAgICAgICAqIEBwYXJhbSB7UElYSS5pbnRlcmFjdGlvbi5JbnRlcmFjdGlvbkV2ZW50fSBldmVudCAtIEludGVyYWN0aW9uIGV2ZW50XG4gICAgICAgICAqL1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlZCB3aGVuIGEgcG9pbnRlciBkZXZpY2Ugc2Vjb25kYXJ5IGJ1dHRvbiAodXN1YWxseSBhIG1vdXNlIHJpZ2h0LWJ1dHRvbikgaXMgcmVsZWFzZWRcbiAgICAgICAgICogb3ZlciB0aGUgZGlzcGxheSBvYmplY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBldmVudCBQSVhJLmludGVyYWN0aW9uLkludGVyYWN0aW9uTWFuYWdlciNyaWdodHVwXG4gICAgICAgICAqIEBwYXJhbSB7UElYSS5pbnRlcmFjdGlvbi5JbnRlcmFjdGlvbkV2ZW50fSBldmVudCAtIEludGVyYWN0aW9uIGV2ZW50XG4gICAgICAgICAqL1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlZCB3aGVuIGEgcG9pbnRlciBkZXZpY2UgYnV0dG9uICh1c3VhbGx5IGEgbW91c2UgbGVmdC1idXR0b24pIGlzIHByZXNzZWQgYW5kIHJlbGVhc2VkIG9uXG4gICAgICAgICAqIHRoZSBkaXNwbGF5IG9iamVjdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV2ZW50IFBJWEkuaW50ZXJhY3Rpb24uSW50ZXJhY3Rpb25NYW5hZ2VyI2NsaWNrXG4gICAgICAgICAqIEBwYXJhbSB7UElYSS5pbnRlcmFjdGlvbi5JbnRlcmFjdGlvbkV2ZW50fSBldmVudCAtIEludGVyYWN0aW9uIGV2ZW50XG4gICAgICAgICAqL1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlZCB3aGVuIGEgcG9pbnRlciBkZXZpY2Ugc2Vjb25kYXJ5IGJ1dHRvbiAodXN1YWxseSBhIG1vdXNlIHJpZ2h0LWJ1dHRvbikgaXMgcHJlc3NlZFxuICAgICAgICAgKiBhbmQgcmVsZWFzZWQgb24gdGhlIGRpc3BsYXkgb2JqZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXZlbnQgUElYSS5pbnRlcmFjdGlvbi5JbnRlcmFjdGlvbk1hbmFnZXIjcmlnaHRjbGlja1xuICAgICAgICAgKiBAcGFyYW0ge1BJWEkuaW50ZXJhY3Rpb24uSW50ZXJhY3Rpb25FdmVudH0gZXZlbnQgLSBJbnRlcmFjdGlvbiBldmVudFxuICAgICAgICAgKi9cblxuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZWQgd2hlbiBhIHBvaW50ZXIgZGV2aWNlIGJ1dHRvbiAodXN1YWxseSBhIG1vdXNlIGxlZnQtYnV0dG9uKSBpcyByZWxlYXNlZCBvdXRzaWRlIHRoZVxuICAgICAgICAgKiBkaXNwbGF5IG9iamVjdCB0aGF0IGluaXRpYWxseSByZWdpc3RlcmVkIGFcbiAgICAgICAgICogW21vdXNlZG93bl17QGxpbmsgUElYSS5pbnRlcmFjdGlvbi5JbnRlcmFjdGlvbk1hbmFnZXIjZXZlbnQ6bW91c2Vkb3dufS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV2ZW50IFBJWEkuaW50ZXJhY3Rpb24uSW50ZXJhY3Rpb25NYW5hZ2VyI21vdXNldXBvdXRzaWRlXG4gICAgICAgICAqIEBwYXJhbSB7UElYSS5pbnRlcmFjdGlvbi5JbnRlcmFjdGlvbkV2ZW50fSBldmVudCAtIEludGVyYWN0aW9uIGV2ZW50XG4gICAgICAgICAqL1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlZCB3aGVuIGEgcG9pbnRlciBkZXZpY2Ugc2Vjb25kYXJ5IGJ1dHRvbiAodXN1YWxseSBhIG1vdXNlIHJpZ2h0LWJ1dHRvbikgaXMgcmVsZWFzZWRcbiAgICAgICAgICogb3V0c2lkZSB0aGUgZGlzcGxheSBvYmplY3QgdGhhdCBpbml0aWFsbHkgcmVnaXN0ZXJlZCBhXG4gICAgICAgICAqIFtyaWdodGRvd25de0BsaW5rIFBJWEkuaW50ZXJhY3Rpb24uSW50ZXJhY3Rpb25NYW5hZ2VyI2V2ZW50OnJpZ2h0ZG93bn0uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBldmVudCBQSVhJLmludGVyYWN0aW9uLkludGVyYWN0aW9uTWFuYWdlciNyaWdodHVwb3V0c2lkZVxuICAgICAgICAgKiBAcGFyYW0ge1BJWEkuaW50ZXJhY3Rpb24uSW50ZXJhY3Rpb25FdmVudH0gZXZlbnQgLSBJbnRlcmFjdGlvbiBldmVudFxuICAgICAgICAgKi9cblxuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZWQgd2hlbiBhIHBvaW50ZXIgZGV2aWNlICh1c3VhbGx5IGEgbW91c2UpIGlzIG1vdmVkIHdoaWxlIG92ZXIgdGhlIGRpc3BsYXkgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEBldmVudCBQSVhJLmludGVyYWN0aW9uLkludGVyYWN0aW9uTWFuYWdlciNtb3VzZW1vdmVcbiAgICAgICAgICogQHBhcmFtIHtQSVhJLmludGVyYWN0aW9uLkludGVyYWN0aW9uRXZlbnR9IGV2ZW50IC0gSW50ZXJhY3Rpb24gZXZlbnRcbiAgICAgICAgICovXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVkIHdoZW4gYSBwb2ludGVyIGRldmljZSAodXN1YWxseSBhIG1vdXNlKSBpcyBtb3ZlZCBvbnRvIHRoZSBkaXNwbGF5IG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXZlbnQgUElYSS5pbnRlcmFjdGlvbi5JbnRlcmFjdGlvbk1hbmFnZXIjbW91c2VvdmVyXG4gICAgICAgICAqIEBwYXJhbSB7UElYSS5pbnRlcmFjdGlvbi5JbnRlcmFjdGlvbkV2ZW50fSBldmVudCAtIEludGVyYWN0aW9uIGV2ZW50XG4gICAgICAgICAqL1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlZCB3aGVuIGEgcG9pbnRlciBkZXZpY2UgKHVzdWFsbHkgYSBtb3VzZSkgaXMgbW92ZWQgb2ZmIHRoZSBkaXNwbGF5IG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXZlbnQgUElYSS5pbnRlcmFjdGlvbi5JbnRlcmFjdGlvbk1hbmFnZXIjbW91c2VvdXRcbiAgICAgICAgICogQHBhcmFtIHtQSVhJLmludGVyYWN0aW9uLkludGVyYWN0aW9uRXZlbnR9IGV2ZW50IC0gSW50ZXJhY3Rpb24gZXZlbnRcbiAgICAgICAgICovXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVkIHdoZW4gYSBwb2ludGVyIGRldmljZSBidXR0b24gaXMgcHJlc3NlZCBvbiB0aGUgZGlzcGxheSBvYmplY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBldmVudCBQSVhJLmludGVyYWN0aW9uLkludGVyYWN0aW9uTWFuYWdlciNwb2ludGVyZG93blxuICAgICAgICAgKiBAcGFyYW0ge1BJWEkuaW50ZXJhY3Rpb24uSW50ZXJhY3Rpb25FdmVudH0gZXZlbnQgLSBJbnRlcmFjdGlvbiBldmVudFxuICAgICAgICAgKi9cblxuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZWQgd2hlbiBhIHBvaW50ZXIgZGV2aWNlIGJ1dHRvbiBpcyByZWxlYXNlZCBvdmVyIHRoZSBkaXNwbGF5IG9iamVjdC5cbiAgICAgICAgICogTm90IGFsd2F5cyBmaXJlZCB3aGVuIHNvbWUgYnV0dG9ucyBhcmUgaGVsZCBkb3duIHdoaWxlIG90aGVycyBhcmUgcmVsZWFzZWQuIEluIHRob3NlIGNhc2VzLFxuICAgICAgICAgKiB1c2UgW21vdXNlZG93bl17QGxpbmsgUElYSS5pbnRlcmFjdGlvbi5JbnRlcmFjdGlvbk1hbmFnZXIjZXZlbnQ6bW91c2Vkb3dufSBhbmRcbiAgICAgICAgICogW21vdXNldXBde0BsaW5rIFBJWEkuaW50ZXJhY3Rpb24uSW50ZXJhY3Rpb25NYW5hZ2VyI2V2ZW50Om1vdXNldXB9IGluc3RlYWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBldmVudCBQSVhJLmludGVyYWN0aW9uLkludGVyYWN0aW9uTWFuYWdlciNwb2ludGVydXBcbiAgICAgICAgICogQHBhcmFtIHtQSVhJLmludGVyYWN0aW9uLkludGVyYWN0aW9uRXZlbnR9IGV2ZW50IC0gSW50ZXJhY3Rpb24gZXZlbnRcbiAgICAgICAgICovXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVkIHdoZW4gdGhlIG9wZXJhdGluZyBzeXN0ZW0gY2FuY2VscyBhIHBvaW50ZXIgZXZlbnRcbiAgICAgICAgICpcbiAgICAgICAgICogQGV2ZW50IFBJWEkuaW50ZXJhY3Rpb24uSW50ZXJhY3Rpb25NYW5hZ2VyI3BvaW50ZXJjYW5jZWxcbiAgICAgICAgICogQHBhcmFtIHtQSVhJLmludGVyYWN0aW9uLkludGVyYWN0aW9uRXZlbnR9IGV2ZW50IC0gSW50ZXJhY3Rpb24gZXZlbnRcbiAgICAgICAgICovXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVkIHdoZW4gYSBwb2ludGVyIGRldmljZSBidXR0b24gaXMgcHJlc3NlZCBhbmQgcmVsZWFzZWQgb24gdGhlIGRpc3BsYXkgb2JqZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXZlbnQgUElYSS5pbnRlcmFjdGlvbi5JbnRlcmFjdGlvbk1hbmFnZXIjcG9pbnRlcnRhcFxuICAgICAgICAgKiBAcGFyYW0ge1BJWEkuaW50ZXJhY3Rpb24uSW50ZXJhY3Rpb25FdmVudH0gZXZlbnQgLSBJbnRlcmFjdGlvbiBldmVudFxuICAgICAgICAgKi9cblxuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZWQgd2hlbiBhIHBvaW50ZXIgZGV2aWNlIGJ1dHRvbiBpcyByZWxlYXNlZCBvdXRzaWRlIHRoZSBkaXNwbGF5IG9iamVjdCB0aGF0IGluaXRpYWxseVxuICAgICAgICAgKiByZWdpc3RlcmVkIGEgW3BvaW50ZXJkb3duXXtAbGluayBQSVhJLmludGVyYWN0aW9uLkludGVyYWN0aW9uTWFuYWdlciNldmVudDpwb2ludGVyZG93bn0uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBldmVudCBQSVhJLmludGVyYWN0aW9uLkludGVyYWN0aW9uTWFuYWdlciNwb2ludGVydXBvdXRzaWRlXG4gICAgICAgICAqIEBwYXJhbSB7UElYSS5pbnRlcmFjdGlvbi5JbnRlcmFjdGlvbkV2ZW50fSBldmVudCAtIEludGVyYWN0aW9uIGV2ZW50XG4gICAgICAgICAqL1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlZCB3aGVuIGEgcG9pbnRlciBkZXZpY2UgaXMgbW92ZWQgd2hpbGUgb3ZlciB0aGUgZGlzcGxheSBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogQGV2ZW50IFBJWEkuaW50ZXJhY3Rpb24uSW50ZXJhY3Rpb25NYW5hZ2VyI3BvaW50ZXJtb3ZlXG4gICAgICAgICAqIEBwYXJhbSB7UElYSS5pbnRlcmFjdGlvbi5JbnRlcmFjdGlvbkV2ZW50fSBldmVudCAtIEludGVyYWN0aW9uIGV2ZW50XG4gICAgICAgICAqL1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlZCB3aGVuIGEgcG9pbnRlciBkZXZpY2UgaXMgbW92ZWQgb250byB0aGUgZGlzcGxheSBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogQGV2ZW50IFBJWEkuaW50ZXJhY3Rpb24uSW50ZXJhY3Rpb25NYW5hZ2VyI3BvaW50ZXJvdmVyXG4gICAgICAgICAqIEBwYXJhbSB7UElYSS5pbnRlcmFjdGlvbi5JbnRlcmFjdGlvbkV2ZW50fSBldmVudCAtIEludGVyYWN0aW9uIGV2ZW50XG4gICAgICAgICAqL1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlZCB3aGVuIGEgcG9pbnRlciBkZXZpY2UgaXMgbW92ZWQgb2ZmIHRoZSBkaXNwbGF5IG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXZlbnQgUElYSS5pbnRlcmFjdGlvbi5JbnRlcmFjdGlvbk1hbmFnZXIjcG9pbnRlcm91dFxuICAgICAgICAgKiBAcGFyYW0ge1BJWEkuaW50ZXJhY3Rpb24uSW50ZXJhY3Rpb25FdmVudH0gZXZlbnQgLSBJbnRlcmFjdGlvbiBldmVudFxuICAgICAgICAgKi9cblxuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZWQgd2hlbiBhIHRvdWNoIHBvaW50IGlzIHBsYWNlZCBvbiB0aGUgZGlzcGxheSBvYmplY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBldmVudCBQSVhJLmludGVyYWN0aW9uLkludGVyYWN0aW9uTWFuYWdlciN0b3VjaHN0YXJ0XG4gICAgICAgICAqIEBwYXJhbSB7UElYSS5pbnRlcmFjdGlvbi5JbnRlcmFjdGlvbkV2ZW50fSBldmVudCAtIEludGVyYWN0aW9uIGV2ZW50XG4gICAgICAgICAqL1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlZCB3aGVuIGEgdG91Y2ggcG9pbnQgaXMgcmVtb3ZlZCBmcm9tIHRoZSBkaXNwbGF5IG9iamVjdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV2ZW50IFBJWEkuaW50ZXJhY3Rpb24uSW50ZXJhY3Rpb25NYW5hZ2VyI3RvdWNoZW5kXG4gICAgICAgICAqIEBwYXJhbSB7UElYSS5pbnRlcmFjdGlvbi5JbnRlcmFjdGlvbkV2ZW50fSBldmVudCAtIEludGVyYWN0aW9uIGV2ZW50XG4gICAgICAgICAqL1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlZCB3aGVuIHRoZSBvcGVyYXRpbmcgc3lzdGVtIGNhbmNlbHMgYSB0b3VjaFxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXZlbnQgUElYSS5pbnRlcmFjdGlvbi5JbnRlcmFjdGlvbk1hbmFnZXIjdG91Y2hjYW5jZWxcbiAgICAgICAgICogQHBhcmFtIHtQSVhJLmludGVyYWN0aW9uLkludGVyYWN0aW9uRXZlbnR9IGV2ZW50IC0gSW50ZXJhY3Rpb24gZXZlbnRcbiAgICAgICAgICovXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVkIHdoZW4gYSB0b3VjaCBwb2ludCBpcyBwbGFjZWQgYW5kIHJlbW92ZWQgZnJvbSB0aGUgZGlzcGxheSBvYmplY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBldmVudCBQSVhJLmludGVyYWN0aW9uLkludGVyYWN0aW9uTWFuYWdlciN0YXBcbiAgICAgICAgICogQHBhcmFtIHtQSVhJLmludGVyYWN0aW9uLkludGVyYWN0aW9uRXZlbnR9IGV2ZW50IC0gSW50ZXJhY3Rpb24gZXZlbnRcbiAgICAgICAgICovXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVkIHdoZW4gYSB0b3VjaCBwb2ludCBpcyByZW1vdmVkIG91dHNpZGUgb2YgdGhlIGRpc3BsYXkgb2JqZWN0IHRoYXQgaW5pdGlhbGx5XG4gICAgICAgICAqIHJlZ2lzdGVyZWQgYSBbdG91Y2hzdGFydF17QGxpbmsgUElYSS5pbnRlcmFjdGlvbi5JbnRlcmFjdGlvbk1hbmFnZXIjZXZlbnQ6dG91Y2hzdGFydH0uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBldmVudCBQSVhJLmludGVyYWN0aW9uLkludGVyYWN0aW9uTWFuYWdlciN0b3VjaGVuZG91dHNpZGVcbiAgICAgICAgICogQHBhcmFtIHtQSVhJLmludGVyYWN0aW9uLkludGVyYWN0aW9uRXZlbnR9IGV2ZW50IC0gSW50ZXJhY3Rpb24gZXZlbnRcbiAgICAgICAgICovXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVkIHdoZW4gYSB0b3VjaCBwb2ludCBpcyBtb3ZlZCBhbG9uZyB0aGUgZGlzcGxheSBvYmplY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBldmVudCBQSVhJLmludGVyYWN0aW9uLkludGVyYWN0aW9uTWFuYWdlciN0b3VjaG1vdmVcbiAgICAgICAgICogQHBhcmFtIHtQSVhJLmludGVyYWN0aW9uLkludGVyYWN0aW9uRXZlbnR9IGV2ZW50IC0gSW50ZXJhY3Rpb24gZXZlbnRcbiAgICAgICAgICovXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVkIHdoZW4gYSBwb2ludGVyIGRldmljZSBidXR0b24gKHVzdWFsbHkgYSBtb3VzZSBsZWZ0LWJ1dHRvbikgaXMgcHJlc3NlZCBvbiB0aGUgZGlzcGxheS5cbiAgICAgICAgICogb2JqZWN0LiBEaXNwbGF5T2JqZWN0J3MgYGludGVyYWN0aXZlYCBwcm9wZXJ0eSBtdXN0IGJlIHNldCB0byBgdHJ1ZWAgdG8gZmlyZSBldmVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV2ZW50IFBJWEkuRGlzcGxheU9iamVjdCNtb3VzZWRvd25cbiAgICAgICAgICogQHBhcmFtIHtQSVhJLmludGVyYWN0aW9uLkludGVyYWN0aW9uRXZlbnR9IGV2ZW50IC0gSW50ZXJhY3Rpb24gZXZlbnRcbiAgICAgICAgICovXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVkIHdoZW4gYSBwb2ludGVyIGRldmljZSBzZWNvbmRhcnkgYnV0dG9uICh1c3VhbGx5IGEgbW91c2UgcmlnaHQtYnV0dG9uKSBpcyBwcmVzc2VkXG4gICAgICAgICAqIG9uIHRoZSBkaXNwbGF5IG9iamVjdC4gRGlzcGxheU9iamVjdCdzIGBpbnRlcmFjdGl2ZWAgcHJvcGVydHkgbXVzdCBiZSBzZXQgdG8gYHRydWVgIHRvIGZpcmUgZXZlbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBldmVudCBQSVhJLkRpc3BsYXlPYmplY3QjcmlnaHRkb3duXG4gICAgICAgICAqIEBwYXJhbSB7UElYSS5pbnRlcmFjdGlvbi5JbnRlcmFjdGlvbkV2ZW50fSBldmVudCAtIEludGVyYWN0aW9uIGV2ZW50XG4gICAgICAgICAqL1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlZCB3aGVuIGEgcG9pbnRlciBkZXZpY2UgYnV0dG9uICh1c3VhbGx5IGEgbW91c2UgbGVmdC1idXR0b24pIGlzIHJlbGVhc2VkIG92ZXIgdGhlIGRpc3BsYXlcbiAgICAgICAgICogb2JqZWN0LiBEaXNwbGF5T2JqZWN0J3MgYGludGVyYWN0aXZlYCBwcm9wZXJ0eSBtdXN0IGJlIHNldCB0byBgdHJ1ZWAgdG8gZmlyZSBldmVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV2ZW50IFBJWEkuRGlzcGxheU9iamVjdCNtb3VzZXVwXG4gICAgICAgICAqIEBwYXJhbSB7UElYSS5pbnRlcmFjdGlvbi5JbnRlcmFjdGlvbkV2ZW50fSBldmVudCAtIEludGVyYWN0aW9uIGV2ZW50XG4gICAgICAgICAqL1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlZCB3aGVuIGEgcG9pbnRlciBkZXZpY2Ugc2Vjb25kYXJ5IGJ1dHRvbiAodXN1YWxseSBhIG1vdXNlIHJpZ2h0LWJ1dHRvbikgaXMgcmVsZWFzZWRcbiAgICAgICAgICogb3ZlciB0aGUgZGlzcGxheSBvYmplY3QuIERpc3BsYXlPYmplY3QncyBgaW50ZXJhY3RpdmVgIHByb3BlcnR5IG11c3QgYmUgc2V0IHRvIGB0cnVlYCB0byBmaXJlIGV2ZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXZlbnQgUElYSS5EaXNwbGF5T2JqZWN0I3JpZ2h0dXBcbiAgICAgICAgICogQHBhcmFtIHtQSVhJLmludGVyYWN0aW9uLkludGVyYWN0aW9uRXZlbnR9IGV2ZW50IC0gSW50ZXJhY3Rpb24gZXZlbnRcbiAgICAgICAgICovXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVkIHdoZW4gYSBwb2ludGVyIGRldmljZSBidXR0b24gKHVzdWFsbHkgYSBtb3VzZSBsZWZ0LWJ1dHRvbikgaXMgcHJlc3NlZCBhbmQgcmVsZWFzZWQgb25cbiAgICAgICAgICogdGhlIGRpc3BsYXkgb2JqZWN0LiBEaXNwbGF5T2JqZWN0J3MgYGludGVyYWN0aXZlYCBwcm9wZXJ0eSBtdXN0IGJlIHNldCB0byBgdHJ1ZWAgdG8gZmlyZSBldmVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV2ZW50IFBJWEkuRGlzcGxheU9iamVjdCNjbGlja1xuICAgICAgICAgKiBAcGFyYW0ge1BJWEkuaW50ZXJhY3Rpb24uSW50ZXJhY3Rpb25FdmVudH0gZXZlbnQgLSBJbnRlcmFjdGlvbiBldmVudFxuICAgICAgICAgKi9cblxuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZWQgd2hlbiBhIHBvaW50ZXIgZGV2aWNlIHNlY29uZGFyeSBidXR0b24gKHVzdWFsbHkgYSBtb3VzZSByaWdodC1idXR0b24pIGlzIHByZXNzZWRcbiAgICAgICAgICogYW5kIHJlbGVhc2VkIG9uIHRoZSBkaXNwbGF5IG9iamVjdC4gRGlzcGxheU9iamVjdCdzIGBpbnRlcmFjdGl2ZWAgcHJvcGVydHkgbXVzdCBiZSBzZXQgdG8gYHRydWVgIHRvIGZpcmUgZXZlbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBldmVudCBQSVhJLkRpc3BsYXlPYmplY3QjcmlnaHRjbGlja1xuICAgICAgICAgKiBAcGFyYW0ge1BJWEkuaW50ZXJhY3Rpb24uSW50ZXJhY3Rpb25FdmVudH0gZXZlbnQgLSBJbnRlcmFjdGlvbiBldmVudFxuICAgICAgICAgKi9cblxuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZWQgd2hlbiBhIHBvaW50ZXIgZGV2aWNlIGJ1dHRvbiAodXN1YWxseSBhIG1vdXNlIGxlZnQtYnV0dG9uKSBpcyByZWxlYXNlZCBvdXRzaWRlIHRoZVxuICAgICAgICAgKiBkaXNwbGF5IG9iamVjdCB0aGF0IGluaXRpYWxseSByZWdpc3RlcmVkIGFcbiAgICAgICAgICogW21vdXNlZG93bl17QGxpbmsgUElYSS5EaXNwbGF5T2JqZWN0I2V2ZW50Om1vdXNlZG93bn0uXG4gICAgICAgICAqIERpc3BsYXlPYmplY3QncyBgaW50ZXJhY3RpdmVgIHByb3BlcnR5IG11c3QgYmUgc2V0IHRvIGB0cnVlYCB0byBmaXJlIGV2ZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXZlbnQgUElYSS5EaXNwbGF5T2JqZWN0I21vdXNldXBvdXRzaWRlXG4gICAgICAgICAqIEBwYXJhbSB7UElYSS5pbnRlcmFjdGlvbi5JbnRlcmFjdGlvbkV2ZW50fSBldmVudCAtIEludGVyYWN0aW9uIGV2ZW50XG4gICAgICAgICAqL1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlZCB3aGVuIGEgcG9pbnRlciBkZXZpY2Ugc2Vjb25kYXJ5IGJ1dHRvbiAodXN1YWxseSBhIG1vdXNlIHJpZ2h0LWJ1dHRvbikgaXMgcmVsZWFzZWRcbiAgICAgICAgICogb3V0c2lkZSB0aGUgZGlzcGxheSBvYmplY3QgdGhhdCBpbml0aWFsbHkgcmVnaXN0ZXJlZCBhXG4gICAgICAgICAqIFtyaWdodGRvd25de0BsaW5rIFBJWEkuRGlzcGxheU9iamVjdCNldmVudDpyaWdodGRvd259LlxuICAgICAgICAgKiBEaXNwbGF5T2JqZWN0J3MgYGludGVyYWN0aXZlYCBwcm9wZXJ0eSBtdXN0IGJlIHNldCB0byBgdHJ1ZWAgdG8gZmlyZSBldmVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV2ZW50IFBJWEkuRGlzcGxheU9iamVjdCNyaWdodHVwb3V0c2lkZVxuICAgICAgICAgKiBAcGFyYW0ge1BJWEkuaW50ZXJhY3Rpb24uSW50ZXJhY3Rpb25FdmVudH0gZXZlbnQgLSBJbnRlcmFjdGlvbiBldmVudFxuICAgICAgICAgKi9cblxuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZWQgd2hlbiBhIHBvaW50ZXIgZGV2aWNlICh1c3VhbGx5IGEgbW91c2UpIGlzIG1vdmVkIHdoaWxlIG92ZXIgdGhlIGRpc3BsYXkgb2JqZWN0LlxuICAgICAgICAgKiBEaXNwbGF5T2JqZWN0J3MgYGludGVyYWN0aXZlYCBwcm9wZXJ0eSBtdXN0IGJlIHNldCB0byBgdHJ1ZWAgdG8gZmlyZSBldmVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV2ZW50IFBJWEkuRGlzcGxheU9iamVjdCNtb3VzZW1vdmVcbiAgICAgICAgICogQHBhcmFtIHtQSVhJLmludGVyYWN0aW9uLkludGVyYWN0aW9uRXZlbnR9IGV2ZW50IC0gSW50ZXJhY3Rpb24gZXZlbnRcbiAgICAgICAgICovXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVkIHdoZW4gYSBwb2ludGVyIGRldmljZSAodXN1YWxseSBhIG1vdXNlKSBpcyBtb3ZlZCBvbnRvIHRoZSBkaXNwbGF5IG9iamVjdC5cbiAgICAgICAgICogRGlzcGxheU9iamVjdCdzIGBpbnRlcmFjdGl2ZWAgcHJvcGVydHkgbXVzdCBiZSBzZXQgdG8gYHRydWVgIHRvIGZpcmUgZXZlbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBldmVudCBQSVhJLkRpc3BsYXlPYmplY3QjbW91c2VvdmVyXG4gICAgICAgICAqIEBwYXJhbSB7UElYSS5pbnRlcmFjdGlvbi5JbnRlcmFjdGlvbkV2ZW50fSBldmVudCAtIEludGVyYWN0aW9uIGV2ZW50XG4gICAgICAgICAqL1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlZCB3aGVuIGEgcG9pbnRlciBkZXZpY2UgKHVzdWFsbHkgYSBtb3VzZSkgaXMgbW92ZWQgb2ZmIHRoZSBkaXNwbGF5IG9iamVjdC5cbiAgICAgICAgICogRGlzcGxheU9iamVjdCdzIGBpbnRlcmFjdGl2ZWAgcHJvcGVydHkgbXVzdCBiZSBzZXQgdG8gYHRydWVgIHRvIGZpcmUgZXZlbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBldmVudCBQSVhJLkRpc3BsYXlPYmplY3QjbW91c2VvdXRcbiAgICAgICAgICogQHBhcmFtIHtQSVhJLmludGVyYWN0aW9uLkludGVyYWN0aW9uRXZlbnR9IGV2ZW50IC0gSW50ZXJhY3Rpb24gZXZlbnRcbiAgICAgICAgICovXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVkIHdoZW4gYSBwb2ludGVyIGRldmljZSBidXR0b24gaXMgcHJlc3NlZCBvbiB0aGUgZGlzcGxheSBvYmplY3QuXG4gICAgICAgICAqIERpc3BsYXlPYmplY3QncyBgaW50ZXJhY3RpdmVgIHByb3BlcnR5IG11c3QgYmUgc2V0IHRvIGB0cnVlYCB0byBmaXJlIGV2ZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXZlbnQgUElYSS5EaXNwbGF5T2JqZWN0I3BvaW50ZXJkb3duXG4gICAgICAgICAqIEBwYXJhbSB7UElYSS5pbnRlcmFjdGlvbi5JbnRlcmFjdGlvbkV2ZW50fSBldmVudCAtIEludGVyYWN0aW9uIGV2ZW50XG4gICAgICAgICAqL1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlZCB3aGVuIGEgcG9pbnRlciBkZXZpY2UgYnV0dG9uIGlzIHJlbGVhc2VkIG92ZXIgdGhlIGRpc3BsYXkgb2JqZWN0LlxuICAgICAgICAgKiBEaXNwbGF5T2JqZWN0J3MgYGludGVyYWN0aXZlYCBwcm9wZXJ0eSBtdXN0IGJlIHNldCB0byBgdHJ1ZWAgdG8gZmlyZSBldmVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV2ZW50IFBJWEkuRGlzcGxheU9iamVjdCNwb2ludGVydXBcbiAgICAgICAgICogQHBhcmFtIHtQSVhJLmludGVyYWN0aW9uLkludGVyYWN0aW9uRXZlbnR9IGV2ZW50IC0gSW50ZXJhY3Rpb24gZXZlbnRcbiAgICAgICAgICovXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVkIHdoZW4gdGhlIG9wZXJhdGluZyBzeXN0ZW0gY2FuY2VscyBhIHBvaW50ZXIgZXZlbnQuXG4gICAgICAgICAqIERpc3BsYXlPYmplY3QncyBgaW50ZXJhY3RpdmVgIHByb3BlcnR5IG11c3QgYmUgc2V0IHRvIGB0cnVlYCB0byBmaXJlIGV2ZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXZlbnQgUElYSS5EaXNwbGF5T2JqZWN0I3BvaW50ZXJjYW5jZWxcbiAgICAgICAgICogQHBhcmFtIHtQSVhJLmludGVyYWN0aW9uLkludGVyYWN0aW9uRXZlbnR9IGV2ZW50IC0gSW50ZXJhY3Rpb24gZXZlbnRcbiAgICAgICAgICovXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVkIHdoZW4gYSBwb2ludGVyIGRldmljZSBidXR0b24gaXMgcHJlc3NlZCBhbmQgcmVsZWFzZWQgb24gdGhlIGRpc3BsYXkgb2JqZWN0LlxuICAgICAgICAgKiBEaXNwbGF5T2JqZWN0J3MgYGludGVyYWN0aXZlYCBwcm9wZXJ0eSBtdXN0IGJlIHNldCB0byBgdHJ1ZWAgdG8gZmlyZSBldmVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV2ZW50IFBJWEkuRGlzcGxheU9iamVjdCNwb2ludGVydGFwXG4gICAgICAgICAqIEBwYXJhbSB7UElYSS5pbnRlcmFjdGlvbi5JbnRlcmFjdGlvbkV2ZW50fSBldmVudCAtIEludGVyYWN0aW9uIGV2ZW50XG4gICAgICAgICAqL1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlZCB3aGVuIGEgcG9pbnRlciBkZXZpY2UgYnV0dG9uIGlzIHJlbGVhc2VkIG91dHNpZGUgdGhlIGRpc3BsYXkgb2JqZWN0IHRoYXQgaW5pdGlhbGx5XG4gICAgICAgICAqIHJlZ2lzdGVyZWQgYSBbcG9pbnRlcmRvd25de0BsaW5rIFBJWEkuRGlzcGxheU9iamVjdCNldmVudDpwb2ludGVyZG93bn0uXG4gICAgICAgICAqIERpc3BsYXlPYmplY3QncyBgaW50ZXJhY3RpdmVgIHByb3BlcnR5IG11c3QgYmUgc2V0IHRvIGB0cnVlYCB0byBmaXJlIGV2ZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXZlbnQgUElYSS5EaXNwbGF5T2JqZWN0I3BvaW50ZXJ1cG91dHNpZGVcbiAgICAgICAgICogQHBhcmFtIHtQSVhJLmludGVyYWN0aW9uLkludGVyYWN0aW9uRXZlbnR9IGV2ZW50IC0gSW50ZXJhY3Rpb24gZXZlbnRcbiAgICAgICAgICovXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVkIHdoZW4gYSBwb2ludGVyIGRldmljZSBpcyBtb3ZlZCB3aGlsZSBvdmVyIHRoZSBkaXNwbGF5IG9iamVjdC5cbiAgICAgICAgICogRGlzcGxheU9iamVjdCdzIGBpbnRlcmFjdGl2ZWAgcHJvcGVydHkgbXVzdCBiZSBzZXQgdG8gYHRydWVgIHRvIGZpcmUgZXZlbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBldmVudCBQSVhJLkRpc3BsYXlPYmplY3QjcG9pbnRlcm1vdmVcbiAgICAgICAgICogQHBhcmFtIHtQSVhJLmludGVyYWN0aW9uLkludGVyYWN0aW9uRXZlbnR9IGV2ZW50IC0gSW50ZXJhY3Rpb24gZXZlbnRcbiAgICAgICAgICovXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVkIHdoZW4gYSBwb2ludGVyIGRldmljZSBpcyBtb3ZlZCBvbnRvIHRoZSBkaXNwbGF5IG9iamVjdC5cbiAgICAgICAgICogRGlzcGxheU9iamVjdCdzIGBpbnRlcmFjdGl2ZWAgcHJvcGVydHkgbXVzdCBiZSBzZXQgdG8gYHRydWVgIHRvIGZpcmUgZXZlbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBldmVudCBQSVhJLkRpc3BsYXlPYmplY3QjcG9pbnRlcm92ZXJcbiAgICAgICAgICogQHBhcmFtIHtQSVhJLmludGVyYWN0aW9uLkludGVyYWN0aW9uRXZlbnR9IGV2ZW50IC0gSW50ZXJhY3Rpb24gZXZlbnRcbiAgICAgICAgICovXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVkIHdoZW4gYSBwb2ludGVyIGRldmljZSBpcyBtb3ZlZCBvZmYgdGhlIGRpc3BsYXkgb2JqZWN0LlxuICAgICAgICAgKiBEaXNwbGF5T2JqZWN0J3MgYGludGVyYWN0aXZlYCBwcm9wZXJ0eSBtdXN0IGJlIHNldCB0byBgdHJ1ZWAgdG8gZmlyZSBldmVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV2ZW50IFBJWEkuRGlzcGxheU9iamVjdCNwb2ludGVyb3V0XG4gICAgICAgICAqIEBwYXJhbSB7UElYSS5pbnRlcmFjdGlvbi5JbnRlcmFjdGlvbkV2ZW50fSBldmVudCAtIEludGVyYWN0aW9uIGV2ZW50XG4gICAgICAgICAqL1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlZCB3aGVuIGEgdG91Y2ggcG9pbnQgaXMgcGxhY2VkIG9uIHRoZSBkaXNwbGF5IG9iamVjdC5cbiAgICAgICAgICogRGlzcGxheU9iamVjdCdzIGBpbnRlcmFjdGl2ZWAgcHJvcGVydHkgbXVzdCBiZSBzZXQgdG8gYHRydWVgIHRvIGZpcmUgZXZlbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBldmVudCBQSVhJLkRpc3BsYXlPYmplY3QjdG91Y2hzdGFydFxuICAgICAgICAgKiBAcGFyYW0ge1BJWEkuaW50ZXJhY3Rpb24uSW50ZXJhY3Rpb25FdmVudH0gZXZlbnQgLSBJbnRlcmFjdGlvbiBldmVudFxuICAgICAgICAgKi9cblxuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZWQgd2hlbiBhIHRvdWNoIHBvaW50IGlzIHJlbW92ZWQgZnJvbSB0aGUgZGlzcGxheSBvYmplY3QuXG4gICAgICAgICAqIERpc3BsYXlPYmplY3QncyBgaW50ZXJhY3RpdmVgIHByb3BlcnR5IG11c3QgYmUgc2V0IHRvIGB0cnVlYCB0byBmaXJlIGV2ZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXZlbnQgUElYSS5EaXNwbGF5T2JqZWN0I3RvdWNoZW5kXG4gICAgICAgICAqIEBwYXJhbSB7UElYSS5pbnRlcmFjdGlvbi5JbnRlcmFjdGlvbkV2ZW50fSBldmVudCAtIEludGVyYWN0aW9uIGV2ZW50XG4gICAgICAgICAqL1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlZCB3aGVuIHRoZSBvcGVyYXRpbmcgc3lzdGVtIGNhbmNlbHMgYSB0b3VjaC5cbiAgICAgICAgICogRGlzcGxheU9iamVjdCdzIGBpbnRlcmFjdGl2ZWAgcHJvcGVydHkgbXVzdCBiZSBzZXQgdG8gYHRydWVgIHRvIGZpcmUgZXZlbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBldmVudCBQSVhJLkRpc3BsYXlPYmplY3QjdG91Y2hjYW5jZWxcbiAgICAgICAgICogQHBhcmFtIHtQSVhJLmludGVyYWN0aW9uLkludGVyYWN0aW9uRXZlbnR9IGV2ZW50IC0gSW50ZXJhY3Rpb24gZXZlbnRcbiAgICAgICAgICovXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVkIHdoZW4gYSB0b3VjaCBwb2ludCBpcyBwbGFjZWQgYW5kIHJlbW92ZWQgZnJvbSB0aGUgZGlzcGxheSBvYmplY3QuXG4gICAgICAgICAqIERpc3BsYXlPYmplY3QncyBgaW50ZXJhY3RpdmVgIHByb3BlcnR5IG11c3QgYmUgc2V0IHRvIGB0cnVlYCB0byBmaXJlIGV2ZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXZlbnQgUElYSS5EaXNwbGF5T2JqZWN0I3RhcFxuICAgICAgICAgKiBAcGFyYW0ge1BJWEkuaW50ZXJhY3Rpb24uSW50ZXJhY3Rpb25FdmVudH0gZXZlbnQgLSBJbnRlcmFjdGlvbiBldmVudFxuICAgICAgICAgKi9cblxuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZWQgd2hlbiBhIHRvdWNoIHBvaW50IGlzIHJlbW92ZWQgb3V0c2lkZSBvZiB0aGUgZGlzcGxheSBvYmplY3QgdGhhdCBpbml0aWFsbHlcbiAgICAgICAgICogcmVnaXN0ZXJlZCBhIFt0b3VjaHN0YXJ0XXtAbGluayBQSVhJLkRpc3BsYXlPYmplY3QjZXZlbnQ6dG91Y2hzdGFydH0uXG4gICAgICAgICAqIERpc3BsYXlPYmplY3QncyBgaW50ZXJhY3RpdmVgIHByb3BlcnR5IG11c3QgYmUgc2V0IHRvIGB0cnVlYCB0byBmaXJlIGV2ZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXZlbnQgUElYSS5EaXNwbGF5T2JqZWN0I3RvdWNoZW5kb3V0c2lkZVxuICAgICAgICAgKiBAcGFyYW0ge1BJWEkuaW50ZXJhY3Rpb24uSW50ZXJhY3Rpb25FdmVudH0gZXZlbnQgLSBJbnRlcmFjdGlvbiBldmVudFxuICAgICAgICAgKi9cblxuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZWQgd2hlbiBhIHRvdWNoIHBvaW50IGlzIG1vdmVkIGFsb25nIHRoZSBkaXNwbGF5IG9iamVjdC5cbiAgICAgICAgICogRGlzcGxheU9iamVjdCdzIGBpbnRlcmFjdGl2ZWAgcHJvcGVydHkgbXVzdCBiZSBzZXQgdG8gYHRydWVgIHRvIGZpcmUgZXZlbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBldmVudCBQSVhJLkRpc3BsYXlPYmplY3QjdG91Y2htb3ZlXG4gICAgICAgICAqIEBwYXJhbSB7UElYSS5pbnRlcmFjdGlvbi5JbnRlcmFjdGlvbkV2ZW50fSBldmVudCAtIEludGVyYWN0aW9uIGV2ZW50XG4gICAgICAgICAqL1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGl0IHRlc3RzIGEgcG9pbnQgYWdhaW5zdCB0aGUgZGlzcGxheSB0cmVlLCByZXR1cm5pbmcgdGhlIGZpcnN0IGludGVyYWN0aXZlIG9iamVjdCB0aGF0IGlzIGhpdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5Qb2ludH0gZ2xvYmFsUG9pbnQgLSBBIHBvaW50IHRvIGhpdCB0ZXN0IHdpdGgsIGluIGdsb2JhbCBzcGFjZS5cbiAgICAgKiBAcGFyYW0ge1BJWEkuQ29udGFpbmVyfSBbcm9vdF0gLSBUaGUgcm9vdCBkaXNwbGF5IG9iamVjdCB0byBzdGFydCBmcm9tLiBJZiBvbWl0dGVkLCBkZWZhdWx0c1xuICAgICAqIHRvIHRoZSBsYXN0IHJlbmRlcmVkIHJvb3Qgb2YgdGhlIGFzc29jaWF0ZWQgcmVuZGVyZXIuXG4gICAgICogQHJldHVybiB7UElYSS5EaXNwbGF5T2JqZWN0fSBUaGUgaGl0IGRpc3BsYXkgb2JqZWN0LCBpZiBhbnkuXG4gICAgICovXG5cblxuICAgIEludGVyYWN0aW9uTWFuYWdlci5wcm90b3R5cGUuaGl0VGVzdCA9IGZ1bmN0aW9uIGhpdFRlc3QoZ2xvYmFsUG9pbnQsIHJvb3QpIHtcbiAgICAgICAgLy8gY2xlYXIgdGhlIHRhcmdldCBmb3Igb3VyIGhpdCB0ZXN0XG4gICAgICAgIGhpdFRlc3RFdmVudC50YXJnZXQgPSBudWxsO1xuICAgICAgICAvLyBhc3NpZ24gdGhlIGdsb2JhbCBwb2ludFxuICAgICAgICBoaXRUZXN0RXZlbnQuZGF0YS5nbG9iYWwgPSBnbG9iYWxQb2ludDtcbiAgICAgICAgLy8gZW5zdXJlIHNhZmV0eSBvZiB0aGUgcm9vdFxuICAgICAgICBpZiAoIXJvb3QpIHtcbiAgICAgICAgICAgIHJvb3QgPSB0aGlzLnJlbmRlcmVyLl9sYXN0T2JqZWN0UmVuZGVyZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcnVuIHRoZSBoaXQgdGVzdFxuICAgICAgICB0aGlzLnByb2Nlc3NJbnRlcmFjdGl2ZShoaXRUZXN0RXZlbnQsIHJvb3QsIG51bGwsIHRydWUpO1xuICAgICAgICAvLyByZXR1cm4gb3VyIGZvdW5kIG9iamVjdCAtIGl0J2xsIGJlIG51bGwgaWYgd2UgZGlkbid0IGhpdCBhbnl0aGluZ1xuXG4gICAgICAgIHJldHVybiBoaXRUZXN0RXZlbnQudGFyZ2V0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBET00gZWxlbWVudCB3aGljaCB3aWxsIHJlY2VpdmUgbW91c2UvdG91Y2ggZXZlbnRzLiBUaGlzIGlzIHVzZWZ1bCBmb3Igd2hlbiB5b3UgaGF2ZVxuICAgICAqIG90aGVyIERPTSBlbGVtZW50cyBvbiB0b3Agb2YgdGhlIHJlbmRlcmVycyBDYW52YXMgZWxlbWVudC4gV2l0aCB0aGlzIHlvdSdsbCBiZSBiYWxlIHRvIGRlbGV0ZWdhdGVcbiAgICAgKiBhbm90aGVyIERPTSBlbGVtZW50IHRvIHJlY2VpdmUgdGhvc2UgZXZlbnRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gZWxlbWVudCAtIHRoZSBET00gZWxlbWVudCB3aGljaCB3aWxsIHJlY2VpdmUgbW91c2UgYW5kIHRvdWNoIGV2ZW50cy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3Jlc29sdXRpb249MV0gLSBUaGUgcmVzb2x1dGlvbiAvIGRldmljZSBwaXhlbCByYXRpbyBvZiB0aGUgbmV3IGVsZW1lbnQgKHJlbGF0aXZlIHRvIHRoZSBjYW52YXMpLlxuICAgICAqL1xuXG5cbiAgICBJbnRlcmFjdGlvbk1hbmFnZXIucHJvdG90eXBlLnNldFRhcmdldEVsZW1lbnQgPSBmdW5jdGlvbiBzZXRUYXJnZXRFbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIHJlc29sdXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDE7XG5cbiAgICAgICAgdGhpcy5yZW1vdmVFdmVudHMoKTtcblxuICAgICAgICB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudCA9IGVsZW1lbnQ7XG5cbiAgICAgICAgdGhpcy5yZXNvbHV0aW9uID0gcmVzb2x1dGlvbjtcblxuICAgICAgICB0aGlzLmFkZEV2ZW50cygpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYWxsIHRoZSBET00gZXZlbnRzXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG5cbiAgICBJbnRlcmFjdGlvbk1hbmFnZXIucHJvdG90eXBlLmFkZEV2ZW50cyA9IGZ1bmN0aW9uIGFkZEV2ZW50cygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29yZS50aWNrZXIuc2hhcmVkLmFkZCh0aGlzLnVwZGF0ZSwgdGhpcywgY29yZS5VUERBVEVfUFJJT1JJVFkuSU5URVJBQ1RJT04pO1xuXG4gICAgICAgIGlmICh3aW5kb3cubmF2aWdhdG9yLm1zUG9pbnRlckVuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LnN0eWxlWyctbXMtY29udGVudC16b29taW5nJ10gPSAnbm9uZSc7XG4gICAgICAgICAgICB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudC5zdHlsZVsnLW1zLXRvdWNoLWFjdGlvbiddID0gJ25vbmUnO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc3VwcG9ydHNQb2ludGVyRXZlbnRzKSB7XG4gICAgICAgICAgICB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudC5zdHlsZVsndG91Y2gtYWN0aW9uJ10gPSAnbm9uZSc7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlc2UgZXZlbnRzIGFyZSBhZGRlZCBmaXJzdCwgc28gdGhhdCBpZiBwb2ludGVyIGV2ZW50cyBhcmUgbm9ybWFsaXNlZCwgdGhleSBhcmUgZmlyZWRcbiAgICAgICAgICogaW4gdGhlIHNhbWUgb3JkZXIgYXMgbm9uLW5vcm1hbGlzZWQgZXZlbnRzLiBpZS4gcG9pbnRlciBldmVudCAxc3QsIG1vdXNlIC8gdG91Y2ggMm5kXG4gICAgICAgICAqL1xuICAgICAgICBpZiAodGhpcy5zdXBwb3J0c1BvaW50ZXJFdmVudHMpIHtcbiAgICAgICAgICAgIHdpbmRvdy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVybW92ZScsIHRoaXMub25Qb2ludGVyTW92ZSwgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVyZG93bicsIHRoaXMub25Qb2ludGVyRG93biwgdHJ1ZSk7XG4gICAgICAgICAgICAvLyBwb2ludGVyb3V0IGlzIGZpcmVkIGluIGFkZGl0aW9uIHRvIHBvaW50ZXJ1cCAoZm9yIHRvdWNoIGV2ZW50cykgYW5kIHBvaW50ZXJjYW5jZWxcbiAgICAgICAgICAgIC8vIHdlIGFscmVhZHkgaGFuZGxlIHRob3NlLCBzbyBmb3IgdGhlIHB1cnBvc2VzIG9mIHdoYXQgd2UgZG8gaW4gb25Qb2ludGVyT3V0LCB3ZSBvbmx5XG4gICAgICAgICAgICAvLyBjYXJlIGFib3V0IHRoZSBwb2ludGVybGVhdmUgZXZlbnRcbiAgICAgICAgICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJsZWF2ZScsIHRoaXMub25Qb2ludGVyT3V0LCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJvdmVyJywgdGhpcy5vblBvaW50ZXJPdmVyLCB0cnVlKTtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVyY2FuY2VsJywgdGhpcy5vblBvaW50ZXJDYW5jZWwsIHRydWUpO1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJ1cCcsIHRoaXMub25Qb2ludGVyVXAsIHRydWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2luZG93LmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMub25Qb2ludGVyTW92ZSwgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm9uUG9pbnRlckRvd24sIHRydWUpO1xuICAgICAgICAgICAgdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdXQnLCB0aGlzLm9uUG9pbnRlck91dCwgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW92ZXInLCB0aGlzLm9uUG9pbnRlck92ZXIsIHRydWUpO1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm9uUG9pbnRlclVwLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFsd2F5cyBsb29rIGRpcmVjdGx5IGZvciB0b3VjaCBldmVudHMgc28gdGhhdCB3ZSBjYW4gcHJvdmlkZSBvcmlnaW5hbCBkYXRhXG4gICAgICAgIC8vIEluIGEgZnV0dXJlIHZlcnNpb24gd2Ugc2hvdWxkIGNoYW5nZSB0aGlzIHRvIGJlaW5nIGp1c3QgYSBmYWxsYmFjayBhbmQgcmVseSBzb2xlbHkgb25cbiAgICAgICAgLy8gUG9pbnRlckV2ZW50cyB3aGVuZXZlciBhdmFpbGFibGVcbiAgICAgICAgaWYgKHRoaXMuc3VwcG9ydHNUb3VjaEV2ZW50cykge1xuICAgICAgICAgICAgdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMub25Qb2ludGVyRG93biwgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGNhbmNlbCcsIHRoaXMub25Qb2ludGVyQ2FuY2VsLCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5vblBvaW50ZXJVcCwgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLm9uUG9pbnRlck1vdmUsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ldmVudHNBZGRlZCA9IHRydWU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIHRoZSBET00gZXZlbnRzIHRoYXQgd2VyZSBwcmV2aW91c2x5IHJlZ2lzdGVyZWRcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cblxuICAgIEludGVyYWN0aW9uTWFuYWdlci5wcm90b3R5cGUucmVtb3ZlRXZlbnRzID0gZnVuY3Rpb24gcmVtb3ZlRXZlbnRzKCkge1xuICAgICAgICBpZiAoIXRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb3JlLnRpY2tlci5zaGFyZWQucmVtb3ZlKHRoaXMudXBkYXRlLCB0aGlzKTtcblxuICAgICAgICBpZiAod2luZG93Lm5hdmlnYXRvci5tc1BvaW50ZXJFbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudC5zdHlsZVsnLW1zLWNvbnRlbnQtem9vbWluZyddID0gJyc7XG4gICAgICAgICAgICB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudC5zdHlsZVsnLW1zLXRvdWNoLWFjdGlvbiddID0gJyc7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5zdXBwb3J0c1BvaW50ZXJFdmVudHMpIHtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LnN0eWxlWyd0b3VjaC1hY3Rpb24nXSA9ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuc3VwcG9ydHNQb2ludGVyRXZlbnRzKSB7XG4gICAgICAgICAgICB3aW5kb3cuZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcm1vdmUnLCB0aGlzLm9uUG9pbnRlck1vdmUsIHRydWUpO1xuICAgICAgICAgICAgdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcmRvd24nLCB0aGlzLm9uUG9pbnRlckRvd24sIHRydWUpO1xuICAgICAgICAgICAgdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcmxlYXZlJywgdGhpcy5vblBvaW50ZXJPdXQsIHRydWUpO1xuICAgICAgICAgICAgdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcm92ZXInLCB0aGlzLm9uUG9pbnRlck92ZXIsIHRydWUpO1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJjYW5jZWwnLCB0aGlzLm9uUG9pbnRlckNhbmNlbCwgdHJ1ZSk7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcnVwJywgdGhpcy5vblBvaW50ZXJVcCwgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3aW5kb3cuZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5vblBvaW50ZXJNb3ZlLCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25Qb2ludGVyRG93biwgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW91dCcsIHRoaXMub25Qb2ludGVyT3V0LCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlb3ZlcicsIHRoaXMub25Qb2ludGVyT3ZlciwgdHJ1ZSk7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMub25Qb2ludGVyVXAsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuc3VwcG9ydHNUb3VjaEV2ZW50cykge1xuICAgICAgICAgICAgdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMub25Qb2ludGVyRG93biwgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGNhbmNlbCcsIHRoaXMub25Qb2ludGVyQ2FuY2VsLCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5vblBvaW50ZXJVcCwgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLm9uUG9pbnRlck1vdmUsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuZXZlbnRzQWRkZWQgPSBmYWxzZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgc3RhdGUgb2YgaW50ZXJhY3RpdmUgb2JqZWN0cy5cbiAgICAgKiBJbnZva2VkIGJ5IGEgdGhyb3R0bGVkIHRpY2tlciB1cGRhdGUgZnJvbSB7QGxpbmsgUElYSS50aWNrZXIuc2hhcmVkfS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZWx0YVRpbWUgLSB0aW1lIGRlbHRhIHNpbmNlIGxhc3QgdGlja1xuICAgICAqL1xuXG5cbiAgICBJbnRlcmFjdGlvbk1hbmFnZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShkZWx0YVRpbWUpIHtcbiAgICAgICAgdGhpcy5fZGVsdGFUaW1lICs9IGRlbHRhVGltZTtcblxuICAgICAgICBpZiAodGhpcy5fZGVsdGFUaW1lIDwgdGhpcy5pbnRlcmFjdGlvbkZyZXF1ZW5jeSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZGVsdGFUaW1lID0gMDtcblxuICAgICAgICBpZiAoIXRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB0aGUgdXNlciBtb3ZlIHRoZSBtb3VzZSB0aGlzIGNoZWNrIGhhcyBhbHJlYWR5IGJlZW4gZG9uZSB1c2luZyB0aGUgbW91c2UgbW92ZSFcbiAgICAgICAgaWYgKHRoaXMuZGlkTW92ZSkge1xuICAgICAgICAgICAgdGhpcy5kaWRNb3ZlID0gZmFsc2U7XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY3Vyc29yID0gbnVsbDtcblxuICAgICAgICAvLyBSZXNldHMgdGhlIGZsYWcgYXMgc2V0IGJ5IGEgc3RvcFByb3BhZ2F0aW9uIGNhbGwuIFRoaXMgZmxhZyBpcyB1c3VhbGx5IHJlc2V0IGJ5IGEgdXNlciBpbnRlcmFjdGlvbiBvZiBhbnkga2luZCxcbiAgICAgICAgLy8gYnV0IHRoZXJlIHdhcyBhIHNjZW5hcmlvIG9mIGEgZGlzcGxheSBvYmplY3QgbW92aW5nIHVuZGVyIGEgc3RhdGljIG1vdXNlIGN1cnNvci5cbiAgICAgICAgLy8gSW4gdGhpcyBjYXNlLCBtb3VzZW92ZXIgYW5kIG1vdXNlZXZlbnRzIHdvdWxkIG5vdCBwYXNzIHRoZSBmbGFnIHRlc3QgaW4gZGlzcGF0Y2hFdmVudCBmdW5jdGlvblxuICAgICAgICBmb3IgKHZhciBrIGluIHRoaXMuYWN0aXZlSW50ZXJhY3Rpb25EYXRhKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG4gICAgICAgICAgICBpZiAodGhpcy5hY3RpdmVJbnRlcmFjdGlvbkRhdGEuaGFzT3duUHJvcGVydHkoaykpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW50ZXJhY3Rpb25EYXRhID0gdGhpcy5hY3RpdmVJbnRlcmFjdGlvbkRhdGFba107XG5cbiAgICAgICAgICAgICAgICBpZiAoaW50ZXJhY3Rpb25EYXRhLm9yaWdpbmFsRXZlbnQgJiYgaW50ZXJhY3Rpb25EYXRhLnBvaW50ZXJUeXBlICE9PSAndG91Y2gnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbnRlcmFjdGlvbkV2ZW50ID0gdGhpcy5jb25maWd1cmVJbnRlcmFjdGlvbkV2ZW50Rm9yRE9NRXZlbnQodGhpcy5ldmVudERhdGEsIGludGVyYWN0aW9uRGF0YS5vcmlnaW5hbEV2ZW50LCBpbnRlcmFjdGlvbkRhdGEpO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzc0ludGVyYWN0aXZlKGludGVyYWN0aW9uRXZlbnQsIHRoaXMucmVuZGVyZXIuX2xhc3RPYmplY3RSZW5kZXJlZCwgdGhpcy5wcm9jZXNzUG9pbnRlck92ZXJPdXQsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2V0Q3Vyc29yTW9kZSh0aGlzLmN1cnNvcik7XG5cbiAgICAgICAgLy8gVE9ET1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBjdXJyZW50IGN1cnNvciBtb2RlLCBoYW5kbGluZyBhbnkgY2FsbGJhY2tzIG9yIENTUyBzdHlsZSBjaGFuZ2VzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1vZGUgLSBjdXJzb3IgbW9kZSwgYSBrZXkgZnJvbSB0aGUgY3Vyc29yU3R5bGVzIGRpY3Rpb25hcnlcbiAgICAgKi9cblxuXG4gICAgSW50ZXJhY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5zZXRDdXJzb3JNb2RlID0gZnVuY3Rpb24gc2V0Q3Vyc29yTW9kZShtb2RlKSB7XG4gICAgICAgIG1vZGUgPSBtb2RlIHx8ICdkZWZhdWx0JztcbiAgICAgICAgLy8gaWYgdGhlIG1vZGUgZGlkbid0IGFjdHVhbGx5IGNoYW5nZSwgYmFpbCBlYXJseVxuICAgICAgICBpZiAodGhpcy5jdXJyZW50Q3Vyc29yTW9kZSA9PT0gbW9kZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3VycmVudEN1cnNvck1vZGUgPSBtb2RlO1xuICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLmN1cnNvclN0eWxlc1ttb2RlXTtcblxuICAgICAgICAvLyBvbmx5IGRvIHRoaW5ncyBpZiB0aGVyZSBpcyBhIGN1cnNvciBzdHlsZSBmb3IgaXRcbiAgICAgICAgaWYgKHN0eWxlKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBzdHlsZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2Yoc3R5bGUpKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RyaW5nIHN0eWxlcyBhcmUgaGFuZGxlZCBhcyBjdXJzb3IgQ1NTXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LnN0eWxlLmN1cnNvciA9IHN0eWxlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgICAgICAgICAgICAgIC8vIGZ1bmN0aW9ucyBhcmUganVzdCBjYWxsZWQsIGFuZCBwYXNzZWQgdGhlIGN1cnNvciBtb2RlXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlKG1vZGUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICAvLyBpZiBpdCBpcyBhbiBvYmplY3QsIGFzc3VtZSB0aGF0IGl0IGlzIGEgZGljdGlvbmFyeSBvZiBDU1Mgc3R5bGVzLFxuICAgICAgICAgICAgICAgICAgICAvLyBhcHBseSBpdCB0byB0aGUgaW50ZXJhY3Rpb25ET01FbGVtZW50XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQuc3R5bGUsIHN0eWxlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG1vZGUgPT09ICdzdHJpbmcnICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5jdXJzb3JTdHlsZXMsIG1vZGUpKSB7XG4gICAgICAgICAgICAvLyBpZiBpdCBtb2RlIGlzIGEgc3RyaW5nIChub3QgYSBTeW1ib2wpIGFuZCBjdXJzb3JTdHlsZXMgZG9lc24ndCBoYXZlIGFueSBlbnRyeVxuICAgICAgICAgICAgLy8gZm9yIHRoZSBtb2RlLCB0aGVuIGFzc3VtZSB0aGF0IHRoZSBkZXYgd2FudHMgaXQgdG8gYmUgQ1NTIGZvciB0aGUgY3Vyc29yLlxuICAgICAgICAgICAgdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQuc3R5bGUuY3Vyc29yID0gbW9kZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEaXNwYXRjaGVzIGFuIGV2ZW50IG9uIHRoZSBkaXNwbGF5IG9iamVjdCB0aGF0IHdhcyBpbnRlcmFjdGVkIHdpdGhcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5Db250YWluZXJ8UElYSS5TcHJpdGV8UElYSS5leHRyYXMuVGlsaW5nU3ByaXRlfSBkaXNwbGF5T2JqZWN0IC0gdGhlIGRpc3BsYXkgb2JqZWN0IGluIHF1ZXN0aW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50U3RyaW5nIC0gdGhlIG5hbWUgb2YgdGhlIGV2ZW50IChlLmcsIG1vdXNlZG93bilcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZXZlbnREYXRhIC0gdGhlIGV2ZW50IGRhdGEgb2JqZWN0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuXG4gICAgSW50ZXJhY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5kaXNwYXRjaEV2ZW50ID0gZnVuY3Rpb24gZGlzcGF0Y2hFdmVudChkaXNwbGF5T2JqZWN0LCBldmVudFN0cmluZywgZXZlbnREYXRhKSB7XG4gICAgICAgIGlmICghZXZlbnREYXRhLnN0b3BwZWQpIHtcbiAgICAgICAgICAgIGV2ZW50RGF0YS5jdXJyZW50VGFyZ2V0ID0gZGlzcGxheU9iamVjdDtcbiAgICAgICAgICAgIGV2ZW50RGF0YS50eXBlID0gZXZlbnRTdHJpbmc7XG5cbiAgICAgICAgICAgIGRpc3BsYXlPYmplY3QuZW1pdChldmVudFN0cmluZywgZXZlbnREYXRhKTtcblxuICAgICAgICAgICAgaWYgKGRpc3BsYXlPYmplY3RbZXZlbnRTdHJpbmddKSB7XG4gICAgICAgICAgICAgICAgZGlzcGxheU9iamVjdFtldmVudFN0cmluZ10oZXZlbnREYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBNYXBzIHggYW5kIHkgY29vcmRzIGZyb20gYSBET00gb2JqZWN0IGFuZCBtYXBzIHRoZW0gY29ycmVjdGx5IHRvIHRoZSBQaXhpSlMgdmlldy4gVGhlXG4gICAgICogcmVzdWx0aW5nIHZhbHVlIGlzIHN0b3JlZCBpbiB0aGUgcG9pbnQuIFRoaXMgdGFrZXMgaW50byBhY2NvdW50IHRoZSBmYWN0IHRoYXQgdGhlIERPTVxuICAgICAqIGVsZW1lbnQgY291bGQgYmUgc2NhbGVkIGFuZCBwb3NpdGlvbmVkIGFueXdoZXJlIG9uIHRoZSBzY3JlZW4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtQSVhJLlBvaW50fSBwb2ludCAtIHRoZSBwb2ludCB0aGF0IHRoZSByZXN1bHQgd2lsbCBiZSBzdG9yZWQgaW5cbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHggLSB0aGUgeCBjb29yZCBvZiB0aGUgcG9zaXRpb24gdG8gbWFwXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB5IC0gdGhlIHkgY29vcmQgb2YgdGhlIHBvc2l0aW9uIHRvIG1hcFxuICAgICAqL1xuXG5cbiAgICBJbnRlcmFjdGlvbk1hbmFnZXIucHJvdG90eXBlLm1hcFBvc2l0aW9uVG9Qb2ludCA9IGZ1bmN0aW9uIG1hcFBvc2l0aW9uVG9Qb2ludChwb2ludCwgeCwgeSkge1xuICAgICAgICB2YXIgcmVjdCA9IHZvaWQgMDtcblxuICAgICAgICAvLyBJRSAxMSBmaXhcbiAgICAgICAgaWYgKCF0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudC5wYXJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgICByZWN0ID0geyB4OiAwLCB5OiAwLCB3aWR0aDogMCwgaGVpZ2h0OiAwIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWN0ID0gdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzb2x1dGlvbk11bHRpcGxpZXIgPSBuYXZpZ2F0b3IuaXNDb2Nvb25KUyA/IHRoaXMucmVzb2x1dGlvbiA6IDEuMCAvIHRoaXMucmVzb2x1dGlvbjtcblxuICAgICAgICBwb2ludC54ID0gKHggLSByZWN0LmxlZnQpICogKHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LndpZHRoIC8gcmVjdC53aWR0aCkgKiByZXNvbHV0aW9uTXVsdGlwbGllcjtcbiAgICAgICAgcG9pbnQueSA9ICh5IC0gcmVjdC50b3ApICogKHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LmhlaWdodCAvIHJlY3QuaGVpZ2h0KSAqIHJlc29sdXRpb25NdWx0aXBsaWVyO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIHByb3ZpZGVzIGEgbmVhdCB3YXkgb2YgY3Jhd2xpbmcgdGhyb3VnaCB0aGUgc2NlbmUgZ3JhcGggYW5kIHJ1bm5pbmcgYVxuICAgICAqIHNwZWNpZmllZCBmdW5jdGlvbiBvbiBhbGwgaW50ZXJhY3RpdmUgb2JqZWN0cyBpdCBmaW5kcy4gSXQgd2lsbCBhbHNvIHRha2UgY2FyZSBvZiBoaXRcbiAgICAgKiB0ZXN0aW5nIHRoZSBpbnRlcmFjdGl2ZSBvYmplY3RzIGFuZCBwYXNzZXMgdGhlIGhpdCBhY3Jvc3MgaW4gdGhlIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1BJWEkuaW50ZXJhY3Rpb24uSW50ZXJhY3Rpb25FdmVudH0gaW50ZXJhY3Rpb25FdmVudCAtIGV2ZW50IGNvbnRhaW5pbmcgdGhlIHBvaW50IHRoYXRcbiAgICAgKiAgaXMgdGVzdGVkIGZvciBjb2xsaXNpb25cbiAgICAgKiBAcGFyYW0ge1BJWEkuQ29udGFpbmVyfFBJWEkuU3ByaXRlfFBJWEkuZXh0cmFzLlRpbGluZ1Nwcml0ZX0gZGlzcGxheU9iamVjdCAtIHRoZSBkaXNwbGF5T2JqZWN0XG4gICAgICogIHRoYXQgd2lsbCBiZSBoaXQgdGVzdCAocmVjdXJzaXZlbHkgY3Jhd2xzIGl0cyBjaGlsZHJlbilcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZnVuY10gLSB0aGUgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCBvbiBlYWNoIGludGVyYWN0aXZlIG9iamVjdC4gVGhlXG4gICAgICogIGludGVyYWN0aW9uRXZlbnQsIGRpc3BsYXlPYmplY3QgYW5kIGhpdCB3aWxsIGJlIHBhc3NlZCB0byB0aGUgZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtoaXRUZXN0XSAtIHRoaXMgaW5kaWNhdGVzIGlmIHRoZSBvYmplY3RzIGluc2lkZSBzaG91bGQgYmUgaGl0IHRlc3QgYWdhaW5zdCB0aGUgcG9pbnRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpbnRlcmFjdGl2ZV0gLSBXaGV0aGVyIHRoZSBkaXNwbGF5T2JqZWN0IGlzIGludGVyYWN0aXZlXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gcmV0dXJucyB0cnVlIGlmIHRoZSBkaXNwbGF5T2JqZWN0IGhpdCB0aGUgcG9pbnRcbiAgICAgKi9cblxuXG4gICAgSW50ZXJhY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5wcm9jZXNzSW50ZXJhY3RpdmUgPSBmdW5jdGlvbiBwcm9jZXNzSW50ZXJhY3RpdmUoaW50ZXJhY3Rpb25FdmVudCwgZGlzcGxheU9iamVjdCwgZnVuYywgaGl0VGVzdCwgaW50ZXJhY3RpdmUpIHtcbiAgICAgICAgaWYgKCFkaXNwbGF5T2JqZWN0IHx8ICFkaXNwbGF5T2JqZWN0LnZpc2libGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwb2ludCA9IGludGVyYWN0aW9uRXZlbnQuZGF0YS5nbG9iYWw7XG5cbiAgICAgICAgLy8gVG9vayBhIGxpdHRsZSB3aGlsZSB0byByZXdvcmsgdGhpcyBmdW5jdGlvbiBjb3JyZWN0bHkhIEJ1dCBub3cgaXQgaXMgZG9uZSBhbmQgbmljZSBhbmQgb3B0aW1pc2VkLiBeX15cbiAgICAgICAgLy9cbiAgICAgICAgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIG5vdyBsb29wIHRocm91Z2ggYWxsIG9iamVjdHMgYW5kIHRoZW4gb25seSBoaXQgdGVzdCB0aGUgb2JqZWN0cyBpdCBIQVNcbiAgICAgICAgLy8gdG8sIG5vdCBhbGwgb2YgdGhlbS4gTVVDSCBmYXN0ZXIuLlxuICAgICAgICAvLyBBbiBvYmplY3Qgd2lsbCBiZSBoaXQgdGVzdCBpZiB0aGUgZm9sbG93aW5nIGlzIHRydWU6XG4gICAgICAgIC8vXG4gICAgICAgIC8vIDE6IEl0IGlzIGludGVyYWN0aXZlLlxuICAgICAgICAvLyAyOiBJdCBiZWxvbmdzIHRvIGEgcGFyZW50IHRoYXQgaXMgaW50ZXJhY3RpdmUgQU5EIG9uZSBvZiB0aGUgcGFyZW50cyBjaGlsZHJlbiBoYXZlIG5vdCBhbHJlYWR5IGJlZW4gaGl0LlxuICAgICAgICAvL1xuICAgICAgICAvLyBBcyBhbm90aGVyIGxpdHRsZSBvcHRpbWlzYXRpb24gb25jZSBhbiBpbnRlcmFjdGl2ZSBvYmplY3QgaGFzIGJlZW4gaGl0IHdlIGNhbiBjYXJyeSBvblxuICAgICAgICAvLyB0aHJvdWdoIHRoZSBzY2VuZWdyYXBoLCBidXQgd2Uga25vdyB0aGF0IHRoZXJlIHdpbGwgYmUgbm8gbW9yZSBoaXRzISBTbyB3ZSBjYW4gYXZvaWQgZXh0cmEgaGl0IHRlc3RzXG4gICAgICAgIC8vIEEgZmluYWwgb3B0aW1pc2F0aW9uIGlzIHRoYXQgYW4gb2JqZWN0IGlzIG5vdCBoaXQgdGVzdCBkaXJlY3RseSBpZiBhIGNoaWxkIGhhcyBhbHJlYWR5IGJlZW4gaGl0LlxuXG4gICAgICAgIGludGVyYWN0aXZlID0gZGlzcGxheU9iamVjdC5pbnRlcmFjdGl2ZSB8fCBpbnRlcmFjdGl2ZTtcblxuICAgICAgICB2YXIgaGl0ID0gZmFsc2U7XG4gICAgICAgIHZhciBpbnRlcmFjdGl2ZVBhcmVudCA9IGludGVyYWN0aXZlO1xuXG4gICAgICAgIC8vIEZsYWcgaGVyZSBjYW4gc2V0IHRvIGZhbHNlIGlmIHRoZSBldmVudCBpcyBvdXRzaWRlIHRoZSBwYXJlbnRzIGhpdEFyZWEgb3IgbWFza1xuICAgICAgICB2YXIgaGl0VGVzdENoaWxkcmVuID0gdHJ1ZTtcblxuICAgICAgICAvLyBJZiB0aGVyZSBpcyBhIGhpdEFyZWEsIG5vIG5lZWQgdG8gdGVzdCBhZ2FpbnN0IGFueXRoaW5nIGVsc2UgaWYgdGhlIHBvaW50ZXIgaXMgbm90IHdpdGhpbiB0aGUgaGl0QXJlYVxuICAgICAgICAvLyBUaGVyZSBpcyBhbHNvIG5vIGxvbmdlciBhIG5lZWQgdG8gaGl0VGVzdCBjaGlsZHJlbi5cbiAgICAgICAgaWYgKGRpc3BsYXlPYmplY3QuaGl0QXJlYSkge1xuICAgICAgICAgICAgaWYgKGhpdFRlc3QpIHtcbiAgICAgICAgICAgICAgICBkaXNwbGF5T2JqZWN0LndvcmxkVHJhbnNmb3JtLmFwcGx5SW52ZXJzZShwb2ludCwgdGhpcy5fdGVtcFBvaW50KTtcbiAgICAgICAgICAgICAgICBpZiAoIWRpc3BsYXlPYmplY3QuaGl0QXJlYS5jb250YWlucyh0aGlzLl90ZW1wUG9pbnQueCwgdGhpcy5fdGVtcFBvaW50LnkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGhpdFRlc3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaGl0VGVzdENoaWxkcmVuID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbnRlcmFjdGl2ZVBhcmVudCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZXJlIGlzIGEgbWFzaywgbm8gbmVlZCB0byB0ZXN0IGFnYWluc3QgYW55dGhpbmcgZWxzZSBpZiB0aGUgcG9pbnRlciBpcyBub3Qgd2l0aGluIHRoZSBtYXNrXG4gICAgICAgIGVsc2UgaWYgKGRpc3BsYXlPYmplY3QuX21hc2spIHtcbiAgICAgICAgICAgICAgICBpZiAoaGl0VGVzdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWRpc3BsYXlPYmplY3QuX21hc2suY29udGFpbnNQb2ludChwb2ludCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpdFRlc3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpdFRlc3RDaGlsZHJlbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgIC8vICoqIEZSRUUgVElQICoqISBJZiBhbiBvYmplY3QgaXMgbm90IGludGVyYWN0aXZlIG9yIGhhcyBubyBidXR0b25zIGluIGl0XG4gICAgICAgIC8vIChzdWNoIGFzIGEgZ2FtZSBzY2VuZSEpIHNldCBpbnRlcmFjdGl2ZUNoaWxkcmVuIHRvIGZhbHNlIGZvciB0aGF0IGRpc3BsYXlPYmplY3QuXG4gICAgICAgIC8vIFRoaXMgd2lsbCBhbGxvdyBQaXhpSlMgdG8gY29tcGxldGVseSBpZ25vcmUgYW5kIGJ5cGFzcyBjaGVja2luZyB0aGUgZGlzcGxheU9iamVjdHMgY2hpbGRyZW4uXG4gICAgICAgIGlmIChoaXRUZXN0Q2hpbGRyZW4gJiYgZGlzcGxheU9iamVjdC5pbnRlcmFjdGl2ZUNoaWxkcmVuICYmIGRpc3BsYXlPYmplY3QuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IGRpc3BsYXlPYmplY3QuY2hpbGRyZW47XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBjaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuXG4gICAgICAgICAgICAgICAgLy8gdGltZSB0byBnZXQgcmVjdXJzaXZlLi4gaWYgdGhpcyBmdW5jdGlvbiB3aWxsIHJldHVybiBpZiBzb21ldGhpbmcgaXMgaGl0Li5cbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRIaXQgPSB0aGlzLnByb2Nlc3NJbnRlcmFjdGl2ZShpbnRlcmFjdGlvbkV2ZW50LCBjaGlsZCwgZnVuYywgaGl0VGVzdCwgaW50ZXJhY3RpdmVQYXJlbnQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkSGl0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGl0cyBhIGdvb2QgaWRlYSB0byBjaGVjayBpZiBhIGNoaWxkIGhhcyBsb3N0IGl0cyBwYXJlbnQuXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgbWVhbnMgaXQgaGFzIGJlZW4gcmVtb3ZlZCB3aGlsc3QgbG9vcGluZyBzbyBpdHMgYmVzdFxuICAgICAgICAgICAgICAgICAgICBpZiAoIWNoaWxkLnBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBubyBsb25nZXIgbmVlZCB0byBoaXQgdGVzdCBhbnkgbW9yZSBvYmplY3RzIGluIHRoaXMgY29udGFpbmVyIGFzIHdlIHdlXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vdyBrbm93IHRoZSBwYXJlbnQgaGFzIGJlZW4gaGl0XG4gICAgICAgICAgICAgICAgICAgIGludGVyYWN0aXZlUGFyZW50ID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGNoaWxkIGlzIGludGVyYWN0aXZlICwgdGhhdCBtZWFucyB0aGF0IHRoZSBvYmplY3QgaGl0IHdhcyBhY3R1YWxseVxuICAgICAgICAgICAgICAgICAgICAvLyBpbnRlcmFjdGl2ZSBhbmQgbm90IGp1c3QgdGhlIGNoaWxkIG9mIGFuIGludGVyYWN0aXZlIG9iamVjdC5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBtZWFucyB3ZSBubyBsb25nZXIgbmVlZCB0byBoaXQgdGVzdCBhbnl0aGluZyBlbHNlLiBXZSBzdGlsbCBuZWVkIHRvIHJ1blxuICAgICAgICAgICAgICAgICAgICAvLyB0aHJvdWdoIGFsbCBvYmplY3RzLCBidXQgd2UgZG9uJ3QgbmVlZCB0byBwZXJmb3JtIGFueSBoaXQgdGVzdHMuXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkSGl0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW50ZXJhY3Rpb25FdmVudC50YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaXRUZXN0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBoaXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gbm8gcG9pbnQgcnVubmluZyB0aGlzIGlmIHRoZSBpdGVtIGlzIG5vdCBpbnRlcmFjdGl2ZSBvciBkb2VzIG5vdCBoYXZlIGFuIGludGVyYWN0aXZlIHBhcmVudC5cbiAgICAgICAgaWYgKGludGVyYWN0aXZlKSB7XG4gICAgICAgICAgICAvLyBpZiB3ZSBhcmUgaGl0IHRlc3RpbmcgKGFzIGluIHdlIGhhdmUgbm8gaGl0IGFueSBvYmplY3RzIHlldClcbiAgICAgICAgICAgIC8vIFdlIGFsc28gZG9uJ3QgbmVlZCB0byB3b3JyeSBhYm91dCBoaXQgdGVzdGluZyBpZiBvbmNlIG9mIHRoZSBkaXNwbGF5T2JqZWN0cyBjaGlsZHJlblxuICAgICAgICAgICAgLy8gaGFzIGFscmVhZHkgYmVlbiBoaXQgLSBidXQgb25seSBpZiBpdCB3YXMgaW50ZXJhY3RpdmUsIG90aGVyd2lzZSB3ZSBuZWVkIHRvIGtlZXBcbiAgICAgICAgICAgIC8vIGxvb2tpbmcgZm9yIGFuIGludGVyYWN0aXZlIGNoaWxkLCBqdXN0IGluIGNhc2Ugd2UgaGl0IG9uZVxuICAgICAgICAgICAgaWYgKGhpdFRlc3QgJiYgIWludGVyYWN0aW9uRXZlbnQudGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgLy8gYWxyZWFkeSB0ZXN0ZWQgYWdhaW5zdCBoaXRBcmVhIGlmIGl0IGlzIGRlZmluZWRcbiAgICAgICAgICAgICAgICBpZiAoIWRpc3BsYXlPYmplY3QuaGl0QXJlYSAmJiBkaXNwbGF5T2JqZWN0LmNvbnRhaW5zUG9pbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpc3BsYXlPYmplY3QuY29udGFpbnNQb2ludChwb2ludCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkaXNwbGF5T2JqZWN0LmludGVyYWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhpdCAmJiAhaW50ZXJhY3Rpb25FdmVudC50YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJhY3Rpb25FdmVudC50YXJnZXQgPSBkaXNwbGF5T2JqZWN0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChmdW5jKSB7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmMoaW50ZXJhY3Rpb25FdmVudCwgZGlzcGxheU9iamVjdCwgISFoaXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBoaXQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIElzIGNhbGxlZCB3aGVuIHRoZSBwb2ludGVyIGJ1dHRvbiBpcyBwcmVzc2VkIGRvd24gb24gdGhlIHJlbmRlcmVyIGVsZW1lbnRcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtQb2ludGVyRXZlbnR9IG9yaWdpbmFsRXZlbnQgLSBUaGUgRE9NIGV2ZW50IG9mIGEgcG9pbnRlciBidXR0b24gYmVpbmcgcHJlc3NlZCBkb3duXG4gICAgICovXG5cblxuICAgIEludGVyYWN0aW9uTWFuYWdlci5wcm90b3R5cGUub25Qb2ludGVyRG93biA9IGZ1bmN0aW9uIG9uUG9pbnRlckRvd24ob3JpZ2luYWxFdmVudCkge1xuICAgICAgICAvLyBpZiB3ZSBzdXBwb3J0IHRvdWNoIGV2ZW50cywgdGhlbiBvbmx5IHVzZSB0aG9zZSBmb3IgdG91Y2ggZXZlbnRzLCBub3QgcG9pbnRlciBldmVudHNcbiAgICAgICAgaWYgKHRoaXMuc3VwcG9ydHNUb3VjaEV2ZW50cyAmJiBvcmlnaW5hbEV2ZW50LnBvaW50ZXJUeXBlID09PSAndG91Y2gnKSByZXR1cm47XG5cbiAgICAgICAgdmFyIGV2ZW50cyA9IHRoaXMubm9ybWFsaXplVG9Qb2ludGVyRGF0YShvcmlnaW5hbEV2ZW50KTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogTm8gbmVlZCB0byBwcmV2ZW50IGRlZmF1bHQgb24gbmF0dXJhbCBwb2ludGVyIGV2ZW50cywgYXMgdGhlcmUgYXJlIG5vIHNpZGUgZWZmZWN0c1xuICAgICAgICAgKiBOb3JtYWxpemVkIGV2ZW50cywgaG93ZXZlciwgbWF5IGhhdmUgdGhlIGRvdWJsZSBtb3VzZWRvd24vdG91Y2hzdGFydCBpc3N1ZSBvbiB0aGUgbmF0aXZlIGFuZHJvaWQgYnJvd3NlcixcbiAgICAgICAgICogc28gc3RpbGwgbmVlZCB0byBiZSBwcmV2ZW50ZWQuXG4gICAgICAgICAqL1xuXG4gICAgICAgIC8vIEd1YXJhbnRlZWQgdGhhdCB0aGVyZSB3aWxsIGJlIGF0IGxlYXN0IG9uZSBldmVudCBpbiBldmVudHMsIGFuZCBhbGwgZXZlbnRzIG11c3QgaGF2ZSB0aGUgc2FtZSBwb2ludGVyIHR5cGVcblxuICAgICAgICBpZiAodGhpcy5hdXRvUHJldmVudERlZmF1bHQgJiYgZXZlbnRzWzBdLmlzTm9ybWFsaXplZCkge1xuICAgICAgICAgICAgb3JpZ2luYWxFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGV2ZW50TGVuID0gZXZlbnRzLmxlbmd0aDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV2ZW50TGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBldmVudCA9IGV2ZW50c1tpXTtcblxuICAgICAgICAgICAgdmFyIGludGVyYWN0aW9uRGF0YSA9IHRoaXMuZ2V0SW50ZXJhY3Rpb25EYXRhRm9yUG9pbnRlcklkKGV2ZW50KTtcblxuICAgICAgICAgICAgdmFyIGludGVyYWN0aW9uRXZlbnQgPSB0aGlzLmNvbmZpZ3VyZUludGVyYWN0aW9uRXZlbnRGb3JET01FdmVudCh0aGlzLmV2ZW50RGF0YSwgZXZlbnQsIGludGVyYWN0aW9uRGF0YSk7XG5cbiAgICAgICAgICAgIGludGVyYWN0aW9uRXZlbnQuZGF0YS5vcmlnaW5hbEV2ZW50ID0gb3JpZ2luYWxFdmVudDtcblxuICAgICAgICAgICAgdGhpcy5wcm9jZXNzSW50ZXJhY3RpdmUoaW50ZXJhY3Rpb25FdmVudCwgdGhpcy5yZW5kZXJlci5fbGFzdE9iamVjdFJlbmRlcmVkLCB0aGlzLnByb2Nlc3NQb2ludGVyRG93biwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIHRoaXMuZW1pdCgncG9pbnRlcmRvd24nLCBpbnRlcmFjdGlvbkV2ZW50KTtcbiAgICAgICAgICAgIGlmIChldmVudC5wb2ludGVyVHlwZSA9PT0gJ3RvdWNoJykge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgndG91Y2hzdGFydCcsIGludGVyYWN0aW9uRXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZW1pdCBhIG1vdXNlIGV2ZW50IGZvciBcInBlblwiIHBvaW50ZXJzLCB0aGUgd2F5IGEgYnJvd3NlciB3b3VsZCBlbWl0IGEgZmFsbGJhY2sgZXZlbnRcbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50LnBvaW50ZXJUeXBlID09PSAnbW91c2UnIHx8IGV2ZW50LnBvaW50ZXJUeXBlID09PSAncGVuJykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaXNSaWdodEJ1dHRvbiA9IGV2ZW50LmJ1dHRvbiA9PT0gMjtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoaXNSaWdodEJ1dHRvbiA/ICdyaWdodGRvd24nIDogJ21vdXNlZG93bicsIHRoaXMuZXZlbnREYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUHJvY2Vzc2VzIHRoZSByZXN1bHQgb2YgdGhlIHBvaW50ZXIgZG93biBjaGVjayBhbmQgZGlzcGF0Y2hlcyB0aGUgZXZlbnQgaWYgbmVlZCBiZVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1BJWEkuaW50ZXJhY3Rpb24uSW50ZXJhY3Rpb25FdmVudH0gaW50ZXJhY3Rpb25FdmVudCAtIFRoZSBpbnRlcmFjdGlvbiBldmVudCB3cmFwcGluZyB0aGUgRE9NIGV2ZW50XG4gICAgICogQHBhcmFtIHtQSVhJLkNvbnRhaW5lcnxQSVhJLlNwcml0ZXxQSVhJLmV4dHJhcy5UaWxpbmdTcHJpdGV9IGRpc3BsYXlPYmplY3QgLSBUaGUgZGlzcGxheSBvYmplY3QgdGhhdCB3YXMgdGVzdGVkXG4gICAgICogQHBhcmFtIHtib29sZWFufSBoaXQgLSB0aGUgcmVzdWx0IG9mIHRoZSBoaXQgdGVzdCBvbiB0aGUgZGlzcGxheSBvYmplY3RcbiAgICAgKi9cblxuXG4gICAgSW50ZXJhY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5wcm9jZXNzUG9pbnRlckRvd24gPSBmdW5jdGlvbiBwcm9jZXNzUG9pbnRlckRvd24oaW50ZXJhY3Rpb25FdmVudCwgZGlzcGxheU9iamVjdCwgaGl0KSB7XG4gICAgICAgIHZhciBkYXRhID0gaW50ZXJhY3Rpb25FdmVudC5kYXRhO1xuICAgICAgICB2YXIgaWQgPSBpbnRlcmFjdGlvbkV2ZW50LmRhdGEuaWRlbnRpZmllcjtcblxuICAgICAgICBpZiAoaGl0KSB7XG4gICAgICAgICAgICBpZiAoIWRpc3BsYXlPYmplY3QudHJhY2tlZFBvaW50ZXJzW2lkXSkge1xuICAgICAgICAgICAgICAgIGRpc3BsYXlPYmplY3QudHJhY2tlZFBvaW50ZXJzW2lkXSA9IG5ldyBfSW50ZXJhY3Rpb25UcmFja2luZ0RhdGEyLmRlZmF1bHQoaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGRpc3BsYXlPYmplY3QsICdwb2ludGVyZG93bicsIGludGVyYWN0aW9uRXZlbnQpO1xuXG4gICAgICAgICAgICBpZiAoZGF0YS5wb2ludGVyVHlwZSA9PT0gJ3RvdWNoJykge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChkaXNwbGF5T2JqZWN0LCAndG91Y2hzdGFydCcsIGludGVyYWN0aW9uRXZlbnQpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChkYXRhLnBvaW50ZXJUeXBlID09PSAnbW91c2UnIHx8IGRhdGEucG9pbnRlclR5cGUgPT09ICdwZW4nKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlzUmlnaHRCdXR0b24gPSBkYXRhLmJ1dHRvbiA9PT0gMjtcblxuICAgICAgICAgICAgICAgIGlmIChpc1JpZ2h0QnV0dG9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXlPYmplY3QudHJhY2tlZFBvaW50ZXJzW2lkXS5yaWdodERvd24gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXlPYmplY3QudHJhY2tlZFBvaW50ZXJzW2lkXS5sZWZ0RG93biA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGRpc3BsYXlPYmplY3QsIGlzUmlnaHRCdXR0b24gPyAncmlnaHRkb3duJyA6ICdtb3VzZWRvd24nLCBpbnRlcmFjdGlvbkV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJcyBjYWxsZWQgd2hlbiB0aGUgcG9pbnRlciBidXR0b24gaXMgcmVsZWFzZWQgb24gdGhlIHJlbmRlcmVyIGVsZW1lbnRcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtQb2ludGVyRXZlbnR9IG9yaWdpbmFsRXZlbnQgLSBUaGUgRE9NIGV2ZW50IG9mIGEgcG9pbnRlciBidXR0b24gYmVpbmcgcmVsZWFzZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNhbmNlbGxlZCAtIHRydWUgaWYgdGhlIHBvaW50ZXIgaXMgY2FuY2VsbGVkXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyAtIEZ1bmN0aW9uIHBhc3NlZCB0byB7QGxpbmsgcHJvY2Vzc0ludGVyYWN0aXZlfVxuICAgICAqL1xuXG5cbiAgICBJbnRlcmFjdGlvbk1hbmFnZXIucHJvdG90eXBlLm9uUG9pbnRlckNvbXBsZXRlID0gZnVuY3Rpb24gb25Qb2ludGVyQ29tcGxldGUob3JpZ2luYWxFdmVudCwgY2FuY2VsbGVkLCBmdW5jKSB7XG4gICAgICAgIHZhciBldmVudHMgPSB0aGlzLm5vcm1hbGl6ZVRvUG9pbnRlckRhdGEob3JpZ2luYWxFdmVudCk7XG5cbiAgICAgICAgdmFyIGV2ZW50TGVuID0gZXZlbnRzLmxlbmd0aDtcblxuICAgICAgICAvLyBpZiB0aGUgZXZlbnQgd2Fzbid0IHRhcmdldGluZyBvdXIgY2FudmFzLCB0aGVuIGNvbnNpZGVyIGl0IHRvIGJlIHBvaW50ZXJ1cG91dHNpZGVcbiAgICAgICAgLy8gaW4gYWxsIGNhc2VzICh1bmxlc3MgaXQgd2FzIGEgcG9pbnRlcmNhbmNlbClcbiAgICAgICAgdmFyIGV2ZW50QXBwZW5kID0gb3JpZ2luYWxFdmVudC50YXJnZXQgIT09IHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50ID8gJ291dHNpZGUnIDogJyc7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBldmVudExlbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZXZlbnQgPSBldmVudHNbaV07XG5cbiAgICAgICAgICAgIHZhciBpbnRlcmFjdGlvbkRhdGEgPSB0aGlzLmdldEludGVyYWN0aW9uRGF0YUZvclBvaW50ZXJJZChldmVudCk7XG5cbiAgICAgICAgICAgIHZhciBpbnRlcmFjdGlvbkV2ZW50ID0gdGhpcy5jb25maWd1cmVJbnRlcmFjdGlvbkV2ZW50Rm9yRE9NRXZlbnQodGhpcy5ldmVudERhdGEsIGV2ZW50LCBpbnRlcmFjdGlvbkRhdGEpO1xuXG4gICAgICAgICAgICBpbnRlcmFjdGlvbkV2ZW50LmRhdGEub3JpZ2luYWxFdmVudCA9IG9yaWdpbmFsRXZlbnQ7XG5cbiAgICAgICAgICAgIC8vIHBlcmZvcm0gaGl0IHRlc3RpbmcgZm9yIGV2ZW50cyB0YXJnZXRpbmcgb3VyIGNhbnZhcyBvciBjYW5jZWwgZXZlbnRzXG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NJbnRlcmFjdGl2ZShpbnRlcmFjdGlvbkV2ZW50LCB0aGlzLnJlbmRlcmVyLl9sYXN0T2JqZWN0UmVuZGVyZWQsIGZ1bmMsIGNhbmNlbGxlZCB8fCAhZXZlbnRBcHBlbmQpO1xuXG4gICAgICAgICAgICB0aGlzLmVtaXQoY2FuY2VsbGVkID8gJ3BvaW50ZXJjYW5jZWwnIDogJ3BvaW50ZXJ1cCcgKyBldmVudEFwcGVuZCwgaW50ZXJhY3Rpb25FdmVudCk7XG5cbiAgICAgICAgICAgIGlmIChldmVudC5wb2ludGVyVHlwZSA9PT0gJ21vdXNlJyB8fCBldmVudC5wb2ludGVyVHlwZSA9PT0gJ3BlbicpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXNSaWdodEJ1dHRvbiA9IGV2ZW50LmJ1dHRvbiA9PT0gMjtcblxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChpc1JpZ2h0QnV0dG9uID8gJ3JpZ2h0dXAnICsgZXZlbnRBcHBlbmQgOiAnbW91c2V1cCcgKyBldmVudEFwcGVuZCwgaW50ZXJhY3Rpb25FdmVudCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LnBvaW50ZXJUeXBlID09PSAndG91Y2gnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KGNhbmNlbGxlZCA/ICd0b3VjaGNhbmNlbCcgOiAndG91Y2hlbmQnICsgZXZlbnRBcHBlbmQsIGludGVyYWN0aW9uRXZlbnQpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVsZWFzZUludGVyYWN0aW9uRGF0YUZvclBvaW50ZXJJZChldmVudC5wb2ludGVySWQsIGludGVyYWN0aW9uRGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSXMgY2FsbGVkIHdoZW4gdGhlIHBvaW50ZXIgYnV0dG9uIGlzIGNhbmNlbGxlZFxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1BvaW50ZXJFdmVudH0gZXZlbnQgLSBUaGUgRE9NIGV2ZW50IG9mIGEgcG9pbnRlciBidXR0b24gYmVpbmcgcmVsZWFzZWRcbiAgICAgKi9cblxuXG4gICAgSW50ZXJhY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5vblBvaW50ZXJDYW5jZWwgPSBmdW5jdGlvbiBvblBvaW50ZXJDYW5jZWwoZXZlbnQpIHtcbiAgICAgICAgLy8gaWYgd2Ugc3VwcG9ydCB0b3VjaCBldmVudHMsIHRoZW4gb25seSB1c2UgdGhvc2UgZm9yIHRvdWNoIGV2ZW50cywgbm90IHBvaW50ZXIgZXZlbnRzXG4gICAgICAgIGlmICh0aGlzLnN1cHBvcnRzVG91Y2hFdmVudHMgJiYgZXZlbnQucG9pbnRlclR5cGUgPT09ICd0b3VjaCcpIHJldHVybjtcblxuICAgICAgICB0aGlzLm9uUG9pbnRlckNvbXBsZXRlKGV2ZW50LCB0cnVlLCB0aGlzLnByb2Nlc3NQb2ludGVyQ2FuY2VsKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUHJvY2Vzc2VzIHRoZSByZXN1bHQgb2YgdGhlIHBvaW50ZXIgY2FuY2VsIGNoZWNrIGFuZCBkaXNwYXRjaGVzIHRoZSBldmVudCBpZiBuZWVkIGJlXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7UElYSS5pbnRlcmFjdGlvbi5JbnRlcmFjdGlvbkV2ZW50fSBpbnRlcmFjdGlvbkV2ZW50IC0gVGhlIGludGVyYWN0aW9uIGV2ZW50IHdyYXBwaW5nIHRoZSBET00gZXZlbnRcbiAgICAgKiBAcGFyYW0ge1BJWEkuQ29udGFpbmVyfFBJWEkuU3ByaXRlfFBJWEkuZXh0cmFzLlRpbGluZ1Nwcml0ZX0gZGlzcGxheU9iamVjdCAtIFRoZSBkaXNwbGF5IG9iamVjdCB0aGF0IHdhcyB0ZXN0ZWRcbiAgICAgKi9cblxuXG4gICAgSW50ZXJhY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5wcm9jZXNzUG9pbnRlckNhbmNlbCA9IGZ1bmN0aW9uIHByb2Nlc3NQb2ludGVyQ2FuY2VsKGludGVyYWN0aW9uRXZlbnQsIGRpc3BsYXlPYmplY3QpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBpbnRlcmFjdGlvbkV2ZW50LmRhdGE7XG5cbiAgICAgICAgdmFyIGlkID0gaW50ZXJhY3Rpb25FdmVudC5kYXRhLmlkZW50aWZpZXI7XG5cbiAgICAgICAgaWYgKGRpc3BsYXlPYmplY3QudHJhY2tlZFBvaW50ZXJzW2lkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBkZWxldGUgZGlzcGxheU9iamVjdC50cmFja2VkUG9pbnRlcnNbaWRdO1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGRpc3BsYXlPYmplY3QsICdwb2ludGVyY2FuY2VsJywgaW50ZXJhY3Rpb25FdmVudCk7XG5cbiAgICAgICAgICAgIGlmIChkYXRhLnBvaW50ZXJUeXBlID09PSAndG91Y2gnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGRpc3BsYXlPYmplY3QsICd0b3VjaGNhbmNlbCcsIGludGVyYWN0aW9uRXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIElzIGNhbGxlZCB3aGVuIHRoZSBwb2ludGVyIGJ1dHRvbiBpcyByZWxlYXNlZCBvbiB0aGUgcmVuZGVyZXIgZWxlbWVudFxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1BvaW50ZXJFdmVudH0gZXZlbnQgLSBUaGUgRE9NIGV2ZW50IG9mIGEgcG9pbnRlciBidXR0b24gYmVpbmcgcmVsZWFzZWRcbiAgICAgKi9cblxuXG4gICAgSW50ZXJhY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5vblBvaW50ZXJVcCA9IGZ1bmN0aW9uIG9uUG9pbnRlclVwKGV2ZW50KSB7XG4gICAgICAgIC8vIGlmIHdlIHN1cHBvcnQgdG91Y2ggZXZlbnRzLCB0aGVuIG9ubHkgdXNlIHRob3NlIGZvciB0b3VjaCBldmVudHMsIG5vdCBwb2ludGVyIGV2ZW50c1xuICAgICAgICBpZiAodGhpcy5zdXBwb3J0c1RvdWNoRXZlbnRzICYmIGV2ZW50LnBvaW50ZXJUeXBlID09PSAndG91Y2gnKSByZXR1cm47XG5cbiAgICAgICAgdGhpcy5vblBvaW50ZXJDb21wbGV0ZShldmVudCwgZmFsc2UsIHRoaXMucHJvY2Vzc1BvaW50ZXJVcCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFByb2Nlc3NlcyB0aGUgcmVzdWx0IG9mIHRoZSBwb2ludGVyIHVwIGNoZWNrIGFuZCBkaXNwYXRjaGVzIHRoZSBldmVudCBpZiBuZWVkIGJlXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7UElYSS5pbnRlcmFjdGlvbi5JbnRlcmFjdGlvbkV2ZW50fSBpbnRlcmFjdGlvbkV2ZW50IC0gVGhlIGludGVyYWN0aW9uIGV2ZW50IHdyYXBwaW5nIHRoZSBET00gZXZlbnRcbiAgICAgKiBAcGFyYW0ge1BJWEkuQ29udGFpbmVyfFBJWEkuU3ByaXRlfFBJWEkuZXh0cmFzLlRpbGluZ1Nwcml0ZX0gZGlzcGxheU9iamVjdCAtIFRoZSBkaXNwbGF5IG9iamVjdCB0aGF0IHdhcyB0ZXN0ZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhpdCAtIHRoZSByZXN1bHQgb2YgdGhlIGhpdCB0ZXN0IG9uIHRoZSBkaXNwbGF5IG9iamVjdFxuICAgICAqL1xuXG5cbiAgICBJbnRlcmFjdGlvbk1hbmFnZXIucHJvdG90eXBlLnByb2Nlc3NQb2ludGVyVXAgPSBmdW5jdGlvbiBwcm9jZXNzUG9pbnRlclVwKGludGVyYWN0aW9uRXZlbnQsIGRpc3BsYXlPYmplY3QsIGhpdCkge1xuICAgICAgICB2YXIgZGF0YSA9IGludGVyYWN0aW9uRXZlbnQuZGF0YTtcblxuICAgICAgICB2YXIgaWQgPSBpbnRlcmFjdGlvbkV2ZW50LmRhdGEuaWRlbnRpZmllcjtcblxuICAgICAgICB2YXIgdHJhY2tpbmdEYXRhID0gZGlzcGxheU9iamVjdC50cmFja2VkUG9pbnRlcnNbaWRdO1xuXG4gICAgICAgIHZhciBpc1RvdWNoID0gZGF0YS5wb2ludGVyVHlwZSA9PT0gJ3RvdWNoJztcblxuICAgICAgICB2YXIgaXNNb3VzZSA9IGRhdGEucG9pbnRlclR5cGUgPT09ICdtb3VzZScgfHwgZGF0YS5wb2ludGVyVHlwZSA9PT0gJ3Blbic7XG4gICAgICAgIC8vIG5lZWQgdG8gdHJhY2sgbW91c2UgZG93biBzdGF0dXMgaW4gdGhlIG1vdXNlIGJsb2NrIHNvIHRoYXQgd2UgY2FuIGVtaXRcbiAgICAgICAgLy8gZXZlbnQgaW4gYSBsYXRlciBibG9ja1xuICAgICAgICB2YXIgaXNNb3VzZVRhcCA9IGZhbHNlO1xuXG4gICAgICAgIC8vIE1vdXNlIG9ubHlcbiAgICAgICAgaWYgKGlzTW91c2UpIHtcbiAgICAgICAgICAgIHZhciBpc1JpZ2h0QnV0dG9uID0gZGF0YS5idXR0b24gPT09IDI7XG5cbiAgICAgICAgICAgIHZhciBmbGFncyA9IF9JbnRlcmFjdGlvblRyYWNraW5nRGF0YTIuZGVmYXVsdC5GTEFHUztcblxuICAgICAgICAgICAgdmFyIHRlc3QgPSBpc1JpZ2h0QnV0dG9uID8gZmxhZ3MuUklHSFRfRE9XTiA6IGZsYWdzLkxFRlRfRE9XTjtcblxuICAgICAgICAgICAgdmFyIGlzRG93biA9IHRyYWNraW5nRGF0YSAhPT0gdW5kZWZpbmVkICYmIHRyYWNraW5nRGF0YS5mbGFncyAmIHRlc3Q7XG5cbiAgICAgICAgICAgIGlmIChoaXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZGlzcGxheU9iamVjdCwgaXNSaWdodEJ1dHRvbiA/ICdyaWdodHVwJyA6ICdtb3VzZXVwJywgaW50ZXJhY3Rpb25FdmVudCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNEb3duKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChkaXNwbGF5T2JqZWN0LCBpc1JpZ2h0QnV0dG9uID8gJ3JpZ2h0Y2xpY2snIDogJ2NsaWNrJywgaW50ZXJhY3Rpb25FdmVudCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGJlY2F1c2Ugd2UgY2FuIGNvbmZpcm0gdGhhdCB0aGUgbW91c2Vkb3duIGhhcHBlbmVkIG9uIHRoaXMgb2JqZWN0LCBmbGFnIGZvciBsYXRlciBlbWl0IG9mIHBvaW50ZXJ0YXBcbiAgICAgICAgICAgICAgICAgICAgaXNNb3VzZVRhcCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0Rvd24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZGlzcGxheU9iamVjdCwgaXNSaWdodEJ1dHRvbiA/ICdyaWdodHVwb3V0c2lkZScgOiAnbW91c2V1cG91dHNpZGUnLCBpbnRlcmFjdGlvbkV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgZG93biBzdGF0ZSBvZiB0aGUgdHJhY2tpbmcgZGF0YVxuICAgICAgICAgICAgaWYgKHRyYWNraW5nRGF0YSkge1xuICAgICAgICAgICAgICAgIGlmIChpc1JpZ2h0QnV0dG9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNraW5nRGF0YS5yaWdodERvd24gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0cmFja2luZ0RhdGEubGVmdERvd24gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQb2ludGVycyBhbmQgVG91Y2hlcywgYW5kIE1vdXNlXG4gICAgICAgIGlmIChoaXQpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChkaXNwbGF5T2JqZWN0LCAncG9pbnRlcnVwJywgaW50ZXJhY3Rpb25FdmVudCk7XG4gICAgICAgICAgICBpZiAoaXNUb3VjaCkgdGhpcy5kaXNwYXRjaEV2ZW50KGRpc3BsYXlPYmplY3QsICd0b3VjaGVuZCcsIGludGVyYWN0aW9uRXZlbnQpO1xuXG4gICAgICAgICAgICBpZiAodHJhY2tpbmdEYXRhKSB7XG4gICAgICAgICAgICAgICAgLy8gZW1pdCBwb2ludGVydGFwIGlmIG5vdCBhIG1vdXNlLCBvciBpZiB0aGUgbW91c2UgYmxvY2sgZGVjaWRlZCBpdCB3YXMgYSB0YXBcbiAgICAgICAgICAgICAgICBpZiAoIWlzTW91c2UgfHwgaXNNb3VzZVRhcCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZGlzcGxheU9iamVjdCwgJ3BvaW50ZXJ0YXAnLCBpbnRlcmFjdGlvbkV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzVG91Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGRpc3BsYXlPYmplY3QsICd0YXAnLCBpbnRlcmFjdGlvbkV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gdG91Y2hlcyBhcmUgbm8gbG9uZ2VyIG92ZXIgKGlmIHRoZXkgZXZlciB3ZXJlKSB3aGVuIHdlIGdldCB0aGUgdG91Y2hlbmRcbiAgICAgICAgICAgICAgICAgICAgLy8gc28gd2Ugc2hvdWxkIGVuc3VyZSB0aGF0IHdlIGRvbid0IGtlZXAgcHJldGVuZGluZyB0aGF0IHRoZXkgYXJlXG4gICAgICAgICAgICAgICAgICAgIHRyYWNraW5nRGF0YS5vdmVyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRyYWNraW5nRGF0YSkge1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGRpc3BsYXlPYmplY3QsICdwb2ludGVydXBvdXRzaWRlJywgaW50ZXJhY3Rpb25FdmVudCk7XG4gICAgICAgICAgICBpZiAoaXNUb3VjaCkgdGhpcy5kaXNwYXRjaEV2ZW50KGRpc3BsYXlPYmplY3QsICd0b3VjaGVuZG91dHNpZGUnLCBpbnRlcmFjdGlvbkV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBPbmx5IHJlbW92ZSB0aGUgdHJhY2tpbmcgZGF0YSBpZiB0aGVyZSBpcyBubyBvdmVyL2Rvd24gc3RhdGUgc3RpbGwgYXNzb2NpYXRlZCB3aXRoIGl0XG4gICAgICAgIGlmICh0cmFja2luZ0RhdGEgJiYgdHJhY2tpbmdEYXRhLm5vbmUpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBkaXNwbGF5T2JqZWN0LnRyYWNrZWRQb2ludGVyc1tpZF07XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSXMgY2FsbGVkIHdoZW4gdGhlIHBvaW50ZXIgbW92ZXMgYWNyb3NzIHRoZSByZW5kZXJlciBlbGVtZW50XG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7UG9pbnRlckV2ZW50fSBvcmlnaW5hbEV2ZW50IC0gVGhlIERPTSBldmVudCBvZiBhIHBvaW50ZXIgbW92aW5nXG4gICAgICovXG5cblxuICAgIEludGVyYWN0aW9uTWFuYWdlci5wcm90b3R5cGUub25Qb2ludGVyTW92ZSA9IGZ1bmN0aW9uIG9uUG9pbnRlck1vdmUob3JpZ2luYWxFdmVudCkge1xuICAgICAgICAvLyBpZiB3ZSBzdXBwb3J0IHRvdWNoIGV2ZW50cywgdGhlbiBvbmx5IHVzZSB0aG9zZSBmb3IgdG91Y2ggZXZlbnRzLCBub3QgcG9pbnRlciBldmVudHNcbiAgICAgICAgaWYgKHRoaXMuc3VwcG9ydHNUb3VjaEV2ZW50cyAmJiBvcmlnaW5hbEV2ZW50LnBvaW50ZXJUeXBlID09PSAndG91Y2gnKSByZXR1cm47XG5cbiAgICAgICAgdmFyIGV2ZW50cyA9IHRoaXMubm9ybWFsaXplVG9Qb2ludGVyRGF0YShvcmlnaW5hbEV2ZW50KTtcblxuICAgICAgICBpZiAoZXZlbnRzWzBdLnBvaW50ZXJUeXBlID09PSAnbW91c2UnIHx8IGV2ZW50c1swXS5wb2ludGVyVHlwZSA9PT0gJ3BlbicpIHtcbiAgICAgICAgICAgIHRoaXMuZGlkTW92ZSA9IHRydWU7XG5cbiAgICAgICAgICAgIHRoaXMuY3Vyc29yID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBldmVudExlbiA9IGV2ZW50cy5sZW5ndGg7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBldmVudExlbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZXZlbnQgPSBldmVudHNbaV07XG5cbiAgICAgICAgICAgIHZhciBpbnRlcmFjdGlvbkRhdGEgPSB0aGlzLmdldEludGVyYWN0aW9uRGF0YUZvclBvaW50ZXJJZChldmVudCk7XG5cbiAgICAgICAgICAgIHZhciBpbnRlcmFjdGlvbkV2ZW50ID0gdGhpcy5jb25maWd1cmVJbnRlcmFjdGlvbkV2ZW50Rm9yRE9NRXZlbnQodGhpcy5ldmVudERhdGEsIGV2ZW50LCBpbnRlcmFjdGlvbkRhdGEpO1xuXG4gICAgICAgICAgICBpbnRlcmFjdGlvbkV2ZW50LmRhdGEub3JpZ2luYWxFdmVudCA9IG9yaWdpbmFsRXZlbnQ7XG5cbiAgICAgICAgICAgIHZhciBpbnRlcmFjdGl2ZSA9IGV2ZW50LnBvaW50ZXJUeXBlID09PSAndG91Y2gnID8gdGhpcy5tb3ZlV2hlbkluc2lkZSA6IHRydWU7XG5cbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc0ludGVyYWN0aXZlKGludGVyYWN0aW9uRXZlbnQsIHRoaXMucmVuZGVyZXIuX2xhc3RPYmplY3RSZW5kZXJlZCwgdGhpcy5wcm9jZXNzUG9pbnRlck1vdmUsIGludGVyYWN0aXZlKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncG9pbnRlcm1vdmUnLCBpbnRlcmFjdGlvbkV2ZW50KTtcbiAgICAgICAgICAgIGlmIChldmVudC5wb2ludGVyVHlwZSA9PT0gJ3RvdWNoJykgdGhpcy5lbWl0KCd0b3VjaG1vdmUnLCBpbnRlcmFjdGlvbkV2ZW50KTtcbiAgICAgICAgICAgIGlmIChldmVudC5wb2ludGVyVHlwZSA9PT0gJ21vdXNlJyB8fCBldmVudC5wb2ludGVyVHlwZSA9PT0gJ3BlbicpIHRoaXMuZW1pdCgnbW91c2Vtb3ZlJywgaW50ZXJhY3Rpb25FdmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXZlbnRzWzBdLnBvaW50ZXJUeXBlID09PSAnbW91c2UnKSB7XG4gICAgICAgICAgICB0aGlzLnNldEN1cnNvck1vZGUodGhpcy5jdXJzb3IpO1xuXG4gICAgICAgICAgICAvLyBUT0RPIEJVRyBmb3IgcGFyZW50cyBpbnRlcmFjdGl2ZSBvYmplY3QgKGJvcmRlciBvcmRlciBpc3N1ZSlcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzZXMgdGhlIHJlc3VsdCBvZiB0aGUgcG9pbnRlciBtb3ZlIGNoZWNrIGFuZCBkaXNwYXRjaGVzIHRoZSBldmVudCBpZiBuZWVkIGJlXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7UElYSS5pbnRlcmFjdGlvbi5JbnRlcmFjdGlvbkV2ZW50fSBpbnRlcmFjdGlvbkV2ZW50IC0gVGhlIGludGVyYWN0aW9uIGV2ZW50IHdyYXBwaW5nIHRoZSBET00gZXZlbnRcbiAgICAgKiBAcGFyYW0ge1BJWEkuQ29udGFpbmVyfFBJWEkuU3ByaXRlfFBJWEkuZXh0cmFzLlRpbGluZ1Nwcml0ZX0gZGlzcGxheU9iamVjdCAtIFRoZSBkaXNwbGF5IG9iamVjdCB0aGF0IHdhcyB0ZXN0ZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhpdCAtIHRoZSByZXN1bHQgb2YgdGhlIGhpdCB0ZXN0IG9uIHRoZSBkaXNwbGF5IG9iamVjdFxuICAgICAqL1xuXG5cbiAgICBJbnRlcmFjdGlvbk1hbmFnZXIucHJvdG90eXBlLnByb2Nlc3NQb2ludGVyTW92ZSA9IGZ1bmN0aW9uIHByb2Nlc3NQb2ludGVyTW92ZShpbnRlcmFjdGlvbkV2ZW50LCBkaXNwbGF5T2JqZWN0LCBoaXQpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBpbnRlcmFjdGlvbkV2ZW50LmRhdGE7XG5cbiAgICAgICAgdmFyIGlzVG91Y2ggPSBkYXRhLnBvaW50ZXJUeXBlID09PSAndG91Y2gnO1xuXG4gICAgICAgIHZhciBpc01vdXNlID0gZGF0YS5wb2ludGVyVHlwZSA9PT0gJ21vdXNlJyB8fCBkYXRhLnBvaW50ZXJUeXBlID09PSAncGVuJztcblxuICAgICAgICBpZiAoaXNNb3VzZSkge1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzUG9pbnRlck92ZXJPdXQoaW50ZXJhY3Rpb25FdmVudCwgZGlzcGxheU9iamVjdCwgaGl0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5tb3ZlV2hlbkluc2lkZSB8fCBoaXQpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChkaXNwbGF5T2JqZWN0LCAncG9pbnRlcm1vdmUnLCBpbnRlcmFjdGlvbkV2ZW50KTtcbiAgICAgICAgICAgIGlmIChpc1RvdWNoKSB0aGlzLmRpc3BhdGNoRXZlbnQoZGlzcGxheU9iamVjdCwgJ3RvdWNobW92ZScsIGludGVyYWN0aW9uRXZlbnQpO1xuICAgICAgICAgICAgaWYgKGlzTW91c2UpIHRoaXMuZGlzcGF0Y2hFdmVudChkaXNwbGF5T2JqZWN0LCAnbW91c2Vtb3ZlJywgaW50ZXJhY3Rpb25FdmVudCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSXMgY2FsbGVkIHdoZW4gdGhlIHBvaW50ZXIgaXMgbW92ZWQgb3V0IG9mIHRoZSByZW5kZXJlciBlbGVtZW50XG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7UG9pbnRlckV2ZW50fSBvcmlnaW5hbEV2ZW50IC0gVGhlIERPTSBldmVudCBvZiBhIHBvaW50ZXIgYmVpbmcgbW92ZWQgb3V0XG4gICAgICovXG5cblxuICAgIEludGVyYWN0aW9uTWFuYWdlci5wcm90b3R5cGUub25Qb2ludGVyT3V0ID0gZnVuY3Rpb24gb25Qb2ludGVyT3V0KG9yaWdpbmFsRXZlbnQpIHtcbiAgICAgICAgLy8gaWYgd2Ugc3VwcG9ydCB0b3VjaCBldmVudHMsIHRoZW4gb25seSB1c2UgdGhvc2UgZm9yIHRvdWNoIGV2ZW50cywgbm90IHBvaW50ZXIgZXZlbnRzXG4gICAgICAgIGlmICh0aGlzLnN1cHBvcnRzVG91Y2hFdmVudHMgJiYgb3JpZ2luYWxFdmVudC5wb2ludGVyVHlwZSA9PT0gJ3RvdWNoJykgcmV0dXJuO1xuXG4gICAgICAgIHZhciBldmVudHMgPSB0aGlzLm5vcm1hbGl6ZVRvUG9pbnRlckRhdGEob3JpZ2luYWxFdmVudCk7XG5cbiAgICAgICAgLy8gT25seSBtb3VzZSBhbmQgcG9pbnRlciBjYW4gY2FsbCBvblBvaW50ZXJPdXQsIHNvIGV2ZW50cyB3aWxsIGFsd2F5cyBiZSBsZW5ndGggMVxuICAgICAgICB2YXIgZXZlbnQgPSBldmVudHNbMF07XG5cbiAgICAgICAgaWYgKGV2ZW50LnBvaW50ZXJUeXBlID09PSAnbW91c2UnKSB7XG4gICAgICAgICAgICB0aGlzLm1vdXNlT3ZlclJlbmRlcmVyID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnNldEN1cnNvck1vZGUobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaW50ZXJhY3Rpb25EYXRhID0gdGhpcy5nZXRJbnRlcmFjdGlvbkRhdGFGb3JQb2ludGVySWQoZXZlbnQpO1xuXG4gICAgICAgIHZhciBpbnRlcmFjdGlvbkV2ZW50ID0gdGhpcy5jb25maWd1cmVJbnRlcmFjdGlvbkV2ZW50Rm9yRE9NRXZlbnQodGhpcy5ldmVudERhdGEsIGV2ZW50LCBpbnRlcmFjdGlvbkRhdGEpO1xuXG4gICAgICAgIGludGVyYWN0aW9uRXZlbnQuZGF0YS5vcmlnaW5hbEV2ZW50ID0gZXZlbnQ7XG5cbiAgICAgICAgdGhpcy5wcm9jZXNzSW50ZXJhY3RpdmUoaW50ZXJhY3Rpb25FdmVudCwgdGhpcy5yZW5kZXJlci5fbGFzdE9iamVjdFJlbmRlcmVkLCB0aGlzLnByb2Nlc3NQb2ludGVyT3Zlck91dCwgZmFsc2UpO1xuXG4gICAgICAgIHRoaXMuZW1pdCgncG9pbnRlcm91dCcsIGludGVyYWN0aW9uRXZlbnQpO1xuICAgICAgICBpZiAoZXZlbnQucG9pbnRlclR5cGUgPT09ICdtb3VzZScgfHwgZXZlbnQucG9pbnRlclR5cGUgPT09ICdwZW4nKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ21vdXNlb3V0JywgaW50ZXJhY3Rpb25FdmVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB3ZSBjYW4gZ2V0IHRvdWNobGVhdmUgZXZlbnRzIGFmdGVyIHRvdWNoZW5kLCBzbyB3ZSB3YW50IHRvIG1ha2Ugc3VyZSB3ZSBkb24ndFxuICAgICAgICAgICAgLy8gaW50cm9kdWNlIG1lbW9yeSBsZWFrc1xuICAgICAgICAgICAgdGhpcy5yZWxlYXNlSW50ZXJhY3Rpb25EYXRhRm9yUG9pbnRlcklkKGludGVyYWN0aW9uRGF0YS5pZGVudGlmaWVyKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzZXMgdGhlIHJlc3VsdCBvZiB0aGUgcG9pbnRlciBvdmVyL291dCBjaGVjayBhbmQgZGlzcGF0Y2hlcyB0aGUgZXZlbnQgaWYgbmVlZCBiZVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1BJWEkuaW50ZXJhY3Rpb24uSW50ZXJhY3Rpb25FdmVudH0gaW50ZXJhY3Rpb25FdmVudCAtIFRoZSBpbnRlcmFjdGlvbiBldmVudCB3cmFwcGluZyB0aGUgRE9NIGV2ZW50XG4gICAgICogQHBhcmFtIHtQSVhJLkNvbnRhaW5lcnxQSVhJLlNwcml0ZXxQSVhJLmV4dHJhcy5UaWxpbmdTcHJpdGV9IGRpc3BsYXlPYmplY3QgLSBUaGUgZGlzcGxheSBvYmplY3QgdGhhdCB3YXMgdGVzdGVkXG4gICAgICogQHBhcmFtIHtib29sZWFufSBoaXQgLSB0aGUgcmVzdWx0IG9mIHRoZSBoaXQgdGVzdCBvbiB0aGUgZGlzcGxheSBvYmplY3RcbiAgICAgKi9cblxuXG4gICAgSW50ZXJhY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5wcm9jZXNzUG9pbnRlck92ZXJPdXQgPSBmdW5jdGlvbiBwcm9jZXNzUG9pbnRlck92ZXJPdXQoaW50ZXJhY3Rpb25FdmVudCwgZGlzcGxheU9iamVjdCwgaGl0KSB7XG4gICAgICAgIHZhciBkYXRhID0gaW50ZXJhY3Rpb25FdmVudC5kYXRhO1xuXG4gICAgICAgIHZhciBpZCA9IGludGVyYWN0aW9uRXZlbnQuZGF0YS5pZGVudGlmaWVyO1xuXG4gICAgICAgIHZhciBpc01vdXNlID0gZGF0YS5wb2ludGVyVHlwZSA9PT0gJ21vdXNlJyB8fCBkYXRhLnBvaW50ZXJUeXBlID09PSAncGVuJztcblxuICAgICAgICB2YXIgdHJhY2tpbmdEYXRhID0gZGlzcGxheU9iamVjdC50cmFja2VkUG9pbnRlcnNbaWRdO1xuXG4gICAgICAgIC8vIGlmIHdlIGp1c3QgbW91c2VkIG92ZXIgdGhlIGRpc3BsYXkgb2JqZWN0LCB0aGVuIHdlIG5lZWQgdG8gdHJhY2sgdGhhdCBzdGF0ZVxuICAgICAgICBpZiAoaGl0ICYmICF0cmFja2luZ0RhdGEpIHtcbiAgICAgICAgICAgIHRyYWNraW5nRGF0YSA9IGRpc3BsYXlPYmplY3QudHJhY2tlZFBvaW50ZXJzW2lkXSA9IG5ldyBfSW50ZXJhY3Rpb25UcmFja2luZ0RhdGEyLmRlZmF1bHQoaWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRyYWNraW5nRGF0YSA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG5cbiAgICAgICAgaWYgKGhpdCAmJiB0aGlzLm1vdXNlT3ZlclJlbmRlcmVyKSB7XG4gICAgICAgICAgICBpZiAoIXRyYWNraW5nRGF0YS5vdmVyKSB7XG4gICAgICAgICAgICAgICAgdHJhY2tpbmdEYXRhLm92ZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChkaXNwbGF5T2JqZWN0LCAncG9pbnRlcm92ZXInLCBpbnRlcmFjdGlvbkV2ZW50KTtcbiAgICAgICAgICAgICAgICBpZiAoaXNNb3VzZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZGlzcGxheU9iamVjdCwgJ21vdXNlb3ZlcicsIGludGVyYWN0aW9uRXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gb25seSBjaGFuZ2UgdGhlIGN1cnNvciBpZiBpdCBoYXMgbm90IGFscmVhZHkgYmVlbiBjaGFuZ2VkIChieSBzb21ldGhpbmcgZGVlcGVyIGluIHRoZVxuICAgICAgICAgICAgLy8gZGlzcGxheSB0cmVlKVxuICAgICAgICAgICAgaWYgKGlzTW91c2UgJiYgdGhpcy5jdXJzb3IgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnNvciA9IGRpc3BsYXlPYmplY3QuY3Vyc29yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRyYWNraW5nRGF0YS5vdmVyKSB7XG4gICAgICAgICAgICB0cmFja2luZ0RhdGEub3ZlciA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGRpc3BsYXlPYmplY3QsICdwb2ludGVyb3V0JywgdGhpcy5ldmVudERhdGEpO1xuICAgICAgICAgICAgaWYgKGlzTW91c2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZGlzcGxheU9iamVjdCwgJ21vdXNlb3V0JywgaW50ZXJhY3Rpb25FdmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBubyBtb3VzZSBkb3duIGluZm9ybWF0aW9uIGZvciB0aGUgcG9pbnRlciwgdGhlbiBpdCBpcyBzYWZlIHRvIGRlbGV0ZVxuICAgICAgICAgICAgaWYgKHRyYWNraW5nRGF0YS5ub25lKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGRpc3BsYXlPYmplY3QudHJhY2tlZFBvaW50ZXJzW2lkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJcyBjYWxsZWQgd2hlbiB0aGUgcG9pbnRlciBpcyBtb3ZlZCBpbnRvIHRoZSByZW5kZXJlciBlbGVtZW50XG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7UG9pbnRlckV2ZW50fSBvcmlnaW5hbEV2ZW50IC0gVGhlIERPTSBldmVudCBvZiBhIHBvaW50ZXIgYnV0dG9uIGJlaW5nIG1vdmVkIGludG8gdGhlIHJlbmRlcmVyIHZpZXdcbiAgICAgKi9cblxuXG4gICAgSW50ZXJhY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5vblBvaW50ZXJPdmVyID0gZnVuY3Rpb24gb25Qb2ludGVyT3ZlcihvcmlnaW5hbEV2ZW50KSB7XG4gICAgICAgIHZhciBldmVudHMgPSB0aGlzLm5vcm1hbGl6ZVRvUG9pbnRlckRhdGEob3JpZ2luYWxFdmVudCk7XG5cbiAgICAgICAgLy8gT25seSBtb3VzZSBhbmQgcG9pbnRlciBjYW4gY2FsbCBvblBvaW50ZXJPdmVyLCBzbyBldmVudHMgd2lsbCBhbHdheXMgYmUgbGVuZ3RoIDFcbiAgICAgICAgdmFyIGV2ZW50ID0gZXZlbnRzWzBdO1xuXG4gICAgICAgIHZhciBpbnRlcmFjdGlvbkRhdGEgPSB0aGlzLmdldEludGVyYWN0aW9uRGF0YUZvclBvaW50ZXJJZChldmVudCk7XG5cbiAgICAgICAgdmFyIGludGVyYWN0aW9uRXZlbnQgPSB0aGlzLmNvbmZpZ3VyZUludGVyYWN0aW9uRXZlbnRGb3JET01FdmVudCh0aGlzLmV2ZW50RGF0YSwgZXZlbnQsIGludGVyYWN0aW9uRGF0YSk7XG5cbiAgICAgICAgaW50ZXJhY3Rpb25FdmVudC5kYXRhLm9yaWdpbmFsRXZlbnQgPSBldmVudDtcblxuICAgICAgICBpZiAoZXZlbnQucG9pbnRlclR5cGUgPT09ICdtb3VzZScpIHtcbiAgICAgICAgICAgIHRoaXMubW91c2VPdmVyUmVuZGVyZXIgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5lbWl0KCdwb2ludGVyb3ZlcicsIGludGVyYWN0aW9uRXZlbnQpO1xuICAgICAgICBpZiAoZXZlbnQucG9pbnRlclR5cGUgPT09ICdtb3VzZScgfHwgZXZlbnQucG9pbnRlclR5cGUgPT09ICdwZW4nKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ21vdXNlb3ZlcicsIGludGVyYWN0aW9uRXZlbnQpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBJbnRlcmFjdGlvbkRhdGEgZm9yIGEgZ2l2ZW4gcG9pbnRlcklkLiBTdG9yZSB0aGF0IGRhdGEgYXMgd2VsbFxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1BvaW50ZXJFdmVudH0gZXZlbnQgLSBOb3JtYWxpemVkIHBvaW50ZXIgZXZlbnQsIG91dHB1dCBmcm9tIG5vcm1hbGl6ZVRvUG9pbnRlckRhdGFcbiAgICAgKiBAcmV0dXJuIHtQSVhJLmludGVyYWN0aW9uLkludGVyYWN0aW9uRGF0YX0gLSBJbnRlcmFjdGlvbiBkYXRhIGZvciB0aGUgZ2l2ZW4gcG9pbnRlciBpZGVudGlmaWVyXG4gICAgICovXG5cblxuICAgIEludGVyYWN0aW9uTWFuYWdlci5wcm90b3R5cGUuZ2V0SW50ZXJhY3Rpb25EYXRhRm9yUG9pbnRlcklkID0gZnVuY3Rpb24gZ2V0SW50ZXJhY3Rpb25EYXRhRm9yUG9pbnRlcklkKGV2ZW50KSB7XG4gICAgICAgIHZhciBwb2ludGVySWQgPSBldmVudC5wb2ludGVySWQ7XG5cbiAgICAgICAgdmFyIGludGVyYWN0aW9uRGF0YSA9IHZvaWQgMDtcblxuICAgICAgICBpZiAocG9pbnRlcklkID09PSBNT1VTRV9QT0lOVEVSX0lEIHx8IGV2ZW50LnBvaW50ZXJUeXBlID09PSAnbW91c2UnKSB7XG4gICAgICAgICAgICBpbnRlcmFjdGlvbkRhdGEgPSB0aGlzLm1vdXNlO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuYWN0aXZlSW50ZXJhY3Rpb25EYXRhW3BvaW50ZXJJZF0pIHtcbiAgICAgICAgICAgIGludGVyYWN0aW9uRGF0YSA9IHRoaXMuYWN0aXZlSW50ZXJhY3Rpb25EYXRhW3BvaW50ZXJJZF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbnRlcmFjdGlvbkRhdGEgPSB0aGlzLmludGVyYWN0aW9uRGF0YVBvb2wucG9wKCkgfHwgbmV3IF9JbnRlcmFjdGlvbkRhdGEyLmRlZmF1bHQoKTtcbiAgICAgICAgICAgIGludGVyYWN0aW9uRGF0YS5pZGVudGlmaWVyID0gcG9pbnRlcklkO1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVJbnRlcmFjdGlvbkRhdGFbcG9pbnRlcklkXSA9IGludGVyYWN0aW9uRGF0YTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjb3B5IHByb3BlcnRpZXMgZnJvbSB0aGUgZXZlbnQsIHNvIHRoYXQgd2UgY2FuIG1ha2Ugc3VyZSB0aGF0IHRvdWNoL3BvaW50ZXIgc3BlY2lmaWNcbiAgICAgICAgLy8gZGF0YSBpcyBhdmFpbGFibGVcbiAgICAgICAgaW50ZXJhY3Rpb25EYXRhLmNvcHlFdmVudChldmVudCk7XG5cbiAgICAgICAgcmV0dXJuIGludGVyYWN0aW9uRGF0YTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHVudXNlZCBJbnRlcmFjdGlvbkRhdGEgdG8gdGhlIHBvb2wsIGZvciBhIGdpdmVuIHBvaW50ZXJJZFxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcG9pbnRlcklkIC0gSWRlbnRpZmllciBmcm9tIGEgcG9pbnRlciBldmVudFxuICAgICAqL1xuXG5cbiAgICBJbnRlcmFjdGlvbk1hbmFnZXIucHJvdG90eXBlLnJlbGVhc2VJbnRlcmFjdGlvbkRhdGFGb3JQb2ludGVySWQgPSBmdW5jdGlvbiByZWxlYXNlSW50ZXJhY3Rpb25EYXRhRm9yUG9pbnRlcklkKHBvaW50ZXJJZCkge1xuICAgICAgICB2YXIgaW50ZXJhY3Rpb25EYXRhID0gdGhpcy5hY3RpdmVJbnRlcmFjdGlvbkRhdGFbcG9pbnRlcklkXTtcblxuICAgICAgICBpZiAoaW50ZXJhY3Rpb25EYXRhKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5hY3RpdmVJbnRlcmFjdGlvbkRhdGFbcG9pbnRlcklkXTtcbiAgICAgICAgICAgIGludGVyYWN0aW9uRGF0YS5yZXNldCgpO1xuICAgICAgICAgICAgdGhpcy5pbnRlcmFjdGlvbkRhdGFQb29sLnB1c2goaW50ZXJhY3Rpb25EYXRhKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDb25maWd1cmUgYW4gSW50ZXJhY3Rpb25FdmVudCB0byB3cmFwIGEgRE9NIFBvaW50ZXJFdmVudCBhbmQgSW50ZXJhY3Rpb25EYXRhXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7UElYSS5pbnRlcmFjdGlvbi5JbnRlcmFjdGlvbkV2ZW50fSBpbnRlcmFjdGlvbkV2ZW50IC0gVGhlIGV2ZW50IHRvIGJlIGNvbmZpZ3VyZWRcbiAgICAgKiBAcGFyYW0ge1BvaW50ZXJFdmVudH0gcG9pbnRlckV2ZW50IC0gVGhlIERPTSBldmVudCB0aGF0IHdpbGwgYmUgcGFpcmVkIHdpdGggdGhlIEludGVyYWN0aW9uRXZlbnRcbiAgICAgKiBAcGFyYW0ge1BJWEkuaW50ZXJhY3Rpb24uSW50ZXJhY3Rpb25EYXRhfSBpbnRlcmFjdGlvbkRhdGEgLSBUaGUgSW50ZXJhY3Rpb25EYXRhIHRoYXQgd2lsbCBiZSBwYWlyZWRcbiAgICAgKiAgICAgICAgd2l0aCB0aGUgSW50ZXJhY3Rpb25FdmVudFxuICAgICAqIEByZXR1cm4ge1BJWEkuaW50ZXJhY3Rpb24uSW50ZXJhY3Rpb25FdmVudH0gdGhlIGludGVyYWN0aW9uIGV2ZW50IHRoYXQgd2FzIHBhc3NlZCBpblxuICAgICAqL1xuXG5cbiAgICBJbnRlcmFjdGlvbk1hbmFnZXIucHJvdG90eXBlLmNvbmZpZ3VyZUludGVyYWN0aW9uRXZlbnRGb3JET01FdmVudCA9IGZ1bmN0aW9uIGNvbmZpZ3VyZUludGVyYWN0aW9uRXZlbnRGb3JET01FdmVudChpbnRlcmFjdGlvbkV2ZW50LCBwb2ludGVyRXZlbnQsIGludGVyYWN0aW9uRGF0YSkge1xuICAgICAgICBpbnRlcmFjdGlvbkV2ZW50LmRhdGEgPSBpbnRlcmFjdGlvbkRhdGE7XG5cbiAgICAgICAgdGhpcy5tYXBQb3NpdGlvblRvUG9pbnQoaW50ZXJhY3Rpb25EYXRhLmdsb2JhbCwgcG9pbnRlckV2ZW50LmNsaWVudFgsIHBvaW50ZXJFdmVudC5jbGllbnRZKTtcblxuICAgICAgICAvLyBUaGlzIGlzIHRoZSB3YXkgSW50ZXJhY3Rpb25NYW5hZ2VyIHByb2Nlc3NlZCB0b3VjaCBldmVudHMgYmVmb3JlIHRoZSByZWZhY3RvcmluZywgc28gSSd2ZSBrZXB0XG4gICAgICAgIC8vIGl0IGhlcmUuIEJ1dCBpdCBkb2Vzbid0IG1ha2UgdGhhdCBtdWNoIHNlbnNlIHRvIG1lLCBzaW5jZSBtYXBQb3NpdGlvblRvUG9pbnQgYWxyZWFkeSBmYWN0b3JzXG4gICAgICAgIC8vIGluIHRoaXMucmVzb2x1dGlvbiwgc28gdGhpcyBqdXN0IGRpdmlkZXMgYnkgdGhpcy5yZXNvbHV0aW9uIHR3aWNlIGZvciB0b3VjaCBldmVudHMuLi5cbiAgICAgICAgaWYgKG5hdmlnYXRvci5pc0NvY29vbkpTICYmIHBvaW50ZXJFdmVudC5wb2ludGVyVHlwZSA9PT0gJ3RvdWNoJykge1xuICAgICAgICAgICAgaW50ZXJhY3Rpb25EYXRhLmdsb2JhbC54ID0gaW50ZXJhY3Rpb25EYXRhLmdsb2JhbC54IC8gdGhpcy5yZXNvbHV0aW9uO1xuICAgICAgICAgICAgaW50ZXJhY3Rpb25EYXRhLmdsb2JhbC55ID0gaW50ZXJhY3Rpb25EYXRhLmdsb2JhbC55IC8gdGhpcy5yZXNvbHV0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTm90IHJlYWxseSBzdXJlIHdoeSB0aGlzIGlzIGhhcHBlbmluZywgYnV0IGl0J3MgaG93IGEgcHJldmlvdXMgdmVyc2lvbiBoYW5kbGVkIHRoaW5nc1xuICAgICAgICBpZiAocG9pbnRlckV2ZW50LnBvaW50ZXJUeXBlID09PSAndG91Y2gnKSB7XG4gICAgICAgICAgICBwb2ludGVyRXZlbnQuZ2xvYmFsWCA9IGludGVyYWN0aW9uRGF0YS5nbG9iYWwueDtcbiAgICAgICAgICAgIHBvaW50ZXJFdmVudC5nbG9iYWxZID0gaW50ZXJhY3Rpb25EYXRhLmdsb2JhbC55O1xuICAgICAgICB9XG5cbiAgICAgICAgaW50ZXJhY3Rpb25EYXRhLm9yaWdpbmFsRXZlbnQgPSBwb2ludGVyRXZlbnQ7XG4gICAgICAgIGludGVyYWN0aW9uRXZlbnQucmVzZXQoKTtcblxuICAgICAgICByZXR1cm4gaW50ZXJhY3Rpb25FdmVudDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRW5zdXJlcyB0aGF0IHRoZSBvcmlnaW5hbCBldmVudCBvYmplY3QgY29udGFpbnMgYWxsIGRhdGEgdGhhdCBhIHJlZ3VsYXIgcG9pbnRlciBldmVudCB3b3VsZCBoYXZlXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7VG91Y2hFdmVudHxNb3VzZUV2ZW50fFBvaW50ZXJFdmVudH0gZXZlbnQgLSBUaGUgb3JpZ2luYWwgZXZlbnQgZGF0YSBmcm9tIGEgdG91Y2ggb3IgbW91c2UgZXZlbnRcbiAgICAgKiBAcmV0dXJuIHtQb2ludGVyRXZlbnRbXX0gQW4gYXJyYXkgY29udGFpbmluZyBhIHNpbmdsZSBub3JtYWxpemVkIHBvaW50ZXIgZXZlbnQsIGluIHRoZSBjYXNlIG9mIGEgcG9pbnRlclxuICAgICAqICBvciBtb3VzZSBldmVudCwgb3IgYSBtdWx0aXBsZSBub3JtYWxpemVkIHBvaW50ZXIgZXZlbnRzIGlmIHRoZXJlIGFyZSBtdWx0aXBsZSBjaGFuZ2VkIHRvdWNoZXNcbiAgICAgKi9cblxuXG4gICAgSW50ZXJhY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5ub3JtYWxpemVUb1BvaW50ZXJEYXRhID0gZnVuY3Rpb24gbm9ybWFsaXplVG9Qb2ludGVyRGF0YShldmVudCkge1xuICAgICAgICB2YXIgbm9ybWFsaXplZEV2ZW50cyA9IFtdO1xuXG4gICAgICAgIGlmICh0aGlzLnN1cHBvcnRzVG91Y2hFdmVudHMgJiYgZXZlbnQgaW5zdGFuY2VvZiBUb3VjaEV2ZW50KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGkgPSBldmVudC5jaGFuZ2VkVG91Y2hlcy5sZW5ndGg7IGkgPCBsaTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRvdWNoID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbaV07XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRvdWNoLmJ1dHRvbiA9PT0gJ3VuZGVmaW5lZCcpIHRvdWNoLmJ1dHRvbiA9IGV2ZW50LnRvdWNoZXMubGVuZ3RoID8gMSA6IDA7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0b3VjaC5idXR0b25zID09PSAndW5kZWZpbmVkJykgdG91Y2guYnV0dG9ucyA9IGV2ZW50LnRvdWNoZXMubGVuZ3RoID8gMSA6IDA7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0b3VjaC5pc1ByaW1hcnkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvdWNoLmlzUHJpbWFyeSA9IGV2ZW50LnRvdWNoZXMubGVuZ3RoID09PSAxICYmIGV2ZW50LnR5cGUgPT09ICd0b3VjaHN0YXJ0JztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0b3VjaC53aWR0aCA9PT0gJ3VuZGVmaW5lZCcpIHRvdWNoLndpZHRoID0gdG91Y2gucmFkaXVzWCB8fCAxO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdG91Y2guaGVpZ2h0ID09PSAndW5kZWZpbmVkJykgdG91Y2guaGVpZ2h0ID0gdG91Y2gucmFkaXVzWSB8fCAxO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdG91Y2gudGlsdFggPT09ICd1bmRlZmluZWQnKSB0b3VjaC50aWx0WCA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0b3VjaC50aWx0WSA9PT0gJ3VuZGVmaW5lZCcpIHRvdWNoLnRpbHRZID0gMDtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRvdWNoLnBvaW50ZXJUeXBlID09PSAndW5kZWZpbmVkJykgdG91Y2gucG9pbnRlclR5cGUgPSAndG91Y2gnO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdG91Y2gucG9pbnRlcklkID09PSAndW5kZWZpbmVkJykgdG91Y2gucG9pbnRlcklkID0gdG91Y2guaWRlbnRpZmllciB8fCAwO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdG91Y2gucHJlc3N1cmUgPT09ICd1bmRlZmluZWQnKSB0b3VjaC5wcmVzc3VyZSA9IHRvdWNoLmZvcmNlIHx8IDAuNTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRvdWNoLnR3aXN0ID09PSAndW5kZWZpbmVkJykgdG91Y2gudHdpc3QgPSAwO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdG91Y2gudGFuZ2VudGlhbFByZXNzdXJlID09PSAndW5kZWZpbmVkJykgdG91Y2gudGFuZ2VudGlhbFByZXNzdXJlID0gMDtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBSZW1vdmUgdGhlc2UsIGFzIGxheWVyWC9ZIGlzIG5vdCBhIHN0YW5kYXJkLCBpcyBkZXByZWNhdGVkLCBoYXMgdW5ldmVuXG4gICAgICAgICAgICAgICAgLy8gc3VwcG9ydCwgYW5kIHRoZSBmaWxsIGlucyBhcmUgbm90IHF1aXRlIHRoZSBzYW1lXG4gICAgICAgICAgICAgICAgLy8gb2Zmc2V0WC9ZIG1pZ2h0IGJlIG9rYXksIGJ1dCBpcyBub3QgdGhlIHNhbWUgYXMgY2xpZW50WC9ZIHdoZW4gdGhlIGNhbnZhcydzIHRvcFxuICAgICAgICAgICAgICAgIC8vIGxlZnQgaXMgbm90IDAsMCBvbiB0aGUgcGFnZVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdG91Y2gubGF5ZXJYID09PSAndW5kZWZpbmVkJykgdG91Y2gubGF5ZXJYID0gdG91Y2gub2Zmc2V0WCA9IHRvdWNoLmNsaWVudFg7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0b3VjaC5sYXllclkgPT09ICd1bmRlZmluZWQnKSB0b3VjaC5sYXllclkgPSB0b3VjaC5vZmZzZXRZID0gdG91Y2guY2xpZW50WTtcblxuICAgICAgICAgICAgICAgIC8vIG1hcmsgdGhlIHRvdWNoIGFzIG5vcm1hbGl6ZWQsIGp1c3Qgc28gdGhhdCB3ZSBrbm93IHdlIGRpZCBpdFxuICAgICAgICAgICAgICAgIHRvdWNoLmlzTm9ybWFsaXplZCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICBub3JtYWxpemVkRXZlbnRzLnB1c2godG91Y2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGFwcGFyZW50bHkgUG9pbnRlckV2ZW50IHN1YmNsYXNzZXMgTW91c2VFdmVudCwgc28geWF5XG4gICAgICAgIGVsc2UgaWYgKGV2ZW50IGluc3RhbmNlb2YgTW91c2VFdmVudCAmJiAoIXRoaXMuc3VwcG9ydHNQb2ludGVyRXZlbnRzIHx8ICEoZXZlbnQgaW5zdGFuY2VvZiB3aW5kb3cuUG9pbnRlckV2ZW50KSkpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGV2ZW50LmlzUHJpbWFyeSA9PT0gJ3VuZGVmaW5lZCcpIGV2ZW50LmlzUHJpbWFyeSA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBldmVudC53aWR0aCA9PT0gJ3VuZGVmaW5lZCcpIGV2ZW50LndpZHRoID0gMTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGV2ZW50LmhlaWdodCA9PT0gJ3VuZGVmaW5lZCcpIGV2ZW50LmhlaWdodCA9IDE7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBldmVudC50aWx0WCA9PT0gJ3VuZGVmaW5lZCcpIGV2ZW50LnRpbHRYID0gMDtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGV2ZW50LnRpbHRZID09PSAndW5kZWZpbmVkJykgZXZlbnQudGlsdFkgPSAwO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZXZlbnQucG9pbnRlclR5cGUgPT09ICd1bmRlZmluZWQnKSBldmVudC5wb2ludGVyVHlwZSA9ICdtb3VzZSc7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBldmVudC5wb2ludGVySWQgPT09ICd1bmRlZmluZWQnKSBldmVudC5wb2ludGVySWQgPSBNT1VTRV9QT0lOVEVSX0lEO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZXZlbnQucHJlc3N1cmUgPT09ICd1bmRlZmluZWQnKSBldmVudC5wcmVzc3VyZSA9IDAuNTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGV2ZW50LnR3aXN0ID09PSAndW5kZWZpbmVkJykgZXZlbnQudHdpc3QgPSAwO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZXZlbnQudGFuZ2VudGlhbFByZXNzdXJlID09PSAndW5kZWZpbmVkJykgZXZlbnQudGFuZ2VudGlhbFByZXNzdXJlID0gMDtcblxuICAgICAgICAgICAgICAgIC8vIG1hcmsgdGhlIG1vdXNlIGV2ZW50IGFzIG5vcm1hbGl6ZWQsIGp1c3Qgc28gdGhhdCB3ZSBrbm93IHdlIGRpZCBpdFxuICAgICAgICAgICAgICAgIGV2ZW50LmlzTm9ybWFsaXplZCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICBub3JtYWxpemVkRXZlbnRzLnB1c2goZXZlbnQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBub3JtYWxpemVkRXZlbnRzLnB1c2goZXZlbnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub3JtYWxpemVkRXZlbnRzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyB0aGUgaW50ZXJhY3Rpb24gbWFuYWdlclxuICAgICAqXG4gICAgICovXG5cblxuICAgIEludGVyYWN0aW9uTWFuYWdlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlRXZlbnRzKCk7XG5cbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcblxuICAgICAgICB0aGlzLnJlbmRlcmVyID0gbnVsbDtcblxuICAgICAgICB0aGlzLm1vdXNlID0gbnVsbDtcblxuICAgICAgICB0aGlzLmV2ZW50RGF0YSA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQgPSBudWxsO1xuXG4gICAgICAgIHRoaXMub25Qb2ludGVyRG93biA9IG51bGw7XG4gICAgICAgIHRoaXMucHJvY2Vzc1BvaW50ZXJEb3duID0gbnVsbDtcblxuICAgICAgICB0aGlzLm9uUG9pbnRlclVwID0gbnVsbDtcbiAgICAgICAgdGhpcy5wcm9jZXNzUG9pbnRlclVwID0gbnVsbDtcblxuICAgICAgICB0aGlzLm9uUG9pbnRlckNhbmNlbCA9IG51bGw7XG4gICAgICAgIHRoaXMucHJvY2Vzc1BvaW50ZXJDYW5jZWwgPSBudWxsO1xuXG4gICAgICAgIHRoaXMub25Qb2ludGVyTW92ZSA9IG51bGw7XG4gICAgICAgIHRoaXMucHJvY2Vzc1BvaW50ZXJNb3ZlID0gbnVsbDtcblxuICAgICAgICB0aGlzLm9uUG9pbnRlck91dCA9IG51bGw7XG4gICAgICAgIHRoaXMucHJvY2Vzc1BvaW50ZXJPdmVyT3V0ID0gbnVsbDtcblxuICAgICAgICB0aGlzLm9uUG9pbnRlck92ZXIgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuX3RlbXBQb2ludCA9IG51bGw7XG4gICAgfTtcblxuICAgIHJldHVybiBJbnRlcmFjdGlvbk1hbmFnZXI7XG59KF9ldmVudGVtaXR0ZXIyLmRlZmF1bHQpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBJbnRlcmFjdGlvbk1hbmFnZXI7XG5cblxuY29yZS5XZWJHTFJlbmRlcmVyLnJlZ2lzdGVyUGx1Z2luKCdpbnRlcmFjdGlvbicsIEludGVyYWN0aW9uTWFuYWdlcik7XG5jb3JlLkNhbnZhc1JlbmRlcmVyLnJlZ2lzdGVyUGx1Z2luKCdpbnRlcmFjdGlvbicsIEludGVyYWN0aW9uTWFuYWdlcik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1JbnRlcmFjdGlvbk1hbmFnZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8qKlxuICogRGlzcGxheU9iamVjdHMgd2l0aCB0aGUge0BsaW5rIFBJWEkuaW50ZXJhY3Rpb24uaW50ZXJhY3RpdmVUYXJnZXR9IG1peGluIHVzZSB0aGlzIGNsYXNzIHRvIHRyYWNrIGludGVyYWN0aW9uc1xuICpcbiAqIEBjbGFzc1xuICogQHByaXZhdGVcbiAqIEBtZW1iZXJvZiBQSVhJLmludGVyYWN0aW9uXG4gKi9cbnZhciBJbnRlcmFjdGlvblRyYWNraW5nRGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcG9pbnRlcklkIC0gVW5pcXVlIHBvaW50ZXIgaWQgb2YgdGhlIGV2ZW50XG4gICAgICovXG4gICAgZnVuY3Rpb24gSW50ZXJhY3Rpb25UcmFja2luZ0RhdGEocG9pbnRlcklkKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbnRlcmFjdGlvblRyYWNraW5nRGF0YSk7XG5cbiAgICAgICAgdGhpcy5fcG9pbnRlcklkID0gcG9pbnRlcklkO1xuICAgICAgICB0aGlzLl9mbGFncyA9IEludGVyYWN0aW9uVHJhY2tpbmdEYXRhLkZMQUdTLk5PTkU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBmbGFnIC0gVGhlIGludGVyYWN0aW9uIGZsYWcgdG8gc2V0XG4gICAgICogQHBhcmFtIHtib29sZWFufSB5biAtIFNob3VsZCB0aGUgZmxhZyBiZSBzZXQgb3IgdW5zZXRcbiAgICAgKi9cblxuXG4gICAgSW50ZXJhY3Rpb25UcmFja2luZ0RhdGEucHJvdG90eXBlLl9kb1NldCA9IGZ1bmN0aW9uIF9kb1NldChmbGFnLCB5bikge1xuICAgICAgICBpZiAoeW4pIHtcbiAgICAgICAgICAgIHRoaXMuX2ZsYWdzID0gdGhpcy5fZmxhZ3MgfCBmbGFnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZmxhZ3MgPSB0aGlzLl9mbGFncyAmIH5mbGFnO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFVuaXF1ZSBwb2ludGVyIGlkIG9mIHRoZSBldmVudFxuICAgICAqXG4gICAgICogQHJlYWRvbmx5XG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqL1xuXG5cbiAgICBfY3JlYXRlQ2xhc3MoSW50ZXJhY3Rpb25UcmFja2luZ0RhdGEsIFt7XG4gICAgICAgIGtleTogXCJwb2ludGVySWRcIixcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcG9pbnRlcklkO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0YXRlIG9mIHRoZSB0cmFja2luZyBkYXRhLCBleHByZXNzZWQgYXMgYml0IGZsYWdzXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQG1lbWJlcm9mIFBJWEkuaW50ZXJhY3Rpb24uSW50ZXJhY3Rpb25UcmFja2luZ0RhdGEjXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiZmxhZ3NcIixcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZmxhZ3M7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoZSBmbGFncyBmb3IgdGhlIHRyYWNraW5nIGRhdGFcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGZsYWdzIC0gRmxhZ3MgdG8gc2V0XG4gICAgICAgICAqL1xuICAgICAgICAsXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KGZsYWdzKSB7XG4gICAgICAgICAgICB0aGlzLl9mbGFncyA9IGZsYWdzO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElzIHRoZSB0cmFja2VkIGV2ZW50IGluYWN0aXZlIChub3Qgb3ZlciBvciBkb3duKT9cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAbWVtYmVyb2YgUElYSS5pbnRlcmFjdGlvbi5JbnRlcmFjdGlvblRyYWNraW5nRGF0YSNcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJub25lXCIsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZsYWdzID09PSB0aGlzLmNvbnN0cnVjdG9yLkZMQUdTLk5PTkU7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogSXMgdGhlIHRyYWNrZWQgZXZlbnQgb3ZlciB0aGUgRGlzcGxheU9iamVjdD9cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgICAgICogQG1lbWJlcm9mIFBJWEkuaW50ZXJhY3Rpb24uSW50ZXJhY3Rpb25UcmFja2luZ0RhdGEjXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6IFwib3ZlclwiLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5fZmxhZ3MgJiB0aGlzLmNvbnN0cnVjdG9yLkZMQUdTLk9WRVIpICE9PSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGUgb3ZlciBmbGFnXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0geW4gLSBJcyB0aGUgZXZlbnQgb3Zlcj9cbiAgICAgICAgICovXG4gICAgICAgICxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoeW4pIHtcbiAgICAgICAgICAgIHRoaXMuX2RvU2V0KHRoaXMuY29uc3RydWN0b3IuRkxBR1MuT1ZFUiwgeW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpZCB0aGUgcmlnaHQgbW91c2UgYnV0dG9uIGNvbWUgZG93biBpbiB0aGUgRGlzcGxheU9iamVjdD9cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgICAgICogQG1lbWJlcm9mIFBJWEkuaW50ZXJhY3Rpb24uSW50ZXJhY3Rpb25UcmFja2luZ0RhdGEjXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6IFwicmlnaHREb3duXCIsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLl9mbGFncyAmIHRoaXMuY29uc3RydWN0b3IuRkxBR1MuUklHSFRfRE9XTikgIT09IDA7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoZSByaWdodCBkb3duIGZsYWdcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSB5biAtIElzIHRoZSByaWdodCBtb3VzZSBidXR0b24gZG93bj9cbiAgICAgICAgICovXG4gICAgICAgICxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoeW4pIHtcbiAgICAgICAgICAgIHRoaXMuX2RvU2V0KHRoaXMuY29uc3RydWN0b3IuRkxBR1MuUklHSFRfRE9XTiwgeW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpZCB0aGUgbGVmdCBtb3VzZSBidXR0b24gY29tZSBkb3duIGluIHRoZSBEaXNwbGF5T2JqZWN0P1xuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAgICAgKiBAbWVtYmVyb2YgUElYSS5pbnRlcmFjdGlvbi5JbnRlcmFjdGlvblRyYWNraW5nRGF0YSNcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJsZWZ0RG93blwiLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5fZmxhZ3MgJiB0aGlzLmNvbnN0cnVjdG9yLkZMQUdTLkxFRlRfRE9XTikgIT09IDA7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoZSBsZWZ0IGRvd24gZmxhZ1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHluIC0gSXMgdGhlIGxlZnQgbW91c2UgYnV0dG9uIGRvd24/XG4gICAgICAgICAqL1xuICAgICAgICAsXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHluKSB7XG4gICAgICAgICAgICB0aGlzLl9kb1NldCh0aGlzLmNvbnN0cnVjdG9yLkZMQUdTLkxFRlRfRE9XTiwgeW4pO1xuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEludGVyYWN0aW9uVHJhY2tpbmdEYXRhO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBJbnRlcmFjdGlvblRyYWNraW5nRGF0YTtcblxuXG5JbnRlcmFjdGlvblRyYWNraW5nRGF0YS5GTEFHUyA9IE9iamVjdC5mcmVlemUoe1xuICAgIE5PTkU6IDAsXG4gICAgT1ZFUjogMSA8PCAwLFxuICAgIExFRlRfRE9XTjogMSA8PCAxLFxuICAgIFJJR0hUX0RPV046IDEgPDwgMlxufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1JbnRlcmFjdGlvblRyYWNraW5nRGF0YS5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfSW50ZXJhY3Rpb25EYXRhID0gcmVxdWlyZSgnLi9JbnRlcmFjdGlvbkRhdGEnKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdJbnRlcmFjdGlvbkRhdGEnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9JbnRlcmFjdGlvbkRhdGEpLmRlZmF1bHQ7XG4gIH1cbn0pO1xuXG52YXIgX0ludGVyYWN0aW9uTWFuYWdlciA9IHJlcXVpcmUoJy4vSW50ZXJhY3Rpb25NYW5hZ2VyJyk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnSW50ZXJhY3Rpb25NYW5hZ2VyJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfSW50ZXJhY3Rpb25NYW5hZ2VyKS5kZWZhdWx0O1xuICB9XG59KTtcblxudmFyIF9pbnRlcmFjdGl2ZVRhcmdldCA9IHJlcXVpcmUoJy4vaW50ZXJhY3RpdmVUYXJnZXQnKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdpbnRlcmFjdGl2ZVRhcmdldCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ludGVyYWN0aXZlVGFyZ2V0KS5kZWZhdWx0O1xuICB9XG59KTtcblxudmFyIF9JbnRlcmFjdGlvblRyYWNraW5nRGF0YSA9IHJlcXVpcmUoJy4vSW50ZXJhY3Rpb25UcmFja2luZ0RhdGEnKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdJbnRlcmFjdGlvblRyYWNraW5nRGF0YScsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0ludGVyYWN0aW9uVHJhY2tpbmdEYXRhKS5kZWZhdWx0O1xuICB9XG59KTtcblxudmFyIF9JbnRlcmFjdGlvbkV2ZW50ID0gcmVxdWlyZSgnLi9JbnRlcmFjdGlvbkV2ZW50Jyk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnSW50ZXJhY3Rpb25FdmVudCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0ludGVyYWN0aW9uRXZlbnQpLmRlZmF1bHQ7XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuLyoqXG4gKiBEZWZhdWx0IHByb3BlcnR5IHZhbHVlcyBvZiBpbnRlcmFjdGl2ZSBvYmplY3RzXG4gKiBVc2VkIGJ5IHtAbGluayBQSVhJLmludGVyYWN0aW9uLkludGVyYWN0aW9uTWFuYWdlcn0gdG8gYXV0b21hdGljYWxseSBnaXZlIGFsbCBEaXNwbGF5T2JqZWN0cyB0aGVzZSBwcm9wZXJ0aWVzXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGludGVyYWN0aXZlVGFyZ2V0XG4gKiBAbWVtYmVyb2YgUElYSS5pbnRlcmFjdGlvblxuICogQGV4YW1wbGVcbiAqICAgICAgZnVuY3Rpb24gTXlPYmplY3QoKSB7fVxuICpcbiAqICAgICAgT2JqZWN0LmFzc2lnbihcbiAqICAgICAgICAgIGNvcmUuRGlzcGxheU9iamVjdC5wcm90b3R5cGUsXG4gKiAgICAgICAgICBQSVhJLmludGVyYWN0aW9uLmludGVyYWN0aXZlVGFyZ2V0XG4gKiAgICAgICk7XG4gKi9cbmV4cG9ydHMuZGVmYXVsdCA9IHtcblxuICAvKipcbiAgICogRW5hYmxlIGludGVyYWN0aW9uIGV2ZW50cyBmb3IgdGhlIERpc3BsYXlPYmplY3QuIFRvdWNoLCBwb2ludGVyIGFuZCBtb3VzZVxuICAgKiBldmVudHMgd2lsbCBub3QgYmUgZW1pdHRlZCB1bmxlc3MgYGludGVyYWN0aXZlYCBpcyBzZXQgdG8gYHRydWVgLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCBzcHJpdGUgPSBuZXcgUElYSS5TcHJpdGUodGV4dHVyZSk7XG4gICAqIHNwcml0ZS5pbnRlcmFjdGl2ZSA9IHRydWU7XG4gICAqIHNwcml0ZS5vbigndGFwJywgKGV2ZW50KSA9PiB7XG4gICAqICAgIC8vaGFuZGxlIGV2ZW50XG4gICAqIH0pO1xuICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgKiBAbWVtYmVyb2YgUElYSS5EaXNwbGF5T2JqZWN0I1xuICAgKi9cbiAgaW50ZXJhY3RpdmU6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIGlmIHRoZSBjaGlsZHJlbiB0byB0aGUgZGlzcGxheU9iamVjdCBjYW4gYmUgY2xpY2tlZC90b3VjaGVkXG4gICAqIFNldHRpbmcgdGhpcyB0byBmYWxzZSBhbGxvd3MgUGl4aUpTIHRvIGJ5cGFzcyBhIHJlY3Vyc2l2ZSBgaGl0VGVzdGAgZnVuY3Rpb25cbiAgICpcbiAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICogQG1lbWJlcm9mIFBJWEkuQ29udGFpbmVyI1xuICAgKi9cbiAgaW50ZXJhY3RpdmVDaGlsZHJlbjogdHJ1ZSxcblxuICAvKipcbiAgICogSW50ZXJhY3Rpb24gc2hhcGUuIENoaWxkcmVuIHdpbGwgYmUgaGl0IGZpcnN0LCB0aGVuIHRoaXMgc2hhcGUgd2lsbCBiZSBjaGVja2VkLlxuICAgKiBTZXR0aW5nIHRoaXMgd2lsbCBjYXVzZSB0aGlzIHNoYXBlIHRvIGJlIGNoZWNrZWQgaW4gaGl0IHRlc3RzIHJhdGhlciB0aGFuIHRoZSBkaXNwbGF5T2JqZWN0J3MgYm91bmRzLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCBzcHJpdGUgPSBuZXcgUElYSS5TcHJpdGUodGV4dHVyZSk7XG4gICAqIHNwcml0ZS5pbnRlcmFjdGl2ZSA9IHRydWU7XG4gICAqIHNwcml0ZS5oaXRBcmVhID0gbmV3IFBJWEkuUmVjdGFuZ2xlKDAsIDAsIDEwMCwgMTAwKTtcbiAgICogQG1lbWJlciB7UElYSS5SZWN0YW5nbGV8UElYSS5DaXJjbGV8UElYSS5FbGxpcHNlfFBJWEkuUG9seWdvbnxQSVhJLlJvdW5kZWRSZWN0YW5nbGV9XG4gICAqIEBtZW1iZXJvZiBQSVhJLkRpc3BsYXlPYmplY3QjXG4gICAqL1xuICBoaXRBcmVhOiBudWxsLFxuXG4gIC8qKlxuICAgKiBJZiBlbmFibGVkLCB0aGUgbW91c2UgY3Vyc29yIHVzZSB0aGUgcG9pbnRlciBiZWhhdmlvciB3aGVuIGhvdmVyZWQgb3ZlciB0aGUgZGlzcGxheU9iamVjdCBpZiBpdCBpcyBpbnRlcmFjdGl2ZVxuICAgKiBTZXR0aW5nIHRoaXMgY2hhbmdlcyB0aGUgJ2N1cnNvcicgcHJvcGVydHkgdG8gYCdwb2ludGVyJ2AuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IHNwcml0ZSA9IG5ldyBQSVhJLlNwcml0ZSh0ZXh0dXJlKTtcbiAgICogc3ByaXRlLmludGVyYWN0aXZlID0gdHJ1ZTtcbiAgICogc3ByaXRlLmJ1dHRvbk1vZGUgPSB0cnVlO1xuICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgKiBAbWVtYmVyb2YgUElYSS5EaXNwbGF5T2JqZWN0I1xuICAgKi9cbiAgZ2V0IGJ1dHRvbk1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3Vyc29yID09PSAncG9pbnRlcic7XG4gIH0sXG4gIHNldCBidXR0b25Nb2RlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICB0aGlzLmN1cnNvciA9ICdwb2ludGVyJztcbiAgICB9IGVsc2UgaWYgKHRoaXMuY3Vyc29yID09PSAncG9pbnRlcicpIHtcbiAgICAgIHRoaXMuY3Vyc29yID0gbnVsbDtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRoaXMgZGVmaW5lcyB3aGF0IGN1cnNvciBtb2RlIGlzIHVzZWQgd2hlbiB0aGUgbW91c2UgY3Vyc29yXG4gICAqIGlzIGhvdmVyZWQgb3ZlciB0aGUgZGlzcGxheU9iamVjdC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY29uc3Qgc3ByaXRlID0gbmV3IFBJWEkuU3ByaXRlKHRleHR1cmUpO1xuICAgKiBzcHJpdGUuaW50ZXJhY3RpdmUgPSB0cnVlO1xuICAgKiBzcHJpdGUuY3Vyc29yID0gJ3dhaXQnO1xuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0NTUy9jdXJzb3JcbiAgICpcbiAgICogQG1lbWJlciB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgUElYSS5EaXNwbGF5T2JqZWN0I1xuICAgKi9cbiAgY3Vyc29yOiBudWxsLFxuXG4gIC8qKlxuICAgKiBJbnRlcm5hbCBzZXQgb2YgYWxsIGFjdGl2ZSBwb2ludGVycywgYnkgaWRlbnRpZmllclxuICAgKlxuICAgKiBAbWVtYmVyIHtNYXA8bnVtYmVyLCBJbnRlcmFjdGlvblRyYWNraW5nRGF0YT59XG4gICAqIEBtZW1iZXJvZiBQSVhJLkRpc3BsYXlPYmplY3QjXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXQgdHJhY2tlZFBvaW50ZXJzKCkge1xuICAgIGlmICh0aGlzLl90cmFja2VkUG9pbnRlcnMgPT09IHVuZGVmaW5lZCkgdGhpcy5fdHJhY2tlZFBvaW50ZXJzID0ge307XG5cbiAgICByZXR1cm4gdGhpcy5fdHJhY2tlZFBvaW50ZXJzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBNYXAgb2YgYWxsIHRyYWNrZWQgcG9pbnRlcnMsIGJ5IGlkZW50aWZpZXIuIFVzZSB0cmFja2VkUG9pbnRlcnMgdG8gYWNjZXNzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7TWFwPG51bWJlciwgSW50ZXJhY3Rpb25UcmFja2luZ0RhdGE+fVxuICAgKi9cbiAgX3RyYWNrZWRQb2ludGVyczogdW5kZWZpbmVkXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW50ZXJhY3RpdmVUYXJnZXQuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGJpdG1hcEZvbnRQYXJzZXIocmVzb3VyY2UsIG5leHQpIHtcbiAgICAgICAgLy8gc2tpcCBpZiBubyBkYXRhIG9yIG5vdCB4bWwgZGF0YVxuICAgICAgICBpZiAoIXJlc291cmNlLmRhdGEgfHwgcmVzb3VyY2UudHlwZSAhPT0gX3Jlc291cmNlTG9hZGVyLlJlc291cmNlLlRZUEUuWE1MKSB7XG4gICAgICAgICAgICBuZXh0KCk7XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNraXAgaWYgbm90IGJpdG1hcCBmb250IGRhdGEsIHVzaW5nIHNvbWUgc2lsbHkgZHVjay10eXBpbmdcbiAgICAgICAgaWYgKHJlc291cmNlLmRhdGEuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3BhZ2UnKS5sZW5ndGggPT09IDAgfHwgcmVzb3VyY2UuZGF0YS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaW5mbycpLmxlbmd0aCA9PT0gMCB8fCByZXNvdXJjZS5kYXRhLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdpbmZvJylbMF0uZ2V0QXR0cmlidXRlKCdmYWNlJykgPT09IG51bGwpIHtcbiAgICAgICAgICAgIG5leHQoKTtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHhtbFVybCA9ICFyZXNvdXJjZS5pc0RhdGFVcmwgPyBwYXRoLmRpcm5hbWUocmVzb3VyY2UudXJsKSA6ICcnO1xuXG4gICAgICAgIGlmIChyZXNvdXJjZS5pc0RhdGFVcmwpIHtcbiAgICAgICAgICAgIGlmICh4bWxVcmwgPT09ICcuJykge1xuICAgICAgICAgICAgICAgIHhtbFVybCA9ICcnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5iYXNlVXJsICYmIHhtbFVybCkge1xuICAgICAgICAgICAgICAgIC8vIGlmIGJhc2V1cmwgaGFzIGEgdHJhaWxpbmcgc2xhc2ggdGhlbiBhZGQgb25lIHRvIHhtbFVybCBzbyB0aGUgcmVwbGFjZSB3b3JrcyBiZWxvd1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmJhc2VVcmwuY2hhckF0KHRoaXMuYmFzZVVybC5sZW5ndGggLSAxKSA9PT0gJy8nKSB7XG4gICAgICAgICAgICAgICAgICAgIHhtbFVybCArPSAnLyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVtb3ZlIGJhc2VVcmwgZnJvbSB4bWxVcmxcbiAgICAgICAgeG1sVXJsID0geG1sVXJsLnJlcGxhY2UodGhpcy5iYXNlVXJsLCAnJyk7XG5cbiAgICAgICAgLy8gaWYgdGhlcmUgaXMgYW4geG1sVXJsIG5vdywgaXQgbmVlZHMgYSB0cmFpbGluZyBzbGFzaC4gRW5zdXJlIHRoYXQgaXQgZG9lcyBpZiB0aGUgc3RyaW5nIGlzbid0IGVtcHR5LlxuICAgICAgICBpZiAoeG1sVXJsICYmIHhtbFVybC5jaGFyQXQoeG1sVXJsLmxlbmd0aCAtIDEpICE9PSAnLycpIHtcbiAgICAgICAgICAgIHhtbFVybCArPSAnLyc7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGFnZXMgPSByZXNvdXJjZS5kYXRhLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdwYWdlJyk7XG4gICAgICAgIHZhciB0ZXh0dXJlcyA9IHt9O1xuXG4gICAgICAgIC8vIEhhbmRsZSBjb21wbGV0ZWQsIHdoZW4gdGhlIG51bWJlciBvZiB0ZXh0dXJlc1xuICAgICAgICAvLyBsb2FkIGlzIHRoZSBzYW1lIG51bWJlciBhcyByZWZlcmVuY2VzIGluIHRoZSBmbnQgZmlsZVxuICAgICAgICB2YXIgY29tcGxldGVkID0gZnVuY3Rpb24gY29tcGxldGVkKHBhZ2UpIHtcbiAgICAgICAgICAgIHRleHR1cmVzW3BhZ2UubWV0YWRhdGEucGFnZUZpbGVdID0gcGFnZS50ZXh0dXJlO1xuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXModGV4dHVyZXMpLmxlbmd0aCA9PT0gcGFnZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcGFyc2UocmVzb3VyY2UsIHRleHR1cmVzKTtcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYWdlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIHBhZ2VGaWxlID0gcGFnZXNbaV0uZ2V0QXR0cmlidXRlKCdmaWxlJyk7XG4gICAgICAgICAgICB2YXIgdXJsID0geG1sVXJsICsgcGFnZUZpbGU7XG4gICAgICAgICAgICB2YXIgZXhpc3RzID0gZmFsc2U7XG5cbiAgICAgICAgICAgIC8vIGluY2FzZSB0aGUgaW1hZ2UgaXMgbG9hZGVkIG91dHNpZGVcbiAgICAgICAgICAgIC8vIHVzaW5nIHRoZSBzYW1lIGxvYWRlciwgcmVzb3VyY2Ugd2lsbCBiZSBhdmFpbGFibGVcbiAgICAgICAgICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcy5yZXNvdXJjZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgYml0bWFwUmVzb3VyY2UgPSB0aGlzLnJlc291cmNlc1tuYW1lXTtcblxuICAgICAgICAgICAgICAgIGlmIChiaXRtYXBSZXNvdXJjZS51cmwgPT09IHVybCkge1xuICAgICAgICAgICAgICAgICAgICBiaXRtYXBSZXNvdXJjZS5tZXRhZGF0YS5wYWdlRmlsZSA9IHBhZ2VGaWxlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYml0bWFwUmVzb3VyY2UudGV4dHVyZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGVkKGJpdG1hcFJlc291cmNlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJpdG1hcFJlc291cmNlLm9uQWZ0ZXJNaWRkbGV3YXJlLmFkZChjb21wbGV0ZWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGV4aXN0cyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gdGV4dHVyZSBpcyBub3QgbG9hZGVkLCB3ZSdsbCBhdHRlbXB0IHRvIGFkZFxuICAgICAgICAgICAgLy8gaXQgdG8gdGhlIGxvYWQgYW5kIGFkZCB0aGUgdGV4dHVyZSB0byB0aGUgbGlzdFxuICAgICAgICAgICAgaWYgKCFleGlzdHMpIHtcbiAgICAgICAgICAgICAgICAvLyBTdGFuZGFyZCBsb2FkaW5nIG9wdGlvbnMgZm9yIGltYWdlc1xuICAgICAgICAgICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgICAgICAgICAgICBjcm9zc09yaWdpbjogcmVzb3VyY2UuY3Jvc3NPcmlnaW4sXG4gICAgICAgICAgICAgICAgICAgIGxvYWRUeXBlOiBfcmVzb3VyY2VMb2FkZXIuUmVzb3VyY2UuTE9BRF9UWVBFLklNQUdFLFxuICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YTogT2JqZWN0LmFzc2lnbih7IHBhZ2VGaWxlOiBwYWdlRmlsZSB9LCByZXNvdXJjZS5tZXRhZGF0YS5pbWFnZU1ldGFkYXRhKSxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50UmVzb3VyY2U6IHJlc291cmNlXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHRoaXMuYWRkKHVybCwgb3B0aW9ucywgY29tcGxldGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59O1xuXG52YXIgX3BhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5cbnZhciBwYXRoID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX3BhdGgpO1xuXG52YXIgX3Jlc291cmNlTG9hZGVyID0gcmVxdWlyZSgncmVzb3VyY2UtbG9hZGVyJyk7XG5cbnZhciBfZXh0cmFzID0gcmVxdWlyZSgnLi4vZXh0cmFzJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbi8qKlxuICogUmVnaXN0ZXIgYSBCaXRtYXBUZXh0IGZvbnQgZnJvbSBsb2FkZXIgcmVzb3VyY2UuXG4gKlxuICogQGZ1bmN0aW9uIHBhcnNlQml0bWFwRm9udERhdGFcbiAqIEBtZW1iZXJvZiBQSVhJLmxvYWRlcnNcbiAqIEBwYXJhbSB7UElYSS5sb2FkZXJzLlJlc291cmNlfSByZXNvdXJjZSAtIExvYWRlciByZXNvdXJjZS5cbiAqIEBwYXJhbSB7UElYSS5UZXh0dXJlfFBJWEkuVGV4dHVyZVtdfSB0ZXh0dXJlcyAtIExpc3Qgb2YgdGV4dHVyZXMgZm9yIGVhY2ggcGFnZS5cbiAqL1xuZnVuY3Rpb24gcGFyc2UocmVzb3VyY2UsIHRleHR1cmVzKSB7XG4gICAgcmVzb3VyY2UuYml0bWFwRm9udCA9IF9leHRyYXMuQml0bWFwVGV4dC5yZWdpc3RlckZvbnQocmVzb3VyY2UuZGF0YSwgdGV4dHVyZXMpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Yml0bWFwRm9udFBhcnNlci5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLnNoYXJlZCA9IGV4cG9ydHMuUmVzb3VyY2UgPSBleHBvcnRzLnRleHR1cmVQYXJzZXIgPSBleHBvcnRzLmdldFJlc291cmNlUGF0aCA9IGV4cG9ydHMuc3ByaXRlc2hlZXRQYXJzZXIgPSBleHBvcnRzLnBhcnNlQml0bWFwRm9udERhdGEgPSBleHBvcnRzLmJpdG1hcEZvbnRQYXJzZXIgPSBleHBvcnRzLkxvYWRlciA9IHVuZGVmaW5lZDtcblxudmFyIF9iaXRtYXBGb250UGFyc2VyID0gcmVxdWlyZSgnLi9iaXRtYXBGb250UGFyc2VyJyk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnYml0bWFwRm9udFBhcnNlcicsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYml0bWFwRm9udFBhcnNlcikuZGVmYXVsdDtcbiAgICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAncGFyc2VCaXRtYXBGb250RGF0YScsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gX2JpdG1hcEZvbnRQYXJzZXIucGFyc2U7XG4gICAgfVxufSk7XG5cbnZhciBfc3ByaXRlc2hlZXRQYXJzZXIgPSByZXF1aXJlKCcuL3Nwcml0ZXNoZWV0UGFyc2VyJyk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnc3ByaXRlc2hlZXRQYXJzZXInLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Nwcml0ZXNoZWV0UGFyc2VyKS5kZWZhdWx0O1xuICAgIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdnZXRSZXNvdXJjZVBhdGgnLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIF9zcHJpdGVzaGVldFBhcnNlci5nZXRSZXNvdXJjZVBhdGg7XG4gICAgfVxufSk7XG5cbnZhciBfdGV4dHVyZVBhcnNlciA9IHJlcXVpcmUoJy4vdGV4dHVyZVBhcnNlcicpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ3RleHR1cmVQYXJzZXInLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RleHR1cmVQYXJzZXIpLmRlZmF1bHQ7XG4gICAgfVxufSk7XG5cbnZhciBfcmVzb3VyY2VMb2FkZXIgPSByZXF1aXJlKCdyZXNvdXJjZS1sb2FkZXInKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdSZXNvdXJjZScsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gX3Jlc291cmNlTG9hZGVyLlJlc291cmNlO1xuICAgIH1cbn0pO1xuXG52YXIgX0FwcGxpY2F0aW9uID0gcmVxdWlyZSgnLi4vY29yZS9BcHBsaWNhdGlvbicpO1xuXG52YXIgX0FwcGxpY2F0aW9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0FwcGxpY2F0aW9uKTtcblxudmFyIF9sb2FkZXIgPSByZXF1aXJlKCcuL2xvYWRlcicpO1xuXG52YXIgX2xvYWRlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9sb2FkZXIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKipcbiAqIFRoaXMgbmFtZXNwYWNlIGNvbnRhaW5zIEFQSXMgd2hpY2ggZXh0ZW5kcyB0aGUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9lbmdsZXJjai9yZXNvdXJjZS1sb2FkZXIgcmVzb3VyY2UtbG9hZGVyfSBtb2R1bGVcbiAqIGZvciBsb2FkaW5nIGFzc2V0cywgZGF0YSwgYW5kIG90aGVyIHJlc291cmNlcyBkeW5hbWljYWxseS5cbiAqIEBleGFtcGxlXG4gKiBjb25zdCBsb2FkZXIgPSBuZXcgUElYSS5sb2FkZXJzLkxvYWRlcigpO1xuICogbG9hZGVyLmFkZCgnYnVubnknLCAnZGF0YS9idW5ueS5wbmcnKVxuICogICAgICAgLmFkZCgnc3BhY2VzaGlwJywgJ2Fzc2V0cy9zcHJpdGVzaGVldC5qc29uJyk7XG4gKiBsb2FkZXIubG9hZCgobG9hZGVyLCByZXNvdXJjZXMpID0+IHtcbiAqICAgIC8vIHJlc291cmNlcy5idW5ueVxuICogICAgLy8gcmVzb3VyY2VzLnNwYWNlc2hpcFxuICogfSk7XG4gKiBAbmFtZXNwYWNlIFBJWEkubG9hZGVyc1xuICovXG5leHBvcnRzLkxvYWRlciA9IF9sb2FkZXIyLmRlZmF1bHQ7XG5cblxuLyoqXG4gKiBBIHByZW1hZGUgaW5zdGFuY2Ugb2YgdGhlIGxvYWRlciB0aGF0IGNhbiBiZSB1c2VkIHRvIGxvYWQgcmVzb3VyY2VzLlxuICogQG5hbWUgc2hhcmVkXG4gKiBAbWVtYmVyb2YgUElYSS5sb2FkZXJzXG4gKiBAdHlwZSB7UElYSS5sb2FkZXJzLkxvYWRlcn1cbiAqL1xudmFyIHNoYXJlZCA9IG5ldyBfbG9hZGVyMi5kZWZhdWx0KCk7XG5cbnNoYXJlZC5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIHByb3RlY3QgZGVzdHJveWluZyBzaGFyZWQgbG9hZGVyXG59O1xuXG5leHBvcnRzLnNoYXJlZCA9IHNoYXJlZDtcblxuLy8gTWl4aW4gdGhlIGxvYWRlciBjb25zdHJ1Y3Rpb25cblxudmFyIEFwcFByb3RvdHlwZSA9IF9BcHBsaWNhdGlvbjIuZGVmYXVsdC5wcm90b3R5cGU7XG5cbkFwcFByb3RvdHlwZS5fbG9hZGVyID0gbnVsbDtcblxuLyoqXG4gKiBMb2FkZXIgaW5zdGFuY2UgdG8gaGVscCB3aXRoIGFzc2V0IGxvYWRpbmcuXG4gKiBAbmFtZSBQSVhJLkFwcGxpY2F0aW9uI2xvYWRlclxuICogQHR5cGUge1BJWEkubG9hZGVycy5Mb2FkZXJ9XG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShBcHBQcm90b3R5cGUsICdsb2FkZXInLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIGlmICghdGhpcy5fbG9hZGVyKSB7XG4gICAgICAgICAgICB2YXIgc2hhcmVkTG9hZGVyID0gdGhpcy5fb3B0aW9ucy5zaGFyZWRMb2FkZXI7XG5cbiAgICAgICAgICAgIHRoaXMuX2xvYWRlciA9IHNoYXJlZExvYWRlciA/IHNoYXJlZCA6IG5ldyBfbG9hZGVyMi5kZWZhdWx0KCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fbG9hZGVyO1xuICAgIH1cbn0pO1xuXG4vLyBPdmVycmlkZSB0aGUgZGVzdHJveSBmdW5jdGlvblxuLy8gbWFraW5nIHN1cmUgdG8gZGVzdHJveSB0aGUgY3VycmVudCBMb2FkZXJcbkFwcFByb3RvdHlwZS5fcGFyZW50RGVzdHJveSA9IEFwcFByb3RvdHlwZS5kZXN0cm95O1xuQXBwUHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KHJlbW92ZVZpZXcsIHN0YWdlT3B0aW9ucykge1xuICAgIGlmICh0aGlzLl9sb2FkZXIpIHtcbiAgICAgICAgdGhpcy5fbG9hZGVyLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5fbG9hZGVyID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5fcGFyZW50RGVzdHJveShyZW1vdmVWaWV3LCBzdGFnZU9wdGlvbnMpO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9yZXNvdXJjZUxvYWRlciA9IHJlcXVpcmUoJ3Jlc291cmNlLWxvYWRlcicpO1xuXG52YXIgX3Jlc291cmNlTG9hZGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Jlc291cmNlTG9hZGVyKTtcblxudmFyIF9ibG9iID0gcmVxdWlyZSgncmVzb3VyY2UtbG9hZGVyL2xpYi9taWRkbGV3YXJlcy9wYXJzaW5nL2Jsb2InKTtcblxudmFyIF9ldmVudGVtaXR0ZXIgPSByZXF1aXJlKCdldmVudGVtaXR0ZXIzJyk7XG5cbnZhciBfZXZlbnRlbWl0dGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2V2ZW50ZW1pdHRlcik7XG5cbnZhciBfdGV4dHVyZVBhcnNlciA9IHJlcXVpcmUoJy4vdGV4dHVyZVBhcnNlcicpO1xuXG52YXIgX3RleHR1cmVQYXJzZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdGV4dHVyZVBhcnNlcik7XG5cbnZhciBfc3ByaXRlc2hlZXRQYXJzZXIgPSByZXF1aXJlKCcuL3Nwcml0ZXNoZWV0UGFyc2VyJyk7XG5cbnZhciBfc3ByaXRlc2hlZXRQYXJzZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3ByaXRlc2hlZXRQYXJzZXIpO1xuXG52YXIgX2JpdG1hcEZvbnRQYXJzZXIgPSByZXF1aXJlKCcuL2JpdG1hcEZvbnRQYXJzZXInKTtcblxudmFyIF9iaXRtYXBGb250UGFyc2VyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2JpdG1hcEZvbnRQYXJzZXIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbi8qKlxuICpcbiAqIFRoZSBuZXcgbG9hZGVyLCBleHRlbmRzIFJlc291cmNlIExvYWRlciBieSBDaGFkIEVuZ2xlcjogaHR0cHM6Ly9naXRodWIuY29tL2VuZ2xlcmNqL3Jlc291cmNlLWxvYWRlclxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCBsb2FkZXIgPSBQSVhJLmxvYWRlcjsgLy8gUGl4aUpTIGV4cG9zZXMgYSBwcmVtYWRlIGluc3RhbmNlIGZvciB5b3UgdG8gdXNlLlxuICogLy9vclxuICogY29uc3QgbG9hZGVyID0gbmV3IFBJWEkubG9hZGVycy5Mb2FkZXIoKTsgLy8geW91IGNhbiBhbHNvIGNyZWF0ZSB5b3VyIG93biBpZiB5b3Ugd2FudFxuICpcbiAqIGNvbnN0IHNwcml0ZXMgPSB7fTtcbiAqXG4gKiAvLyBDaGFpbmFibGUgYGFkZGAgdG8gZW5xdWV1ZSBhIHJlc291cmNlXG4gKiBsb2FkZXIuYWRkKCdidW5ueScsICdkYXRhL2J1bm55LnBuZycpXG4gKiAgICAgICAuYWRkKCdzcGFjZXNoaXAnLCAnYXNzZXRzL3Nwcml0ZXNoZWV0Lmpzb24nKTtcbiAqIGxvYWRlci5hZGQoJ3Njb3JlRm9udCcsICdhc3NldHMvc2NvcmUuZm50Jyk7XG4gKlxuICogLy8gQ2hhaW5hYmxlIGBwcmVgIHRvIGFkZCBhIG1pZGRsZXdhcmUgdGhhdCBydW5zIGZvciBlYWNoIHJlc291cmNlLCAqYmVmb3JlKiBsb2FkaW5nIHRoYXQgcmVzb3VyY2UuXG4gKiAvLyBUaGlzIGlzIHVzZWZ1bCB0byBpbXBsZW1lbnQgY3VzdG9tIGNhY2hpbmcgbW9kdWxlcyAodXNpbmcgZmlsZXN5c3RlbSwgaW5kZXhlZGRiLCBtZW1vcnksIGV0YykuXG4gKiBsb2FkZXIucHJlKGNhY2hpbmdNaWRkbGV3YXJlKTtcbiAqXG4gKiAvLyBDaGFpbmFibGUgYHVzZWAgdG8gYWRkIGEgbWlkZGxld2FyZSB0aGF0IHJ1bnMgZm9yIGVhY2ggcmVzb3VyY2UsICphZnRlciogbG9hZGluZyB0aGF0IHJlc291cmNlLlxuICogLy8gVGhpcyBpcyB1c2VmdWwgdG8gaW1wbGVtZW50IGN1c3RvbSBwYXJzaW5nIG1vZHVsZXMgKGxpa2Ugc3ByaXRlc2hlZXQgcGFyc2Vycywgc3BpbmUgcGFyc2VyLCBldGMpLlxuICogbG9hZGVyLnVzZShwYXJzaW5nTWlkZGxld2FyZSk7XG4gKlxuICogLy8gVGhlIGBsb2FkYCBtZXRob2QgbG9hZHMgdGhlIHF1ZXVlIG9mIHJlc291cmNlcywgYW5kIGNhbGxzIHRoZSBwYXNzZWQgaW4gY2FsbGJhY2sgY2FsbGVkIG9uY2UgYWxsXG4gKiAvLyByZXNvdXJjZXMgaGF2ZSBsb2FkZWQuXG4gKiBsb2FkZXIubG9hZCgobG9hZGVyLCByZXNvdXJjZXMpID0+IHtcbiAqICAgICAvLyByZXNvdXJjZXMgaXMgYW4gb2JqZWN0IHdoZXJlIHRoZSBrZXkgaXMgdGhlIG5hbWUgb2YgdGhlIHJlc291cmNlIGxvYWRlZCBhbmQgdGhlIHZhbHVlIGlzIHRoZSByZXNvdXJjZSBvYmplY3QuXG4gKiAgICAgLy8gVGhleSBoYXZlIGEgY291cGxlIGRlZmF1bHQgcHJvcGVydGllczpcbiAqICAgICAvLyAtIGB1cmxgOiBUaGUgVVJMIHRoYXQgdGhlIHJlc291cmNlIHdhcyBsb2FkZWQgZnJvbVxuICogICAgIC8vIC0gYGVycm9yYDogVGhlIGVycm9yIHRoYXQgaGFwcGVuZWQgd2hlbiB0cnlpbmcgdG8gbG9hZCAoaWYgYW55KVxuICogICAgIC8vIC0gYGRhdGFgOiBUaGUgcmF3IGRhdGEgdGhhdCB3YXMgbG9hZGVkXG4gKiAgICAgLy8gYWxzbyBtYXkgY29udGFpbiBvdGhlciBwcm9wZXJ0aWVzIGJhc2VkIG9uIHRoZSBtaWRkbGV3YXJlIHRoYXQgcnVucy5cbiAqICAgICBzcHJpdGVzLmJ1bm55ID0gbmV3IFBJWEkuVGlsaW5nU3ByaXRlKHJlc291cmNlcy5idW5ueS50ZXh0dXJlKTtcbiAqICAgICBzcHJpdGVzLnNwYWNlc2hpcCA9IG5ldyBQSVhJLlRpbGluZ1Nwcml0ZShyZXNvdXJjZXMuc3BhY2VzaGlwLnRleHR1cmUpO1xuICogICAgIHNwcml0ZXMuc2NvcmVGb250ID0gbmV3IFBJWEkuVGlsaW5nU3ByaXRlKHJlc291cmNlcy5zY29yZUZvbnQudGV4dHVyZSk7XG4gKiB9KTtcbiAqXG4gKiAvLyB0aHJvdWdob3V0IHRoZSBwcm9jZXNzIG11bHRpcGxlIHNpZ25hbHMgY2FuIGJlIGRpc3BhdGNoZWQuXG4gKiBsb2FkZXIub25Qcm9ncmVzcy5hZGQoKCkgPT4ge30pOyAvLyBjYWxsZWQgb25jZSBwZXIgbG9hZGVkL2Vycm9yZWQgZmlsZVxuICogbG9hZGVyLm9uRXJyb3IuYWRkKCgpID0+IHt9KTsgLy8gY2FsbGVkIG9uY2UgcGVyIGVycm9yZWQgZmlsZVxuICogbG9hZGVyLm9uTG9hZC5hZGQoKCkgPT4ge30pOyAvLyBjYWxsZWQgb25jZSBwZXIgbG9hZGVkIGZpbGVcbiAqIGxvYWRlci5vbkNvbXBsZXRlLmFkZCgoKSA9PiB7fSk7IC8vIGNhbGxlZCBvbmNlIHdoZW4gdGhlIHF1ZXVlZCByZXNvdXJjZXMgYWxsIGxvYWQuXG4gKiBgYGBcbiAqXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lbmdsZXJjai9yZXNvdXJjZS1sb2FkZXJcbiAqXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIG1vZHVsZTpyZXNvdXJjZS1sb2FkZXIuUmVzb3VyY2VMb2FkZXJcbiAqIEBtZW1iZXJvZiBQSVhJLmxvYWRlcnNcbiAqL1xudmFyIExvYWRlciA9IGZ1bmN0aW9uIChfUmVzb3VyY2VMb2FkZXIpIHtcbiAgICBfaW5oZXJpdHMoTG9hZGVyLCBfUmVzb3VyY2VMb2FkZXIpO1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtiYXNlVXJsPScnXSAtIFRoZSBiYXNlIHVybCBmb3IgYWxsIHJlc291cmNlcyBsb2FkZWQgYnkgdGhpcyBsb2FkZXIuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtjb25jdXJyZW5jeT0xMF0gLSBUaGUgbnVtYmVyIG9mIHJlc291cmNlcyB0byBsb2FkIGNvbmN1cnJlbnRseS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBMb2FkZXIoYmFzZVVybCwgY29uY3VycmVuY3kpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIExvYWRlcik7XG5cbiAgICAgICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1Jlc291cmNlTG9hZGVyLmNhbGwodGhpcywgYmFzZVVybCwgY29uY3VycmVuY3kpKTtcblxuICAgICAgICBfZXZlbnRlbWl0dGVyMi5kZWZhdWx0LmNhbGwoX3RoaXMpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTG9hZGVyLl9waXhpTWlkZGxld2FyZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgX3RoaXMudXNlKExvYWRlci5fcGl4aU1pZGRsZXdhcmVbaV0oKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb21wYXQgbGF5ZXIsIHRyYW5zbGF0ZSB0aGUgbmV3IHYyIHNpZ25hbHMgaW50byBvbGQgdjEgZXZlbnRzLlxuICAgICAgICBfdGhpcy5vblN0YXJ0LmFkZChmdW5jdGlvbiAobCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmVtaXQoJ3N0YXJ0JywgbCk7XG4gICAgICAgIH0pO1xuICAgICAgICBfdGhpcy5vblByb2dyZXNzLmFkZChmdW5jdGlvbiAobCwgcikge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmVtaXQoJ3Byb2dyZXNzJywgbCwgcik7XG4gICAgICAgIH0pO1xuICAgICAgICBfdGhpcy5vbkVycm9yLmFkZChmdW5jdGlvbiAoZSwgbCwgcikge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmVtaXQoJ2Vycm9yJywgZSwgbCwgcik7XG4gICAgICAgIH0pO1xuICAgICAgICBfdGhpcy5vbkxvYWQuYWRkKGZ1bmN0aW9uIChsLCByKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuZW1pdCgnbG9hZCcsIGwsIHIpO1xuICAgICAgICB9KTtcbiAgICAgICAgX3RoaXMub25Db21wbGV0ZS5hZGQoZnVuY3Rpb24gKGwsIHIpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5lbWl0KCdjb21wbGV0ZScsIGwsIHIpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBkZWZhdWx0IG1pZGRsZXdhcmUgdG8gdGhlIFBpeGlKUyBsb2FkZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSBUaGUgbWlkZGxld2FyZSB0byBhZGQuXG4gICAgICovXG5cblxuICAgIExvYWRlci5hZGRQaXhpTWlkZGxld2FyZSA9IGZ1bmN0aW9uIGFkZFBpeGlNaWRkbGV3YXJlKGZuKSB7XG4gICAgICAgIExvYWRlci5fcGl4aU1pZGRsZXdhcmUucHVzaChmbik7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERlc3Ryb3kgdGhlIGxvYWRlciwgcmVtb3ZlcyByZWZlcmVuY2VzLlxuICAgICAqL1xuXG5cbiAgICBMb2FkZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgfTtcblxuICAgIHJldHVybiBMb2FkZXI7XG59KF9yZXNvdXJjZUxvYWRlcjIuZGVmYXVsdCk7XG5cbi8vIENvcHkgRUUzIHByb3RvdHlwZSAobWl4aW4pXG5cblxuZXhwb3J0cy5kZWZhdWx0ID0gTG9hZGVyO1xuZm9yICh2YXIgayBpbiBfZXZlbnRlbWl0dGVyMi5kZWZhdWx0LnByb3RvdHlwZSkge1xuICAgIExvYWRlci5wcm90b3R5cGVba10gPSBfZXZlbnRlbWl0dGVyMi5kZWZhdWx0LnByb3RvdHlwZVtrXTtcbn1cblxuTG9hZGVyLl9waXhpTWlkZGxld2FyZSA9IFtcbi8vIHBhcnNlIGFueSBibG9iIGludG8gbW9yZSB1c2FibGUgb2JqZWN0cyAoZS5nLiBJbWFnZSlcbl9ibG9iLmJsb2JNaWRkbGV3YXJlRmFjdG9yeSxcbi8vIHBhcnNlIGFueSBJbWFnZSBvYmplY3RzIGludG8gdGV4dHVyZXNcbl90ZXh0dXJlUGFyc2VyMi5kZWZhdWx0LFxuLy8gcGFyc2UgYW55IHNwcml0ZXNoZWV0IGRhdGEgaW50byBtdWx0aXBsZSB0ZXh0dXJlc1xuX3Nwcml0ZXNoZWV0UGFyc2VyMi5kZWZhdWx0LFxuLy8gcGFyc2UgYml0bWFwIGZvbnQgZGF0YSBpbnRvIG11bHRpcGxlIHRleHR1cmVzXG5fYml0bWFwRm9udFBhcnNlcjIuZGVmYXVsdF07XG5cbi8vIEFkZCBjdXN0b20gZXh0ZW50aW9uc1xudmFyIFJlc291cmNlID0gX3Jlc291cmNlTG9hZGVyMi5kZWZhdWx0LlJlc291cmNlO1xuXG5SZXNvdXJjZS5zZXRFeHRlbnNpb25YaHJUeXBlKCdmbnQnLCBSZXNvdXJjZS5YSFJfUkVTUE9OU0VfVFlQRS5ET0NVTUVOVCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2FkZXIuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHNwcml0ZXNoZWV0UGFyc2VyKHJlc291cmNlLCBuZXh0KSB7XG4gICAgICAgIHZhciBpbWFnZVJlc291cmNlTmFtZSA9IHJlc291cmNlLm5hbWUgKyAnX2ltYWdlJztcblxuICAgICAgICAvLyBza2lwIGlmIG5vIGRhdGEsIGl0cyBub3QganNvbiwgaXQgaXNuJ3Qgc3ByaXRlc2hlZXQgZGF0YSwgb3IgdGhlIGltYWdlIHJlc291cmNlIGFscmVhZHkgZXhpc3RzXG4gICAgICAgIGlmICghcmVzb3VyY2UuZGF0YSB8fCByZXNvdXJjZS50eXBlICE9PSBfcmVzb3VyY2VMb2FkZXIuUmVzb3VyY2UuVFlQRS5KU09OIHx8ICFyZXNvdXJjZS5kYXRhLmZyYW1lcyB8fCB0aGlzLnJlc291cmNlc1tpbWFnZVJlc291cmNlTmFtZV0pIHtcbiAgICAgICAgICAgIG5leHQoKTtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxvYWRPcHRpb25zID0ge1xuICAgICAgICAgICAgY3Jvc3NPcmlnaW46IHJlc291cmNlLmNyb3NzT3JpZ2luLFxuICAgICAgICAgICAgbWV0YWRhdGE6IHJlc291cmNlLm1ldGFkYXRhLmltYWdlTWV0YWRhdGEsXG4gICAgICAgICAgICBwYXJlbnRSZXNvdXJjZTogcmVzb3VyY2VcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgcmVzb3VyY2VQYXRoID0gZ2V0UmVzb3VyY2VQYXRoKHJlc291cmNlLCB0aGlzLmJhc2VVcmwpO1xuXG4gICAgICAgIC8vIGxvYWQgdGhlIGltYWdlIGZvciB0aGlzIHNoZWV0XG4gICAgICAgIHRoaXMuYWRkKGltYWdlUmVzb3VyY2VOYW1lLCByZXNvdXJjZVBhdGgsIGxvYWRPcHRpb25zLCBmdW5jdGlvbiBvbkltYWdlTG9hZChyZXMpIHtcbiAgICAgICAgICAgIGlmIChyZXMuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBuZXh0KHJlcy5lcnJvcik7XG5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzcHJpdGVzaGVldCA9IG5ldyBfY29yZS5TcHJpdGVzaGVldChyZXMudGV4dHVyZS5iYXNlVGV4dHVyZSwgcmVzb3VyY2UuZGF0YSwgcmVzb3VyY2UudXJsKTtcblxuICAgICAgICAgICAgc3ByaXRlc2hlZXQucGFyc2UoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJlc291cmNlLnNwcml0ZXNoZWV0ID0gc3ByaXRlc2hlZXQ7XG4gICAgICAgICAgICAgICAgcmVzb3VyY2UudGV4dHVyZXMgPSBzcHJpdGVzaGVldC50ZXh0dXJlcztcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbn07XG5cbmV4cG9ydHMuZ2V0UmVzb3VyY2VQYXRoID0gZ2V0UmVzb3VyY2VQYXRoO1xuXG52YXIgX3Jlc291cmNlTG9hZGVyID0gcmVxdWlyZSgncmVzb3VyY2UtbG9hZGVyJyk7XG5cbnZhciBfdXJsID0gcmVxdWlyZSgndXJsJyk7XG5cbnZhciBfdXJsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3VybCk7XG5cbnZhciBfY29yZSA9IHJlcXVpcmUoJy4uL2NvcmUnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gZ2V0UmVzb3VyY2VQYXRoKHJlc291cmNlLCBiYXNlVXJsKSB7XG4gICAgLy8gUHJlcGVuZCB1cmwgcGF0aCB1bmxlc3MgdGhlIHJlc291cmNlIGltYWdlIGlzIGEgZGF0YSB1cmxcbiAgICBpZiAocmVzb3VyY2UuaXNEYXRhVXJsKSB7XG4gICAgICAgIHJldHVybiByZXNvdXJjZS5kYXRhLm1ldGEuaW1hZ2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIF91cmwyLmRlZmF1bHQucmVzb2x2ZShyZXNvdXJjZS51cmwucmVwbGFjZShiYXNlVXJsLCAnJyksIHJlc291cmNlLmRhdGEubWV0YS5pbWFnZSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zcHJpdGVzaGVldFBhcnNlci5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gdGV4dHVyZVBhcnNlcihyZXNvdXJjZSwgbmV4dCkge1xuICAgICAgICAvLyBjcmVhdGUgYSBuZXcgdGV4dHVyZSBpZiB0aGUgZGF0YSBpcyBhbiBJbWFnZSBvYmplY3RcbiAgICAgICAgaWYgKHJlc291cmNlLmRhdGEgJiYgcmVzb3VyY2UudHlwZSA9PT0gX3Jlc291cmNlTG9hZGVyLlJlc291cmNlLlRZUEUuSU1BR0UpIHtcbiAgICAgICAgICAgIHJlc291cmNlLnRleHR1cmUgPSBfVGV4dHVyZTIuZGVmYXVsdC5mcm9tTG9hZGVyKHJlc291cmNlLmRhdGEsIHJlc291cmNlLnVybCwgcmVzb3VyY2UubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgbmV4dCgpO1xuICAgIH07XG59O1xuXG52YXIgX3Jlc291cmNlTG9hZGVyID0gcmVxdWlyZSgncmVzb3VyY2UtbG9hZGVyJyk7XG5cbnZhciBfVGV4dHVyZSA9IHJlcXVpcmUoJy4uL2NvcmUvdGV4dHVyZXMvVGV4dHVyZScpO1xuXG52YXIgX1RleHR1cmUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVGV4dHVyZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG4vLyMgc291cmNlTWFwcGluZ1VSTD10ZXh0dXJlUGFyc2VyLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9jb3JlID0gcmVxdWlyZSgnLi4vY29yZScpO1xuXG52YXIgY29yZSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9jb3JlKTtcblxudmFyIF9UZXh0dXJlID0gcmVxdWlyZSgnLi4vY29yZS90ZXh0dXJlcy9UZXh0dXJlJyk7XG5cbnZhciBfVGV4dHVyZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9UZXh0dXJlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgdGVtcFBvaW50ID0gbmV3IGNvcmUuUG9pbnQoKTtcbnZhciB0ZW1wUG9seWdvbiA9IG5ldyBjb3JlLlBvbHlnb24oKTtcblxuLyoqXG4gKiBCYXNlIG1lc2ggY2xhc3NcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgUElYSS5Db250YWluZXJcbiAqIEBtZW1iZXJvZiBQSVhJLm1lc2hcbiAqL1xuXG52YXIgTWVzaCA9IGZ1bmN0aW9uIChfY29yZSRDb250YWluZXIpIHtcbiAgICBfaW5oZXJpdHMoTWVzaCwgX2NvcmUkQ29udGFpbmVyKTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7UElYSS5UZXh0dXJlfSB0ZXh0dXJlIC0gVGhlIHRleHR1cmUgdG8gdXNlXG4gICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl9IFt2ZXJ0aWNlc10gLSBpZiB5b3Ugd2FudCB0byBzcGVjaWZ5IHRoZSB2ZXJ0aWNlc1xuICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSBbdXZzXSAtIGlmIHlvdSB3YW50IHRvIHNwZWNpZnkgdGhlIHV2c1xuICAgICAqIEBwYXJhbSB7VWludDE2QXJyYXl9IFtpbmRpY2VzXSAtIGlmIHlvdSB3YW50IHRvIHNwZWNpZnkgdGhlIGluZGljZXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2RyYXdNb2RlXSAtIHRoZSBkcmF3TW9kZSwgY2FuIGJlIGFueSBvZiB0aGUgTWVzaC5EUkFXX01PREVTIGNvbnN0c1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIE1lc2godGV4dHVyZSwgdmVydGljZXMsIHV2cywgaW5kaWNlcywgZHJhd01vZGUpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1lc2gpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdGV4dHVyZSBvZiB0aGUgTWVzaFxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLlRleHR1cmV9XG4gICAgICAgICAqIEBkZWZhdWx0IFBJWEkuVGV4dHVyZS5FTVBUWVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2NvcmUkQ29udGFpbmVyLmNhbGwodGhpcykpO1xuXG4gICAgICAgIF90aGlzLl90ZXh0dXJlID0gdGV4dHVyZSB8fCBfVGV4dHVyZTIuZGVmYXVsdC5FTVBUWTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIFV2cyBvZiB0aGUgTWVzaFxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtGbG9hdDMyQXJyYXl9XG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy51dnMgPSB1dnMgfHwgbmV3IEZsb2F0MzJBcnJheShbMCwgMCwgMSwgMCwgMSwgMSwgMCwgMV0pO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBhcnJheSBvZiB2ZXJ0aWNlc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtGbG9hdDMyQXJyYXl9XG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy52ZXJ0aWNlcyA9IHZlcnRpY2VzIHx8IG5ldyBGbG9hdDMyQXJyYXkoWzAsIDAsIDEwMCwgMCwgMTAwLCAxMDAsIDAsIDEwMF0pO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBhcnJheSBjb250YWluaW5nIHRoZSBpbmRpY2VzIG9mIHRoZSB2ZXJ0aWNlc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtVaW50MTZBcnJheX1cbiAgICAgICAgICovXG4gICAgICAgIC8vICBUT0RPIGF1dG8gZ2VuZXJhdGUgdGhpcyBiYXNlZCBvbiBkcmF3IG1vZGUhXG4gICAgICAgIF90aGlzLmluZGljZXMgPSBpbmRpY2VzIHx8IG5ldyBVaW50MTZBcnJheShbMCwgMSwgMywgMl0pO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBWZXJzaW9uIG9mIG1lc2ggdXZzIGFyZSBkaXJ0eSBvciBub3RcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuZGlydHkgPSAwO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBWZXJzaW9uIG9mIG1lc2ggaW5kaWNlc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5pbmRleERpcnR5ID0gMDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVmVyc2lvbiBvZiBtZXNoIHZlcnRpY2llcyBhcnJheVxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy52ZXJ0ZXhEaXJ0eSA9IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB0aGUgZGVmYXVsdCBpcyB0byByZS11cGxvYWQgdmVydGljaWVzIGVhY2ggcmVuZGVyIGNhbGwuXG4gICAgICAgICAqIFNldCB0aGlzIHRvIGBmYWxzZWAgYW5kIGluY3JlYXNlIGB2ZXJ0ZXhEaXJ0eWAgdG8gbWFudWFsbHkgcmUtdXBsb2FkIHRoZSBidWZmZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5hdXRvVXBkYXRlID0gdHJ1ZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGJsZW5kIG1vZGUgdG8gYmUgYXBwbGllZCB0byB0aGUgc3ByaXRlLiBTZXQgdG8gYFBJWEkuQkxFTkRfTU9ERVMuTk9STUFMYCB0byByZW1vdmVcbiAgICAgICAgICogYW55IGJsZW5kIG1vZGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgUElYSS5CTEVORF9NT0RFUy5OT1JNQUxcbiAgICAgICAgICogQHNlZSBQSVhJLkJMRU5EX01PREVTXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5ibGVuZE1vZGUgPSBjb3JlLkJMRU5EX01PREVTLk5PUk1BTDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVHJpYW5nbGVzIGluIGNhbnZhcyBtb2RlIGFyZSBhdXRvbWF0aWNhbGx5IGFudGlhbGlhc2VkLCB1c2UgdGhpcyB2YWx1ZSB0byBmb3JjZSB0cmlhbmdsZXNcbiAgICAgICAgICogdG8gb3ZlcmxhcCBhIGJpdCB3aXRoIGVhY2ggb3RoZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLmNhbnZhc1BhZGRpbmcgPSBjb3JlLnNldHRpbmdzLk1FU0hfQ0FOVkFTX1BBRERJTkc7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB3YXkgdGhlIE1lc2ggc2hvdWxkIGJlIGRyYXduLCBjYW4gYmUgYW55IG9mIHRoZSB7QGxpbmsgUElYSS5tZXNoLk1lc2guRFJBV19NT0RFU30gY29uc3RzXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQHNlZSBQSVhJLm1lc2guTWVzaC5EUkFXX01PREVTXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5kcmF3TW9kZSA9IGRyYXdNb2RlIHx8IE1lc2guRFJBV19NT0RFUy5UUklBTkdMRV9NRVNIO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGVmYXVsdCBzaGFkZXIgdGhhdCBpcyB1c2VkIGlmIGEgbWVzaCBkb2Vzbid0IGhhdmUgYSBtb3JlIHNwZWNpZmljIG9uZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5TaGFkZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5zaGFkZXIgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdGludCBhcHBsaWVkIHRvIHRoZSBtZXNoLiBUaGlzIGlzIGEgW3IsZyxiXSB2YWx1ZS4gQSB2YWx1ZSBvZiBbMSwxLDFdIHdpbGwgcmVtb3ZlIGFueVxuICAgICAgICAgKiB0aW50IGVmZmVjdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMudGludFJnYiA9IG5ldyBGbG9hdDMyQXJyYXkoWzEsIDEsIDFdKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBtYXAgb2YgcmVuZGVyZXIgSURzIHRvIHdlYmdsIHJlbmRlciBkYXRhXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBtZW1iZXIge29iamVjdDxudW1iZXIsIG9iamVjdD59XG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5fZ2xEYXRhcyA9IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0cmFuc2Zvcm0gdGhhdCBpcyBhcHBsaWVkIHRvIFVWIHRvIGdldCB0aGUgdGV4dHVyZSBjb29yZHNcbiAgICAgICAgICogaXRzIHVwZGF0ZWQgaW5kZXBlbmRlbnRseSBmcm9tIHRleHR1cmUgdXZUcmFuc2Zvcm1cbiAgICAgICAgICogdXBkYXRlcyBvZiB1dnMgYXJlIHRpZWQgdG8gdGhhdCB0aGluZ1xuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLlRleHR1cmVNYXRyaXh9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5fdXZUcmFuc2Zvcm0gPSBuZXcgY29yZS5UZXh0dXJlTWF0cml4KF90aGlzLl90ZXh0dXJlKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogd2hldGhlciBvciBub3QgdXBsb2FkIHV2VHJhbnNmb3JtIHRvIHNoYWRlclxuICAgICAgICAgKiBpZiBpdHMgZmFsc2UsIHRoZW4gdXZzIHNob3VsZCBiZSBwcmUtbXVsdGlwbGllZFxuICAgICAgICAgKiBpZiB5b3UgY2hhbmdlIGl0IGZvciBnZW5lcmF0ZWQgbWVzaCwgcGxlYXNlIGNhbGwgJ3JlZnJlc2godHJ1ZSknXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy51cGxvYWRVdlRyYW5zZm9ybSA9IGZhbHNlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQbHVnaW4gdGhhdCBpcyByZXNwb25zaWJsZSBmb3IgcmVuZGVyaW5nIHRoaXMgZWxlbWVudC5cbiAgICAgICAgICogQWxsb3dzIHRvIGN1c3RvbWl6ZSB0aGUgcmVuZGVyaW5nIHByb2Nlc3Mgd2l0aG91dCBvdmVycmlkaW5nICdfcmVuZGVyV2ViR0wnICYgJ19yZW5kZXJDYW52YXMnIG1ldGhvZHMuXG4gICAgICAgICAqIEBtZW1iZXIge3N0cmluZ31cbiAgICAgICAgICogQGRlZmF1bHQgJ21lc2gnXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5wbHVnaW5OYW1lID0gJ21lc2gnO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0aGUgb2JqZWN0IHVzaW5nIHRoZSBXZWJHTCByZW5kZXJlclxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1BJWEkuV2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBhIHJlZmVyZW5jZSB0byB0aGUgV2ViR0wgcmVuZGVyZXJcbiAgICAgKi9cblxuXG4gICAgTWVzaC5wcm90b3R5cGUuX3JlbmRlcldlYkdMID0gZnVuY3Rpb24gX3JlbmRlcldlYkdMKHJlbmRlcmVyKSB7XG4gICAgICAgIHRoaXMucmVmcmVzaCgpO1xuICAgICAgICByZW5kZXJlci5zZXRPYmplY3RSZW5kZXJlcihyZW5kZXJlci5wbHVnaW5zW3RoaXMucGx1Z2luTmFtZV0pO1xuICAgICAgICByZW5kZXJlci5wbHVnaW5zW3RoaXMucGx1Z2luTmFtZV0ucmVuZGVyKHRoaXMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIHRoZSBvYmplY3QgdXNpbmcgdGhlIENhbnZhcyByZW5kZXJlclxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1BJWEkuQ2FudmFzUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIGNhbnZhcyByZW5kZXJlci5cbiAgICAgKi9cblxuXG4gICAgTWVzaC5wcm90b3R5cGUuX3JlbmRlckNhbnZhcyA9IGZ1bmN0aW9uIF9yZW5kZXJDYW52YXMocmVuZGVyZXIpIHtcbiAgICAgICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgICAgIHJlbmRlcmVyLnBsdWdpbnNbdGhpcy5wbHVnaW5OYW1lXS5yZW5kZXIodGhpcyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFdoZW4gdGhlIHRleHR1cmUgaXMgdXBkYXRlZCwgdGhpcyBldmVudCB3aWxsIGZpcmUgdG8gdXBkYXRlIHRoZSBzY2FsZSBhbmQgZnJhbWVcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cblxuICAgIE1lc2gucHJvdG90eXBlLl9vblRleHR1cmVVcGRhdGUgPSBmdW5jdGlvbiBfb25UZXh0dXJlVXBkYXRlKCkge1xuICAgICAgICB0aGlzLl91dlRyYW5zZm9ybS50ZXh0dXJlID0gdGhpcy5fdGV4dHVyZTtcbiAgICAgICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIG11bHRpcGxpZXMgdXZzIG9ubHkgaWYgdXBsb2FkVXZUcmFuc2Zvcm0gaXMgZmFsc2VcbiAgICAgKiBjYWxsIGl0IGFmdGVyIHlvdSBjaGFuZ2UgdXZzIG1hbnVhbGx5XG4gICAgICogbWFrZSBzdXJlIHRoYXQgdGV4dHVyZSBpcyB2YWxpZFxuICAgICAqL1xuXG5cbiAgICBNZXNoLnByb3RvdHlwZS5tdWx0aXBseVV2cyA9IGZ1bmN0aW9uIG11bHRpcGx5VXZzKCkge1xuICAgICAgICBpZiAoIXRoaXMudXBsb2FkVXZUcmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIHRoaXMuX3V2VHJhbnNmb3JtLm11bHRpcGx5VXZzKHRoaXMudXZzKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZWZyZXNoZXMgdXZzIGZvciBnZW5lcmF0ZWQgbWVzaGVzIChyb3BlLCBwbGFuZSlcbiAgICAgKiBzb21ldGltZXMgcmVmcmVzaGVzIHZlcnRpY2VzIHRvb1xuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZm9yY2VVcGRhdGU9ZmFsc2VdIGlmIHRydWUsIG1hdHJpY2VzIHdpbGwgYmUgdXBkYXRlZCBhbnkgY2FzZVxuICAgICAqL1xuXG5cbiAgICBNZXNoLnByb3RvdHlwZS5yZWZyZXNoID0gZnVuY3Rpb24gcmVmcmVzaChmb3JjZVVwZGF0ZSkge1xuICAgICAgICBpZiAodGhpcy5hdXRvVXBkYXRlKSB7XG4gICAgICAgICAgICB0aGlzLnZlcnRleERpcnR5Kys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3V2VHJhbnNmb3JtLnVwZGF0ZShmb3JjZVVwZGF0ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlZnJlc2goKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiByZS1jYWxjdWxhdGVzIG1lc2ggY29vcmRzXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuXG5cbiAgICBNZXNoLnByb3RvdHlwZS5fcmVmcmVzaCA9IGZ1bmN0aW9uIF9yZWZyZXNoKCkge31cbiAgICAvKiBlbXB0eSAqL1xuXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBib3VuZHMgb2YgdGhlIG1lc2ggYXMgYSByZWN0YW5nbGUuIFRoZSBib3VuZHMgY2FsY3VsYXRpb24gdGFrZXMgdGhlIHdvcmxkVHJhbnNmb3JtIGludG8gYWNjb3VudC5cbiAgICAgKlxuICAgICAqL1xuICAgIDtcblxuICAgIE1lc2gucHJvdG90eXBlLl9jYWxjdWxhdGVCb3VuZHMgPSBmdW5jdGlvbiBfY2FsY3VsYXRlQm91bmRzKCkge1xuICAgICAgICAvLyBUT0RPIC0gd2UgY2FuIGNhY2hlIGxvY2FsIGJvdW5kcyBhbmQgdXNlIHRoZW0gaWYgdGhleSBhcmUgZGlydHkgKGxpa2UgZ3JhcGhpY3MpXG4gICAgICAgIHRoaXMuX2JvdW5kcy5hZGRWZXJ0aWNlcyh0aGlzLnRyYW5zZm9ybSwgdGhpcy52ZXJ0aWNlcywgMCwgdGhpcy52ZXJ0aWNlcy5sZW5ndGgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUZXN0cyBpZiBhIHBvaW50IGlzIGluc2lkZSB0aGlzIG1lc2guIFdvcmtzIG9ubHkgZm9yIFRSSUFOR0xFX01FU0hcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5Qb2ludH0gcG9pbnQgLSB0aGUgcG9pbnQgdG8gdGVzdFxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IHRoZSByZXN1bHQgb2YgdGhlIHRlc3RcbiAgICAgKi9cblxuXG4gICAgTWVzaC5wcm90b3R5cGUuY29udGFpbnNQb2ludCA9IGZ1bmN0aW9uIGNvbnRhaW5zUG9pbnQocG9pbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmdldEJvdW5kcygpLmNvbnRhaW5zKHBvaW50LngsIHBvaW50LnkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLndvcmxkVHJhbnNmb3JtLmFwcGx5SW52ZXJzZShwb2ludCwgdGVtcFBvaW50KTtcblxuICAgICAgICB2YXIgdmVydGljZXMgPSB0aGlzLnZlcnRpY2VzO1xuICAgICAgICB2YXIgcG9pbnRzID0gdGVtcFBvbHlnb24ucG9pbnRzO1xuICAgICAgICB2YXIgaW5kaWNlcyA9IHRoaXMuaW5kaWNlcztcbiAgICAgICAgdmFyIGxlbiA9IHRoaXMuaW5kaWNlcy5sZW5ndGg7XG4gICAgICAgIHZhciBzdGVwID0gdGhpcy5kcmF3TW9kZSA9PT0gTWVzaC5EUkFXX01PREVTLlRSSUFOR0xFUyA/IDMgOiAxO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpICsgMiA8IGxlbjsgaSArPSBzdGVwKSB7XG4gICAgICAgICAgICB2YXIgaW5kMCA9IGluZGljZXNbaV0gKiAyO1xuICAgICAgICAgICAgdmFyIGluZDEgPSBpbmRpY2VzW2kgKyAxXSAqIDI7XG4gICAgICAgICAgICB2YXIgaW5kMiA9IGluZGljZXNbaSArIDJdICogMjtcblxuICAgICAgICAgICAgcG9pbnRzWzBdID0gdmVydGljZXNbaW5kMF07XG4gICAgICAgICAgICBwb2ludHNbMV0gPSB2ZXJ0aWNlc1tpbmQwICsgMV07XG4gICAgICAgICAgICBwb2ludHNbMl0gPSB2ZXJ0aWNlc1tpbmQxXTtcbiAgICAgICAgICAgIHBvaW50c1szXSA9IHZlcnRpY2VzW2luZDEgKyAxXTtcbiAgICAgICAgICAgIHBvaW50c1s0XSA9IHZlcnRpY2VzW2luZDJdO1xuICAgICAgICAgICAgcG9pbnRzWzVdID0gdmVydGljZXNbaW5kMiArIDFdO1xuXG4gICAgICAgICAgICBpZiAodGVtcFBvbHlnb24uY29udGFpbnModGVtcFBvaW50LngsIHRlbXBQb2ludC55KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdGV4dHVyZSB0aGF0IHRoZSBtZXNoIHVzZXMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtQSVhJLlRleHR1cmV9XG4gICAgICovXG5cblxuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIHRoZSBNZXNoIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fGJvb2xlYW59IFtvcHRpb25zXSAtIE9wdGlvbnMgcGFyYW1ldGVyLiBBIGJvb2xlYW4gd2lsbCBhY3QgYXMgaWYgYWxsXG4gICAgICogIG9wdGlvbnMgaGF2ZSBiZWVuIHNldCB0byB0aGF0IHZhbHVlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jaGlsZHJlbj1mYWxzZV0gLSBpZiBzZXQgdG8gdHJ1ZSwgYWxsIHRoZSBjaGlsZHJlbiB3aWxsIGhhdmVcbiAgICAgKiAgdGhlaXIgZGVzdHJveSBtZXRob2QgY2FsbGVkIGFzIHdlbGwuICdvcHRpb25zJyB3aWxsIGJlIHBhc3NlZCBvbiB0byB0aG9zZSBjYWxscy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRleHR1cmU9ZmFsc2VdIC0gT25seSB1c2VkIGZvciBjaGlsZCBTcHJpdGVzIGlmIG9wdGlvbnMuY2hpbGRyZW4gaXMgc2V0IHRvIHRydWVcbiAgICAgKiAgU2hvdWxkIGl0IGRlc3Ryb3kgdGhlIHRleHR1cmUgb2YgdGhlIGNoaWxkIHNwcml0ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuYmFzZVRleHR1cmU9ZmFsc2VdIC0gT25seSB1c2VkIGZvciBjaGlsZCBTcHJpdGVzIGlmIG9wdGlvbnMuY2hpbGRyZW4gaXMgc2V0IHRvIHRydWVcbiAgICAgKiAgU2hvdWxkIGl0IGRlc3Ryb3kgdGhlIGJhc2UgdGV4dHVyZSBvZiB0aGUgY2hpbGQgc3ByaXRlXG4gICAgICovXG4gICAgTWVzaC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3kob3B0aW9ucykge1xuICAgICAgICAvLyBmb3IgZWFjaCB3ZWJnbCBkYXRhIGVudHJ5LCBkZXN0cm95IHRoZSBXZWJHTEdyYXBoaWNzRGF0YVxuICAgICAgICBmb3IgKHZhciBpZCBpbiB0aGlzLl9nbERhdGFzKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX2dsRGF0YXNbaWRdO1xuXG4gICAgICAgICAgICBpZiAoZGF0YS5kZXN0cm95KSB7XG4gICAgICAgICAgICAgICAgZGF0YS5kZXN0cm95KCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChkYXRhLnZlcnRleEJ1ZmZlcikge1xuICAgICAgICAgICAgICAgICAgICBkYXRhLnZlcnRleEJ1ZmZlci5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEudmVydGV4QnVmZmVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuaW5kZXhCdWZmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5pbmRleEJ1ZmZlci5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEuaW5kZXhCdWZmZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZGF0YS51dkJ1ZmZlcikge1xuICAgICAgICAgICAgICAgICAgICBkYXRhLnV2QnVmZmVyLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS51dkJ1ZmZlciA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkYXRhLnZhbykge1xuICAgICAgICAgICAgICAgICAgICBkYXRhLnZhby5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEudmFvID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9nbERhdGFzID0gbnVsbDtcblxuICAgICAgICBfY29yZSRDb250YWluZXIucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICB9O1xuXG4gICAgX2NyZWF0ZUNsYXNzKE1lc2gsIFt7XG4gICAgICAgIGtleTogJ3RleHR1cmUnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90ZXh0dXJlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSByZXF1aXJlLWpzZG9jXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl90ZXh0dXJlID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fdGV4dHVyZSA9IHZhbHVlO1xuXG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAvLyB3YWl0IGZvciB0aGUgdGV4dHVyZSB0byBsb2FkXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLmJhc2VUZXh0dXJlLmhhc0xvYWRlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vblRleHR1cmVVcGRhdGUoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZS5vbmNlKCd1cGRhdGUnLCB0aGlzLl9vblRleHR1cmVVcGRhdGUsIHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdGludCBhcHBsaWVkIHRvIHRoZSBtZXNoLiBUaGlzIGlzIGEgaGV4IHZhbHVlLiBBIHZhbHVlIG9mIDB4RkZGRkZGIHdpbGwgcmVtb3ZlIGFueSB0aW50IGVmZmVjdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAweEZGRkZGRlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndGludCcsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvcmUudXRpbHMucmdiMmhleCh0aGlzLnRpbnRSZ2IpO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSByZXF1aXJlLWpzZG9jXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMudGludFJnYiA9IGNvcmUudXRpbHMuaGV4MnJnYih2YWx1ZSwgdGhpcy50aW50UmdiKTtcbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBNZXNoO1xufShjb3JlLkNvbnRhaW5lcik7XG5cbi8qKlxuICogRGlmZmVyZW50IGRyYXdpbmcgYnVmZmVyIG1vZGVzIHN1cHBvcnRlZFxuICpcbiAqIEBzdGF0aWNcbiAqIEBjb25zdGFudFxuICogQHR5cGUge29iamVjdH1cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBUUklBTkdMRV9NRVNIXG4gKiBAcHJvcGVydHkge251bWJlcn0gVFJJQU5HTEVTXG4gKi9cblxuXG5leHBvcnRzLmRlZmF1bHQgPSBNZXNoO1xuTWVzaC5EUkFXX01PREVTID0ge1xuICAgIFRSSUFOR0xFX01FU0g6IDAsXG4gICAgVFJJQU5HTEVTOiAxXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TWVzaC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfUGxhbmUyID0gcmVxdWlyZSgnLi9QbGFuZScpO1xuXG52YXIgX1BsYW5lMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1BsYW5lMik7XG5cbnZhciBfQ2FudmFzVGludGVyID0gcmVxdWlyZSgnLi4vY29yZS9zcHJpdGVzL2NhbnZhcy9DYW52YXNUaW50ZXInKTtcblxudmFyIF9DYW52YXNUaW50ZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQ2FudmFzVGludGVyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgREVGQVVMVF9CT1JERVJfU0laRSA9IDEwO1xuXG4vKipcbiAqIFRoZSBOaW5lU2xpY2VQbGFuZSBhbGxvd3MgeW91IHRvIHN0cmV0Y2ggYSB0ZXh0dXJlIHVzaW5nIDktc2xpY2Ugc2NhbGluZy4gVGhlIGNvcm5lcnMgd2lsbCByZW1haW4gdW5zY2FsZWQgKHVzZWZ1bFxuICogZm9yIGJ1dHRvbnMgd2l0aCByb3VuZGVkIGNvcm5lcnMgZm9yIGV4YW1wbGUpIGFuZCB0aGUgb3RoZXIgYXJlYXMgd2lsbCBiZSBzY2FsZWQgaG9yaXpvbnRhbGx5IGFuZCBvciB2ZXJ0aWNhbGx5XG4gKlxuICpgYGBqc1xuICogbGV0IFBsYW5lOSA9IG5ldyBQSVhJLk5pbmVTbGljZVBsYW5lKFBJWEkuVGV4dHVyZS5mcm9tSW1hZ2UoJ0JveFdpdGhSb3VuZGVkQ29ybmVycy5wbmcnKSwgMTUsIDE1LCAxNSwgMTUpO1xuICogIGBgYFxuICogPHByZT5cbiAqICAgICAgQSAgICAgICAgICAgICAgICAgICAgICAgICAgQlxuICogICAgKy0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLStcbiAqICBDIHwgMSB8ICAgICAgICAgIDIgICAgICAgICAgIHwgMyB8XG4gKiAgICArLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tK1xuICogICAgfCAgIHwgICAgICAgICAgICAgICAgICAgICAgfCAgIHxcbiAqICAgIHwgNCB8ICAgICAgICAgIDUgICAgICAgICAgIHwgNiB8XG4gKiAgICB8ICAgfCAgICAgICAgICAgICAgICAgICAgICB8ICAgfFxuICogICAgKy0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLStcbiAqICBEIHwgNyB8ICAgICAgICAgIDggICAgICAgICAgIHwgOSB8XG4gKiAgICArLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tK1xuXG4gKiAgV2hlbiBjaGFuZ2luZyB0aGlzIG9iamVjdHMgd2lkdGggYW5kL29yIGhlaWdodDpcbiAqICAgICBhcmVhcyAxIDMgNyBhbmQgOSB3aWxsIHJlbWFpbiB1bnNjYWxlZC5cbiAqICAgICBhcmVhcyAyIGFuZCA4IHdpbGwgYmUgc3RyZXRjaGVkIGhvcml6b250YWxseVxuICogICAgIGFyZWFzIDQgYW5kIDYgd2lsbCBiZSBzdHJldGNoZWQgdmVydGljYWxseVxuICogICAgIGFyZWEgNSB3aWxsIGJlIHN0cmV0Y2hlZCBib3RoIGhvcml6b250YWxseSBhbmQgdmVydGljYWxseVxuICogPC9wcmU+XG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQSVhJLm1lc2guUGxhbmVcbiAqIEBtZW1iZXJvZiBQSVhJLm1lc2hcbiAqXG4gKi9cblxudmFyIE5pbmVTbGljZVBsYW5lID0gZnVuY3Rpb24gKF9QbGFuZSkge1xuICAgIF9pbmhlcml0cyhOaW5lU2xpY2VQbGFuZSwgX1BsYW5lKTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7UElYSS5UZXh0dXJlfSB0ZXh0dXJlIC0gVGhlIHRleHR1cmUgdG8gdXNlIG9uIHRoZSBOaW5lU2xpY2VQbGFuZS5cbiAgICAgKiBAcGFyYW0ge2ludH0gW2xlZnRXaWR0aD0xMF0gc2l6ZSBvZiB0aGUgbGVmdCB2ZXJ0aWNhbCBiYXIgKEEpXG4gICAgICogQHBhcmFtIHtpbnR9IFt0b3BIZWlnaHQ9MTBdIHNpemUgb2YgdGhlIHRvcCBob3Jpem9udGFsIGJhciAoQylcbiAgICAgKiBAcGFyYW0ge2ludH0gW3JpZ2h0V2lkdGg9MTBdIHNpemUgb2YgdGhlIHJpZ2h0IHZlcnRpY2FsIGJhciAoQilcbiAgICAgKiBAcGFyYW0ge2ludH0gW2JvdHRvbUhlaWdodD0xMF0gc2l6ZSBvZiB0aGUgYm90dG9tIGhvcml6b250YWwgYmFyIChEKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE5pbmVTbGljZVBsYW5lKHRleHR1cmUsIGxlZnRXaWR0aCwgdG9wSGVpZ2h0LCByaWdodFdpZHRoLCBib3R0b21IZWlnaHQpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE5pbmVTbGljZVBsYW5lKTtcblxuICAgICAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUGxhbmUuY2FsbCh0aGlzLCB0ZXh0dXJlLCA0LCA0KSk7XG5cbiAgICAgICAgX3RoaXMuX29yaWdXaWR0aCA9IHRleHR1cmUub3JpZy53aWR0aDtcbiAgICAgICAgX3RoaXMuX29yaWdIZWlnaHQgPSB0ZXh0dXJlLm9yaWcuaGVpZ2h0O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgd2lkdGggb2YgdGhlIE5pbmVTbGljZVBsYW5lLCBzZXR0aW5nIHRoaXMgd2lsbCBhY3R1YWxseSBtb2RpZnkgdGhlIHZlcnRpY2VzIGFuZCBVVidzIG9mIHRoaXMgcGxhbmVcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAbWVtYmVyb2YgUElYSS5OaW5lU2xpY2VQbGFuZSNcbiAgICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5fd2lkdGggPSBfdGhpcy5fb3JpZ1dpZHRoO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgaGVpZ2h0IG9mIHRoZSBOaW5lU2xpY2VQbGFuZSwgc2V0dGluZyB0aGlzIHdpbGwgYWN0dWFsbHkgbW9kaWZ5IHRoZSB2ZXJ0aWNlcyBhbmQgVVYncyBvZiB0aGlzIHBsYW5lXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQG1lbWJlcm9mIFBJWEkuTmluZVNsaWNlUGxhbmUjXG4gICAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuX2hlaWdodCA9IF90aGlzLl9vcmlnSGVpZ2h0O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgd2lkdGggb2YgdGhlIGxlZnQgY29sdW1uIChhKVxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBtZW1iZXJvZiBQSVhJLk5pbmVTbGljZVBsYW5lI1xuICAgICAgICAgKiBAb3ZlcnJpZGVcbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLl9sZWZ0V2lkdGggPSB0eXBlb2YgbGVmdFdpZHRoICE9PSAndW5kZWZpbmVkJyA/IGxlZnRXaWR0aCA6IERFRkFVTFRfQk9SREVSX1NJWkU7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB3aWR0aCBvZiB0aGUgcmlnaHQgY29sdW1uIChiKVxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBtZW1iZXJvZiBQSVhJLk5pbmVTbGljZVBsYW5lI1xuICAgICAgICAgKiBAb3ZlcnJpZGVcbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLl9yaWdodFdpZHRoID0gdHlwZW9mIHJpZ2h0V2lkdGggIT09ICd1bmRlZmluZWQnID8gcmlnaHRXaWR0aCA6IERFRkFVTFRfQk9SREVSX1NJWkU7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBoZWlnaHQgb2YgdGhlIHRvcCByb3cgKGMpXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQG1lbWJlcm9mIFBJWEkuTmluZVNsaWNlUGxhbmUjXG4gICAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuX3RvcEhlaWdodCA9IHR5cGVvZiB0b3BIZWlnaHQgIT09ICd1bmRlZmluZWQnID8gdG9wSGVpZ2h0IDogREVGQVVMVF9CT1JERVJfU0laRTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGhlaWdodCBvZiB0aGUgYm90dG9tIHJvdyAoZClcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAbWVtYmVyb2YgUElYSS5OaW5lU2xpY2VQbGFuZSNcbiAgICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5fYm90dG9tSGVpZ2h0ID0gdHlwZW9mIGJvdHRvbUhlaWdodCAhPT0gJ3VuZGVmaW5lZCcgPyBib3R0b21IZWlnaHQgOiBERUZBVUxUX0JPUkRFUl9TSVpFO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWNoZWQgdGludCB2YWx1ZSBzbyB3ZSBjYW4gdGVsbCB3aGVuIHRoZSB0aW50IGlzIGNoYW5nZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuX2NhY2hlZFRpbnQgPSAweEZGRkZGRjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FjaGVkIHRpbnRlZCB0ZXh0dXJlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtIVE1MQ2FudmFzRWxlbWVudH1cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuX3RpbnRlZFRleHR1cmUgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUZW1wb3Jhcnkgc3RvcmFnZSBmb3IgY2FudmFzIHNvdXJjZSBjb29yZHNcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyW119XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5fY2FudmFzVXZzID0gbnVsbDtcblxuICAgICAgICBfdGhpcy5yZWZyZXNoKHRydWUpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgaG9yaXpvbnRhbCB2ZXJ0aWNlcy5cbiAgICAgKlxuICAgICAqL1xuXG5cbiAgICBOaW5lU2xpY2VQbGFuZS5wcm90b3R5cGUudXBkYXRlSG9yaXpvbnRhbFZlcnRpY2VzID0gZnVuY3Rpb24gdXBkYXRlSG9yaXpvbnRhbFZlcnRpY2VzKCkge1xuICAgICAgICB2YXIgdmVydGljZXMgPSB0aGlzLnZlcnRpY2VzO1xuXG4gICAgICAgIHZhciBoID0gdGhpcy5fdG9wSGVpZ2h0ICsgdGhpcy5fYm90dG9tSGVpZ2h0O1xuICAgICAgICB2YXIgc2NhbGUgPSB0aGlzLl9oZWlnaHQgPiBoID8gMS4wIDogdGhpcy5faGVpZ2h0IC8gaDtcblxuICAgICAgICB2ZXJ0aWNlc1s5XSA9IHZlcnRpY2VzWzExXSA9IHZlcnRpY2VzWzEzXSA9IHZlcnRpY2VzWzE1XSA9IHRoaXMuX3RvcEhlaWdodCAqIHNjYWxlO1xuICAgICAgICB2ZXJ0aWNlc1sxN10gPSB2ZXJ0aWNlc1sxOV0gPSB2ZXJ0aWNlc1syMV0gPSB2ZXJ0aWNlc1syM10gPSB0aGlzLl9oZWlnaHQgLSB0aGlzLl9ib3R0b21IZWlnaHQgKiBzY2FsZTtcbiAgICAgICAgdmVydGljZXNbMjVdID0gdmVydGljZXNbMjddID0gdmVydGljZXNbMjldID0gdmVydGljZXNbMzFdID0gdGhpcy5faGVpZ2h0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSB2ZXJ0aWNhbCB2ZXJ0aWNlcy5cbiAgICAgKlxuICAgICAqL1xuXG5cbiAgICBOaW5lU2xpY2VQbGFuZS5wcm90b3R5cGUudXBkYXRlVmVydGljYWxWZXJ0aWNlcyA9IGZ1bmN0aW9uIHVwZGF0ZVZlcnRpY2FsVmVydGljZXMoKSB7XG4gICAgICAgIHZhciB2ZXJ0aWNlcyA9IHRoaXMudmVydGljZXM7XG5cbiAgICAgICAgdmFyIHcgPSB0aGlzLl9sZWZ0V2lkdGggKyB0aGlzLl9yaWdodFdpZHRoO1xuICAgICAgICB2YXIgc2NhbGUgPSB0aGlzLl93aWR0aCA+IHcgPyAxLjAgOiB0aGlzLl93aWR0aCAvIHc7XG5cbiAgICAgICAgdmVydGljZXNbMl0gPSB2ZXJ0aWNlc1sxMF0gPSB2ZXJ0aWNlc1sxOF0gPSB2ZXJ0aWNlc1syNl0gPSB0aGlzLl9sZWZ0V2lkdGggKiBzY2FsZTtcbiAgICAgICAgdmVydGljZXNbNF0gPSB2ZXJ0aWNlc1sxMl0gPSB2ZXJ0aWNlc1syMF0gPSB2ZXJ0aWNlc1syOF0gPSB0aGlzLl93aWR0aCAtIHRoaXMuX3JpZ2h0V2lkdGggKiBzY2FsZTtcbiAgICAgICAgdmVydGljZXNbNl0gPSB2ZXJ0aWNlc1sxNF0gPSB2ZXJ0aWNlc1syMl0gPSB2ZXJ0aWNlc1szMF0gPSB0aGlzLl93aWR0aDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0aGUgb2JqZWN0IHVzaW5nIHRoZSBDYW52YXMgcmVuZGVyZXJcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtQSVhJLkNhbnZhc1JlbmRlcmVyfSByZW5kZXJlciAtIFRoZSBjYW52YXMgcmVuZGVyZXIgdG8gcmVuZGVyIHdpdGguXG4gICAgICovXG5cblxuICAgIE5pbmVTbGljZVBsYW5lLnByb3RvdHlwZS5fcmVuZGVyQ2FudmFzID0gZnVuY3Rpb24gX3JlbmRlckNhbnZhcyhyZW5kZXJlcikge1xuICAgICAgICB2YXIgY29udGV4dCA9IHJlbmRlcmVyLmNvbnRleHQ7XG4gICAgICAgIHZhciB0cmFuc2Zvcm0gPSB0aGlzLndvcmxkVHJhbnNmb3JtO1xuICAgICAgICB2YXIgcmVzID0gcmVuZGVyZXIucmVzb2x1dGlvbjtcbiAgICAgICAgdmFyIGlzVGludGVkID0gdGhpcy50aW50ICE9PSAweEZGRkZGRjtcbiAgICAgICAgdmFyIHRleHR1cmUgPSB0aGlzLl90ZXh0dXJlO1xuXG4gICAgICAgIC8vIFdvcmsgb3V0IHRpbnRpbmdcbiAgICAgICAgaWYgKGlzVGludGVkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fY2FjaGVkVGludCAhPT0gdGhpcy50aW50KSB7XG4gICAgICAgICAgICAgICAgLy8gVGludCBoYXMgY2hhbmdlZCwgbmVlZCB0byB1cGRhdGUgdGhlIHRpbnRlZCB0ZXh0dXJlIGFuZCB1c2UgdGhhdCBpbnN0ZWFkXG5cbiAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZWRUaW50ID0gdGhpcy50aW50O1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fdGludGVkVGV4dHVyZSA9IF9DYW52YXNUaW50ZXIyLmRlZmF1bHQuZ2V0VGludGVkVGV4dHVyZSh0aGlzLCB0aGlzLnRpbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRleHR1cmVTb3VyY2UgPSAhaXNUaW50ZWQgPyB0ZXh0dXJlLmJhc2VUZXh0dXJlLnNvdXJjZSA6IHRoaXMuX3RpbnRlZFRleHR1cmU7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9jYW52YXNVdnMpIHtcbiAgICAgICAgICAgIHRoaXMuX2NhbnZhc1V2cyA9IFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB2ZXJ0aWNlcyA9IHRoaXMudmVydGljZXM7XG4gICAgICAgIHZhciB1dnMgPSB0aGlzLl9jYW52YXNVdnM7XG4gICAgICAgIHZhciB1MCA9IGlzVGludGVkID8gMCA6IHRleHR1cmUuZnJhbWUueDtcbiAgICAgICAgdmFyIHYwID0gaXNUaW50ZWQgPyAwIDogdGV4dHVyZS5mcmFtZS55O1xuICAgICAgICB2YXIgdTEgPSB1MCArIHRleHR1cmUuZnJhbWUud2lkdGg7XG4gICAgICAgIHZhciB2MSA9IHYwICsgdGV4dHVyZS5mcmFtZS5oZWlnaHQ7XG5cbiAgICAgICAgdXZzWzBdID0gdTA7XG4gICAgICAgIHV2c1sxXSA9IHUwICsgdGhpcy5fbGVmdFdpZHRoO1xuICAgICAgICB1dnNbMl0gPSB1MSAtIHRoaXMuX3JpZ2h0V2lkdGg7XG4gICAgICAgIHV2c1szXSA9IHUxO1xuICAgICAgICB1dnNbNF0gPSB2MDtcbiAgICAgICAgdXZzWzVdID0gdjAgKyB0aGlzLl90b3BIZWlnaHQ7XG4gICAgICAgIHV2c1s2XSA9IHYxIC0gdGhpcy5fYm90dG9tSGVpZ2h0O1xuICAgICAgICB1dnNbN10gPSB2MTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDg7IGkrKykge1xuICAgICAgICAgICAgdXZzW2ldICo9IHRleHR1cmUuYmFzZVRleHR1cmUucmVzb2x1dGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQuZ2xvYmFsQWxwaGEgPSB0aGlzLndvcmxkQWxwaGE7XG4gICAgICAgIHJlbmRlcmVyLnNldEJsZW5kTW9kZSh0aGlzLmJsZW5kTW9kZSk7XG5cbiAgICAgICAgaWYgKHJlbmRlcmVyLnJvdW5kUGl4ZWxzKSB7XG4gICAgICAgICAgICBjb250ZXh0LnNldFRyYW5zZm9ybSh0cmFuc2Zvcm0uYSAqIHJlcywgdHJhbnNmb3JtLmIgKiByZXMsIHRyYW5zZm9ybS5jICogcmVzLCB0cmFuc2Zvcm0uZCAqIHJlcywgdHJhbnNmb3JtLnR4ICogcmVzIHwgMCwgdHJhbnNmb3JtLnR5ICogcmVzIHwgMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250ZXh0LnNldFRyYW5zZm9ybSh0cmFuc2Zvcm0uYSAqIHJlcywgdHJhbnNmb3JtLmIgKiByZXMsIHRyYW5zZm9ybS5jICogcmVzLCB0cmFuc2Zvcm0uZCAqIHJlcywgdHJhbnNmb3JtLnR4ICogcmVzLCB0cmFuc2Zvcm0udHkgKiByZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgcm93ID0gMDsgcm93IDwgMzsgcm93KyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGNvbCA9IDA7IGNvbCA8IDM7IGNvbCsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluZCA9IGNvbCAqIDIgKyByb3cgKiA4O1xuICAgICAgICAgICAgICAgIHZhciBzdyA9IE1hdGgubWF4KDEsIHV2c1tjb2wgKyAxXSAtIHV2c1tjb2xdKTtcbiAgICAgICAgICAgICAgICB2YXIgc2ggPSBNYXRoLm1heCgxLCB1dnNbcm93ICsgNV0gLSB1dnNbcm93ICsgNF0pO1xuICAgICAgICAgICAgICAgIHZhciBkdyA9IE1hdGgubWF4KDEsIHZlcnRpY2VzW2luZCArIDEwXSAtIHZlcnRpY2VzW2luZF0pO1xuICAgICAgICAgICAgICAgIHZhciBkaCA9IE1hdGgubWF4KDEsIHZlcnRpY2VzW2luZCArIDExXSAtIHZlcnRpY2VzW2luZCArIDFdKTtcblxuICAgICAgICAgICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKHRleHR1cmVTb3VyY2UsIHV2c1tjb2xdLCB1dnNbcm93ICsgNF0sIHN3LCBzaCwgdmVydGljZXNbaW5kXSwgdmVydGljZXNbaW5kICsgMV0sIGR3LCBkaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIHdpZHRoIG9mIHRoZSBOaW5lU2xpY2VQbGFuZSwgc2V0dGluZyB0aGlzIHdpbGwgYWN0dWFsbHkgbW9kaWZ5IHRoZSB2ZXJ0aWNlcyBhbmQgVVYncyBvZiB0aGlzIHBsYW5lXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICovXG5cblxuICAgIC8qKlxuICAgICAqIFJlZnJlc2hlcyBOaW5lU2xpY2VQbGFuZSBjb29yZHMuIEFsbCBvZiB0aGVtLlxuICAgICAqL1xuICAgIE5pbmVTbGljZVBsYW5lLnByb3RvdHlwZS5fcmVmcmVzaCA9IGZ1bmN0aW9uIF9yZWZyZXNoKCkge1xuICAgICAgICBfUGxhbmUucHJvdG90eXBlLl9yZWZyZXNoLmNhbGwodGhpcyk7XG5cbiAgICAgICAgdmFyIHV2cyA9IHRoaXMudXZzO1xuICAgICAgICB2YXIgdGV4dHVyZSA9IHRoaXMuX3RleHR1cmU7XG5cbiAgICAgICAgdGhpcy5fb3JpZ1dpZHRoID0gdGV4dHVyZS5vcmlnLndpZHRoO1xuICAgICAgICB0aGlzLl9vcmlnSGVpZ2h0ID0gdGV4dHVyZS5vcmlnLmhlaWdodDtcblxuICAgICAgICB2YXIgX3V2dyA9IDEuMCAvIHRoaXMuX29yaWdXaWR0aDtcbiAgICAgICAgdmFyIF91dmggPSAxLjAgLyB0aGlzLl9vcmlnSGVpZ2h0O1xuXG4gICAgICAgIHV2c1swXSA9IHV2c1s4XSA9IHV2c1sxNl0gPSB1dnNbMjRdID0gMDtcbiAgICAgICAgdXZzWzFdID0gdXZzWzNdID0gdXZzWzVdID0gdXZzWzddID0gMDtcbiAgICAgICAgdXZzWzZdID0gdXZzWzE0XSA9IHV2c1syMl0gPSB1dnNbMzBdID0gMTtcbiAgICAgICAgdXZzWzI1XSA9IHV2c1syN10gPSB1dnNbMjldID0gdXZzWzMxXSA9IDE7XG5cbiAgICAgICAgdXZzWzJdID0gdXZzWzEwXSA9IHV2c1sxOF0gPSB1dnNbMjZdID0gX3V2dyAqIHRoaXMuX2xlZnRXaWR0aDtcbiAgICAgICAgdXZzWzRdID0gdXZzWzEyXSA9IHV2c1syMF0gPSB1dnNbMjhdID0gMSAtIF91dncgKiB0aGlzLl9yaWdodFdpZHRoO1xuICAgICAgICB1dnNbOV0gPSB1dnNbMTFdID0gdXZzWzEzXSA9IHV2c1sxNV0gPSBfdXZoICogdGhpcy5fdG9wSGVpZ2h0O1xuICAgICAgICB1dnNbMTddID0gdXZzWzE5XSA9IHV2c1syMV0gPSB1dnNbMjNdID0gMSAtIF91dmggKiB0aGlzLl9ib3R0b21IZWlnaHQ7XG5cbiAgICAgICAgdGhpcy51cGRhdGVIb3Jpem9udGFsVmVydGljZXMoKTtcbiAgICAgICAgdGhpcy51cGRhdGVWZXJ0aWNhbFZlcnRpY2VzKCk7XG5cbiAgICAgICAgdGhpcy5kaXJ0eSsrO1xuXG4gICAgICAgIHRoaXMubXVsdGlwbHlVdnMoKTtcbiAgICB9O1xuXG4gICAgX2NyZWF0ZUNsYXNzKE5pbmVTbGljZVBsYW5lLCBbe1xuICAgICAgICBrZXk6ICd3aWR0aCcsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dpZHRoO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSByZXF1aXJlLWpzZG9jXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX3dpZHRoID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLl9yZWZyZXNoKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGhlaWdodCBvZiB0aGUgTmluZVNsaWNlUGxhbmUsIHNldHRpbmcgdGhpcyB3aWxsIGFjdHVhbGx5IG1vZGlmeSB0aGUgdmVydGljZXMgYW5kIFVWJ3Mgb2YgdGhpcyBwbGFuZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdoZWlnaHQnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9oZWlnaHQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlcXVpcmUtanNkb2NcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5faGVpZ2h0ID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLl9yZWZyZXNoKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHdpZHRoIG9mIHRoZSBsZWZ0IGNvbHVtblxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdsZWZ0V2lkdGgnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sZWZ0V2lkdGg7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlcXVpcmUtanNkb2NcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fbGVmdFdpZHRoID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLl9yZWZyZXNoKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHdpZHRoIG9mIHRoZSByaWdodCBjb2x1bW5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAncmlnaHRXaWR0aCcsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JpZ2h0V2lkdGg7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlcXVpcmUtanNkb2NcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fcmlnaHRXaWR0aCA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5fcmVmcmVzaCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBoZWlnaHQgb2YgdGhlIHRvcCByb3dcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndG9wSGVpZ2h0JyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdG9wSGVpZ2h0O1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSByZXF1aXJlLWpzZG9jXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX3RvcEhlaWdodCA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5fcmVmcmVzaCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBoZWlnaHQgb2YgdGhlIGJvdHRvbSByb3dcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnYm90dG9tSGVpZ2h0JyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYm90dG9tSGVpZ2h0O1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSByZXF1aXJlLWpzZG9jXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX2JvdHRvbUhlaWdodCA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5fcmVmcmVzaCgpO1xuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIE5pbmVTbGljZVBsYW5lO1xufShfUGxhbmUzLmRlZmF1bHQpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBOaW5lU2xpY2VQbGFuZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU5pbmVTbGljZVBsYW5lLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9NZXNoMiA9IHJlcXVpcmUoJy4vTWVzaCcpO1xuXG52YXIgX01lc2gzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWVzaDIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbi8qKlxuICogVGhlIFBsYW5lIGFsbG93cyB5b3UgdG8gZHJhdyBhIHRleHR1cmUgYWNyb3NzIHNldmVyYWwgcG9pbnRzIGFuZCB0aGVtIG1hbmlwdWxhdGUgdGhlc2UgcG9pbnRzXG4gKlxuICpgYGBqc1xuICogZm9yIChsZXQgaSA9IDA7IGkgPCAyMDsgaSsrKSB7XG4gKiAgICAgcG9pbnRzLnB1c2gobmV3IFBJWEkuUG9pbnQoaSAqIDUwLCAwKSk7XG4gKiB9O1xuICogbGV0IFBsYW5lID0gbmV3IFBJWEkuUGxhbmUoUElYSS5UZXh0dXJlLmZyb21JbWFnZShcInNuYWtlLnBuZ1wiKSwgcG9pbnRzKTtcbiAqICBgYGBcbiAqXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIFBJWEkubWVzaC5NZXNoXG4gKiBAbWVtYmVyb2YgUElYSS5tZXNoXG4gKlxuICovXG52YXIgUGxhbmUgPSBmdW5jdGlvbiAoX01lc2gpIHtcbiAgICBfaW5oZXJpdHMoUGxhbmUsIF9NZXNoKTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7UElYSS5UZXh0dXJlfSB0ZXh0dXJlIC0gVGhlIHRleHR1cmUgdG8gdXNlIG9uIHRoZSBQbGFuZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ZlcnRpY2VzWD0xMF0gLSBUaGUgbnVtYmVyIG9mIHZlcnRpY2VzIGluIHRoZSB4LWF4aXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ZlcnRpY2VzWT0xMF0gLSBUaGUgbnVtYmVyIG9mIHZlcnRpY2VzIGluIHRoZSB5LWF4aXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBQbGFuZSh0ZXh0dXJlLCB2ZXJ0aWNlc1gsIHZlcnRpY2VzWSkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUGxhbmUpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcmFja2VyIGZvciBpZiB0aGUgUGxhbmUgaXMgcmVhZHkgdG8gYmUgZHJhd24uIE5lZWRlZCBiZWNhdXNlIE1lc2ggY3RvciBjYW5cbiAgICAgICAgICogY2FsbCBfb25UZXh0dXJlVXBkYXRlZCB3aGljaCBjb3VsZCBjYWxsIHJlZnJlc2ggdG9vIGVhcmx5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX01lc2guY2FsbCh0aGlzLCB0ZXh0dXJlKSk7XG5cbiAgICAgICAgX3RoaXMuX3JlYWR5ID0gdHJ1ZTtcblxuICAgICAgICBfdGhpcy52ZXJ0aWNlc1ggPSB2ZXJ0aWNlc1ggfHwgMTA7XG4gICAgICAgIF90aGlzLnZlcnRpY2VzWSA9IHZlcnRpY2VzWSB8fCAxMDtcblxuICAgICAgICBfdGhpcy5kcmF3TW9kZSA9IF9NZXNoMy5kZWZhdWx0LkRSQVdfTU9ERVMuVFJJQU5HTEVTO1xuICAgICAgICBfdGhpcy5yZWZyZXNoKCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWZyZXNoZXMgcGxhbmUgY29vcmRpbmF0ZXNcbiAgICAgKlxuICAgICAqL1xuXG5cbiAgICBQbGFuZS5wcm90b3R5cGUuX3JlZnJlc2ggPSBmdW5jdGlvbiBfcmVmcmVzaCgpIHtcbiAgICAgICAgdmFyIHRleHR1cmUgPSB0aGlzLl90ZXh0dXJlO1xuICAgICAgICB2YXIgdG90YWwgPSB0aGlzLnZlcnRpY2VzWCAqIHRoaXMudmVydGljZXNZO1xuICAgICAgICB2YXIgdmVydHMgPSBbXTtcbiAgICAgICAgdmFyIGNvbG9ycyA9IFtdO1xuICAgICAgICB2YXIgdXZzID0gW107XG4gICAgICAgIHZhciBpbmRpY2VzID0gW107XG5cbiAgICAgICAgdmFyIHNlZ21lbnRzWCA9IHRoaXMudmVydGljZXNYIC0gMTtcbiAgICAgICAgdmFyIHNlZ21lbnRzWSA9IHRoaXMudmVydGljZXNZIC0gMTtcblxuICAgICAgICB2YXIgc2l6ZVggPSB0ZXh0dXJlLndpZHRoIC8gc2VnbWVudHNYO1xuICAgICAgICB2YXIgc2l6ZVkgPSB0ZXh0dXJlLmhlaWdodCAvIHNlZ21lbnRzWTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvdGFsOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB4ID0gaSAlIHRoaXMudmVydGljZXNYO1xuICAgICAgICAgICAgdmFyIHkgPSBpIC8gdGhpcy52ZXJ0aWNlc1ggfCAwO1xuXG4gICAgICAgICAgICB2ZXJ0cy5wdXNoKHggKiBzaXplWCwgeSAqIHNpemVZKTtcblxuICAgICAgICAgICAgdXZzLnB1c2goeCAvIHNlZ21lbnRzWCwgeSAvIHNlZ21lbnRzWSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAgY29uc1xuXG4gICAgICAgIHZhciB0b3RhbFN1YiA9IHNlZ21lbnRzWCAqIHNlZ21lbnRzWTtcblxuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgdG90YWxTdWI7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciB4cG9zID0gX2kgJSBzZWdtZW50c1g7XG4gICAgICAgICAgICB2YXIgeXBvcyA9IF9pIC8gc2VnbWVudHNYIHwgMDtcblxuICAgICAgICAgICAgdmFyIHZhbHVlID0geXBvcyAqIHRoaXMudmVydGljZXNYICsgeHBvcztcbiAgICAgICAgICAgIHZhciB2YWx1ZTIgPSB5cG9zICogdGhpcy52ZXJ0aWNlc1ggKyB4cG9zICsgMTtcbiAgICAgICAgICAgIHZhciB2YWx1ZTMgPSAoeXBvcyArIDEpICogdGhpcy52ZXJ0aWNlc1ggKyB4cG9zO1xuICAgICAgICAgICAgdmFyIHZhbHVlNCA9ICh5cG9zICsgMSkgKiB0aGlzLnZlcnRpY2VzWCArIHhwb3MgKyAxO1xuXG4gICAgICAgICAgICBpbmRpY2VzLnB1c2godmFsdWUsIHZhbHVlMiwgdmFsdWUzKTtcbiAgICAgICAgICAgIGluZGljZXMucHVzaCh2YWx1ZTIsIHZhbHVlNCwgdmFsdWUzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGluZGljZXMpXG4gICAgICAgIHRoaXMudmVydGljZXMgPSBuZXcgRmxvYXQzMkFycmF5KHZlcnRzKTtcbiAgICAgICAgdGhpcy51dnMgPSBuZXcgRmxvYXQzMkFycmF5KHV2cyk7XG4gICAgICAgIHRoaXMuY29sb3JzID0gbmV3IEZsb2F0MzJBcnJheShjb2xvcnMpO1xuICAgICAgICB0aGlzLmluZGljZXMgPSBuZXcgVWludDE2QXJyYXkoaW5kaWNlcyk7XG5cbiAgICAgICAgdGhpcy5kaXJ0eSsrO1xuICAgICAgICB0aGlzLmluZGV4RGlydHkrKztcblxuICAgICAgICB0aGlzLm11bHRpcGx5VXZzKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENsZWFyIHRleHR1cmUgVVZzIHdoZW4gbmV3IHRleHR1cmUgaXMgc2V0XG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG5cbiAgICBQbGFuZS5wcm90b3R5cGUuX29uVGV4dHVyZVVwZGF0ZSA9IGZ1bmN0aW9uIF9vblRleHR1cmVVcGRhdGUoKSB7XG4gICAgICAgIF9NZXNoMy5kZWZhdWx0LnByb3RvdHlwZS5fb25UZXh0dXJlVXBkYXRlLmNhbGwodGhpcyk7XG5cbiAgICAgICAgLy8gd2FpdCBmb3IgdGhlIFBsYW5lIGN0b3IgdG8gZmluaXNoIGJlZm9yZSBjYWxsaW5nIHJlZnJlc2hcbiAgICAgICAgaWYgKHRoaXMuX3JlYWR5KSB7XG4gICAgICAgICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gUGxhbmU7XG59KF9NZXNoMy5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gUGxhbmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1QbGFuZS5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfTWVzaDIgPSByZXF1aXJlKCcuL01lc2gnKTtcblxudmFyIF9NZXNoMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01lc2gyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4vKipcbiAqIFRoZSByb3BlIGFsbG93cyB5b3UgdG8gZHJhdyBhIHRleHR1cmUgYWNyb3NzIHNldmVyYWwgcG9pbnRzIGFuZCB0aGVtIG1hbmlwdWxhdGUgdGhlc2UgcG9pbnRzXG4gKlxuICpgYGBqc1xuICogZm9yIChsZXQgaSA9IDA7IGkgPCAyMDsgaSsrKSB7XG4gKiAgICAgcG9pbnRzLnB1c2gobmV3IFBJWEkuUG9pbnQoaSAqIDUwLCAwKSk7XG4gKiB9O1xuICogbGV0IHJvcGUgPSBuZXcgUElYSS5Sb3BlKFBJWEkuVGV4dHVyZS5mcm9tSW1hZ2UoXCJzbmFrZS5wbmdcIiksIHBvaW50cyk7XG4gKiAgYGBgXG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQSVhJLm1lc2guTWVzaFxuICogQG1lbWJlcm9mIFBJWEkubWVzaFxuICpcbiAqL1xudmFyIFJvcGUgPSBmdW5jdGlvbiAoX01lc2gpIHtcbiAgICBfaW5oZXJpdHMoUm9wZSwgX01lc2gpO1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtQSVhJLlRleHR1cmV9IHRleHR1cmUgLSBUaGUgdGV4dHVyZSB0byB1c2Ugb24gdGhlIHJvcGUuXG4gICAgICogQHBhcmFtIHtQSVhJLlBvaW50W119IHBvaW50cyAtIEFuIGFycmF5IG9mIHtAbGluayBQSVhJLlBvaW50fSBvYmplY3RzIHRvIGNvbnN0cnVjdCB0aGlzIHJvcGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gUm9wZSh0ZXh0dXJlLCBwb2ludHMpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJvcGUpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBhcnJheSBvZiBwb2ludHMgdGhhdCBkZXRlcm1pbmUgdGhlIHJvcGVcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5Qb2ludFtdfVxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX01lc2guY2FsbCh0aGlzLCB0ZXh0dXJlKSk7XG5cbiAgICAgICAgX3RoaXMucG9pbnRzID0gcG9pbnRzO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBhcnJheSBvZiB2ZXJ0aWNlcyB1c2VkIHRvIGNvbnN0cnVjdCB0aGlzIHJvcGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge0Zsb2F0MzJBcnJheX1cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLnZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheShwb2ludHMubGVuZ3RoICogNCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBXZWJHTCBVdnMgb2YgdGhlIHJvcGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge0Zsb2F0MzJBcnJheX1cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLnV2cyA9IG5ldyBGbG9hdDMyQXJyYXkocG9pbnRzLmxlbmd0aCAqIDQpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBhcnJheSBjb250YWluaW5nIHRoZSBjb2xvciBjb21wb25lbnRzXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge0Zsb2F0MzJBcnJheX1cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLmNvbG9ycyA9IG5ldyBGbG9hdDMyQXJyYXkocG9pbnRzLmxlbmd0aCAqIDIpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBhcnJheSBjb250YWluaW5nIHRoZSBpbmRpY2VzIG9mIHRoZSB2ZXJ0aWNlc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtVaW50MTZBcnJheX1cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLmluZGljZXMgPSBuZXcgVWludDE2QXJyYXkocG9pbnRzLmxlbmd0aCAqIDIpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiByZWZyZXNoZXMgdmVydGljZXMgb24gZXZlcnkgdXBkYXRlVHJhbnNmb3JtXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLmF1dG9VcGRhdGUgPSB0cnVlO1xuXG4gICAgICAgIF90aGlzLnJlZnJlc2goKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlZnJlc2hlc1xuICAgICAqXG4gICAgICovXG5cblxuICAgIFJvcGUucHJvdG90eXBlLl9yZWZyZXNoID0gZnVuY3Rpb24gX3JlZnJlc2goKSB7XG4gICAgICAgIHZhciBwb2ludHMgPSB0aGlzLnBvaW50cztcblxuICAgICAgICAvLyBpZiB0b28gbGl0dGxlIHBvaW50cywgb3IgdGV4dHVyZSBoYXNuJ3QgZ290IFVWcyBzZXQgeWV0IGp1c3QgbW92ZSBvbi5cbiAgICAgICAgaWYgKHBvaW50cy5sZW5ndGggPCAxIHx8ICF0aGlzLl90ZXh0dXJlLl91dnMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHRoZSBudW1iZXIgb2YgcG9pbnRzIGhhcyBjaGFuZ2VkIHdlIHdpbGwgbmVlZCB0byByZWNyZWF0ZSB0aGUgYXJyYXlidWZmZXJzXG4gICAgICAgIGlmICh0aGlzLnZlcnRpY2VzLmxlbmd0aCAvIDQgIT09IHBvaW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMudmVydGljZXMgPSBuZXcgRmxvYXQzMkFycmF5KHBvaW50cy5sZW5ndGggKiA0KTtcbiAgICAgICAgICAgIHRoaXMudXZzID0gbmV3IEZsb2F0MzJBcnJheShwb2ludHMubGVuZ3RoICogNCk7XG4gICAgICAgICAgICB0aGlzLmNvbG9ycyA9IG5ldyBGbG9hdDMyQXJyYXkocG9pbnRzLmxlbmd0aCAqIDIpO1xuICAgICAgICAgICAgdGhpcy5pbmRpY2VzID0gbmV3IFVpbnQxNkFycmF5KHBvaW50cy5sZW5ndGggKiAyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB1dnMgPSB0aGlzLnV2cztcblxuICAgICAgICB2YXIgaW5kaWNlcyA9IHRoaXMuaW5kaWNlcztcbiAgICAgICAgdmFyIGNvbG9ycyA9IHRoaXMuY29sb3JzO1xuXG4gICAgICAgIHV2c1swXSA9IDA7XG4gICAgICAgIHV2c1sxXSA9IDA7XG4gICAgICAgIHV2c1syXSA9IDA7XG4gICAgICAgIHV2c1szXSA9IDE7XG5cbiAgICAgICAgY29sb3JzWzBdID0gMTtcbiAgICAgICAgY29sb3JzWzFdID0gMTtcblxuICAgICAgICBpbmRpY2VzWzBdID0gMDtcbiAgICAgICAgaW5kaWNlc1sxXSA9IDE7XG5cbiAgICAgICAgdmFyIHRvdGFsID0gcG9pbnRzLmxlbmd0aDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHRvdGFsOyBpKyspIHtcbiAgICAgICAgICAgIC8vIHRpbWUgdG8gZG8gc29tZSBzbWFydCBkcmF3aW5nIVxuICAgICAgICAgICAgdmFyIGluZGV4ID0gaSAqIDQ7XG4gICAgICAgICAgICB2YXIgYW1vdW50ID0gaSAvICh0b3RhbCAtIDEpO1xuXG4gICAgICAgICAgICB1dnNbaW5kZXhdID0gYW1vdW50O1xuICAgICAgICAgICAgdXZzW2luZGV4ICsgMV0gPSAwO1xuXG4gICAgICAgICAgICB1dnNbaW5kZXggKyAyXSA9IGFtb3VudDtcbiAgICAgICAgICAgIHV2c1tpbmRleCArIDNdID0gMTtcblxuICAgICAgICAgICAgaW5kZXggPSBpICogMjtcbiAgICAgICAgICAgIGNvbG9yc1tpbmRleF0gPSAxO1xuICAgICAgICAgICAgY29sb3JzW2luZGV4ICsgMV0gPSAxO1xuXG4gICAgICAgICAgICBpbmRleCA9IGkgKiAyO1xuICAgICAgICAgICAgaW5kaWNlc1tpbmRleF0gPSBpbmRleDtcbiAgICAgICAgICAgIGluZGljZXNbaW5kZXggKyAxXSA9IGluZGV4ICsgMTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGVuc3VyZSB0aGF0IHRoZSBjaGFuZ2VzIGFyZSB1cGxvYWRlZFxuICAgICAgICB0aGlzLmRpcnR5Kys7XG4gICAgICAgIHRoaXMuaW5kZXhEaXJ0eSsrO1xuXG4gICAgICAgIHRoaXMubXVsdGlwbHlVdnMoKTtcbiAgICAgICAgdGhpcy5yZWZyZXNoVmVydGljZXMoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogcmVmcmVzaGVzIHZlcnRpY2VzIG9mIFJvcGUgbWVzaFxuICAgICAqL1xuXG5cbiAgICBSb3BlLnByb3RvdHlwZS5yZWZyZXNoVmVydGljZXMgPSBmdW5jdGlvbiByZWZyZXNoVmVydGljZXMoKSB7XG4gICAgICAgIHZhciBwb2ludHMgPSB0aGlzLnBvaW50cztcblxuICAgICAgICBpZiAocG9pbnRzLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsYXN0UG9pbnQgPSBwb2ludHNbMF07XG4gICAgICAgIHZhciBuZXh0UG9pbnQgPSB2b2lkIDA7XG4gICAgICAgIHZhciBwZXJwWCA9IDA7XG4gICAgICAgIHZhciBwZXJwWSA9IDA7XG5cbiAgICAgICAgLy8gdGhpcy5jb3VudCAtPSAwLjI7XG5cbiAgICAgICAgdmFyIHZlcnRpY2VzID0gdGhpcy52ZXJ0aWNlcztcbiAgICAgICAgdmFyIHRvdGFsID0gcG9pbnRzLmxlbmd0aDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvdGFsOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwb2ludCA9IHBvaW50c1tpXTtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IGkgKiA0O1xuXG4gICAgICAgICAgICBpZiAoaSA8IHBvaW50cy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgbmV4dFBvaW50ID0gcG9pbnRzW2kgKyAxXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV4dFBvaW50ID0gcG9pbnQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBlcnBZID0gLShuZXh0UG9pbnQueCAtIGxhc3RQb2ludC54KTtcbiAgICAgICAgICAgIHBlcnBYID0gbmV4dFBvaW50LnkgLSBsYXN0UG9pbnQueTtcblxuICAgICAgICAgICAgdmFyIHJhdGlvID0gKDEgLSBpIC8gKHRvdGFsIC0gMSkpICogMTA7XG5cbiAgICAgICAgICAgIGlmIChyYXRpbyA+IDEpIHtcbiAgICAgICAgICAgICAgICByYXRpbyA9IDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBwZXJwTGVuZ3RoID0gTWF0aC5zcXJ0KHBlcnBYICogcGVycFggKyBwZXJwWSAqIHBlcnBZKTtcbiAgICAgICAgICAgIHZhciBudW0gPSB0aGlzLl90ZXh0dXJlLmhlaWdodCAvIDI7IC8vICgyMCArIE1hdGguYWJzKE1hdGguc2luKChpICsgdGhpcy5jb3VudCkgKiAwLjMpICogNTApICkqIHJhdGlvO1xuXG4gICAgICAgICAgICBwZXJwWCAvPSBwZXJwTGVuZ3RoO1xuICAgICAgICAgICAgcGVycFkgLz0gcGVycExlbmd0aDtcblxuICAgICAgICAgICAgcGVycFggKj0gbnVtO1xuICAgICAgICAgICAgcGVycFkgKj0gbnVtO1xuXG4gICAgICAgICAgICB2ZXJ0aWNlc1tpbmRleF0gPSBwb2ludC54ICsgcGVycFg7XG4gICAgICAgICAgICB2ZXJ0aWNlc1tpbmRleCArIDFdID0gcG9pbnQueSArIHBlcnBZO1xuICAgICAgICAgICAgdmVydGljZXNbaW5kZXggKyAyXSA9IHBvaW50LnggLSBwZXJwWDtcbiAgICAgICAgICAgIHZlcnRpY2VzW2luZGV4ICsgM10gPSBwb2ludC55IC0gcGVycFk7XG5cbiAgICAgICAgICAgIGxhc3RQb2ludCA9IHBvaW50O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIG9iamVjdCB0cmFuc2Zvcm0gZm9yIHJlbmRlcmluZ1xuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuXG4gICAgUm9wZS5wcm90b3R5cGUudXBkYXRlVHJhbnNmb3JtID0gZnVuY3Rpb24gdXBkYXRlVHJhbnNmb3JtKCkge1xuICAgICAgICBpZiAodGhpcy5hdXRvVXBkYXRlKSB7XG4gICAgICAgICAgICB0aGlzLnJlZnJlc2hWZXJ0aWNlcygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29udGFpbmVyVXBkYXRlVHJhbnNmb3JtKCk7XG4gICAgfTtcblxuICAgIHJldHVybiBSb3BlO1xufShfTWVzaDMuZGVmYXVsdCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFJvcGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Sb3BlLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9jb3JlID0gcmVxdWlyZSgnLi4vLi4vY29yZScpO1xuXG52YXIgY29yZSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9jb3JlKTtcblxudmFyIF9NZXNoID0gcmVxdWlyZSgnLi4vTWVzaCcpO1xuXG52YXIgX01lc2gyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWVzaCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8qKlxuICogUmVuZGVyZXIgZGVkaWNhdGVkIHRvIG1lc2hlcy5cbiAqXG4gKiBAY2xhc3NcbiAqIEBwcml2YXRlXG4gKiBAbWVtYmVyb2YgUElYSVxuICovXG52YXIgTWVzaFNwcml0ZVJlbmRlcmVyID0gZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7UElYSS5DYW52YXNSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIgdGhpcyBkb3ducG9ydCB3b3JrcyBmb3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNZXNoU3ByaXRlUmVuZGVyZXIocmVuZGVyZXIpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1lc2hTcHJpdGVSZW5kZXJlcik7XG5cbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgdGhlIE1lc2hcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5tZXNoLk1lc2h9IG1lc2ggLSB0aGUgTWVzaCB0byByZW5kZXJcbiAgICAgKi9cblxuXG4gICAgTWVzaFNwcml0ZVJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIobWVzaCkge1xuICAgICAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyO1xuICAgICAgICB2YXIgY29udGV4dCA9IHJlbmRlcmVyLmNvbnRleHQ7XG5cbiAgICAgICAgdmFyIHRyYW5zZm9ybSA9IG1lc2gud29ybGRUcmFuc2Zvcm07XG4gICAgICAgIHZhciByZXMgPSByZW5kZXJlci5yZXNvbHV0aW9uO1xuXG4gICAgICAgIGlmIChyZW5kZXJlci5yb3VuZFBpeGVscykge1xuICAgICAgICAgICAgY29udGV4dC5zZXRUcmFuc2Zvcm0odHJhbnNmb3JtLmEgKiByZXMsIHRyYW5zZm9ybS5iICogcmVzLCB0cmFuc2Zvcm0uYyAqIHJlcywgdHJhbnNmb3JtLmQgKiByZXMsIHRyYW5zZm9ybS50eCAqIHJlcyB8IDAsIHRyYW5zZm9ybS50eSAqIHJlcyB8IDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29udGV4dC5zZXRUcmFuc2Zvcm0odHJhbnNmb3JtLmEgKiByZXMsIHRyYW5zZm9ybS5iICogcmVzLCB0cmFuc2Zvcm0uYyAqIHJlcywgdHJhbnNmb3JtLmQgKiByZXMsIHRyYW5zZm9ybS50eCAqIHJlcywgdHJhbnNmb3JtLnR5ICogcmVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlbmRlcmVyLmNvbnRleHQuZ2xvYmFsQWxwaGEgPSBtZXNoLndvcmxkQWxwaGE7XG4gICAgICAgIHJlbmRlcmVyLnNldEJsZW5kTW9kZShtZXNoLmJsZW5kTW9kZSk7XG5cbiAgICAgICAgaWYgKG1lc2guZHJhd01vZGUgPT09IF9NZXNoMi5kZWZhdWx0LkRSQVdfTU9ERVMuVFJJQU5HTEVfTUVTSCkge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyVHJpYW5nbGVNZXNoKG1lc2gpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyVHJpYW5nbGVzKG1lc2gpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERyYXdzIHRoZSBvYmplY3QgaW4gVHJpYW5nbGUgTWVzaCBtb2RlXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7UElYSS5tZXNoLk1lc2h9IG1lc2ggLSB0aGUgTWVzaCB0byByZW5kZXJcbiAgICAgKi9cblxuXG4gICAgTWVzaFNwcml0ZVJlbmRlcmVyLnByb3RvdHlwZS5fcmVuZGVyVHJpYW5nbGVNZXNoID0gZnVuY3Rpb24gX3JlbmRlclRyaWFuZ2xlTWVzaChtZXNoKSB7XG4gICAgICAgIC8vIGRyYXcgdHJpYW5nbGVzISFcbiAgICAgICAgdmFyIGxlbmd0aCA9IG1lc2gudmVydGljZXMubGVuZ3RoIC8gMjtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aCAtIDI7IGkrKykge1xuICAgICAgICAgICAgLy8gZHJhdyBzb21lIHRyaWFuZ2xlcyFcbiAgICAgICAgICAgIHZhciBpbmRleCA9IGkgKiAyO1xuXG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJEcmF3VHJpYW5nbGUobWVzaCwgaW5kZXgsIGluZGV4ICsgMiwgaW5kZXggKyA0KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEcmF3cyB0aGUgb2JqZWN0IGluIHRyaWFuZ2xlIG1vZGUgdXNpbmcgY2FudmFzXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7UElYSS5tZXNoLk1lc2h9IG1lc2ggLSB0aGUgY3VycmVudCBtZXNoXG4gICAgICovXG5cblxuICAgIE1lc2hTcHJpdGVSZW5kZXJlci5wcm90b3R5cGUuX3JlbmRlclRyaWFuZ2xlcyA9IGZ1bmN0aW9uIF9yZW5kZXJUcmlhbmdsZXMobWVzaCkge1xuICAgICAgICAvLyBkcmF3IHRyaWFuZ2xlcyEhXG4gICAgICAgIHZhciBpbmRpY2VzID0gbWVzaC5pbmRpY2VzO1xuICAgICAgICB2YXIgbGVuZ3RoID0gaW5kaWNlcy5sZW5ndGg7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMykge1xuICAgICAgICAgICAgLy8gZHJhdyBzb21lIHRyaWFuZ2xlcyFcbiAgICAgICAgICAgIHZhciBpbmRleDAgPSBpbmRpY2VzW2ldICogMjtcbiAgICAgICAgICAgIHZhciBpbmRleDEgPSBpbmRpY2VzW2kgKyAxXSAqIDI7XG4gICAgICAgICAgICB2YXIgaW5kZXgyID0gaW5kaWNlc1tpICsgMl0gKiAyO1xuXG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJEcmF3VHJpYW5nbGUobWVzaCwgaW5kZXgwLCBpbmRleDEsIGluZGV4Mik7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRHJhd3Mgb25lIG9mIHRoZSB0cmlhbmdsZXMgdGhhdCBmcm9tIHRoZSBNZXNoXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7UElYSS5tZXNoLk1lc2h9IG1lc2ggLSB0aGUgY3VycmVudCBtZXNoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4MCAtIHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgdmVydGV4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4MSAtIHRoZSBpbmRleCBvZiB0aGUgc2Vjb25kIHZlcnRleFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleDIgLSB0aGUgaW5kZXggb2YgdGhlIHRoaXJkIHZlcnRleFxuICAgICAqL1xuXG5cbiAgICBNZXNoU3ByaXRlUmVuZGVyZXIucHJvdG90eXBlLl9yZW5kZXJEcmF3VHJpYW5nbGUgPSBmdW5jdGlvbiBfcmVuZGVyRHJhd1RyaWFuZ2xlKG1lc2gsIGluZGV4MCwgaW5kZXgxLCBpbmRleDIpIHtcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLnJlbmRlcmVyLmNvbnRleHQ7XG4gICAgICAgIHZhciB1dnMgPSBtZXNoLnV2cztcbiAgICAgICAgdmFyIHZlcnRpY2VzID0gbWVzaC52ZXJ0aWNlcztcbiAgICAgICAgdmFyIHRleHR1cmUgPSBtZXNoLl90ZXh0dXJlO1xuXG4gICAgICAgIGlmICghdGV4dHVyZS52YWxpZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGJhc2UgPSB0ZXh0dXJlLmJhc2VUZXh0dXJlO1xuICAgICAgICB2YXIgdGV4dHVyZVNvdXJjZSA9IGJhc2Uuc291cmNlO1xuICAgICAgICB2YXIgdGV4dHVyZVdpZHRoID0gYmFzZS53aWR0aDtcbiAgICAgICAgdmFyIHRleHR1cmVIZWlnaHQgPSBiYXNlLmhlaWdodDtcblxuICAgICAgICB2YXIgdTAgPSB2b2lkIDA7XG4gICAgICAgIHZhciB1MSA9IHZvaWQgMDtcbiAgICAgICAgdmFyIHUyID0gdm9pZCAwO1xuICAgICAgICB2YXIgdjAgPSB2b2lkIDA7XG4gICAgICAgIHZhciB2MSA9IHZvaWQgMDtcbiAgICAgICAgdmFyIHYyID0gdm9pZCAwO1xuXG4gICAgICAgIGlmIChtZXNoLnVwbG9hZFV2VHJhbnNmb3JtKSB7XG4gICAgICAgICAgICB2YXIgdXQgPSBtZXNoLl91dlRyYW5zZm9ybS5tYXBDb29yZDtcblxuICAgICAgICAgICAgdTAgPSAodXZzW2luZGV4MF0gKiB1dC5hICsgdXZzW2luZGV4MCArIDFdICogdXQuYyArIHV0LnR4KSAqIGJhc2Uud2lkdGg7XG4gICAgICAgICAgICB1MSA9ICh1dnNbaW5kZXgxXSAqIHV0LmEgKyB1dnNbaW5kZXgxICsgMV0gKiB1dC5jICsgdXQudHgpICogYmFzZS53aWR0aDtcbiAgICAgICAgICAgIHUyID0gKHV2c1tpbmRleDJdICogdXQuYSArIHV2c1tpbmRleDIgKyAxXSAqIHV0LmMgKyB1dC50eCkgKiBiYXNlLndpZHRoO1xuICAgICAgICAgICAgdjAgPSAodXZzW2luZGV4MF0gKiB1dC5iICsgdXZzW2luZGV4MCArIDFdICogdXQuZCArIHV0LnR5KSAqIGJhc2UuaGVpZ2h0O1xuICAgICAgICAgICAgdjEgPSAodXZzW2luZGV4MV0gKiB1dC5iICsgdXZzW2luZGV4MSArIDFdICogdXQuZCArIHV0LnR5KSAqIGJhc2UuaGVpZ2h0O1xuICAgICAgICAgICAgdjIgPSAodXZzW2luZGV4Ml0gKiB1dC5iICsgdXZzW2luZGV4MiArIDFdICogdXQuZCArIHV0LnR5KSAqIGJhc2UuaGVpZ2h0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdTAgPSB1dnNbaW5kZXgwXSAqIGJhc2Uud2lkdGg7XG4gICAgICAgICAgICB1MSA9IHV2c1tpbmRleDFdICogYmFzZS53aWR0aDtcbiAgICAgICAgICAgIHUyID0gdXZzW2luZGV4Ml0gKiBiYXNlLndpZHRoO1xuICAgICAgICAgICAgdjAgPSB1dnNbaW5kZXgwICsgMV0gKiBiYXNlLmhlaWdodDtcbiAgICAgICAgICAgIHYxID0gdXZzW2luZGV4MSArIDFdICogYmFzZS5oZWlnaHQ7XG4gICAgICAgICAgICB2MiA9IHV2c1tpbmRleDIgKyAxXSAqIGJhc2UuaGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHgwID0gdmVydGljZXNbaW5kZXgwXTtcbiAgICAgICAgdmFyIHgxID0gdmVydGljZXNbaW5kZXgxXTtcbiAgICAgICAgdmFyIHgyID0gdmVydGljZXNbaW5kZXgyXTtcbiAgICAgICAgdmFyIHkwID0gdmVydGljZXNbaW5kZXgwICsgMV07XG4gICAgICAgIHZhciB5MSA9IHZlcnRpY2VzW2luZGV4MSArIDFdO1xuICAgICAgICB2YXIgeTIgPSB2ZXJ0aWNlc1tpbmRleDIgKyAxXTtcblxuICAgICAgICB2YXIgY2FudmFzUGFkZGluZyA9IG1lc2guY2FudmFzUGFkZGluZyAvIHRoaXMucmVuZGVyZXIucmVzb2x1dGlvbjtcblxuICAgICAgICBpZiAoY2FudmFzUGFkZGluZyA+IDApIHtcbiAgICAgICAgICAgIHZhciBwYWRkaW5nWCA9IGNhbnZhc1BhZGRpbmcgLyBNYXRoLmFicyhtZXNoLndvcmxkVHJhbnNmb3JtLmEpO1xuICAgICAgICAgICAgdmFyIHBhZGRpbmdZID0gY2FudmFzUGFkZGluZyAvIE1hdGguYWJzKG1lc2gud29ybGRUcmFuc2Zvcm0uZCk7XG4gICAgICAgICAgICB2YXIgY2VudGVyWCA9ICh4MCArIHgxICsgeDIpIC8gMztcbiAgICAgICAgICAgIHZhciBjZW50ZXJZID0gKHkwICsgeTEgKyB5MikgLyAzO1xuXG4gICAgICAgICAgICB2YXIgbm9ybVggPSB4MCAtIGNlbnRlclg7XG4gICAgICAgICAgICB2YXIgbm9ybVkgPSB5MCAtIGNlbnRlclk7XG5cbiAgICAgICAgICAgIHZhciBkaXN0ID0gTWF0aC5zcXJ0KG5vcm1YICogbm9ybVggKyBub3JtWSAqIG5vcm1ZKTtcblxuICAgICAgICAgICAgeDAgPSBjZW50ZXJYICsgbm9ybVggLyBkaXN0ICogKGRpc3QgKyBwYWRkaW5nWCk7XG4gICAgICAgICAgICB5MCA9IGNlbnRlclkgKyBub3JtWSAvIGRpc3QgKiAoZGlzdCArIHBhZGRpbmdZKTtcblxuICAgICAgICAgICAgLy9cblxuICAgICAgICAgICAgbm9ybVggPSB4MSAtIGNlbnRlclg7XG4gICAgICAgICAgICBub3JtWSA9IHkxIC0gY2VudGVyWTtcblxuICAgICAgICAgICAgZGlzdCA9IE1hdGguc3FydChub3JtWCAqIG5vcm1YICsgbm9ybVkgKiBub3JtWSk7XG4gICAgICAgICAgICB4MSA9IGNlbnRlclggKyBub3JtWCAvIGRpc3QgKiAoZGlzdCArIHBhZGRpbmdYKTtcbiAgICAgICAgICAgIHkxID0gY2VudGVyWSArIG5vcm1ZIC8gZGlzdCAqIChkaXN0ICsgcGFkZGluZ1kpO1xuXG4gICAgICAgICAgICBub3JtWCA9IHgyIC0gY2VudGVyWDtcbiAgICAgICAgICAgIG5vcm1ZID0geTIgLSBjZW50ZXJZO1xuXG4gICAgICAgICAgICBkaXN0ID0gTWF0aC5zcXJ0KG5vcm1YICogbm9ybVggKyBub3JtWSAqIG5vcm1ZKTtcbiAgICAgICAgICAgIHgyID0gY2VudGVyWCArIG5vcm1YIC8gZGlzdCAqIChkaXN0ICsgcGFkZGluZ1gpO1xuICAgICAgICAgICAgeTIgPSBjZW50ZXJZICsgbm9ybVkgLyBkaXN0ICogKGRpc3QgKyBwYWRkaW5nWSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcblxuICAgICAgICBjb250ZXh0Lm1vdmVUbyh4MCwgeTApO1xuICAgICAgICBjb250ZXh0LmxpbmVUbyh4MSwgeTEpO1xuICAgICAgICBjb250ZXh0LmxpbmVUbyh4MiwgeTIpO1xuXG4gICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG5cbiAgICAgICAgY29udGV4dC5jbGlwKCk7XG5cbiAgICAgICAgLy8gQ29tcHV0ZSBtYXRyaXggdHJhbnNmb3JtXG4gICAgICAgIHZhciBkZWx0YSA9IHUwICogdjEgKyB2MCAqIHUyICsgdTEgKiB2MiAtIHYxICogdTIgLSB2MCAqIHUxIC0gdTAgKiB2MjtcbiAgICAgICAgdmFyIGRlbHRhQSA9IHgwICogdjEgKyB2MCAqIHgyICsgeDEgKiB2MiAtIHYxICogeDIgLSB2MCAqIHgxIC0geDAgKiB2MjtcbiAgICAgICAgdmFyIGRlbHRhQiA9IHUwICogeDEgKyB4MCAqIHUyICsgdTEgKiB4MiAtIHgxICogdTIgLSB4MCAqIHUxIC0gdTAgKiB4MjtcbiAgICAgICAgdmFyIGRlbHRhQyA9IHUwICogdjEgKiB4MiArIHYwICogeDEgKiB1MiArIHgwICogdTEgKiB2MiAtIHgwICogdjEgKiB1MiAtIHYwICogdTEgKiB4MiAtIHUwICogeDEgKiB2MjtcbiAgICAgICAgdmFyIGRlbHRhRCA9IHkwICogdjEgKyB2MCAqIHkyICsgeTEgKiB2MiAtIHYxICogeTIgLSB2MCAqIHkxIC0geTAgKiB2MjtcbiAgICAgICAgdmFyIGRlbHRhRSA9IHUwICogeTEgKyB5MCAqIHUyICsgdTEgKiB5MiAtIHkxICogdTIgLSB5MCAqIHUxIC0gdTAgKiB5MjtcbiAgICAgICAgdmFyIGRlbHRhRiA9IHUwICogdjEgKiB5MiArIHYwICogeTEgKiB1MiArIHkwICogdTEgKiB2MiAtIHkwICogdjEgKiB1MiAtIHYwICogdTEgKiB5MiAtIHUwICogeTEgKiB2MjtcblxuICAgICAgICBjb250ZXh0LnRyYW5zZm9ybShkZWx0YUEgLyBkZWx0YSwgZGVsdGFEIC8gZGVsdGEsIGRlbHRhQiAvIGRlbHRhLCBkZWx0YUUgLyBkZWx0YSwgZGVsdGFDIC8gZGVsdGEsIGRlbHRhRiAvIGRlbHRhKTtcblxuICAgICAgICBjb250ZXh0LmRyYXdJbWFnZSh0ZXh0dXJlU291cmNlLCAwLCAwLCB0ZXh0dXJlV2lkdGggKiBiYXNlLnJlc29sdXRpb24sIHRleHR1cmVIZWlnaHQgKiBiYXNlLnJlc29sdXRpb24sIDAsIDAsIHRleHR1cmVXaWR0aCwgdGV4dHVyZUhlaWdodCk7XG5cbiAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuaW52YWxpZGF0ZUJsZW5kTW9kZSgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIGEgZmxhdCBNZXNoXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7UElYSS5tZXNoLk1lc2h9IG1lc2ggLSBUaGUgTWVzaCB0byByZW5kZXJcbiAgICAgKi9cblxuXG4gICAgTWVzaFNwcml0ZVJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJNZXNoRmxhdCA9IGZ1bmN0aW9uIHJlbmRlck1lc2hGbGF0KG1lc2gpIHtcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLnJlbmRlcmVyLmNvbnRleHQ7XG4gICAgICAgIHZhciB2ZXJ0aWNlcyA9IG1lc2gudmVydGljZXM7XG4gICAgICAgIHZhciBsZW5ndGggPSB2ZXJ0aWNlcy5sZW5ndGggLyAyO1xuXG4gICAgICAgIC8vIHRoaXMuY291bnQrKztcblxuICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuZ3RoIC0gMjsgKytpKSB7XG4gICAgICAgICAgICAvLyBkcmF3IHNvbWUgdHJpYW5nbGVzIVxuICAgICAgICAgICAgdmFyIGluZGV4ID0gaSAqIDI7XG5cbiAgICAgICAgICAgIHZhciB4MCA9IHZlcnRpY2VzW2luZGV4XTtcbiAgICAgICAgICAgIHZhciB5MCA9IHZlcnRpY2VzW2luZGV4ICsgMV07XG5cbiAgICAgICAgICAgIHZhciB4MSA9IHZlcnRpY2VzW2luZGV4ICsgMl07XG4gICAgICAgICAgICB2YXIgeTEgPSB2ZXJ0aWNlc1tpbmRleCArIDNdO1xuXG4gICAgICAgICAgICB2YXIgeDIgPSB2ZXJ0aWNlc1tpbmRleCArIDRdO1xuICAgICAgICAgICAgdmFyIHkyID0gdmVydGljZXNbaW5kZXggKyA1XTtcblxuICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8oeDAsIHkwKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHgxLCB5MSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyh4MiwgeTIpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSAnI0ZGMDAwMCc7XG4gICAgICAgIGNvbnRleHQuZmlsbCgpO1xuICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBkZXN0cm95IHRoZSB0aGUgcmVuZGVyZXIuXG4gICAgICpcbiAgICAgKi9cblxuXG4gICAgTWVzaFNwcml0ZVJlbmRlcmVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IG51bGw7XG4gICAgfTtcblxuICAgIHJldHVybiBNZXNoU3ByaXRlUmVuZGVyZXI7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IE1lc2hTcHJpdGVSZW5kZXJlcjtcblxuXG5jb3JlLkNhbnZhc1JlbmRlcmVyLnJlZ2lzdGVyUGx1Z2luKCdtZXNoJywgTWVzaFNwcml0ZVJlbmRlcmVyKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNhbnZhc01lc2hSZW5kZXJlci5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfTWVzaCA9IHJlcXVpcmUoJy4vTWVzaCcpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ01lc2gnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZXNoKS5kZWZhdWx0O1xuICB9XG59KTtcblxudmFyIF9NZXNoUmVuZGVyZXIgPSByZXF1aXJlKCcuL3dlYmdsL01lc2hSZW5kZXJlcicpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ01lc2hSZW5kZXJlcicsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01lc2hSZW5kZXJlcikuZGVmYXVsdDtcbiAgfVxufSk7XG5cbnZhciBfQ2FudmFzTWVzaFJlbmRlcmVyID0gcmVxdWlyZSgnLi9jYW52YXMvQ2FudmFzTWVzaFJlbmRlcmVyJyk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnQ2FudmFzTWVzaFJlbmRlcmVyJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQ2FudmFzTWVzaFJlbmRlcmVyKS5kZWZhdWx0O1xuICB9XG59KTtcblxudmFyIF9QbGFuZSA9IHJlcXVpcmUoJy4vUGxhbmUnKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdQbGFuZScsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1BsYW5lKS5kZWZhdWx0O1xuICB9XG59KTtcblxudmFyIF9OaW5lU2xpY2VQbGFuZSA9IHJlcXVpcmUoJy4vTmluZVNsaWNlUGxhbmUnKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdOaW5lU2xpY2VQbGFuZScsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX05pbmVTbGljZVBsYW5lKS5kZWZhdWx0O1xuICB9XG59KTtcblxudmFyIF9Sb3BlID0gcmVxdWlyZSgnLi9Sb3BlJyk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnUm9wZScsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1JvcGUpLmRlZmF1bHQ7XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2NvcmUgPSByZXF1aXJlKCcuLi8uLi9jb3JlJyk7XG5cbnZhciBjb3JlID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX2NvcmUpO1xuXG52YXIgX3BpeGlHbENvcmUgPSByZXF1aXJlKCdwaXhpLWdsLWNvcmUnKTtcblxudmFyIF9waXhpR2xDb3JlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BpeGlHbENvcmUpO1xuXG52YXIgX01lc2ggPSByZXF1aXJlKCcuLi9NZXNoJyk7XG5cbnZhciBfTWVzaDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZXNoKTtcblxudmFyIF9wYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBtYXRyaXhJZGVudGl0eSA9IGNvcmUuTWF0cml4LklERU5USVRZO1xuXG4vKipcbiAqIFdlYkdMIHJlbmRlcmVyIHBsdWdpbiBmb3IgdGlsaW5nIHNwcml0ZXNcbiAqXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKiBAZXh0ZW5kcyBQSVhJLk9iamVjdFJlbmRlcmVyXG4gKi9cblxudmFyIE1lc2hSZW5kZXJlciA9IGZ1bmN0aW9uIChfY29yZSRPYmplY3RSZW5kZXJlcikge1xuICAgIF9pbmhlcml0cyhNZXNoUmVuZGVyZXIsIF9jb3JlJE9iamVjdFJlbmRlcmVyKTtcblxuICAgIC8qKlxuICAgICAqIGNvbnN0cnVjdG9yIGZvciByZW5kZXJlclxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciBUaGUgcmVuZGVyZXIgdGhpcyB0aWxpbmcgYXdlc29tZW5lc3Mgd29ya3MgZm9yLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE1lc2hSZW5kZXJlcihyZW5kZXJlcikge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTWVzaFJlbmRlcmVyKTtcblxuICAgICAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfY29yZSRPYmplY3RSZW5kZXJlci5jYWxsKHRoaXMsIHJlbmRlcmVyKSk7XG5cbiAgICAgICAgX3RoaXMuc2hhZGVyID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdXAgdGhlIHJlbmRlcmVyIGNvbnRleHQgYW5kIG5lY2Vzc2FyeSBidWZmZXJzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuXG4gICAgTWVzaFJlbmRlcmVyLnByb3RvdHlwZS5vbkNvbnRleHRDaGFuZ2UgPSBmdW5jdGlvbiBvbkNvbnRleHRDaGFuZ2UoKSB7XG4gICAgICAgIHZhciBnbCA9IHRoaXMucmVuZGVyZXIuZ2w7XG5cbiAgICAgICAgdGhpcy5zaGFkZXIgPSBuZXcgY29yZS5TaGFkZXIoZ2wsICdhdHRyaWJ1dGUgdmVjMiBhVmVydGV4UG9zaXRpb247XFxuYXR0cmlidXRlIHZlYzIgYVRleHR1cmVDb29yZDtcXG5cXG51bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDtcXG51bmlmb3JtIG1hdDMgdHJhbnNsYXRpb25NYXRyaXg7XFxudW5pZm9ybSBtYXQzIHVUcmFuc2Zvcm07XFxuXFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxuXFxudm9pZCBtYWluKHZvaWQpXFxue1xcbiAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoKHByb2plY3Rpb25NYXRyaXggKiB0cmFuc2xhdGlvbk1hdHJpeCAqIHZlYzMoYVZlcnRleFBvc2l0aW9uLCAxLjApKS54eSwgMC4wLCAxLjApO1xcblxcbiAgICB2VGV4dHVyZUNvb3JkID0gKHVUcmFuc2Zvcm0gKiB2ZWMzKGFUZXh0dXJlQ29vcmQsIDEuMCkpLnh5O1xcbn1cXG4nLCAndmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxudW5pZm9ybSB2ZWM0IHVDb2xvcjtcXG5cXG51bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcXG5cXG52b2lkIG1haW4odm9pZClcXG57XFxuICAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCkgKiB1Q29sb3I7XFxufVxcbicpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiByZW5kZXJzIG1lc2hcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5tZXNoLk1lc2h9IG1lc2ggbWVzaCBpbnN0YW5jZVxuICAgICAqL1xuXG5cbiAgICBNZXNoUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcihtZXNoKSB7XG4gICAgICAgIHZhciByZW5kZXJlciA9IHRoaXMucmVuZGVyZXI7XG4gICAgICAgIHZhciBnbCA9IHJlbmRlcmVyLmdsO1xuICAgICAgICB2YXIgdGV4dHVyZSA9IG1lc2guX3RleHR1cmU7XG5cbiAgICAgICAgaWYgKCF0ZXh0dXJlLnZhbGlkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZ2xEYXRhID0gbWVzaC5fZ2xEYXRhc1tyZW5kZXJlci5DT05URVhUX1VJRF07XG5cbiAgICAgICAgaWYgKCFnbERhdGEpIHtcbiAgICAgICAgICAgIHJlbmRlcmVyLmJpbmRWYW8obnVsbCk7XG5cbiAgICAgICAgICAgIGdsRGF0YSA9IHtcbiAgICAgICAgICAgICAgICBzaGFkZXI6IHRoaXMuc2hhZGVyLFxuICAgICAgICAgICAgICAgIHZlcnRleEJ1ZmZlcjogX3BpeGlHbENvcmUyLmRlZmF1bHQuR0xCdWZmZXIuY3JlYXRlVmVydGV4QnVmZmVyKGdsLCBtZXNoLnZlcnRpY2VzLCBnbC5TVFJFQU1fRFJBVyksXG4gICAgICAgICAgICAgICAgdXZCdWZmZXI6IF9waXhpR2xDb3JlMi5kZWZhdWx0LkdMQnVmZmVyLmNyZWF0ZVZlcnRleEJ1ZmZlcihnbCwgbWVzaC51dnMsIGdsLlNUUkVBTV9EUkFXKSxcbiAgICAgICAgICAgICAgICBpbmRleEJ1ZmZlcjogX3BpeGlHbENvcmUyLmRlZmF1bHQuR0xCdWZmZXIuY3JlYXRlSW5kZXhCdWZmZXIoZ2wsIG1lc2guaW5kaWNlcywgZ2wuU1RBVElDX0RSQVcpLFxuICAgICAgICAgICAgICAgIC8vIGJ1aWxkIHRoZSB2YW8gb2JqZWN0IHRoYXQgd2lsbCByZW5kZXIuLlxuICAgICAgICAgICAgICAgIHZhbzogbnVsbCxcbiAgICAgICAgICAgICAgICBkaXJ0eTogbWVzaC5kaXJ0eSxcbiAgICAgICAgICAgICAgICBpbmRleERpcnR5OiBtZXNoLmluZGV4RGlydHksXG4gICAgICAgICAgICAgICAgdmVydGV4RGlydHk6IG1lc2gudmVydGV4RGlydHlcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIGJ1aWxkIHRoZSB2YW8gb2JqZWN0IHRoYXQgd2lsbCByZW5kZXIuLlxuICAgICAgICAgICAgZ2xEYXRhLnZhbyA9IG5ldyBfcGl4aUdsQ29yZTIuZGVmYXVsdC5WZXJ0ZXhBcnJheU9iamVjdChnbCkuYWRkSW5kZXgoZ2xEYXRhLmluZGV4QnVmZmVyKS5hZGRBdHRyaWJ1dGUoZ2xEYXRhLnZlcnRleEJ1ZmZlciwgZ2xEYXRhLnNoYWRlci5hdHRyaWJ1dGVzLmFWZXJ0ZXhQb3NpdGlvbiwgZ2wuRkxPQVQsIGZhbHNlLCAyICogNCwgMCkuYWRkQXR0cmlidXRlKGdsRGF0YS51dkJ1ZmZlciwgZ2xEYXRhLnNoYWRlci5hdHRyaWJ1dGVzLmFUZXh0dXJlQ29vcmQsIGdsLkZMT0FULCBmYWxzZSwgMiAqIDQsIDApO1xuXG4gICAgICAgICAgICBtZXNoLl9nbERhdGFzW3JlbmRlcmVyLkNPTlRFWFRfVUlEXSA9IGdsRGF0YTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlbmRlcmVyLmJpbmRWYW8oZ2xEYXRhLnZhbyk7XG5cbiAgICAgICAgaWYgKG1lc2guZGlydHkgIT09IGdsRGF0YS5kaXJ0eSkge1xuICAgICAgICAgICAgZ2xEYXRhLmRpcnR5ID0gbWVzaC5kaXJ0eTtcbiAgICAgICAgICAgIGdsRGF0YS51dkJ1ZmZlci51cGxvYWQobWVzaC51dnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1lc2guaW5kZXhEaXJ0eSAhPT0gZ2xEYXRhLmluZGV4RGlydHkpIHtcbiAgICAgICAgICAgIGdsRGF0YS5pbmRleERpcnR5ID0gbWVzaC5pbmRleERpcnR5O1xuICAgICAgICAgICAgZ2xEYXRhLmluZGV4QnVmZmVyLnVwbG9hZChtZXNoLmluZGljZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1lc2gudmVydGV4RGlydHkgIT09IGdsRGF0YS52ZXJ0ZXhEaXJ0eSkge1xuICAgICAgICAgICAgZ2xEYXRhLnZlcnRleERpcnR5ID0gbWVzaC52ZXJ0ZXhEaXJ0eTtcbiAgICAgICAgICAgIGdsRGF0YS52ZXJ0ZXhCdWZmZXIudXBsb2FkKG1lc2gudmVydGljZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVuZGVyZXIuYmluZFNoYWRlcihnbERhdGEuc2hhZGVyKTtcblxuICAgICAgICBnbERhdGEuc2hhZGVyLnVuaWZvcm1zLnVTYW1wbGVyID0gcmVuZGVyZXIuYmluZFRleHR1cmUodGV4dHVyZSk7XG5cbiAgICAgICAgcmVuZGVyZXIuc3RhdGUuc2V0QmxlbmRNb2RlKGNvcmUudXRpbHMuY29ycmVjdEJsZW5kTW9kZShtZXNoLmJsZW5kTW9kZSwgdGV4dHVyZS5iYXNlVGV4dHVyZS5wcmVtdWx0aXBsaWVkQWxwaGEpKTtcblxuICAgICAgICBpZiAoZ2xEYXRhLnNoYWRlci51bmlmb3Jtcy51VHJhbnNmb3JtKSB7XG4gICAgICAgICAgICBpZiAobWVzaC51cGxvYWRVdlRyYW5zZm9ybSkge1xuICAgICAgICAgICAgICAgIGdsRGF0YS5zaGFkZXIudW5pZm9ybXMudVRyYW5zZm9ybSA9IG1lc2guX3V2VHJhbnNmb3JtLm1hcENvb3JkLnRvQXJyYXkodHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGdsRGF0YS5zaGFkZXIudW5pZm9ybXMudVRyYW5zZm9ybSA9IG1hdHJpeElkZW50aXR5LnRvQXJyYXkodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZ2xEYXRhLnNoYWRlci51bmlmb3Jtcy50cmFuc2xhdGlvbk1hdHJpeCA9IG1lc2gud29ybGRUcmFuc2Zvcm0udG9BcnJheSh0cnVlKTtcblxuICAgICAgICBnbERhdGEuc2hhZGVyLnVuaWZvcm1zLnVDb2xvciA9IGNvcmUudXRpbHMucHJlbXVsdGlwbHlSZ2JhKG1lc2gudGludFJnYiwgbWVzaC53b3JsZEFscGhhLCBnbERhdGEuc2hhZGVyLnVuaWZvcm1zLnVDb2xvciwgdGV4dHVyZS5iYXNlVGV4dHVyZS5wcmVtdWx0aXBsaWVkQWxwaGEpO1xuXG4gICAgICAgIHZhciBkcmF3TW9kZSA9IG1lc2guZHJhd01vZGUgPT09IF9NZXNoMi5kZWZhdWx0LkRSQVdfTU9ERVMuVFJJQU5HTEVfTUVTSCA/IGdsLlRSSUFOR0xFX1NUUklQIDogZ2wuVFJJQU5HTEVTO1xuXG4gICAgICAgIGdsRGF0YS52YW8uZHJhdyhkcmF3TW9kZSwgbWVzaC5pbmRpY2VzLmxlbmd0aCwgMCk7XG4gICAgfTtcblxuICAgIHJldHVybiBNZXNoUmVuZGVyZXI7XG59KGNvcmUuT2JqZWN0UmVuZGVyZXIpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBNZXNoUmVuZGVyZXI7XG5cblxuY29yZS5XZWJHTFJlbmRlcmVyLnJlZ2lzdGVyUGx1Z2luKCdtZXNoJywgTWVzaFJlbmRlcmVyKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1lc2hSZW5kZXJlci5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfY29yZSA9IHJlcXVpcmUoJy4uL2NvcmUnKTtcblxudmFyIGNvcmUgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfY29yZSk7XG5cbnZhciBfdXRpbHMgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuLyoqXG4gKiBUaGUgUGFydGljbGVDb250YWluZXIgY2xhc3MgaXMgYSByZWFsbHkgZmFzdCB2ZXJzaW9uIG9mIHRoZSBDb250YWluZXIgYnVpbHQgc29sZWx5IGZvciBzcGVlZCxcbiAqIHNvIHVzZSB3aGVuIHlvdSBuZWVkIGEgbG90IG9mIHNwcml0ZXMgb3IgcGFydGljbGVzLiBUaGUgdHJhZGVvZmYgb2YgdGhlIFBhcnRpY2xlQ29udGFpbmVyIGlzIHRoYXQgbW9zdCBhZHZhbmNlZFxuICogZnVuY3Rpb25hbGl0eSB3aWxsIG5vdCB3b3JrLiBQYXJ0aWNsZUNvbnRhaW5lciBpbXBsZW1lbnRzIHRoZSBiYXNpYyBvYmplY3QgdHJhbnNmb3JtIChwb3NpdGlvbiwgc2NhbGUsIHJvdGF0aW9uKVxuICogYW5kIHNvbWUgYWR2YW5jZWQgZnVuY3Rpb25hbGl0eSBsaWtlIHRpbnQgKGFzIG9mIHY0LjUuNikuXG4gKiBPdGhlciBtb3JlIGFkdmFuY2VkIGZ1bmN0aW9uYWxpdHkgbGlrZSBtYXNraW5nLCBjaGlsZHJlbiwgZmlsdGVycywgZXRjIHdpbGwgbm90IHdvcmsgb24gc3ByaXRlcyBpbiB0aGlzIGJhdGNoLlxuICpcbiAqIEl0J3MgZXh0cmVtZWx5IGVhc3kgdG8gdXNlIDpcbiAqXG4gKiBgYGBqc1xuICogbGV0IGNvbnRhaW5lciA9IG5ldyBQYXJ0aWNsZUNvbnRhaW5lcigpO1xuICpcbiAqIGZvciAobGV0IGkgPSAwOyBpIDwgMTAwOyArK2kpXG4gKiB7XG4gKiAgICAgbGV0IHNwcml0ZSA9IG5ldyBQSVhJLlNwcml0ZS5mcm9tSW1hZ2UoXCJteUltYWdlLnBuZ1wiKTtcbiAqICAgICBjb250YWluZXIuYWRkQ2hpbGQoc3ByaXRlKTtcbiAqIH1cbiAqIGBgYFxuICpcbiAqIEFuZCBoZXJlIHlvdSBoYXZlIGEgaHVuZHJlZCBzcHJpdGVzIHRoYXQgd2lsbCBiZSByZW5kZXJlZCBhdCB0aGUgc3BlZWQgb2YgbGlnaHQuXG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQSVhJLkNvbnRhaW5lclxuICogQG1lbWJlcm9mIFBJWEkucGFydGljbGVzXG4gKi9cbnZhciBQYXJ0aWNsZUNvbnRhaW5lciA9IGZ1bmN0aW9uIChfY29yZSRDb250YWluZXIpIHtcbiAgICBfaW5oZXJpdHMoUGFydGljbGVDb250YWluZXIsIF9jb3JlJENvbnRhaW5lcik7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW21heFNpemU9MTUwMF0gLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgcGFydGljbGVzIHRoYXQgY2FuIGJlIHJlbmRlcmVkIGJ5IHRoZSBjb250YWluZXIuXG4gICAgICogIEFmZmVjdHMgc2l6ZSBvZiBhbGxvY2F0ZWQgYnVmZmVycy5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW3Byb3BlcnRpZXNdIC0gVGhlIHByb3BlcnRpZXMgb2YgY2hpbGRyZW4gdGhhdCBzaG91bGQgYmUgdXBsb2FkZWQgdG8gdGhlIGdwdSBhbmQgYXBwbGllZC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtwcm9wZXJ0aWVzLnZlcnRpY2VzPWZhbHNlXSAtIFdoZW4gdHJ1ZSwgdmVydGljZXMgYmUgdXBsb2FkZWQgYW5kIGFwcGxpZWQuXG4gICAgICogICAgICAgICAgICAgICAgICBpZiBzcHJpdGUncyBgIHNjYWxlL2FuY2hvci90cmltL2ZyYW1lL29yaWdgIGlzIGR5bmFtaWMsIHBsZWFzZSBzZXQgYHRydWVgLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Byb3BlcnRpZXMucG9zaXRpb249dHJ1ZV0gLSBXaGVuIHRydWUsIHBvc2l0aW9uIGJlIHVwbG9hZGVkIGFuZCBhcHBsaWVkLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Byb3BlcnRpZXMucm90YXRpb249ZmFsc2VdIC0gV2hlbiB0cnVlLCByb3RhdGlvbiBiZSB1cGxvYWRlZCBhbmQgYXBwbGllZC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtwcm9wZXJ0aWVzLnV2cz1mYWxzZV0gLSBXaGVuIHRydWUsIHV2cyBiZSB1cGxvYWRlZCBhbmQgYXBwbGllZC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtwcm9wZXJ0aWVzLnRpbnQ9ZmFsc2VdIC0gV2hlbiB0cnVlLCBhbHBoYSBhbmQgdGludCBiZSB1cGxvYWRlZCBhbmQgYXBwbGllZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2JhdGNoU2l6ZT0xNjM4NF0gLSBOdW1iZXIgb2YgcGFydGljbGVzIHBlciBiYXRjaC4gSWYgbGVzcyB0aGFuIG1heFNpemUsIGl0IHVzZXMgbWF4U2l6ZSBpbnN0ZWFkLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2F1dG9SZXNpemU9ZmFsc2VdIElmIHRydWUsIGNvbnRhaW5lciBhbGxvY2F0ZXMgbW9yZSBiYXRjaGVzIGluIGNhc2VcbiAgICAgKiAgdGhlcmUgYXJlIG1vcmUgdGhhbiBgbWF4U2l6ZWAgcGFydGljbGVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFBhcnRpY2xlQ29udGFpbmVyKCkge1xuICAgICAgICB2YXIgbWF4U2l6ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMTUwMDtcbiAgICAgICAgdmFyIHByb3BlcnRpZXMgPSBhcmd1bWVudHNbMV07XG4gICAgICAgIHZhciBiYXRjaFNpemUgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDE2Mzg0O1xuICAgICAgICB2YXIgYXV0b1Jlc2l6ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogZmFsc2U7XG5cbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBhcnRpY2xlQ29udGFpbmVyKTtcblxuICAgICAgICAvLyBNYWtpbmcgc3VyZSB0aGUgYmF0Y2ggc2l6ZSBpcyB2YWxpZFxuICAgICAgICAvLyA2NTUzNSBpcyBtYXggdmVydGV4IGluZGV4IGluIHRoZSBpbmRleCBidWZmZXIgKHNlZSBQYXJ0aWNsZVJlbmRlcmVyKVxuICAgICAgICAvLyBzbyBtYXggbnVtYmVyIG9mIHBhcnRpY2xlcyBpcyA2NTUzNiAvIDQgPSAxNjM4NFxuICAgICAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfY29yZSRDb250YWluZXIuY2FsbCh0aGlzKSk7XG5cbiAgICAgICAgdmFyIG1heEJhdGNoU2l6ZSA9IDE2Mzg0O1xuXG4gICAgICAgIGlmIChiYXRjaFNpemUgPiBtYXhCYXRjaFNpemUpIHtcbiAgICAgICAgICAgIGJhdGNoU2l6ZSA9IG1heEJhdGNoU2l6ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChiYXRjaFNpemUgPiBtYXhTaXplKSB7XG4gICAgICAgICAgICBiYXRjaFNpemUgPSBtYXhTaXplO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCBwcm9wZXJ0aWVzIHRvIGJlIGR5bmFtaWMgKHRydWUpIC8gc3RhdGljIChmYWxzZSlcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbltdfVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuX3Byb3BlcnRpZXMgPSBbZmFsc2UsIHRydWUsIGZhbHNlLCBmYWxzZSwgZmFsc2VdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5fbWF4U2l6ZSA9IG1heFNpemU7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLl9iYXRjaFNpemUgPSBiYXRjaFNpemU7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge29iamVjdDxudW1iZXIsIFdlYkdMQnVmZmVyPn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLl9nbEJ1ZmZlcnMgPSB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogZm9yIGV2ZXJ5IGJhdGNoIHN0b3JlcyBfdXBkYXRlSUQgY29ycmVzcG9uZGluZyB0byB0aGUgbGFzdCBjaGFuZ2UgaW4gdGhhdCBiYXRjaFxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJbXX1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLl9idWZmZXJVcGRhdGVJRHMgPSBbXTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogd2hlbiBjaGlsZCBpbnNlcnRlZCwgcmVtb3ZlZCBvciBjaGFuZ2VzIHBvc2l0aW9uIHRoaXMgbnVtYmVyIGdvZXMgdXBcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyW119XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5fdXBkYXRlSUQgPSAwO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuaW50ZXJhY3RpdmVDaGlsZHJlbiA9IGZhbHNlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYmxlbmQgbW9kZSB0byBiZSBhcHBsaWVkIHRvIHRoZSBzcHJpdGUuIEFwcGx5IGEgdmFsdWUgb2YgYFBJWEkuQkxFTkRfTU9ERVMuTk9STUFMYFxuICAgICAgICAgKiB0byByZXNldCB0aGUgYmxlbmQgbW9kZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCBQSVhJLkJMRU5EX01PREVTLk5PUk1BTFxuICAgICAgICAgKiBAc2VlIFBJWEkuQkxFTkRfTU9ERVNcbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLmJsZW5kTW9kZSA9IGNvcmUuQkxFTkRfTU9ERVMuTk9STUFMO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0cnVlLCBjb250YWluZXIgYWxsb2NhdGVzIG1vcmUgYmF0Y2hlcyBpbiBjYXNlIHRoZXJlIGFyZSBtb3JlIHRoYW4gYG1heFNpemVgIHBhcnRpY2xlcy5cbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLmF1dG9SZXNpemUgPSBhdXRvUmVzaXplO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVc2VkIGZvciBjYW52YXMgcmVuZGVyZXJpbmcuIElmIHRydWUgdGhlbiB0aGUgZWxlbWVudHMgd2lsbCBiZSBwb3NpdGlvbmVkIGF0IHRoZVxuICAgICAgICAgKiBuZWFyZXN0IHBpeGVsLiBUaGlzIHByb3ZpZGVzIGEgbmljZSBzcGVlZCBib29zdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgICAgICogQGRlZmF1bHQgdHJ1ZTtcbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLnJvdW5kUGl4ZWxzID0gdHJ1ZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRleHR1cmUgdXNlZCB0byByZW5kZXIgdGhlIGNoaWxkcmVuLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmVhZG9ubHlcbiAgICAgICAgICogQG1lbWJlciB7QmFzZVRleHR1cmV9XG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5iYXNlVGV4dHVyZSA9IG51bGw7XG5cbiAgICAgICAgX3RoaXMuc2V0UHJvcGVydGllcyhwcm9wZXJ0aWVzKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRpbnQgYXBwbGllZCB0byB0aGUgY29udGFpbmVyLlxuICAgICAgICAgKiBUaGlzIGlzIGEgaGV4IHZhbHVlLiBBIHZhbHVlIG9mIDB4RkZGRkZGIHdpbGwgcmVtb3ZlIGFueSB0aW50IGVmZmVjdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAweEZGRkZGRlxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuX3RpbnQgPSAwO1xuICAgICAgICBfdGhpcy50aW50UmdiID0gbmV3IEZsb2F0MzJBcnJheSg0KTtcbiAgICAgICAgX3RoaXMudGludCA9IDB4RkZGRkZGO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgcHJpdmF0ZSBwcm9wZXJ0aWVzIGFycmF5IHRvIGR5bmFtaWMgLyBzdGF0aWMgYmFzZWQgb24gdGhlIHBhc3NlZCBwcm9wZXJ0aWVzIG9iamVjdFxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHByb3BlcnRpZXMgLSBUaGUgcHJvcGVydGllcyB0byBiZSB1cGxvYWRlZFxuICAgICAqL1xuXG5cbiAgICBQYXJ0aWNsZUNvbnRhaW5lci5wcm90b3R5cGUuc2V0UHJvcGVydGllcyA9IGZ1bmN0aW9uIHNldFByb3BlcnRpZXMocHJvcGVydGllcykge1xuICAgICAgICBpZiAocHJvcGVydGllcykge1xuICAgICAgICAgICAgdGhpcy5fcHJvcGVydGllc1swXSA9ICd2ZXJ0aWNlcycgaW4gcHJvcGVydGllcyB8fCAnc2NhbGUnIGluIHByb3BlcnRpZXMgPyAhIXByb3BlcnRpZXMudmVydGljZXMgfHwgISFwcm9wZXJ0aWVzLnNjYWxlIDogdGhpcy5fcHJvcGVydGllc1swXTtcbiAgICAgICAgICAgIHRoaXMuX3Byb3BlcnRpZXNbMV0gPSAncG9zaXRpb24nIGluIHByb3BlcnRpZXMgPyAhIXByb3BlcnRpZXMucG9zaXRpb24gOiB0aGlzLl9wcm9wZXJ0aWVzWzFdO1xuICAgICAgICAgICAgdGhpcy5fcHJvcGVydGllc1syXSA9ICdyb3RhdGlvbicgaW4gcHJvcGVydGllcyA/ICEhcHJvcGVydGllcy5yb3RhdGlvbiA6IHRoaXMuX3Byb3BlcnRpZXNbMl07XG4gICAgICAgICAgICB0aGlzLl9wcm9wZXJ0aWVzWzNdID0gJ3V2cycgaW4gcHJvcGVydGllcyA/ICEhcHJvcGVydGllcy51dnMgOiB0aGlzLl9wcm9wZXJ0aWVzWzNdO1xuICAgICAgICAgICAgdGhpcy5fcHJvcGVydGllc1s0XSA9ICd0aW50JyBpbiBwcm9wZXJ0aWVzIHx8ICdhbHBoYScgaW4gcHJvcGVydGllcyA/ICEhcHJvcGVydGllcy50aW50IHx8ICEhcHJvcGVydGllcy5hbHBoYSA6IHRoaXMuX3Byb3BlcnRpZXNbNF07XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgb2JqZWN0IHRyYW5zZm9ybSBmb3IgcmVuZGVyaW5nXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG5cbiAgICBQYXJ0aWNsZUNvbnRhaW5lci5wcm90b3R5cGUudXBkYXRlVHJhbnNmb3JtID0gZnVuY3Rpb24gdXBkYXRlVHJhbnNmb3JtKCkge1xuICAgICAgICAvLyBUT0RPIGRvbid0IG5lZWQgdG8hXG4gICAgICAgIHRoaXMuZGlzcGxheU9iamVjdFVwZGF0ZVRyYW5zZm9ybSgpO1xuICAgICAgICAvLyAgUElYSS5Db250YWluZXIucHJvdG90eXBlLnVwZGF0ZVRyYW5zZm9ybS5jYWxsKCB0aGlzICk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB0aW50IGFwcGxpZWQgdG8gdGhlIGNvbnRhaW5lci4gVGhpcyBpcyBhIGhleCB2YWx1ZS5cbiAgICAgKiBBIHZhbHVlIG9mIDB4RkZGRkZGIHdpbGwgcmVtb3ZlIGFueSB0aW50IGVmZmVjdC5cbiAgICAgKiogSU1QT1JUQU5UOiBUaGlzIGlzIGEgd2ViR0wgb25seSBmZWF0dXJlIGFuZCB3aWxsIGJlIGlnbm9yZWQgYnkgdGhlIGNhbnZhcyByZW5kZXJlci5cbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMHhGRkZGRkZcbiAgICAgKi9cblxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0aGUgY29udGFpbmVyIHVzaW5nIHRoZSBXZWJHTCByZW5kZXJlclxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1BJWEkuV2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgd2ViZ2wgcmVuZGVyZXJcbiAgICAgKi9cbiAgICBQYXJ0aWNsZUNvbnRhaW5lci5wcm90b3R5cGUucmVuZGVyV2ViR0wgPSBmdW5jdGlvbiByZW5kZXJXZWJHTChyZW5kZXJlcikge1xuICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICBpZiAoIXRoaXMudmlzaWJsZSB8fCB0aGlzLndvcmxkQWxwaGEgPD0gMCB8fCAhdGhpcy5jaGlsZHJlbi5sZW5ndGggfHwgIXRoaXMucmVuZGVyYWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLmJhc2VUZXh0dXJlKSB7XG4gICAgICAgICAgICB0aGlzLmJhc2VUZXh0dXJlID0gdGhpcy5jaGlsZHJlblswXS5fdGV4dHVyZS5iYXNlVGV4dHVyZTtcbiAgICAgICAgICAgIGlmICghdGhpcy5iYXNlVGV4dHVyZS5oYXNMb2FkZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJhc2VUZXh0dXJlLm9uY2UoJ3VwZGF0ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMi5vbkNoaWxkcmVuQ2hhbmdlKDApO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmVuZGVyZXIuc2V0T2JqZWN0UmVuZGVyZXIocmVuZGVyZXIucGx1Z2lucy5wYXJ0aWNsZSk7XG4gICAgICAgIHJlbmRlcmVyLnBsdWdpbnMucGFydGljbGUucmVuZGVyKHRoaXMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGZsYWcgdGhhdCBzdGF0aWMgZGF0YSBzaG91bGQgYmUgdXBkYXRlZCB0byB0cnVlXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzbWFsbGVzdENoaWxkSW5kZXggLSBUaGUgc21hbGxlc3QgY2hpbGQgaW5kZXhcbiAgICAgKi9cblxuXG4gICAgUGFydGljbGVDb250YWluZXIucHJvdG90eXBlLm9uQ2hpbGRyZW5DaGFuZ2UgPSBmdW5jdGlvbiBvbkNoaWxkcmVuQ2hhbmdlKHNtYWxsZXN0Q2hpbGRJbmRleCkge1xuICAgICAgICB2YXIgYnVmZmVySW5kZXggPSBNYXRoLmZsb29yKHNtYWxsZXN0Q2hpbGRJbmRleCAvIHRoaXMuX2JhdGNoU2l6ZSk7XG5cbiAgICAgICAgd2hpbGUgKHRoaXMuX2J1ZmZlclVwZGF0ZUlEcy5sZW5ndGggPCBidWZmZXJJbmRleCkge1xuICAgICAgICAgICAgdGhpcy5fYnVmZmVyVXBkYXRlSURzLnB1c2goMCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYnVmZmVyVXBkYXRlSURzW2J1ZmZlckluZGV4XSA9ICsrdGhpcy5fdXBkYXRlSUQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgdGhlIG9iamVjdCB1c2luZyB0aGUgQ2FudmFzIHJlbmRlcmVyXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7UElYSS5DYW52YXNSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgY2FudmFzIHJlbmRlcmVyXG4gICAgICovXG5cblxuICAgIFBhcnRpY2xlQ29udGFpbmVyLnByb3RvdHlwZS5yZW5kZXJDYW52YXMgPSBmdW5jdGlvbiByZW5kZXJDYW52YXMocmVuZGVyZXIpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZpc2libGUgfHwgdGhpcy53b3JsZEFscGhhIDw9IDAgfHwgIXRoaXMuY2hpbGRyZW4ubGVuZ3RoIHx8ICF0aGlzLnJlbmRlcmFibGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb250ZXh0ID0gcmVuZGVyZXIuY29udGV4dDtcbiAgICAgICAgdmFyIHRyYW5zZm9ybSA9IHRoaXMud29ybGRUcmFuc2Zvcm07XG4gICAgICAgIHZhciBpc1JvdGF0ZWQgPSB0cnVlO1xuXG4gICAgICAgIHZhciBwb3NpdGlvblggPSAwO1xuICAgICAgICB2YXIgcG9zaXRpb25ZID0gMDtcblxuICAgICAgICB2YXIgZmluYWxXaWR0aCA9IDA7XG4gICAgICAgIHZhciBmaW5hbEhlaWdodCA9IDA7XG5cbiAgICAgICAgcmVuZGVyZXIuc2V0QmxlbmRNb2RlKHRoaXMuYmxlbmRNb2RlKTtcblxuICAgICAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gdGhpcy53b3JsZEFscGhhO1xuXG4gICAgICAgIHRoaXMuZGlzcGxheU9iamVjdFVwZGF0ZVRyYW5zZm9ybSgpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXTtcblxuICAgICAgICAgICAgaWYgKCFjaGlsZC52aXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBmcmFtZSA9IGNoaWxkLl90ZXh0dXJlLmZyYW1lO1xuXG4gICAgICAgICAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gdGhpcy53b3JsZEFscGhhICogY2hpbGQuYWxwaGE7XG5cbiAgICAgICAgICAgIGlmIChjaGlsZC5yb3RhdGlvbiAlIChNYXRoLlBJICogMikgPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIHRoZSBmYXN0ZXN0ICB3YXkgdG8gb3B0aW1pc2UhIC0gaWYgcm90YXRpb24gaXMgMCB0aGVuIHdlIGNhbiBhdm9pZCBhbnkga2luZCBvZiBzZXRUcmFuc2Zvcm0gY2FsbFxuICAgICAgICAgICAgICAgIGlmIChpc1JvdGF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5zZXRUcmFuc2Zvcm0odHJhbnNmb3JtLmEsIHRyYW5zZm9ybS5iLCB0cmFuc2Zvcm0uYywgdHJhbnNmb3JtLmQsIHRyYW5zZm9ybS50eCAqIHJlbmRlcmVyLnJlc29sdXRpb24sIHRyYW5zZm9ybS50eSAqIHJlbmRlcmVyLnJlc29sdXRpb24pO1xuXG4gICAgICAgICAgICAgICAgICAgIGlzUm90YXRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHBvc2l0aW9uWCA9IGNoaWxkLmFuY2hvci54ICogKC1mcmFtZS53aWR0aCAqIGNoaWxkLnNjYWxlLngpICsgY2hpbGQucG9zaXRpb24ueCArIDAuNTtcbiAgICAgICAgICAgICAgICBwb3NpdGlvblkgPSBjaGlsZC5hbmNob3IueSAqICgtZnJhbWUuaGVpZ2h0ICogY2hpbGQuc2NhbGUueSkgKyBjaGlsZC5wb3NpdGlvbi55ICsgMC41O1xuXG4gICAgICAgICAgICAgICAgZmluYWxXaWR0aCA9IGZyYW1lLndpZHRoICogY2hpbGQuc2NhbGUueDtcbiAgICAgICAgICAgICAgICBmaW5hbEhlaWdodCA9IGZyYW1lLmhlaWdodCAqIGNoaWxkLnNjYWxlLnk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghaXNSb3RhdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzUm90YXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY2hpbGQuZGlzcGxheU9iamVjdFVwZGF0ZVRyYW5zZm9ybSgpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkVHJhbnNmb3JtID0gY2hpbGQud29ybGRUcmFuc2Zvcm07XG5cbiAgICAgICAgICAgICAgICBpZiAocmVuZGVyZXIucm91bmRQaXhlbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5zZXRUcmFuc2Zvcm0oY2hpbGRUcmFuc2Zvcm0uYSwgY2hpbGRUcmFuc2Zvcm0uYiwgY2hpbGRUcmFuc2Zvcm0uYywgY2hpbGRUcmFuc2Zvcm0uZCwgY2hpbGRUcmFuc2Zvcm0udHggKiByZW5kZXJlci5yZXNvbHV0aW9uIHwgMCwgY2hpbGRUcmFuc2Zvcm0udHkgKiByZW5kZXJlci5yZXNvbHV0aW9uIHwgMCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5zZXRUcmFuc2Zvcm0oY2hpbGRUcmFuc2Zvcm0uYSwgY2hpbGRUcmFuc2Zvcm0uYiwgY2hpbGRUcmFuc2Zvcm0uYywgY2hpbGRUcmFuc2Zvcm0uZCwgY2hpbGRUcmFuc2Zvcm0udHggKiByZW5kZXJlci5yZXNvbHV0aW9uLCBjaGlsZFRyYW5zZm9ybS50eSAqIHJlbmRlcmVyLnJlc29sdXRpb24pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHBvc2l0aW9uWCA9IGNoaWxkLmFuY2hvci54ICogLWZyYW1lLndpZHRoICsgMC41O1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uWSA9IGNoaWxkLmFuY2hvci55ICogLWZyYW1lLmhlaWdodCArIDAuNTtcblxuICAgICAgICAgICAgICAgIGZpbmFsV2lkdGggPSBmcmFtZS53aWR0aDtcbiAgICAgICAgICAgICAgICBmaW5hbEhlaWdodCA9IGZyYW1lLmhlaWdodDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHJlc29sdXRpb24gPSBjaGlsZC5fdGV4dHVyZS5iYXNlVGV4dHVyZS5yZXNvbHV0aW9uO1xuXG4gICAgICAgICAgICBjb250ZXh0LmRyYXdJbWFnZShjaGlsZC5fdGV4dHVyZS5iYXNlVGV4dHVyZS5zb3VyY2UsIGZyYW1lLnggKiByZXNvbHV0aW9uLCBmcmFtZS55ICogcmVzb2x1dGlvbiwgZnJhbWUud2lkdGggKiByZXNvbHV0aW9uLCBmcmFtZS5oZWlnaHQgKiByZXNvbHV0aW9uLCBwb3NpdGlvblggKiByZW5kZXJlci5yZXNvbHV0aW9uLCBwb3NpdGlvblkgKiByZW5kZXJlci5yZXNvbHV0aW9uLCBmaW5hbFdpZHRoICogcmVuZGVyZXIucmVzb2x1dGlvbiwgZmluYWxIZWlnaHQgKiByZW5kZXJlci5yZXNvbHV0aW9uKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyB0aGUgY29udGFpbmVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdHxib29sZWFufSBbb3B0aW9uc10gLSBPcHRpb25zIHBhcmFtZXRlci4gQSBib29sZWFuIHdpbGwgYWN0IGFzIGlmIGFsbCBvcHRpb25zXG4gICAgICogIGhhdmUgYmVlbiBzZXQgdG8gdGhhdCB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY2hpbGRyZW49ZmFsc2VdIC0gaWYgc2V0IHRvIHRydWUsIGFsbCB0aGUgY2hpbGRyZW4gd2lsbCBoYXZlIHRoZWlyXG4gICAgICogIGRlc3Ryb3kgbWV0aG9kIGNhbGxlZCBhcyB3ZWxsLiAnb3B0aW9ucycgd2lsbCBiZSBwYXNzZWQgb24gdG8gdGhvc2UgY2FsbHMuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50ZXh0dXJlPWZhbHNlXSAtIE9ubHkgdXNlZCBmb3IgY2hpbGQgU3ByaXRlcyBpZiBvcHRpb25zLmNoaWxkcmVuIGlzIHNldCB0byB0cnVlXG4gICAgICogIFNob3VsZCBpdCBkZXN0cm95IHRoZSB0ZXh0dXJlIG9mIHRoZSBjaGlsZCBzcHJpdGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmJhc2VUZXh0dXJlPWZhbHNlXSAtIE9ubHkgdXNlZCBmb3IgY2hpbGQgU3ByaXRlcyBpZiBvcHRpb25zLmNoaWxkcmVuIGlzIHNldCB0byB0cnVlXG4gICAgICogIFNob3VsZCBpdCBkZXN0cm95IHRoZSBiYXNlIHRleHR1cmUgb2YgdGhlIGNoaWxkIHNwcml0ZVxuICAgICAqL1xuXG5cbiAgICBQYXJ0aWNsZUNvbnRhaW5lci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3kob3B0aW9ucykge1xuICAgICAgICBfY29yZSRDb250YWluZXIucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICAgICAgICBpZiAodGhpcy5fYnVmZmVycykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9idWZmZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYnVmZmVyc1tpXS5kZXN0cm95KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9wcm9wZXJ0aWVzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fYnVmZmVycyA9IG51bGw7XG4gICAgICAgIHRoaXMuX2J1ZmZlclVwZGF0ZUlEcyA9IG51bGw7XG4gICAgfTtcblxuICAgIF9jcmVhdGVDbGFzcyhQYXJ0aWNsZUNvbnRhaW5lciwgW3tcbiAgICAgICAga2V5OiAndGludCcsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RpbnQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlcXVpcmUtanNkb2NcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fdGludCA9IHZhbHVlO1xuICAgICAgICAgICAgKDAsIF91dGlscy5oZXgycmdiKSh2YWx1ZSwgdGhpcy50aW50UmdiKTtcbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBQYXJ0aWNsZUNvbnRhaW5lcjtcbn0oY29yZS5Db250YWluZXIpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBQYXJ0aWNsZUNvbnRhaW5lcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVBhcnRpY2xlQ29udGFpbmVyLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9QYXJ0aWNsZUNvbnRhaW5lciA9IHJlcXVpcmUoJy4vUGFydGljbGVDb250YWluZXInKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdQYXJ0aWNsZUNvbnRhaW5lcicsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1BhcnRpY2xlQ29udGFpbmVyKS5kZWZhdWx0O1xuICB9XG59KTtcblxudmFyIF9QYXJ0aWNsZVJlbmRlcmVyID0gcmVxdWlyZSgnLi93ZWJnbC9QYXJ0aWNsZVJlbmRlcmVyJyk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnUGFydGljbGVSZW5kZXJlcicsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1BhcnRpY2xlUmVuZGVyZXIpLmRlZmF1bHQ7XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3BpeGlHbENvcmUgPSByZXF1aXJlKCdwaXhpLWdsLWNvcmUnKTtcblxudmFyIF9waXhpR2xDb3JlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BpeGlHbENvcmUpO1xuXG52YXIgX2NyZWF0ZUluZGljZXNGb3JRdWFkcyA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvdXRpbHMvY3JlYXRlSW5kaWNlc0ZvclF1YWRzJyk7XG5cbnZhciBfY3JlYXRlSW5kaWNlc0ZvclF1YWRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUluZGljZXNGb3JRdWFkcyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8qKlxuICogQGF1dGhvciBNYXQgR3JvdmVzXG4gKlxuICogQmlnIHRoYW5rcyB0byB0aGUgdmVyeSBjbGV2ZXIgTWF0dCBEZXNMYXVyaWVycyA8bWF0dGRlc2w+IGh0dHBzOi8vZ2l0aHViLmNvbS9tYXR0ZGVzbC9cbiAqIGZvciBjcmVhdGluZyB0aGUgb3JpZ2luYWwgUGl4aUpTIHZlcnNpb24hXG4gKiBBbHNvIGEgdGhhbmtzIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9iY2hldmFsaWVyIGZvciB0d2Vha2luZyB0aGUgdGludCBhbmQgYWxwaGEgc28gdGhhdFxuICogdGhleSBub3cgc2hhcmUgNCBieXRlcyBvbiB0aGUgdmVydGV4IGJ1ZmZlclxuICpcbiAqIEhlYXZpbHkgaW5zcGlyZWQgYnkgTGliR0RYJ3MgUGFydGljbGVCdWZmZXI6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vbGliZ2R4L2xpYmdkeC9ibG9iL21hc3Rlci9nZHgvc3JjL2NvbS9iYWRsb2dpYy9nZHgvZ3JhcGhpY3MvZzJkL1BhcnRpY2xlQnVmZmVyLmphdmFcbiAqL1xuXG4vKipcbiAqIFRoZSBwYXJ0aWNsZSBidWZmZXIgbWFuYWdlcyB0aGUgc3RhdGljIGFuZCBkeW5hbWljIGJ1ZmZlcnMgZm9yIGEgcGFydGljbGUgY29udGFpbmVyLlxuICpcbiAqIEBjbGFzc1xuICogQHByaXZhdGVcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKi9cbnZhciBQYXJ0aWNsZUJ1ZmZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgLSBUaGUgcmVuZGVyaW5nIGNvbnRleHQuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHByb3BlcnRpZXMgLSBUaGUgcHJvcGVydGllcyB0byB1cGxvYWQuXG4gICAgICogQHBhcmFtIHtib29sZWFuW119IGR5bmFtaWNQcm9wZXJ0eUZsYWdzIC0gRmxhZ3MgZm9yIHdoaWNoIHByb3BlcnRpZXMgYXJlIGR5bmFtaWMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNpemUgLSBUaGUgc2l6ZSBvZiB0aGUgYmF0Y2guXG4gICAgICovXG4gICAgZnVuY3Rpb24gUGFydGljbGVCdWZmZXIoZ2wsIHByb3BlcnRpZXMsIGR5bmFtaWNQcm9wZXJ0eUZsYWdzLCBzaXplKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQYXJ0aWNsZUJ1ZmZlcik7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjdXJyZW50IFdlYkdMIGRyYXdpbmcgY29udGV4dC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5nbCA9IGdsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbnVtYmVyIG9mIHBhcnRpY2xlcyB0aGUgYnVmZmVyIGNhbiBob2xkXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2l6ZSA9IHNpemU7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgbGlzdCBvZiB0aGUgcHJvcGVydGllcyB0aGF0IGFyZSBkeW5hbWljLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtvYmplY3RbXX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZHluYW1pY1Byb3BlcnRpZXMgPSBbXTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBsaXN0IG9mIHRoZSBwcm9wZXJ0aWVzIHRoYXQgYXJlIHN0YXRpYy5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7b2JqZWN0W119XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YXRpY1Byb3BlcnRpZXMgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BlcnRpZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBwcm9wZXJ0eSA9IHByb3BlcnRpZXNbaV07XG5cbiAgICAgICAgICAgIC8vIE1ha2UgY29weSBvZiBwcm9wZXJ0aWVzIG9iamVjdCBzbyB0aGF0IHdoZW4gd2UgZWRpdCB0aGUgb2Zmc2V0IGl0IGRvZXNuJ3RcbiAgICAgICAgICAgIC8vIGNoYW5nZSBhbGwgb3RoZXIgaW5zdGFuY2VzIG9mIHRoZSBvYmplY3QgbGl0ZXJhbFxuICAgICAgICAgICAgcHJvcGVydHkgPSB7XG4gICAgICAgICAgICAgICAgYXR0cmlidXRlOiBwcm9wZXJ0eS5hdHRyaWJ1dGUsXG4gICAgICAgICAgICAgICAgc2l6ZTogcHJvcGVydHkuc2l6ZSxcbiAgICAgICAgICAgICAgICB1cGxvYWRGdW5jdGlvbjogcHJvcGVydHkudXBsb2FkRnVuY3Rpb24sXG4gICAgICAgICAgICAgICAgdW5zaWduZWRCeXRlOiBwcm9wZXJ0eS51bnNpZ25lZEJ5dGUsXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiBwcm9wZXJ0eS5vZmZzZXRcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmIChkeW5hbWljUHJvcGVydHlGbGFnc1tpXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZHluYW1pY1Byb3BlcnRpZXMucHVzaChwcm9wZXJ0eSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGljUHJvcGVydGllcy5wdXNoKHByb3BlcnR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc3RhdGljU3RyaWRlID0gMDtcbiAgICAgICAgdGhpcy5zdGF0aWNCdWZmZXIgPSBudWxsO1xuICAgICAgICB0aGlzLnN0YXRpY0RhdGEgPSBudWxsO1xuICAgICAgICB0aGlzLnN0YXRpY0RhdGFVaW50MzIgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuZHluYW1pY1N0cmlkZSA9IDA7XG4gICAgICAgIHRoaXMuZHluYW1pY0J1ZmZlciA9IG51bGw7XG4gICAgICAgIHRoaXMuZHluYW1pY0RhdGEgPSBudWxsO1xuICAgICAgICB0aGlzLmR5bmFtaWNEYXRhVWludDMyID0gbnVsbDtcblxuICAgICAgICB0aGlzLl91cGRhdGVJRCA9IDA7XG5cbiAgICAgICAgdGhpcy5pbml0QnVmZmVycygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdXAgdGhlIHJlbmRlcmVyIGNvbnRleHQgYW5kIG5lY2Vzc2FyeSBidWZmZXJzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuXG4gICAgUGFydGljbGVCdWZmZXIucHJvdG90eXBlLmluaXRCdWZmZXJzID0gZnVuY3Rpb24gaW5pdEJ1ZmZlcnMoKSB7XG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2w7XG4gICAgICAgIHZhciBkeW5hbWljT2Zmc2V0ID0gMDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSG9sZHMgdGhlIGluZGljZXMgb2YgdGhlIGdlb21ldHJ5IChxdWFkcykgdG8gZHJhd1xuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtVaW50MTZBcnJheX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaW5kaWNlcyA9ICgwLCBfY3JlYXRlSW5kaWNlc0ZvclF1YWRzMi5kZWZhdWx0KSh0aGlzLnNpemUpO1xuICAgICAgICB0aGlzLmluZGV4QnVmZmVyID0gX3BpeGlHbENvcmUyLmRlZmF1bHQuR0xCdWZmZXIuY3JlYXRlSW5kZXhCdWZmZXIoZ2wsIHRoaXMuaW5kaWNlcywgZ2wuU1RBVElDX0RSQVcpO1xuXG4gICAgICAgIHRoaXMuZHluYW1pY1N0cmlkZSA9IDA7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgcHJvcGVydHkgPSB0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzW2ldO1xuXG4gICAgICAgICAgICBwcm9wZXJ0eS5vZmZzZXQgPSBkeW5hbWljT2Zmc2V0O1xuICAgICAgICAgICAgZHluYW1pY09mZnNldCArPSBwcm9wZXJ0eS5zaXplO1xuICAgICAgICAgICAgdGhpcy5keW5hbWljU3RyaWRlICs9IHByb3BlcnR5LnNpemU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZHluQnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKHRoaXMuc2l6ZSAqIHRoaXMuZHluYW1pY1N0cmlkZSAqIDQgKiA0KTtcblxuICAgICAgICB0aGlzLmR5bmFtaWNEYXRhID0gbmV3IEZsb2F0MzJBcnJheShkeW5CdWZmZXIpO1xuICAgICAgICB0aGlzLmR5bmFtaWNEYXRhVWludDMyID0gbmV3IFVpbnQzMkFycmF5KGR5bkJ1ZmZlcik7XG4gICAgICAgIHRoaXMuZHluYW1pY0J1ZmZlciA9IF9waXhpR2xDb3JlMi5kZWZhdWx0LkdMQnVmZmVyLmNyZWF0ZVZlcnRleEJ1ZmZlcihnbCwgZHluQnVmZmVyLCBnbC5TVFJFQU1fRFJBVyk7XG5cbiAgICAgICAgLy8gc3RhdGljIC8vXG4gICAgICAgIHZhciBzdGF0aWNPZmZzZXQgPSAwO1xuXG4gICAgICAgIHRoaXMuc3RhdGljU3RyaWRlID0gMDtcblxuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgdGhpcy5zdGF0aWNQcm9wZXJ0aWVzLmxlbmd0aDsgKytfaSkge1xuICAgICAgICAgICAgdmFyIF9wcm9wZXJ0eSA9IHRoaXMuc3RhdGljUHJvcGVydGllc1tfaV07XG5cbiAgICAgICAgICAgIF9wcm9wZXJ0eS5vZmZzZXQgPSBzdGF0aWNPZmZzZXQ7XG4gICAgICAgICAgICBzdGF0aWNPZmZzZXQgKz0gX3Byb3BlcnR5LnNpemU7XG4gICAgICAgICAgICB0aGlzLnN0YXRpY1N0cmlkZSArPSBfcHJvcGVydHkuc2l6ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzdGF0QnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKHRoaXMuc2l6ZSAqIHRoaXMuc3RhdGljU3RyaWRlICogNCAqIDQpO1xuXG4gICAgICAgIHRoaXMuc3RhdGljRGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoc3RhdEJ1ZmZlcik7XG4gICAgICAgIHRoaXMuc3RhdGljRGF0YVVpbnQzMiA9IG5ldyBVaW50MzJBcnJheShzdGF0QnVmZmVyKTtcbiAgICAgICAgdGhpcy5zdGF0aWNCdWZmZXIgPSBfcGl4aUdsQ29yZTIuZGVmYXVsdC5HTEJ1ZmZlci5jcmVhdGVWZXJ0ZXhCdWZmZXIoZ2wsIHN0YXRCdWZmZXIsIGdsLlNUQVRJQ19EUkFXKTtcblxuICAgICAgICB0aGlzLnZhbyA9IG5ldyBfcGl4aUdsQ29yZTIuZGVmYXVsdC5WZXJ0ZXhBcnJheU9iamVjdChnbCkuYWRkSW5kZXgodGhpcy5pbmRleEJ1ZmZlcik7XG5cbiAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgdGhpcy5keW5hbWljUHJvcGVydGllcy5sZW5ndGg7ICsrX2kyKSB7XG4gICAgICAgICAgICB2YXIgX3Byb3BlcnR5MiA9IHRoaXMuZHluYW1pY1Byb3BlcnRpZXNbX2kyXTtcblxuICAgICAgICAgICAgaWYgKF9wcm9wZXJ0eTIudW5zaWduZWRCeXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52YW8uYWRkQXR0cmlidXRlKHRoaXMuZHluYW1pY0J1ZmZlciwgX3Byb3BlcnR5Mi5hdHRyaWJ1dGUsIGdsLlVOU0lHTkVEX0JZVEUsIHRydWUsIHRoaXMuZHluYW1pY1N0cmlkZSAqIDQsIF9wcm9wZXJ0eTIub2Zmc2V0ICogNCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudmFvLmFkZEF0dHJpYnV0ZSh0aGlzLmR5bmFtaWNCdWZmZXIsIF9wcm9wZXJ0eTIuYXR0cmlidXRlLCBnbC5GTE9BVCwgZmFsc2UsIHRoaXMuZHluYW1pY1N0cmlkZSAqIDQsIF9wcm9wZXJ0eTIub2Zmc2V0ICogNCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCB0aGlzLnN0YXRpY1Byb3BlcnRpZXMubGVuZ3RoOyArK19pMykge1xuICAgICAgICAgICAgdmFyIF9wcm9wZXJ0eTMgPSB0aGlzLnN0YXRpY1Byb3BlcnRpZXNbX2kzXTtcblxuICAgICAgICAgICAgaWYgKF9wcm9wZXJ0eTMudW5zaWduZWRCeXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52YW8uYWRkQXR0cmlidXRlKHRoaXMuc3RhdGljQnVmZmVyLCBfcHJvcGVydHkzLmF0dHJpYnV0ZSwgZ2wuVU5TSUdORURfQllURSwgdHJ1ZSwgdGhpcy5zdGF0aWNTdHJpZGUgKiA0LCBfcHJvcGVydHkzLm9mZnNldCAqIDQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhby5hZGRBdHRyaWJ1dGUodGhpcy5zdGF0aWNCdWZmZXIsIF9wcm9wZXJ0eTMuYXR0cmlidXRlLCBnbC5GTE9BVCwgZmFsc2UsIHRoaXMuc3RhdGljU3RyaWRlICogNCwgX3Byb3BlcnR5My5vZmZzZXQgKiA0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBVcGxvYWRzIHRoZSBkeW5hbWljIHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuRGlzcGxheU9iamVjdFtdfSBjaGlsZHJlbiAtIFRoZSBjaGlsZHJlbiB0byB1cGxvYWQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0SW5kZXggLSBUaGUgaW5kZXggdG8gc3RhcnQgYXQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFtb3VudCAtIFRoZSBudW1iZXIgdG8gdXBsb2FkLlxuICAgICAqL1xuXG5cbiAgICBQYXJ0aWNsZUJ1ZmZlci5wcm90b3R5cGUudXBsb2FkRHluYW1pYyA9IGZ1bmN0aW9uIHVwbG9hZER5bmFtaWMoY2hpbGRyZW4sIHN0YXJ0SW5kZXgsIGFtb3VudCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZHluYW1pY1Byb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwcm9wZXJ0eSA9IHRoaXMuZHluYW1pY1Byb3BlcnRpZXNbaV07XG5cbiAgICAgICAgICAgIHByb3BlcnR5LnVwbG9hZEZ1bmN0aW9uKGNoaWxkcmVuLCBzdGFydEluZGV4LCBhbW91bnQsIHByb3BlcnR5LnVuc2lnbmVkQnl0ZSA/IHRoaXMuZHluYW1pY0RhdGFVaW50MzIgOiB0aGlzLmR5bmFtaWNEYXRhLCB0aGlzLmR5bmFtaWNTdHJpZGUsIHByb3BlcnR5Lm9mZnNldCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmR5bmFtaWNCdWZmZXIudXBsb2FkKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFVwbG9hZHMgdGhlIHN0YXRpYyBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLkRpc3BsYXlPYmplY3RbXX0gY2hpbGRyZW4gLSBUaGUgY2hpbGRyZW4gdG8gdXBsb2FkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydEluZGV4IC0gVGhlIGluZGV4IHRvIHN0YXJ0IGF0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbW91bnQgLSBUaGUgbnVtYmVyIHRvIHVwbG9hZC5cbiAgICAgKi9cblxuXG4gICAgUGFydGljbGVCdWZmZXIucHJvdG90eXBlLnVwbG9hZFN0YXRpYyA9IGZ1bmN0aW9uIHVwbG9hZFN0YXRpYyhjaGlsZHJlbiwgc3RhcnRJbmRleCwgYW1vdW50KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zdGF0aWNQcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcHJvcGVydHkgPSB0aGlzLnN0YXRpY1Byb3BlcnRpZXNbaV07XG5cbiAgICAgICAgICAgIHByb3BlcnR5LnVwbG9hZEZ1bmN0aW9uKGNoaWxkcmVuLCBzdGFydEluZGV4LCBhbW91bnQsIHByb3BlcnR5LnVuc2lnbmVkQnl0ZSA/IHRoaXMuc3RhdGljRGF0YVVpbnQzMiA6IHRoaXMuc3RhdGljRGF0YSwgdGhpcy5zdGF0aWNTdHJpZGUsIHByb3BlcnR5Lm9mZnNldCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnN0YXRpY0J1ZmZlci51cGxvYWQoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGVzdHJveXMgdGhlIFBhcnRpY2xlQnVmZmVyLlxuICAgICAqXG4gICAgICovXG5cblxuICAgIFBhcnRpY2xlQnVmZmVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5keW5hbWljUHJvcGVydGllcyA9IG51bGw7XG4gICAgICAgIHRoaXMuZHluYW1pY0J1ZmZlci5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuZHluYW1pY0J1ZmZlciA9IG51bGw7XG4gICAgICAgIHRoaXMuZHluYW1pY0RhdGEgPSBudWxsO1xuICAgICAgICB0aGlzLmR5bmFtaWNEYXRhVWludDMyID0gbnVsbDtcblxuICAgICAgICB0aGlzLnN0YXRpY1Byb3BlcnRpZXMgPSBudWxsO1xuICAgICAgICB0aGlzLnN0YXRpY0J1ZmZlci5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuc3RhdGljQnVmZmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdGF0aWNEYXRhID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdGF0aWNEYXRhVWludDMyID0gbnVsbDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFBhcnRpY2xlQnVmZmVyO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBQYXJ0aWNsZUJ1ZmZlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVBhcnRpY2xlQnVmZmVyLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9jb3JlID0gcmVxdWlyZSgnLi4vLi4vY29yZScpO1xuXG52YXIgY29yZSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9jb3JlKTtcblxudmFyIF9QYXJ0aWNsZVNoYWRlciA9IHJlcXVpcmUoJy4vUGFydGljbGVTaGFkZXInKTtcblxudmFyIF9QYXJ0aWNsZVNoYWRlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9QYXJ0aWNsZVNoYWRlcik7XG5cbnZhciBfUGFydGljbGVCdWZmZXIgPSByZXF1aXJlKCcuL1BhcnRpY2xlQnVmZmVyJyk7XG5cbnZhciBfUGFydGljbGVCdWZmZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUGFydGljbGVCdWZmZXIpO1xuXG52YXIgX3V0aWxzID0gcmVxdWlyZSgnLi4vLi4vY29yZS91dGlscycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbi8qKlxuICogQGF1dGhvciBNYXQgR3JvdmVzXG4gKlxuICogQmlnIHRoYW5rcyB0byB0aGUgdmVyeSBjbGV2ZXIgTWF0dCBEZXNMYXVyaWVycyA8bWF0dGRlc2w+IGh0dHBzOi8vZ2l0aHViLmNvbS9tYXR0ZGVzbC9cbiAqIGZvciBjcmVhdGluZyB0aGUgb3JpZ2luYWwgUGl4aUpTIHZlcnNpb24hXG4gKiBBbHNvIGEgdGhhbmtzIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9iY2hldmFsaWVyIGZvciB0d2Vha2luZyB0aGUgdGludCBhbmQgYWxwaGEgc28gdGhhdCB0aGV5IG5vd1xuICogc2hhcmUgNCBieXRlcyBvbiB0aGUgdmVydGV4IGJ1ZmZlclxuICpcbiAqIEhlYXZpbHkgaW5zcGlyZWQgYnkgTGliR0RYJ3MgUGFydGljbGVSZW5kZXJlcjpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9saWJnZHgvbGliZ2R4L2Jsb2IvbWFzdGVyL2dkeC9zcmMvY29tL2JhZGxvZ2ljL2dkeC9ncmFwaGljcy9nMmQvUGFydGljbGVSZW5kZXJlci5qYXZhXG4gKi9cblxuLyoqXG4gKlxuICogQGNsYXNzXG4gKiBAcHJpdmF0ZVxuICogQG1lbWJlcm9mIFBJWElcbiAqL1xudmFyIFBhcnRpY2xlUmVuZGVyZXIgPSBmdW5jdGlvbiAoX2NvcmUkT2JqZWN0UmVuZGVyZXIpIHtcbiAgICBfaW5oZXJpdHMoUGFydGljbGVSZW5kZXJlciwgX2NvcmUkT2JqZWN0UmVuZGVyZXIpO1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtQSVhJLldlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyIHRoaXMgc3ByaXRlIGJhdGNoIHdvcmtzIGZvci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBQYXJ0aWNsZVJlbmRlcmVyKHJlbmRlcmVyKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQYXJ0aWNsZVJlbmRlcmVyKTtcblxuICAgICAgICAvLyA2NTUzNSBpcyBtYXggdmVydGV4IGluZGV4IGluIHRoZSBpbmRleCBidWZmZXIgKHNlZSBQYXJ0aWNsZVJlbmRlcmVyKVxuICAgICAgICAvLyBzbyBtYXggbnVtYmVyIG9mIHBhcnRpY2xlcyBpcyA2NTUzNiAvIDQgPSAxNjM4NFxuICAgICAgICAvLyBhbmQgbWF4IG51bWJlciBvZiBlbGVtZW50IGluIHRoZSBpbmRleCBidWZmZXIgaXMgMTYzODQgKiA2ID0gOTgzMDRcbiAgICAgICAgLy8gQ3JlYXRpbmcgYSBmdWxsIGluZGV4IGJ1ZmZlciwgb3ZlcmhlYWQgaXMgOTgzMDQgKiAyID0gMTk2S29cbiAgICAgICAgLy8gbGV0IG51bUluZGljZXMgPSA5ODMwNDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGRlZmF1bHQgc2hhZGVyIHRoYXQgaXMgdXNlZCBpZiBhIHNwcml0ZSBkb2Vzbid0IGhhdmUgYSBtb3JlIHNwZWNpZmljIG9uZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5TaGFkZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfY29yZSRPYmplY3RSZW5kZXJlci5jYWxsKHRoaXMsIHJlbmRlcmVyKSk7XG5cbiAgICAgICAgX3RoaXMuc2hhZGVyID0gbnVsbDtcblxuICAgICAgICBfdGhpcy5pbmRleEJ1ZmZlciA9IG51bGw7XG5cbiAgICAgICAgX3RoaXMucHJvcGVydGllcyA9IG51bGw7XG5cbiAgICAgICAgX3RoaXMudGVtcE1hdHJpeCA9IG5ldyBjb3JlLk1hdHJpeCgpO1xuXG4gICAgICAgIF90aGlzLkNPTlRFWFRfVUlEID0gMDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdoZW4gdGhlcmUgaXMgYSBXZWJHTCBjb250ZXh0IGNoYW5nZVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuXG4gICAgUGFydGljbGVSZW5kZXJlci5wcm90b3R5cGUub25Db250ZXh0Q2hhbmdlID0gZnVuY3Rpb24gb25Db250ZXh0Q2hhbmdlKCkge1xuICAgICAgICB2YXIgZ2wgPSB0aGlzLnJlbmRlcmVyLmdsO1xuXG4gICAgICAgIHRoaXMuQ09OVEVYVF9VSUQgPSB0aGlzLnJlbmRlcmVyLkNPTlRFWFRfVUlEO1xuXG4gICAgICAgIC8vIHNldHVwIGRlZmF1bHQgc2hhZGVyXG4gICAgICAgIHRoaXMuc2hhZGVyID0gbmV3IF9QYXJ0aWNsZVNoYWRlcjIuZGVmYXVsdChnbCk7XG5cbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0gW1xuICAgICAgICAvLyB2ZXJ0aWNlc0RhdGFcbiAgICAgICAge1xuICAgICAgICAgICAgYXR0cmlidXRlOiB0aGlzLnNoYWRlci5hdHRyaWJ1dGVzLmFWZXJ0ZXhQb3NpdGlvbixcbiAgICAgICAgICAgIHNpemU6IDIsXG4gICAgICAgICAgICB1cGxvYWRGdW5jdGlvbjogdGhpcy51cGxvYWRWZXJ0aWNlcyxcbiAgICAgICAgICAgIG9mZnNldDogMFxuICAgICAgICB9LFxuICAgICAgICAvLyBwb3NpdGlvbkRhdGFcbiAgICAgICAge1xuICAgICAgICAgICAgYXR0cmlidXRlOiB0aGlzLnNoYWRlci5hdHRyaWJ1dGVzLmFQb3NpdGlvbkNvb3JkLFxuICAgICAgICAgICAgc2l6ZTogMixcbiAgICAgICAgICAgIHVwbG9hZEZ1bmN0aW9uOiB0aGlzLnVwbG9hZFBvc2l0aW9uLFxuICAgICAgICAgICAgb2Zmc2V0OiAwXG4gICAgICAgIH0sXG4gICAgICAgIC8vIHJvdGF0aW9uRGF0YVxuICAgICAgICB7XG4gICAgICAgICAgICBhdHRyaWJ1dGU6IHRoaXMuc2hhZGVyLmF0dHJpYnV0ZXMuYVJvdGF0aW9uLFxuICAgICAgICAgICAgc2l6ZTogMSxcbiAgICAgICAgICAgIHVwbG9hZEZ1bmN0aW9uOiB0aGlzLnVwbG9hZFJvdGF0aW9uLFxuICAgICAgICAgICAgb2Zmc2V0OiAwXG4gICAgICAgIH0sXG4gICAgICAgIC8vIHV2c0RhdGFcbiAgICAgICAge1xuICAgICAgICAgICAgYXR0cmlidXRlOiB0aGlzLnNoYWRlci5hdHRyaWJ1dGVzLmFUZXh0dXJlQ29vcmQsXG4gICAgICAgICAgICBzaXplOiAyLFxuICAgICAgICAgICAgdXBsb2FkRnVuY3Rpb246IHRoaXMudXBsb2FkVXZzLFxuICAgICAgICAgICAgb2Zmc2V0OiAwXG4gICAgICAgIH0sXG4gICAgICAgIC8vIHRpbnREYXRhXG4gICAgICAgIHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZTogdGhpcy5zaGFkZXIuYXR0cmlidXRlcy5hQ29sb3IsXG4gICAgICAgICAgICBzaXplOiAxLFxuICAgICAgICAgICAgdW5zaWduZWRCeXRlOiB0cnVlLFxuICAgICAgICAgICAgdXBsb2FkRnVuY3Rpb246IHRoaXMudXBsb2FkVGludCxcbiAgICAgICAgICAgIG9mZnNldDogMFxuICAgICAgICB9XTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU3RhcnRzIGEgbmV3IHBhcnRpY2xlIGJhdGNoLlxuICAgICAqXG4gICAgICovXG5cblxuICAgIFBhcnRpY2xlUmVuZGVyZXIucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gc3RhcnQoKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuYmluZFNoYWRlcih0aGlzLnNoYWRlcik7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgdGhlIHBhcnRpY2xlIGNvbnRhaW5lciBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuUGFydGljbGVDb250YWluZXJ9IGNvbnRhaW5lciAtIFRoZSBjb250YWluZXIgdG8gcmVuZGVyIHVzaW5nIHRoaXMgUGFydGljbGVSZW5kZXJlclxuICAgICAqL1xuXG5cbiAgICBQYXJ0aWNsZVJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoY29udGFpbmVyKSB7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IGNvbnRhaW5lci5jaGlsZHJlbjtcbiAgICAgICAgdmFyIG1heFNpemUgPSBjb250YWluZXIuX21heFNpemU7XG4gICAgICAgIHZhciBiYXRjaFNpemUgPSBjb250YWluZXIuX2JhdGNoU2l6ZTtcbiAgICAgICAgdmFyIHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcjtcbiAgICAgICAgdmFyIHRvdGFsQ2hpbGRyZW4gPSBjaGlsZHJlbi5sZW5ndGg7XG5cbiAgICAgICAgaWYgKHRvdGFsQ2hpbGRyZW4gPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIGlmICh0b3RhbENoaWxkcmVuID4gbWF4U2l6ZSkge1xuICAgICAgICAgICAgdG90YWxDaGlsZHJlbiA9IG1heFNpemU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYnVmZmVycyA9IGNvbnRhaW5lci5fZ2xCdWZmZXJzW3JlbmRlcmVyLkNPTlRFWFRfVUlEXTtcblxuICAgICAgICBpZiAoIWJ1ZmZlcnMpIHtcbiAgICAgICAgICAgIGJ1ZmZlcnMgPSBjb250YWluZXIuX2dsQnVmZmVyc1tyZW5kZXJlci5DT05URVhUX1VJRF0gPSB0aGlzLmdlbmVyYXRlQnVmZmVycyhjb250YWluZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGJhc2VUZXh0dXJlID0gY2hpbGRyZW5bMF0uX3RleHR1cmUuYmFzZVRleHR1cmU7XG5cbiAgICAgICAgLy8gaWYgdGhlIHV2cyBoYXZlIG5vdCB1cGRhdGVkIHRoZW4gbm8gcG9pbnQgcmVuZGVyaW5nIGp1c3QgeWV0IVxuICAgICAgICB0aGlzLnJlbmRlcmVyLnNldEJsZW5kTW9kZShjb3JlLnV0aWxzLmNvcnJlY3RCbGVuZE1vZGUoY29udGFpbmVyLmJsZW5kTW9kZSwgYmFzZVRleHR1cmUucHJlbXVsdGlwbGllZEFscGhhKSk7XG5cbiAgICAgICAgdmFyIGdsID0gcmVuZGVyZXIuZ2w7XG5cbiAgICAgICAgdmFyIG0gPSBjb250YWluZXIud29ybGRUcmFuc2Zvcm0uY29weSh0aGlzLnRlbXBNYXRyaXgpO1xuXG4gICAgICAgIG0ucHJlcGVuZChyZW5kZXJlci5fYWN0aXZlUmVuZGVyVGFyZ2V0LnByb2plY3Rpb25NYXRyaXgpO1xuXG4gICAgICAgIHRoaXMuc2hhZGVyLnVuaWZvcm1zLnByb2plY3Rpb25NYXRyaXggPSBtLnRvQXJyYXkodHJ1ZSk7XG5cbiAgICAgICAgdGhpcy5zaGFkZXIudW5pZm9ybXMudUNvbG9yID0gY29yZS51dGlscy5wcmVtdWx0aXBseVJnYmEoY29udGFpbmVyLnRpbnRSZ2IsIGNvbnRhaW5lci53b3JsZEFscGhhLCB0aGlzLnNoYWRlci51bmlmb3Jtcy51Q29sb3IsIGJhc2VUZXh0dXJlLnByZW11bHRpcGxpZWRBbHBoYSk7XG5cbiAgICAgICAgLy8gbWFrZSBzdXJlIHRoZSB0ZXh0dXJlIGlzIGJvdW5kLi5cbiAgICAgICAgdGhpcy5zaGFkZXIudW5pZm9ybXMudVNhbXBsZXIgPSByZW5kZXJlci5iaW5kVGV4dHVyZShiYXNlVGV4dHVyZSk7XG5cbiAgICAgICAgdmFyIHVwZGF0ZVN0YXRpYyA9IGZhbHNlO1xuXG4gICAgICAgIC8vIG5vdyBsZXRzIHVwbG9hZCBhbmQgcmVuZGVyIHRoZSBidWZmZXJzLi5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSAwOyBpIDwgdG90YWxDaGlsZHJlbjsgaSArPSBiYXRjaFNpemUsIGogKz0gMSkge1xuICAgICAgICAgICAgdmFyIGFtb3VudCA9IHRvdGFsQ2hpbGRyZW4gLSBpO1xuXG4gICAgICAgICAgICBpZiAoYW1vdW50ID4gYmF0Y2hTaXplKSB7XG4gICAgICAgICAgICAgICAgYW1vdW50ID0gYmF0Y2hTaXplO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaiA+PSBidWZmZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmICghY29udGFpbmVyLmF1dG9SZXNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJ1ZmZlcnMucHVzaCh0aGlzLl9nZW5lcmF0ZU9uZU1vcmVCdWZmZXIoY29udGFpbmVyKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBidWZmZXIgPSBidWZmZXJzW2pdO1xuXG4gICAgICAgICAgICAvLyB3ZSBhbHdheXMgdXBsb2FkIHRoZSBkeW5hbWljXG4gICAgICAgICAgICBidWZmZXIudXBsb2FkRHluYW1pYyhjaGlsZHJlbiwgaSwgYW1vdW50KTtcblxuICAgICAgICAgICAgdmFyIGJpZCA9IGNvbnRhaW5lci5fYnVmZmVyVXBkYXRlSURzW2pdIHx8IDA7XG5cbiAgICAgICAgICAgIHVwZGF0ZVN0YXRpYyA9IHVwZGF0ZVN0YXRpYyB8fCBidWZmZXIuX3VwZGF0ZUlEIDwgYmlkO1xuICAgICAgICAgICAgLy8gd2Ugb25seSB1cGxvYWQgdGhlIHN0YXRpYyBjb250ZW50IHdoZW4gd2UgaGF2ZSB0byFcbiAgICAgICAgICAgIGlmICh1cGRhdGVTdGF0aWMpIHtcbiAgICAgICAgICAgICAgICBidWZmZXIuX3VwZGF0ZUlEID0gY29udGFpbmVyLl91cGRhdGVJRDtcbiAgICAgICAgICAgICAgICBidWZmZXIudXBsb2FkU3RhdGljKGNoaWxkcmVuLCBpLCBhbW91bnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBiaW5kIHRoZSBidWZmZXJcbiAgICAgICAgICAgIHJlbmRlcmVyLmJpbmRWYW8oYnVmZmVyLnZhbyk7XG4gICAgICAgICAgICBidWZmZXIudmFvLmRyYXcoZ2wuVFJJQU5HTEVTLCBhbW91bnQgKiA2KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIG9uZSBwYXJ0aWNsZSBidWZmZXIgZm9yIGVhY2ggY2hpbGQgaW4gdGhlIGNvbnRhaW5lciB3ZSB3YW50IHRvIHJlbmRlciBhbmQgdXBkYXRlcyBpbnRlcm5hbCBwcm9wZXJ0aWVzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuUGFydGljbGVDb250YWluZXJ9IGNvbnRhaW5lciAtIFRoZSBjb250YWluZXIgdG8gcmVuZGVyIHVzaW5nIHRoaXMgUGFydGljbGVSZW5kZXJlclxuICAgICAqIEByZXR1cm4ge1BJWEkuUGFydGljbGVCdWZmZXJbXX0gVGhlIGJ1ZmZlcnNcbiAgICAgKi9cblxuXG4gICAgUGFydGljbGVSZW5kZXJlci5wcm90b3R5cGUuZ2VuZXJhdGVCdWZmZXJzID0gZnVuY3Rpb24gZ2VuZXJhdGVCdWZmZXJzKGNvbnRhaW5lcikge1xuICAgICAgICB2YXIgZ2wgPSB0aGlzLnJlbmRlcmVyLmdsO1xuICAgICAgICB2YXIgYnVmZmVycyA9IFtdO1xuICAgICAgICB2YXIgc2l6ZSA9IGNvbnRhaW5lci5fbWF4U2l6ZTtcbiAgICAgICAgdmFyIGJhdGNoU2l6ZSA9IGNvbnRhaW5lci5fYmF0Y2hTaXplO1xuICAgICAgICB2YXIgZHluYW1pY1Byb3BlcnR5RmxhZ3MgPSBjb250YWluZXIuX3Byb3BlcnRpZXM7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyBpICs9IGJhdGNoU2l6ZSkge1xuICAgICAgICAgICAgYnVmZmVycy5wdXNoKG5ldyBfUGFydGljbGVCdWZmZXIyLmRlZmF1bHQoZ2wsIHRoaXMucHJvcGVydGllcywgZHluYW1pY1Byb3BlcnR5RmxhZ3MsIGJhdGNoU2l6ZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGJ1ZmZlcnM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgb25lIG1vcmUgcGFydGljbGUgYnVmZmVyLCBiZWNhdXNlIGNvbnRhaW5lciBoYXMgYXV0b1Jlc2l6ZSBmZWF0dXJlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuUGFydGljbGVDb250YWluZXJ9IGNvbnRhaW5lciAtIFRoZSBjb250YWluZXIgdG8gcmVuZGVyIHVzaW5nIHRoaXMgUGFydGljbGVSZW5kZXJlclxuICAgICAqIEByZXR1cm4ge1BJWEkuUGFydGljbGVCdWZmZXJ9IGdlbmVyYXRlZCBidWZmZXJcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG5cbiAgICBQYXJ0aWNsZVJlbmRlcmVyLnByb3RvdHlwZS5fZ2VuZXJhdGVPbmVNb3JlQnVmZmVyID0gZnVuY3Rpb24gX2dlbmVyYXRlT25lTW9yZUJ1ZmZlcihjb250YWluZXIpIHtcbiAgICAgICAgdmFyIGdsID0gdGhpcy5yZW5kZXJlci5nbDtcbiAgICAgICAgdmFyIGJhdGNoU2l6ZSA9IGNvbnRhaW5lci5fYmF0Y2hTaXplO1xuICAgICAgICB2YXIgZHluYW1pY1Byb3BlcnR5RmxhZ3MgPSBjb250YWluZXIuX3Byb3BlcnRpZXM7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBfUGFydGljbGVCdWZmZXIyLmRlZmF1bHQoZ2wsIHRoaXMucHJvcGVydGllcywgZHluYW1pY1Byb3BlcnR5RmxhZ3MsIGJhdGNoU2l6ZSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFVwbG9hZHMgdGhlIHZlcnRpY2llcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5EaXNwbGF5T2JqZWN0W119IGNoaWxkcmVuIC0gdGhlIGFycmF5IG9mIGRpc3BsYXkgb2JqZWN0cyB0byByZW5kZXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRJbmRleCAtIHRoZSBpbmRleCB0byBzdGFydCBmcm9tIGluIHRoZSBjaGlsZHJlbiBhcnJheVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbW91bnQgLSB0aGUgYW1vdW50IG9mIGNoaWxkcmVuIHRoYXQgd2lsbCBoYXZlIHRoZWlyIHZlcnRpY2VzIHVwbG9hZGVkXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gYXJyYXkgLSBUaGUgdmVydGljZXMgdG8gdXBsb2FkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgLSBTdHJpZGUgdG8gdXNlIGZvciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCAtIE9mZnNldCB0byBzdGFydCBhdC5cbiAgICAgKi9cblxuXG4gICAgUGFydGljbGVSZW5kZXJlci5wcm90b3R5cGUudXBsb2FkVmVydGljZXMgPSBmdW5jdGlvbiB1cGxvYWRWZXJ0aWNlcyhjaGlsZHJlbiwgc3RhcnRJbmRleCwgYW1vdW50LCBhcnJheSwgc3RyaWRlLCBvZmZzZXQpIHtcbiAgICAgICAgdmFyIHcwID0gMDtcbiAgICAgICAgdmFyIHcxID0gMDtcbiAgICAgICAgdmFyIGgwID0gMDtcbiAgICAgICAgdmFyIGgxID0gMDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFtb3VudDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgc3ByaXRlID0gY2hpbGRyZW5bc3RhcnRJbmRleCArIGldO1xuICAgICAgICAgICAgdmFyIHRleHR1cmUgPSBzcHJpdGUuX3RleHR1cmU7XG4gICAgICAgICAgICB2YXIgc3ggPSBzcHJpdGUuc2NhbGUueDtcbiAgICAgICAgICAgIHZhciBzeSA9IHNwcml0ZS5zY2FsZS55O1xuICAgICAgICAgICAgdmFyIHRyaW0gPSB0ZXh0dXJlLnRyaW07XG4gICAgICAgICAgICB2YXIgb3JpZyA9IHRleHR1cmUub3JpZztcblxuICAgICAgICAgICAgaWYgKHRyaW0pIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgc3ByaXRlIGlzIHRyaW1tZWQgYW5kIGlzIG5vdCBhIHRpbGluZ3Nwcml0ZSB0aGVuIHdlIG5lZWQgdG8gYWRkIHRoZVxuICAgICAgICAgICAgICAgIC8vIGV4dHJhIHNwYWNlIGJlZm9yZSB0cmFuc2Zvcm1pbmcgdGhlIHNwcml0ZSBjb29yZHMuLlxuICAgICAgICAgICAgICAgIHcxID0gdHJpbS54IC0gc3ByaXRlLmFuY2hvci54ICogb3JpZy53aWR0aDtcbiAgICAgICAgICAgICAgICB3MCA9IHcxICsgdHJpbS53aWR0aDtcblxuICAgICAgICAgICAgICAgIGgxID0gdHJpbS55IC0gc3ByaXRlLmFuY2hvci55ICogb3JpZy5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgaDAgPSBoMSArIHRyaW0uaGVpZ2h0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB3MCA9IG9yaWcud2lkdGggKiAoMSAtIHNwcml0ZS5hbmNob3IueCk7XG4gICAgICAgICAgICAgICAgdzEgPSBvcmlnLndpZHRoICogLXNwcml0ZS5hbmNob3IueDtcblxuICAgICAgICAgICAgICAgIGgwID0gb3JpZy5oZWlnaHQgKiAoMSAtIHNwcml0ZS5hbmNob3IueSk7XG4gICAgICAgICAgICAgICAgaDEgPSBvcmlnLmhlaWdodCAqIC1zcHJpdGUuYW5jaG9yLnk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGFycmF5W29mZnNldF0gPSB3MSAqIHN4O1xuICAgICAgICAgICAgYXJyYXlbb2Zmc2V0ICsgMV0gPSBoMSAqIHN5O1xuXG4gICAgICAgICAgICBhcnJheVtvZmZzZXQgKyBzdHJpZGVdID0gdzAgKiBzeDtcbiAgICAgICAgICAgIGFycmF5W29mZnNldCArIHN0cmlkZSArIDFdID0gaDEgKiBzeTtcblxuICAgICAgICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlICogMl0gPSB3MCAqIHN4O1xuICAgICAgICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlICogMiArIDFdID0gaDAgKiBzeTtcblxuICAgICAgICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlICogM10gPSB3MSAqIHN4O1xuICAgICAgICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlICogMyArIDFdID0gaDAgKiBzeTtcblxuICAgICAgICAgICAgb2Zmc2V0ICs9IHN0cmlkZSAqIDQ7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuRGlzcGxheU9iamVjdFtdfSBjaGlsZHJlbiAtIHRoZSBhcnJheSBvZiBkaXNwbGF5IG9iamVjdHMgdG8gcmVuZGVyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0SW5kZXggLSB0aGUgaW5kZXggdG8gc3RhcnQgZnJvbSBpbiB0aGUgY2hpbGRyZW4gYXJyYXlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYW1vdW50IC0gdGhlIGFtb3VudCBvZiBjaGlsZHJlbiB0aGF0IHdpbGwgaGF2ZSB0aGVpciBwb3NpdGlvbnMgdXBsb2FkZWRcbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBhcnJheSAtIFRoZSB2ZXJ0aWNlcyB0byB1cGxvYWQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSAtIFN0cmlkZSB0byB1c2UgZm9yIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IC0gT2Zmc2V0IHRvIHN0YXJ0IGF0LlxuICAgICAqL1xuXG5cbiAgICBQYXJ0aWNsZVJlbmRlcmVyLnByb3RvdHlwZS51cGxvYWRQb3NpdGlvbiA9IGZ1bmN0aW9uIHVwbG9hZFBvc2l0aW9uKGNoaWxkcmVuLCBzdGFydEluZGV4LCBhbW91bnQsIGFycmF5LCBzdHJpZGUsIG9mZnNldCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFtb3VudDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgc3ByaXRlUG9zaXRpb24gPSBjaGlsZHJlbltzdGFydEluZGV4ICsgaV0ucG9zaXRpb247XG5cbiAgICAgICAgICAgIGFycmF5W29mZnNldF0gPSBzcHJpdGVQb3NpdGlvbi54O1xuICAgICAgICAgICAgYXJyYXlbb2Zmc2V0ICsgMV0gPSBzcHJpdGVQb3NpdGlvbi55O1xuXG4gICAgICAgICAgICBhcnJheVtvZmZzZXQgKyBzdHJpZGVdID0gc3ByaXRlUG9zaXRpb24ueDtcbiAgICAgICAgICAgIGFycmF5W29mZnNldCArIHN0cmlkZSArIDFdID0gc3ByaXRlUG9zaXRpb24ueTtcblxuICAgICAgICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlICogMl0gPSBzcHJpdGVQb3NpdGlvbi54O1xuICAgICAgICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlICogMiArIDFdID0gc3ByaXRlUG9zaXRpb24ueTtcblxuICAgICAgICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlICogM10gPSBzcHJpdGVQb3NpdGlvbi54O1xuICAgICAgICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlICogMyArIDFdID0gc3ByaXRlUG9zaXRpb24ueTtcblxuICAgICAgICAgICAgb2Zmc2V0ICs9IHN0cmlkZSAqIDQ7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuRGlzcGxheU9iamVjdFtdfSBjaGlsZHJlbiAtIHRoZSBhcnJheSBvZiBkaXNwbGF5IG9iamVjdHMgdG8gcmVuZGVyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0SW5kZXggLSB0aGUgaW5kZXggdG8gc3RhcnQgZnJvbSBpbiB0aGUgY2hpbGRyZW4gYXJyYXlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYW1vdW50IC0gdGhlIGFtb3VudCBvZiBjaGlsZHJlbiB0aGF0IHdpbGwgaGF2ZSB0aGVpciByb3RhdGlvbiB1cGxvYWRlZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IGFycmF5IC0gVGhlIHZlcnRpY2VzIHRvIHVwbG9hZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIC0gU3RyaWRlIHRvIHVzZSBmb3IgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgLSBPZmZzZXQgdG8gc3RhcnQgYXQuXG4gICAgICovXG5cblxuICAgIFBhcnRpY2xlUmVuZGVyZXIucHJvdG90eXBlLnVwbG9hZFJvdGF0aW9uID0gZnVuY3Rpb24gdXBsb2FkUm90YXRpb24oY2hpbGRyZW4sIHN0YXJ0SW5kZXgsIGFtb3VudCwgYXJyYXksIHN0cmlkZSwgb2Zmc2V0KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW1vdW50OyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzcHJpdGVSb3RhdGlvbiA9IGNoaWxkcmVuW3N0YXJ0SW5kZXggKyBpXS5yb3RhdGlvbjtcblxuICAgICAgICAgICAgYXJyYXlbb2Zmc2V0XSA9IHNwcml0ZVJvdGF0aW9uO1xuICAgICAgICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlXSA9IHNwcml0ZVJvdGF0aW9uO1xuICAgICAgICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlICogMl0gPSBzcHJpdGVSb3RhdGlvbjtcbiAgICAgICAgICAgIGFycmF5W29mZnNldCArIHN0cmlkZSAqIDNdID0gc3ByaXRlUm90YXRpb247XG5cbiAgICAgICAgICAgIG9mZnNldCArPSBzdHJpZGUgKiA0O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLkRpc3BsYXlPYmplY3RbXX0gY2hpbGRyZW4gLSB0aGUgYXJyYXkgb2YgZGlzcGxheSBvYmplY3RzIHRvIHJlbmRlclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydEluZGV4IC0gdGhlIGluZGV4IHRvIHN0YXJ0IGZyb20gaW4gdGhlIGNoaWxkcmVuIGFycmF5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFtb3VudCAtIHRoZSBhbW91bnQgb2YgY2hpbGRyZW4gdGhhdCB3aWxsIGhhdmUgdGhlaXIgcm90YXRpb24gdXBsb2FkZWRcbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBhcnJheSAtIFRoZSB2ZXJ0aWNlcyB0byB1cGxvYWQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSAtIFN0cmlkZSB0byB1c2UgZm9yIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IC0gT2Zmc2V0IHRvIHN0YXJ0IGF0LlxuICAgICAqL1xuXG5cbiAgICBQYXJ0aWNsZVJlbmRlcmVyLnByb3RvdHlwZS51cGxvYWRVdnMgPSBmdW5jdGlvbiB1cGxvYWRVdnMoY2hpbGRyZW4sIHN0YXJ0SW5kZXgsIGFtb3VudCwgYXJyYXksIHN0cmlkZSwgb2Zmc2V0KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW1vdW50OyArK2kpIHtcbiAgICAgICAgICAgIHZhciB0ZXh0dXJlVXZzID0gY2hpbGRyZW5bc3RhcnRJbmRleCArIGldLl90ZXh0dXJlLl91dnM7XG5cbiAgICAgICAgICAgIGlmICh0ZXh0dXJlVXZzKSB7XG4gICAgICAgICAgICAgICAgYXJyYXlbb2Zmc2V0XSA9IHRleHR1cmVVdnMueDA7XG4gICAgICAgICAgICAgICAgYXJyYXlbb2Zmc2V0ICsgMV0gPSB0ZXh0dXJlVXZzLnkwO1xuXG4gICAgICAgICAgICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlXSA9IHRleHR1cmVVdnMueDE7XG4gICAgICAgICAgICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlICsgMV0gPSB0ZXh0dXJlVXZzLnkxO1xuXG4gICAgICAgICAgICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlICogMl0gPSB0ZXh0dXJlVXZzLngyO1xuICAgICAgICAgICAgICAgIGFycmF5W29mZnNldCArIHN0cmlkZSAqIDIgKyAxXSA9IHRleHR1cmVVdnMueTI7XG5cbiAgICAgICAgICAgICAgICBhcnJheVtvZmZzZXQgKyBzdHJpZGUgKiAzXSA9IHRleHR1cmVVdnMueDM7XG4gICAgICAgICAgICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlICogMyArIDFdID0gdGV4dHVyZVV2cy55MztcblxuICAgICAgICAgICAgICAgIG9mZnNldCArPSBzdHJpZGUgKiA0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPIHlvdSBrbm93IHRoaXMgY2FuIGJlIGVhc2llciFcbiAgICAgICAgICAgICAgICBhcnJheVtvZmZzZXRdID0gMDtcbiAgICAgICAgICAgICAgICBhcnJheVtvZmZzZXQgKyAxXSA9IDA7XG5cbiAgICAgICAgICAgICAgICBhcnJheVtvZmZzZXQgKyBzdHJpZGVdID0gMDtcbiAgICAgICAgICAgICAgICBhcnJheVtvZmZzZXQgKyBzdHJpZGUgKyAxXSA9IDA7XG5cbiAgICAgICAgICAgICAgICBhcnJheVtvZmZzZXQgKyBzdHJpZGUgKiAyXSA9IDA7XG4gICAgICAgICAgICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlICogMiArIDFdID0gMDtcblxuICAgICAgICAgICAgICAgIGFycmF5W29mZnNldCArIHN0cmlkZSAqIDNdID0gMDtcbiAgICAgICAgICAgICAgICBhcnJheVtvZmZzZXQgKyBzdHJpZGUgKiAzICsgMV0gPSAwO1xuXG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IHN0cmlkZSAqIDQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuRGlzcGxheU9iamVjdFtdfSBjaGlsZHJlbiAtIHRoZSBhcnJheSBvZiBkaXNwbGF5IG9iamVjdHMgdG8gcmVuZGVyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0SW5kZXggLSB0aGUgaW5kZXggdG8gc3RhcnQgZnJvbSBpbiB0aGUgY2hpbGRyZW4gYXJyYXlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYW1vdW50IC0gdGhlIGFtb3VudCBvZiBjaGlsZHJlbiB0aGF0IHdpbGwgaGF2ZSB0aGVpciByb3RhdGlvbiB1cGxvYWRlZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IGFycmF5IC0gVGhlIHZlcnRpY2VzIHRvIHVwbG9hZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIC0gU3RyaWRlIHRvIHVzZSBmb3IgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgLSBPZmZzZXQgdG8gc3RhcnQgYXQuXG4gICAgICovXG5cblxuICAgIFBhcnRpY2xlUmVuZGVyZXIucHJvdG90eXBlLnVwbG9hZFRpbnQgPSBmdW5jdGlvbiB1cGxvYWRUaW50KGNoaWxkcmVuLCBzdGFydEluZGV4LCBhbW91bnQsIGFycmF5LCBzdHJpZGUsIG9mZnNldCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFtb3VudDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgc3ByaXRlID0gY2hpbGRyZW5bc3RhcnRJbmRleCArIGldO1xuICAgICAgICAgICAgdmFyIHByZW11bHRpcGxpZWQgPSBzcHJpdGUuX3RleHR1cmUuYmFzZVRleHR1cmUucHJlbXVsdGlwbGllZEFscGhhO1xuICAgICAgICAgICAgdmFyIGFscGhhID0gc3ByaXRlLmFscGhhO1xuICAgICAgICAgICAgLy8gd2UgZG9udCBjYWxsIGV4dHJhIGZ1bmN0aW9uIGlmIGFscGhhIGlzIDEuMCwgdGhhdCdzIGZhc3RlclxuICAgICAgICAgICAgdmFyIGFyZ2IgPSBhbHBoYSA8IDEuMCAmJiBwcmVtdWx0aXBsaWVkID8gKDAsIF91dGlscy5wcmVtdWx0aXBseVRpbnQpKHNwcml0ZS5fdGludFJHQiwgYWxwaGEpIDogc3ByaXRlLl90aW50UkdCICsgKGFscGhhICogMjU1IDw8IDI0KTtcblxuICAgICAgICAgICAgYXJyYXlbb2Zmc2V0XSA9IGFyZ2I7XG4gICAgICAgICAgICBhcnJheVtvZmZzZXQgKyBzdHJpZGVdID0gYXJnYjtcbiAgICAgICAgICAgIGFycmF5W29mZnNldCArIHN0cmlkZSAqIDJdID0gYXJnYjtcbiAgICAgICAgICAgIGFycmF5W29mZnNldCArIHN0cmlkZSAqIDNdID0gYXJnYjtcblxuICAgICAgICAgICAgb2Zmc2V0ICs9IHN0cmlkZSAqIDQ7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGVzdHJveXMgdGhlIFBhcnRpY2xlUmVuZGVyZXIuXG4gICAgICpcbiAgICAgKi9cblxuXG4gICAgUGFydGljbGVSZW5kZXJlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLnJlbmRlcmVyLmdsKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmdsLmRlbGV0ZUJ1ZmZlcih0aGlzLmluZGV4QnVmZmVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9jb3JlJE9iamVjdFJlbmRlcmVyLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG5cbiAgICAgICAgdGhpcy5zaGFkZXIuZGVzdHJveSgpO1xuXG4gICAgICAgIHRoaXMuaW5kaWNlcyA9IG51bGw7XG4gICAgICAgIHRoaXMudGVtcE1hdHJpeCA9IG51bGw7XG4gICAgfTtcblxuICAgIHJldHVybiBQYXJ0aWNsZVJlbmRlcmVyO1xufShjb3JlLk9iamVjdFJlbmRlcmVyKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gUGFydGljbGVSZW5kZXJlcjtcblxuXG5jb3JlLldlYkdMUmVuZGVyZXIucmVnaXN0ZXJQbHVnaW4oJ3BhcnRpY2xlJywgUGFydGljbGVSZW5kZXJlcik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1QYXJ0aWNsZVJlbmRlcmVyLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9TaGFkZXIyID0gcmVxdWlyZSgnLi4vLi4vY29yZS9TaGFkZXInKTtcblxudmFyIF9TaGFkZXIzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU2hhZGVyMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuLyoqXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIFBJWEkuU2hhZGVyXG4gKiBAbWVtYmVyb2YgUElYSVxuICovXG52YXIgUGFydGljbGVTaGFkZXIgPSBmdW5jdGlvbiAoX1NoYWRlcikge1xuICAgIF9pbmhlcml0cyhQYXJ0aWNsZVNoYWRlciwgX1NoYWRlcik7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1BJWEkuU2hhZGVyfSBnbCAtIFRoZSB3ZWJnbCBzaGFkZXIgbWFuYWdlciB0aGlzIHNoYWRlciB3b3JrcyBmb3IuXG4gICAgICovXG4gICAgZnVuY3Rpb24gUGFydGljbGVTaGFkZXIoZ2wpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBhcnRpY2xlU2hhZGVyKTtcblxuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1NoYWRlci5jYWxsKHRoaXMsIGdsLFxuICAgICAgICAvLyB2ZXJ0ZXggc2hhZGVyXG4gICAgICAgIFsnYXR0cmlidXRlIHZlYzIgYVZlcnRleFBvc2l0aW9uOycsICdhdHRyaWJ1dGUgdmVjMiBhVGV4dHVyZUNvb3JkOycsICdhdHRyaWJ1dGUgdmVjNCBhQ29sb3I7JywgJ2F0dHJpYnV0ZSB2ZWMyIGFQb3NpdGlvbkNvb3JkOycsICdhdHRyaWJ1dGUgZmxvYXQgYVJvdGF0aW9uOycsICd1bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDsnLCAndW5pZm9ybSB2ZWM0IHVDb2xvcjsnLCAndmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7JywgJ3ZhcnlpbmcgdmVjNCB2Q29sb3I7JywgJ3ZvaWQgbWFpbih2b2lkKXsnLCAnICAgZmxvYXQgeCA9IChhVmVydGV4UG9zaXRpb24ueCkgKiBjb3MoYVJvdGF0aW9uKSAtIChhVmVydGV4UG9zaXRpb24ueSkgKiBzaW4oYVJvdGF0aW9uKTsnLCAnICAgZmxvYXQgeSA9IChhVmVydGV4UG9zaXRpb24ueCkgKiBzaW4oYVJvdGF0aW9uKSArIChhVmVydGV4UG9zaXRpb24ueSkgKiBjb3MoYVJvdGF0aW9uKTsnLCAnICAgdmVjMiB2ID0gdmVjMih4LCB5KTsnLCAnICAgdiA9IHYgKyBhUG9zaXRpb25Db29yZDsnLCAnICAgZ2xfUG9zaXRpb24gPSB2ZWM0KChwcm9qZWN0aW9uTWF0cml4ICogdmVjMyh2LCAxLjApKS54eSwgMC4wLCAxLjApOycsICcgICB2VGV4dHVyZUNvb3JkID0gYVRleHR1cmVDb29yZDsnLCAnICAgdkNvbG9yID0gYUNvbG9yICogdUNvbG9yOycsICd9J10uam9pbignXFxuJyksXG4gICAgICAgIC8vIGhlbGxvXG4gICAgICAgIFsndmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7JywgJ3ZhcnlpbmcgdmVjNCB2Q29sb3I7JywgJ3VuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyOycsICd2b2lkIG1haW4odm9pZCl7JywgJyAgdmVjNCBjb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCkgKiB2Q29sb3I7JywgJyAgZ2xfRnJhZ0NvbG9yID0gY29sb3I7JywgJ30nXS5qb2luKCdcXG4nKSkpO1xuICAgIH1cblxuICAgIHJldHVybiBQYXJ0aWNsZVNoYWRlcjtcbn0oX1NoYWRlcjMuZGVmYXVsdCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFBhcnRpY2xlU2hhZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UGFydGljbGVTaGFkZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIFJlZmVyZW5jZXM6XG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL3NpZ25cblxuaWYgKCFNYXRoLnNpZ24pIHtcbiAgICBNYXRoLnNpZ24gPSBmdW5jdGlvbiBtYXRoU2lnbih4KSB7XG4gICAgICAgIHggPSBOdW1iZXIoeCk7XG5cbiAgICAgICAgaWYgKHggPT09IDAgfHwgaXNOYU4oeCkpIHtcbiAgICAgICAgICAgIHJldHVybiB4O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHggPiAwID8gMSA6IC0xO1xuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1NYXRoLnNpZ24uanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBSZWZlcmVuY2VzOlxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTnVtYmVyL2lzSW50ZWdlclxuXG5pZiAoIU51bWJlci5pc0ludGVnZXIpIHtcbiAgICBOdW1iZXIuaXNJbnRlZ2VyID0gZnVuY3Rpb24gbnVtYmVySXNJbnRlZ2VyKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIGlzRmluaXRlKHZhbHVlKSAmJiBNYXRoLmZsb29yKHZhbHVlKSA9PT0gdmFsdWU7XG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU51bWJlci5pc0ludGVnZXIuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX29iamVjdEFzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIF9vYmplY3RBc3NpZ24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfb2JqZWN0QXNzaWduKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuaWYgKCFPYmplY3QuYXNzaWduKSB7XG4gICAgT2JqZWN0LmFzc2lnbiA9IF9vYmplY3RBc3NpZ24yLmRlZmF1bHQ7XG59IC8vIFJlZmVyZW5jZXM6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vc2luZHJlc29yaHVzL29iamVjdC1hc3NpZ25cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9hc3NpZ25cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU9iamVjdC5hc3NpZ24uanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5yZXF1aXJlKCcuL09iamVjdC5hc3NpZ24nKTtcblxucmVxdWlyZSgnLi9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUnKTtcblxucmVxdWlyZSgnLi9NYXRoLnNpZ24nKTtcblxucmVxdWlyZSgnLi9OdW1iZXIuaXNJbnRlZ2VyJyk7XG5cbmlmICghd2luZG93LkFycmF5QnVmZmVyKSB7XG4gICAgd2luZG93LkFycmF5QnVmZmVyID0gQXJyYXk7XG59XG5cbmlmICghd2luZG93LkZsb2F0MzJBcnJheSkge1xuICAgIHdpbmRvdy5GbG9hdDMyQXJyYXkgPSBBcnJheTtcbn1cblxuaWYgKCF3aW5kb3cuVWludDMyQXJyYXkpIHtcbiAgICB3aW5kb3cuVWludDMyQXJyYXkgPSBBcnJheTtcbn1cblxuaWYgKCF3aW5kb3cuVWludDE2QXJyYXkpIHtcbiAgICB3aW5kb3cuVWludDE2QXJyYXkgPSBBcnJheTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuLy8gUmVmZXJlbmNlczpcbi8vIGh0dHA6Ly9wYXVsaXJpc2guY29tLzIwMTEvcmVxdWVzdGFuaW1hdGlvbmZyYW1lLWZvci1zbWFydC1hbmltYXRpbmcvXG4vLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS8xNTc5NjcxXG4vLyBodHRwOi8vdXBkYXRlcy5odG1sNXJvY2tzLmNvbS8yMDEyLzA1L3JlcXVlc3RBbmltYXRpb25GcmFtZS1BUEktbm93LXdpdGgtc3ViLW1pbGxpc2Vjb25kLXByZWNpc2lvblxuLy8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vdGltaGFsbC80MDc4NjE0XG4vLyBodHRwczovL2dpdGh1Yi5jb20vRmluYW5jaWFsLVRpbWVzL3BvbHlmaWxsLXNlcnZpY2UvdHJlZS9tYXN0ZXIvcG9seWZpbGxzL3JlcXVlc3RBbmltYXRpb25GcmFtZVxuXG4vLyBFeHBlY3RlZCB0byBiZSB1c2VkIHdpdGggQnJvd3NlcmZpeVxuLy8gQnJvd3NlcmlmeSBhdXRvbWF0aWNhbGx5IGRldGVjdHMgdGhlIHVzZSBvZiBgZ2xvYmFsYCBhbmQgcGFzc2VzIHRoZVxuLy8gY29ycmVjdCByZWZlcmVuY2Ugb2YgYGdsb2JhbGAsIGBzZWxmYCwgYW5kIGZpbmFsbHkgYHdpbmRvd2BcblxudmFyIE9ORV9GUkFNRV9USU1FID0gMTY7XG5cbi8vIERhdGUubm93XG5pZiAoIShEYXRlLm5vdyAmJiBEYXRlLnByb3RvdHlwZS5nZXRUaW1lKSkge1xuICAgIERhdGUubm93ID0gZnVuY3Rpb24gbm93KCkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgfTtcbn1cblxuLy8gcGVyZm9ybWFuY2Uubm93XG5pZiAoIShnbG9iYWwucGVyZm9ybWFuY2UgJiYgZ2xvYmFsLnBlcmZvcm1hbmNlLm5vdykpIHtcbiAgICB2YXIgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcblxuICAgIGlmICghZ2xvYmFsLnBlcmZvcm1hbmNlKSB7XG4gICAgICAgIGdsb2JhbC5wZXJmb3JtYW5jZSA9IHt9O1xuICAgIH1cblxuICAgIGdsb2JhbC5wZXJmb3JtYW5jZS5ub3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBEYXRlLm5vdygpIC0gc3RhcnRUaW1lO1xuICAgIH07XG59XG5cbi8vIHJlcXVlc3RBbmltYXRpb25GcmFtZVxudmFyIGxhc3RUaW1lID0gRGF0ZS5ub3coKTtcbnZhciB2ZW5kb3JzID0gWydtcycsICdtb3onLCAnd2Via2l0JywgJ28nXTtcblxuZm9yICh2YXIgeCA9IDA7IHggPCB2ZW5kb3JzLmxlbmd0aCAmJiAhZ2xvYmFsLnJlcXVlc3RBbmltYXRpb25GcmFtZTsgKyt4KSB7XG4gICAgdmFyIHAgPSB2ZW5kb3JzW3hdO1xuXG4gICAgZ2xvYmFsLnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IGdsb2JhbFtwICsgJ1JlcXVlc3RBbmltYXRpb25GcmFtZSddO1xuICAgIGdsb2JhbC5jYW5jZWxBbmltYXRpb25GcmFtZSA9IGdsb2JhbFtwICsgJ0NhbmNlbEFuaW1hdGlvbkZyYW1lJ10gfHwgZ2xvYmFsW3AgKyAnQ2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lJ107XG59XG5cbmlmICghZ2xvYmFsLnJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuICAgIGdsb2JhbC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihjYWxsYmFjayArICdpcyBub3QgYSBmdW5jdGlvbicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdmFyIGRlbGF5ID0gT05FX0ZSQU1FX1RJTUUgKyBsYXN0VGltZSAtIGN1cnJlbnRUaW1lO1xuXG4gICAgICAgIGlmIChkZWxheSA8IDApIHtcbiAgICAgICAgICAgIGRlbGF5ID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxhc3RUaW1lID0gY3VycmVudFRpbWU7XG5cbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgbGFzdFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgY2FsbGJhY2socGVyZm9ybWFuY2Uubm93KCkpO1xuICAgICAgICB9LCBkZWxheSk7XG4gICAgfTtcbn1cblxuaWYgKCFnbG9iYWwuY2FuY2VsQW5pbWF0aW9uRnJhbWUpIHtcbiAgICBnbG9iYWwuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChpZCk7XG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlcXVlc3RBbmltYXRpb25GcmFtZS5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfY29yZSA9IHJlcXVpcmUoJy4uL2NvcmUnKTtcblxudmFyIGNvcmUgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfY29yZSk7XG5cbnZhciBfQ291bnRMaW1pdGVyID0gcmVxdWlyZSgnLi9saW1pdGVycy9Db3VudExpbWl0ZXInKTtcblxudmFyIF9Db3VudExpbWl0ZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQ291bnRMaW1pdGVyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIFNoYXJlZFRpY2tlciA9IGNvcmUudGlja2VyLnNoYXJlZDtcblxuLyoqXG4gKiBEZWZhdWx0IG51bWJlciBvZiB1cGxvYWRzIHBlciBmcmFtZSB1c2luZyBwcmVwYXJlIHBsdWdpbi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyb2YgUElYSS5zZXR0aW5nc1xuICogQG5hbWUgVVBMT0FEU19QRVJfRlJBTUVcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAZGVmYXVsdCA0XG4gKi9cbmNvcmUuc2V0dGluZ3MuVVBMT0FEU19QRVJfRlJBTUUgPSA0O1xuXG4vKipcbiAqIFRoZSBwcmVwYXJlIG1hbmFnZXIgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSB0byB1cGxvYWQgY29udGVudCB0byB0aGUgR1BVLiBCYXNlUHJlcGFyZSBoYW5kbGVzXG4gKiBiYXNpYyBxdWV1aW5nIGZ1bmN0aW9uYWxpdHkgYW5kIGlzIGV4dGVuZGVkIGJ5IHtAbGluayBQSVhJLnByZXBhcmUuV2ViR0xQcmVwYXJlfSBhbmQge0BsaW5rIFBJWEkucHJlcGFyZS5DYW52YXNQcmVwYXJlfVxuICogdG8gcHJvdmlkZSBwcmVwYXJhdGlvbiBjYXBhYmlsaXRpZXMgc3BlY2lmaWMgdG8gdGhlaXIgcmVzcGVjdGl2ZSByZW5kZXJlcnMuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIENyZWF0ZSBhIHNwcml0ZVxuICogY29uc3Qgc3ByaXRlID0gbmV3IFBJWEkuU3ByaXRlLmZyb21JbWFnZSgnc29tZXRoaW5nLnBuZycpO1xuICpcbiAqIC8vIExvYWQgb2JqZWN0IGludG8gR1BVXG4gKiBhcHAucmVuZGVyZXIucGx1Z2lucy5wcmVwYXJlLnVwbG9hZChzcHJpdGUsICgpID0+IHtcbiAqXG4gKiAgICAgLy9UZXh0dXJlKHMpIGhhcyBiZWVuIHVwbG9hZGVkIHRvIEdQVVxuICogICAgIGFwcC5zdGFnZS5hZGRDaGlsZChzcHJpdGUpO1xuICpcbiAqIH0pXG4gKlxuICogQGFic3RyYWN0XG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQSVhJLnByZXBhcmVcbiAqL1xuXG52YXIgQmFzZVByZXBhcmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtQSVhJLlN5c3RlbVJlbmRlcmVyfSByZW5kZXJlciAtIEEgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IHJlbmRlcmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gQmFzZVByZXBhcmUocmVuZGVyZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQmFzZVByZXBhcmUpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbGltaXRlciB0byBiZSB1c2VkIHRvIGNvbnRyb2wgaG93IHF1aWNrbHkgaXRlbXMgYXJlIHByZXBhcmVkLlxuICAgICAgICAgKiBAdHlwZSB7UElYSS5wcmVwYXJlLkNvdW50TGltaXRlcnxQSVhJLnByZXBhcmUuVGltZUxpbWl0ZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxpbWl0ZXIgPSBuZXcgX0NvdW50TGltaXRlcjIuZGVmYXVsdChjb3JlLnNldHRpbmdzLlVQTE9BRFNfUEVSX0ZSQU1FKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVmZXJlbmNlIHRvIHRoZSByZW5kZXJlci5cbiAgICAgICAgICogQHR5cGUge1BJWEkuU3lzdGVtUmVuZGVyZXJ9XG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG9ubHkgcmVhbCBkaWZmZXJlbmNlIGJldHdlZW4gQ2FudmFzUHJlcGFyZSBhbmQgV2ViR0xQcmVwYXJlIGlzIHdoYXQgdGhleSBwYXNzXG4gICAgICAgICAqIHRvIHVwbG9hZCBob29rcy4gVGhhdCBkaWZmZXJlbnQgcGFyYW1ldGVyIGlzIHN0b3JlZCBoZXJlLlxuICAgICAgICAgKiBAdHlwZSB7UElYSS5wcmVwYXJlLkNhbnZhc1ByZXBhcmV8UElYSS5XZWJHTFJlbmRlcmVyfVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnVwbG9hZEhvb2tIZWxwZXIgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb2xsZWN0aW9uIG9mIGl0ZW1zIHRvIHVwbG9hZHMgYXQgb25jZS5cbiAgICAgICAgICogQHR5cGUge0FycmF5PCo+fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5xdWV1ZSA9IFtdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb2xsZWN0aW9uIG9mIGFkZGl0aW9uYWwgaG9va3MgZm9yIGZpbmRpbmcgYXNzZXRzLlxuICAgICAgICAgKiBAdHlwZSB7QXJyYXk8RnVuY3Rpb24+fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hZGRIb29rcyA9IFtdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb2xsZWN0aW9uIG9mIGFkZGl0aW9uYWwgaG9va3MgZm9yIHByb2Nlc3NpbmcgYXNzZXRzLlxuICAgICAgICAgKiBAdHlwZSB7QXJyYXk8RnVuY3Rpb24+fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy51cGxvYWRIb29rcyA9IFtdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxsYmFjayB0byBjYWxsIGFmdGVyIGNvbXBsZXRlZC5cbiAgICAgICAgICogQHR5cGUge0FycmF5PEZ1bmN0aW9uPn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29tcGxldGVzID0gW107XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHByZXBhcmUgaXMgdGlja2luZyAocnVubmluZykuXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50aWNraW5nID0gZmFsc2U7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqICdib3VuZCcgY2FsbCBmb3IgcHJlcGFyZUl0ZW1zKCkuXG4gICAgICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGVsYXllZFRpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyB1bmxpa2VseSwgYnV0IGluIGNhc2Ugd2Ugd2VyZSBkZXN0cm95ZWQgYmV0d2VlbiB0aWNrKCkgYW5kIGRlbGF5ZWRUaWNrKClcbiAgICAgICAgICAgIGlmICghX3RoaXMucXVldWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5wcmVwYXJlSXRlbXMoKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBob29rcyB0byBmaW5kIHRoZSBjb3JyZWN0IHRleHR1cmVcbiAgICAgICAgdGhpcy5yZWdpc3RlckZpbmRIb29rKGZpbmRUZXh0KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlckZpbmRIb29rKGZpbmRUZXh0U3R5bGUpO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyRmluZEhvb2soZmluZE11bHRpcGxlQmFzZVRleHR1cmVzKTtcbiAgICAgICAgdGhpcy5yZWdpc3RlckZpbmRIb29rKGZpbmRCYXNlVGV4dHVyZSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJGaW5kSG9vayhmaW5kVGV4dHVyZSk7XG5cbiAgICAgICAgLy8gdXBsb2FkIGhvb2tzXG4gICAgICAgIHRoaXMucmVnaXN0ZXJVcGxvYWRIb29rKGRyYXdUZXh0KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlclVwbG9hZEhvb2soY2FsY3VsYXRlVGV4dFN0eWxlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGxvYWQgYWxsIHRoZSB0ZXh0dXJlcyBhbmQgZ3JhcGhpY3MgdG8gdGhlIEdQVS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258UElYSS5EaXNwbGF5T2JqZWN0fFBJWEkuQ29udGFpbmVyfFBJWEkuQmFzZVRleHR1cmV8UElYSS5UZXh0dXJlfFBJWEkuR3JhcGhpY3N8UElYSS5UZXh0fSBpdGVtIC1cbiAgICAgKiAgICAgICAgRWl0aGVyIHRoZSBjb250YWluZXIgb3IgZGlzcGxheSBvYmplY3QgdG8gc2VhcmNoIGZvciBpdGVtcyB0byB1cGxvYWQsIHRoZSBpdGVtcyB0byB1cGxvYWQgdGhlbXNlbHZlcyxcbiAgICAgKiAgICAgICAgb3IgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLCBpZiBpdGVtcyBoYXZlIGJlZW4gYWRkZWQgdXNpbmcgYHByZXBhcmUuYWRkYC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZG9uZV0gLSBPcHRpb25hbCBjYWxsYmFjayB3aGVuIGFsbCBxdWV1ZWQgdXBsb2FkcyBoYXZlIGNvbXBsZXRlZFxuICAgICAqL1xuXG5cbiAgICBCYXNlUHJlcGFyZS5wcm90b3R5cGUudXBsb2FkID0gZnVuY3Rpb24gdXBsb2FkKGl0ZW0sIGRvbmUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpdGVtID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBkb25lID0gaXRlbTtcbiAgICAgICAgICAgIGl0ZW0gPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgYSBkaXNwbGF5IG9iamVjdCwgc2VhcmNoIGZvciBpdGVtc1xuICAgICAgICAvLyB0aGF0IHdlIGNvdWxkIHVwbG9hZFxuICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgdGhpcy5hZGQoaXRlbSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHZXQgdGhlIGl0ZW1zIGZvciB1cGxvYWQgZnJvbSB0aGUgZGlzcGxheVxuICAgICAgICBpZiAodGhpcy5xdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb21wbGV0ZXMucHVzaChkb25lKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCF0aGlzLnRpY2tpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRpY2tpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIFNoYXJlZFRpY2tlci5hZGRPbmNlKHRoaXMudGljaywgdGhpcywgY29yZS5VUERBVEVfUFJJT1JJVFkuVVRJTElUWSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZG9uZSkge1xuICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEhhbmRsZSB0aWNrIHVwZGF0ZVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuXG4gICAgQmFzZVByZXBhcmUucHJvdG90eXBlLnRpY2sgPSBmdW5jdGlvbiB0aWNrKCkge1xuICAgICAgICBzZXRUaW1lb3V0KHRoaXMuZGVsYXllZFRpY2ssIDApO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBY3R1YWxseSBwcmVwYXJlIGl0ZW1zLiBUaGlzIGlzIGhhbmRsZWQgb3V0c2lkZSBvZiB0aGUgdGljayBiZWNhdXNlIGl0IHdpbGwgdGFrZSBhIHdoaWxlXG4gICAgICogYW5kIHdlIGRvIE5PVCB3YW50IHRvIGJsb2NrIHRoZSBjdXJyZW50IGFuaW1hdGlvbiBmcmFtZSBmcm9tIHJlbmRlcmluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cblxuICAgIEJhc2VQcmVwYXJlLnByb3RvdHlwZS5wcmVwYXJlSXRlbXMgPSBmdW5jdGlvbiBwcmVwYXJlSXRlbXMoKSB7XG4gICAgICAgIHRoaXMubGltaXRlci5iZWdpbkZyYW1lKCk7XG4gICAgICAgIC8vIFVwbG9hZCB0aGUgZ3JhcGhpY3NcbiAgICAgICAgd2hpbGUgKHRoaXMucXVldWUubGVuZ3RoICYmIHRoaXMubGltaXRlci5hbGxvd2VkVG9VcGxvYWQoKSkge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLnF1ZXVlWzBdO1xuICAgICAgICAgICAgdmFyIHVwbG9hZGVkID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmIChpdGVtICYmICFpdGVtLl9kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy51cGxvYWRIb29rcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy51cGxvYWRIb29rc1tpXSh0aGlzLnVwbG9hZEhvb2tIZWxwZXIsIGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGxvYWRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCF1cGxvYWRlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMucXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdlJ3JlIGZpbmlzaGVkXG4gICAgICAgIGlmICghdGhpcy5xdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMudGlja2luZyA9IGZhbHNlO1xuXG4gICAgICAgICAgICB2YXIgY29tcGxldGVzID0gdGhpcy5jb21wbGV0ZXMuc2xpY2UoMCk7XG5cbiAgICAgICAgICAgIHRoaXMuY29tcGxldGVzLmxlbmd0aCA9IDA7XG5cbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2xlbiA9IGNvbXBsZXRlcy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgICAgICAgIGNvbXBsZXRlc1tfaV0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGlmIHdlIGFyZSBub3QgZmluaXNoZWQsIG9uIHRoZSBuZXh0IHJBRiBkbyB0aGlzIGFnYWluXG4gICAgICAgICAgICBTaGFyZWRUaWNrZXIuYWRkT25jZSh0aGlzLnRpY2ssIHRoaXMsIGNvcmUuVVBEQVRFX1BSSU9SSVRZLlVUSUxJVFkpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFkZHMgaG9va3MgZm9yIGZpbmRpbmcgaXRlbXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhZGRIb29rIC0gRnVuY3Rpb24gY2FsbCB0aGF0IHRha2VzIHR3byBwYXJhbWV0ZXJzOiBgaXRlbToqLCBxdWV1ZTpBcnJheWBcbiAgICAgKiAgICAgICAgICBmdW5jdGlvbiBtdXN0IHJldHVybiBgdHJ1ZWAgaWYgaXQgd2FzIGFibGUgdG8gYWRkIGl0ZW0gdG8gdGhlIHF1ZXVlLlxuICAgICAqIEByZXR1cm4ge1BJWEkuQmFzZVByZXBhcmV9IEluc3RhbmNlIG9mIHBsdWdpbiBmb3IgY2hhaW5pbmcuXG4gICAgICovXG5cblxuICAgIEJhc2VQcmVwYXJlLnByb3RvdHlwZS5yZWdpc3RlckZpbmRIb29rID0gZnVuY3Rpb24gcmVnaXN0ZXJGaW5kSG9vayhhZGRIb29rKSB7XG4gICAgICAgIGlmIChhZGRIb29rKSB7XG4gICAgICAgICAgICB0aGlzLmFkZEhvb2tzLnB1c2goYWRkSG9vayk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQWRkcyBob29rcyBmb3IgdXBsb2FkaW5nIGl0ZW1zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gdXBsb2FkSG9vayAtIEZ1bmN0aW9uIGNhbGwgdGhhdCB0YWtlcyB0d28gcGFyYW1ldGVyczogYHByZXBhcmU6Q2FudmFzUHJlcGFyZSwgaXRlbToqYCBhbmRcbiAgICAgKiAgICAgICAgICBmdW5jdGlvbiBtdXN0IHJldHVybiBgdHJ1ZWAgaWYgaXQgd2FzIGFibGUgdG8gaGFuZGxlIHVwbG9hZCBvZiBpdGVtLlxuICAgICAqIEByZXR1cm4ge1BJWEkuQmFzZVByZXBhcmV9IEluc3RhbmNlIG9mIHBsdWdpbiBmb3IgY2hhaW5pbmcuXG4gICAgICovXG5cblxuICAgIEJhc2VQcmVwYXJlLnByb3RvdHlwZS5yZWdpc3RlclVwbG9hZEhvb2sgPSBmdW5jdGlvbiByZWdpc3RlclVwbG9hZEhvb2sodXBsb2FkSG9vaykge1xuICAgICAgICBpZiAodXBsb2FkSG9vaykge1xuICAgICAgICAgICAgdGhpcy51cGxvYWRIb29rcy5wdXNoKHVwbG9hZEhvb2spO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIE1hbnVhbGx5IGFkZCBhbiBpdGVtIHRvIHRoZSB1cGxvYWRpbmcgcXVldWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuRGlzcGxheU9iamVjdHxQSVhJLkNvbnRhaW5lcnxQSVhJLkJhc2VUZXh0dXJlfFBJWEkuVGV4dHVyZXxQSVhJLkdyYXBoaWNzfFBJWEkuVGV4dHwqfSBpdGVtIC0gT2JqZWN0IHRvXG4gICAgICogICAgICAgIGFkZCB0byB0aGUgcXVldWVcbiAgICAgKiBAcmV0dXJuIHtQSVhJLkNhbnZhc1ByZXBhcmV9IEluc3RhbmNlIG9mIHBsdWdpbiBmb3IgY2hhaW5pbmcuXG4gICAgICovXG5cblxuICAgIEJhc2VQcmVwYXJlLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQoaXRlbSkge1xuICAgICAgICAvLyBBZGQgYWRkaXRpb25hbCBob29rcyBmb3IgZmluZGluZyBlbGVtZW50cyBvbiBzcGVjaWFsXG4gICAgICAgIC8vIHR5cGVzIG9mIG9iamVjdHMgdGhhdFxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5hZGRIb29rcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuYWRkSG9va3NbaV0oaXRlbSwgdGhpcy5xdWV1ZSkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdldCBjaGlsZGVuIHJlY3Vyc2l2ZWx5XG4gICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgY29yZS5Db250YWluZXIpIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9pMiA9IGl0ZW0uY2hpbGRyZW4ubGVuZ3RoIC0gMTsgX2kyID49IDA7IF9pMi0tKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGQoaXRlbS5jaGlsZHJlbltfaTJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyB0aGUgcGx1Z2luLCBkb24ndCB1c2UgYWZ0ZXIgdGhpcy5cbiAgICAgKlxuICAgICAqL1xuXG5cbiAgICBCYXNlUHJlcGFyZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLnRpY2tpbmcpIHtcbiAgICAgICAgICAgIFNoYXJlZFRpY2tlci5yZW1vdmUodGhpcy50aWNrLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRpY2tpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hZGRIb29rcyA9IG51bGw7XG4gICAgICAgIHRoaXMudXBsb2FkSG9va3MgPSBudWxsO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5jb21wbGV0ZXMgPSBudWxsO1xuICAgICAgICB0aGlzLnF1ZXVlID0gbnVsbDtcbiAgICAgICAgdGhpcy5saW1pdGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy51cGxvYWRIb29rSGVscGVyID0gbnVsbDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEJhc2VQcmVwYXJlO1xufSgpO1xuXG4vKipcbiAqIEJ1aWx0LWluIGhvb2sgdG8gZmluZCBtdWx0aXBsZSB0ZXh0dXJlcyBmcm9tIG9iamVjdHMgbGlrZSBBbmltYXRlZFNwcml0ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7UElYSS5EaXNwbGF5T2JqZWN0fSBpdGVtIC0gRGlzcGxheSBvYmplY3QgdG8gY2hlY2tcbiAqIEBwYXJhbSB7QXJyYXk8Kj59IHF1ZXVlIC0gQ29sbGVjdGlvbiBvZiBpdGVtcyB0byB1cGxvYWRcbiAqIEByZXR1cm4ge2Jvb2xlYW59IGlmIGEgUElYSS5UZXh0dXJlIG9iamVjdCB3YXMgZm91bmQuXG4gKi9cblxuXG5leHBvcnRzLmRlZmF1bHQgPSBCYXNlUHJlcGFyZTtcbmZ1bmN0aW9uIGZpbmRNdWx0aXBsZUJhc2VUZXh0dXJlcyhpdGVtLCBxdWV1ZSkge1xuICAgIHZhciByZXN1bHQgPSBmYWxzZTtcblxuICAgIC8vIE9iamVjdHMgd2l0aCBtdXRsaXBsZSB0ZXh0dXJlc1xuICAgIGlmIChpdGVtICYmIGl0ZW0uX3RleHR1cmVzICYmIGl0ZW0uX3RleHR1cmVzLmxlbmd0aCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW0uX3RleHR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaXRlbS5fdGV4dHVyZXNbaV0gaW5zdGFuY2VvZiBjb3JlLlRleHR1cmUpIHtcbiAgICAgICAgICAgICAgICB2YXIgYmFzZVRleHR1cmUgPSBpdGVtLl90ZXh0dXJlc1tpXS5iYXNlVGV4dHVyZTtcblxuICAgICAgICAgICAgICAgIGlmIChxdWV1ZS5pbmRleE9mKGJhc2VUZXh0dXJlKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcXVldWUucHVzaChiYXNlVGV4dHVyZSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBCdWlsdC1pbiBob29rIHRvIGZpbmQgQmFzZVRleHR1cmVzIGZyb20gU3ByaXRlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtQSVhJLkRpc3BsYXlPYmplY3R9IGl0ZW0gLSBEaXNwbGF5IG9iamVjdCB0byBjaGVja1xuICogQHBhcmFtIHtBcnJheTwqPn0gcXVldWUgLSBDb2xsZWN0aW9uIG9mIGl0ZW1zIHRvIHVwbG9hZFxuICogQHJldHVybiB7Ym9vbGVhbn0gaWYgYSBQSVhJLlRleHR1cmUgb2JqZWN0IHdhcyBmb3VuZC5cbiAqL1xuZnVuY3Rpb24gZmluZEJhc2VUZXh0dXJlKGl0ZW0sIHF1ZXVlKSB7XG4gICAgLy8gT2JqZWN0cyB3aXRoIHRleHR1cmVzLCBsaWtlIFNwcml0ZXMvVGV4dFxuICAgIGlmIChpdGVtIGluc3RhbmNlb2YgY29yZS5CYXNlVGV4dHVyZSkge1xuICAgICAgICBpZiAocXVldWUuaW5kZXhPZihpdGVtKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHF1ZXVlLnB1c2goaXRlbSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQnVpbHQtaW4gaG9vayB0byBmaW5kIHRleHR1cmVzIGZyb20gb2JqZWN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtQSVhJLkRpc3BsYXlPYmplY3R9IGl0ZW0gLSBEaXNwbGF5IG9iamVjdCB0byBjaGVja1xuICogQHBhcmFtIHtBcnJheTwqPn0gcXVldWUgLSBDb2xsZWN0aW9uIG9mIGl0ZW1zIHRvIHVwbG9hZFxuICogQHJldHVybiB7Ym9vbGVhbn0gaWYgYSBQSVhJLlRleHR1cmUgb2JqZWN0IHdhcyBmb3VuZC5cbiAqL1xuZnVuY3Rpb24gZmluZFRleHR1cmUoaXRlbSwgcXVldWUpIHtcbiAgICBpZiAoaXRlbS5fdGV4dHVyZSAmJiBpdGVtLl90ZXh0dXJlIGluc3RhbmNlb2YgY29yZS5UZXh0dXJlKSB7XG4gICAgICAgIHZhciB0ZXh0dXJlID0gaXRlbS5fdGV4dHVyZS5iYXNlVGV4dHVyZTtcblxuICAgICAgICBpZiAocXVldWUuaW5kZXhPZih0ZXh0dXJlKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHF1ZXVlLnB1c2godGV4dHVyZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQnVpbHQtaW4gaG9vayB0byBkcmF3IFBJWEkuVGV4dCB0byBpdHMgdGV4dHVyZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtQSVhJLldlYkdMUmVuZGVyZXJ8UElYSS5DYW52YXNQcmVwYXJlfSBoZWxwZXIgLSBOb3QgdXNlZCBieSB0aGlzIHVwbG9hZCBoYW5kbGVyXG4gKiBAcGFyYW0ge1BJWEkuRGlzcGxheU9iamVjdH0gaXRlbSAtIEl0ZW0gdG8gY2hlY2tcbiAqIEByZXR1cm4ge2Jvb2xlYW59IElmIGl0ZW0gd2FzIHVwbG9hZGVkLlxuICovXG5mdW5jdGlvbiBkcmF3VGV4dChoZWxwZXIsIGl0ZW0pIHtcbiAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIGNvcmUuVGV4dCkge1xuICAgICAgICAvLyB1cGRhdGluZyB0ZXh0IHdpbGwgcmV0dXJuIGVhcmx5IGlmIGl0IGlzIG5vdCBkaXJ0eVxuICAgICAgICBpdGVtLnVwZGF0ZVRleHQodHJ1ZSk7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIEJ1aWx0LWluIGhvb2sgdG8gY2FsY3VsYXRlIGEgdGV4dCBzdHlsZSBmb3IgYSBQSVhJLlRleHQgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1BJWEkuV2ViR0xSZW5kZXJlcnxQSVhJLkNhbnZhc1ByZXBhcmV9IGhlbHBlciAtIE5vdCB1c2VkIGJ5IHRoaXMgdXBsb2FkIGhhbmRsZXJcbiAqIEBwYXJhbSB7UElYSS5EaXNwbGF5T2JqZWN0fSBpdGVtIC0gSXRlbSB0byBjaGVja1xuICogQHJldHVybiB7Ym9vbGVhbn0gSWYgaXRlbSB3YXMgdXBsb2FkZWQuXG4gKi9cbmZ1bmN0aW9uIGNhbGN1bGF0ZVRleHRTdHlsZShoZWxwZXIsIGl0ZW0pIHtcbiAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIGNvcmUuVGV4dFN0eWxlKSB7XG4gICAgICAgIHZhciBmb250ID0gaXRlbS50b0ZvbnRTdHJpbmcoKTtcblxuICAgICAgICBjb3JlLlRleHRNZXRyaWNzLm1lYXN1cmVGb250KGZvbnQpO1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBCdWlsdC1pbiBob29rIHRvIGZpbmQgVGV4dCBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1BJWEkuRGlzcGxheU9iamVjdH0gaXRlbSAtIERpc3BsYXkgb2JqZWN0IHRvIGNoZWNrXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBxdWV1ZSAtIENvbGxlY3Rpb24gb2YgaXRlbXMgdG8gdXBsb2FkXG4gKiBAcmV0dXJuIHtib29sZWFufSBpZiBhIFBJWEkuVGV4dCBvYmplY3Qgd2FzIGZvdW5kLlxuICovXG5mdW5jdGlvbiBmaW5kVGV4dChpdGVtLCBxdWV1ZSkge1xuICAgIGlmIChpdGVtIGluc3RhbmNlb2YgY29yZS5UZXh0KSB7XG4gICAgICAgIC8vIHB1c2ggdGhlIHRleHQgc3R5bGUgdG8gcHJlcGFyZSBpdCAtIHRoaXMgY2FuIGJlIHJlYWxseSBleHBlbnNpdmVcbiAgICAgICAgaWYgKHF1ZXVlLmluZGV4T2YoaXRlbS5zdHlsZSkgPT09IC0xKSB7XG4gICAgICAgICAgICBxdWV1ZS5wdXNoKGl0ZW0uc3R5bGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFsc28gcHVzaCB0aGUgdGV4dCBvYmplY3Qgc28gdGhhdCB3ZSBjYW4gcmVuZGVyIGl0ICh0byBjYW52YXMvdGV4dHVyZSkgaWYgbmVlZGVkXG4gICAgICAgIGlmIChxdWV1ZS5pbmRleE9mKGl0ZW0pID09PSAtMSkge1xuICAgICAgICAgICAgcXVldWUucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhbHNvIHB1c2ggdGhlIFRleHQncyB0ZXh0dXJlIGZvciB1cGxvYWQgdG8gR1BVXG4gICAgICAgIHZhciB0ZXh0dXJlID0gaXRlbS5fdGV4dHVyZS5iYXNlVGV4dHVyZTtcblxuICAgICAgICBpZiAocXVldWUuaW5kZXhPZih0ZXh0dXJlKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHF1ZXVlLnB1c2godGV4dHVyZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQnVpbHQtaW4gaG9vayB0byBmaW5kIFRleHRTdHlsZSBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1BJWEkuVGV4dFN0eWxlfSBpdGVtIC0gRGlzcGxheSBvYmplY3QgdG8gY2hlY2tcbiAqIEBwYXJhbSB7QXJyYXk8Kj59IHF1ZXVlIC0gQ29sbGVjdGlvbiBvZiBpdGVtcyB0byB1cGxvYWRcbiAqIEByZXR1cm4ge2Jvb2xlYW59IGlmIGEgUElYSS5UZXh0U3R5bGUgb2JqZWN0IHdhcyBmb3VuZC5cbiAqL1xuZnVuY3Rpb24gZmluZFRleHRTdHlsZShpdGVtLCBxdWV1ZSkge1xuICAgIGlmIChpdGVtIGluc3RhbmNlb2YgY29yZS5UZXh0U3R5bGUpIHtcbiAgICAgICAgaWYgKHF1ZXVlLmluZGV4T2YoaXRlbSkgPT09IC0xKSB7XG4gICAgICAgICAgICBxdWV1ZS5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QmFzZVByZXBhcmUuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2NvcmUgPSByZXF1aXJlKCcuLi8uLi9jb3JlJyk7XG5cbnZhciBjb3JlID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX2NvcmUpO1xuXG52YXIgX0Jhc2VQcmVwYXJlMiA9IHJlcXVpcmUoJy4uL0Jhc2VQcmVwYXJlJyk7XG5cbnZhciBfQmFzZVByZXBhcmUzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQmFzZVByZXBhcmUyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgQ0FOVkFTX1NUQVJUX1NJWkUgPSAxNjtcblxuLyoqXG4gKiBUaGUgcHJlcGFyZSBtYW5hZ2VyIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgdG8gdXBsb2FkIGNvbnRlbnQgdG8gdGhlIEdQVVxuICogVGhpcyBjYW5ub3QgYmUgZG9uZSBkaXJlY3RseSBmb3IgQ2FudmFzIGxpa2UgaW4gV2ViR0wsIGJ1dCB0aGUgZWZmZWN0IGNhbiBiZSBhY2hpZXZlZCBieSBkcmF3aW5nXG4gKiB0ZXh0dXJlcyB0byBhbiBvZmZsaW5lIGNhbnZhcy5cbiAqIFRoaXMgZHJhdyBjYWxsIHdpbGwgZm9yY2UgdGhlIHRleHR1cmUgdG8gYmUgbW92ZWQgb250byB0aGUgR1BVLlxuICpcbiAqIEFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MgaXMgYXV0b21hdGljYWxseSBjcmVhdGVkIGJ5IGRlZmF1bHQsIGFuZCBjYW4gYmUgZm91bmQgYXQgcmVuZGVyZXIucGx1Z2lucy5wcmVwYXJlXG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQSVhJLnByZXBhcmUuQmFzZVByZXBhcmVcbiAqIEBtZW1iZXJvZiBQSVhJLnByZXBhcmVcbiAqL1xuXG52YXIgQ2FudmFzUHJlcGFyZSA9IGZ1bmN0aW9uIChfQmFzZVByZXBhcmUpIHtcbiAgICBfaW5oZXJpdHMoQ2FudmFzUHJlcGFyZSwgX0Jhc2VQcmVwYXJlKTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7UElYSS5DYW52YXNSZW5kZXJlcn0gcmVuZGVyZXIgLSBBIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudCByZW5kZXJlclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIENhbnZhc1ByZXBhcmUocmVuZGVyZXIpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENhbnZhc1ByZXBhcmUpO1xuXG4gICAgICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9CYXNlUHJlcGFyZS5jYWxsKHRoaXMsIHJlbmRlcmVyKSk7XG5cbiAgICAgICAgX3RoaXMudXBsb2FkSG9va0hlbHBlciA9IF90aGlzO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAqIEFuIG9mZmxpbmUgY2FudmFzIHRvIHJlbmRlciB0ZXh0dXJlcyB0b1xuICAgICAgICAqIEB0eXBlIHtIVE1MQ2FudmFzRWxlbWVudH1cbiAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAqL1xuICAgICAgICBfdGhpcy5jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgX3RoaXMuY2FudmFzLndpZHRoID0gQ0FOVkFTX1NUQVJUX1NJWkU7XG4gICAgICAgIF90aGlzLmNhbnZhcy5oZWlnaHQgPSBDQU5WQVNfU1RBUlRfU0laRTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNvbnRleHQgdG8gdGhlIGNhbnZhc1xuICAgICAgICAqIEB0eXBlIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9XG4gICAgICAgICogQHByaXZhdGVcbiAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuY3R4ID0gX3RoaXMuY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAgICAgLy8gQWRkIHRleHR1cmVzIHRvIHVwbG9hZFxuICAgICAgICBfdGhpcy5yZWdpc3RlclVwbG9hZEhvb2sodXBsb2FkQmFzZVRleHR1cmVzKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIHRoZSBwbHVnaW4sIGRvbid0IHVzZSBhZnRlciB0aGlzLlxuICAgICAqXG4gICAgICovXG5cblxuICAgIENhbnZhc1ByZXBhcmUucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICBfQmFzZVByZXBhcmUucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5jdHggPSBudWxsO1xuICAgICAgICB0aGlzLmNhbnZhcyA9IG51bGw7XG4gICAgfTtcblxuICAgIHJldHVybiBDYW52YXNQcmVwYXJlO1xufShfQmFzZVByZXBhcmUzLmRlZmF1bHQpO1xuXG4vKipcbiAqIEJ1aWx0LWluIGhvb2sgdG8gdXBsb2FkIFBJWEkuVGV4dHVyZSBvYmplY3RzIHRvIHRoZSBHUFUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gcHJlcGFyZSAtIEluc3RhbmNlIG9mIENhbnZhc1ByZXBhcmVcbiAqIEBwYXJhbSB7Kn0gaXRlbSAtIEl0ZW0gdG8gY2hlY2tcbiAqIEByZXR1cm4ge2Jvb2xlYW59IElmIGl0ZW0gd2FzIHVwbG9hZGVkLlxuICovXG5cblxuZXhwb3J0cy5kZWZhdWx0ID0gQ2FudmFzUHJlcGFyZTtcbmZ1bmN0aW9uIHVwbG9hZEJhc2VUZXh0dXJlcyhwcmVwYXJlLCBpdGVtKSB7XG4gICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBjb3JlLkJhc2VUZXh0dXJlKSB7XG4gICAgICAgIHZhciBpbWFnZSA9IGl0ZW0uc291cmNlO1xuXG4gICAgICAgIC8vIFNvbWV0aW1lcyBpbWFnZXMgKGxpa2UgYXRsYXMgaW1hZ2VzKSByZXBvcnQgYSBzaXplIG9mIHplcm8sIGNhdXNpbmcgZXJyb3JzIG9uIHdpbmRvd3MgcGhvbmUuXG4gICAgICAgIC8vIFNvIGlmIHRoZSB3aWR0aCBvciBoZWlnaHQgaXMgZXF1YWwgdG8gemVybyB0aGVuIHVzZSB0aGUgY2FudmFzIHNpemVcbiAgICAgICAgLy8gT3RoZXJ3aXNlIHVzZSB3aGF0ZXZlciBpcyBzbWFsbGVyLCB0aGUgaW1hZ2UgZGltZW5zaW9ucyBvciB0aGUgY2FudmFzIGRpbWVuc2lvbnMuXG4gICAgICAgIHZhciBpbWFnZVdpZHRoID0gaW1hZ2Uud2lkdGggPT09IDAgPyBwcmVwYXJlLmNhbnZhcy53aWR0aCA6IE1hdGgubWluKHByZXBhcmUuY2FudmFzLndpZHRoLCBpbWFnZS53aWR0aCk7XG4gICAgICAgIHZhciBpbWFnZUhlaWdodCA9IGltYWdlLmhlaWdodCA9PT0gMCA/IHByZXBhcmUuY2FudmFzLmhlaWdodCA6IE1hdGgubWluKHByZXBhcmUuY2FudmFzLmhlaWdodCwgaW1hZ2UuaGVpZ2h0KTtcblxuICAgICAgICAvLyBPbmx5IGEgc21hbGwgc3Vic2VjdGlvbnMgaXMgcmVxdWlyZWQgdG8gYmUgZHJhd24gdG8gaGF2ZSB0aGUgd2hvbGUgdGV4dHVyZSB1cGxvYWRlZCB0byB0aGUgR1BVXG4gICAgICAgIC8vIEEgc21hbGxlciBkcmF3IGNhbiBiZSBmYXN0ZXIuXG4gICAgICAgIHByZXBhcmUuY3R4LmRyYXdJbWFnZShpbWFnZSwgMCwgMCwgaW1hZ2VXaWR0aCwgaW1hZ2VIZWlnaHQsIDAsIDAsIHByZXBhcmUuY2FudmFzLndpZHRoLCBwcmVwYXJlLmNhbnZhcy5oZWlnaHQpO1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuY29yZS5DYW52YXNSZW5kZXJlci5yZWdpc3RlclBsdWdpbigncHJlcGFyZScsIENhbnZhc1ByZXBhcmUpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2FudmFzUHJlcGFyZS5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfV2ViR0xQcmVwYXJlID0gcmVxdWlyZSgnLi93ZWJnbC9XZWJHTFByZXBhcmUnKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICd3ZWJnbCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1dlYkdMUHJlcGFyZSkuZGVmYXVsdDtcbiAgfVxufSk7XG5cbnZhciBfQ2FudmFzUHJlcGFyZSA9IHJlcXVpcmUoJy4vY2FudmFzL0NhbnZhc1ByZXBhcmUnKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdjYW52YXMnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9DYW52YXNQcmVwYXJlKS5kZWZhdWx0O1xuICB9XG59KTtcblxudmFyIF9CYXNlUHJlcGFyZSA9IHJlcXVpcmUoJy4vQmFzZVByZXBhcmUnKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdCYXNlUHJlcGFyZScsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Jhc2VQcmVwYXJlKS5kZWZhdWx0O1xuICB9XG59KTtcblxudmFyIF9Db3VudExpbWl0ZXIgPSByZXF1aXJlKCcuL2xpbWl0ZXJzL0NvdW50TGltaXRlcicpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ0NvdW50TGltaXRlcicsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0NvdW50TGltaXRlcikuZGVmYXVsdDtcbiAgfVxufSk7XG5cbnZhciBfVGltZUxpbWl0ZXIgPSByZXF1aXJlKCcuL2xpbWl0ZXJzL1RpbWVMaW1pdGVyJyk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnVGltZUxpbWl0ZXInLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9UaW1lTGltaXRlcikuZGVmYXVsdDtcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuLyoqXG4gKiBDb3VudExpbWl0ZXIgbGltaXRzIHRoZSBudW1iZXIgb2YgaXRlbXMgaGFuZGxlZCBieSBhIHtAbGluayBQSVhJLnByZXBhcmUuQmFzZVByZXBhcmV9IHRvIGEgc3BlY2lmaWVkXG4gKiBudW1iZXIgb2YgaXRlbXMgcGVyIGZyYW1lLlxuICpcbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIFBJWElcbiAqL1xudmFyIENvdW50TGltaXRlciA9IGZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhJdGVtc1BlckZyYW1lIC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGl0ZW1zIHRoYXQgY2FuIGJlIHByZXBhcmVkIGVhY2ggZnJhbWUuXG4gICAqL1xuICBmdW5jdGlvbiBDb3VudExpbWl0ZXIobWF4SXRlbXNQZXJGcmFtZSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb3VudExpbWl0ZXIpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG1heGltdW0gbnVtYmVyIG9mIGl0ZW1zIHRoYXQgY2FuIGJlIHByZXBhcmVkIGVhY2ggZnJhbWUuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLm1heEl0ZW1zUGVyRnJhbWUgPSBtYXhJdGVtc1BlckZyYW1lO1xuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgaXRlbXMgdGhhdCBjYW4gYmUgcHJlcGFyZWQgaW4gdGhlIGN1cnJlbnQgZnJhbWUuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuaXRlbXNMZWZ0ID0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNldHMgYW55IGNvdW50aW5nIHByb3BlcnRpZXMgdG8gc3RhcnQgZnJlc2ggb24gYSBuZXcgZnJhbWUuXG4gICAqL1xuXG5cbiAgQ291bnRMaW1pdGVyLnByb3RvdHlwZS5iZWdpbkZyYW1lID0gZnVuY3Rpb24gYmVnaW5GcmFtZSgpIHtcbiAgICB0aGlzLml0ZW1zTGVmdCA9IHRoaXMubWF4SXRlbXNQZXJGcmFtZTtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2tzIHRvIHNlZSBpZiBhbm90aGVyIGl0ZW0gY2FuIGJlIHVwbG9hZGVkLiBUaGlzIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbmNlIHBlciBpdGVtLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBJZiB0aGUgaXRlbSBpcyBhbGxvd2VkIHRvIGJlIHVwbG9hZGVkLlxuICAgKi9cblxuXG4gIENvdW50TGltaXRlci5wcm90b3R5cGUuYWxsb3dlZFRvVXBsb2FkID0gZnVuY3Rpb24gYWxsb3dlZFRvVXBsb2FkKCkge1xuICAgIHJldHVybiB0aGlzLml0ZW1zTGVmdC0tID4gMDtcbiAgfTtcblxuICByZXR1cm4gQ291bnRMaW1pdGVyO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBDb3VudExpbWl0ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db3VudExpbWl0ZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8qKlxuICogVGltZUxpbWl0ZXIgbGltaXRzIHRoZSBudW1iZXIgb2YgaXRlbXMgaGFuZGxlZCBieSBhIHtAbGluayBQSVhJLkJhc2VQcmVwYXJlfSB0byBhIHNwZWNpZmllZFxuICogbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBwZXIgZnJhbWUuXG4gKlxuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgUElYSVxuICovXG52YXIgVGltZUxpbWl0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWF4TWlsbGlzZWNvbmRzIC0gVGhlIG1heGltdW0gbWlsbGlzZWNvbmRzIHRoYXQgY2FuIGJlIHNwZW50IHByZXBhcmluZyBpdGVtcyBlYWNoIGZyYW1lLlxuICAgKi9cbiAgZnVuY3Rpb24gVGltZUxpbWl0ZXIobWF4TWlsbGlzZWNvbmRzKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRpbWVMaW1pdGVyKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBtYXhpbXVtIG1pbGxpc2Vjb25kcyB0aGF0IGNhbiBiZSBzcGVudCBwcmVwYXJpbmcgaXRlbXMgZWFjaCBmcmFtZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMubWF4TWlsbGlzZWNvbmRzID0gbWF4TWlsbGlzZWNvbmRzO1xuICAgIC8qKlxuICAgICAqIFRoZSBzdGFydCB0aW1lIG9mIHRoZSBjdXJyZW50IGZyYW1lLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmZyYW1lU3RhcnQgPSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc2V0cyBhbnkgY291bnRpbmcgcHJvcGVydGllcyB0byBzdGFydCBmcmVzaCBvbiBhIG5ldyBmcmFtZS5cbiAgICovXG5cblxuICBUaW1lTGltaXRlci5wcm90b3R5cGUuYmVnaW5GcmFtZSA9IGZ1bmN0aW9uIGJlZ2luRnJhbWUoKSB7XG4gICAgdGhpcy5mcmFtZVN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2tzIHRvIHNlZSBpZiBhbm90aGVyIGl0ZW0gY2FuIGJlIHVwbG9hZGVkLiBUaGlzIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbmNlIHBlciBpdGVtLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBJZiB0aGUgaXRlbSBpcyBhbGxvd2VkIHRvIGJlIHVwbG9hZGVkLlxuICAgKi9cblxuXG4gIFRpbWVMaW1pdGVyLnByb3RvdHlwZS5hbGxvd2VkVG9VcGxvYWQgPSBmdW5jdGlvbiBhbGxvd2VkVG9VcGxvYWQoKSB7XG4gICAgcmV0dXJuIERhdGUubm93KCkgLSB0aGlzLmZyYW1lU3RhcnQgPCB0aGlzLm1heE1pbGxpc2Vjb25kcztcbiAgfTtcblxuICByZXR1cm4gVGltZUxpbWl0ZXI7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFRpbWVMaW1pdGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGltZUxpbWl0ZXIuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2NvcmUgPSByZXF1aXJlKCcuLi8uLi9jb3JlJyk7XG5cbnZhciBjb3JlID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX2NvcmUpO1xuXG52YXIgX0Jhc2VQcmVwYXJlMiA9IHJlcXVpcmUoJy4uL0Jhc2VQcmVwYXJlJyk7XG5cbnZhciBfQmFzZVByZXBhcmUzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQmFzZVByZXBhcmUyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4vKipcbiAqIFRoZSBwcmVwYXJlIG1hbmFnZXIgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSB0byB1cGxvYWQgY29udGVudCB0byB0aGUgR1BVLlxuICpcbiAqIEFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MgaXMgYXV0b21hdGljYWxseSBjcmVhdGVkIGJ5IGRlZmF1bHQsIGFuZCBjYW4gYmUgZm91bmQgYXQgcmVuZGVyZXIucGx1Z2lucy5wcmVwYXJlXG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQSVhJLnByZXBhcmUuQmFzZVByZXBhcmVcbiAqIEBtZW1iZXJvZiBQSVhJLnByZXBhcmVcbiAqL1xudmFyIFdlYkdMUHJlcGFyZSA9IGZ1bmN0aW9uIChfQmFzZVByZXBhcmUpIHtcbiAgICBfaW5oZXJpdHMoV2ViR0xQcmVwYXJlLCBfQmFzZVByZXBhcmUpO1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtQSVhJLldlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gQSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgcmVuZGVyZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBXZWJHTFByZXBhcmUocmVuZGVyZXIpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFdlYkdMUHJlcGFyZSk7XG5cbiAgICAgICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0Jhc2VQcmVwYXJlLmNhbGwodGhpcywgcmVuZGVyZXIpKTtcblxuICAgICAgICBfdGhpcy51cGxvYWRIb29rSGVscGVyID0gX3RoaXMucmVuZGVyZXI7XG5cbiAgICAgICAgLy8gQWRkIHRleHR1cmVzIGFuZCBncmFwaGljcyB0byB1cGxvYWRcbiAgICAgICAgX3RoaXMucmVnaXN0ZXJGaW5kSG9vayhmaW5kR3JhcGhpY3MpO1xuICAgICAgICBfdGhpcy5yZWdpc3RlclVwbG9hZEhvb2sodXBsb2FkQmFzZVRleHR1cmVzKTtcbiAgICAgICAgX3RoaXMucmVnaXN0ZXJVcGxvYWRIb29rKHVwbG9hZEdyYXBoaWNzKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIHJldHVybiBXZWJHTFByZXBhcmU7XG59KF9CYXNlUHJlcGFyZTMuZGVmYXVsdCk7XG4vKipcbiAqIEJ1aWx0LWluIGhvb2sgdG8gdXBsb2FkIFBJWEkuVGV4dHVyZSBvYmplY3RzIHRvIHRoZSBHUFUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7UElYSS5XZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIGluc3RhbmNlIG9mIHRoZSB3ZWJnbCByZW5kZXJlclxuICogQHBhcmFtIHtQSVhJLkRpc3BsYXlPYmplY3R9IGl0ZW0gLSBJdGVtIHRvIGNoZWNrXG4gKiBAcmV0dXJuIHtib29sZWFufSBJZiBpdGVtIHdhcyB1cGxvYWRlZC5cbiAqL1xuXG5cbmV4cG9ydHMuZGVmYXVsdCA9IFdlYkdMUHJlcGFyZTtcbmZ1bmN0aW9uIHVwbG9hZEJhc2VUZXh0dXJlcyhyZW5kZXJlciwgaXRlbSkge1xuICAgIGlmIChpdGVtIGluc3RhbmNlb2YgY29yZS5CYXNlVGV4dHVyZSkge1xuICAgICAgICAvLyBpZiB0aGUgdGV4dHVyZSBhbHJlYWR5IGhhcyBhIEdMIHRleHR1cmUsIHRoZW4gdGhlIHRleHR1cmUgaGFzIGJlZW4gcHJlcGFyZWQgb3IgcmVuZGVyZWRcbiAgICAgICAgLy8gYmVmb3JlIG5vdy4gSWYgdGhlIHRleHR1cmUgY2hhbmdlZCwgdGhlbiB0aGUgY2hhbmdlciBzaG91bGQgYmUgY2FsbGluZyB0ZXh0dXJlLnVwZGF0ZSgpIHdoaWNoXG4gICAgICAgIC8vIHJldXBsb2FkcyB0aGUgdGV4dHVyZSB3aXRob3V0IG5lZWQgZm9yIHByZXBhcmluZyBpdCBhZ2FpblxuICAgICAgICBpZiAoIWl0ZW0uX2dsVGV4dHVyZXNbcmVuZGVyZXIuQ09OVEVYVF9VSURdKSB7XG4gICAgICAgICAgICByZW5kZXJlci50ZXh0dXJlTWFuYWdlci51cGRhdGVUZXh0dXJlKGl0ZW0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIEJ1aWx0LWluIGhvb2sgdG8gdXBsb2FkIFBJWEkuR3JhcGhpY3MgdG8gdGhlIEdQVS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtQSVhJLldlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gaW5zdGFuY2Ugb2YgdGhlIHdlYmdsIHJlbmRlcmVyXG4gKiBAcGFyYW0ge1BJWEkuRGlzcGxheU9iamVjdH0gaXRlbSAtIEl0ZW0gdG8gY2hlY2tcbiAqIEByZXR1cm4ge2Jvb2xlYW59IElmIGl0ZW0gd2FzIHVwbG9hZGVkLlxuICovXG5mdW5jdGlvbiB1cGxvYWRHcmFwaGljcyhyZW5kZXJlciwgaXRlbSkge1xuICAgIGlmIChpdGVtIGluc3RhbmNlb2YgY29yZS5HcmFwaGljcykge1xuICAgICAgICAvLyBpZiB0aGUgaXRlbSBpcyBub3QgZGlydHkgYW5kIGFscmVhZHkgaGFzIHdlYmdsIGRhdGEsIHRoZW4gaXQgZ290IHByZXBhcmVkIG9yIHJlbmRlcmVkXG4gICAgICAgIC8vIGJlZm9yZSBub3cgYW5kIHdlIHNob3VsZG4ndCB3YXN0ZSB0aW1lIHVwZGF0aW5nIGl0IGFnYWluXG4gICAgICAgIGlmIChpdGVtLmRpcnR5IHx8IGl0ZW0uY2xlYXJEaXJ0eSB8fCAhaXRlbS5fd2ViR0xbcmVuZGVyZXIucGx1Z2lucy5ncmFwaGljcy5DT05URVhUX1VJRF0pIHtcbiAgICAgICAgICAgIHJlbmRlcmVyLnBsdWdpbnMuZ3JhcGhpY3MudXBkYXRlR3JhcGhpY3MoaXRlbSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQnVpbHQtaW4gaG9vayB0byBmaW5kIGdyYXBoaWNzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1BJWEkuRGlzcGxheU9iamVjdH0gaXRlbSAtIERpc3BsYXkgb2JqZWN0IHRvIGNoZWNrXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBxdWV1ZSAtIENvbGxlY3Rpb24gb2YgaXRlbXMgdG8gdXBsb2FkXG4gKiBAcmV0dXJuIHtib29sZWFufSBpZiBhIFBJWEkuR3JhcGhpY3Mgb2JqZWN0IHdhcyBmb3VuZC5cbiAqL1xuZnVuY3Rpb24gZmluZEdyYXBoaWNzKGl0ZW0sIHF1ZXVlKSB7XG4gICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBjb3JlLkdyYXBoaWNzKSB7XG4gICAgICAgIHF1ZXVlLnB1c2goaXRlbSk7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5jb3JlLldlYkdMUmVuZGVyZXIucmVnaXN0ZXJQbHVnaW4oJ3ByZXBhcmUnLCBXZWJHTFByZXBhcmUpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9V2ViR0xQcmVwYXJlLmpzLm1hcCIsIid1c2Ugc3RyaWN0J1xuXG4vKipcbiAqIFJlbW92ZSBhIHJhbmdlIG9mIGl0ZW1zIGZyb20gYW4gYXJyYXlcbiAqXG4gKiBAZnVuY3Rpb24gcmVtb3ZlSXRlbXNcbiAqIEBwYXJhbSB7QXJyYXk8Kj59IGFyciBUaGUgdGFyZ2V0IGFycmF5XG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnRJZHggVGhlIGluZGV4IHRvIGJlZ2luIHJlbW92aW5nIGZyb20gKGluY2x1c2l2ZSlcbiAqIEBwYXJhbSB7bnVtYmVyfSByZW1vdmVDb3VudCBIb3cgbWFueSBpdGVtcyB0byByZW1vdmVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiByZW1vdmVJdGVtcyAoYXJyLCBzdGFydElkeCwgcmVtb3ZlQ291bnQpIHtcbiAgdmFyIGksIGxlbmd0aCA9IGFyci5sZW5ndGhcblxuICBpZiAoc3RhcnRJZHggPj0gbGVuZ3RoIHx8IHJlbW92ZUNvdW50ID09PSAwKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICByZW1vdmVDb3VudCA9IChzdGFydElkeCArIHJlbW92ZUNvdW50ID4gbGVuZ3RoID8gbGVuZ3RoIC0gc3RhcnRJZHggOiByZW1vdmVDb3VudClcblxuICB2YXIgbGVuID0gbGVuZ3RoIC0gcmVtb3ZlQ291bnRcblxuICBmb3IgKGkgPSBzdGFydElkeDsgaSA8IGxlbjsgKytpKSB7XG4gICAgYXJyW2ldID0gYXJyW2kgKyByZW1vdmVDb3VudF1cbiAgfVxuXG4gIGFyci5sZW5ndGggPSBsZW5cbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuTG9hZGVyID0gdW5kZWZpbmVkO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfbWluaVNpZ25hbHMgPSByZXF1aXJlKCdtaW5pLXNpZ25hbHMnKTtcblxudmFyIF9taW5pU2lnbmFsczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9taW5pU2lnbmFscyk7XG5cbnZhciBfcGFyc2VVcmkgPSByZXF1aXJlKCdwYXJzZS11cmknKTtcblxudmFyIF9wYXJzZVVyaTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wYXJzZVVyaSk7XG5cbnZhciBfYXN5bmMgPSByZXF1aXJlKCcuL2FzeW5jJyk7XG5cbnZhciBhc3luYyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9hc3luYyk7XG5cbnZhciBfUmVzb3VyY2UgPSByZXF1aXJlKCcuL1Jlc291cmNlJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8vIHNvbWUgY29uc3RhbnRzXG52YXIgTUFYX1BST0dSRVNTID0gMTAwO1xudmFyIHJneEV4dHJhY3RVcmxIYXNoID0gLygjW1xcdy1dKyk/JC87XG5cbi8qKlxuICogTWFuYWdlcyB0aGUgc3RhdGUgYW5kIGxvYWRpbmcgb2YgbXVsdGlwbGUgcmVzb3VyY2VzIHRvIGxvYWQuXG4gKlxuICogQGNsYXNzXG4gKi9cblxudmFyIExvYWRlciA9IGV4cG9ydHMuTG9hZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbYmFzZVVybD0nJ10gLSBUaGUgYmFzZSB1cmwgZm9yIGFsbCByZXNvdXJjZXMgbG9hZGVkIGJ5IHRoaXMgbG9hZGVyLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbY29uY3VycmVuY3k9MTBdIC0gVGhlIG51bWJlciBvZiByZXNvdXJjZXMgdG8gbG9hZCBjb25jdXJyZW50bHkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gTG9hZGVyKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIHZhciBiYXNlVXJsID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAnJztcbiAgICAgICAgdmFyIGNvbmN1cnJlbmN5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAxMDtcblxuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTG9hZGVyKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGJhc2UgdXJsIGZvciBhbGwgcmVzb3VyY2VzIGxvYWRlZCBieSB0aGlzIGxvYWRlci5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5iYXNlVXJsID0gYmFzZVVybDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHByb2dyZXNzIHBlcmNlbnQgb2YgdGhlIGxvYWRlciBnb2luZyB0aHJvdWdoIHRoZSBxdWV1ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wcm9ncmVzcyA9IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIExvYWRpbmcgc3RhdGUgb2YgdGhlIGxvYWRlciwgdHJ1ZSBpZiBpdCBpcyBjdXJyZW50bHkgbG9hZGluZyByZXNvdXJjZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxvYWRpbmcgPSBmYWxzZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBxdWVyeXN0cmluZyB0byBhcHBlbmQgdG8gZXZlcnkgVVJMIGFkZGVkIHRvIHRoZSBsb2FkZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgc2hvdWxkIGJlIGEgdmFsaWQgcXVlcnkgc3RyaW5nICp3aXRob3V0KiB0aGUgcXVlc3Rpb24tbWFyayAoYD9gKS4gVGhlIGxvYWRlciB3aWxsXG4gICAgICAgICAqIGFsc28gKm5vdCogZXNjYXBlIHZhbHVlcyBmb3IgeW91LiBNYWtlIHN1cmUgdG8gZXNjYXBlIHlvdXIgcGFyYW1ldGVycyB3aXRoXG4gICAgICAgICAqIFtgZW5jb2RlVVJJQ29tcG9uZW50YF0oaHR0cHM6Ly9tZG4uaW8vZW5jb2RlVVJJQ29tcG9uZW50KSBiZWZvcmUgYXNzaWduaW5nIHRoaXMgcHJvcGVydHkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGNvbnN0IGxvYWRlciA9IG5ldyBMb2FkZXIoKTtcbiAgICAgICAgICpcbiAgICAgICAgICogbG9hZGVyLmRlZmF1bHRRdWVyeVN0cmluZyA9ICd1c2VyPW1lJnBhc3N3b3JkPXNlY3JldCc7XG4gICAgICAgICAqXG4gICAgICAgICAqIC8vIFRoaXMgd2lsbCByZXF1ZXN0ICdpbWFnZS5wbmc/dXNlcj1tZSZwYXNzd29yZD1zZWNyZXQnXG4gICAgICAgICAqIGxvYWRlci5hZGQoJ2ltYWdlLnBuZycpLmxvYWQoKTtcbiAgICAgICAgICpcbiAgICAgICAgICogbG9hZGVyLnJlc2V0KCk7XG4gICAgICAgICAqXG4gICAgICAgICAqIC8vIFRoaXMgd2lsbCByZXF1ZXN0ICdpbWFnZS5wbmc/dj0xJnVzZXI9bWUmcGFzc3dvcmQ9c2VjcmV0J1xuICAgICAgICAgKiBsb2FkZXIuYWRkKCdpYW1nZS5wbmc/dj0xJykubG9hZCgpO1xuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRlZmF1bHRRdWVyeVN0cmluZyA9ICcnO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbWlkZGxld2FyZSB0byBydW4gYmVmb3JlIGxvYWRpbmcgZWFjaCByZXNvdXJjZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQG1lbWJlciB7ZnVuY3Rpb25bXX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2JlZm9yZU1pZGRsZXdhcmUgPSBbXTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG1pZGRsZXdhcmUgdG8gcnVuIGFmdGVyIGxvYWRpbmcgZWFjaCByZXNvdXJjZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQG1lbWJlciB7ZnVuY3Rpb25bXX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2FmdGVyTWlkZGxld2FyZSA9IFtdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdHJhY2tzIHRoZSByZXNvdXJjZXMgd2UgYXJlIGN1cnJlbnRseSBjb21wbGV0aW5nIHBhcnNpbmcgZm9yLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAbWVtYmVyIHtSZXNvdXJjZVtdfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fcmVzb3VyY2VzUGFyc2luZyA9IFtdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYF9sb2FkUmVzb3VyY2VgIGZ1bmN0aW9uIGJvdW5kIHdpdGggdGhpcyBvYmplY3QgY29udGV4dC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQG1lbWJlciB7ZnVuY3Rpb259XG4gICAgICAgICAqIEBwYXJhbSB7UmVzb3VyY2V9IHIgLSBUaGUgcmVzb3VyY2UgdG8gbG9hZFxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkIC0gVGhlIGRlcXVldWUgZnVuY3Rpb25cbiAgICAgICAgICogQHJldHVybiB7dW5kZWZpbmVkfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fYm91bmRMb2FkUmVzb3VyY2UgPSBmdW5jdGlvbiAociwgZCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9sb2FkUmVzb3VyY2UociwgZCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSByZXNvdXJjZXMgd2FpdGluZyB0byBiZSBsb2FkZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBtZW1iZXIge1Jlc291cmNlW119XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9xdWV1ZSA9IGFzeW5jLnF1ZXVlKHRoaXMuX2JvdW5kTG9hZFJlc291cmNlLCBjb25jdXJyZW5jeSk7XG5cbiAgICAgICAgdGhpcy5fcXVldWUucGF1c2UoKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQWxsIHRoZSByZXNvdXJjZXMgZm9yIHRoaXMgbG9hZGVyIGtleWVkIGJ5IG5hbWUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge29iamVjdDxzdHJpbmcsIFJlc291cmNlPn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVzb3VyY2VzID0ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc3BhdGNoZWQgb25jZSBwZXIgbG9hZGVkIG9yIGVycm9yZWQgcmVzb3VyY2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBjYWxsYmFjayBsb29rcyBsaWtlIHtAbGluayBMb2FkZXIuT25Qcm9ncmVzc1NpZ25hbH0uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge1NpZ25hbDxMb2FkZXIuT25Qcm9ncmVzc1NpZ25hbD59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uUHJvZ3Jlc3MgPSBuZXcgX21pbmlTaWduYWxzMi5kZWZhdWx0KCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc3BhdGNoZWQgb25jZSBwZXIgZXJyb3JlZCByZXNvdXJjZS5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIGNhbGxiYWNrIGxvb2tzIGxpa2Uge0BsaW5rIExvYWRlci5PbkVycm9yU2lnbmFsfS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7U2lnbmFsPExvYWRlci5PbkVycm9yU2lnbmFsPn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub25FcnJvciA9IG5ldyBfbWluaVNpZ25hbHMyLmRlZmF1bHQoKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGlzcGF0Y2hlZCBvbmNlIHBlciBsb2FkZWQgcmVzb3VyY2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBjYWxsYmFjayBsb29rcyBsaWtlIHtAbGluayBMb2FkZXIuT25Mb2FkU2lnbmFsfS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7U2lnbmFsPExvYWRlci5PbkxvYWRTaWduYWw+fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vbkxvYWQgPSBuZXcgX21pbmlTaWduYWxzMi5kZWZhdWx0KCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc3BhdGNoZWQgd2hlbiB0aGUgbG9hZGVyIGJlZ2lucyB0byBwcm9jZXNzIHRoZSBxdWV1ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIGNhbGxiYWNrIGxvb2tzIGxpa2Uge0BsaW5rIExvYWRlci5PblN0YXJ0U2lnbmFsfS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7U2lnbmFsPExvYWRlci5PblN0YXJ0U2lnbmFsPn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub25TdGFydCA9IG5ldyBfbWluaVNpZ25hbHMyLmRlZmF1bHQoKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGlzcGF0Y2hlZCB3aGVuIHRoZSBxdWV1ZWQgcmVzb3VyY2VzIGFsbCBsb2FkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgY2FsbGJhY2sgbG9va3MgbGlrZSB7QGxpbmsgTG9hZGVyLk9uQ29tcGxldGVTaWduYWx9LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtTaWduYWw8TG9hZGVyLk9uQ29tcGxldGVTaWduYWw+fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vbkNvbXBsZXRlID0gbmV3IF9taW5pU2lnbmFsczIuZGVmYXVsdCgpO1xuXG4gICAgICAgIC8vIEFkZCBkZWZhdWx0IGJlZm9yZSBtaWRkbGV3YXJlXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTG9hZGVyLl9kZWZhdWx0QmVmb3JlTWlkZGxld2FyZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdGhpcy5wcmUoTG9hZGVyLl9kZWZhdWx0QmVmb3JlTWlkZGxld2FyZVtpXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgZGVmYXVsdCBhZnRlciBtaWRkbGV3YXJlXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBMb2FkZXIuX2RlZmF1bHRBZnRlck1pZGRsZXdhcmUubGVuZ3RoOyArK19pKSB7XG4gICAgICAgICAgICB0aGlzLnVzZShMb2FkZXIuX2RlZmF1bHRBZnRlck1pZGRsZXdhcmVbX2ldKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdoZW4gdGhlIHByb2dyZXNzIGNoYW5nZXMgdGhlIGxvYWRlciBhbmQgcmVzb3VyY2UgYXJlIGRpc2FwdGNoZWQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTG9hZGVyXG4gICAgICogQGNhbGxiYWNrIE9uUHJvZ3Jlc3NTaWduYWxcbiAgICAgKiBAcGFyYW0ge0xvYWRlcn0gbG9hZGVyIC0gVGhlIGxvYWRlciB0aGUgcHJvZ3Jlc3MgaXMgYWR2YW5jaW5nIG9uLlxuICAgICAqIEBwYXJhbSB7UmVzb3VyY2V9IHJlc291cmNlIC0gVGhlIHJlc291cmNlIHRoYXQgaGFzIGNvbXBsZXRlZCBvciBmYWlsZWQgdG8gY2F1c2UgdGhlIHByb2dyZXNzIHRvIGFkdmFuY2UuXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGFuIGVycm9yIG9jY3VycnMgdGhlIGxvYWRlciBhbmQgcmVzb3VyY2UgYXJlIGRpc2FwdGNoZWQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTG9hZGVyXG4gICAgICogQGNhbGxiYWNrIE9uRXJyb3JTaWduYWxcbiAgICAgKiBAcGFyYW0ge0xvYWRlcn0gbG9hZGVyIC0gVGhlIGxvYWRlciB0aGUgZXJyb3IgaGFwcGVuZWQgaW4uXG4gICAgICogQHBhcmFtIHtSZXNvdXJjZX0gcmVzb3VyY2UgLSBUaGUgcmVzb3VyY2UgdGhhdCBjYXVzZWQgdGhlIGVycm9yLlxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogV2hlbiBhIGxvYWQgY29tcGxldGVzIHRoZSBsb2FkZXIgYW5kIHJlc291cmNlIGFyZSBkaXNhcHRjaGVkLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIExvYWRlclxuICAgICAqIEBjYWxsYmFjayBPbkxvYWRTaWduYWxcbiAgICAgKiBAcGFyYW0ge0xvYWRlcn0gbG9hZGVyIC0gVGhlIGxvYWRlciB0aGF0IGxhb2RlZCB0aGUgcmVzb3VyY2UuXG4gICAgICogQHBhcmFtIHtSZXNvdXJjZX0gcmVzb3VyY2UgLSBUaGUgcmVzb3VyY2UgdGhhdCBoYXMgY29tcGxldGVkIGxvYWRpbmcuXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRoZSBsb2FkZXIgc3RhcnRzIGxvYWRpbmcgcmVzb3VyY2VzIGl0IGRpc3BhdGNoZXMgdGhpcyBjYWxsYmFjay5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBMb2FkZXJcbiAgICAgKiBAY2FsbGJhY2sgT25TdGFydFNpZ25hbFxuICAgICAqIEBwYXJhbSB7TG9hZGVyfSBsb2FkZXIgLSBUaGUgbG9hZGVyIHRoYXQgaGFzIHN0YXJ0ZWQgbG9hZGluZyByZXNvdXJjZXMuXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRoZSBsb2FkZXIgY29tcGxldGVzIGxvYWRpbmcgcmVzb3VyY2VzIGl0IGRpc3BhdGNoZXMgdGhpcyBjYWxsYmFjay5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBMb2FkZXJcbiAgICAgKiBAY2FsbGJhY2sgT25Db21wbGV0ZVNpZ25hbFxuICAgICAqIEBwYXJhbSB7TG9hZGVyfSBsb2FkZXIgLSBUaGUgbG9hZGVyIHRoYXQgaGFzIGZpbmlzaGVkIGxvYWRpbmcgcmVzb3VyY2VzLlxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogT3B0aW9ucyBmb3IgYSBjYWxsIHRvIGAuYWRkKClgLlxuICAgICAqXG4gICAgICogQHNlZSBMb2FkZXIjYWRkXG4gICAgICpcbiAgICAgKiBAdHlwZWRlZiB7b2JqZWN0fSBJQWRkT3B0aW9uc1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbbmFtZV0gLSBUaGUgbmFtZSBvZiB0aGUgcmVzb3VyY2UgdG8gbG9hZCwgaWYgbm90IHBhc3NlZCB0aGUgdXJsIGlzIHVzZWQuXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtrZXldIC0gQWxpYXMgZm9yIGBuYW1lYC5cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3VybF0gLSBUaGUgdXJsIGZvciB0aGlzIHJlc291cmNlLCByZWxhdGl2ZSB0byB0aGUgYmFzZVVybCBvZiB0aGlzIGxvYWRlci5cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ3xib29sZWFufSBbY3Jvc3NPcmlnaW5dIC0gSXMgdGhpcyByZXF1ZXN0IGNyb3NzLW9yaWdpbj8gRGVmYXVsdCBpcyB0b1xuICAgICAqICAgICAgZGV0ZXJtaW5lIGF1dG9tYXRpY2FsbHkuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IFt0aW1lb3V0PTBdIC0gQSB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcyBmb3IgdGhlIGxvYWQuIElmIHRoZSBsb2FkIHRha2VzXG4gICAgICogICAgICBsb25nZXIgdGhhbiB0aGlzIHRpbWUgaXQgaXMgY2FuY2VsbGVkIGFuZCB0aGUgbG9hZCBpcyBjb25zaWRlcmVkIGEgZmFpbHVyZS4gSWYgdGhpcyB2YWx1ZSBpc1xuICAgICAqICAgICAgc2V0IHRvIGAwYCB0aGVuIHRoZXJlIGlzIG5vIGV4cGxpY2l0IHRpbWVvdXQuXG4gICAgICogQHByb3BlcnR5IHtSZXNvdXJjZS5MT0FEX1RZUEV9IFtsb2FkVHlwZT1SZXNvdXJjZS5MT0FEX1RZUEUuWEhSXSAtIEhvdyBzaG91bGQgdGhpcyByZXNvdXJjZVxuICAgICAqICAgICAgYmUgbG9hZGVkP1xuICAgICAqIEBwcm9wZXJ0eSB7UmVzb3VyY2UuWEhSX1JFU1BPTlNFX1RZUEV9IFt4aHJUeXBlPVJlc291cmNlLlhIUl9SRVNQT05TRV9UWVBFLkRFRkFVTFRdIC0gSG93XG4gICAgICogICAgICBzaG91bGQgdGhlIGRhdGEgYmVpbmcgbG9hZGVkIGJlIGludGVycHJldGVkIHdoZW4gdXNpbmcgWEhSP1xuICAgICAqIEBwcm9wZXJ0eSB7UmVzb3VyY2UuT25Db21wbGV0ZVNpZ25hbH0gW29uQ29tcGxldGVdIC0gQ2FsbGJhY2sgdG8gYWRkIGFuIGFuIG9uQ29tcGxldGUgc2lnbmFsIGlzdGVuZXIuXG4gICAgICogQHByb3BlcnR5IHtSZXNvdXJjZS5PbkNvbXBsZXRlU2lnbmFsfSBbY2FsbGJhY2tdIC0gQWxpYXMgZm9yIGBvbkNvbXBsZXRlYC5cbiAgICAgKiBAcHJvcGVydHkge1Jlc291cmNlLklNZXRhZGF0YX0gW21ldGFkYXRhXSAtIEV4dHJhIGNvbmZpZ3VyYXRpb24gZm9yIG1pZGRsZXdhcmUgYW5kIHRoZSBSZXNvdXJjZSBvYmplY3QuXG4gICAgICovXG5cbiAgICAvKiBlc2xpbnQtZGlzYWJsZSByZXF1aXJlLWpzZG9jLHZhbGlkLWpzZG9jICovXG4gICAgLyoqXG4gICAgICogQWRkcyBhIHJlc291cmNlIChvciBtdWx0aXBsZSByZXNvdXJjZXMpIHRvIHRoZSBsb2FkZXIgcXVldWUuXG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGNhbiB0YWtlIGEgd2lkZSB2YXJpZXR5IG9mIGRpZmZlcmVudCBwYXJhbWV0ZXJzLiBUaGUgb25seSB0aGluZyB0aGF0IGlzIGFsd2F5c1xuICAgICAqIHJlcXVpcmVkIHRoZSB1cmwgdG8gbG9hZC4gQWxsIHRoZSBmb2xsb3dpbmcgd2lsbCB3b3JrOlxuICAgICAqXG4gICAgICogYGBganNcbiAgICAgKiBsb2FkZXJcbiAgICAgKiAgICAgLy8gbm9ybWFsIHBhcmFtIHN5bnRheFxuICAgICAqICAgICAuYWRkKCdrZXknLCAnaHR0cDovLy4uLicsIGZ1bmN0aW9uICgpIHt9KVxuICAgICAqICAgICAuYWRkKCdodHRwOi8vLi4uJywgZnVuY3Rpb24gKCkge30pXG4gICAgICogICAgIC5hZGQoJ2h0dHA6Ly8uLi4nKVxuICAgICAqXG4gICAgICogICAgIC8vIG9iamVjdCBzeW50YXhcbiAgICAgKiAgICAgLmFkZCh7XG4gICAgICogICAgICAgICBuYW1lOiAna2V5MicsXG4gICAgICogICAgICAgICB1cmw6ICdodHRwOi8vLi4uJ1xuICAgICAqICAgICB9LCBmdW5jdGlvbiAoKSB7fSlcbiAgICAgKiAgICAgLmFkZCh7XG4gICAgICogICAgICAgICB1cmw6ICdodHRwOi8vLi4uJ1xuICAgICAqICAgICB9LCBmdW5jdGlvbiAoKSB7fSlcbiAgICAgKiAgICAgLmFkZCh7XG4gICAgICogICAgICAgICBuYW1lOiAna2V5MycsXG4gICAgICogICAgICAgICB1cmw6ICdodHRwOi8vLi4uJ1xuICAgICAqICAgICAgICAgb25Db21wbGV0ZTogZnVuY3Rpb24gKCkge31cbiAgICAgKiAgICAgfSlcbiAgICAgKiAgICAgLmFkZCh7XG4gICAgICogICAgICAgICB1cmw6ICdodHRwczovLy4uLicsXG4gICAgICogICAgICAgICBvbkNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7fSxcbiAgICAgKiAgICAgICAgIGNyb3NzT3JpZ2luOiB0cnVlXG4gICAgICogICAgIH0pXG4gICAgICpcbiAgICAgKiAgICAgLy8geW91IGNhbiBhbHNvIHBhc3MgYW4gYXJyYXkgb2Ygb2JqZWN0cyBvciB1cmxzIG9yIGJvdGhcbiAgICAgKiAgICAgLmFkZChbXG4gICAgICogICAgICAgICB7IG5hbWU6ICdrZXk0JywgdXJsOiAnaHR0cDovLy4uLicsIG9uQ29tcGxldGU6IGZ1bmN0aW9uICgpIHt9IH0sXG4gICAgICogICAgICAgICB7IHVybDogJ2h0dHA6Ly8uLi4nLCBvbkNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7fSB9LFxuICAgICAqICAgICAgICAgJ2h0dHA6Ly8uLi4nXG4gICAgICogICAgIF0pXG4gICAgICpcbiAgICAgKiAgICAgLy8gYW5kIHlvdSBjYW4gdXNlIGJvdGggcGFyYW1zIGFuZCBvcHRpb25zXG4gICAgICogICAgIC5hZGQoJ2tleScsICdodHRwOi8vLi4uJywgeyBjcm9zc09yaWdpbjogdHJ1ZSB9LCBmdW5jdGlvbiAoKSB7fSlcbiAgICAgKiAgICAgLmFkZCgnaHR0cDovLy4uLicsIHsgY3Jvc3NPcmlnaW46IHRydWUgfSwgZnVuY3Rpb24gKCkge30pO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHZhcmlhdGlvbiAxXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgcmVzb3VyY2UgdG8gbG9hZC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIC0gVGhlIHVybCBmb3IgdGhpcyByZXNvdXJjZSwgcmVsYXRpdmUgdG8gdGhlIGJhc2VVcmwgb2YgdGhpcyBsb2FkZXIuXG4gICAgICogQHBhcmFtIHtSZXNvdXJjZS5PbkNvbXBsZXRlU2lnbmFsfSBbY2FsbGJhY2tdIC0gRnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoaXMgc3BlY2lmaWMgcmVzb3VyY2UgY29tcGxldGVzIGxvYWRpbmcuXG4gICAgICogQHJldHVybiB7dGhpc30gUmV0dXJucyBpdHNlbGYuXG4gICAgICovIC8qKlxuICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAqIEB2YXJpYXRpb24gMlxuICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHJlc291cmNlIHRvIGxvYWQuXG4gICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHVybCAtIFRoZSB1cmwgZm9yIHRoaXMgcmVzb3VyY2UsIHJlbGF0aXZlIHRvIHRoZSBiYXNlVXJsIG9mIHRoaXMgbG9hZGVyLlxuICAgICAgICAqIEBwYXJhbSB7SUFkZE9wdGlvbnN9IFtvcHRpb25zXSAtIFRoZSBvcHRpb25zIGZvciB0aGUgbG9hZC5cbiAgICAgICAgKiBAcGFyYW0ge1Jlc291cmNlLk9uQ29tcGxldGVTaWduYWx9IFtjYWxsYmFja10gLSBGdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhpcyBzcGVjaWZpYyByZXNvdXJjZSBjb21wbGV0ZXMgbG9hZGluZy5cbiAgICAgICAgKiBAcmV0dXJuIHt0aGlzfSBSZXR1cm5zIGl0c2VsZi5cbiAgICAgICAgKi8gLyoqXG4gICAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAgICogQHZhcmlhdGlvbiAzXG4gICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHVybCAtIFRoZSB1cmwgZm9yIHRoaXMgcmVzb3VyY2UsIHJlbGF0aXZlIHRvIHRoZSBiYXNlVXJsIG9mIHRoaXMgbG9hZGVyLlxuICAgICAgICAgICAqIEBwYXJhbSB7UmVzb3VyY2UuT25Db21wbGV0ZVNpZ25hbH0gW2NhbGxiYWNrXSAtIEZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGlzIHNwZWNpZmljIHJlc291cmNlIGNvbXBsZXRlcyBsb2FkaW5nLlxuICAgICAgICAgICAqIEByZXR1cm4ge3RoaXN9IFJldHVybnMgaXRzZWxmLlxuICAgICAgICAgICAqLyAvKipcbiAgICAgICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICAgICAgKiBAdmFyaWF0aW9uIDRcbiAgICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIC0gVGhlIHVybCBmb3IgdGhpcyByZXNvdXJjZSwgcmVsYXRpdmUgdG8gdGhlIGJhc2VVcmwgb2YgdGhpcyBsb2FkZXIuXG4gICAgICAgICAgICAgICogQHBhcmFtIHtJQWRkT3B0aW9uc30gW29wdGlvbnNdIC0gVGhlIG9wdGlvbnMgZm9yIHRoZSBsb2FkLlxuICAgICAgICAgICAgICAqIEBwYXJhbSB7UmVzb3VyY2UuT25Db21wbGV0ZVNpZ25hbH0gW2NhbGxiYWNrXSAtIEZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGlzIHNwZWNpZmljIHJlc291cmNlIGNvbXBsZXRlcyBsb2FkaW5nLlxuICAgICAgICAgICAgICAqIEByZXR1cm4ge3RoaXN9IFJldHVybnMgaXRzZWxmLlxuICAgICAgICAgICAgICAqLyAvKipcbiAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgKiBAdmFyaWF0aW9uIDVcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge0lBZGRPcHRpb25zfSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIHRoZSBsb2FkLiBUaGlzIG9iamVjdCBtdXN0IGNvbnRhaW4gYSBgdXJsYCBwcm9wZXJ0eS5cbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge1Jlc291cmNlLk9uQ29tcGxldGVTaWduYWx9IFtjYWxsYmFja10gLSBGdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhpcyBzcGVjaWZpYyByZXNvdXJjZSBjb21wbGV0ZXMgbG9hZGluZy5cbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHt0aGlzfSBSZXR1cm5zIGl0c2VsZi5cbiAgICAgICAgICAgICAgICAgKi8gLyoqXG4gICAgICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgICAgICogQHZhcmlhdGlvbiA2XG4gICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheTxJQWRkT3B0aW9uc3xzdHJpbmc+fSByZXNvdXJjZXMgLSBBbiBhcnJheSBvZiByZXNvdXJjZXMgdG8gbG9hZCwgd2hlcmUgZWFjaCBpc1xuICAgICAgICAgICAgICAgICAgICAqICAgICAgZWl0aGVyIGFuIG9iamVjdCB3aXRoIHRoZSBvcHRpb25zIG9yIGEgc3RyaW5nIHVybC4gSWYgeW91IHBhc3MgYW4gb2JqZWN0LCBpdCBtdXN0IGNvbnRhaW4gYSBgdXJsYCBwcm9wZXJ0eS5cbiAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge1Jlc291cmNlLk9uQ29tcGxldGVTaWduYWx9IFtjYWxsYmFja10gLSBGdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhpcyBzcGVjaWZpYyByZXNvdXJjZSBjb21wbGV0ZXMgbG9hZGluZy5cbiAgICAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHt0aGlzfSBSZXR1cm5zIGl0c2VsZi5cbiAgICAgICAgICAgICAgICAgICAgKi9cblxuXG4gICAgTG9hZGVyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQobmFtZSwgdXJsLCBvcHRpb25zLCBjYikge1xuICAgICAgICAvLyBzcGVjaWFsIGNhc2Ugb2YgYW4gYXJyYXkgb2Ygb2JqZWN0cyBvciB1cmxzXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG5hbWUpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZChuYW1lW2ldKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBhbiBvYmplY3QgaXMgcGFzc2VkIGluc3RlYWQgb2YgcGFyYW1zXG4gICAgICAgIGlmICgodHlwZW9mIG5hbWUgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKG5hbWUpKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGNiID0gdXJsIHx8IG5hbWUuY2FsbGJhY2sgfHwgbmFtZS5vbkNvbXBsZXRlO1xuICAgICAgICAgICAgb3B0aW9ucyA9IG5hbWU7XG4gICAgICAgICAgICB1cmwgPSBuYW1lLnVybDtcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lLm5hbWUgfHwgbmFtZS5rZXkgfHwgbmFtZS51cmw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjYXNlIHdoZXJlIG5vIG5hbWUgaXMgcGFzc2VkIHNoaWZ0IGFsbCBhcmdzIG92ZXIgYnkgb25lLlxuICAgICAgICBpZiAodHlwZW9mIHVybCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNiID0gb3B0aW9ucztcbiAgICAgICAgICAgIG9wdGlvbnMgPSB1cmw7XG4gICAgICAgICAgICB1cmwgPSBuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbm93IHRoYXQgd2Ugc2hpZnRlZCBtYWtlIHN1cmUgd2UgaGF2ZSBhIHByb3BlciB1cmwuXG4gICAgICAgIGlmICh0eXBlb2YgdXJsICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyB1cmwgcGFzc2VkIHRvIGFkZCByZXNvdXJjZSB0byBsb2FkZXIuJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBvcHRpb25zIGFyZSBvcHRpb25hbCBzbyBwZW9wbGUgbWlnaHQgcGFzcyBhIGZ1bmN0aW9uIGFuZCBubyBvcHRpb25zXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2IgPSBvcHRpb25zO1xuICAgICAgICAgICAgb3B0aW9ucyA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBsb2FkaW5nIGFscmVhZHkgeW91IGNhbiBvbmx5IGFkZCByZXNvdXJjZXMgdGhhdCBoYXZlIGEgcGFyZW50LlxuICAgICAgICBpZiAodGhpcy5sb2FkaW5nICYmICghb3B0aW9ucyB8fCAhb3B0aW9ucy5wYXJlbnRSZXNvdXJjZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGFkZCByZXNvdXJjZXMgd2hpbGUgdGhlIGxvYWRlciBpcyBydW5uaW5nLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2hlY2sgaWYgcmVzb3VyY2UgYWxyZWFkeSBleGlzdHMuXG4gICAgICAgIGlmICh0aGlzLnJlc291cmNlc1tuYW1lXSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZXNvdXJjZSBuYW1lZCBcIicgKyBuYW1lICsgJ1wiIGFscmVhZHkgZXhpc3RzLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIGJhc2UgdXJsIGlmIHRoaXMgaXNuJ3QgYW4gYWJzb2x1dGUgdXJsXG4gICAgICAgIHVybCA9IHRoaXMuX3ByZXBhcmVVcmwodXJsKTtcblxuICAgICAgICAvLyBjcmVhdGUgdGhlIHN0b3JlIHRoZSByZXNvdXJjZVxuICAgICAgICB0aGlzLnJlc291cmNlc1tuYW1lXSA9IG5ldyBfUmVzb3VyY2UuUmVzb3VyY2UobmFtZSwgdXJsLCBvcHRpb25zKTtcblxuICAgICAgICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLnJlc291cmNlc1tuYW1lXS5vbkFmdGVyTWlkZGxld2FyZS5vbmNlKGNiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIGFjdGl2ZWx5IGxvYWRpbmcsIG1ha2Ugc3VyZSB0byBhZGp1c3QgcHJvZ3Jlc3MgY2h1bmtzIGZvciB0aGF0IHBhcmVudCBhbmQgaXRzIGNoaWxkcmVuXG4gICAgICAgIGlmICh0aGlzLmxvYWRpbmcpIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSBvcHRpb25zLnBhcmVudFJlc291cmNlO1xuICAgICAgICAgICAgdmFyIGluY29tcGxldGVDaGlsZHJlbiA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBwYXJlbnQuY2hpbGRyZW4ubGVuZ3RoOyArK19pMikge1xuICAgICAgICAgICAgICAgIGlmICghcGFyZW50LmNoaWxkcmVuW19pMl0uaXNDb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgICAgICBpbmNvbXBsZXRlQ2hpbGRyZW4ucHVzaChwYXJlbnQuY2hpbGRyZW5bX2kyXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZnVsbENodW5rID0gcGFyZW50LnByb2dyZXNzQ2h1bmsgKiAoaW5jb21wbGV0ZUNoaWxkcmVuLmxlbmd0aCArIDEpOyAvLyArMSBmb3IgcGFyZW50XG4gICAgICAgICAgICB2YXIgZWFjaENodW5rID0gZnVsbENodW5rIC8gKGluY29tcGxldGVDaGlsZHJlbi5sZW5ndGggKyAyKTsgLy8gKzIgZm9yIHBhcmVudCAmIG5ldyBjaGlsZFxuXG4gICAgICAgICAgICBwYXJlbnQuY2hpbGRyZW4ucHVzaCh0aGlzLnJlc291cmNlc1tuYW1lXSk7XG4gICAgICAgICAgICBwYXJlbnQucHJvZ3Jlc3NDaHVuayA9IGVhY2hDaHVuaztcblxuICAgICAgICAgICAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgaW5jb21wbGV0ZUNoaWxkcmVuLmxlbmd0aDsgKytfaTMpIHtcbiAgICAgICAgICAgICAgICBpbmNvbXBsZXRlQ2hpbGRyZW5bX2kzXS5wcm9ncmVzc0NodW5rID0gZWFjaENodW5rO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnJlc291cmNlc1tuYW1lXS5wcm9ncmVzc0NodW5rID0gZWFjaENodW5rO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIHRoZSByZXNvdXJjZSB0byB0aGUgcXVldWVcbiAgICAgICAgdGhpcy5fcXVldWUucHVzaCh0aGlzLnJlc291cmNlc1tuYW1lXSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIHJlcXVpcmUtanNkb2MsdmFsaWQtanNkb2MgKi9cblxuICAgIC8qKlxuICAgICAqIFNldHMgdXAgYSBtaWRkbGV3YXJlIGZ1bmN0aW9uIHRoYXQgd2lsbCBydW4gKmJlZm9yZSogdGhlXG4gICAgICogcmVzb3VyY2UgaXMgbG9hZGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZm4gLSBUaGUgbWlkZGxld2FyZSBmdW5jdGlvbiB0byByZWdpc3Rlci5cbiAgICAgKiBAcmV0dXJuIHt0aGlzfSBSZXR1cm5zIGl0c2VsZi5cbiAgICAgKi9cblxuXG4gICAgTG9hZGVyLnByb3RvdHlwZS5wcmUgPSBmdW5jdGlvbiBwcmUoZm4pIHtcbiAgICAgICAgdGhpcy5fYmVmb3JlTWlkZGxld2FyZS5wdXNoKGZuKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0cyB1cCBhIG1pZGRsZXdhcmUgZnVuY3Rpb24gdGhhdCB3aWxsIHJ1biAqYWZ0ZXIqIHRoZVxuICAgICAqIHJlc291cmNlIGlzIGxvYWRlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIC0gVGhlIG1pZGRsZXdhcmUgZnVuY3Rpb24gdG8gcmVnaXN0ZXIuXG4gICAgICogQHJldHVybiB7dGhpc30gUmV0dXJucyBpdHNlbGYuXG4gICAgICovXG5cblxuICAgIExvYWRlci5wcm90b3R5cGUudXNlID0gZnVuY3Rpb24gdXNlKGZuKSB7XG4gICAgICAgIHRoaXMuX2FmdGVyTWlkZGxld2FyZS5wdXNoKGZuKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVzZXRzIHRoZSBxdWV1ZSBvZiB0aGUgbG9hZGVyIHRvIHByZXBhcmUgZm9yIGEgbmV3IGxvYWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHt0aGlzfSBSZXR1cm5zIGl0c2VsZi5cbiAgICAgKi9cblxuXG4gICAgTG9hZGVyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgICB0aGlzLnByb2dyZXNzID0gMDtcbiAgICAgICAgdGhpcy5sb2FkaW5nID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5fcXVldWUua2lsbCgpO1xuICAgICAgICB0aGlzLl9xdWV1ZS5wYXVzZSgpO1xuXG4gICAgICAgIC8vIGFib3J0IGFsbCByZXNvdXJjZSBsb2Fkc1xuICAgICAgICBmb3IgKHZhciBrIGluIHRoaXMucmVzb3VyY2VzKSB7XG4gICAgICAgICAgICB2YXIgcmVzID0gdGhpcy5yZXNvdXJjZXNba107XG5cbiAgICAgICAgICAgIGlmIChyZXMuX29uTG9hZEJpbmRpbmcpIHtcbiAgICAgICAgICAgICAgICByZXMuX29uTG9hZEJpbmRpbmcuZGV0YWNoKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChyZXMuaXNMb2FkaW5nKSB7XG4gICAgICAgICAgICAgICAgcmVzLmFib3J0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJlc291cmNlcyA9IHt9O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTdGFydHMgbG9hZGluZyB0aGUgcXVldWVkIHJlc291cmNlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYl0gLSBPcHRpb25hbCBjYWxsYmFjayB0aGF0IHdpbGwgYmUgYm91bmQgdG8gdGhlIGBjb21wbGV0ZWAgZXZlbnQuXG4gICAgICogQHJldHVybiB7dGhpc30gUmV0dXJucyBpdHNlbGYuXG4gICAgICovXG5cblxuICAgIExvYWRlci5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uIGxvYWQoY2IpIHtcbiAgICAgICAgLy8gcmVnaXN0ZXIgY29tcGxldGUgY2FsbGJhY2sgaWYgdGhleSBwYXNzIG9uZVxuICAgICAgICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLm9uQ29tcGxldGUub25jZShjYik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB0aGUgcXVldWUgaGFzIGFscmVhZHkgc3RhcnRlZCB3ZSBhcmUgZG9uZSBoZXJlXG4gICAgICAgIGlmICh0aGlzLmxvYWRpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX3F1ZXVlLmlkbGUoKSkge1xuICAgICAgICAgICAgdGhpcy5fb25TdGFydCgpO1xuICAgICAgICAgICAgdGhpcy5fb25Db21wbGV0ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gZGlzdHJpYnV0ZSBwcm9ncmVzcyBjaHVua3NcbiAgICAgICAgICAgIHZhciBudW1UYXNrcyA9IHRoaXMuX3F1ZXVlLl90YXNrcy5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgY2h1bmsgPSBNQVhfUFJPR1JFU1MgLyBudW1UYXNrcztcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9xdWV1ZS5fdGFza3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9xdWV1ZS5fdGFza3NbaV0uZGF0YS5wcm9ncmVzc0NodW5rID0gY2h1bms7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIG5vdGlmeSB3ZSBhcmUgc3RhcnRpbmdcbiAgICAgICAgICAgIHRoaXMuX29uU3RhcnQoKTtcblxuICAgICAgICAgICAgLy8gc3RhcnQgbG9hZGluZ1xuICAgICAgICAgICAgdGhpcy5fcXVldWUucmVzdW1lKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiByZXNvdXJjZXMgdG8gbG9hZCBjb25jdXJyZW50bHkuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMTBcbiAgICAgKi9cblxuXG4gICAgLyoqXG4gICAgICogUHJlcGFyZXMgYSB1cmwgZm9yIHVzYWdlIGJhc2VkIG9uIHRoZSBjb25maWd1cmF0aW9uIG9mIHRoaXMgb2JqZWN0XG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgLSBUaGUgdXJsIHRvIHByZXBhcmUuXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgcHJlcGFyZWQgdXJsLlxuICAgICAqL1xuICAgIExvYWRlci5wcm90b3R5cGUuX3ByZXBhcmVVcmwgPSBmdW5jdGlvbiBfcHJlcGFyZVVybCh1cmwpIHtcbiAgICAgICAgdmFyIHBhcnNlZFVybCA9ICgwLCBfcGFyc2VVcmkyLmRlZmF1bHQpKHVybCwgeyBzdHJpY3RNb2RlOiB0cnVlIH0pO1xuICAgICAgICB2YXIgcmVzdWx0ID0gdm9pZCAwO1xuXG4gICAgICAgIC8vIGFic29sdXRlIHVybCwganVzdCB1c2UgaXQgYXMgaXMuXG4gICAgICAgIGlmIChwYXJzZWRVcmwucHJvdG9jb2wgfHwgIXBhcnNlZFVybC5wYXRoIHx8IHVybC5pbmRleE9mKCcvLycpID09PSAwKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB1cmw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgYmFzZVVybCBkb2Vzbid0IGVuZCBpbiBzbGFzaCBhbmQgdXJsIGRvZXNuJ3Qgc3RhcnQgd2l0aCBzbGFzaCwgdGhlbiBhZGQgYSBzbGFzaCBpbmJldHdlZW5cbiAgICAgICAgZWxzZSBpZiAodGhpcy5iYXNlVXJsLmxlbmd0aCAmJiB0aGlzLmJhc2VVcmwubGFzdEluZGV4T2YoJy8nKSAhPT0gdGhpcy5iYXNlVXJsLmxlbmd0aCAtIDEgJiYgdXJsLmNoYXJBdCgwKSAhPT0gJy8nKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5iYXNlVXJsICsgJy8nICsgdXJsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLmJhc2VVcmwgKyB1cmw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgd2UgbmVlZCB0byBhZGQgYSBkZWZhdWx0IHF1ZXJ5c3RyaW5nLCB0aGVyZSBpcyBhIGJpdCBtb3JlIHdvcmtcbiAgICAgICAgaWYgKHRoaXMuZGVmYXVsdFF1ZXJ5U3RyaW5nKSB7XG4gICAgICAgICAgICB2YXIgaGFzaCA9IHJneEV4dHJhY3RVcmxIYXNoLmV4ZWMocmVzdWx0KVswXTtcblxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnN1YnN0cigwLCByZXN1bHQubGVuZ3RoIC0gaGFzaC5sZW5ndGgpO1xuXG4gICAgICAgICAgICBpZiAocmVzdWx0LmluZGV4T2YoJz8nKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gJyYnICsgdGhpcy5kZWZhdWx0UXVlcnlTdHJpbmc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnPycgKyB0aGlzLmRlZmF1bHRRdWVyeVN0cmluZztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzdWx0ICs9IGhhc2g7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBMb2FkcyBhIHNpbmdsZSByZXNvdXJjZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtSZXNvdXJjZX0gcmVzb3VyY2UgLSBUaGUgcmVzb3VyY2UgdG8gbG9hZC5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBkZXF1ZXVlIC0gVGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB3ZSBuZWVkIHRvIGRlcXVldWUgdGhpcyBpdGVtLlxuICAgICAqL1xuXG5cbiAgICBMb2FkZXIucHJvdG90eXBlLl9sb2FkUmVzb3VyY2UgPSBmdW5jdGlvbiBfbG9hZFJlc291cmNlKHJlc291cmNlLCBkZXF1ZXVlKSB7XG4gICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgIHJlc291cmNlLl9kZXF1ZXVlID0gZGVxdWV1ZTtcblxuICAgICAgICAvLyBydW4gYmVmb3JlIG1pZGRsZXdhcmVcbiAgICAgICAgYXN5bmMuZWFjaFNlcmllcyh0aGlzLl9iZWZvcmVNaWRkbGV3YXJlLCBmdW5jdGlvbiAoZm4sIG5leHQpIHtcbiAgICAgICAgICAgIGZuLmNhbGwoX3RoaXMyLCByZXNvdXJjZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBiZWZvcmUgbWlkZGxld2FyZSBtYXJrcyB0aGUgcmVzb3VyY2UgYXMgY29tcGxldGUsXG4gICAgICAgICAgICAgICAgLy8gYnJlYWsgYW5kIGRvbid0IHByb2Nlc3MgYW55IG1vcmUgYmVmb3JlIG1pZGRsZXdhcmVcbiAgICAgICAgICAgICAgICBuZXh0KHJlc291cmNlLmlzQ29tcGxldGUgPyB7fSA6IG51bGwpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChyZXNvdXJjZS5pc0NvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMyLl9vbkxvYWQocmVzb3VyY2UpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXNvdXJjZS5fb25Mb2FkQmluZGluZyA9IHJlc291cmNlLm9uQ29tcGxldGUub25jZShfdGhpczIuX29uTG9hZCwgX3RoaXMyKTtcbiAgICAgICAgICAgICAgICByZXNvdXJjZS5sb2FkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRydWUpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgb25jZSBsb2FkaW5nIGhhcyBzdGFydGVkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuXG4gICAgTG9hZGVyLnByb3RvdHlwZS5fb25TdGFydCA9IGZ1bmN0aW9uIF9vblN0YXJ0KCkge1xuICAgICAgICB0aGlzLnByb2dyZXNzID0gMDtcbiAgICAgICAgdGhpcy5sb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vblN0YXJ0LmRpc3BhdGNoKHRoaXMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgb25jZSBlYWNoIHJlc291cmNlIGhhcyBsb2FkZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG5cbiAgICBMb2FkZXIucHJvdG90eXBlLl9vbkNvbXBsZXRlID0gZnVuY3Rpb24gX29uQ29tcGxldGUoKSB7XG4gICAgICAgIHRoaXMucHJvZ3Jlc3MgPSBNQVhfUFJPR1JFU1M7XG4gICAgICAgIHRoaXMubG9hZGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9uQ29tcGxldGUuZGlzcGF0Y2godGhpcywgdGhpcy5yZXNvdXJjZXMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgZWFjaCB0aW1lIGEgcmVzb3VyY2VzIGlzIGxvYWRlZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtSZXNvdXJjZX0gcmVzb3VyY2UgLSBUaGUgcmVzb3VyY2UgdGhhdCB3YXMgbG9hZGVkXG4gICAgICovXG5cblxuICAgIExvYWRlci5wcm90b3R5cGUuX29uTG9hZCA9IGZ1bmN0aW9uIF9vbkxvYWQocmVzb3VyY2UpIHtcbiAgICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgICAgcmVzb3VyY2UuX29uTG9hZEJpbmRpbmcgPSBudWxsO1xuXG4gICAgICAgIC8vIHJlbW92ZSB0aGlzIHJlc291cmNlIGZyb20gdGhlIGFzeW5jIHF1ZXVlLCBhbmQgYWRkIGl0IHRvIG91ciBsaXN0IG9mIHJlc291cmNlcyB0aGF0IGFyZSBiZWluZyBwYXJzZWRcbiAgICAgICAgdGhpcy5fcmVzb3VyY2VzUGFyc2luZy5wdXNoKHJlc291cmNlKTtcbiAgICAgICAgcmVzb3VyY2UuX2RlcXVldWUoKTtcblxuICAgICAgICAvLyBydW4gYWxsIHRoZSBhZnRlciBtaWRkbGV3YXJlIGZvciB0aGlzIHJlc291cmNlXG4gICAgICAgIGFzeW5jLmVhY2hTZXJpZXModGhpcy5fYWZ0ZXJNaWRkbGV3YXJlLCBmdW5jdGlvbiAoZm4sIG5leHQpIHtcbiAgICAgICAgICAgIGZuLmNhbGwoX3RoaXMzLCByZXNvdXJjZSwgbmV4dCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJlc291cmNlLm9uQWZ0ZXJNaWRkbGV3YXJlLmRpc3BhdGNoKHJlc291cmNlKTtcblxuICAgICAgICAgICAgX3RoaXMzLnByb2dyZXNzID0gTWF0aC5taW4oTUFYX1BST0dSRVNTLCBfdGhpczMucHJvZ3Jlc3MgKyByZXNvdXJjZS5wcm9ncmVzc0NodW5rKTtcbiAgICAgICAgICAgIF90aGlzMy5vblByb2dyZXNzLmRpc3BhdGNoKF90aGlzMywgcmVzb3VyY2UpO1xuXG4gICAgICAgICAgICBpZiAocmVzb3VyY2UuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBfdGhpczMub25FcnJvci5kaXNwYXRjaChyZXNvdXJjZS5lcnJvciwgX3RoaXMzLCByZXNvdXJjZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIF90aGlzMy5vbkxvYWQuZGlzcGF0Y2goX3RoaXMzLCByZXNvdXJjZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF90aGlzMy5fcmVzb3VyY2VzUGFyc2luZy5zcGxpY2UoX3RoaXMzLl9yZXNvdXJjZXNQYXJzaW5nLmluZGV4T2YocmVzb3VyY2UpLCAxKTtcblxuICAgICAgICAgICAgLy8gZG8gY29tcGxldGlvbiBjaGVja1xuICAgICAgICAgICAgaWYgKF90aGlzMy5fcXVldWUuaWRsZSgpICYmIF90aGlzMy5fcmVzb3VyY2VzUGFyc2luZy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBfdGhpczMuX29uQ29tcGxldGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdHJ1ZSk7XG4gICAgfTtcblxuICAgIF9jcmVhdGVDbGFzcyhMb2FkZXIsIFt7XG4gICAgICAgIGtleTogJ2NvbmN1cnJlbmN5JyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcXVldWUuY29uY3VycmVuY3k7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlcXVpcmUtanNkb2NcbiAgICAgICAgLFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChjb25jdXJyZW5jeSkge1xuICAgICAgICAgICAgdGhpcy5fcXVldWUuY29uY3VycmVuY3kgPSBjb25jdXJyZW5jeTtcbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBMb2FkZXI7XG59KCk7XG5cbi8qKlxuICogQSBkZWZhdWx0IGFycmF5IG9mIG1pZGRsZXdhcmUgdG8gcnVuIGJlZm9yZSBsb2FkaW5nIGVhY2ggcmVzb3VyY2UuXG4gKiBFYWNoIG9mIHRoZXNlIG1pZGRsZXdhcmVzIGFyZSBhZGRlZCB0byBhbnkgbmV3IExvYWRlciBpbnN0YW5jZXMgd2hlbiB0aGV5IGFyZSBjcmVhdGVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbWVtYmVyIHtmdW5jdGlvbltdfVxuICovXG5cblxuTG9hZGVyLl9kZWZhdWx0QmVmb3JlTWlkZGxld2FyZSA9IFtdO1xuXG4vKipcbiAqIEEgZGVmYXVsdCBhcnJheSBvZiBtaWRkbGV3YXJlIHRvIHJ1biBhZnRlciBsb2FkaW5nIGVhY2ggcmVzb3VyY2UuXG4gKiBFYWNoIG9mIHRoZXNlIG1pZGRsZXdhcmVzIGFyZSBhZGRlZCB0byBhbnkgbmV3IExvYWRlciBpbnN0YW5jZXMgd2hlbiB0aGV5IGFyZSBjcmVhdGVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbWVtYmVyIHtmdW5jdGlvbltdfVxuICovXG5Mb2FkZXIuX2RlZmF1bHRBZnRlck1pZGRsZXdhcmUgPSBbXTtcblxuLyoqXG4gKiBTZXRzIHVwIGEgbWlkZGxld2FyZSBmdW5jdGlvbiB0aGF0IHdpbGwgcnVuICpiZWZvcmUqIHRoZVxuICogcmVzb3VyY2UgaXMgbG9hZGVkLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIC0gVGhlIG1pZGRsZXdhcmUgZnVuY3Rpb24gdG8gcmVnaXN0ZXIuXG4gKiBAcmV0dXJuIHtMb2FkZXJ9IFJldHVybnMgaXRzZWxmLlxuICovXG5Mb2FkZXIucHJlID0gZnVuY3Rpb24gTG9hZGVyUHJlU3RhdGljKGZuKSB7XG4gICAgTG9hZGVyLl9kZWZhdWx0QmVmb3JlTWlkZGxld2FyZS5wdXNoKGZuKTtcblxuICAgIHJldHVybiBMb2FkZXI7XG59O1xuXG4vKipcbiAqIFNldHMgdXAgYSBtaWRkbGV3YXJlIGZ1bmN0aW9uIHRoYXQgd2lsbCBydW4gKmFmdGVyKiB0aGVcbiAqIHJlc291cmNlIGlzIGxvYWRlZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBmbiAtIFRoZSBtaWRkbGV3YXJlIGZ1bmN0aW9uIHRvIHJlZ2lzdGVyLlxuICogQHJldHVybiB7TG9hZGVyfSBSZXR1cm5zIGl0c2VsZi5cbiAqL1xuTG9hZGVyLnVzZSA9IGZ1bmN0aW9uIExvYWRlclVzZVN0YXRpYyhmbikge1xuICAgIExvYWRlci5fZGVmYXVsdEFmdGVyTWlkZGxld2FyZS5wdXNoKGZuKTtcblxuICAgIHJldHVybiBMb2FkZXI7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TG9hZGVyLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuUmVzb3VyY2UgPSB1bmRlZmluZWQ7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfcGFyc2VVcmkgPSByZXF1aXJlKCdwYXJzZS11cmknKTtcblxudmFyIF9wYXJzZVVyaTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wYXJzZVVyaSk7XG5cbnZhciBfbWluaVNpZ25hbHMgPSByZXF1aXJlKCdtaW5pLXNpZ25hbHMnKTtcblxudmFyIF9taW5pU2lnbmFsczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9taW5pU2lnbmFscyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8vIHRlc3RzIGlmIENPUlMgaXMgc3VwcG9ydGVkIGluIFhIUiwgaWYgbm90IHdlIG5lZWQgdG8gdXNlIFhEUlxudmFyIHVzZVhkciA9ICEhKHdpbmRvdy5YRG9tYWluUmVxdWVzdCAmJiAhKCd3aXRoQ3JlZGVudGlhbHMnIGluIG5ldyBYTUxIdHRwUmVxdWVzdCgpKSk7XG52YXIgdGVtcEFuY2hvciA9IG51bGw7XG5cbi8vIHNvbWUgc3RhdHVzIGNvbnN0YW50c1xudmFyIFNUQVRVU19OT05FID0gMDtcbnZhciBTVEFUVVNfT0sgPSAyMDA7XG52YXIgU1RBVFVTX0VNUFRZID0gMjA0O1xudmFyIFNUQVRVU19JRV9CVUdfRU1QVFkgPSAxMjIzO1xudmFyIFNUQVRVU19UWVBFX09LID0gMjtcblxuLy8gbm9vcFxuZnVuY3Rpb24gX25vb3AoKSB7fSAvKiBlbXB0eSAqL1xuXG4vKipcbiAqIE1hbmFnZXMgdGhlIHN0YXRlIGFuZCBsb2FkaW5nIG9mIGEgcmVzb3VyY2UgYW5kIGFsbCBjaGlsZCByZXNvdXJjZXMuXG4gKlxuICogQGNsYXNzXG4gKi9cblxudmFyIFJlc291cmNlID0gZXhwb3J0cy5SZXNvdXJjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBsb2FkIHR5cGUgdG8gYmUgdXNlZCBmb3IgYSBzcGVjaWZpYyBleHRlbnNpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV4dG5hbWUgLSBUaGUgZXh0ZW5zaW9uIHRvIHNldCB0aGUgdHlwZSBmb3IsIGUuZy4gXCJwbmdcIiBvciBcImZudFwiXG4gICAgICogQHBhcmFtIHtSZXNvdXJjZS5MT0FEX1RZUEV9IGxvYWRUeXBlIC0gVGhlIGxvYWQgdHlwZSB0byBzZXQgaXQgdG8uXG4gICAgICovXG4gICAgUmVzb3VyY2Uuc2V0RXh0ZW5zaW9uTG9hZFR5cGUgPSBmdW5jdGlvbiBzZXRFeHRlbnNpb25Mb2FkVHlwZShleHRuYW1lLCBsb2FkVHlwZSkge1xuICAgICAgICBzZXRFeHRNYXAoUmVzb3VyY2UuX2xvYWRUeXBlTWFwLCBleHRuYW1lLCBsb2FkVHlwZSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGxvYWQgdHlwZSB0byBiZSB1c2VkIGZvciBhIHNwZWNpZmljIGV4dGVuc2lvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXh0bmFtZSAtIFRoZSBleHRlbnNpb24gdG8gc2V0IHRoZSB0eXBlIGZvciwgZS5nLiBcInBuZ1wiIG9yIFwiZm50XCJcbiAgICAgKiBAcGFyYW0ge1Jlc291cmNlLlhIUl9SRVNQT05TRV9UWVBFfSB4aHJUeXBlIC0gVGhlIHhociB0eXBlIHRvIHNldCBpdCB0by5cbiAgICAgKi9cblxuXG4gICAgUmVzb3VyY2Uuc2V0RXh0ZW5zaW9uWGhyVHlwZSA9IGZ1bmN0aW9uIHNldEV4dGVuc2lvblhoclR5cGUoZXh0bmFtZSwgeGhyVHlwZSkge1xuICAgICAgICBzZXRFeHRNYXAoUmVzb3VyY2UuX3hoclR5cGVNYXAsIGV4dG5hbWUsIHhoclR5cGUpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSByZXNvdXJjZSB0byBsb2FkLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSB1cmwgLSBUaGUgdXJsIGZvciB0aGlzIHJlc291cmNlLCBmb3IgYXVkaW8vdmlkZW8gbG9hZHMgeW91IGNhbiBwYXNzXG4gICAgICogICAgICBhbiBhcnJheSBvZiBzb3VyY2VzLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gLSBUaGUgb3B0aW9ucyBmb3IgdGhlIGxvYWQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd8Ym9vbGVhbn0gW29wdGlvbnMuY3Jvc3NPcmlnaW5dIC0gSXMgdGhpcyByZXF1ZXN0IGNyb3NzLW9yaWdpbj8gRGVmYXVsdCBpcyB0b1xuICAgICAqICAgICAgZGV0ZXJtaW5lIGF1dG9tYXRpY2FsbHkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnRpbWVvdXQ9MF0gLSBBIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIGZvciB0aGUgbG9hZC4gSWYgdGhlIGxvYWQgdGFrZXNcbiAgICAgKiAgICAgIGxvbmdlciB0aGFuIHRoaXMgdGltZSBpdCBpcyBjYW5jZWxsZWQgYW5kIHRoZSBsb2FkIGlzIGNvbnNpZGVyZWQgYSBmYWlsdXJlLiBJZiB0aGlzIHZhbHVlIGlzXG4gICAgICogICAgICBzZXQgdG8gYDBgIHRoZW4gdGhlcmUgaXMgbm8gZXhwbGljaXQgdGltZW91dC5cbiAgICAgKiBAcGFyYW0ge1Jlc291cmNlLkxPQURfVFlQRX0gW29wdGlvbnMubG9hZFR5cGU9UmVzb3VyY2UuTE9BRF9UWVBFLlhIUl0gLSBIb3cgc2hvdWxkIHRoaXMgcmVzb3VyY2VcbiAgICAgKiAgICAgIGJlIGxvYWRlZD9cbiAgICAgKiBAcGFyYW0ge1Jlc291cmNlLlhIUl9SRVNQT05TRV9UWVBFfSBbb3B0aW9ucy54aHJUeXBlPVJlc291cmNlLlhIUl9SRVNQT05TRV9UWVBFLkRFRkFVTFRdIC0gSG93XG4gICAgICogICAgICBzaG91bGQgdGhlIGRhdGEgYmVpbmcgbG9hZGVkIGJlIGludGVycHJldGVkIHdoZW4gdXNpbmcgWEhSP1xuICAgICAqIEBwYXJhbSB7UmVzb3VyY2UuSU1ldGFkYXRhfSBbb3B0aW9ucy5tZXRhZGF0YV0gLSBFeHRyYSBjb25maWd1cmF0aW9uIGZvciBtaWRkbGV3YXJlIGFuZCB0aGUgUmVzb3VyY2Ugb2JqZWN0LlxuICAgICAqL1xuXG5cbiAgICBmdW5jdGlvbiBSZXNvdXJjZShuYW1lLCB1cmwsIG9wdGlvbnMpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJlc291cmNlKTtcblxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnIHx8IHR5cGVvZiB1cmwgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JvdGggbmFtZSBhbmQgdXJsIGFyZSByZXF1aXJlZCBmb3IgY29uc3RydWN0aW5nIGEgcmVzb3VyY2UuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHN0YXRlIGZsYWdzIG9mIHRoaXMgcmVzb3VyY2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2ZsYWdzID0gMDtcblxuICAgICAgICAvLyBzZXQgZGF0YSB1cmwgZmxhZywgbmVlZHMgdG8gYmUgc2V0IGVhcmx5IGZvciBzb21lIF9kZXRlcm1pbmVYIGNoZWNrcyB0byB3b3JrLlxuICAgICAgICB0aGlzLl9zZXRGbGFnKFJlc291cmNlLlNUQVRVU19GTEFHUy5EQVRBX1VSTCwgdXJsLmluZGV4T2YoJ2RhdGE6JykgPT09IDApO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbmFtZSBvZiB0aGlzIHJlc291cmNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmVhZG9ubHlcbiAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHVybCB1c2VkIHRvIGxvYWQgdGhpcyByZXNvdXJjZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICAqIEBtZW1iZXIge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudXJsID0gdXJsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZXh0ZW5zaW9uIHVzZWQgdG8gbG9hZCB0aGlzIHJlc291cmNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmVhZG9ubHlcbiAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5leHRlbnNpb24gPSB0aGlzLl9nZXRFeHRlbnNpb24oKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGRhdGEgdGhhdCB3YXMgbG9hZGVkIGJ5IHRoZSByZXNvdXJjZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7YW55fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kYXRhID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSXMgdGhpcyByZXF1ZXN0IGNyb3NzLW9yaWdpbj8gSWYgdW5zZXQsIGRldGVybWluZWQgYXV0b21hdGljYWxseS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jcm9zc09yaWdpbiA9IG9wdGlvbnMuY3Jvc3NPcmlnaW4gPT09IHRydWUgPyAnYW5vbnltb3VzJyA6IG9wdGlvbnMuY3Jvc3NPcmlnaW47XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgdGltZW91dCBpbiBtaWxsaXNlY29uZHMgZm9yIHRoZSBsb2FkLiBJZiB0aGUgbG9hZCB0YWtlcyBsb25nZXIgdGhhbiB0aGlzIHRpbWVcbiAgICAgICAgICogaXQgaXMgY2FuY2VsbGVkIGFuZCB0aGUgbG9hZCBpcyBjb25zaWRlcmVkIGEgZmFpbHVyZS4gSWYgdGhpcyB2YWx1ZSBpcyBzZXQgdG8gYDBgXG4gICAgICAgICAqIHRoZW4gdGhlcmUgaXMgbm8gZXhwbGljaXQgdGltZW91dC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50aW1lb3V0ID0gb3B0aW9ucy50aW1lb3V0IHx8IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBtZXRob2Qgb2YgbG9hZGluZyB0byB1c2UgZm9yIHRoaXMgcmVzb3VyY2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge1Jlc291cmNlLkxPQURfVFlQRX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubG9hZFR5cGUgPSBvcHRpb25zLmxvYWRUeXBlIHx8IHRoaXMuX2RldGVybWluZUxvYWRUeXBlKCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0eXBlIHVzZWQgdG8gbG9hZCB0aGUgcmVzb3VyY2UgdmlhIFhIUi4gSWYgdW5zZXQsIGRldGVybWluZWQgYXV0b21hdGljYWxseS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy54aHJUeXBlID0gb3B0aW9ucy54aHJUeXBlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFeHRyYSBpbmZvIGZvciBtaWRkbGV3YXJlLCBhbmQgY29udHJvbGxpbmcgc3BlY2lmaWNzIGFib3V0IGhvdyB0aGUgcmVzb3VyY2UgbG9hZHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIE5vdGUgdGhhdCBpZiB5b3UgcGFzcyBpbiBhIGBsb2FkRWxlbWVudGAsIHRoZSBSZXNvdXJjZSBjbGFzcyB0YWtlcyBvd25lcnNoaXAgb2YgaXQuXG4gICAgICAgICAqIE1lYW5pbmcgaXQgd2lsbCBtb2RpZnkgaXQgYXMgaXQgc2VlcyBmaXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge1Jlc291cmNlLklNZXRhZGF0YX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBvcHRpb25zLm1ldGFkYXRhIHx8IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZXJyb3IgdGhhdCBvY2N1cnJlZCB3aGlsZSBsb2FkaW5nIChpZiBhbnkpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmVhZG9ubHlcbiAgICAgICAgICogQG1lbWJlciB7RXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmVycm9yID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIFhIUiBvYmplY3QgdGhhdCB3YXMgdXNlZCB0byBsb2FkIHRoaXMgcmVzb3VyY2UuIFRoaXMgaXMgb25seSBzZXRcbiAgICAgICAgICogd2hlbiBgbG9hZFR5cGVgIGlzIGBSZXNvdXJjZS5MT0FEX1RZUEUuWEhSYC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICAqIEBtZW1iZXIge1hNTEh0dHBSZXF1ZXN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy54aHIgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY2hpbGQgcmVzb3VyY2VzIHRoaXMgcmVzb3VyY2Ugb3ducy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICAqIEBtZW1iZXIge1Jlc291cmNlW119XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gW107XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSByZXNvdXJjZSB0eXBlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmVhZG9ubHlcbiAgICAgICAgICogQG1lbWJlciB7UmVzb3VyY2UuVFlQRX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudHlwZSA9IFJlc291cmNlLlRZUEUuVU5LTk9XTjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHByb2dyZXNzIGNodW5rIG93bmVkIGJ5IHRoaXMgcmVzb3VyY2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZWFkb25seVxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnByb2dyZXNzQ2h1bmsgPSAwO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYGRlcXVldWVgIG1ldGhvZCB0aGF0IHdpbGwgYmUgdXNlZCBhIHN0b3JhZ2UgcGxhY2UgZm9yIHRoZSBhc3luYyBxdWV1ZSBkZXF1ZXVlIG1ldGhvZFxuICAgICAgICAgKiB1c2VkIHByaXZhdGVseSBieSB0aGUgbG9hZGVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAbWVtYmVyIHtmdW5jdGlvbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2RlcXVldWUgPSBfbm9vcDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVXNlZCBhIHN0b3JhZ2UgcGxhY2UgZm9yIHRoZSBvbiBsb2FkIGJpbmRpbmcgdXNlZCBwcml2YXRlbHkgYnkgdGhlIGxvYWRlci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQG1lbWJlciB7ZnVuY3Rpb259XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9vbkxvYWRCaW5kaW5nID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRpbWVyIGZvciBlbGVtZW50IGxvYWRzIHRvIGNoZWNrIGlmIHRoZXkgdGltZW91dC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fZWxlbWVudFRpbWVyID0gMDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGBjb21wbGV0ZWAgZnVuY3Rpb24gYm91bmQgdG8gdGhpcyByZXNvdXJjZSdzIGNvbnRleHQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBtZW1iZXIge2Z1bmN0aW9ufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fYm91bmRDb21wbGV0ZSA9IHRoaXMuY29tcGxldGUuYmluZCh0aGlzKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGBfb25FcnJvcmAgZnVuY3Rpb24gYm91bmQgdG8gdGhpcyByZXNvdXJjZSdzIGNvbnRleHQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBtZW1iZXIge2Z1bmN0aW9ufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fYm91bmRPbkVycm9yID0gdGhpcy5fb25FcnJvci5iaW5kKHRoaXMpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYF9vblByb2dyZXNzYCBmdW5jdGlvbiBib3VuZCB0byB0aGlzIHJlc291cmNlJ3MgY29udGV4dC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQG1lbWJlciB7ZnVuY3Rpb259XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9ib3VuZE9uUHJvZ3Jlc3MgPSB0aGlzLl9vblByb2dyZXNzLmJpbmQodGhpcyk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBgX29uVGltZW91dGAgZnVuY3Rpb24gYm91bmQgdG8gdGhpcyByZXNvdXJjZSdzIGNvbnRleHQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBtZW1iZXIge2Z1bmN0aW9ufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fYm91bmRPblRpbWVvdXQgPSB0aGlzLl9vblRpbWVvdXQuYmluZCh0aGlzKTtcblxuICAgICAgICAvLyB4aHIgY2FsbGJhY2tzXG4gICAgICAgIHRoaXMuX2JvdW5kWGhyT25FcnJvciA9IHRoaXMuX3hock9uRXJyb3IuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5fYm91bmRYaHJPblRpbWVvdXQgPSB0aGlzLl94aHJPblRpbWVvdXQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5fYm91bmRYaHJPbkFib3J0ID0gdGhpcy5feGhyT25BYm9ydC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLl9ib3VuZFhock9uTG9hZCA9IHRoaXMuX3hock9uTG9hZC5iaW5kKHRoaXMpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNwYXRjaGVkIHdoZW4gdGhlIHJlc291cmNlIGJlaW5ncyB0byBsb2FkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgY2FsbGJhY2sgbG9va3MgbGlrZSB7QGxpbmsgUmVzb3VyY2UuT25TdGFydFNpZ25hbH0uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge1NpZ25hbDxSZXNvdXJjZS5PblN0YXJ0U2lnbmFsPn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub25TdGFydCA9IG5ldyBfbWluaVNpZ25hbHMyLmRlZmF1bHQoKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGlzcGF0Y2hlZCBlYWNoIHRpbWUgcHJvZ3Jlc3Mgb2YgdGhpcyByZXNvdXJjZSBsb2FkIHVwZGF0ZXMuXG4gICAgICAgICAqIE5vdCBhbGwgcmVzb3VyY2VzIHR5cGVzIGFuZCBsb2FkZXIgc3lzdGVtcyBjYW4gc3VwcG9ydCB0aGlzIGV2ZW50XG4gICAgICAgICAqIHNvIHNvbWV0aW1lcyBpdCBtYXkgbm90IGJlIGF2YWlsYWJsZS4gSWYgdGhlIHJlc291cmNlXG4gICAgICAgICAqIGlzIGJlaW5nIGxvYWRlZCBvbiBhIG1vZGVybiBicm93c2VyLCB1c2luZyBYSFIsIGFuZCB0aGUgcmVtb3RlIHNlcnZlclxuICAgICAgICAgKiBwcm9wZXJseSBzZXRzIENvbnRlbnQtTGVuZ3RoIGhlYWRlcnMsIHRoZW4gdGhpcyB3aWxsIGJlIGF2YWlsYWJsZS5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIGNhbGxiYWNrIGxvb2tzIGxpa2Uge0BsaW5rIFJlc291cmNlLk9uUHJvZ3Jlc3NTaWduYWx9LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtTaWduYWw8UmVzb3VyY2UuT25Qcm9ncmVzc1NpZ25hbD59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uUHJvZ3Jlc3MgPSBuZXcgX21pbmlTaWduYWxzMi5kZWZhdWx0KCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc3BhdGNoZWQgb25jZSB0aGlzIHJlc291cmNlIGhhcyBsb2FkZWQsIGlmIHRoZXJlIHdhcyBhbiBlcnJvciBpdCB3aWxsXG4gICAgICAgICAqIGJlIGluIHRoZSBgZXJyb3JgIHByb3BlcnR5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgY2FsbGJhY2sgbG9va3MgbGlrZSB7QGxpbmsgUmVzb3VyY2UuT25Db21wbGV0ZVNpZ25hbH0uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge1NpZ25hbDxSZXNvdXJjZS5PbkNvbXBsZXRlU2lnbmFsPn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub25Db21wbGV0ZSA9IG5ldyBfbWluaVNpZ25hbHMyLmRlZmF1bHQoKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGlzcGF0Y2hlZCBhZnRlciB0aGlzIHJlc291cmNlIGhhcyBoYWQgYWxsIHRoZSAqYWZ0ZXIqIG1pZGRsZXdhcmUgcnVuIG9uIGl0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgY2FsbGJhY2sgbG9va3MgbGlrZSB7QGxpbmsgUmVzb3VyY2UuT25Db21wbGV0ZVNpZ25hbH0uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge1NpZ25hbDxSZXNvdXJjZS5PbkNvbXBsZXRlU2lnbmFsPn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub25BZnRlck1pZGRsZXdhcmUgPSBuZXcgX21pbmlTaWduYWxzMi5kZWZhdWx0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2hlbiB0aGUgcmVzb3VyY2Ugc3RhcnRzIHRvIGxvYWQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgUmVzb3VyY2VcbiAgICAgKiBAY2FsbGJhY2sgT25TdGFydFNpZ25hbFxuICAgICAqIEBwYXJhbSB7UmVzb3VyY2V9IHJlc291cmNlIC0gVGhlIHJlc291cmNlIHRoYXQgdGhlIGV2ZW50IGhhcHBlbmVkIG9uLlxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogV2hlbiB0aGUgcmVzb3VyY2UgcmVwb3J0cyBsb2FkaW5nIHByb2dyZXNzLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIFJlc291cmNlXG4gICAgICogQGNhbGxiYWNrIE9uUHJvZ3Jlc3NTaWduYWxcbiAgICAgKiBAcGFyYW0ge1Jlc291cmNlfSByZXNvdXJjZSAtIFRoZSByZXNvdXJjZSB0aGF0IHRoZSBldmVudCBoYXBwZW5lZCBvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGVyY2VudGFnZSAtIFRoZSBwcm9ncmVzcyBvZiB0aGUgbG9hZCBpbiB0aGUgcmFuZ2UgWzAsIDFdLlxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogV2hlbiB0aGUgcmVzb3VyY2UgZmluaXNoZXMgbG9hZGluZy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBSZXNvdXJjZVxuICAgICAqIEBjYWxsYmFjayBPbkNvbXBsZXRlU2lnbmFsXG4gICAgICogQHBhcmFtIHtSZXNvdXJjZX0gcmVzb3VyY2UgLSBUaGUgcmVzb3VyY2UgdGhhdCB0aGUgZXZlbnQgaGFwcGVuZWQgb24uXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyb2YgUmVzb3VyY2VcbiAgICAgKiBAdHlwZWRlZiB7b2JqZWN0fSBJTWV0YWRhdGFcbiAgICAgKiBAcHJvcGVydHkge0hUTUxJbWFnZUVsZW1lbnR8SFRNTEF1ZGlvRWxlbWVudHxIVE1MVmlkZW9FbGVtZW50fSBbbG9hZEVsZW1lbnQ9bnVsbF0gLSBUaGVcbiAgICAgKiAgICAgIGVsZW1lbnQgdG8gdXNlIGZvciBsb2FkaW5nLCBpbnN0ZWFkIG9mIGNyZWF0aW5nIG9uZS5cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtza2lwU291cmNlPWZhbHNlXSAtIFNraXBzIGFkZGluZyBzb3VyY2UocykgdG8gdGhlIGxvYWQgZWxlbWVudC4gVGhpc1xuICAgICAqICAgICAgaXMgdXNlZnVsIGlmIHlvdSB3YW50IHRvIHBhc3MgaW4gYSBgbG9hZEVsZW1lbnRgIHRoYXQgeW91IGFscmVhZHkgYWRkZWQgbG9hZCBzb3VyY2VzIHRvLlxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfHN0cmluZ1tdfSBbbWltZVR5cGVdIC0gVGhlIG1pbWUgdHlwZSB0byB1c2UgZm9yIHRoZSBzb3VyY2UgZWxlbWVudFxuICAgICAqICAgICAgb2YgYSB2aWRlby9hdWRpbyBlbG1lbnQuIElmIHRoZSB1cmxzIGFyZSBhbiBhcnJheSwgeW91IGNhbiBwYXNzIHRoaXMgYXMgYW4gYXJyYXkgYXMgd2VsbFxuICAgICAqICAgICAgd2hlcmUgZWFjaCBpbmRleCBpcyB0aGUgbWltZSB0eXBlIHRvIHVzZSBmb3IgdGhlIGNvcnJlc3BvbmRpbmcgdXJsIGluZGV4LlxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogU3RvcmVzIHdoZXRoZXIgb3Igbm90IHRoaXMgdXJsIGlzIGEgZGF0YSB1cmwuXG4gICAgICpcbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAqL1xuXG5cbiAgICAvKipcbiAgICAgKiBNYXJrcyB0aGUgcmVzb3VyY2UgYXMgY29tcGxldGUuXG4gICAgICpcbiAgICAgKi9cbiAgICBSZXNvdXJjZS5wcm90b3R5cGUuY29tcGxldGUgPSBmdW5jdGlvbiBjb21wbGV0ZSgpIHtcbiAgICAgICAgdGhpcy5fY2xlYXJFdmVudHMoKTtcbiAgICAgICAgdGhpcy5fZmluaXNoKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFib3J0cyB0aGUgbG9hZGluZyBvZiB0aGlzIHJlc291cmNlLCB3aXRoIGFuIG9wdGlvbmFsIG1lc3NhZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSAtIFRoZSBtZXNzYWdlIHRvIHVzZSBmb3IgdGhlIGVycm9yXG4gICAgICovXG5cblxuICAgIFJlc291cmNlLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uIGFib3J0KG1lc3NhZ2UpIHtcbiAgICAgICAgLy8gYWJvcnQgY2FuIGJlIGNhbGxlZCBtdWx0aXBsZSB0aW1lcywgaWdub3JlIHN1YnNlcXVlbnQgY2FsbHMuXG4gICAgICAgIGlmICh0aGlzLmVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzdG9yZSBlcnJvclxuICAgICAgICB0aGlzLmVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuXG4gICAgICAgIC8vIGNsZWFyIGV2ZW50cyBiZWZvcmUgY2FsbGluZyBhYm9ydHNcbiAgICAgICAgdGhpcy5fY2xlYXJFdmVudHMoKTtcblxuICAgICAgICAvLyBhYm9ydCB0aGUgYWN0dWFsIGxvYWRpbmdcbiAgICAgICAgaWYgKHRoaXMueGhyKSB7XG4gICAgICAgICAgICB0aGlzLnhoci5hYm9ydCgpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMueGRyKSB7XG4gICAgICAgICAgICB0aGlzLnhkci5hYm9ydCgpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZGF0YSkge1xuICAgICAgICAgICAgLy8gc2luZ2xlIHNvdXJjZVxuICAgICAgICAgICAgaWYgKHRoaXMuZGF0YS5zcmMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGEuc3JjID0gUmVzb3VyY2UuRU1QVFlfR0lGO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbXVsdGktc291cmNlXG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHRoaXMuZGF0YS5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGEucmVtb3ZlQ2hpbGQodGhpcy5kYXRhLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZG9uZSBub3cuXG4gICAgICAgIHRoaXMuX2ZpbmlzaCgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBLaWNrcyBvZmYgbG9hZGluZyBvZiB0aGlzIHJlc291cmNlLiBUaGlzIG1ldGhvZCBpcyBhc3luY2hyb25vdXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1Jlc291cmNlLk9uQ29tcGxldGVTaWduYWx9IFtjYl0gLSBPcHRpb25hbCBjYWxsYmFjayB0byBjYWxsIG9uY2UgdGhlIHJlc291cmNlIGlzIGxvYWRlZC5cbiAgICAgKi9cblxuXG4gICAgUmVzb3VyY2UucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiBsb2FkKGNiKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNMb2FkaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5pc0NvbXBsZXRlKSB7XG4gICAgICAgICAgICBpZiAoY2IpIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNiKF90aGlzKTtcbiAgICAgICAgICAgICAgICB9LCAxKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2UgaWYgKGNiKSB7XG4gICAgICAgICAgICB0aGlzLm9uQ29tcGxldGUub25jZShjYik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9zZXRGbGFnKFJlc291cmNlLlNUQVRVU19GTEFHUy5MT0FESU5HLCB0cnVlKTtcblxuICAgICAgICB0aGlzLm9uU3RhcnQuZGlzcGF0Y2godGhpcyk7XG5cbiAgICAgICAgLy8gaWYgdW5zZXQsIGRldGVybWluZSB0aGUgdmFsdWVcbiAgICAgICAgaWYgKHRoaXMuY3Jvc3NPcmlnaW4gPT09IGZhbHNlIHx8IHR5cGVvZiB0aGlzLmNyb3NzT3JpZ2luICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhpcy5jcm9zc09yaWdpbiA9IHRoaXMuX2RldGVybWluZUNyb3NzT3JpZ2luKHRoaXMudXJsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAodGhpcy5sb2FkVHlwZSkge1xuICAgICAgICAgICAgY2FzZSBSZXNvdXJjZS5MT0FEX1RZUEUuSU1BR0U6XG4gICAgICAgICAgICAgICAgdGhpcy50eXBlID0gUmVzb3VyY2UuVFlQRS5JTUFHRTtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2FkRWxlbWVudCgnaW1hZ2UnKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBSZXNvdXJjZS5MT0FEX1RZUEUuQVVESU86XG4gICAgICAgICAgICAgICAgdGhpcy50eXBlID0gUmVzb3VyY2UuVFlQRS5BVURJTztcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2FkU291cmNlRWxlbWVudCgnYXVkaW8nKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBSZXNvdXJjZS5MT0FEX1RZUEUuVklERU86XG4gICAgICAgICAgICAgICAgdGhpcy50eXBlID0gUmVzb3VyY2UuVFlQRS5WSURFTztcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2FkU291cmNlRWxlbWVudCgndmlkZW8nKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBSZXNvdXJjZS5MT0FEX1RZUEUuWEhSOlxuICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBpZiAodXNlWGRyICYmIHRoaXMuY3Jvc3NPcmlnaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9hZFhkcigpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvYWRYaHIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBmbGFnIGlzIHNldC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGZsYWcgLSBUaGUgZmxhZyB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBmbGFnIGlzIHNldC5cbiAgICAgKi9cblxuXG4gICAgUmVzb3VyY2UucHJvdG90eXBlLl9oYXNGbGFnID0gZnVuY3Rpb24gX2hhc0ZsYWcoZmxhZykge1xuICAgICAgICByZXR1cm4gKHRoaXMuX2ZsYWdzICYgZmxhZykgIT09IDA7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIChVbilTZXRzIHRoZSBmbGFnLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZmxhZyAtIFRoZSBmbGFnIHRvICh1bilzZXQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSB2YWx1ZSAtIFdoZXRoZXIgdG8gc2V0IG9yICh1bilzZXQgdGhlIGZsYWcuXG4gICAgICovXG5cblxuICAgIFJlc291cmNlLnByb3RvdHlwZS5fc2V0RmxhZyA9IGZ1bmN0aW9uIF9zZXRGbGFnKGZsYWcsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2ZsYWdzID0gdmFsdWUgPyB0aGlzLl9mbGFncyB8IGZsYWcgOiB0aGlzLl9mbGFncyAmIH5mbGFnO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgYWxsIHRoZSBldmVudHMgZnJvbSB0aGUgdW5kZXJseWluZyBsb2FkaW5nIHNvdXJjZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cblxuICAgIFJlc291cmNlLnByb3RvdHlwZS5fY2xlYXJFdmVudHMgPSBmdW5jdGlvbiBfY2xlYXJFdmVudHMoKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9lbGVtZW50VGltZXIpO1xuXG4gICAgICAgIGlmICh0aGlzLmRhdGEgJiYgdGhpcy5kYXRhLnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YS5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIHRoaXMuX2JvdW5kT25FcnJvciwgZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy5kYXRhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xvYWQnLCB0aGlzLl9ib3VuZENvbXBsZXRlLCBmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLmRhdGEucmVtb3ZlRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCB0aGlzLl9ib3VuZE9uUHJvZ3Jlc3MsIGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMuZGF0YS5yZW1vdmVFdmVudExpc3RlbmVyKCdjYW5wbGF5dGhyb3VnaCcsIHRoaXMuX2JvdW5kQ29tcGxldGUsIGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnhocikge1xuICAgICAgICAgICAgaWYgKHRoaXMueGhyLnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnhoci5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIHRoaXMuX2JvdW5kWGhyT25FcnJvciwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIHRoaXMueGhyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RpbWVvdXQnLCB0aGlzLl9ib3VuZFhock9uVGltZW91dCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIHRoaXMueGhyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgdGhpcy5fYm91bmRYaHJPbkFib3J0LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgdGhpcy54aHIucmVtb3ZlRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCB0aGlzLl9ib3VuZE9uUHJvZ3Jlc3MsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnhoci5yZW1vdmVFdmVudExpc3RlbmVyKCdsb2FkJywgdGhpcy5fYm91bmRYaHJPbkxvYWQsIGZhbHNlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy54aHIub25lcnJvciA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy54aHIub250aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLnhoci5vbnByb2dyZXNzID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLnhoci5vbmxvYWQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEZpbmFsaXplcyB0aGUgbG9hZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cblxuICAgIFJlc291cmNlLnByb3RvdHlwZS5fZmluaXNoID0gZnVuY3Rpb24gX2ZpbmlzaCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNDb21wbGV0ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb21wbGV0ZSBjYWxsZWQgYWdhaW4gZm9yIGFuIGFscmVhZHkgY29tcGxldGVkIHJlc291cmNlLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fc2V0RmxhZyhSZXNvdXJjZS5TVEFUVVNfRkxBR1MuQ09NUExFVEUsIHRydWUpO1xuICAgICAgICB0aGlzLl9zZXRGbGFnKFJlc291cmNlLlNUQVRVU19GTEFHUy5MT0FESU5HLCBmYWxzZSk7XG5cbiAgICAgICAgdGhpcy5vbkNvbXBsZXRlLmRpc3BhdGNoKHRoaXMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBMb2FkcyB0aGlzIHJlc291cmNlcyB1c2luZyBhbiBlbGVtZW50IHRoYXQgaGFzIGEgc2luZ2xlIHNvdXJjZSxcbiAgICAgKiBsaWtlIGFuIEhUTUxJbWFnZUVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gVGhlIHR5cGUgb2YgZWxlbWVudCB0byB1c2UuXG4gICAgICovXG5cblxuICAgIFJlc291cmNlLnByb3RvdHlwZS5fbG9hZEVsZW1lbnQgPSBmdW5jdGlvbiBfbG9hZEVsZW1lbnQodHlwZSkge1xuICAgICAgICBpZiAodGhpcy5tZXRhZGF0YS5sb2FkRWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5kYXRhID0gdGhpcy5tZXRhZGF0YS5sb2FkRWxlbWVudDtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnaW1hZ2UnICYmIHR5cGVvZiB3aW5kb3cuSW1hZ2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodHlwZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5jcm9zc09yaWdpbikge1xuICAgICAgICAgICAgdGhpcy5kYXRhLmNyb3NzT3JpZ2luID0gdGhpcy5jcm9zc09yaWdpbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5tZXRhZGF0YS5za2lwU291cmNlKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGEuc3JjID0gdGhpcy51cmw7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRhdGEuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCB0aGlzLl9ib3VuZE9uRXJyb3IsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5kYXRhLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCB0aGlzLl9ib3VuZENvbXBsZXRlLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuZGF0YS5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIHRoaXMuX2JvdW5kT25Qcm9ncmVzcywgZmFsc2UpO1xuXG4gICAgICAgIGlmICh0aGlzLnRpbWVvdXQpIHtcbiAgICAgICAgICAgIHRoaXMuX2VsZW1lbnRUaW1lciA9IHNldFRpbWVvdXQodGhpcy5fYm91bmRPblRpbWVvdXQsIHRoaXMudGltZW91dCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTG9hZHMgdGhpcyByZXNvdXJjZXMgdXNpbmcgYW4gZWxlbWVudCB0aGF0IGhhcyBtdWx0aXBsZSBzb3VyY2VzLFxuICAgICAqIGxpa2UgYW4gSFRNTEF1ZGlvRWxlbWVudCBvciBIVE1MVmlkZW9FbGVtZW50LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIFRoZSB0eXBlIG9mIGVsZW1lbnQgdG8gdXNlLlxuICAgICAqL1xuXG5cbiAgICBSZXNvdXJjZS5wcm90b3R5cGUuX2xvYWRTb3VyY2VFbGVtZW50ID0gZnVuY3Rpb24gX2xvYWRTb3VyY2VFbGVtZW50KHR5cGUpIHtcbiAgICAgICAgaWYgKHRoaXMubWV0YWRhdGEubG9hZEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IHRoaXMubWV0YWRhdGEubG9hZEVsZW1lbnQ7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2F1ZGlvJyAmJiB0eXBlb2Ygd2luZG93LkF1ZGlvICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhpcy5kYXRhID0gbmV3IEF1ZGlvKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHR5cGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuZGF0YSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5hYm9ydCgnVW5zdXBwb3J0ZWQgZWxlbWVudDogJyArIHR5cGUpO1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5jcm9zc09yaWdpbikge1xuICAgICAgICAgICAgdGhpcy5kYXRhLmNyb3NzT3JpZ2luID0gdGhpcy5jcm9zc09yaWdpbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5tZXRhZGF0YS5za2lwU291cmNlKSB7XG4gICAgICAgICAgICAvLyBzdXBwb3J0IGZvciBDb2Nvb25KUyBDYW52YXMrIHJ1bnRpbWUsIGxhY2tzIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NvdXJjZScpXG4gICAgICAgICAgICBpZiAobmF2aWdhdG9yLmlzQ29jb29uSlMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGEuc3JjID0gQXJyYXkuaXNBcnJheSh0aGlzLnVybCkgPyB0aGlzLnVybFswXSA6IHRoaXMudXJsO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHRoaXMudXJsKSkge1xuICAgICAgICAgICAgICAgIHZhciBtaW1lVHlwZXMgPSB0aGlzLm1ldGFkYXRhLm1pbWVUeXBlO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnVybC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGEuYXBwZW5kQ2hpbGQodGhpcy5fY3JlYXRlU291cmNlKHR5cGUsIHRoaXMudXJsW2ldLCBBcnJheS5pc0FycmF5KG1pbWVUeXBlcykgPyBtaW1lVHlwZXNbaV0gOiBtaW1lVHlwZXMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBfbWltZVR5cGVzID0gdGhpcy5tZXRhZGF0YS5taW1lVHlwZTtcblxuICAgICAgICAgICAgICAgIHRoaXMuZGF0YS5hcHBlbmRDaGlsZCh0aGlzLl9jcmVhdGVTb3VyY2UodHlwZSwgdGhpcy51cmwsIEFycmF5LmlzQXJyYXkoX21pbWVUeXBlcykgPyBfbWltZVR5cGVzWzBdIDogX21pbWVUeXBlcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5kYXRhLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgdGhpcy5fYm91bmRPbkVycm9yLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuZGF0YS5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgdGhpcy5fYm91bmRDb21wbGV0ZSwgZmFsc2UpO1xuICAgICAgICB0aGlzLmRhdGEuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCB0aGlzLl9ib3VuZE9uUHJvZ3Jlc3MsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5kYXRhLmFkZEV2ZW50TGlzdGVuZXIoJ2NhbnBsYXl0aHJvdWdoJywgdGhpcy5fYm91bmRDb21wbGV0ZSwgZmFsc2UpO1xuXG4gICAgICAgIHRoaXMuZGF0YS5sb2FkKCk7XG5cbiAgICAgICAgaWYgKHRoaXMudGltZW91dCkge1xuICAgICAgICAgICAgdGhpcy5fZWxlbWVudFRpbWVyID0gc2V0VGltZW91dCh0aGlzLl9ib3VuZE9uVGltZW91dCwgdGhpcy50aW1lb3V0KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBMb2FkcyB0aGlzIHJlc291cmNlcyB1c2luZyBhbiBYTUxIdHRwUmVxdWVzdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cblxuICAgIFJlc291cmNlLnByb3RvdHlwZS5fbG9hZFhociA9IGZ1bmN0aW9uIF9sb2FkWGhyKCkge1xuICAgICAgICAvLyBpZiB1bnNldCwgZGV0ZXJtaW5lIHRoZSB2YWx1ZVxuICAgICAgICBpZiAodHlwZW9mIHRoaXMueGhyVHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRoaXMueGhyVHlwZSA9IHRoaXMuX2RldGVybWluZVhoclR5cGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB4aHIgPSB0aGlzLnhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG4gICAgICAgIC8vIHNldCB0aGUgcmVxdWVzdCB0eXBlIGFuZCB1cmxcbiAgICAgICAgeGhyLm9wZW4oJ0dFVCcsIHRoaXMudXJsLCB0cnVlKTtcblxuICAgICAgICB4aHIudGltZW91dCA9IHRoaXMudGltZW91dDtcblxuICAgICAgICAvLyBsb2FkIGpzb24gYXMgdGV4dCBhbmQgcGFyc2UgaXQgb3Vyc2VsdmVzLiBXZSBkbyB0aGlzIGJlY2F1c2Ugc29tZSBicm93c2Vyc1xuICAgICAgICAvLyAqY291Z2gqIHNhZmFyaSAqY291Z2gqIGNhbid0IGRlYWwgd2l0aCBpdC5cbiAgICAgICAgaWYgKHRoaXMueGhyVHlwZSA9PT0gUmVzb3VyY2UuWEhSX1JFU1BPTlNFX1RZUEUuSlNPTiB8fCB0aGlzLnhoclR5cGUgPT09IFJlc291cmNlLlhIUl9SRVNQT05TRV9UWVBFLkRPQ1VNRU5UKSB7XG4gICAgICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gUmVzb3VyY2UuWEhSX1JFU1BPTlNFX1RZUEUuVEVYVDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSB0aGlzLnhoclR5cGU7XG4gICAgICAgIH1cblxuICAgICAgICB4aHIuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCB0aGlzLl9ib3VuZFhock9uRXJyb3IsIGZhbHNlKTtcbiAgICAgICAgeGhyLmFkZEV2ZW50TGlzdGVuZXIoJ3RpbWVvdXQnLCB0aGlzLl9ib3VuZFhock9uVGltZW91dCwgZmFsc2UpO1xuICAgICAgICB4aHIuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCB0aGlzLl9ib3VuZFhock9uQWJvcnQsIGZhbHNlKTtcbiAgICAgICAgeGhyLmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgdGhpcy5fYm91bmRPblByb2dyZXNzLCBmYWxzZSk7XG4gICAgICAgIHhoci5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgdGhpcy5fYm91bmRYaHJPbkxvYWQsIGZhbHNlKTtcblxuICAgICAgICB4aHIuc2VuZCgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBMb2FkcyB0aGlzIHJlc291cmNlcyB1c2luZyBhbiBYRG9tYWluUmVxdWVzdC4gVGhpcyBpcyBoZXJlIGJlY2F1c2Ugd2UgbmVlZCB0byBzdXBwb3J0IElFOSAoZ3Jvc3MpLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuXG4gICAgUmVzb3VyY2UucHJvdG90eXBlLl9sb2FkWGRyID0gZnVuY3Rpb24gX2xvYWRYZHIoKSB7XG4gICAgICAgIC8vIGlmIHVuc2V0LCBkZXRlcm1pbmUgdGhlIHZhbHVlXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy54aHJUeXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhpcy54aHJUeXBlID0gdGhpcy5fZGV0ZXJtaW5lWGhyVHlwZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHhkciA9IHRoaXMueGhyID0gbmV3IFhEb21haW5SZXF1ZXN0KCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuICAgICAgICAvLyBYRG9tYWluUmVxdWVzdCBoYXMgYSBmZXcgcXVpcmtzLiBPY2Nhc2lvbmFsbHkgaXQgd2lsbCBhYm9ydCByZXF1ZXN0c1xuICAgICAgICAvLyBBIHdheSB0byBhdm9pZCB0aGlzIGlzIHRvIG1ha2Ugc3VyZSBBTEwgY2FsbGJhY2tzIGFyZSBzZXQgZXZlbiBpZiBub3QgdXNlZFxuICAgICAgICAvLyBNb3JlIGluZm8gaGVyZTogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xNTc4Njk2Ni94ZG9tYWlucmVxdWVzdC1hYm9ydHMtcG9zdC1vbi1pZS05XG4gICAgICAgIHhkci50aW1lb3V0ID0gdGhpcy50aW1lb3V0IHx8IDUwMDA7IC8vIFhEUiBuZWVkcyBhIHRpbWVvdXQgdmFsdWUgb3IgaXQgYnJlYWtzIGluIElFOVxuXG4gICAgICAgIHhkci5vbmVycm9yID0gdGhpcy5fYm91bmRYaHJPbkVycm9yO1xuICAgICAgICB4ZHIub250aW1lb3V0ID0gdGhpcy5fYm91bmRYaHJPblRpbWVvdXQ7XG4gICAgICAgIHhkci5vbnByb2dyZXNzID0gdGhpcy5fYm91bmRPblByb2dyZXNzO1xuICAgICAgICB4ZHIub25sb2FkID0gdGhpcy5fYm91bmRYaHJPbkxvYWQ7XG5cbiAgICAgICAgeGRyLm9wZW4oJ0dFVCcsIHRoaXMudXJsLCB0cnVlKTtcblxuICAgICAgICAvLyBOb3RlOiBUaGUgeGRyLnNlbmQoKSBjYWxsIGlzIHdyYXBwZWQgaW4gYSB0aW1lb3V0IHRvIHByZXZlbnQgYW5cbiAgICAgICAgLy8gaXNzdWUgd2l0aCB0aGUgaW50ZXJmYWNlIHdoZXJlIHNvbWUgcmVxdWVzdHMgYXJlIGxvc3QgaWYgbXVsdGlwbGVcbiAgICAgICAgLy8gWERvbWFpblJlcXVlc3RzIGFyZSBiZWluZyBzZW50IGF0IHRoZSBzYW1lIHRpbWUuXG4gICAgICAgIC8vIFNvbWUgaW5mbyBoZXJlOiBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9uc3Rvcm0vcGhhc2VyL2lzc3Vlcy8xMjQ4XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHhkci5zZW5kKCk7XG4gICAgICAgIH0sIDEpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc291cmNlIHVzZWQgaW4gbG9hZGluZyB2aWEgYW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBUaGUgZWxlbWVudCB0eXBlICh2aWRlbyBvciBhdWRpbykuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybCAtIFRoZSBzb3VyY2UgVVJMIHRvIGxvYWQgZnJvbS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW21pbWVdIC0gVGhlIG1pbWUgdHlwZSBvZiB0aGUgdmlkZW9cbiAgICAgKiBAcmV0dXJuIHtIVE1MU291cmNlRWxlbWVudH0gVGhlIHNvdXJjZSBlbGVtZW50LlxuICAgICAqL1xuXG5cbiAgICBSZXNvdXJjZS5wcm90b3R5cGUuX2NyZWF0ZVNvdXJjZSA9IGZ1bmN0aW9uIF9jcmVhdGVTb3VyY2UodHlwZSwgdXJsLCBtaW1lKSB7XG4gICAgICAgIGlmICghbWltZSkge1xuICAgICAgICAgICAgbWltZSA9IHR5cGUgKyAnLycgKyB0aGlzLl9nZXRFeHRlbnNpb24odXJsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzb3VyY2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzb3VyY2UnKTtcblxuICAgICAgICBzb3VyY2Uuc3JjID0gdXJsO1xuICAgICAgICBzb3VyY2UudHlwZSA9IG1pbWU7XG5cbiAgICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIGlmIGEgbG9hZCBlcnJvcnMgb3V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBUaGUgZXJyb3IgZXZlbnQgZnJvbSB0aGUgZWxlbWVudCB0aGF0IGVtaXRzIGl0LlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cblxuICAgIFJlc291cmNlLnByb3RvdHlwZS5fb25FcnJvciA9IGZ1bmN0aW9uIF9vbkVycm9yKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuYWJvcnQoJ0ZhaWxlZCB0byBsb2FkIGVsZW1lbnQgdXNpbmc6ICcgKyBldmVudC50YXJnZXQubm9kZU5hbWUpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgaWYgYSBsb2FkIHByb2dyZXNzIGV2ZW50IGZpcmVzIGZvciBhbiBlbGVtZW50IG9yIHhoci94ZHIuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7WE1MSHR0cFJlcXVlc3RQcm9ncmVzc0V2ZW50fEV2ZW50fSBldmVudCAtIFByb2dyZXNzIGV2ZW50LlxuICAgICAqL1xuXG5cbiAgICBSZXNvdXJjZS5wcm90b3R5cGUuX29uUHJvZ3Jlc3MgPSBmdW5jdGlvbiBfb25Qcm9ncmVzcyhldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQgJiYgZXZlbnQubGVuZ3RoQ29tcHV0YWJsZSkge1xuICAgICAgICAgICAgdGhpcy5vblByb2dyZXNzLmRpc3BhdGNoKHRoaXMsIGV2ZW50LmxvYWRlZCAvIGV2ZW50LnRvdGFsKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgaWYgYSB0aW1lb3V0IGV2ZW50IGZpcmVzIGZvciBhbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuXG4gICAgUmVzb3VyY2UucHJvdG90eXBlLl9vblRpbWVvdXQgPSBmdW5jdGlvbiBfb25UaW1lb3V0KCkge1xuICAgICAgICB0aGlzLmFib3J0KCdMb2FkIHRpbWVkIG91dC4nKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIGlmIGFuIGVycm9yIGV2ZW50IGZpcmVzIGZvciB4aHIveGRyLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuXG4gICAgUmVzb3VyY2UucHJvdG90eXBlLl94aHJPbkVycm9yID0gZnVuY3Rpb24gX3hock9uRXJyb3IoKSB7XG4gICAgICAgIHZhciB4aHIgPSB0aGlzLnhocjtcblxuICAgICAgICB0aGlzLmFib3J0KHJlcVR5cGUoeGhyKSArICcgUmVxdWVzdCBmYWlsZWQuIFN0YXR1czogJyArIHhoci5zdGF0dXMgKyAnLCB0ZXh0OiBcIicgKyB4aHIuc3RhdHVzVGV4dCArICdcIicpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgaWYgYW4gZXJyb3IgZXZlbnQgZmlyZXMgZm9yIHhoci94ZHIuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG5cbiAgICBSZXNvdXJjZS5wcm90b3R5cGUuX3hock9uVGltZW91dCA9IGZ1bmN0aW9uIF94aHJPblRpbWVvdXQoKSB7XG4gICAgICAgIHZhciB4aHIgPSB0aGlzLnhocjtcblxuICAgICAgICB0aGlzLmFib3J0KHJlcVR5cGUoeGhyKSArICcgUmVxdWVzdCB0aW1lZCBvdXQuJyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENhbGxlZCBpZiBhbiBhYm9ydCBldmVudCBmaXJlcyBmb3IgeGhyL3hkci5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cblxuICAgIFJlc291cmNlLnByb3RvdHlwZS5feGhyT25BYm9ydCA9IGZ1bmN0aW9uIF94aHJPbkFib3J0KCkge1xuICAgICAgICB2YXIgeGhyID0gdGhpcy54aHI7XG5cbiAgICAgICAgdGhpcy5hYm9ydChyZXFUeXBlKHhocikgKyAnIFJlcXVlc3Qgd2FzIGFib3J0ZWQgYnkgdGhlIHVzZXIuJyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIGRhdGEgc3VjY2Vzc2Z1bGx5IGxvYWRzIGZyb20gYW4geGhyL3hkciByZXF1ZXN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1hNTEh0dHBSZXF1ZXN0TG9hZEV2ZW50fEV2ZW50fSBldmVudCAtIExvYWQgZXZlbnRcbiAgICAgKi9cblxuXG4gICAgUmVzb3VyY2UucHJvdG90eXBlLl94aHJPbkxvYWQgPSBmdW5jdGlvbiBfeGhyT25Mb2FkKCkge1xuICAgICAgICB2YXIgeGhyID0gdGhpcy54aHI7XG4gICAgICAgIHZhciB0ZXh0ID0gJyc7XG4gICAgICAgIHZhciBzdGF0dXMgPSB0eXBlb2YgeGhyLnN0YXR1cyA9PT0gJ3VuZGVmaW5lZCcgPyBTVEFUVVNfT0sgOiB4aHIuc3RhdHVzOyAvLyBYRFIgaGFzIG5vIGAuc3RhdHVzYCwgYXNzdW1lIDIwMC5cblxuICAgICAgICAvLyByZXNwb25zZVRleHQgaXMgYWNjZXNzaWJsZSBvbmx5IGlmIHJlc3BvbnNlVHlwZSBpcyAnJyBvciAndGV4dCcgYW5kIG9uIG9sZGVyIGJyb3dzZXJzXG4gICAgICAgIGlmICh4aHIucmVzcG9uc2VUeXBlID09PSAnJyB8fCB4aHIucmVzcG9uc2VUeXBlID09PSAndGV4dCcgfHwgdHlwZW9mIHhoci5yZXNwb25zZVR5cGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0ZXh0ID0geGhyLnJlc3BvbnNlVGV4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHN0YXR1cyBjYW4gYmUgMCB3aGVuIHVzaW5nIHRoZSBgZmlsZTovL2AgcHJvdG9jb2wgc28gd2UgYWxzbyBjaGVjayBpZiBhIHJlc3BvbnNlIGlzIHNldC5cbiAgICAgICAgLy8gSWYgaXQgaGFzIGEgcmVzcG9uc2UsIHdlIGFzc3VtZSAyMDA7IG90aGVyd2lzZSBhIDAgc3RhdHVzIGNvZGUgd2l0aCBubyBjb250ZW50cyBpcyBhbiBhYm9ydGVkIHJlcXVlc3QuXG4gICAgICAgIGlmIChzdGF0dXMgPT09IFNUQVRVU19OT05FICYmICh0ZXh0Lmxlbmd0aCA+IDAgfHwgeGhyLnJlc3BvbnNlVHlwZSA9PT0gUmVzb3VyY2UuWEhSX1JFU1BPTlNFX1RZUEUuQlVGRkVSKSkge1xuICAgICAgICAgICAgc3RhdHVzID0gU1RBVFVTX09LO1xuICAgICAgICB9XG4gICAgICAgIC8vIGhhbmRsZSBJRTkgYnVnOiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEwMDQ2OTcyL21zaWUtcmV0dXJucy1zdGF0dXMtY29kZS1vZi0xMjIzLWZvci1hamF4LXJlcXVlc3RcbiAgICAgICAgZWxzZSBpZiAoc3RhdHVzID09PSBTVEFUVVNfSUVfQlVHX0VNUFRZKSB7XG4gICAgICAgICAgICAgICAgc3RhdHVzID0gU1RBVFVTX0VNUFRZO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIHZhciBzdGF0dXNUeXBlID0gc3RhdHVzIC8gMTAwIHwgMDtcblxuICAgICAgICBpZiAoc3RhdHVzVHlwZSA9PT0gU1RBVFVTX1RZUEVfT0spIHtcbiAgICAgICAgICAgIC8vIGlmIHRleHQsIGp1c3QgcmV0dXJuIGl0XG4gICAgICAgICAgICBpZiAodGhpcy54aHJUeXBlID09PSBSZXNvdXJjZS5YSFJfUkVTUE9OU0VfVFlQRS5URVhUKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhID0gdGV4dDtcbiAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSBSZXNvdXJjZS5UWVBFLlRFWFQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiBqc29uLCBwYXJzZSBpbnRvIGpzb24gb2JqZWN0XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnhoclR5cGUgPT09IFJlc291cmNlLlhIUl9SRVNQT05TRV9UWVBFLkpTT04pIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0YSA9IEpTT04ucGFyc2UodGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSBSZXNvdXJjZS5UWVBFLkpTT047XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWJvcnQoJ0Vycm9yIHRyeWluZyB0byBwYXJzZSBsb2FkZWQganNvbjogJyArIGUpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gaWYgeG1sLCBwYXJzZSBpbnRvIGFuIHhtbCBkb2N1bWVudCBvciBkaXYgZWxlbWVudFxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMueGhyVHlwZSA9PT0gUmVzb3VyY2UuWEhSX1JFU1BPTlNFX1RZUEUuRE9DVU1FTlQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdpbmRvdy5ET01QYXJzZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRvbXBhcnNlciA9IG5ldyBET01QYXJzZXIoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGEgPSBkb21wYXJzZXIucGFyc2VGcm9tU3RyaW5nKHRleHQsICd0ZXh0L3htbCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXYuaW5uZXJIVE1MID0gdGV4dDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGEgPSBkaXY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50eXBlID0gUmVzb3VyY2UuVFlQRS5YTUw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hYm9ydCgnRXJyb3IgdHJ5aW5nIHRvIHBhcnNlIGxvYWRlZCB4bWw6ICcgKyBlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBvdGhlciB0eXBlcyBqdXN0IHJldHVybiB0aGUgcmVzcG9uc2VcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRhID0geGhyLnJlc3BvbnNlIHx8IHRleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFib3J0KCdbJyArIHhoci5zdGF0dXMgKyAnXSAnICsgeGhyLnN0YXR1c1RleHQgKyAnOiAnICsgeGhyLnJlc3BvbnNlVVJMKTtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jb21wbGV0ZSgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBgY3Jvc3NPcmlnaW5gIHByb3BlcnR5IGZvciB0aGlzIHJlc291cmNlIGJhc2VkIG9uIGlmIHRoZSB1cmxcbiAgICAgKiBmb3IgdGhpcyByZXNvdXJjZSBpcyBjcm9zcy1vcmlnaW4uIElmIGNyb3NzT3JpZ2luIHdhcyBtYW51YWxseSBzZXQsIHRoaXNcbiAgICAgKiBmdW5jdGlvbiBkb2VzIG5vdGhpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgLSBUaGUgdXJsIHRvIHRlc3QuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtsb2M9d2luZG93LmxvY2F0aW9uXSAtIFRoZSBsb2NhdGlvbiBvYmplY3QgdG8gdGVzdCBhZ2FpbnN0LlxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGNyb3NzT3JpZ2luIHZhbHVlIHRvIHVzZSAob3IgZW1wdHkgc3RyaW5nIGZvciBub25lKS5cbiAgICAgKi9cblxuXG4gICAgUmVzb3VyY2UucHJvdG90eXBlLl9kZXRlcm1pbmVDcm9zc09yaWdpbiA9IGZ1bmN0aW9uIF9kZXRlcm1pbmVDcm9zc09yaWdpbih1cmwsIGxvYykge1xuICAgICAgICAvLyBkYXRhOiBhbmQgamF2YXNjcmlwdDogdXJscyBhcmUgY29uc2lkZXJlZCBzYW1lLW9yaWdpblxuICAgICAgICBpZiAodXJsLmluZGV4T2YoJ2RhdGE6JykgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEEgc2FuZGJveGVkIGlmcmFtZSB3aXRob3V0IHRoZSAnYWxsb3ctc2FtZS1vcmlnaW4nIGF0dHJpYnV0ZSB3aWxsIGhhdmUgYSBzcGVjaWFsXG4gICAgICAgIC8vIG9yaWdpbiBkZXNpZ25lZCBub3QgdG8gbWF0Y2ggd2luZG93LmxvY2F0aW9uLm9yaWdpbiwgYW5kIHdpbGwgYWx3YXlzIHJlcXVpcmVcbiAgICAgICAgLy8gY3Jvc3NPcmlnaW4gcmVxdWVzdHMgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoZSBsb2NhdGlvbiBtYXRjaGVzLlxuICAgICAgICBpZiAod2luZG93Lm9yaWdpbiAhPT0gd2luZG93LmxvY2F0aW9uLm9yaWdpbikge1xuICAgICAgICAgICAgcmV0dXJuICdhbm9ueW1vdXMnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZGVmYXVsdCBpcyB3aW5kb3cubG9jYXRpb25cbiAgICAgICAgbG9jID0gbG9jIHx8IHdpbmRvdy5sb2NhdGlvbjtcblxuICAgICAgICBpZiAoIXRlbXBBbmNob3IpIHtcbiAgICAgICAgICAgIHRlbXBBbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBsZXQgdGhlIGJyb3dzZXIgZGV0ZXJtaW5lIHRoZSBmdWxsIGhyZWYgZm9yIHRoZSB1cmwgb2YgdGhpcyByZXNvdXJjZSBhbmQgdGhlblxuICAgICAgICAvLyBwYXJzZSB3aXRoIHRoZSBub2RlIHVybCBsaWIsIHdlIGNhbid0IHVzZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgYW5jaG9yIGVsZW1lbnRcbiAgICAgICAgLy8gYmVjYXVzZSB0aGV5IGRvbid0IHdvcmsgaW4gSUU5IDooXG4gICAgICAgIHRlbXBBbmNob3IuaHJlZiA9IHVybDtcbiAgICAgICAgdXJsID0gKDAsIF9wYXJzZVVyaTIuZGVmYXVsdCkodGVtcEFuY2hvci5ocmVmLCB7IHN0cmljdE1vZGU6IHRydWUgfSk7XG5cbiAgICAgICAgdmFyIHNhbWVQb3J0ID0gIXVybC5wb3J0ICYmIGxvYy5wb3J0ID09PSAnJyB8fCB1cmwucG9ydCA9PT0gbG9jLnBvcnQ7XG4gICAgICAgIHZhciBwcm90b2NvbCA9IHVybC5wcm90b2NvbCA/IHVybC5wcm90b2NvbCArICc6JyA6ICcnO1xuXG4gICAgICAgIC8vIGlmIGNyb3NzIG9yaWdpblxuICAgICAgICBpZiAodXJsLmhvc3QgIT09IGxvYy5ob3N0bmFtZSB8fCAhc2FtZVBvcnQgfHwgcHJvdG9jb2wgIT09IGxvYy5wcm90b2NvbCkge1xuICAgICAgICAgICAgcmV0dXJuICdhbm9ueW1vdXMnO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHRoZSByZXNwb25zZVR5cGUgb2YgYW4gWEhSIHJlcXVlc3QgYmFzZWQgb24gdGhlIGV4dGVuc2lvbiBvZiB0aGVcbiAgICAgKiByZXNvdXJjZSBiZWluZyBsb2FkZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge1Jlc291cmNlLlhIUl9SRVNQT05TRV9UWVBFfSBUaGUgcmVzcG9uc2VUeXBlIHRvIHVzZS5cbiAgICAgKi9cblxuXG4gICAgUmVzb3VyY2UucHJvdG90eXBlLl9kZXRlcm1pbmVYaHJUeXBlID0gZnVuY3Rpb24gX2RldGVybWluZVhoclR5cGUoKSB7XG4gICAgICAgIHJldHVybiBSZXNvdXJjZS5feGhyVHlwZU1hcFt0aGlzLmV4dGVuc2lvbl0gfHwgUmVzb3VyY2UuWEhSX1JFU1BPTlNFX1RZUEUuVEVYVDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB0aGUgbG9hZFR5cGUgb2YgYSByZXNvdXJjZSBiYXNlZCBvbiB0aGUgZXh0ZW5zaW9uIG9mIHRoZVxuICAgICAqIHJlc291cmNlIGJlaW5nIGxvYWRlZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7UmVzb3VyY2UuTE9BRF9UWVBFfSBUaGUgbG9hZFR5cGUgdG8gdXNlLlxuICAgICAqL1xuXG5cbiAgICBSZXNvdXJjZS5wcm90b3R5cGUuX2RldGVybWluZUxvYWRUeXBlID0gZnVuY3Rpb24gX2RldGVybWluZUxvYWRUeXBlKCkge1xuICAgICAgICByZXR1cm4gUmVzb3VyY2UuX2xvYWRUeXBlTWFwW3RoaXMuZXh0ZW5zaW9uXSB8fCBSZXNvdXJjZS5MT0FEX1RZUEUuWEhSO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBFeHRyYWN0cyB0aGUgZXh0ZW5zaW9uIChzYW5zICcuJykgb2YgdGhlIGZpbGUgYmVpbmcgbG9hZGVkIGJ5IHRoZSByZXNvdXJjZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgZXh0ZW5zaW9uLlxuICAgICAqL1xuXG5cbiAgICBSZXNvdXJjZS5wcm90b3R5cGUuX2dldEV4dGVuc2lvbiA9IGZ1bmN0aW9uIF9nZXRFeHRlbnNpb24oKSB7XG4gICAgICAgIHZhciB1cmwgPSB0aGlzLnVybDtcbiAgICAgICAgdmFyIGV4dCA9ICcnO1xuXG4gICAgICAgIGlmICh0aGlzLmlzRGF0YVVybCkge1xuICAgICAgICAgICAgdmFyIHNsYXNoSW5kZXggPSB1cmwuaW5kZXhPZignLycpO1xuXG4gICAgICAgICAgICBleHQgPSB1cmwuc3Vic3RyaW5nKHNsYXNoSW5kZXggKyAxLCB1cmwuaW5kZXhPZignOycsIHNsYXNoSW5kZXgpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBxdWVyeVN0YXJ0ID0gdXJsLmluZGV4T2YoJz8nKTtcbiAgICAgICAgICAgIHZhciBoYXNoU3RhcnQgPSB1cmwuaW5kZXhPZignIycpO1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gTWF0aC5taW4ocXVlcnlTdGFydCA+IC0xID8gcXVlcnlTdGFydCA6IHVybC5sZW5ndGgsIGhhc2hTdGFydCA+IC0xID8gaGFzaFN0YXJ0IDogdXJsLmxlbmd0aCk7XG5cbiAgICAgICAgICAgIHVybCA9IHVybC5zdWJzdHJpbmcoMCwgaW5kZXgpO1xuICAgICAgICAgICAgZXh0ID0gdXJsLnN1YnN0cmluZyh1cmwubGFzdEluZGV4T2YoJy4nKSArIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGV4dC50b0xvd2VyQ2FzZSgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHRoZSBtaW1lIHR5cGUgb2YgYW4gWEhSIHJlcXVlc3QgYmFzZWQgb24gdGhlIHJlc3BvbnNlVHlwZSBvZlxuICAgICAqIHJlc291cmNlIGJlaW5nIGxvYWRlZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtSZXNvdXJjZS5YSFJfUkVTUE9OU0VfVFlQRX0gdHlwZSAtIFRoZSB0eXBlIHRvIGdldCBhIG1pbWUgdHlwZSBmb3IuXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgbWltZSB0eXBlIHRvIHVzZS5cbiAgICAgKi9cblxuXG4gICAgUmVzb3VyY2UucHJvdG90eXBlLl9nZXRNaW1lRnJvbVhoclR5cGUgPSBmdW5jdGlvbiBfZ2V0TWltZUZyb21YaHJUeXBlKHR5cGUpIHtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFJlc291cmNlLlhIUl9SRVNQT05TRV9UWVBFLkJVRkZFUjpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2FwcGxpY2F0aW9uL29jdGV0LWJpbmFyeSc7XG5cbiAgICAgICAgICAgIGNhc2UgUmVzb3VyY2UuWEhSX1JFU1BPTlNFX1RZUEUuQkxPQjpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2FwcGxpY2F0aW9uL2Jsb2InO1xuXG4gICAgICAgICAgICBjYXNlIFJlc291cmNlLlhIUl9SRVNQT05TRV9UWVBFLkRPQ1VNRU5UOlxuICAgICAgICAgICAgICAgIHJldHVybiAnYXBwbGljYXRpb24veG1sJztcblxuICAgICAgICAgICAgY2FzZSBSZXNvdXJjZS5YSFJfUkVTUE9OU0VfVFlQRS5KU09OOlxuICAgICAgICAgICAgICAgIHJldHVybiAnYXBwbGljYXRpb24vanNvbic7XG5cbiAgICAgICAgICAgIGNhc2UgUmVzb3VyY2UuWEhSX1JFU1BPTlNFX1RZUEUuREVGQVVMVDpcbiAgICAgICAgICAgIGNhc2UgUmVzb3VyY2UuWEhSX1JFU1BPTlNFX1RZUEUuVEVYVDpcbiAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuICd0ZXh0L3BsYWluJztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBfY3JlYXRlQ2xhc3MoUmVzb3VyY2UsIFt7XG4gICAgICAgIGtleTogJ2lzRGF0YVVybCcsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hhc0ZsYWcoUmVzb3VyY2UuU1RBVFVTX0ZMQUdTLkRBVEFfVVJMKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXNjcmliZXMgaWYgdGhpcyByZXNvdXJjZSBoYXMgZmluaXNoZWQgbG9hZGluZy4gSXMgdHJ1ZSB3aGVuIHRoZSByZXNvdXJjZSBoYXMgY29tcGxldGVseVxuICAgICAgICAgKiBsb2FkZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZWFkb25seVxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnaXNDb21wbGV0ZScsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hhc0ZsYWcoUmVzb3VyY2UuU1RBVFVTX0ZMQUdTLkNPTVBMRVRFKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXNjcmliZXMgaWYgdGhpcyByZXNvdXJjZSBpcyBjdXJyZW50bHkgbG9hZGluZy4gSXMgdHJ1ZSB3aGVuIHRoZSByZXNvdXJjZSBzdGFydHMgbG9hZGluZyxcbiAgICAgICAgICogYW5kIGlzIGZhbHNlIGFnYWluIHdoZW4gY29tcGxldGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZWFkb25seVxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnaXNMb2FkaW5nJyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faGFzRmxhZyhSZXNvdXJjZS5TVEFUVVNfRkxBR1MuTE9BRElORyk7XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gUmVzb3VyY2U7XG59KCk7XG5cbi8qKlxuICogVGhlIHR5cGVzIG9mIHJlc291cmNlcyBhIHJlc291cmNlIGNvdWxkIHJlcHJlc2VudC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAcmVhZG9ubHlcbiAqIEBlbnVtIHtudW1iZXJ9XG4gKi9cblxuXG5SZXNvdXJjZS5TVEFUVVNfRkxBR1MgPSB7XG4gICAgTk9ORTogMCxcbiAgICBEQVRBX1VSTDogMSA8PCAwLFxuICAgIENPTVBMRVRFOiAxIDw8IDEsXG4gICAgTE9BRElORzogMSA8PCAyXG59O1xuXG4vKipcbiAqIFRoZSB0eXBlcyBvZiByZXNvdXJjZXMgYSByZXNvdXJjZSBjb3VsZCByZXByZXNlbnQuXG4gKlxuICogQHN0YXRpY1xuICogQHJlYWRvbmx5XG4gKiBAZW51bSB7bnVtYmVyfVxuICovXG5SZXNvdXJjZS5UWVBFID0ge1xuICAgIFVOS05PV046IDAsXG4gICAgSlNPTjogMSxcbiAgICBYTUw6IDIsXG4gICAgSU1BR0U6IDMsXG4gICAgQVVESU86IDQsXG4gICAgVklERU86IDUsXG4gICAgVEVYVDogNlxufTtcblxuLyoqXG4gKiBUaGUgdHlwZXMgb2YgbG9hZGluZyBhIHJlc291cmNlIGNhbiB1c2UuXG4gKlxuICogQHN0YXRpY1xuICogQHJlYWRvbmx5XG4gKiBAZW51bSB7bnVtYmVyfVxuICovXG5SZXNvdXJjZS5MT0FEX1RZUEUgPSB7XG4gICAgLyoqIFVzZXMgWE1MSHR0cFJlcXVlc3QgdG8gbG9hZCB0aGUgcmVzb3VyY2UuICovXG4gICAgWEhSOiAxLFxuICAgIC8qKiBVc2VzIGFuIGBJbWFnZWAgb2JqZWN0IHRvIGxvYWQgdGhlIHJlc291cmNlLiAqL1xuICAgIElNQUdFOiAyLFxuICAgIC8qKiBVc2VzIGFuIGBBdWRpb2Agb2JqZWN0IHRvIGxvYWQgdGhlIHJlc291cmNlLiAqL1xuICAgIEFVRElPOiAzLFxuICAgIC8qKiBVc2VzIGEgYFZpZGVvYCBvYmplY3QgdG8gbG9hZCB0aGUgcmVzb3VyY2UuICovXG4gICAgVklERU86IDRcbn07XG5cbi8qKlxuICogVGhlIFhIUiByZWFkeSBzdGF0ZXMsIHVzZWQgaW50ZXJuYWxseS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAcmVhZG9ubHlcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cblJlc291cmNlLlhIUl9SRVNQT05TRV9UWVBFID0ge1xuICAgIC8qKiBzdHJpbmcgKi9cbiAgICBERUZBVUxUOiAndGV4dCcsXG4gICAgLyoqIEFycmF5QnVmZmVyICovXG4gICAgQlVGRkVSOiAnYXJyYXlidWZmZXInLFxuICAgIC8qKiBCbG9iICovXG4gICAgQkxPQjogJ2Jsb2InLFxuICAgIC8qKiBEb2N1bWVudCAqL1xuICAgIERPQ1VNRU5UOiAnZG9jdW1lbnQnLFxuICAgIC8qKiBPYmplY3QgKi9cbiAgICBKU09OOiAnanNvbicsXG4gICAgLyoqIFN0cmluZyAqL1xuICAgIFRFWFQ6ICd0ZXh0J1xufTtcblxuUmVzb3VyY2UuX2xvYWRUeXBlTWFwID0ge1xuICAgIC8vIGltYWdlc1xuICAgIGdpZjogUmVzb3VyY2UuTE9BRF9UWVBFLklNQUdFLFxuICAgIHBuZzogUmVzb3VyY2UuTE9BRF9UWVBFLklNQUdFLFxuICAgIGJtcDogUmVzb3VyY2UuTE9BRF9UWVBFLklNQUdFLFxuICAgIGpwZzogUmVzb3VyY2UuTE9BRF9UWVBFLklNQUdFLFxuICAgIGpwZWc6IFJlc291cmNlLkxPQURfVFlQRS5JTUFHRSxcbiAgICB0aWY6IFJlc291cmNlLkxPQURfVFlQRS5JTUFHRSxcbiAgICB0aWZmOiBSZXNvdXJjZS5MT0FEX1RZUEUuSU1BR0UsXG4gICAgd2VicDogUmVzb3VyY2UuTE9BRF9UWVBFLklNQUdFLFxuICAgIHRnYTogUmVzb3VyY2UuTE9BRF9UWVBFLklNQUdFLFxuICAgIHN2ZzogUmVzb3VyY2UuTE9BRF9UWVBFLklNQUdFLFxuICAgICdzdmcreG1sJzogUmVzb3VyY2UuTE9BRF9UWVBFLklNQUdFLCAvLyBmb3IgU1ZHIGRhdGEgdXJsc1xuXG4gICAgLy8gYXVkaW9cbiAgICBtcDM6IFJlc291cmNlLkxPQURfVFlQRS5BVURJTyxcbiAgICBvZ2c6IFJlc291cmNlLkxPQURfVFlQRS5BVURJTyxcbiAgICB3YXY6IFJlc291cmNlLkxPQURfVFlQRS5BVURJTyxcblxuICAgIC8vIHZpZGVvc1xuICAgIG1wNDogUmVzb3VyY2UuTE9BRF9UWVBFLlZJREVPLFxuICAgIHdlYm06IFJlc291cmNlLkxPQURfVFlQRS5WSURFT1xufTtcblxuUmVzb3VyY2UuX3hoclR5cGVNYXAgPSB7XG4gICAgLy8geG1sXG4gICAgeGh0bWw6IFJlc291cmNlLlhIUl9SRVNQT05TRV9UWVBFLkRPQ1VNRU5ULFxuICAgIGh0bWw6IFJlc291cmNlLlhIUl9SRVNQT05TRV9UWVBFLkRPQ1VNRU5ULFxuICAgIGh0bTogUmVzb3VyY2UuWEhSX1JFU1BPTlNFX1RZUEUuRE9DVU1FTlQsXG4gICAgeG1sOiBSZXNvdXJjZS5YSFJfUkVTUE9OU0VfVFlQRS5ET0NVTUVOVCxcbiAgICB0bXg6IFJlc291cmNlLlhIUl9SRVNQT05TRV9UWVBFLkRPQ1VNRU5ULFxuICAgIHN2ZzogUmVzb3VyY2UuWEhSX1JFU1BPTlNFX1RZUEUuRE9DVU1FTlQsXG5cbiAgICAvLyBUaGlzIHdhcyBhZGRlZCB0byBoYW5kbGUgVGlsZWQgVGlsZXNldCBYTUwsIGJ1dCAudHN4IGlzIGFsc28gYSBUeXBlU2NyaXB0IFJlYWN0IENvbXBvbmVudC5cbiAgICAvLyBTaW5jZSBpdCBpcyB3YXkgbGVzcyBsaWtlbHkgZm9yIHBlb3BsZSB0byBiZSBsb2FkaW5nIFR5cGVTY3JpcHQgZmlsZXMgaW5zdGVhZCBvZiBUaWxlZCBmaWxlcyxcbiAgICAvLyB0aGlzIHNob3VsZCBwcm9iYWJseSBiZSBmaW5lLlxuICAgIHRzeDogUmVzb3VyY2UuWEhSX1JFU1BPTlNFX1RZUEUuRE9DVU1FTlQsXG5cbiAgICAvLyBpbWFnZXNcbiAgICBnaWY6IFJlc291cmNlLlhIUl9SRVNQT05TRV9UWVBFLkJMT0IsXG4gICAgcG5nOiBSZXNvdXJjZS5YSFJfUkVTUE9OU0VfVFlQRS5CTE9CLFxuICAgIGJtcDogUmVzb3VyY2UuWEhSX1JFU1BPTlNFX1RZUEUuQkxPQixcbiAgICBqcGc6IFJlc291cmNlLlhIUl9SRVNQT05TRV9UWVBFLkJMT0IsXG4gICAganBlZzogUmVzb3VyY2UuWEhSX1JFU1BPTlNFX1RZUEUuQkxPQixcbiAgICB0aWY6IFJlc291cmNlLlhIUl9SRVNQT05TRV9UWVBFLkJMT0IsXG4gICAgdGlmZjogUmVzb3VyY2UuWEhSX1JFU1BPTlNFX1RZUEUuQkxPQixcbiAgICB3ZWJwOiBSZXNvdXJjZS5YSFJfUkVTUE9OU0VfVFlQRS5CTE9CLFxuICAgIHRnYTogUmVzb3VyY2UuWEhSX1JFU1BPTlNFX1RZUEUuQkxPQixcblxuICAgIC8vIGpzb25cbiAgICBqc29uOiBSZXNvdXJjZS5YSFJfUkVTUE9OU0VfVFlQRS5KU09OLFxuXG4gICAgLy8gdGV4dFxuICAgIHRleHQ6IFJlc291cmNlLlhIUl9SRVNQT05TRV9UWVBFLlRFWFQsXG4gICAgdHh0OiBSZXNvdXJjZS5YSFJfUkVTUE9OU0VfVFlQRS5URVhULFxuXG4gICAgLy8gZm9udHNcbiAgICB0dGY6IFJlc291cmNlLlhIUl9SRVNQT05TRV9UWVBFLkJVRkZFUixcbiAgICBvdGY6IFJlc291cmNlLlhIUl9SRVNQT05TRV9UWVBFLkJVRkZFUlxufTtcblxuLy8gV2UgY2FuJ3Qgc2V0IHRoZSBgc3JjYCBhdHRyaWJ1dGUgdG8gZW1wdHkgc3RyaW5nLCBzbyBvbiBhYm9ydCB3ZSBzZXQgaXQgdG8gdGhpcyAxcHggdHJhbnNwYXJlbnQgZ2lmXG5SZXNvdXJjZS5FTVBUWV9HSUYgPSAnZGF0YTppbWFnZS9naWY7YmFzZTY0LFIwbEdPRGxoQVFBQkFJQUFBUC8vL3dBQUFDSDVCQUVBQUFBQUxBQUFBQUFCQUFFQUFBSUNSQUVBT3c9PSc7XG5cbi8qKlxuICogUXVpY2sgaGVscGVyIHRvIHNldCBhIHZhbHVlIG9uIG9uZSBvZiB0aGUgZXh0ZW5zaW9uIG1hcHMuIEVuc3VyZXMgdGhlcmUgaXMgbm9cbiAqIGRvdCBhdCB0aGUgc3RhcnQgb2YgdGhlIGV4dGVuc2lvbi5cbiAqXG4gKiBAaWdub3JlXG4gKiBAcGFyYW0ge29iamVjdH0gbWFwIC0gVGhlIG1hcCB0byBzZXQgb24uXG4gKiBAcGFyYW0ge3N0cmluZ30gZXh0bmFtZSAtIFRoZSBleHRlbnNpb24gKG9yIGtleSkgdG8gc2V0LlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbCAtIFRoZSB2YWx1ZSB0byBzZXQuXG4gKi9cbmZ1bmN0aW9uIHNldEV4dE1hcChtYXAsIGV4dG5hbWUsIHZhbCkge1xuICAgIGlmIChleHRuYW1lICYmIGV4dG5hbWUuaW5kZXhPZignLicpID09PSAwKSB7XG4gICAgICAgIGV4dG5hbWUgPSBleHRuYW1lLnN1YnN0cmluZygxKTtcbiAgICB9XG5cbiAgICBpZiAoIWV4dG5hbWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG1hcFtleHRuYW1lXSA9IHZhbDtcbn1cblxuLyoqXG4gKiBRdWljayBoZWxwZXIgdG8gZ2V0IHN0cmluZyB4aHIgdHlwZS5cbiAqXG4gKiBAaWdub3JlXG4gKiBAcGFyYW0ge1hNTEh0dHBSZXF1ZXN0fFhEb21haW5SZXF1ZXN0fSB4aHIgLSBUaGUgcmVxdWVzdCB0byBjaGVjay5cbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHR5cGUuXG4gKi9cbmZ1bmN0aW9uIHJlcVR5cGUoeGhyKSB7XG4gICAgcmV0dXJuIHhoci50b1N0cmluZygpLnJlcGxhY2UoJ29iamVjdCAnLCAnJyk7XG59XG5cbi8vIEJhY2t3YXJkcyBjb21wYXRcbmlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge1xuICAgIG1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBSZXNvdXJjZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmVzb3VyY2UuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5lYWNoU2VyaWVzID0gZWFjaFNlcmllcztcbmV4cG9ydHMucXVldWUgPSBxdWV1ZTtcbi8qKlxuICogU21hbGxlciB2ZXJzaW9uIG9mIHRoZSBhc3luYyBsaWJyYXJ5IGNvbnN0cnVjdHMuXG4gKlxuICogQG5hbWVzcGFjZSBhc3luY1xuICovXG5cbi8qKlxuICogTm9vcCBmdW5jdGlvblxuICpcbiAqIEBpZ25vcmVcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIGFzeW5jXG4gKi9cbmZ1bmN0aW9uIF9ub29wKCkge30gLyogZW1wdHkgKi9cblxuLyoqXG4gKiBJdGVyYXRlcyBhbiBhcnJheSBpbiBzZXJpZXMuXG4gKlxuICogQG1lbWJlcm9mIGFzeW5jXG4gKiBAcGFyYW0ge0FycmF5LjwqPn0gYXJyYXkgLSBBcnJheSB0byBpdGVyYXRlLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gaXRlcmF0b3IgLSBGdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIGVsZW1lbnQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAtIEZ1bmN0aW9uIHRvIGNhbGwgd2hlbiBkb25lLCBvciBvbiBlcnJvci5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2RlZmVyTmV4dD1mYWxzZV0gLSBCcmVhayBzeW5jaHJvbm91cyBlYWNoIGxvb3AgYnkgY2FsbGluZyBuZXh0IHdpdGggYSBzZXRUaW1lb3V0IG9mIDEuXG4gKi9cbmZ1bmN0aW9uIGVhY2hTZXJpZXMoYXJyYXksIGl0ZXJhdG9yLCBjYWxsYmFjaywgZGVmZXJOZXh0KSB7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBsZW4gPSBhcnJheS5sZW5ndGg7XG5cbiAgICAoZnVuY3Rpb24gbmV4dChlcnIpIHtcbiAgICAgICAgaWYgKGVyciB8fCBpID09PSBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZWZlck5leHQpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGl0ZXJhdG9yKGFycmF5W2krK10sIG5leHQpO1xuICAgICAgICAgICAgfSwgMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpdGVyYXRvcihhcnJheVtpKytdLCBuZXh0KTtcbiAgICAgICAgfVxuICAgIH0pKCk7XG59XG5cbi8qKlxuICogRW5zdXJlcyBhIGZ1bmN0aW9uIGlzIG9ubHkgY2FsbGVkIG9uY2UuXG4gKlxuICogQGlnbm9yZVxuICogQG1lbWJlcm9mIGFzeW5jXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBmbiAtIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICogQHJldHVybiB7ZnVuY3Rpb259IFRoZSB3cmFwcGluZyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb25seU9uY2UoZm4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gb25jZVdyYXBwZXIoKSB7XG4gICAgICAgIGlmIChmbiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYWxsYmFjayB3YXMgYWxyZWFkeSBjYWxsZWQuJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2FsbEZuID0gZm47XG5cbiAgICAgICAgZm4gPSBudWxsO1xuICAgICAgICBjYWxsRm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xufVxuXG4vKipcbiAqIEFzeW5jIHF1ZXVlIGltcGxlbWVudGF0aW9uLFxuICpcbiAqIEBtZW1iZXJvZiBhc3luY1xuICogQHBhcmFtIHtmdW5jdGlvbn0gd29ya2VyIC0gVGhlIHdvcmtlciBmdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIHRhc2suXG4gKiBAcGFyYW0ge251bWJlcn0gY29uY3VycmVuY3kgLSBIb3cgbWFueSB3b3JrZXJzIHRvIHJ1biBpbiBwYXJyYWxsZWwuXG4gKiBAcmV0dXJuIHsqfSBUaGUgYXN5bmMgcXVldWUgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBxdWV1ZSh3b3JrZXIsIGNvbmN1cnJlbmN5KSB7XG4gICAgaWYgKGNvbmN1cnJlbmN5ID09IG51bGwpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1lcS1udWxsLGVxZXFlcVxuICAgICAgICBjb25jdXJyZW5jeSA9IDE7XG4gICAgfSBlbHNlIGlmIChjb25jdXJyZW5jeSA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbmN1cnJlbmN5IG11c3Qgbm90IGJlIHplcm8nKTtcbiAgICB9XG5cbiAgICB2YXIgd29ya2VycyA9IDA7XG4gICAgdmFyIHEgPSB7XG4gICAgICAgIF90YXNrczogW10sXG4gICAgICAgIGNvbmN1cnJlbmN5OiBjb25jdXJyZW5jeSxcbiAgICAgICAgc2F0dXJhdGVkOiBfbm9vcCxcbiAgICAgICAgdW5zYXR1cmF0ZWQ6IF9ub29wLFxuICAgICAgICBidWZmZXI6IGNvbmN1cnJlbmN5IC8gNCxcbiAgICAgICAgZW1wdHk6IF9ub29wLFxuICAgICAgICBkcmFpbjogX25vb3AsXG4gICAgICAgIGVycm9yOiBfbm9vcCxcbiAgICAgICAgc3RhcnRlZDogZmFsc2UsXG4gICAgICAgIHBhdXNlZDogZmFsc2UsXG4gICAgICAgIHB1c2g6IGZ1bmN0aW9uIHB1c2goZGF0YSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIF9pbnNlcnQoZGF0YSwgZmFsc2UsIGNhbGxiYWNrKTtcbiAgICAgICAgfSxcbiAgICAgICAga2lsbDogZnVuY3Rpb24ga2lsbCgpIHtcbiAgICAgICAgICAgIHdvcmtlcnMgPSAwO1xuICAgICAgICAgICAgcS5kcmFpbiA9IF9ub29wO1xuICAgICAgICAgICAgcS5zdGFydGVkID0gZmFsc2U7XG4gICAgICAgICAgICBxLl90YXNrcyA9IFtdO1xuICAgICAgICB9LFxuICAgICAgICB1bnNoaWZ0OiBmdW5jdGlvbiB1bnNoaWZ0KGRhdGEsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBfaW5zZXJ0KGRhdGEsIHRydWUsIGNhbGxiYWNrKTtcbiAgICAgICAgfSxcbiAgICAgICAgcHJvY2VzczogZnVuY3Rpb24gcHJvY2VzcygpIHtcbiAgICAgICAgICAgIHdoaWxlICghcS5wYXVzZWQgJiYgd29ya2VycyA8IHEuY29uY3VycmVuY3kgJiYgcS5fdGFza3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhc2sgPSBxLl90YXNrcy5zaGlmdCgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHEuX3Rhc2tzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBxLmVtcHR5KCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgd29ya2VycyArPSAxO1xuXG4gICAgICAgICAgICAgICAgaWYgKHdvcmtlcnMgPT09IHEuY29uY3VycmVuY3kpIHtcbiAgICAgICAgICAgICAgICAgICAgcS5zYXR1cmF0ZWQoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB3b3JrZXIodGFzay5kYXRhLCBvbmx5T25jZShfbmV4dCh0YXNrKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBsZW5ndGg6IGZ1bmN0aW9uIGxlbmd0aCgpIHtcbiAgICAgICAgICAgIHJldHVybiBxLl90YXNrcy5sZW5ndGg7XG4gICAgICAgIH0sXG4gICAgICAgIHJ1bm5pbmc6IGZ1bmN0aW9uIHJ1bm5pbmcoKSB7XG4gICAgICAgICAgICByZXR1cm4gd29ya2VycztcbiAgICAgICAgfSxcbiAgICAgICAgaWRsZTogZnVuY3Rpb24gaWRsZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBxLl90YXNrcy5sZW5ndGggKyB3b3JrZXJzID09PSAwO1xuICAgICAgICB9LFxuICAgICAgICBwYXVzZTogZnVuY3Rpb24gcGF1c2UoKSB7XG4gICAgICAgICAgICBpZiAocS5wYXVzZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHEucGF1c2VkID0gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVzdW1lOiBmdW5jdGlvbiByZXN1bWUoKSB7XG4gICAgICAgICAgICBpZiAocS5wYXVzZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBxLnBhdXNlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAvLyBOZWVkIHRvIGNhbGwgcS5wcm9jZXNzIG9uY2UgcGVyIGNvbmN1cnJlbnRcbiAgICAgICAgICAgIC8vIHdvcmtlciB0byBwcmVzZXJ2ZSBmdWxsIGNvbmN1cnJlbmN5IGFmdGVyIHBhdXNlXG4gICAgICAgICAgICBmb3IgKHZhciB3ID0gMTsgdyA8PSBxLmNvbmN1cnJlbmN5OyB3KyspIHtcbiAgICAgICAgICAgICAgICBxLnByb2Nlc3MoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBfaW5zZXJ0KGRhdGEsIGluc2VydEF0RnJvbnQsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChjYWxsYmFjayAhPSBudWxsICYmIHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1lcS1udWxsLGVxZXFlcVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0YXNrIGNhbGxiYWNrIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgICB9XG5cbiAgICAgICAgcS5zdGFydGVkID0gdHJ1ZTtcblxuICAgICAgICBpZiAoZGF0YSA9PSBudWxsICYmIHEuaWRsZSgpKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWVxLW51bGwsZXFlcWVxXG4gICAgICAgICAgICAvLyBjYWxsIGRyYWluIGltbWVkaWF0ZWx5IGlmIHRoZXJlIGFyZSBubyB0YXNrc1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHEuZHJhaW4oKTtcbiAgICAgICAgICAgIH0sIDEpO1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaXRlbSA9IHtcbiAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICBjYWxsYmFjazogdHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nID8gY2FsbGJhY2sgOiBfbm9vcFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChpbnNlcnRBdEZyb250KSB7XG4gICAgICAgICAgICBxLl90YXNrcy51bnNoaWZ0KGl0ZW0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcS5fdGFza3MucHVzaChpdGVtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHEucHJvY2VzcygpO1xuICAgICAgICB9LCAxKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfbmV4dCh0YXNrKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgICAgd29ya2VycyAtPSAxO1xuXG4gICAgICAgICAgICB0YXNrLmNhbGxiYWNrLmFwcGx5KHRhc2ssIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIGlmIChhcmd1bWVudHNbMF0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZXEtbnVsbCxlcWVxZXFcbiAgICAgICAgICAgICAgICBxLmVycm9yKGFyZ3VtZW50c1swXSwgdGFzay5kYXRhKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHdvcmtlcnMgPD0gcS5jb25jdXJyZW5jeSAtIHEuYnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgcS51bnNhdHVyYXRlZCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocS5pZGxlKCkpIHtcbiAgICAgICAgICAgICAgICBxLmRyYWluKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHEucHJvY2VzcygpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBxO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXN5bmMuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5lbmNvZGVCaW5hcnkgPSBlbmNvZGVCaW5hcnk7XG52YXIgX2tleVN0ciA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPSc7XG5cbi8qKlxuICogRW5jb2RlcyBiaW5hcnkgaW50byBiYXNlNjQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGlucHV0IFRoZSBpbnB1dCBkYXRhIHRvIGVuY29kZS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBlbmNvZGVkIGJhc2U2NCBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gZW5jb2RlQmluYXJ5KGlucHV0KSB7XG4gICAgdmFyIG91dHB1dCA9ICcnO1xuICAgIHZhciBpbnggPSAwO1xuXG4gICAgd2hpbGUgKGlueCA8IGlucHV0Lmxlbmd0aCkge1xuICAgICAgICAvLyBGaWxsIGJ5dGUgYnVmZmVyIGFycmF5XG4gICAgICAgIHZhciBieXRlYnVmZmVyID0gWzAsIDAsIDBdO1xuICAgICAgICB2YXIgZW5jb2RlZENoYXJJbmRleGVzID0gWzAsIDAsIDAsIDBdO1xuXG4gICAgICAgIGZvciAodmFyIGpueCA9IDA7IGpueCA8IGJ5dGVidWZmZXIubGVuZ3RoOyArK2pueCkge1xuICAgICAgICAgICAgaWYgKGlueCA8IGlucHV0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vIHRocm93IGF3YXkgaGlnaC1vcmRlciBieXRlLCBhcyBkb2N1bWVudGVkIGF0OlxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL0VuL1VzaW5nX1hNTEh0dHBSZXF1ZXN0I0hhbmRsaW5nX2JpbmFyeV9kYXRhXG4gICAgICAgICAgICAgICAgYnl0ZWJ1ZmZlcltqbnhdID0gaW5wdXQuY2hhckNvZGVBdChpbngrKykgJiAweGZmO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBieXRlYnVmZmVyW2pueF0gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2V0IGVhY2ggZW5jb2RlZCBjaGFyYWN0ZXIsIDYgYml0cyBhdCBhIHRpbWVcbiAgICAgICAgLy8gaW5kZXggMTogZmlyc3QgNiBiaXRzXG4gICAgICAgIGVuY29kZWRDaGFySW5kZXhlc1swXSA9IGJ5dGVidWZmZXJbMF0gPj4gMjtcblxuICAgICAgICAvLyBpbmRleCAyOiBzZWNvbmQgNiBiaXRzICgyIGxlYXN0IHNpZ25pZmljYW50IGJpdHMgZnJvbSBpbnB1dCBieXRlIDEgKyA0IG1vc3Qgc2lnbmlmaWNhbnQgYml0cyBmcm9tIGJ5dGUgMilcbiAgICAgICAgZW5jb2RlZENoYXJJbmRleGVzWzFdID0gKGJ5dGVidWZmZXJbMF0gJiAweDMpIDw8IDQgfCBieXRlYnVmZmVyWzFdID4+IDQ7XG5cbiAgICAgICAgLy8gaW5kZXggMzogdGhpcmQgNiBiaXRzICg0IGxlYXN0IHNpZ25pZmljYW50IGJpdHMgZnJvbSBpbnB1dCBieXRlIDIgKyAyIG1vc3Qgc2lnbmlmaWNhbnQgYml0cyBmcm9tIGJ5dGUgMylcbiAgICAgICAgZW5jb2RlZENoYXJJbmRleGVzWzJdID0gKGJ5dGVidWZmZXJbMV0gJiAweDBmKSA8PCAyIHwgYnl0ZWJ1ZmZlclsyXSA+PiA2O1xuXG4gICAgICAgIC8vIGluZGV4IDM6IGZvcnRoIDYgYml0cyAoNiBsZWFzdCBzaWduaWZpY2FudCBiaXRzIGZyb20gaW5wdXQgYnl0ZSAzKVxuICAgICAgICBlbmNvZGVkQ2hhckluZGV4ZXNbM10gPSBieXRlYnVmZmVyWzJdICYgMHgzZjtcblxuICAgICAgICAvLyBEZXRlcm1pbmUgd2hldGhlciBwYWRkaW5nIGhhcHBlbmVkLCBhbmQgYWRqdXN0IGFjY29yZGluZ2x5XG4gICAgICAgIHZhciBwYWRkaW5nQnl0ZXMgPSBpbnggLSAoaW5wdXQubGVuZ3RoIC0gMSk7XG5cbiAgICAgICAgc3dpdGNoIChwYWRkaW5nQnl0ZXMpIHtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAvLyBTZXQgbGFzdCAyIGNoYXJhY3RlcnMgdG8gcGFkZGluZyBjaGFyXG4gICAgICAgICAgICAgICAgZW5jb2RlZENoYXJJbmRleGVzWzNdID0gNjQ7XG4gICAgICAgICAgICAgICAgZW5jb2RlZENoYXJJbmRleGVzWzJdID0gNjQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAvLyBTZXQgbGFzdCBjaGFyYWN0ZXIgdG8gcGFkZGluZyBjaGFyXG4gICAgICAgICAgICAgICAgZW5jb2RlZENoYXJJbmRleGVzWzNdID0gNjQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgYnJlYWs7IC8vIE5vIHBhZGRpbmcgLSBwcm9jZWVkXG4gICAgICAgIH1cblxuICAgICAgICAvLyBOb3cgd2Ugd2lsbCBncmFiIGVhY2ggYXBwcm9wcmlhdGUgY2hhcmFjdGVyIG91dCBvZiBvdXIga2V5c3RyaW5nXG4gICAgICAgIC8vIGJhc2VkIG9uIG91ciBpbmRleCBhcnJheSBhbmQgYXBwZW5kIGl0IHRvIHRoZSBvdXRwdXQgc3RyaW5nXG4gICAgICAgIGZvciAodmFyIF9qbnggPSAwOyBfam54IDwgZW5jb2RlZENoYXJJbmRleGVzLmxlbmd0aDsgKytfam54KSB7XG4gICAgICAgICAgICBvdXRwdXQgKz0gX2tleVN0ci5jaGFyQXQoZW5jb2RlZENoYXJJbmRleGVzW19qbnhdKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvdXRwdXQ7XG59XG5cbi8vIEJhY2t3YXJkcyBjb21wYXRcbmlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge1xuICAgIG1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBlbmNvZGVCaW5hcnk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWI2NC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbi8vIGltcG9ydCBMb2FkZXIgZnJvbSAnLi9Mb2FkZXInO1xuLy8gaW1wb3J0IFJlc291cmNlIGZyb20gJy4vUmVzb3VyY2UnO1xuLy8gaW1wb3J0ICogYXMgYXN5bmMgZnJvbSAnLi9hc3luYyc7XG4vLyBpbXBvcnQgKiBhcyBiNjQgZnJvbSAnLi9iNjQnO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bmRlZiAqL1xuXG52YXIgTG9hZGVyID0gcmVxdWlyZSgnLi9Mb2FkZXInKS5Mb2FkZXI7XG52YXIgUmVzb3VyY2UgPSByZXF1aXJlKCcuL1Jlc291cmNlJykuUmVzb3VyY2U7XG52YXIgYXN5bmMgPSByZXF1aXJlKCcuL2FzeW5jJyk7XG52YXIgYjY0ID0gcmVxdWlyZSgnLi9iNjQnKTtcblxuLyoqXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlcm9mIExvYWRlclxuICogQG1lbWJlciB7Q2xhc3M8UmVzb3VyY2U+fVxuICovXG5Mb2FkZXIuUmVzb3VyY2UgPSBSZXNvdXJjZTtcblxuLyoqXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlcm9mIExvYWRlclxuICogQG1lbWJlciB7Q2xhc3M8YXN5bmM+fVxuICovXG5Mb2FkZXIuYXN5bmMgPSBhc3luYztcblxuLyoqXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlcm9mIExvYWRlclxuICogQG1lbWJlciB7Q2xhc3M8ZW5jb2RlQmluYXJ5Pn1cbiAqL1xuTG9hZGVyLmVuY29kZUJpbmFyeSA9IGI2NDtcblxuLyoqXG4gKlxuICogQGRlcHJlY2F0ZWRcbiAqIEBzZWUgTG9hZGVyLmVuY29kZUJpbmFyeVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJvZiBMb2FkZXJcbiAqIEBtZW1iZXIge0NsYXNzPGVuY29kZUJpbmFyeT59XG4gKi9cbkxvYWRlci5iYXNlNjQgPSBiNjQ7XG5cbi8vIGV4cG9ydCBtYW51YWxseSwgYW5kIGFsc28gYXMgZGVmYXVsdFxubW9kdWxlLmV4cG9ydHMgPSBMb2FkZXI7XG5cbi8vIGRlZmF1bHQgJiBuYW1lZCBleHBvcnRcbm1vZHVsZS5leHBvcnRzLkxvYWRlciA9IExvYWRlcjtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBMb2FkZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmJsb2JNaWRkbGV3YXJlRmFjdG9yeSA9IGJsb2JNaWRkbGV3YXJlRmFjdG9yeTtcblxudmFyIF9SZXNvdXJjZSA9IHJlcXVpcmUoJy4uLy4uL1Jlc291cmNlJyk7XG5cbnZhciBfYiA9IHJlcXVpcmUoJy4uLy4uL2I2NCcpO1xuXG52YXIgVXJsID0gd2luZG93LlVSTCB8fCB3aW5kb3cud2Via2l0VVJMO1xuXG4vLyBhIG1pZGRsZXdhcmUgZm9yIHRyYW5zZm9ybWluZyBYSFIgbG9hZGVkIEJsb2JzIGludG8gbW9yZSB1c2VmdWwgb2JqZWN0c1xuZnVuY3Rpb24gYmxvYk1pZGRsZXdhcmVGYWN0b3J5KCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBibG9iTWlkZGxld2FyZShyZXNvdXJjZSwgbmV4dCkge1xuICAgICAgICBpZiAoIXJlc291cmNlLmRhdGEpIHtcbiAgICAgICAgICAgIG5leHQoKTtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgdGhpcyB3YXMgYW4gWEhSIGxvYWQgb2YgYSBibG9iXG4gICAgICAgIGlmIChyZXNvdXJjZS54aHIgJiYgcmVzb3VyY2UueGhyVHlwZSA9PT0gX1Jlc291cmNlLlJlc291cmNlLlhIUl9SRVNQT05TRV9UWVBFLkJMT0IpIHtcbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIG5vIGJsb2Igc3VwcG9ydCB3ZSBwcm9iYWJseSBnb3QgYSBiaW5hcnkgc3RyaW5nIGJhY2tcbiAgICAgICAgICAgIGlmICghd2luZG93LkJsb2IgfHwgdHlwZW9mIHJlc291cmNlLmRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdmFyIHR5cGUgPSByZXNvdXJjZS54aHIuZ2V0UmVzcG9uc2VIZWFkZXIoJ2NvbnRlbnQtdHlwZScpO1xuXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBhbiBpbWFnZSwgY29udmVydCB0aGUgYmluYXJ5IHN0cmluZyBpbnRvIGEgZGF0YSB1cmxcbiAgICAgICAgICAgICAgICBpZiAodHlwZSAmJiB0eXBlLmluZGV4T2YoJ2ltYWdlJykgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2UuZGF0YSA9IG5ldyBJbWFnZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXNvdXJjZS5kYXRhLnNyYyA9ICdkYXRhOicgKyB0eXBlICsgJztiYXNlNjQsJyArICgwLCBfYi5lbmNvZGVCaW5hcnkpKHJlc291cmNlLnhoci5yZXNwb25zZVRleHQpO1xuXG4gICAgICAgICAgICAgICAgICAgIHJlc291cmNlLnR5cGUgPSBfUmVzb3VyY2UuUmVzb3VyY2UuVFlQRS5JTUFHRTtcblxuICAgICAgICAgICAgICAgICAgICAvLyB3YWl0IHVudGlsIHRoZSBpbWFnZSBsb2FkcyBhbmQgdGhlbiBjYWxsYmFja1xuICAgICAgICAgICAgICAgICAgICByZXNvdXJjZS5kYXRhLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc291cmNlLmRhdGEub25sb2FkID0gbnVsbDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIG5leHQgd2lsbCBiZSBjYWxsZWQgb24gbG9hZFxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgY29udGVudCB0eXBlIHNheXMgdGhpcyBpcyBhbiBpbWFnZSwgdGhlbiB3ZSBzaG91bGQgdHJhbnNmb3JtIHRoZSBibG9iIGludG8gYW4gSW1hZ2Ugb2JqZWN0XG4gICAgICAgICAgICBlbHNlIGlmIChyZXNvdXJjZS5kYXRhLnR5cGUuaW5kZXhPZignaW1hZ2UnKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3JjID0gVXJsLmNyZWF0ZU9iamVjdFVSTChyZXNvdXJjZS5kYXRhKTtcblxuICAgICAgICAgICAgICAgICAgICByZXNvdXJjZS5ibG9iID0gcmVzb3VyY2UuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2UuZGF0YSA9IG5ldyBJbWFnZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXNvdXJjZS5kYXRhLnNyYyA9IHNyYztcblxuICAgICAgICAgICAgICAgICAgICByZXNvdXJjZS50eXBlID0gX1Jlc291cmNlLlJlc291cmNlLlRZUEUuSU1BR0U7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gY2xlYW51cCB0aGUgbm8gbG9uZ2VyIHVzZWQgYmxvYiBhZnRlciB0aGUgaW1hZ2UgbG9hZHNcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogSXMgdGhpcyBjb3JyZWN0PyBXaWxsIHRoZSBpbWFnZSBiZSBpbnZhbGlkIGFmdGVyIHJldm9raW5nP1xuICAgICAgICAgICAgICAgICAgICByZXNvdXJjZS5kYXRhLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFVybC5yZXZva2VPYmplY3RVUkwoc3JjKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc291cmNlLmRhdGEub25sb2FkID0gbnVsbDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIG5leHQgd2lsbCBiZSBjYWxsZWQgb24gbG9hZC5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG5leHQoKTtcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmxvYi5qcy5tYXAiLCIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgdHlwZUlEID0gXCJVSURPRlRZUEVPRlRZUEVTSlNcIjtcclxudmFyIGNyVHlwZUlEID0gXCJVSURPRkNPTlNUUlVDVE9ST0ZUWVBFT0ZUWVBFU0pTXCI7XHJcblxyXG52YXIgaXNUZXN0ID0gdHJ1ZTtcclxuXHJcbnZhciBUeXBlcyA9IHtcclxuXHRuZXdUeXBlOiBmdW5jdGlvbiAobmFtZSwgQ3JUeXBlLCBvdXRKU09OKXtcclxuXHRcdGlmKHR5cGVvZiBuYW1lICE9IFwic3RyaW5nXCIpXHJcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIm5hbWUgaXNuJ3QgU3RyaW5nIVwiKVxyXG5cclxuXHRcdGlmKHR5cGVvZiBDclR5cGUgIT0gXCJmdW5jdGlvblwiKVxyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJDclR5cGUgaXNuJ3QgRnVuY3Rpb24hXCIpXHJcblxyXG5cdFx0aWYodHlwZW9mIG91dEpTT04gIT0gXCJmdW5jdGlvblwiKVxyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJvdXRKU09OIGlzbid0IEZ1bmN0aW9uIVwiKVxyXG5cclxuXHRcdGlmKHRoaXNbbmFtZV0pe1xyXG5cdFx0XHRjb25zb2xlLndhcm4oXCJUeXBlIFwiICsgbmFtZSArIFwiYWxyZWFkeSBjcmVhdGVkIVwiKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBuZXdUeXBlID0ge1xyXG5cdFx0XHRuYW1lOiBuYW1lLFxyXG5cdFx0XHREZWY6IG5ld0NyZWF0b3IoQ3JUeXBlKSxcclxuXHRcdFx0b3V0SlNPTjogY3JPdXRKU09OKG91dEpTT04pLFxyXG5cdFx0fTtcclxuXHJcblx0XHRuZXdUeXBlW2NyVHlwZUlEXSA9IGNyVHlwZUlEO1xyXG5cclxuXHRcdHRoaXNbbmFtZV0gPSBuZXdUeXBlO1xyXG5cclxuXHRcdHJldHVybiB0aGlzW25hbWVdO1xyXG5cclxuXHR9LFxyXG5cdGlzVHlwZTogaXNUeXBlLFxyXG5cdGlzQ3JUeXBlOiBpc0NyVHlwZSxcclxuXHRnZXQgaXNUZXN0KCl7cmV0dXJuIGlzVGVzdH0sXHJcblx0c2V0IGlzVGVzdCh2YWwpe2lzVGVzdCA9ICEhdmFsfSxcclxuXHRhcmdFcnJvcjogZnVuY3Rpb24gYXJnRXJyb3Iod3JvbmdfYXJnLCBtZXNzKXtcclxuXHRcdGlmKG1lc3MgPT09IHVuZGVmaW5lZCkgbWVzcyA9ICcnO1xyXG5cdFx0dmFyIEVSID0gbmV3IFR5cGVFcnJvcignQXJndW1lbnQgdHlwZSBpcyB3cm9uZyEgQXJndW1lbnRzKCcgKyBmb3JBcmcod3JvbmdfYXJnKSArICcpOycgKyBtZXNzKTtcclxuXHRcdEVSLndyb25nX2FyZyA9IHdyb25nX2FyZztcclxuXHJcblx0XHRpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcclxuXHRcdFx0RXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoRVIsIGFyZ0Vycm9yKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gRVI7XHJcblxyXG5cdFx0ZnVuY3Rpb24gZm9yQXJnKGFyZ3Mpe1xyXG5cdFx0XHR2YXIgc3RyX2FyZ3MgPSAnJztcclxuXHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspe1xyXG5cdFx0XHRcdHN0cl9hcmdzICs9IHR5cGVvZihhcmdzW2ldKSArICc6ICcgKyBhcmdzW2ldICsgJzsgJztcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gc3RyX2FyZ3M7XHJcblx0XHR9XHJcblx0fVxyXG59O1xyXG5cclxuZnVuY3Rpb24gbmV3Q3JlYXRvcihDclR5cGUpe1x0XHJcblx0cmV0dXJuIGZ1bmN0aW9uKCl7XHJcblxyXG5cdFx0dmFyIHR5cGUgPSBDclR5cGUuYXBwbHkoQ3JUeXBlLCBhcmd1bWVudHMpO1xyXG5cdFx0bWl4VHlwZSh0eXBlKTtcclxuXHRcdFxyXG5cdFx0cmV0dXJuIHR5cGU7XHJcblx0fTtcclxufVxyXG5cclxuXHJcblxyXG5mdW5jdGlvbiBjck91dEpTT04ob3V0SlNPTil7XHJcblx0cmV0dXJuIGZ1bmN0aW9uKGpzb24pe1xyXG5cclxuXHRcdGlmKHR5cGVvZiBqc29uID09IFwic3RyaW5nXCIpe1xyXG5cdFx0XHR2YXIgdHlwZSA9IG91dEpTT04oSlNPTi5wYXJzZShqc29uKSk7XHJcblx0XHRcdG1peFR5cGUodHlwZSk7XHJcblx0XHR9XHJcblx0XHRlbHNle1xyXG5cdFx0XHR2YXIgdHlwZSA9IG91dEpTT04oanNvbik7XHJcblx0XHRcdG1peFR5cGUodHlwZSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdHlwZTtcclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG1peFR5cGUodHlwZSl7XHJcblx0dHlwZVt0eXBlSURdID0gdHlwZUlEO1xyXG5cdHR5cGUudG9KU09OID0gY3JUb0pTT04odHlwZS5wcmVKU09OKTtcclxuXHR0eXBlLnRlc3QgPSB3cmFwVGVzdCh0eXBlLnRlc3QpO1xyXG59XHJcblxyXG5mdW5jdGlvbiB3cmFwVGVzdCh0ZXN0KXtcclxuXHRyZXR1cm4gZnVuY3Rpb24odmFsKXtcclxuXHRcdGlmKGlzVGVzdClcclxuXHRcdFx0cmV0dXJuIHRlc3QodmFsKTtcclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyVG9KU09OKHByZUpTT04pe1xyXG5cdHJldHVybiBmdW5jdGlvbih0YWJzKXtcclxuXHRcdHZhciBwcmVKc29uID0gT2JqZWN0LmFzc2lnbih7fSwgcHJlSlNPTigpKTtcclxuXHRcdGRlbGV0ZSBwcmVKc29uLnRvSlNPTjtcclxuXHRcdHJldHVybiBKU09OLnN0cmluZ2lmeShwcmVKc29uLCBcIlwiLCB0YWJzKTtcclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzVHlwZSh0eXBlKSB7XHJcblx0cmV0dXJuIHR5cGVvZiB0eXBlID09IFwib2JqZWN0XCIgJiYgdHlwZVt0eXBlSURdID09IHR5cGVJRCBcclxuXHRcdFx0JiYgdHlwZW9mIHR5cGUucmFuZCA9PSBcImZ1bmN0aW9uXCIgXHJcblx0XHRcdCYmIHR5cGVvZiB0eXBlLnRlc3QgPT0gXCJmdW5jdGlvblwiXHJcblx0XHRcdCYmIHR5cGVvZiB0eXBlLnByZUpTT04gPT0gXCJmdW5jdGlvblwiXHJcblx0XHRcdCYmIHR5cGVvZiB0eXBlLnRvSlNPTiA9PSBcImZ1bmN0aW9uXCI7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzQ3JUeXBlKGNyVHlwZSl7XHJcblx0cmV0dXJuIHR5cGVvZiBjclR5cGUgPT0gXCJvYmplY3RcIiAmJiBjclR5cGVbY3JUeXBlSURdID09IGNyVHlwZUlEXHJcblx0XHRcdCYmIHR5cGVvZiBjclR5cGUuRGVmID09IFwiZnVuY3Rpb25cIiBcclxuXHRcdFx0JiYgdHlwZW9mIGNyVHlwZS5vdXRKU09OID09IFwiZnVuY3Rpb25cIjtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBUeXBlczsiLCJjb25zdCBUeXBlcyA9IHJlcXVpcmUoJy4vY29yZS5qcycpO1xyXG5cclxucmVxdWlyZSgnLi90eXBlcy90ZW1wbGF0ZS90eXBlLmpzJykoVHlwZXMpO1xyXG5yZXF1aXJlKCcuL3R5cGVzL2NvbnN0L3R5cGUuanMnKShUeXBlcyk7XHJcbnJlcXVpcmUoJy4vdHlwZXMvYm9vbC90eXBlLmpzJykoVHlwZXMpO1xyXG5yZXF1aXJlKCcuL3R5cGVzL251bWJlci90eXBlLmpzJykoVHlwZXMpO1xyXG5yZXF1aXJlKCcuL3R5cGVzL2luZGV4L3R5cGUuanMnKShUeXBlcyk7XHJcbnJlcXVpcmUoJy4vdHlwZXMva2V5L3R5cGUuanMnKShUeXBlcyk7XHJcbnJlcXVpcmUoJy4vdHlwZXMvb2JqZWN0L3R5cGUuanMnKShUeXBlcyk7XHJcbnJlcXVpcmUoJy4vdHlwZXMvYXJyYXkvdHlwZS5qcycpKFR5cGVzKTtcclxucmVxdWlyZSgnLi90eXBlcy9hbnkvdHlwZS5qcycpKFR5cGVzKTtcclxucmVxdWlyZSgnLi90eXBlcy9zdHJpbmcvdHlwZS5qcycpKFR5cGVzKTtcclxucmVxdWlyZSgnLi90eXBlcy9zd2l0Y2gvdHlwZS5qcycpKFR5cGVzKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVHlwZXM7IiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuY29uc3QgQ3JJbmRleFR5cGUgID0gIHJlcXVpcmUoJy4uL2luZGV4L3R5cGUuanMnKTtcclxuY29uc3QgQ3JDb25zdFR5cGUgID0gIHJlcXVpcmUoJy4uL2luZGV4L3R5cGUuanMnKTtcclxuXHJcbmNvbnN0IHR5cGVOYW1lID0gXCJBbnlcIjtcclxuXHJcbnZhciBhcmdFcnJvciA9IG51bGw7XHJcblxyXG52YXIgVHlwZXMgPSBudWxsO1xyXG5cclxuZnVuY3Rpb24gRXh0ZW5kVHlwZXMoQ29yZSl7XHJcblx0VHlwZXMgPSBDb3JlO1xyXG5cdGFyZ0Vycm9yID0gQ29yZS5hcmdFcnJvcjtcclxuXHJcblx0aWYoIUNvcmUuSW5kZXgpXHJcblx0XHRDckluZGV4VHlwZShDb3JlKTtcclxuXHJcblx0aWYoIUNvcmUuQ29uc3QpXHJcblx0XHRDckNvbnN0VHlwZShDb3JlKTtcclxuXHJcblx0Q29yZS5uZXdUeXBlKHR5cGVOYW1lLCBDb25zdHJ1Y3RvclR5cGUsIG91dEpTT04pO1xyXG59XHJcblxyXG5FeHRlbmRUeXBlcy50eXBlTmFtZSA9IHR5cGVOYW1lO1xyXG5cclxuZnVuY3Rpb24gQ29uc3RydWN0b3JUeXBlKHR5cGVzKXtcclxuXHJcblx0aWYoIUFycmF5LmlzQXJyYXkodHlwZXMpKVxyXG5cdFx0dHlwZXMgPSBBcnJheS5mcm9tKGFyZ3VtZW50cyk7XHJcblxyXG5cdGlmKCFUeXBlcy5pc1R5cGUodHlwZXNbMF0pKVxyXG5cdFx0dGhyb3cgYXJnRXJyb3IoYXJndW1lbnRzLCAnV2FpdCBhcmdzIEFycmF5W1R5cGUoc3VyZWxseSksIFR5cGV8fG51bGx8fHVuZGVmaW5lZCwgLi4uIFR5cGV8fG51bGx8fHVuZGVmaW5lZF0nKTtcclxuXHJcblx0aWYodHlwZXMubGVuZ3RoID4gMSlcclxuXHRcdHZhciB0eXBlSW5kZXggPSBUeXBlcy5JbmRleC5EZWYodHlwZXMubGVuZ3RoKVxyXG5cdGVsc2V7XHJcblx0XHR2YXIgdHlwZUluZGV4ID0gVHlwZXMuSW5kZXguRGVmKDIpXHJcblx0XHR0eXBlc1sxXSA9IFR5cGVzLkNvbnN0LkRlZigpO1xyXG5cdH1cclxuXHJcblx0dmFyIHR5cGUgPSB7XHJcblx0XHRyYW5kOiByYW5kLFxyXG5cdFx0dGVzdDogdGVzdCxcclxuXHRcdHByZUpTT046IHByZUpTT05cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHJhbmQoKXtcclxuXHRcdHJldHVybiB0eXBlc1t0eXBlSW5kZXgucmFuZCgpXS5yYW5kKCk7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiB0ZXN0KHZhbHVlKXtcclxuXHRcdHZhciByZXN1bHQgPSB0eXBlcy5ldmVyeSh0eXBlSXRlbSA9PiB0eXBlSXRlbS50ZXN0KHZhbHVlKSk7XHJcblx0XHRpZihyZXN1bHQpXHJcblx0XHRcdHJldHVybiB7IHZhbHVlOiB2YWx1ZSwgdHlwZTogcHJlSlNPTigpfTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHByZUpTT04oKXtcclxuXHRcdHZhciB0eXBlID0ge307XHJcblx0XHR0eXBlLm5hbWUgPSB0eXBlTmFtZTtcclxuXHRcdHR5cGUuc3RydWN0ID0gdHlwZXMubWFwKHR5cGVJdGVtID0+IHR5cGVJdGVtLnByZUpTT04oKSk7XHJcblx0XHRyZXR1cm4gdHlwZTtcclxuXHR9XHJcblxyXG5cdHJldHVybiB0eXBlO1xyXG5cclxufVxyXG5cclxuZnVuY3Rpb24gb3V0SlNPTihwcmVUeXBlKXtcclxuXHRpZih0eXBlb2YgcHJlVHlwZSA9PSBcIm9iamVjdFwiICYmIHByZVR5cGUubmFtZSA9PSB0eXBlTmFtZSlcclxuXHRcdHJldHVybiBDb25zdHJ1Y3RvclR5cGUocHJlVHlwZS5zdHJ1Y3QubWFwKGl0ZW1PdXRKU09OKSlcclxuXHRlbHNlXHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIGlzbid0IHR5cGUgXCIgKyB0eXBlTmFtZSArIFwiIVwiKTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBFeHRlbmRUeXBlcztcclxuXHJcbmZ1bmN0aW9uIGl0ZW1PdXRKU09OKHByZVR5cGUpe1xyXG5cdGlmKCFUeXBlcy5pc0NyVHlwZShUeXBlc1twcmVUeXBlLm5hbWVdKSlcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIlBhcnNpbmcgRXJyb3IhIFR5cGUgd2l0aCBuYW1lXCIgKyBuYW1lVHlwZSArIFwiaXMgdW5rbm93ZWQhXCIpO1xyXG5cdHJldHVybiBUeXBlc1twcmVUeXBlLm5hbWVdLm91dEpTT04ocHJlVHlwZSk7XHJcbn0iLCIndXNlIHN0cmljdCc7XHJcblxyXG5jb25zdCB0eXBlTmFtZSA9IFwiQXJyYXlcIjtcclxuXHJcbmNvbnN0IENySW5kZXhUeXBlICA9ICByZXF1aXJlKCcuLi9pbmRleC90eXBlLmpzJyk7XHJcblxyXG52YXIgYXJnRXJyb3IgPSBudWxsO1xyXG5cclxudmFyIFR5cGVzID0gbnVsbDtcclxuXHJcbmZ1bmN0aW9uIEV4dGVuZFR5cGVzKENvcmUpe1xyXG5cdFR5cGVzID0gQ29yZTtcclxuXHRhcmdFcnJvciA9IENvcmUuYXJnRXJyb3I7XHJcblx0aWYoIUNvcmUuSW5kZXgpXHJcblx0XHRDckluZGV4VHlwZShDb3JlKTtcclxuXHJcblx0Q29yZS5uZXdUeXBlKHR5cGVOYW1lLCBDb25zdHJ1Y3RvclR5cGUsIG91dEpTT04pO1xyXG59XHJcblxyXG5FeHRlbmRUeXBlcy50eXBlTmFtZSA9IHR5cGVOYW1lO1xyXG5cclxuZnVuY3Rpb24gQ29uc3RydWN0b3JUeXBlKGl0ZW1UeXBlLCBtYXhMZW5ndGgsIGlzX2VtcHR5KXtcclxuXHJcblx0dmFyIG1heExlbmd0aFR5cGUgPSBUeXBlcy5JbmRleC5EZWYoMTAyNCoxMDI0KTtcdFxyXG5cclxuXHRpZighVHlwZXMuaXNUeXBlKGl0ZW1UeXBlKVxyXG5cdFx0fHwgbWF4TGVuZ3RoVHlwZS50ZXN0KG1heExlbmd0aCkpXHJcblx0XHR0aHJvdyBhcmdFcnJvcihhcmd1bWVudHMsICdXYWl0IGFyZ3MgKFR5cGUsIG1heExlbmd0aDwxMDI0KjEwMjQgWywgaXNFbXB0eUFycmF5XSknKTtcclxuXHJcblx0dmFyIGxlbmd0aFR5cGUgPSBUeXBlcy5JbmRleC5EZWYobWF4TGVuZ3RoICsgMSk7XHJcblxyXG5cdHZhciB0eXBlID0ge1xyXG5cdFx0cmFuZDogcmFuZCxcclxuXHRcdHRlc3Q6IHRlc3QsXHJcblx0XHRwcmVKU09OOiBwcmVKU09OXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiByYW5kKCl7XHJcblx0XHR2YXIgbGVuZ3RoID0gbGVuZ3RoVHlwZS5yYW5kKCk7XHJcblx0XHR2YXIgYXJyID0gW107XHJcblxyXG5cdFx0aWYoIWlzX2VtcHR5KVxyXG5cdFx0XHRhcnIucHVzaChpdGVtVHlwZS5yYW5kKCkpO1xyXG5cclxuXHRcdHdoaWxlKGFyci5sZW5ndGggPCBsZW5ndGgpXHJcblx0XHRcdGFyci5wdXNoKGl0ZW1UeXBlLnJhbmQoKSk7XHJcblxyXG5cdFx0cmV0dXJuIGFycjtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHRlc3QoYXJyKXtcclxuXHRcdGlmKChhcnIubGVuZ3RoID4gbWF4TGVuZ3RoKSB8fCAoIWlzX2VtcHR5ICYmIGFyci5sZW5ndGggPT0gMCkpXHJcblx0XHRcdHJldHVybiB7IGxlbmd0aDogYXJyLmxlbmd0aCwgdHlwZTogcHJlSlNPTigpfTtcclxuXHJcblx0XHR2YXIgZXJyX2FyciA9IGFyci5tYXAoaXRlbVR5cGUudGVzdCkuZmlsdGVyKGl0ZW0gPT4gaXRlbSk7XHJcblxyXG5cdFx0aWYoZXJyX2Fyci5sZW5ndGgpXHJcblx0XHRcdHJldHVybiB7IHdyb25nX3ZhbHVlczogZXJyX2FyciwgdHlwZTogcHJlSlNPTigpfTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHByZUpTT04oKXtcclxuXHRcdHZhciB0eXBlID0ge307XHJcblx0XHR0eXBlLm5hbWUgPSB0eXBlTmFtZTtcclxuXHRcdHR5cGUuc3RydWN0ID0ge3R5cGU6IGl0ZW1UeXBlLnByZUpTT04oKSwgbWF4TGVuZ3RoOiBtYXhMZW5ndGgsIGlzX2VtcHR5OiBpc19lbXB0eX07XHJcblx0XHRyZXR1cm4gdHlwZTtcclxuXHR9XHJcblxyXG5cdHJldHVybiB0eXBlO1xyXG5cclxufVxyXG5cclxuZnVuY3Rpb24gb3V0SlNPTihwcmVUeXBlKXtcclxuXHR2YXIgc3RydWN0ID0gcHJlVHlwZS5zdHJ1Y3Q7XHJcblx0dmFyIG5hbWVUeXBlID0gc3RydWN0LnR5cGUubmFtZTtcclxuXHJcblx0aWYoIVR5cGVzLmlzQ3JUeXBlKFR5cGVzW25hbWVUeXBlXSkpXHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJQYXJzaW5nIEVycm9yISBUeXBlIHdpdGggbmFtZVwiICsgbmFtZVR5cGUgKyBcImlzIHVua25vd2VkIVwiKTtcclxuXHJcblx0dmFyIHR5cGUgPSBUeXBlc1tuYW1lVHlwZV0ub3V0SlNPTihzdHJ1Y3QudHlwZSk7XHJcblxyXG5cdGlmKHR5cGVvZiBwcmVUeXBlID09IFwib2JqZWN0XCIgJiYgcHJlVHlwZS5uYW1lID09IHR5cGVOYW1lKVxyXG5cdFx0cmV0dXJuIENvbnN0cnVjdG9yVHlwZSh0eXBlLCBzdHJ1Y3QubWF4TGVuZ3RoLCBzdHJ1Y3QuaXNfZW1wdHkpO1xyXG5cdGVsc2VcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIlRoaXMgaXNuJ3QgdHlwZSBcIiArIHR5cGVOYW1lICsgXCIhXCIpO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEV4dGVuZFR5cGVzOyIsIid1c2Ugc3RyaWN0JztcclxuXHJcbmNvbnN0IHR5cGVOYW1lID0gXCJCb29sXCI7XHJcblxyXG5mdW5jdGlvbiBFeHRlbmRUeXBlcyhDb3JlKXtcclxuXHRDb3JlLm5ld1R5cGUodHlwZU5hbWUsIENvbnN0cnVjdG9yVHlwZSwgb3V0SlNPTik7XHJcbn1cclxuXHJcbkV4dGVuZFR5cGVzLnR5cGVOYW1lID0gdHlwZU5hbWU7XHJcblxyXG5mdW5jdGlvbiBDb25zdHJ1Y3RvclR5cGUoKXtcclxuXHJcblx0dmFyIHR5cGUgPSB7XHJcblx0XHRyYW5kOiByYW5kLFxyXG5cdFx0dGVzdDogdGVzdCxcclxuXHRcdHByZUpTT046IHByZUpTT05cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHJhbmQoKXtcclxuXHRcdHJldHVybiBNYXRoLnJhbmRvbSgpID4gMC41O1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gdGVzdCh2YWx1ZSl7XHJcblx0XHRpZih2YWx1ZSAhPT0gZmFsc2UgJiYgdmFsdWUgIT09IHRydWUpXHJcblx0XHRcdHJldHVybiB7IHZhbHVlOiB2YWx1ZSwgdHlwZTogcHJlSlNPTigpfTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHByZUpTT04oKXtcclxuXHRcdHZhciB0eXBlID0ge307XHJcblx0XHR0eXBlLm5hbWUgPSB0eXBlTmFtZTtcclxuXHRcdHJldHVybiB0eXBlO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIHR5cGU7XHJcblxyXG59XHJcblxyXG5mdW5jdGlvbiBvdXRKU09OKHByZVR5cGUpe1xyXG5cdGlmKHR5cGVvZiBwcmVUeXBlID09IFwib2JqZWN0XCIgJiYgcHJlVHlwZS5uYW1lID09IHR5cGVOYW1lKVxyXG5cdFx0cmV0dXJuIENvbnN0cnVjdG9yVHlwZSgpXHJcblx0ZWxzZVxyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiVGhpcyBpc24ndCBib29sZWFuIHR5cGUhXCIpO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEV4dGVuZFR5cGVzOyIsIid1c2Ugc3RyaWN0JztcclxuXHJcbmNvbnN0IHR5cGVOYW1lID0gXCJDb25zdFwiO1xyXG5cclxudmFyIGFyZ0Vycm9yID0gbnVsbDtcclxuXHJcbmZ1bmN0aW9uIEV4dGVuZFR5cGVzKENvcmUpe1xyXG5cdGFyZ0Vycm9yID0gQ29yZS5hcmdFcnJvcjtcclxuXHRDb3JlLm5ld1R5cGUodHlwZU5hbWUsIENvbnN0cnVjdG9yVHlwZSwgb3V0SlNPTik7XHJcbn1cclxuXHJcbkV4dGVuZFR5cGVzLnR5cGVOYW1lID0gdHlwZU5hbWU7XHJcblxyXG5mdW5jdGlvbiBDb25zdHJ1Y3RvclR5cGUoY29uc3RWYWwpe1xyXG5cclxuXHRpZih0eXBlb2YgY29uc3RWYWwgIT09IFwic3RyaW5nXCJcclxuXHRcdCYmIHR5cGVvZiBjb25zdFZhbCAhPT0gXCJudW1iZXJcIlxyXG5cdFx0JiYgdHlwZW9mIGNvbnN0VmFsICE9PSBcImJvb2xlYW5cIlxyXG5cdFx0JiYgdHlwZW9mIGNvbnN0VmFsICE9PSBcImZ1bmN0aW9uXCJcclxuXHRcdCYmIGNvbnN0VmFsKVxyXG5cdFx0dGhyb3cgYXJnRXJyb3IoYXJndW1lbnRzLCAnV2FpdCBhcmd1bWVudCBpcyBzdHJpbmcgfHwgbnVtYmVyIHx8IGJvb2xlYW4gfHwgbnVsbCB8fCB1bmRlZmluZWQgfHwgZnVuY3Rpb24nKTtcclxuXHJcblx0dmFyIHR5cGUgPSB7XHJcblx0XHRyYW5kOiByYW5kLFxyXG5cdFx0dGVzdDogdGVzdCxcclxuXHRcdHByZUpTT046IHByZUpTT05cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHJhbmQoKXtcclxuXHRcdHJldHVybiBjb25zdFZhbDtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHRlc3QodmFsdWUpe1xyXG5cdFx0aWYodmFsdWUgIT09IGNvbnN0VmFsKVxyXG5cdFx0XHRyZXR1cm4geyB2YWx1ZTogdmFsdWUsIHR5cGU6IHByZUpTT04oKX07XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBwcmVKU09OKCl7XHJcblx0XHR2YXIgdHlwZSA9IHt9O1xyXG5cdFx0dHlwZS5uYW1lID0gdHlwZU5hbWU7XHJcblx0XHR0eXBlLnN0cnVjdCA9IGNvbnN0VmFsO1xyXG5cdFx0cmV0dXJuIHR5cGU7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gdHlwZTtcclxuXHJcbn1cclxuXHJcbmZ1bmN0aW9uIG91dEpTT04ocHJlVHlwZSl7XHJcblx0aWYodHlwZW9mIHByZVR5cGUgPT0gXCJvYmplY3RcIiAmJiBwcmVUeXBlLm5hbWUgPT0gdHlwZU5hbWUpXHJcblx0XHRyZXR1cm4gQ29uc3RydWN0b3JUeXBlKHByZVR5cGUuc3RydWN0KVxyXG5cdGVsc2VcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIlRoaXMgaXNuJ3QgdHlwZSBcIiArIHR5cGVOYW1lICsgXCIhXCIpO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEV4dGVuZFR5cGVzOyIsIid1c2Ugc3RyaWN0JztcclxuXHJcbmNvbnN0IHR5cGVOYW1lID0gXCJJbmRleFwiO1xyXG52YXIgYXJnRXJyb3JcclxuXHJcbmZ1bmN0aW9uIEV4dGVuZFR5cGVzKENvcmUpe1xyXG5cdGFyZ0Vycm9yID0gQ29yZS5hcmdFcnJvcjtcclxuXHRDb3JlLm5ld1R5cGUodHlwZU5hbWUsIENvbnN0cnVjdG9yVHlwZSwgb3V0SlNPTik7XHJcbn1cclxuXHJcbkV4dGVuZFR5cGVzLnR5cGVOYW1lID0gdHlwZU5hbWU7XHJcblxyXG5mdW5jdGlvbiBDb25zdHJ1Y3RvclR5cGUobWF4KXtcclxuXHJcblx0aWYodHlwZW9mIG1heCAhPT0gJ251bWJlcicgfHwgIWlzRmluaXRlKG1heClcclxuXHRcdHx8KG1heCA8PSAwKVxyXG5cdFx0fHwobWF4ICUgMSAhPT0gMCkpXHJcblx0XHR0aHJvdyBhcmdFcnJvcihhcmd1bWVudHMsICdXYWl0IGFyZ3VtZW50czogbWF4KGludD4wKScpO1xyXG5cdFxyXG5cclxuXHR2YXIgdHlwZSA9IHtcclxuXHRcdHJhbmQ6IHJhbmQsXHJcblx0XHR0ZXN0OiB0ZXN0LFxyXG5cdFx0cHJlSlNPTjogcHJlSlNPTlxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gcmFuZCgpe1xyXG5cdFx0cmV0dXJuIE1hdGguZmxvb3IobWF4ICogTWF0aC5hYnMoTWF0aC5yYW5kb20oKSAtIDAuMDEpKTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHRlc3Qobil7XHJcblx0XHRpZih0eXBlb2YgbiAhPT0gJ251bWJlcicgfHwgIWlzRmluaXRlKG4pKVxyXG5cdFx0XHRyZXR1cm4geyB2YWx1ZTogbiwgdHlwZTogcHJlSlNPTigpfTtcclxuXHRcdFxyXG5cclxuXHRcdGlmKG4gPj0gbWF4IHx8IG4gPCAwIHx8IG4gJSAxICE9PSAwKVxyXG5cdFx0XHRyZXR1cm4geyB2YWx1ZTogbiwgdHlwZTogcHJlSlNPTigpfTtcclxuXHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBwcmVKU09OKCl7XHJcblx0XHR2YXIgdHlwZSA9IHt9O1xyXG5cdFx0dHlwZS5uYW1lID0gdHlwZU5hbWU7XHJcblx0XHR0eXBlLnN0cnVjdCA9IHtcclxuXHRcdFx0bWF4OiBtYXhcclxuXHRcdH07XHJcblx0XHRyZXR1cm4gdHlwZTtcclxuXHR9XHJcblxyXG5cdHJldHVybiB0eXBlO1xyXG5cclxufVxyXG5cclxuZnVuY3Rpb24gb3V0SlNPTihwcmVUeXBlKXtcclxuXHR2YXIgYXJnID0gcHJlVHlwZS5zdHJ1Y3Q7XHJcblxyXG5cdGlmKHR5cGVvZiBwcmVUeXBlID09IFwib2JqZWN0XCIgJiYgcHJlVHlwZS5uYW1lID09IHR5cGVOYW1lKVxyXG5cdFx0cmV0dXJuIENvbnN0cnVjdG9yVHlwZShhcmcubWF4KTtcclxuXHRlbHNlXHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIGlzbid0IHR5cGUgXCIgKyB0eXBlTmFtZSArIFwiIVwiKTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBFeHRlbmRUeXBlczsiLCIndXNlIHN0cmljdCc7XHJcblxyXG5jb25zdCB0eXBlTmFtZSA9IFwiS2V5XCI7XHJcblxyXG52YXIgYXJnRXJyb3IgPSBudWxsO1xyXG5cclxuY29uc3QgQ3JJbmRleFR5cGUgID0gIHJlcXVpcmUoJy4uL2luZGV4L3R5cGUuanMnKTtcclxuXHJcbnZhciBUeXBlcyA9IG51bGw7XHJcblxyXG5mdW5jdGlvbiBFeHRlbmRUeXBlcyhDb3JlKXtcclxuXHRUeXBlcyA9IENvcmU7XHJcblx0YXJnRXJyb3IgPSBDb3JlLmFyZ0Vycm9yO1xyXG5cdGlmKCFDb3JlLkluZGV4KVxyXG5cdFx0Q3JJbmRleFR5cGUoQ29yZSk7XHJcblxyXG5cdENvcmUubmV3VHlwZSh0eXBlTmFtZSwgQ29uc3RydWN0b3JUeXBlLCBvdXRKU09OKTtcclxufVxyXG5cclxuRXh0ZW5kVHlwZXMudHlwZU5hbWUgPSB0eXBlTmFtZTtcclxuXHJcbmZ1bmN0aW9uIENvbnN0cnVjdG9yVHlwZSgpe1xyXG5cclxuXHR2YXIgY2hhcnMgPSBjckNoYXJzKCk7XHJcblx0dmFyIHNpemVUeXBlID0gVHlwZXMuSW5kZXguRGVmKDI1Nik7XHJcblx0dmFyIGluZGV4VHlwZSA9IFR5cGVzLkluZGV4LkRlZihjaGFycy5sZW5ndGgpO1xyXG5cdHZhciByZWdFeCA9ICAvXlthLXpBLVowLTlfXSokLztcclxuXHJcblx0dmFyIHR5cGUgPSB7XHJcblx0XHRyYW5kOiByYW5kLFxyXG5cdFx0dGVzdDogdGVzdCxcclxuXHRcdHByZUpTT046IHByZUpTT05cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHJhbmQoKXtcclxuXHRcdHZhciBzaXplID0gc2l6ZVR5cGUucmFuZCgpO1xyXG5cclxuXHRcdHZhciBzdHIgPSAnJztcclxuXHRcdHdoaWxlKHNpemUpe1xyXG5cdFx0XHR2YXIgcmFuZEluZGV4ID0gaW5kZXhUeXBlLnJhbmQoKVxyXG5cdFx0XHR2YXIgY2hhck51bSA9IGNoYXJzW3JhbmRJbmRleF07XHJcblx0XHRcdHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJOdW0pO1xyXG5cdFx0XHRzaXplLS07XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHN0cjtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHRlc3Qoc3RyKXtcclxuXHRcdGlmKHR5cGVvZihzdHIpICE9PSAnc3RyaW5nJ1xyXG5cdFx0fHxzdHIubGVuZ3RoID4gMjU2XHJcblx0XHR8fCFyZWdFeC50ZXN0KHN0cikpe1xyXG5cdFx0XHRyZXR1cm4geyB2YWx1ZTogc3RyLCB0eXBlOiBwcmVKU09OKCl9O1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gcHJlSlNPTigpe1xyXG5cdFx0dmFyIHR5cGUgPSB7fTtcclxuXHRcdHR5cGUubmFtZSA9IHR5cGVOYW1lO1xyXG5cdFx0cmV0dXJuIHR5cGU7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gdHlwZTtcclxuXHJcbn1cclxuXHJcbmZ1bmN0aW9uIG91dEpTT04ocHJlVHlwZSl7XHJcblx0aWYodHlwZW9mIHByZVR5cGUgPT0gXCJvYmplY3RcIiAmJiBwcmVUeXBlLm5hbWUgPT0gdHlwZU5hbWUpXHJcblx0XHRyZXR1cm4gQ29uc3RydWN0b3JUeXBlKHByZVR5cGUuc3RydWN0KVxyXG5cdGVsc2VcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIlRoaXMgaXNuJ3QgdHlwZSBcIiArIHR5cGVOYW1lICsgXCIhXCIpO1xyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gY3JDaGFycygpe1xyXG5cdHZhciBhcnJfY2hhcnMgPSByYW5nZUluQXJyKChcImFcIikuY2hhckNvZGVBdCgwKSwgKFwielwiKS5jaGFyQ29kZUF0KDApKTtcclxuXHJcblx0YXJyX2NoYXJzID0gYXJyX2NoYXJzLmNvbmNhdChyYW5nZUluQXJyKChcIkFcIikuY2hhckNvZGVBdCgwKSwgKFwiWlwiKS5jaGFyQ29kZUF0KDApKSk7XHJcblxyXG5cdGFycl9jaGFycyA9IGFycl9jaGFycy5jb25jYXQocmFuZ2VJbkFycigoXCIwXCIpLmNoYXJDb2RlQXQoMCksIChcIjlcIikuY2hhckNvZGVBdCgwKSkpO1xyXG5cclxuXHRhcnJfY2hhcnMucHVzaCgoXCJfXCIpLmNoYXJDb2RlQXQoMCkpO1xyXG5cclxuXHRyZXR1cm4gYXJyX2NoYXJzO1xyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gcmFuZ2VJbkFycihiZWcsIGVuZCl7XHJcblx0aWYoYmVnID4gZW5kKXtcclxuXHRcdHZhciB0bXAgPSBiZWc7XHJcblx0XHRiZWcgPSBlbmQ7XHJcblx0XHRlbmQgPSB0bXA7XHJcblx0fVxyXG5cclxuXHR2YXIgYXJyID0gW107XHJcblx0Zm9yKHZhciBpID0gYmVnOyBpIDw9IGVuZDsgaSsrKXtcclxuXHRcdGFyci5wdXNoKGkpO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIGFycjtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBFeHRlbmRUeXBlczsiLCIndXNlIHN0cmljdCc7XHJcblxyXG5jb25zdCB0eXBlTmFtZSA9IFwiTnVtYmVyXCI7XHJcbnZhciBhcmdFcnJvclxyXG5cclxuZnVuY3Rpb24gRXh0ZW5kVHlwZXMoQ29yZSl7XHJcblx0YXJnRXJyb3IgPSBDb3JlLmFyZ0Vycm9yO1xyXG5cdENvcmUubmV3VHlwZSh0eXBlTmFtZSwgQ29uc3RydWN0b3JUeXBlLCBvdXRKU09OKTtcclxufVxyXG5cclxuRXh0ZW5kVHlwZXMudHlwZU5hbWUgPSB0eXBlTmFtZTtcclxuXHJcbmZ1bmN0aW9uIENvbnN0cnVjdG9yVHlwZShtYXgsIG1pbiwgcHJlY2lzKXtcclxuXHJcblx0aWYodHlwZW9mIG1pbiAhPT0gJ251bWJlcicgfHwgIWlzRmluaXRlKG1pbilcclxuXHRcdHx8dHlwZW9mIG1heCAhPT0gJ251bWJlcicgfHwgIWlzRmluaXRlKG1heClcclxuXHRcdHx8dHlwZW9mIHByZWNpcyAhPT0gJ251bWJlcicgfHwgIWlzRmluaXRlKHByZWNpcylcclxuXHRcdHx8KG1heCA8PSBtaW4pXHJcblx0XHR8fChwcmVjaXMgPCAwKVxyXG5cdFx0fHwocHJlY2lzID4gOSlcclxuXHRcdHx8KHByZWNpcyAlIDEgIT09IDApKVxyXG5cdFx0dGhyb3cgYXJnRXJyb3IoYXJndW1lbnRzLCAnV2FpdCBhcmd1bWVudHM6IG1heChudW1iZXIpLCA+IG1pbihudW1iZXIpLCBwcmVjaXMoMDw9bnVtYmVyPDkpJyk7XHJcblx0XHJcblxyXG5cdHZhciB0eXBlID0ge1xyXG5cdFx0cmFuZDogcmFuZCxcclxuXHRcdHRlc3Q6IHRlc3QsXHJcblx0XHRwcmVKU09OOiBwcmVKU09OXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiByYW5kKCl7XHJcblx0XHRyZXR1cm4gKygoKG1heCAtIG1pbikqTWF0aC5yYW5kb20oKSArICBtaW4pLnRvRml4ZWQocHJlY2lzKSk7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiB0ZXN0KG4pe1xyXG5cdFx0aWYodHlwZW9mIG4gIT09ICdudW1iZXInIHx8ICFpc0Zpbml0ZShuKSlcclxuXHRcdFx0cmV0dXJuIG5ldyBFcnJvcihKU09OLnN0cmluZ2lmeSh7IHZhbHVlOiBuLCB0eXBlOiBwcmVKU09OKCl9LCBcIlwiLCAyKSk7XHJcblx0XHRcclxuXHJcblx0XHRpZigobiA+IG1heClcclxuXHRcdHx8KG4gPCBtaW4pXHJcblx0XHR8fCAobi50b0ZpeGVkKHByZWNpcykgIT0gbiAmJiBuICE9PSAwKSApXHJcblx0XHRcdHJldHVybiBuZXcgRXJyb3IoSlNPTi5zdHJpbmdpZnkoeyB2YWx1ZTogbiwgdHlwZTogcHJlSlNPTigpfSwgXCJcIiwgMikpO1xyXG5cclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHByZUpTT04oKXtcclxuXHRcdHZhciB0eXBlID0ge307XHJcblx0XHR0eXBlLm5hbWUgPSB0eXBlTmFtZTtcclxuXHRcdHR5cGUuc3RydWN0ID0ge1xyXG5cdFx0XHRtaW46IG1pbixcclxuXHRcdFx0bWF4OiBtYXgsXHJcblx0XHRcdHByZWNpczogcHJlY2lzXHJcblx0XHR9O1xyXG5cdFx0cmV0dXJuIHR5cGU7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gdHlwZTtcclxuXHJcbn1cclxuXHJcbmZ1bmN0aW9uIG91dEpTT04ocHJlVHlwZSl7XHJcblx0dmFyIGFyZyA9IHByZVR5cGUuc3RydWN0O1xyXG5cclxuXHRpZih0eXBlb2YgcHJlVHlwZSA9PSBcIm9iamVjdFwiICYmIHByZVR5cGUubmFtZSA9PSB0eXBlTmFtZSlcclxuXHRcdHJldHVybiBDb25zdHJ1Y3RvclR5cGUoYXJnLm1heCwgYXJnLm1pbiwgYXJnLnByZWNpcyk7XHJcblx0ZWxzZVxyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiVGhpcyBpc24ndCB0eXBlIFwiICsgdHlwZU5hbWUgKyBcIiFcIik7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRXh0ZW5kVHlwZXM7IiwiICBcclxuXHJcbmNvbnN0IHR5cGVOYW1lID0gXCJPYmplY3RcIjtcclxuXHJcbnZhciBhcmdFcnJvciA9IG51bGw7XHJcblxyXG52YXIgVHlwZXMgPSBudWxsO1xyXG5cclxuZnVuY3Rpb24gRXh0ZW5kVHlwZXMoQ29yZSl7XHJcblx0VHlwZXMgPSBDb3JlO1xyXG5cdGFyZ0Vycm9yID0gQ29yZS5hcmdFcnJvcjtcclxuXHRpZighQ29yZS5Db25zdClcclxuXHRcdENySW5kZXhUeXBlKENvbnN0KTtcclxuXHJcblx0Q29yZS5uZXdUeXBlKHR5cGVOYW1lLCBDb25zdHJ1Y3RvclR5cGUsIG91dEpTT04pO1xyXG59XHJcblxyXG5FeHRlbmRUeXBlcy50eXBlTmFtZSA9IHR5cGVOYW1lO1xyXG5cclxuZnVuY3Rpb24gQ29uc3RydWN0b3JUeXBlKHNvdXJjZU9iail7XHJcblxyXG5cdGlmKCFzb3VyY2VPYmogfHwgdHlwZW9mIHNvdXJjZU9iaiAhPT0gXCJvYmplY3RcIilcclxuXHRcdHRocm93IGFyZ0Vycm9yKGFyZ3VtZW50cywgXCJBcmd1bWVudCBpc24ndCBPYmplY3QhXCIgKTtcclxuXHRcclxuXHJcblx0dmFyIHR5cGVPYmogPSByZUNvc3RydWN0T2JqKHNvdXJjZU9iaik7XHJcblxyXG5cdHZhciB0eXBlID0ge1xyXG5cdFx0bmFtZTogdHlwZU5hbWUsXHJcblx0XHRyYW5kOiByYW5kLFxyXG5cdFx0dGVzdDogdGVzdCxcclxuXHRcdHByZUpTT046IHByZUpTT05cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHJhbmQoKXtcclxuXHRcdHJldHVybiBnZW5PYmoodHlwZU9iaik7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiB0ZXN0KHRlc3RpbmdPYmosIG9ianNTdGFjayl7XHJcblx0XHRyZXR1cm4gdGVzdE9iaih0eXBlT2JqLCB0ZXN0aW5nT2JqLCBvYmpzU3RhY2spO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gcHJlSlNPTigpe1xyXG5cdFx0dmFyIHR5cGUgPSB7bmFtZTogdHlwZU5hbWV9O1xyXG5cdFx0dHlwZS5zdHJ1Y3QgPSBvYmpQcmVKc29uKHR5cGVPYmopO1xyXG5cdFx0cmV0dXJuIHR5cGU7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gdHlwZTtcclxuXHJcbn1cclxuXHJcbmZ1bmN0aW9uIG91dEpTT04ocHJlVHlwZSl7XHJcblxyXG5cdGlmKHR5cGVvZiBwcmVUeXBlID09IFwib2JqZWN0XCIgJiYgcHJlVHlwZS5uYW1lID09IHR5cGVOYW1lKVxyXG5cdFx0cmV0dXJuIENvbnN0cnVjdG9yVHlwZShvYmpPdXRKc29uKHByZVR5cGUuc3RydWN0KSk7XHJcblx0ZWxzZVxyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiVGhpcyBpc24ndCB0eXBlIFwiICsgdHlwZU5hbWUgKyBcIiFcIik7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRXh0ZW5kVHlwZXM7XHJcblxyXG5mdW5jdGlvbiByZUNvc3RydWN0T2JqKHNvdXJjZU9iaiwgb2Jqc1N0YWNrKXtcclxuXHJcblx0aWYoIW9ianNTdGFjaylcclxuXHRcdG9ianNTdGFjayA9IFtdO1xyXG5cdFxyXG5cdHZhciBmdW5jT2JqID0ge307XHJcblx0b2Jqc1N0YWNrLnB1c2goc291cmNlT2JqKTtcclxuXHJcblx0Zm9yKHZhciBrZXkgaW4gc291cmNlT2JqKXtcclxuXHJcblx0XHRpZihUeXBlcy5pc1R5cGUoc291cmNlT2JqW2tleV0pKXtcclxuXHRcdFx0ZnVuY09ialtrZXldID0gc291cmNlT2JqW2tleV07XHJcblx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmKCFzb3VyY2VPYmogfHwgKHR5cGVvZiBzb3VyY2VPYmpba2V5XSAhPT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheShzb3VyY2VPYmpba2V5XSkpKXtcclxuXHRcdFx0ZnVuY09ialtrZXldID0gVHlwZXMuQ29uc3QuRGVmKHNvdXJjZU9ialtrZXldKTtcclxuXHRcdH1cclxuXHRcdGVsc2UgaWYob2Jqc1N0YWNrLmluZGV4T2Yoc291cmNlT2JqW2tleV0pICE9PSAtMSlcclxuXHRcdFx0ZGVsZXRlIGZ1bmNPYmpba2V5XTtcclxuXHRcdGVsc2VcclxuXHRcdFx0ZnVuY09ialtrZXldID0gcmVDb3N0cnVjdE9iaihzb3VyY2VPYmpba2V5XSwgb2Jqc1N0YWNrKTtcclxuXHR9XHJcblxyXG5cdG9ianNTdGFjay5wb3AoKTtcclxuXHJcblx0cmV0dXJuIGZ1bmNPYmo7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHRlc3RPYmoodHlwZU9iaiwgdGVzdGluZ09iaiwgb2Jqc1N0YWNrKXtcclxuXHRpZighb2Jqc1N0YWNrKVxyXG5cdFx0b2Jqc1N0YWNrID0gW107XHJcblxyXG5cdG9ianNTdGFjay5wdXNoKHRlc3RpbmdPYmopO1xyXG5cclxuXHR2YXIgcmVzdWx0ID0gZmFsc2U7XHJcblxyXG5cdGZvcihsZXQga2V5IGluIHR5cGVPYmope1xyXG5cclxuXHRcdGlmKFR5cGVzLmlzVHlwZSh0eXBlT2JqW2tleV0pKVxyXG5cdFx0XHRyZXN1bHQgPSB0eXBlT2JqW2tleV0udGVzdCh0ZXN0aW5nT2JqW2tleV0pO1xyXG5cdFx0ZWxzZVxyXG5cdFx0XHRyZXN1bHQgPSB0ZXN0T2JqKHR5cGVPYmpba2V5XSwgdGVzdGluZ09ialtrZXldLCBvYmpzU3RhY2spXHJcblxyXG5cdFx0aWYocmVzdWx0KVxyXG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cdFx0XHJcblx0fVxyXG5cclxuXHRmb3IobGV0IGtleSBpbiB0ZXN0aW5nT2JqKXtcclxuXHRcdGlmKG9ianNTdGFjay5pbmRleE9mKHRlc3RpbmdPYmpba2V5XSkgIT09IC0xKVxyXG5cdFx0XHRjb250aW51ZTtcclxuXHJcblx0XHRpZighVHlwZXMuaXNUeXBlKHR5cGVPYmpba2V5XSkpXHJcblx0XHRcdHJldHVybiB7IG1lc3NlZ2U6IFwiSGVyZSBjYW5ub3QgdmFsdWUhXCIsIGtleToga2V5LCB2YWx1ZTogdGVzdGluZ09ialtrZXldLCB0eXBlOiB7bmFtZTogdHlwZU5hbWUsIHN0cnVjdDogb2JqUHJlSnNvbih0eXBlT2JqW2tleV0pfX07XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gcmVzdWx0O1xyXG5cclxufVxyXG5cclxuZnVuY3Rpb24gZ2VuT2JqKHR5cGVPYmope1xyXG5cdHZhciByZXN1bHRPYmogPSB7fTtcclxuXHJcblx0Zm9yKHZhciBrZXkgaW4gdHlwZU9iail7XHJcblx0XHRpZihUeXBlcy5pc1R5cGUodHlwZU9ialtrZXldKSlcclxuXHRcdFx0cmVzdWx0T2JqW2tleV0gPSB0eXBlT2JqW2tleV0ucmFuZCgpO1xyXG5cdFx0ZWxzZSBcclxuXHRcdFx0cmVzdWx0T2JqW2tleV0gPSBnZW5PYmoodHlwZU9ialtrZXldKTtcclxuXHR9XHJcblxyXG5cdHJldHVybiByZXN1bHRPYmo7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG9ialByZUpzb24odHlwZU9iail7XHJcblx0dmFyIHN0cnVjdCA9IHt9O1xyXG5cclxuXHRmb3IodmFyIGtleSBpbiB0eXBlT2JqKXtcclxuXHRcdGlmKFR5cGVzLmlzVHlwZSh0eXBlT2JqW2tleV0pKVxyXG5cdFx0XHRzdHJ1Y3Rba2V5XSA9IHR5cGVPYmpba2V5XS5wcmVKU09OKCk7XHJcblx0XHRlbHNle1xyXG5cdFx0XHRzdHJ1Y3Rba2V5XSA9IG9ialByZUpzb24odHlwZU9ialtrZXldKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHJldHVybiBzdHJ1Y3Q7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG9iak91dEpzb24oanNvbk9iail7XHJcblx0dmFyIG9iaiA9IHt9O1xyXG5cclxuXHRmb3IodmFyIGtleSBpbiBqc29uT2JqKXtcclxuXHRcdHZhciBwcm9wSnNvbk9iaiA9IGpzb25PYmpba2V5XTtcclxuXHJcblx0XHRpZih0eXBlb2YgcHJvcEpzb25PYmogIT0gXCJvYmplY3RcIilcclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNjaGVtZSBKU09OLCB3cm9uZyB2YWx1ZTogXCIgKyBwcm9wSnNvbk9iaiArIFwiIHdpdGgga2V5OiBcIiArIGtleSk7XHJcblxyXG5cdFx0aWYocHJvcEpzb25PYmoubmFtZSAmJiBUeXBlc1twcm9wSnNvbk9iai5uYW1lXSAmJiBUeXBlcy5pc0NyVHlwZShUeXBlc1twcm9wSnNvbk9iai5uYW1lXSkpe1xyXG5cdFx0XHRvYmpba2V5XSA9IFR5cGVzW3Byb3BKc29uT2JqLm5hbWVdLm91dEpTT04ocHJvcEpzb25PYmopO1xyXG5cdFx0fVxyXG5cdFx0ZWxzZXtcclxuXHRcdFx0b2JqW2tleV0gPSBvYmpPdXRKc29uKHByb3BKc29uT2JqKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHJldHVybiBvYmo7XHJcbn0iLCIndXNlIHN0cmljdCc7XHJcblxyXG5jb25zdCB0eXBlTmFtZSA9IFwiU3RyaW5nXCI7XHJcblxyXG5sZXQgYXJnRXJyb3IgPSBudWxsO1xyXG5cclxubGV0IFR5cGVzID0gbnVsbDtcclxuXHJcbmZ1bmN0aW9uIEV4dGVuZFR5cGVzKENvcmUpe1xyXG5cdFR5cGVzID0gQ29yZTtcclxuXHRhcmdFcnJvciA9IENvcmUuYXJnRXJyb3I7XHJcblx0aWYoIUNvcmUuSW5kZXgpXHJcblx0XHRDckluZGV4VHlwZShDb3JlKTtcclxuXHJcblx0Q29yZS5uZXdUeXBlKHR5cGVOYW1lLCBDb25zdHJ1Y3RvclR5cGUsIG91dEpTT04pO1xyXG59XHJcblxyXG5FeHRlbmRUeXBlcy50eXBlTmFtZSA9IHR5cGVOYW1lO1xyXG5cclxuZnVuY3Rpb24gQ29uc3RydWN0b3JUeXBlKHN5bWJvbENsYXNzLCBtYXhMZW5ndGgpe1xyXG5cclxuXHRsZXQgbWF4TGVuZ3RoVHlwZSA9IFR5cGVzLkluZGV4LkRlZigxMDI0ICogMTAyNCk7XHJcblxyXG5cdGlmKHR5cGVvZiBzeW1ib2xDbGFzcyAhPT0gXCJzdHJpbmdcIiB8fCBtYXhMZW5ndGhUeXBlLnRlc3QobWF4TGVuZ3RoKSlcclxuXHRcdHRocm93IGFyZ0Vycm9yKGFyZ3VtZW50cywgJ1dhaXQgYXJncyAoIFN5bWJvbENsYXNzKFN0cmluZyksIG1heExlbmd0aChJbmRleD4wKSApJyk7XHJcblx0XHJcblx0aWYoc3ltYm9sQ2xhc3NbMF0gPT0gXCJeXCIpXHJcblx0XHRzeW1ib2xDbGFzcyA9IFwiXFxcXFwiICsgc3ltYm9sQ2xhc3M7XHJcblxyXG5cdGxldCByYW5nZVNpbWJvbCA9IHBhcnNlUmFuZ2Uoc3ltYm9sQ2xhc3MpO1xyXG5cdGxldCBpbmRleFJhbmdlVHlwZSA9IFR5cGVzLkluZGV4LkRlZihyYW5nZVNpbWJvbC5sZW5ndGgpO1xyXG5cclxuXHRsZXQgY2hlY2tlZFJlZ0V4cCA9IG5ldyBSZWdFeHAoJ15bJyArIHN5bWJvbENsYXNzICsgJ10rJCcpO1xyXG5cdGxldCBsZW5ndGhUeXBlID0gVHlwZXMuSW5kZXguRGVmKG1heExlbmd0aCk7XHJcblxyXG5cclxuXHRsZXQgdHlwZSA9IHtcclxuXHRcdHJhbmQ6IHJhbmQsXHJcblx0XHR0ZXN0OiB0ZXN0LFxyXG5cdFx0cHJlSlNPTjogcHJlSlNPTlxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gcmFuZCgpe1xyXG5cdFx0bGV0IGxlbmd0aCA9IGxlbmd0aFR5cGUucmFuZCgpO1xyXG5cclxuXHRcdGlmKGxlbmd0aCA8IDEpXHJcblx0XHRcdGxlbmd0aCsrO1xyXG5cclxuXHRcdHZhciBzdHIgPSAnJztcclxuXHJcblx0XHR3aGlsZShsZW5ndGgtLSl7XHJcblx0XHRcdHZhciBkZXIgPSByYW5nZVNpbWJvbFtpbmRleFJhbmdlVHlwZS5yYW5kKCldO1xyXG5cdFx0XHRzdHIgKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGRlcik7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHN0cjtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHRlc3Qoc3RyKXtcclxuXHRcdGlmKCh0eXBlb2Yoc3RyKSAhPT0gJ3N0cmluZycpXHJcblx0XHRcdHx8IGxlbmd0aFR5cGUudGVzdChzdHIubGVuZ3RoKVxyXG5cdFx0XHR8fCAhY2hlY2tlZFJlZ0V4cC50ZXN0KHN0cilcclxuXHRcdClcclxuXHRcdFx0cmV0dXJuIHsgdmFsdWU6IHN0ciwgdHlwZTogcHJlSlNPTigpfTtcclxuXHRcdFxyXG5cclxuXHRcdHJldHVybiAgZmFsc2U7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBwcmVKU09OKCl7XHJcblx0XHR2YXIgdHlwZSA9IHt9O1xyXG5cdFx0dHlwZS5uYW1lID0gdHlwZU5hbWU7XHJcblx0XHR0eXBlLnN0cnVjdCA9IHtcclxuXHRcdFx0c3ltYm9sQ2xhc3MsIFxyXG5cdFx0XHRtYXhMZW5ndGgsXHJcblx0XHR9O1xyXG5cdFx0cmV0dXJuIHR5cGU7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gdHlwZTtcclxuXHJcbn1cclxuXHJcbmZ1bmN0aW9uIG91dEpTT04ocHJlVHlwZSl7XHJcblx0aWYodHlwZW9mIHByZVR5cGUgPT0gXCJvYmplY3RcIiAmJiBwcmVUeXBlLm5hbWUgPT0gdHlwZU5hbWUpXHJcblx0XHRyZXR1cm4gQ29uc3RydWN0b3JUeXBlKHByZVR5cGUuc3RydWN0LnN5bWJvbENsYXNzLCBwcmVUeXBlLnN0cnVjdC5tYXhMZW5ndGgpO1xyXG5cdGVsc2VcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIlRoaXMgaXNuJ3QgdHlwZSBcIiArIHR5cGVOYW1lICsgXCIhXCIpO1xyXG59XHJcblxyXG5mdW5jdGlvbiByZXBsYWNlU3BlY0NoYXIoYyl7XHJcblx0c3dpdGNoKGMpe1xyXG5cdFx0Y2FzZSAndyc6IHJldHVybiAnYS16QS1aMC05Xyc7XHJcblx0XHRjYXNlICdkJzogcmV0dXJuICcwLTknO1xyXG5cdFx0Y2FzZSAncyc6IHJldHVybiAnXFxcXHRcXFxcblxcXFx2XFxcXGZcXFxcciAnO1xyXG5cclxuXHRcdGRlZmF1bHQ6IHJldHVybiBjO1xyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gcmFuZ2VJbkFycihiZWcsIGVuZCl7XHJcblx0aWYoYmVnID4gZW5kKXtcclxuXHRcdHZhciB0bXAgPSBiZWc7XHJcblx0XHRiZWcgPSBlbmQ7XHJcblx0XHRlbmQgPSB0bXA7XHJcblx0fVxyXG5cclxuXHR2YXIgYXJyID0gW107XHJcblx0Zm9yKHZhciBpID0gYmVnOyBpIDw9IGVuZDsgaSsrKXtcclxuXHRcdGFyci5wdXNoKGkpO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIGFycjtcclxufVxyXG5cclxuZnVuY3Rpb24gcGFyc2VSYW5nZShwYXJzZV9zdHIpe1xyXG5cdGlmKC9cXFxcLi8udGVzdChwYXJzZV9zdHIpKXtcclxuXHRcdFx0cGFyc2Vfc3RyID0gcGFyc2Vfc3RyLnJlcGxhY2UoL1xcXFwoLikvZywgZnVuY3Rpb24oc3RyLCBjaGFyKXsgcmV0dXJuIHJlcGxhY2VTcGVjQ2hhcihjaGFyKTt9KTtcclxuXHR9XHJcblxyXG5cdGxldCByZXN1bHQgPSBbXTtcclxuXHJcblx0bGV0IGJlZ19jaGFyID0gcGFyc2Vfc3RyWzBdO1xyXG5cdGZvcihsZXQgaSA9IDE7IGkgPD0gcGFyc2Vfc3RyLmxlbmd0aDsgaSsrKXtcclxuXHJcblx0XHRpZihwYXJzZV9zdHJbaS0xXSAhPT0gJ1xcXFwnXHJcblx0XHRcdCYmcGFyc2Vfc3RyW2ldID09PSAnLSdcclxuXHRcdFx0JiZwYXJzZV9zdHJbaSsxXSl7XHJcblx0XHRcdGkrKztcclxuXHRcdFx0bGV0IGVuZF9jaGFyID0gcGFyc2Vfc3RyW2ldO1xyXG5cclxuXHRcdFx0bGV0IGFycl9jaGFycyA9IHJhbmdlSW5BcnIoYmVnX2NoYXIuY2hhckNvZGVBdCgwKSwgZW5kX2NoYXIuY2hhckNvZGVBdCgwKSk7XHJcblx0XHRcdHJlc3VsdCA9IHJlc3VsdC5jb25jYXQoYXJyX2NoYXJzKTtcclxuXHJcblx0XHRcdGkrKztcclxuXHRcdH1lbHNle1xyXG5cdFx0XHRyZXN1bHQucHVzaChiZWdfY2hhci5jaGFyQ29kZUF0KDApKTtcclxuXHRcdH1cclxuXHJcblx0XHRiZWdfY2hhciA9IHBhcnNlX3N0cltpXTtcclxuXHR9XHJcblx0cmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBFeHRlbmRUeXBlczsiLCIndXNlIHN0cmljdCc7XHJcblxyXG5jb25zdCB0eXBlTmFtZSA9IFwiU3dpdGNoXCI7XHJcblxyXG5sZXQgYXJnRXJyb3IgPSBudWxsO1xyXG5cclxubGV0IFR5cGVzID0gbnVsbDtcclxuXHJcbmNvbnN0IENySW5kZXhUeXBlICA9ICByZXF1aXJlKCcuLi9pbmRleC90eXBlLmpzJyk7XHJcbmNvbnN0IENyS2V5VHlwZSAgPSAgcmVxdWlyZSgnLi4va2V5L3R5cGUuanMnKTtcclxuXHJcbmZ1bmN0aW9uIEV4dGVuZFR5cGVzKENvcmUpe1xyXG5cdFR5cGVzID0gQ29yZTtcclxuXHRhcmdFcnJvciA9IENvcmUuYXJnRXJyb3I7XHJcblx0aWYoIUNvcmUuSW5kZXgpXHJcblx0XHRDckluZGV4VHlwZShDb3JlKTtcclxuXHRpZighQ29yZS5LZXkpXHJcblx0XHRDcktleVR5cGUoQ29yZSk7XHJcblx0Q29yZS5uZXdUeXBlKHR5cGVOYW1lLCBDb25zdHJ1Y3RvclR5cGUsIG91dEpTT04pO1xyXG59XHJcblxyXG5FeHRlbmRUeXBlcy50eXBlTmFtZSA9IHR5cGVOYW1lO1xyXG5cclxuZnVuY3Rpb24gQ29uc3RydWN0b3JUeXBlKGtleVByb3BzLCB0eXBlT2Jqcyl7XHJcblxyXG5cdGxldCBrZXlUeXBlID0gVHlwZXMuS2V5LkRlZigpO1xyXG5cclxuXHRpZighQXJyYXkuaXNBcnJheShrZXlQcm9wcykpXHJcblx0XHRrZXlQcm9wcyA9IFtrZXlQcm9wc107XHJcblxyXG5cdGlmKGtleVByb3BzLnNvbWUoa2V5VHlwZS50ZXN0KSlcclxuXHRcdHRocm93IGFyZ0Vycm9yKGFyZ3VtZW50cywgJ1dhaXQgdGhlIGZpcnN0IGFyZ3VtZW50IEtleSB8fCBBcnJheShLZXkpJyk7XHJcblxyXG5cdGlmKCFBcnJheS5pc0FycmF5KHR5cGVPYmpzKSlcclxuXHRcdHRocm93IGFyZ0Vycm9yKGFyZ3VtZW50cywgJ1dhaXQgc2Vjb25kIGFyZ3VtZW50IEFycmF5IScpO1xyXG5cclxuXHRsZXQga2V5QXJyID0gW107XHJcblxyXG5cdGxldCBlcnIgPSBtc2cgPT4gYXJnRXJyb3IoYXJndW1lbnRzLCAnV2FpdCBzZWNvbmQgYXJndW1lbnQgQXJyYXkoIE9iamVjdHsgW0tleV06IEtleSwgcHJvcDogVHlwZSwgLi4uIH0pLCAuLi4pOyAnICsgbXNnKTtcclxuXHJcblx0bGV0IHR5cGVPYmpBcnIgPSB0eXBlT2Jqcy5tYXAoKHNydWN0T2JqLCBvYmpJbmRleCkgPT4ge1xyXG5cdFx0aWYodHlwZW9mIHNydWN0T2JqICE9IFwib2JqZWN0XCIpXHJcblx0XHRcdHRocm93IGVycihcIkl0ZW0gXCIgKyBvYmpJbmRleCArIFwiIGluIEFycmF5IGlzbid0IE9iamVjdFwiKTtcclxuXHJcblx0XHRsZXQgb2JqID0ge307XHJcblxyXG5cdFx0a2V5QXJyW29iakluZGV4XSA9IHt9O1xyXG5cdFx0a2V5UHJvcHMuZm9yRWFjaChrZXlQcm9wID0+e1xyXG5cdFx0XHRpZihrZXlUeXBlLnRlc3Qoc3J1Y3RPYmpba2V5UHJvcF0pKVxyXG5cdFx0XHRcdHRocm93IGVycihcIkl0ZW0gXCIgKyBvYmpJbmRleCArIFwiLlwiICsga2V5UHJvcCArIFwiIGlzbid0IEtleVwiKTtcclxuXHRcdFx0ZWxzZVxyXG5cdFx0XHRcdGtleUFycltvYmpJbmRleF1ba2V5UHJvcF0gPSBzcnVjdE9ialtrZXlQcm9wXTtcclxuXHRcdH0pO1xyXG5cdFx0XHJcblx0XHRmb3IgKGxldCBrZXkgaW4gc3J1Y3RPYmope1xyXG5cdFx0XHRpZihrZXlQcm9wcy5pbmRleE9mKGtleSkgPT0gLTEpe1xyXG5cclxuXHRcdFx0XHRpZihUeXBlcy5pc1R5cGUoc3J1Y3RPYmpba2V5XSkpXHJcblx0XHRcdFx0XHRvYmpba2V5XSA9IHNydWN0T2JqW2tleV07XHJcblx0XHRcdFx0ZWxzZVxyXG5cdFx0XHRcdFx0dGhyb3cgZXJyKFwiSXRlbSBcIiArIG9iakluZGV4ICsgXCIuXCIgKyBrZXkgKyBcIiBpc24ndCBUeXBlXCIpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG9iajtcclxuXHR9KTtcclxuXHJcblx0bGV0IGluZGV4VHlwZSA9IFR5cGVzLkluZGV4LkRlZihrZXlBcnIubGVuZ3RoKTtcclxuXHRcdFxyXG5cclxuXHRsZXQgdHlwZSA9IHtcclxuXHRcdHJhbmQ6IHJhbmQsXHJcblx0XHR0ZXN0OiB0ZXN0LFxyXG5cdFx0cHJlSlNPTjogcHJlSlNPTlxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gcmFuZCgpe1xyXG5cdFx0bGV0IGluZGV4ID0gaW5kZXhUeXBlLnJhbmQoKTtcclxuXHJcblx0XHRsZXQgb2JqID0ge307XHJcblxyXG5cdFx0bGV0IGtleU9iaiA9IGtleUFycltpbmRleF07XHJcblx0XHRmb3IobGV0IGtleVByb3AgaW4ga2V5T2JqKVxyXG5cdFx0XHRcdG9ialtrZXlQcm9wXSA9IGtleU9ialtrZXlQcm9wXTtcclxuXHRcdFxyXG5cdFx0bGV0IHNydWN0T2JqID0gdHlwZU9iakFycltpbmRleF07XHJcblx0XHRmb3IgKGxldCBrZXkgaW4gc3J1Y3RPYmope1xyXG5cdFx0XHRvYmpba2V5XSA9IHNydWN0T2JqW2tleV0ucmFuZCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBvYmo7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiB0ZXN0KG9iail7XHJcblx0XHRcclxuXHRcdGlmKHR5cGVvZiBvYmogIT0gXCJvYmplY3RcIiB8fCBvYmogPT09IG51bGwpXHJcblx0XHRcdHJldHVybiB7IHZhbHVlOiBvYmosIHR5cGU6IHByZUpTT04oKX07XHJcblxyXG5cdFx0aWYoa2V5UHJvcHMuc29tZShrZXlQcm9wID0+IGtleVR5cGUudGVzdChvYmpba2V5UHJvcF0pKSlcclxuXHRcdFx0cmV0dXJuIHsgdmFsdWU6IG9iaiwgdHlwZTogcHJlSlNPTigpfTtcclxuXHJcblx0XHRsZXQgZXJyID0geyB2YWx1ZTogb2JqLCB0eXBlOiBwcmVKU09OKCl9O1xyXG5cdFx0bGV0IGlzX3JpZ2h0ID0gZmFsc2U7XHJcblxyXG5cdFx0a2V5QXJyLmZvckVhY2goKGtleU9iaiwgaW5kZXgpID0+e1xyXG5cdFx0XHRpZihpc19yaWdodClcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFxyXG5cdFx0XHRsZXQgaXNfcmlnaHRfa2V5cyA9IHRydWU7XHJcblx0XHRcdGZvcihsZXQga2V5UHJvcCBpbiBrZXlPYmopXHJcblx0XHRcdFx0aXNfcmlnaHRfa2V5cyA9IGlzX3JpZ2h0X2tleXMgJiYgKGtleU9ialtrZXlQcm9wXSA9PSBvYmpba2V5UHJvcF0pO1xyXG5cclxuXHRcdFx0aWYoaXNfcmlnaHRfa2V5cyl7XHJcblxyXG5cdFx0XHRcdGxldCBpc19yaWdodF92YWx1ZXMgPSB0cnVlO1xyXG5cdFx0XHRcdGZvcihsZXQga2V5IGluIHR5cGVPYmpBcnJbaW5kZXhdKXtcclxuXHRcdFx0XHRcdGlmKHR5cGVPYmpBcnJbaW5kZXhdW2tleV0udGVzdChvYmpba2V5XSkpe1xyXG5cdFx0XHRcdFx0XHRlcnIgPSB7IHZhbHVlOiBvYmpba2V5XSwgdHlwZTogdHlwZU9iakFycltpbmRleF1ba2V5XS5wcmVKU09OKCl9O1xyXG5cdFx0XHRcdFx0XHRpc19yaWdodF92YWx1ZXMgPSBmYWxzZTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmKGlzX3JpZ2h0X3ZhbHVlcylcclxuXHRcdFx0XHRcdGlzX3JpZ2h0ID0gdHJ1ZTtcclxuXHRcdFx0fSBcclxuXHJcblx0XHR9KTtcclxuXHJcblx0XHRpZighaXNfcmlnaHQpXHJcblx0XHRcdHJldHVybiBlcnI7XHJcblxyXG5cdFx0cmV0dXJuO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gcHJlSlNPTigpe1xyXG5cdFx0dmFyIHR5cGUgPSB7fTtcclxuXHRcdHR5cGUubmFtZSA9IHR5cGVOYW1lO1xyXG5cclxuXHRcdGxldCB0ZW1wT2JqQXJyID0gdHlwZU9ianMubWFwKHNydWN0T2JqID0+IHtcclxuXHRcdFx0bGV0IG9iaiA9IHt9O1xyXG5cdFx0XHRmb3IgKGxldCBrZXkgaW4gc3J1Y3RPYmope1xyXG5cdFx0XHRcdGlmKFR5cGVzLmlzVHlwZShzcnVjdE9ialtrZXldKSlcclxuXHRcdFx0XHRcdG9ialtrZXldID0gc3J1Y3RPYmpba2V5XS5wcmVKU09OKCk7XHJcblx0XHRcdFx0ZWxzZVxyXG5cdFx0XHRcdFx0b2JqW2tleV0gPSBzcnVjdE9ialtrZXldO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gb2JqO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0dHlwZS5zdHJ1Y3QgPSB7IGtleVByb3BzLCB0ZW1wT2JqQXJyIH07XHJcblx0XHRyZXR1cm4gdHlwZTtcclxuXHR9XHJcblxyXG5cdHJldHVybiB0eXBlO1xyXG5cclxufVxyXG5cclxuZnVuY3Rpb24gb3V0SlNPTihwcmVUeXBlKXtcclxuXHRpZih0eXBlb2YgcHJlVHlwZSA9PSBcIm9iamVjdFwiICYmIHByZVR5cGUubmFtZSA9PSB0eXBlTmFtZSl7XHJcblxyXG5cdFx0bGV0IE9ianNBcnIgPSBwcmVUeXBlLnN0cnVjdC50ZW1wT2JqQXJyLm1hcChqc29uT2JqID0+IHtcclxuXHRcdFx0bGV0IG9iaiA9IHt9O1xyXG5cclxuXHRcdFx0Zm9yKHZhciBrZXkgaW4ganNvbk9iail7XHJcblx0XHRcdFx0dmFyIHByb3BKc29uT2JqID0ganNvbk9ialtrZXldO1xyXG5cclxuXHRcdFx0XHRpZihwcm9wSnNvbk9iai5uYW1lICYmIFR5cGVzW3Byb3BKc29uT2JqLm5hbWVdICYmIFR5cGVzLmlzQ3JUeXBlKFR5cGVzW3Byb3BKc29uT2JqLm5hbWVdKSl7XHJcblx0XHRcdFx0XHRvYmpba2V5XSA9IFR5cGVzW3Byb3BKc29uT2JqLm5hbWVdLm91dEpTT04ocHJvcEpzb25PYmopO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRlbHNlXHJcblx0XHRcdFx0XHRvYmpba2V5XSA9IHByb3BKc29uT2JqO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gb2JqO1xyXG5cdFx0fSk7XHJcblx0XHRcclxuXHRcdHJldHVybiBDb25zdHJ1Y3RvclR5cGUocHJlVHlwZS5zdHJ1Y3Qua2V5UHJvcHMsIE9ianNBcnIpO1xyXG5cdH1cclxuXHRlbHNlXHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIGlzbid0IHR5cGUgXCIgKyB0eXBlTmFtZSArIFwiIVwiKTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBFeHRlbmRUeXBlczsiLCIndXNlIHN0cmljdCc7XHJcblxyXG5jb25zdCB0eXBlTmFtZSA9IFwiQ29yZVwiO1xyXG5cclxubGV0IGFyZ0Vycm9yID0gbnVsbDtcclxuXHJcbmxldCBUeXBlcyA9IG51bGw7XHJcblxyXG5mdW5jdGlvbiBFeHRlbmRUeXBlcyhDb3JlKXtcclxuXHRUeXBlcyA9IENvcmU7XHJcblx0YXJnRXJyb3IgPSBDb3JlLmFyZ0Vycm9yO1xyXG5cdENvcmUubmV3VHlwZSh0eXBlTmFtZSwgQ29uc3RydWN0b3JUeXBlLCBvdXRKU09OKTtcclxufVxyXG5cclxuRXh0ZW5kVHlwZXMudHlwZU5hbWUgPSB0eXBlTmFtZTtcclxuXHJcbmZ1bmN0aW9uIENvbnN0cnVjdG9yVHlwZShoZWxsbyl7XHJcblxyXG5cdGlmKHR5cGVvZiBoZWxsbyAhPT0gXCJzdHJpbmdcIilcclxuXHRcdHRocm93IGFyZ0Vycm9yKGFyZ3VtZW50cywgJ1dhaXQgYXJncyAoU3RyaW5nKScpO1xyXG5cclxuXHRsZXQgdHlwZSA9IHtcclxuXHRcdHJhbmQ6IHJhbmQsXHJcblx0XHR0ZXN0OiB0ZXN0LFxyXG5cdFx0cHJlSlNPTjogcHJlSlNPTlxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gcmFuZCgpe1xyXG5cdFx0cmV0dXJuIGhlbGxvO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gdGVzdCh2YWx1ZSl7XHJcblx0XHRpZih2YWx1ZSAhPT0gaGVsbG8pXHJcblx0XHRcdHJldHVybiB7IHZhbHVlOiB2YWx1ZSwgdHlwZTogcHJlSlNPTigpfTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHByZUpTT04oKXtcclxuXHRcdHZhciB0eXBlID0ge307XHJcblx0XHR0eXBlLm5hbWUgPSB0eXBlTmFtZTtcclxuXHRcdHR5cGUuc3RydWN0ID0gaGVsbG87XHJcblx0XHRyZXR1cm4gdHlwZTtcclxuXHR9XHJcblxyXG5cdHJldHVybiB0eXBlO1xyXG5cclxufVxyXG5cclxuZnVuY3Rpb24gb3V0SlNPTihwcmVUeXBlKXtcclxuXHRpZih0eXBlb2YgcHJlVHlwZSA9PSBcIm9iamVjdFwiICYmIHByZVR5cGUubmFtZSA9PSB0eXBlTmFtZSlcclxuXHRcdHJldHVybiBDb25zdHJ1Y3RvclR5cGUocHJlVHlwZS5zdHJ1Y3QpXHJcblx0ZWxzZVxyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiVGhpcyBpc24ndCB0eXBlIFwiICsgdHlwZU5hbWUgKyBcIiFcIik7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRXh0ZW5kVHlwZXM7IiwiLyoqXG4gKiBDb252ZXJ0IGFycmF5IG9mIDE2IGJ5dGUgdmFsdWVzIHRvIFVVSUQgc3RyaW5nIGZvcm1hdCBvZiB0aGUgZm9ybTpcbiAqIFhYWFhYWFhYLVhYWFgtWFhYWC1YWFhYLVhYWFhYWFhYWFhYWFxuICovXG52YXIgYnl0ZVRvSGV4ID0gW107XG5mb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgKytpKSB7XG4gIGJ5dGVUb0hleFtpXSA9IChpICsgMHgxMDApLnRvU3RyaW5nKDE2KS5zdWJzdHIoMSk7XG59XG5cbmZ1bmN0aW9uIGJ5dGVzVG9VdWlkKGJ1Ziwgb2Zmc2V0KSB7XG4gIHZhciBpID0gb2Zmc2V0IHx8IDA7XG4gIHZhciBidGggPSBieXRlVG9IZXg7XG4gIC8vIGpvaW4gdXNlZCB0byBmaXggbWVtb3J5IGlzc3VlIGNhdXNlZCBieSBjb25jYXRlbmF0aW9uOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMTc1I2M0XG4gIHJldHVybiAoW2J0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sIFxuXHRidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLCAnLScsXG5cdGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sICctJyxcblx0YnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSwgJy0nLFxuXHRidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLCAnLScsXG5cdGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sXG5cdGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sXG5cdGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV1dKS5qb2luKCcnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBieXRlc1RvVXVpZDtcbiIsIi8vIFVuaXF1ZSBJRCBjcmVhdGlvbiByZXF1aXJlcyBhIGhpZ2ggcXVhbGl0eSByYW5kb20gIyBnZW5lcmF0b3IuICBJbiB0aGVcbi8vIGJyb3dzZXIgdGhpcyBpcyBhIGxpdHRsZSBjb21wbGljYXRlZCBkdWUgdG8gdW5rbm93biBxdWFsaXR5IG9mIE1hdGgucmFuZG9tKClcbi8vIGFuZCBpbmNvbnNpc3RlbnQgc3VwcG9ydCBmb3IgdGhlIGBjcnlwdG9gIEFQSS4gIFdlIGRvIHRoZSBiZXN0IHdlIGNhbiB2aWFcbi8vIGZlYXR1cmUtZGV0ZWN0aW9uXG5cbi8vIGdldFJhbmRvbVZhbHVlcyBuZWVkcyB0byBiZSBpbnZva2VkIGluIGEgY29udGV4dCB3aGVyZSBcInRoaXNcIiBpcyBhIENyeXB0b1xuLy8gaW1wbGVtZW50YXRpb24uIEFsc28sIGZpbmQgdGhlIGNvbXBsZXRlIGltcGxlbWVudGF0aW9uIG9mIGNyeXB0byBvbiBJRTExLlxudmFyIGdldFJhbmRvbVZhbHVlcyA9ICh0eXBlb2YoY3J5cHRvKSAhPSAndW5kZWZpbmVkJyAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMuYmluZChjcnlwdG8pKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2YobXNDcnlwdG8pICE9ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cubXNDcnlwdG8uZ2V0UmFuZG9tVmFsdWVzID09ICdmdW5jdGlvbicgJiYgbXNDcnlwdG8uZ2V0UmFuZG9tVmFsdWVzLmJpbmQobXNDcnlwdG8pKTtcblxuaWYgKGdldFJhbmRvbVZhbHVlcykge1xuICAvLyBXSEFUV0cgY3J5cHRvIFJORyAtIGh0dHA6Ly93aWtpLndoYXR3Zy5vcmcvd2lraS9DcnlwdG9cbiAgdmFyIHJuZHM4ID0gbmV3IFVpbnQ4QXJyYXkoMTYpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB3aGF0d2dSTkcoKSB7XG4gICAgZ2V0UmFuZG9tVmFsdWVzKHJuZHM4KTtcbiAgICByZXR1cm4gcm5kczg7XG4gIH07XG59IGVsc2Uge1xuICAvLyBNYXRoLnJhbmRvbSgpLWJhc2VkIChSTkcpXG4gIC8vXG4gIC8vIElmIGFsbCBlbHNlIGZhaWxzLCB1c2UgTWF0aC5yYW5kb20oKS4gIEl0J3MgZmFzdCwgYnV0IGlzIG9mIHVuc3BlY2lmaWVkXG4gIC8vIHF1YWxpdHkuXG4gIHZhciBybmRzID0gbmV3IEFycmF5KDE2KTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG1hdGhSTkcoKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIHI7IGkgPCAxNjsgaSsrKSB7XG4gICAgICBpZiAoKGkgJiAweDAzKSA9PT0gMCkgciA9IE1hdGgucmFuZG9tKCkgKiAweDEwMDAwMDAwMDtcbiAgICAgIHJuZHNbaV0gPSByID4+PiAoKGkgJiAweDAzKSA8PCAzKSAmIDB4ZmY7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJuZHM7XG4gIH07XG59XG4iLCIvLyBBZGFwdGVkIGZyb20gQ2hyaXMgVmVuZXNzJyBTSEExIGNvZGUgYXRcbi8vIGh0dHA6Ly93d3cubW92YWJsZS10eXBlLmNvLnVrL3NjcmlwdHMvc2hhMS5odG1sXG4ndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGYocywgeCwgeSwgeikge1xuICBzd2l0Y2ggKHMpIHtcbiAgICBjYXNlIDA6IHJldHVybiAoeCAmIHkpIF4gKH54ICYgeik7XG4gICAgY2FzZSAxOiByZXR1cm4geCBeIHkgXiB6O1xuICAgIGNhc2UgMjogcmV0dXJuICh4ICYgeSkgXiAoeCAmIHopIF4gKHkgJiB6KTtcbiAgICBjYXNlIDM6IHJldHVybiB4IF4geSBeIHo7XG4gIH1cbn1cblxuZnVuY3Rpb24gUk9UTCh4LCBuKSB7XG4gIHJldHVybiAoeCA8PCBuKSB8ICh4Pj4+ICgzMiAtIG4pKTtcbn1cblxuZnVuY3Rpb24gc2hhMShieXRlcykge1xuICB2YXIgSyA9IFsweDVhODI3OTk5LCAweDZlZDllYmExLCAweDhmMWJiY2RjLCAweGNhNjJjMWQ2XTtcbiAgdmFyIEggPSBbMHg2NzQ1MjMwMSwgMHhlZmNkYWI4OSwgMHg5OGJhZGNmZSwgMHgxMDMyNTQ3NiwgMHhjM2QyZTFmMF07XG5cbiAgaWYgKHR5cGVvZihieXRlcykgPT0gJ3N0cmluZycpIHtcbiAgICB2YXIgbXNnID0gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KGJ5dGVzKSk7IC8vIFVURjggZXNjYXBlXG4gICAgYnl0ZXMgPSBuZXcgQXJyYXkobXNnLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpKyspIGJ5dGVzW2ldID0gbXNnLmNoYXJDb2RlQXQoaSk7XG4gIH1cblxuICBieXRlcy5wdXNoKDB4ODApO1xuXG4gIHZhciBsID0gYnl0ZXMubGVuZ3RoLzQgKyAyO1xuICB2YXIgTiA9IE1hdGguY2VpbChsLzE2KTtcbiAgdmFyIE0gPSBuZXcgQXJyYXkoTik7XG5cbiAgZm9yICh2YXIgaT0wOyBpPE47IGkrKykge1xuICAgIE1baV0gPSBuZXcgQXJyYXkoMTYpO1xuICAgIGZvciAodmFyIGo9MDsgajwxNjsgaisrKSB7XG4gICAgICBNW2ldW2pdID1cbiAgICAgICAgYnl0ZXNbaSAqIDY0ICsgaiAqIDRdIDw8IDI0IHxcbiAgICAgICAgYnl0ZXNbaSAqIDY0ICsgaiAqIDQgKyAxXSA8PCAxNiB8XG4gICAgICAgIGJ5dGVzW2kgKiA2NCArIGogKiA0ICsgMl0gPDwgOCB8XG4gICAgICAgIGJ5dGVzW2kgKiA2NCArIGogKiA0ICsgM107XG4gICAgfVxuICB9XG5cbiAgTVtOIC0gMV1bMTRdID0gKChieXRlcy5sZW5ndGggLSAxKSAqIDgpIC9cbiAgICBNYXRoLnBvdygyLCAzMik7IE1bTiAtIDFdWzE0XSA9IE1hdGguZmxvb3IoTVtOIC0gMV1bMTRdKTtcbiAgTVtOIC0gMV1bMTVdID0gKChieXRlcy5sZW5ndGggLSAxKSAqIDgpICYgMHhmZmZmZmZmZjtcblxuICBmb3IgKHZhciBpPTA7IGk8TjsgaSsrKSB7XG4gICAgdmFyIFcgPSBuZXcgQXJyYXkoODApO1xuXG4gICAgZm9yICh2YXIgdD0wOyB0PDE2OyB0KyspIFdbdF0gPSBNW2ldW3RdO1xuICAgIGZvciAodmFyIHQ9MTY7IHQ8ODA7IHQrKykge1xuICAgICAgV1t0XSA9IFJPVEwoV1t0IC0gM10gXiBXW3QgLSA4XSBeIFdbdCAtIDE0XSBeIFdbdCAtIDE2XSwgMSk7XG4gICAgfVxuXG4gICAgdmFyIGEgPSBIWzBdO1xuICAgIHZhciBiID0gSFsxXTtcbiAgICB2YXIgYyA9IEhbMl07XG4gICAgdmFyIGQgPSBIWzNdO1xuICAgIHZhciBlID0gSFs0XTtcblxuICAgIGZvciAodmFyIHQ9MDsgdDw4MDsgdCsrKSB7XG4gICAgICB2YXIgcyA9IE1hdGguZmxvb3IodC8yMCk7XG4gICAgICB2YXIgVCA9IFJPVEwoYSwgNSkgKyBmKHMsIGIsIGMsIGQpICsgZSArIEtbc10gKyBXW3RdID4+PiAwO1xuICAgICAgZSA9IGQ7XG4gICAgICBkID0gYztcbiAgICAgIGMgPSBST1RMKGIsIDMwKSA+Pj4gMDtcbiAgICAgIGIgPSBhO1xuICAgICAgYSA9IFQ7XG4gICAgfVxuXG4gICAgSFswXSA9IChIWzBdICsgYSkgPj4+IDA7XG4gICAgSFsxXSA9IChIWzFdICsgYikgPj4+IDA7XG4gICAgSFsyXSA9IChIWzJdICsgYykgPj4+IDA7XG4gICAgSFszXSA9IChIWzNdICsgZCkgPj4+IDA7XG4gICAgSFs0XSA9IChIWzRdICsgZSkgPj4+IDA7XG4gIH1cblxuICByZXR1cm4gW1xuICAgIEhbMF0gPj4gMjQgJiAweGZmLCBIWzBdID4+IDE2ICYgMHhmZiwgSFswXSA+PiA4ICYgMHhmZiwgSFswXSAmIDB4ZmYsXG4gICAgSFsxXSA+PiAyNCAmIDB4ZmYsIEhbMV0gPj4gMTYgJiAweGZmLCBIWzFdID4+IDggJiAweGZmLCBIWzFdICYgMHhmZixcbiAgICBIWzJdID4+IDI0ICYgMHhmZiwgSFsyXSA+PiAxNiAmIDB4ZmYsIEhbMl0gPj4gOCAmIDB4ZmYsIEhbMl0gJiAweGZmLFxuICAgIEhbM10gPj4gMjQgJiAweGZmLCBIWzNdID4+IDE2ICYgMHhmZiwgSFszXSA+PiA4ICYgMHhmZiwgSFszXSAmIDB4ZmYsXG4gICAgSFs0XSA+PiAyNCAmIDB4ZmYsIEhbNF0gPj4gMTYgJiAweGZmLCBIWzRdID4+IDggJiAweGZmLCBIWzRdICYgMHhmZlxuICBdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNoYTE7XG4iLCJ2YXIgYnl0ZXNUb1V1aWQgPSByZXF1aXJlKCcuL2J5dGVzVG9VdWlkJyk7XG5cbmZ1bmN0aW9uIHV1aWRUb0J5dGVzKHV1aWQpIHtcbiAgLy8gTm90ZTogV2UgYXNzdW1lIHdlJ3JlIGJlaW5nIHBhc3NlZCBhIHZhbGlkIHV1aWQgc3RyaW5nXG4gIHZhciBieXRlcyA9IFtdO1xuICB1dWlkLnJlcGxhY2UoL1thLWZBLUYwLTldezJ9L2csIGZ1bmN0aW9uKGhleCkge1xuICAgIGJ5dGVzLnB1c2gocGFyc2VJbnQoaGV4LCAxNikpO1xuICB9KTtcblxuICByZXR1cm4gYnl0ZXM7XG59XG5cbmZ1bmN0aW9uIHN0cmluZ1RvQnl0ZXMoc3RyKSB7XG4gIHN0ciA9IHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChzdHIpKTsgLy8gVVRGOCBlc2NhcGVcbiAgdmFyIGJ5dGVzID0gbmV3IEFycmF5KHN0ci5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIGJ5dGVzW2ldID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gIH1cbiAgcmV0dXJuIGJ5dGVzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG5hbWUsIHZlcnNpb24sIGhhc2hmdW5jKSB7XG4gIHZhciBnZW5lcmF0ZVVVSUQgPSBmdW5jdGlvbih2YWx1ZSwgbmFtZXNwYWNlLCBidWYsIG9mZnNldCkge1xuICAgIHZhciBvZmYgPSBidWYgJiYgb2Zmc2V0IHx8IDA7XG5cbiAgICBpZiAodHlwZW9mKHZhbHVlKSA9PSAnc3RyaW5nJykgdmFsdWUgPSBzdHJpbmdUb0J5dGVzKHZhbHVlKTtcbiAgICBpZiAodHlwZW9mKG5hbWVzcGFjZSkgPT0gJ3N0cmluZycpIG5hbWVzcGFjZSA9IHV1aWRUb0J5dGVzKG5hbWVzcGFjZSk7XG5cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB0aHJvdyBUeXBlRXJyb3IoJ3ZhbHVlIG11c3QgYmUgYW4gYXJyYXkgb2YgYnl0ZXMnKTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkobmFtZXNwYWNlKSB8fCBuYW1lc3BhY2UubGVuZ3RoICE9PSAxNikgdGhyb3cgVHlwZUVycm9yKCduYW1lc3BhY2UgbXVzdCBiZSB1dWlkIHN0cmluZyBvciBhbiBBcnJheSBvZiAxNiBieXRlIHZhbHVlcycpO1xuXG4gICAgLy8gUGVyIDQuM1xuICAgIHZhciBieXRlcyA9IGhhc2hmdW5jKG5hbWVzcGFjZS5jb25jYXQodmFsdWUpKTtcbiAgICBieXRlc1s2XSA9IChieXRlc1s2XSAmIDB4MGYpIHwgdmVyc2lvbjtcbiAgICBieXRlc1s4XSA9IChieXRlc1s4XSAmIDB4M2YpIHwgMHg4MDtcblxuICAgIGlmIChidWYpIHtcbiAgICAgIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IDE2OyArK2lkeCkge1xuICAgICAgICBidWZbb2ZmK2lkeF0gPSBieXRlc1tpZHhdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBidWYgfHwgYnl0ZXNUb1V1aWQoYnl0ZXMpO1xuICB9O1xuXG4gIC8vIEZ1bmN0aW9uI25hbWUgaXMgbm90IHNldHRhYmxlIG9uIHNvbWUgcGxhdGZvcm1zICgjMjcwKVxuICB0cnkge1xuICAgIGdlbmVyYXRlVVVJRC5uYW1lID0gbmFtZTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gIH1cblxuICAvLyBQcmUtZGVmaW5lZCBuYW1lc3BhY2VzLCBwZXIgQXBwZW5kaXggQ1xuICBnZW5lcmF0ZVVVSUQuRE5TID0gJzZiYTdiODEwLTlkYWQtMTFkMS04MGI0LTAwYzA0ZmQ0MzBjOCc7XG4gIGdlbmVyYXRlVVVJRC5VUkwgPSAnNmJhN2I4MTEtOWRhZC0xMWQxLTgwYjQtMDBjMDRmZDQzMGM4JztcblxuICByZXR1cm4gZ2VuZXJhdGVVVUlEO1xufTtcbiIsInZhciBybmcgPSByZXF1aXJlKCcuL2xpYi9ybmcnKTtcbnZhciBieXRlc1RvVXVpZCA9IHJlcXVpcmUoJy4vbGliL2J5dGVzVG9VdWlkJyk7XG5cbi8vICoqYHYxKClgIC0gR2VuZXJhdGUgdGltZS1iYXNlZCBVVUlEKipcbi8vXG4vLyBJbnNwaXJlZCBieSBodHRwczovL2dpdGh1Yi5jb20vTGlvc0svVVVJRC5qc1xuLy8gYW5kIGh0dHA6Ly9kb2NzLnB5dGhvbi5vcmcvbGlicmFyeS91dWlkLmh0bWxcblxudmFyIF9ub2RlSWQ7XG52YXIgX2Nsb2Nrc2VxO1xuXG4vLyBQcmV2aW91cyB1dWlkIGNyZWF0aW9uIHRpbWVcbnZhciBfbGFzdE1TZWNzID0gMDtcbnZhciBfbGFzdE5TZWNzID0gMDtcblxuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9icm9vZmEvbm9kZS11dWlkIGZvciBBUEkgZGV0YWlsc1xuZnVuY3Rpb24gdjEob3B0aW9ucywgYnVmLCBvZmZzZXQpIHtcbiAgdmFyIGkgPSBidWYgJiYgb2Zmc2V0IHx8IDA7XG4gIHZhciBiID0gYnVmIHx8IFtdO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgbm9kZSA9IG9wdGlvbnMubm9kZSB8fCBfbm9kZUlkO1xuICB2YXIgY2xvY2tzZXEgPSBvcHRpb25zLmNsb2Nrc2VxICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNsb2Nrc2VxIDogX2Nsb2Nrc2VxO1xuXG4gIC8vIG5vZGUgYW5kIGNsb2Nrc2VxIG5lZWQgdG8gYmUgaW5pdGlhbGl6ZWQgdG8gcmFuZG9tIHZhbHVlcyBpZiB0aGV5J3JlIG5vdFxuICAvLyBzcGVjaWZpZWQuICBXZSBkbyB0aGlzIGxhemlseSB0byBtaW5pbWl6ZSBpc3N1ZXMgcmVsYXRlZCB0byBpbnN1ZmZpY2llbnRcbiAgLy8gc3lzdGVtIGVudHJvcHkuICBTZWUgIzE4OVxuICBpZiAobm9kZSA9PSBudWxsIHx8IGNsb2Nrc2VxID09IG51bGwpIHtcbiAgICB2YXIgc2VlZEJ5dGVzID0gcm5nKCk7XG4gICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgLy8gUGVyIDQuNSwgY3JlYXRlIGFuZCA0OC1iaXQgbm9kZSBpZCwgKDQ3IHJhbmRvbSBiaXRzICsgbXVsdGljYXN0IGJpdCA9IDEpXG4gICAgICBub2RlID0gX25vZGVJZCA9IFtcbiAgICAgICAgc2VlZEJ5dGVzWzBdIHwgMHgwMSxcbiAgICAgICAgc2VlZEJ5dGVzWzFdLCBzZWVkQnl0ZXNbMl0sIHNlZWRCeXRlc1szXSwgc2VlZEJ5dGVzWzRdLCBzZWVkQnl0ZXNbNV1cbiAgICAgIF07XG4gICAgfVxuICAgIGlmIChjbG9ja3NlcSA9PSBudWxsKSB7XG4gICAgICAvLyBQZXIgNC4yLjIsIHJhbmRvbWl6ZSAoMTQgYml0KSBjbG9ja3NlcVxuICAgICAgY2xvY2tzZXEgPSBfY2xvY2tzZXEgPSAoc2VlZEJ5dGVzWzZdIDw8IDggfCBzZWVkQnl0ZXNbN10pICYgMHgzZmZmO1xuICAgIH1cbiAgfVxuXG4gIC8vIFVVSUQgdGltZXN0YW1wcyBhcmUgMTAwIG5hbm8tc2Vjb25kIHVuaXRzIHNpbmNlIHRoZSBHcmVnb3JpYW4gZXBvY2gsXG4gIC8vICgxNTgyLTEwLTE1IDAwOjAwKS4gIEpTTnVtYmVycyBhcmVuJ3QgcHJlY2lzZSBlbm91Z2ggZm9yIHRoaXMsIHNvXG4gIC8vIHRpbWUgaXMgaGFuZGxlZCBpbnRlcm5hbGx5IGFzICdtc2VjcycgKGludGVnZXIgbWlsbGlzZWNvbmRzKSBhbmQgJ25zZWNzJ1xuICAvLyAoMTAwLW5hbm9zZWNvbmRzIG9mZnNldCBmcm9tIG1zZWNzKSBzaW5jZSB1bml4IGVwb2NoLCAxOTcwLTAxLTAxIDAwOjAwLlxuICB2YXIgbXNlY3MgPSBvcHRpb25zLm1zZWNzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm1zZWNzIDogbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cbiAgLy8gUGVyIDQuMi4xLjIsIHVzZSBjb3VudCBvZiB1dWlkJ3MgZ2VuZXJhdGVkIGR1cmluZyB0aGUgY3VycmVudCBjbG9ja1xuICAvLyBjeWNsZSB0byBzaW11bGF0ZSBoaWdoZXIgcmVzb2x1dGlvbiBjbG9ja1xuICB2YXIgbnNlY3MgPSBvcHRpb25zLm5zZWNzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm5zZWNzIDogX2xhc3ROU2VjcyArIDE7XG5cbiAgLy8gVGltZSBzaW5jZSBsYXN0IHV1aWQgY3JlYXRpb24gKGluIG1zZWNzKVxuICB2YXIgZHQgPSAobXNlY3MgLSBfbGFzdE1TZWNzKSArIChuc2VjcyAtIF9sYXN0TlNlY3MpLzEwMDAwO1xuXG4gIC8vIFBlciA0LjIuMS4yLCBCdW1wIGNsb2Nrc2VxIG9uIGNsb2NrIHJlZ3Jlc3Npb25cbiAgaWYgKGR0IDwgMCAmJiBvcHRpb25zLmNsb2Nrc2VxID09PSB1bmRlZmluZWQpIHtcbiAgICBjbG9ja3NlcSA9IGNsb2Nrc2VxICsgMSAmIDB4M2ZmZjtcbiAgfVxuXG4gIC8vIFJlc2V0IG5zZWNzIGlmIGNsb2NrIHJlZ3Jlc3NlcyAobmV3IGNsb2Nrc2VxKSBvciB3ZSd2ZSBtb3ZlZCBvbnRvIGEgbmV3XG4gIC8vIHRpbWUgaW50ZXJ2YWxcbiAgaWYgKChkdCA8IDAgfHwgbXNlY3MgPiBfbGFzdE1TZWNzKSAmJiBvcHRpb25zLm5zZWNzID09PSB1bmRlZmluZWQpIHtcbiAgICBuc2VjcyA9IDA7XG4gIH1cblxuICAvLyBQZXIgNC4yLjEuMiBUaHJvdyBlcnJvciBpZiB0b28gbWFueSB1dWlkcyBhcmUgcmVxdWVzdGVkXG4gIGlmIChuc2VjcyA+PSAxMDAwMCkge1xuICAgIHRocm93IG5ldyBFcnJvcigndXVpZC52MSgpOiBDYW5cXCd0IGNyZWF0ZSBtb3JlIHRoYW4gMTBNIHV1aWRzL3NlYycpO1xuICB9XG5cbiAgX2xhc3RNU2VjcyA9IG1zZWNzO1xuICBfbGFzdE5TZWNzID0gbnNlY3M7XG4gIF9jbG9ja3NlcSA9IGNsb2Nrc2VxO1xuXG4gIC8vIFBlciA0LjEuNCAtIENvbnZlcnQgZnJvbSB1bml4IGVwb2NoIHRvIEdyZWdvcmlhbiBlcG9jaFxuICBtc2VjcyArPSAxMjIxOTI5MjgwMDAwMDtcblxuICAvLyBgdGltZV9sb3dgXG4gIHZhciB0bCA9ICgobXNlY3MgJiAweGZmZmZmZmYpICogMTAwMDAgKyBuc2VjcykgJSAweDEwMDAwMDAwMDtcbiAgYltpKytdID0gdGwgPj4+IDI0ICYgMHhmZjtcbiAgYltpKytdID0gdGwgPj4+IDE2ICYgMHhmZjtcbiAgYltpKytdID0gdGwgPj4+IDggJiAweGZmO1xuICBiW2krK10gPSB0bCAmIDB4ZmY7XG5cbiAgLy8gYHRpbWVfbWlkYFxuICB2YXIgdG1oID0gKG1zZWNzIC8gMHgxMDAwMDAwMDAgKiAxMDAwMCkgJiAweGZmZmZmZmY7XG4gIGJbaSsrXSA9IHRtaCA+Pj4gOCAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRtaCAmIDB4ZmY7XG5cbiAgLy8gYHRpbWVfaGlnaF9hbmRfdmVyc2lvbmBcbiAgYltpKytdID0gdG1oID4+PiAyNCAmIDB4ZiB8IDB4MTA7IC8vIGluY2x1ZGUgdmVyc2lvblxuICBiW2krK10gPSB0bWggPj4+IDE2ICYgMHhmZjtcblxuICAvLyBgY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZGAgKFBlciA0LjIuMiAtIGluY2x1ZGUgdmFyaWFudClcbiAgYltpKytdID0gY2xvY2tzZXEgPj4+IDggfCAweDgwO1xuXG4gIC8vIGBjbG9ja19zZXFfbG93YFxuICBiW2krK10gPSBjbG9ja3NlcSAmIDB4ZmY7XG5cbiAgLy8gYG5vZGVgXG4gIGZvciAodmFyIG4gPSAwOyBuIDwgNjsgKytuKSB7XG4gICAgYltpICsgbl0gPSBub2RlW25dO1xuICB9XG5cbiAgcmV0dXJuIGJ1ZiA/IGJ1ZiA6IGJ5dGVzVG9VdWlkKGIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHYxO1xuIiwidmFyIHYzNSA9IHJlcXVpcmUoJy4vbGliL3YzNS5qcycpO1xudmFyIHNoYTEgPSByZXF1aXJlKCcuL2xpYi9zaGExJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHYzNSgndjUnLCAweDUwLCBzaGExKTtcbiIsInJlcXVpcmUoXCIuLi9saWIvbW9mLmpzXCIpO1xyXG5cclxuZnVuY3Rpb24gQ3JCbG9ja3MoUm91dCwganNvbl9kYXRhX2Jsb2tzKXtcclxuXHR2YXIgRGF0YSA9IEpTT04ucGFyc2UoanNvbl9kYXRhX2Jsb2tzKTtcclxuXHR2YXIgc2l6ZXMgPSBEYXRhLm1hcC5zaXplcztcclxuXHR2YXIgVGlsZXMgPSBEYXRhLnRpbGVzO1xyXG5cclxuXHR2YXIgQmxvY2tzID0gQXJyYXkuY3JlYXRlKCk7XHJcblxyXG5cdC8qdmFyIGNyTGluZSA9IEFycmF5LmNyZWF0ZS5iaW5kKG51bGwsIG51bGwsIHNpemVzLndpZHRoKTtcclxuXHR2YXIgY3JQbGluZSA9IEFycmF5LmNyZWF0ZS5iaW5kKG51bGwsIGNyTGluZSwgc2l6ZXMud2lkdGgsIHRydWUpO1xyXG5cdHZhciBtYXAgPSBBcnJheS5jcmVhdGUoY3JQbGluZSwgc2l6ZXMubGF5ZXJzKTsqL1xyXG5cclxuXHR2YXIgU2VuZCA9IHttYXA6IFJvdXQuY29ubmVjdChJbnB1dCl9O1xyXG5cclxuXHQvKlNlbmQubWFwKHtcclxuXHRcdGFjdGlvbjogXCJDcmVhdGVcIixcclxuXHRcdHR5cGU6IFwiQmxvY2tUaWxlc1wiLFxyXG5cdFx0ZGF0YTogVGlsZXMubWFwKCh0aWxlKT0+IHtpbWFnZTogdGlsZS5pbWFnZXNbMF0sIHNpemU6IHRpbGUuc2l6ZX0pXHJcblx0fSk7Ki9cclxuXHRcclxuXHRmdW5jdGlvbiBJbnB1dChtZXNzKXtcclxuXHRcdHN3aXRjaChtZXNzLmFjdGlvbil7XHJcblx0XHRcdFxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly9sb2FkTWFwKERhdGEubWFwLmxheWVycyk7XHJcblxyXG5cdGZ1bmN0aW9uIGxvYWRNYXAobGF5ZXJzKXtcclxuXHRcdHZhciBiYWNrZ3JvdW5kID0gbGF5ZXJzWzBdO1xyXG5cclxuXHRcdGJhY2tncm91bmQuZm9yRWFjaChDckdyb3VuZEJsb2Nrcyk7XHJcblxyXG5cdFx0ZnVuY3Rpb24gQ3JHcm91bmRCbG9ja3MoYmxvY2spe1xyXG5cdFx0XHRibG9jay5pbWFnZXMgPSBUaWxlc1tibG9jay50aWxlX2lkXS5pbWFnZXM7XHJcblx0XHRcdFNlbmQubWFwKHtcclxuXHRcdFx0XHRhY3Rpb246IFwiQ3JlYXRlXCIsXHJcblx0XHRcdFx0dHlwZTogXCJCbG9ja1wiLFxyXG5cdFx0XHRcdGJsb2NrOiBibG9jayxcclxuXHRcdFx0XHRjb2xsaXM6IDBcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHJcblxyXG5cdGZ1bmN0aW9uIGZpbGxCb3godGlsZSwgY29vcmRzLCBzaXplKXtcclxuXHRcdHZhciBib3ggPSB7Y29vcmRzOiBjb29yZHMsIHNpemU6IHRpbGUuc2l6ZSwgdGlsZV9pZDogdGlsZS5pZH07XHJcblx0XHR2YXIgc2l6ZSA9IHRpbGUuc2l6ZTtcclxuXHJcblx0XHRmb3IodmFyIGkgPSBzaXplIC0gMTsgaSA+PSAwOyBpLS0pe1xyXG5cdFx0XHRmb3IodmFyIGogPSBzaXplIC0gMTsgaiA+PSAwOyBqLS0pe1xyXG5cdFx0XHRcdG1hcFtjb29yZHMuel1bY29vcmRzLnkgKyBqXVtjb29yZHMueCArIGldID0gYm94O1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGNvb3JkcztcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGNsZWFyQm94KGJveCl7XHJcblx0XHR2YXIgY29vcmRzID0gYm94LmNvb3JkcztcclxuXHRcdHZhciBzaXplID0gYm94LnNpemU7XHJcblxyXG5cdFx0Zm9yKHZhciBpID0gc2l6ZSAtIDE7IGkgPj0gMDsgaS0tKXtcclxuXHRcdFx0Zm9yKHZhciBqID0gc2l6ZSAtIDE7IGogPj0gMDsgai0tKXtcclxuXHRcdFx0XHRtYXBbY29vcmRzLnpdW2Nvb3Jkcy55ICsgal1bY29vcmRzLnggKyBpXSA9IG51bGw7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBjb29yZHM7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBpc19jb29yZHMoY29vcmRzLCBzaXplPTEpe1xyXG5cdFx0cmV0dXJuIGNvb3JkcyBcclxuXHRcdCYmIG1hcFtjb29yZHMuel0gXHJcblx0XHQmJiBtYXBbY29vcmRzLnpdW2Nvb3Jkcy55XSBcclxuXHRcdCYmIG1hcFtjb29yZHMuel1bY29vcmRzLnkgKyBzaXplIC0gMV1cclxuXHRcdCYmIG1hcFtjb29yZHMuel1bY29vcmRzLnldW2Nvb3Jkcy54XSAhPT0gdW5kZWZpbmVkXHJcblx0XHQmJiBtYXBbY29vcmRzLnpdW2Nvb3Jkcy55ICsgc2l6ZSAtIDFdW2Nvb3Jkcy54ICsgc2l6ZSAtIDFdICE9PSB1bmRlZmluZWQ7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBpc19lbXB0eShjb29yZHMsIHNpemU9MSl7XHJcblx0XHRmb3IodmFyIGkgPSBzaXplIC0gMTsgaSA+PSAwOyBpLS0pe1xyXG5cdFx0XHRmb3IodmFyIGogPSBzaXplIC0gMTsgaiA+PSAwOyBqLS0pe1xyXG5cdFx0XHRcdGlmKG1hcFtjb29yZHMuel1bY29vcmRzLnkgKyBqXVtjb29yZHMueCArIGldICE9PSBudWxsKVxyXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ3JCbG9ja3M7IiwidmFyIHR5cGVzID0gcmVxdWlyZShcIi4vVHlwZXMuanNcIik7XHJcblxyXG52YXIgYnVsbGV0c19kYXRhID0gcmVxdWlyZShcIi4vYnVsbGV0Lmpzb25cIik7XHJcblxyXG5mdW5jdGlvbiBDckJ1bGxldHMoQ29tbXVuKXtcclxuXHR2YXIgQWN0b3IgPSB7XHJcblx0XHRidWxsZXRzOiBBcnJheS5jcmVhdGUoKSxcclxuXHRcdGFkcmVzczogXCJCdWxsZXRzXCJcclxuXHR9O1xyXG5cdFxyXG5cdHZhciBPdXRwdXQgPSBDb21tdW4uY29ubmVjdChJbnB1dCk7XHJcblxyXG5cdE91dHB1dCh7XHJcblx0XHRhY3Rpb246IFwiQWRkXCIsXHJcblx0XHR0eXBlOiBcIlRpbGVzXCIsXHJcblx0XHR0aWxlX3R5cGU6IFwiQnVsbGV0XCIsXHJcblx0XHR0aWxlOiBidWxsZXRzX2RhdGEuQnVsbGV0LnRpbGUsXHJcblx0XHRzb3VyY2U6IEFjdG9yLmFkcmVzc1xyXG5cdH0pO1xyXG5cdFxyXG5cdGZ1bmN0aW9uIENyQnVsbGV0KG1lc3Mpe1x0XHJcblx0XHRcclxuXHRcdHZhciBidWxsID0ge1xyXG5cdFx0XHRzb3VyY2U6IG1lc3Muc291cmNlLFxyXG5cdFx0XHRib3g6IHt3OiAwLjMsIGg6IDAuM30sXHJcblx0XHRcdGRpcjogbWVzcy5kaXIsXHJcblx0XHRcdHNwZWVkOiAxN1xyXG5cdFx0fTtcclxuXHJcblx0XHR2YXIgYXhpcyA9ICd4JztcclxuXHRcdHZhciBhZGRfYXhpcyA9ICd3JztcclxuXHRcdHZhciBkaXIgPSAxO1xyXG5cdFx0c3dpdGNoKGJ1bGwuZGlyKXtcclxuXHRcdFx0Y2FzZSAtMC41OiBkaXIgPSAtMTtcclxuXHRcdFx0Y2FzZSAwLjU6IGF4aXMgPSBcInlcIjsgYWRkX2F4aXMgPSAnaCc7IGJyZWFrO1xyXG5cdFx0XHRjYXNlIDE6XHJcblx0XHRcdGNhc2UgLTE6IGRpciA9IC0xOyBicmVhaztcclxuXHRcdH1cclxuXHRcdFxyXG5cdFx0bWVzcy5wb3NbYXhpc10gKz0gZGlyICogYnVsbC5ib3hbYWRkX2F4aXNdO1xyXG5cdFx0XHJcblx0XHRidWxsLnBvcyA9IHt4OiArbWVzcy5wb3MueC50b0ZpeGVkKDIpLCB5OiArbWVzcy5wb3MueS50b0ZpeGVkKDIpfTtcclxuXHRcdFxyXG5cdFx0aWYodHlwZXMucG9zaXRpb24udGVzdChidWxsLnBvcykpXHJcblx0XHRcdHJldHVybjtcclxuXHJcblx0XHRidWxsLmlkID0gQWN0b3IuYnVsbGV0cy5hZGQoYnVsbCk7XHJcblx0XHRcclxuXHRcdHZhciBuZXdfbWVzcyA9IHtcclxuXHRcdFx0YWN0aW9uOiBcIkNyZWF0ZVwiLFxyXG5cdFx0XHR0eXBlOiBcIkJ1bGxldFwiLFxyXG5cdFx0XHRidWxsOiB7XHJcblx0XHRcdFx0aWQ6IGJ1bGwuaWQsXHJcblx0XHRcdFx0c291cmNlOiBBY3Rvci5hZHJlc3MsXHJcblx0XHRcdFx0c3ByaXRlOiBBY3Rvci50aWxlX2lkLFxyXG5cdFx0XHRcdGRpcjogYnVsbC5kaXIsXHJcblx0XHRcdFx0Ym94OiBPYmplY3QuYXNzaWduKHt9LCBidWxsLmJveCksXHJcblx0XHRcdFx0cG9zOiB7eDogK2J1bGwucG9zLngudG9GaXhlZCgyKSwgeTogK2J1bGwucG9zLnkudG9GaXhlZCgyKX0sXHJcblx0XHRcdFx0c3BlZWQ6IGJ1bGwuc3BlZWRcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0XHJcblx0XHRPdXRwdXQobmV3X21lc3MpO1xyXG5cdH1cclxuXHRcclxuXHRmdW5jdGlvbiBEZWxsQnVsbChtZXNzKXtcclxuXHRcdE91dHB1dCh7YWN0aW9uOiBcIkRlbGxcIiwgdHlwZTogXCJCdWxsZXRcIiwgaWQ6IG1lc3MuaWR9KTtcclxuXHRcdEFjdG9yLmJ1bGxldHMuZGVsbChtZXNzLmlkKTtcclxuXHR9XHJcblx0XHJcblx0ZnVuY3Rpb24gQ29sbGlzaW9uKG1lc3Mpe1xyXG5cdFx0dmFyIGJ1bGxldCA9IEFjdG9yLmJ1bGxldHNbbWVzcy5pZF07XHJcblx0XHREZWxsQnVsbCh7aWQ6IG1lc3MuaWR9KTtcclxuXHRcdFxyXG5cdFx0T3V0cHV0KHtcclxuXHRcdFx0YWN0aW9uOiBcIkRhbWFnZVwiLFxyXG5cdFx0XHR0eXBlOiBtZXNzLmxpc3RbMF0udHlwZSxcclxuXHRcdFx0aWQ6IG1lc3MubGlzdFswXS5pZCxcclxuXHRcdFx0YWRyOiBtZXNzLmxpc3RbMF0uc291cmNlLFxyXG5cdFx0XHRraWxsZXI6IGJ1bGxldC5zb3VyY2VcclxuXHRcdH0pO1xyXG5cdH1cclxuXHJcblxyXG5cdFxyXG5cdGZ1bmN0aW9uIElucHV0KG1lc3Mpe1xyXG5cdFx0c3dpdGNoKG1lc3MudHlwZSl7XHJcblx0XHRcdGNhc2UgXCJUaWxlc1wiOiBcclxuXHRcdFx0XHRzd2l0Y2gobWVzcy5hY3Rpb24pe1xyXG5cdFx0XHRcdFx0Y2FzZSBcIkFkZFwiOiBBY3Rvci50aWxlX2lkID0gbWVzcy50aWxlX2lkOyBicmVhaztcclxuXHRcdFx0XHR9IGJyZWFrO1xyXG5cdFx0fVxyXG5cdFx0c3dpdGNoKG1lc3MuYWN0aW9uKXtcclxuXHRcdFx0Y2FzZSBcIkZpcmVcIjogQ3JCdWxsZXQobWVzcyk7IGJyZWFrO1xyXG5cdFx0XHRjYXNlIFwiQ29sbGlzaW9uXCI6IENvbGxpc2lvbihtZXNzKTsgYnJlYWs7XHJcblx0XHRcdGNhc2UgXCJPdmVyTWFwXCI6XHJcblx0XHRcdGNhc2UgXCJEYW1hZ2VcIjogRGVsbEJ1bGwobWVzcyk7IGJyZWFrO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRcclxuXHRcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDckJ1bGxldHM7XHJcbiIsImZ1bmN0aW9uIENyR2FtZU1vZGUoUm91dGVyLCBQYXJhbSl7XHJcblx0dmFyIE91dHB1dCA9IFJvdXRlci5jb25uZWN0KElucHV0KTtcclxuXHRcclxuXHR2YXIgTGlzdF9BZHIgPSBbXTtcclxuXHRcclxuXHRcclxuXHRmdW5jdGlvbiBJbnB1dChtZXNzKXtcclxuXHRcdHN3aXRjaChtZXNzLmFjdGlvbil7XHJcblx0XHRcdGNhc2UgXCJSZWdcIjogQWRkQWRyKG1lc3MpOyBicmVhaztcclxuXHRcdFx0Y2FzZSBcIktpbGxcIjogS2lsbChtZXNzKTsgYnJlYWs7XHJcblx0XHR9XHJcblx0fVxyXG5cdFxyXG5cdGZ1bmN0aW9uIEFkZEFkcihtZXNzKXtcclxuXHRcdExpc3RfQWRyW21lc3Muc291cmNlXSA9IHtcclxuXHRcdFx0bG9naW46IG1lc3MubG9naW4sXHJcblx0XHRcdGtpbGxzOiAwLFxyXG5cdFx0XHRkZWF0aHM6IDAgXHJcblx0XHR9O1xyXG5cdH1cclxuXHRcclxuXHRmdW5jdGlvbiBLaWxsKG1lc3Mpe1xyXG5cdFx0TGlzdF9BZHJbbWVzcy5raWxsZXJdLmtpbGxzKys7XHJcblx0XHRMaXN0X0FkclttZXNzLmNhc3VhbHR5XS5kZWF0aHMrKztcclxuXHRcdE91dHB1dCh7XHJcblx0XHRcdGFjdGlvbjogXCJLaWxsXCIsXHJcblx0XHRcdHR5cGU6IFwiR2FtZXJcIixcclxuXHRcdFx0YWRyOiBtZXNzLmtpbGxlclxyXG5cdFx0fSk7XHJcblx0XHRcclxuXHRcdGlmKExpc3RfQWRyW21lc3Mua2lsbGVyXS5raWxscyA+PSBQYXJhbS5tYXhfa2lsbHMpIFdpbihtZXNzLmtpbGxlcik7XHJcblx0fVxyXG5cdFxyXG5cdGZ1bmN0aW9uIFdpbih3aW5uZXIpe1xyXG5cdFx0dmFyIHdpbl9sb2dpbiA9IExpc3RfQWRyW3dpbm5lcl0ubG9naW47XHJcblx0XHRcclxuXHRcdExpc3RfQWRyLmZvckVhY2goZnVuY3Rpb24oZ2FtZXIsIGkpe1xyXG5cdFx0XHRpZihnYW1lcil7XHJcblx0XHRcdFx0T3V0cHV0KHtcclxuXHRcdFx0XHRcdGFjdGlvbjogKGkgPT0gd2lubmVyKT8gXCJXaW5cIiA6IFwiTG9zZVwiLFxyXG5cdFx0XHRcdFx0dHlwZTogXCJHYW1lclwiLFxyXG5cdFx0XHRcdFx0d2lubmVyOiAgd2luX2xvZ2luLFxyXG5cdFx0XHRcdFx0YWRyOiBpXHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdH1cclxuXHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ3JHYW1lTW9kZTtcclxuIiwiZnVuY3Rpb24gQ3JNYXAoQ29tbXVuLCBtYXApe1xyXG5cdHZhciBUaWxlcyA9IEFycmF5LmNyZWF0ZSgpO1xyXG5cclxuXHR2YXIgTGlzdCA9IHtcclxuXHRcdEdhbWVyOiBBcnJheS5jcmVhdGUoKSxcclxuXHRcdEJ1bGxldDogQXJyYXkuY3JlYXRlKCksXHJcblx0XHRCbG9jazogQXJyYXkuY3JlYXRlKClcclxuXHR9O1xyXG5cclxuXHRDck1vdmluZ0xvb3AoTGlzdC5HYW1lciwgTW92ZSk7XHJcblx0Q3JNb3ZpbmdMb29wKExpc3QuQnVsbGV0LCBNb3ZlQnVsbGV0KTtcclxuXHRcclxuXHR2YXIgT3V0cHV0ID0gQ29tbXVuLmNvbm5lY3QoSW5wdXQpO1xyXG5cdFxyXG5cdGZ1bmN0aW9uIElucHV0KG1lc3Mpe1xyXG5cdFx0aWYobWVzcy5hY3Rpb24gPT0gJ0Nvbm5lY3QnKSByZXR1cm47XHJcblxyXG5cdFx0c3dpdGNoKG1lc3MudHlwZSl7XHJcblx0XHRcdGNhc2UgXCJUaWxlc1wiOlxyXG5cdFx0XHRcdHN3aXRjaChtZXNzLmFjdGlvbil7XHJcblx0XHRcdFx0XHRjYXNlIFwiQ3JlYXRlXCI6IExvYWRUaWxlcyhtZXNzKTsgYnJlYWs7XHJcblx0XHRcdFx0XHRjYXNlIFwiQWRkXCI6IEFkZFRpbGUobWVzcyk7IGJyZWFrO1xyXG5cdFx0XHRcdH0gXHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdGNhc2UgXCJNYXBcIjpcclxuXHRcdFx0XHRzd2l0Y2gobWVzcy5hY3Rpb24pe1xyXG5cdFx0XHRcdFx0Y2FzZSBcIkNyZWF0ZVwiOiBsb2FkTWFwKG1lc3MpOyBicmVhaztcclxuXHRcdFx0XHR9IFxyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRjYXNlIFwiQnVsbGV0XCI6IFxyXG5cdFx0XHRcdHN3aXRjaChtZXNzLmFjdGlvbil7XHJcblx0XHRcdFx0XHRjYXNlIFwiQ3JlYXRlXCI6IENyQnVsbGV0KG1lc3MpOyBicmVhaztcclxuXHRcdFx0XHR9IFxyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRjYXNlIFwiR2FtZXJcIjogXHJcblx0XHRcdFx0c3dpdGNoKG1lc3MuYWN0aW9uKXtcclxuXHRcdFx0XHRcdGNhc2UgXCJDcmVhdGVcIjogQ3JPYmoobWVzcyk7IGJyZWFrO1xyXG5cdFx0XHRcdFx0Y2FzZSBcIk1vdmVcIjogTW92ZUVsZW0obWVzcyk7IGJyZWFrO1xyXG5cdFx0XHRcdH0gXHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdGRlZmF1bHQ6IGNvbnNvbGUubG9nKFwiVW5rbm93biBtZXNzYWdlOiBcIiwgbWVzcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0c3dpdGNoKG1lc3MuYWN0aW9uKXtcclxuXHRcdFx0Y2FzZSBcIkRlbGxcIjogRGVsbE9iaihtZXNzKTsgYnJlYWs7XHJcblx0XHR9XHJcblx0fVxyXG5cdFxyXG5cdFxyXG5cdFxyXG5cdFxyXG5cclxuLy89PT09PT09PT09PT09PVRJTEVTPT09PT09PT09PT09PT09PT1cclxuXHRmdW5jdGlvbiBBZGRUaWxlKG1lc3Mpe1xyXG5cdFx0dmFyIHRpbGUgPSBtZXNzLnRpbGU7XHJcblx0XHR2YXIgaWQgPSBUaWxlcy5hZGQodGlsZSk7XHJcblx0XHR0aWxlLmlkID0gaWQ7XHJcblxyXG5cdFx0T3V0cHV0KHtcclxuXHRcdFx0YWN0aW9uOiBcIkFkZFwiLFxyXG5cdFx0XHR0eXBlOiBcIlRpbGVzXCIsXHJcblx0XHRcdHRpbGVfdHlwZTogbWVzcy50aWxlX3R5cGUsXHJcblx0XHRcdHRpbGVfaWQ6IHRpbGUuaWQsXHJcblx0XHRcdGFkcjogbWVzcy5zb3VyY2VcclxuXHRcdH0pO1xyXG5cclxuXHRcdHNlbmRBbGxHYW1lcnMoe1xyXG5cdFx0XHRhY3Rpb246IFwiQWRkXCIsXHJcblx0XHRcdHR5cGU6IFwiVGlsZXNcIixcclxuXHRcdFx0dGlsZTogdGlsZVxyXG5cdFx0fSk7XHJcblx0fVxyXG5cdFxyXG5cdGZ1bmN0aW9uIExvYWRUaWxlcyhtZXNzKXtcclxuXHJcblx0XHRPdXRwdXQoe1xyXG5cdFx0XHRhY3Rpb246IFwiQ3JlYXRlXCIsXHJcblx0XHRcdHR5cGU6IFwiVGlsZXNcIixcclxuXHRcdFx0dGlsZXM6IFRpbGVzLmNvbmNhdCgpLFxyXG5cdFx0XHRhZHI6IG1lc3Muc291cmNlXHJcblx0XHR9KTtcclxuXHR9XHJcblxyXG4vLz09PT09PT09PT09PT09R0FNRVJTPT09PT09PT09PT09PT09PVxyXG5cdFxyXG5cdGZ1bmN0aW9uIHNlbmRBbGxHYW1lcnMobmV3X21lc3Mpe1xyXG5cdFx0bmV3X21lc3MuYWRyID0gXCJQbGF5ZXJzTWFuYWdlclwiO1xyXG5cdFx0T3V0cHV0KG5ld19tZXNzKTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIENyT2JqKG1lc3Mpe1xyXG5cdFx0XHJcblx0XHR2YXIgb2JqID0ge1xyXG5cdFx0XHR0eXBlOiBtZXNzLnR5cGUsXHJcblx0XHRcdHNvdXJjZTogbWVzcy5zb3VyY2UsXHJcblx0XHRcdHNwcml0ZTogbWVzcy5zcHJpdGUsXHJcblx0XHRcdGJveDogbWVzcy5ib3hcclxuXHRcdH07XHJcblxyXG5cdFx0aWYobWVzcy5zcGVlZCl7XHJcblx0XHRcdG9iai5zcGVlZCA9IG1lc3Muc3BlZWQ7XHJcblx0XHRcdG9iai5kYXRlID0gRGF0ZS5ub3coKTtcclxuXHRcdH1cclxuXHJcblxyXG5cdFx0aWYoIUxpc3RbbWVzcy50eXBlXSkgTGlzdFttZXNzLnR5cGVdID0gQXJyYXkuY3JlYXRlKCk7XHJcblx0XHR2YXIgaWQgPSBMaXN0W21lc3MudHlwZV0uYWRkKG9iaik7XHJcblx0XHRvYmouaWQgPSBpZDtcclxuXHRcdFxyXG5cdFx0dmFyIG5ld19tZXNzID0ge1xyXG5cdFx0XHRhY3Rpb246IFwiQ3JlYXRlXCIsXHJcblx0XHRcdHR5cGU6IFwiQWN0b3JcIixcclxuXHRcdFx0YWN0b3JfdHlwZTogbWVzcy50eXBlLFxyXG5cdFx0XHRpZDogb2JqLmlkLFxyXG5cdFx0XHRzcHJpdGU6IG9iai5zcHJpdGUsXHJcblx0XHRcdGJveDogbWVzcy5ib3gsXHJcblx0XHR9O1xyXG5cdFx0XHJcblx0XHRpZihtZXNzLnR5cGUgPT0gXCJHYW1lclwiKXtcclxuXHRcdFx0bmV3X21lc3MgPSBDckdhbWVyKG5ld19tZXNzLCBvYmopO1xyXG5cdFx0fVxyXG5cdFx0XHJcblx0XHRzZW5kQWxsR2FtZXJzKG5ld19tZXNzKTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIERlbGxPYmoobWVzcyl7XHJcblxyXG5cdFx0dmFyIG5ld19tZXNzID0ge1xyXG5cdFx0XHRhY3Rpb246IFwiRGVsbFwiLFxyXG5cdFx0XHR0eXBlOiBcIkFjdG9yXCIsIFxyXG5cdFx0XHRhY3Rvcl90eXBlOiBtZXNzLnR5cGUsIFxyXG5cdFx0XHRpZDogbWVzcy5pZFxyXG5cdFx0fVxyXG5cdFx0XHJcblx0XHRzZW5kQWxsR2FtZXJzKG5ld19tZXNzKTtcclxuXHJcblx0XHRpZihtZXNzLnR5cGUgPT0gXCJHYW1lclwiKSBEZWxsR2FtZXIobWVzcyk7XHJcblx0XHRMaXN0W21lc3MudHlwZV0uZGVsbChtZXNzLmlkKTtcclxuXHR9XHJcblx0XHJcblx0ZnVuY3Rpb24gQ3JHYW1lcihtZXNzLCBnYW1lcil7XHJcblx0XHRcclxuXHRcdHZhciByZXNwID0gbWFwLnJlc3BbZ2FtZXIuaWRdWzBdO1xyXG5cdFx0XHJcblx0XHRnYW1lci5wb3MgPSB7eDogK3Jlc3AueC50b0ZpeGVkKDIpLCB5OiArcmVzcC55LnRvRml4ZWQoMil9O1xyXG5cdFx0Z2FtZXIuZGlyID0gMDsgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09UmVzcFxyXG5cdFx0XHJcblx0XHRcclxuXHRcdG1lc3MucG9zID0gZ2FtZXIucG9zO1xyXG5cdFx0bWVzcy5kaXIgPSBnYW1lci5kaXI7XHJcblx0XHRtZXNzLnNwcml0ZSA9IGdhbWVyLnNwcml0ZTtcclxuXHRcdG1lc3Muc291cmNlID0gZ2FtZXIuc291cmNlO1xyXG5cclxuXHRcdFNlbmRHYW1lcihtZXNzKTtcclxuXHRcdFxyXG5cdFx0cmV0dXJuIG1lc3M7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBTZW5kR2FtZXIobWVzcyl7XHJcblx0XHR2YXIgbmV3X21lc3MgPSBPYmplY3QuYXNzaWduKHt9LCBtZXNzKTtcclxuXHRcdG5ld19tZXNzLnR5cGUgPSBcIkdhbWVyXCI7XHJcblx0XHRuZXdfbWVzcy5hZHIgPSBuZXdfbWVzcy5zb3VyY2U7XHJcblx0XHRPdXRwdXQobmV3X21lc3MpO1xyXG5cdH1cclxuXHRcclxuXHRmdW5jdGlvbiBEZWxsR2FtZXIobWVzcyl7XHJcblxyXG5cdH1cclxuXHRcclxuXHRmdW5jdGlvbiBsb2FkTWFwKG1lc3Mpe1xyXG5cdFx0dmFyIEdhbWVycyA9IExpc3RbXCJHYW1lclwiXS5jb25jYXQoKTtcclxuXHRcdHZhciBCbG9ja3MgPSBMaXN0W1wiQmxvY2tcIl0uY29uY2F0KCk7XHJcblx0XHRcclxuXHRcdE91dHB1dCh7XHJcblx0XHRcdGFjdGlvbjogXCJDcmVhdGVcIiwgXHJcblx0XHRcdHR5cGU6IFwiTWFwXCIsIFxyXG5cdFx0XHRzaXplOiBtYXAuc2l6ZSwgXHJcblx0XHRcdGFkcjogbWVzcy5zb3VyY2VcclxuXHRcdH0pO1xyXG5cclxuXHRcdGxvYWRCbG9ja3MoQmxvY2tzLCBtZXNzLnNvdXJjZSk7XHJcblxyXG5cdFx0bG9hZEdhbWVycyhHYW1lcnMsIG1lc3Muc291cmNlKTtcclxuXHR9XHJcblx0XHJcblx0ZnVuY3Rpb24gbG9hZEdhbWVycyhPYmpzLCBhZHIpe1xyXG5cdFx0T2Jqcy5mb3JFYWNoKGZ1bmN0aW9uKG9iail7XHJcblx0XHRcdGlmKG9iaikgT3V0cHV0KHtcclxuXHRcdFx0XHRhY3Rpb246IFwiQ3JlYXRlXCIsXHJcblx0XHRcdFx0dHlwZTogXCJBY3RvclwiLFxyXG5cdFx0XHRcdGFjdG9yX3R5cGU6IG9iai50eXBlLFxyXG5cdFx0XHRcdGlkOiBvYmouaWQsXHJcblx0XHRcdFx0Ym94OiBvYmouYm94LFxyXG5cdFx0XHRcdHBvczoge3g6ICtvYmoucG9zLngudG9GaXhlZCgyKSwgeTogK29iai5wb3MueS50b0ZpeGVkKDIpfSxcclxuXHRcdFx0XHRkaXI6IG9iai5kaXIsXHJcblx0XHRcdFx0c3ByaXRlOiBvYmouc3ByaXRlLFxyXG5cdFx0XHRcdGFkcjogYWRyXHJcblx0XHRcdH0pO1xyXG5cdFx0fSk7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBsb2FkQmxvY2tzKEJsb2NrcywgYWRyKXtcclxuXHRcdEJsb2Nrcy5mb3JFYWNoKGZ1bmN0aW9uKG9iail7XHJcblx0XHRcdGlmKG9iaikgT3V0cHV0KHtcclxuXHRcdFx0XHRhY3Rpb246IFwiQ3JlYXRlXCIsXHJcblx0XHRcdFx0dHlwZTogb2JqLnR5cGUsXHJcblx0XHRcdFx0aWQ6IG9iai5pZCxcclxuXHRcdFx0XHRib3g6IG9iai5ib3gsXHJcblx0XHRcdFx0cG9zOiB7eDogK29iai5wb3MueC50b0ZpeGVkKDIpLCB5OiArb2JqLnBvcy55LnRvRml4ZWQoMil9LFxyXG5cdFx0XHRcdGRpcjogb2JqLmRpcixcclxuXHRcdFx0XHRzcHJpdGU6IG9iai5zcHJpdGUsXHJcblx0XHRcdFx0YWRyOiBhZHJcclxuXHRcdFx0fSk7XHJcblx0XHR9KTtcclxuXHR9XHJcblx0XHJcblxyXG5cdGZ1bmN0aW9uIE1vdmVFbGVtKG1lc3Mpe1xyXG5cdFx0XHJcblx0XHRpZihtZXNzLnR5cGUgPT0gXCJCdWxsZXRcIil7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcigpO1xyXG5cdFx0fVxyXG5cdFx0XHJcblx0XHR2YXIgb2JqID0gTGlzdFttZXNzLnR5cGVdW21lc3MuaWRdO1xyXG5cdFx0XHJcblx0XHRvYmouZGlyID0gbWVzcy5kaXI7XHJcblx0XHRvYmouc3BlZWQgPSBtZXNzLnNwZWVkO1xyXG5cdFx0XHJcblx0XHR2YXIgbmV3X21lc3MgPSB7XHJcblx0XHRcdGFjdGlvbjogXCJVcGRhdGVcIixcclxuXHRcdFx0dHlwZTogXCJBY3RvclwiLFxyXG5cdFx0XHRhY3Rvcl90eXBlOiBvYmoudHlwZSxcclxuXHRcdFx0aWQ6IG9iai5pZCxcclxuXHRcdFx0cG9zOiB7eDogK29iai5wb3MueC50b0ZpeGVkKDIpLCB5OiArb2JqLnBvcy55LnRvRml4ZWQoMil9LFxyXG5cdFx0XHRkaXI6IG9iai5kaXIsXHJcblx0XHRcdHNvdXJjZTogb2JqLnNvdXJjZVxyXG5cdFx0fTtcclxuXHRcdFxyXG5cdFx0aWYob2JqLnR5cGUgPT0gXCJHYW1lclwiKVxyXG5cdFx0XHRTZW5kR2FtZXIobmV3X21lc3MpO1xyXG5cdFx0XHJcblx0XHRzZW5kQWxsR2FtZXJzKG5ld19tZXNzKTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIE1vdmUob2JqKXtcclxuXHRcdGlmKG9iai5zcGVlZCl7XHJcblxyXG5cdFx0XHR2YXIgYXhpcyA9ICd4JztcclxuXHRcdFx0dmFyIGRpciA9IDE7XHJcblx0XHRcdHN3aXRjaChvYmouZGlyKXtcclxuXHRcdFx0XHRjYXNlIC0wLjU6IGRpciA9IC0xO1xyXG5cdFx0XHRcdGNhc2UgMC41OiBheGlzID0gXCJ5XCI7IGJyZWFrO1xyXG5cdFx0XHRcdGNhc2UgMTpcclxuXHRcdFx0XHRjYXNlIC0xOiBkaXIgPSAtMTsgYnJlYWs7XHJcblx0XHRcdH1cclxuXHRcdFx0XHJcblx0XHRcdFxyXG5cdFx0XHR2YXIgbmV3X3BvcyA9IHt4OiBvYmoucG9zLngsIHk6IG9iai5wb3MueX07XHJcblx0XHRcdHZhciBuZXdfZGF0ZSA9IERhdGUubm93KCk7XHJcblxyXG5cdFx0XHRuZXdfcG9zW2F4aXNdICs9IGRpciAqIG9iai5zcGVlZCAqIChuZXdfZGF0ZSAtIG9iai5kYXRlKSAqIDAuMDAwNTtcclxuXHRcdFx0XHJcblx0XHRcdFxyXG5cdFx0XHRpZihpc01vdmUob2JqLCBuZXdfcG9zKSl7XHJcblx0XHRcdFx0b2JqLnBvcyA9IG5ld19wb3M7XHJcblx0XHRcdFx0XHJcblx0XHRcdFx0dmFyIG5ld19tZXNzID0ge1xyXG5cdFx0XHRcdFx0YWN0aW9uOiBcIlVwZGF0ZVwiLFxyXG5cdFx0XHRcdFx0dHlwZTogXCJBY3RvclwiLFxyXG5cdFx0XHRcdFx0YWN0b3JfdHlwZTogb2JqLnR5cGUsXHJcblx0XHRcdFx0XHRpZDogb2JqLmlkLFxyXG5cdFx0XHRcdFx0cG9zOiB7eDogK29iai5wb3MueC50b0ZpeGVkKDIpLCB5OiArb2JqLnBvcy55LnRvRml4ZWQoMil9LFxyXG5cdFx0XHRcdFx0ZGlyOiBvYmouZGlyXHJcblx0XHRcdFx0fTtcclxuXHJcblx0XHRcdFx0aWYob2JqLnR5cGUgPT0gXCJHYW1lclwiKVxyXG5cdFx0XHRcdFx0U2VuZEdhbWVyKG5ld19tZXNzKTtcclxuXHRcdFx0XHRcclxuXHRcdFx0XHRzZW5kQWxsR2FtZXJzKG5ld19tZXNzKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0b2JqLmRhdGUgPSBEYXRlLm5vdygpO1xyXG5cdH1cclxuXHRcclxuXHRmdW5jdGlvbiBpc01vdmUob2JqLCBuZXdfcG9zKXtcclxuXHRcdFxyXG5cdFx0cmV0dXJuIGlzSW50b01hcChvYmosIG5ld19wb3MpXHJcblx0XHQmJiAhTGlzdFtcIkdhbWVyXCJdLnNvbWUoZnVuY3Rpb24od2FsbCwgaWQpe1xyXG5cdFx0XHRpZih3YWxsICYmICh3YWxsLnR5cGUgIT09IG9iai50eXBlIHx8IHdhbGwuaWQgIT09IG9iai5pZCkpIHJldHVybiBpc0NvbGxpcyhvYmosIG5ld19wb3MsIHdhbGwpO1xyXG5cdFx0fSk7XHJcblx0fVxyXG5cdFxyXG4vLz09PT09PT09PT09PT09PUJ1bGxldHM9PT09PT09PT09PT09PT09XHJcblx0XHJcblx0ZnVuY3Rpb24gQ3JCdWxsZXQobWVzcyl7XHJcblx0XHRpZighTGlzdFtcIkJ1bGxldFwiXSkgTGlzdFtcIkJ1bGxldFwiXSA9IEFycmF5LmNyZWF0ZSgpO1xyXG5cdFx0dmFyIGJ1bGwgPSBtZXNzLmJ1bGw7XHJcblx0XHRidWxsLmRhdGUgPSBEYXRlLm5vdygpO1xyXG5cdFx0TGlzdFtcIkJ1bGxldFwiXVtidWxsLmlkXSA9IGJ1bGw7XHJcblxyXG5cdFx0dmFyIG5ld19tZXNzID0ge1xyXG5cdFx0XHRhY3Rpb246IFwiQ3JlYXRlXCIsXHJcblx0XHRcdHR5cGU6IFwiQWN0b3JcIixcclxuXHRcdFx0YWN0b3JfdHlwZTogXCJCdWxsZXRcIixcclxuXHRcdFx0aWQ6IGJ1bGwuaWQsXHJcblx0XHRcdHNwcml0ZTogYnVsbC5zcHJpdGUsXHJcblx0XHRcdGJveDoge3c6IGJ1bGwuYm94LncsIGg6IGJ1bGwuYm94Lmh9LFxyXG5cdFx0XHRwb3M6IHt4OiArYnVsbC5wb3MueC50b0ZpeGVkKDIpLCB5OiArYnVsbC5wb3MueS50b0ZpeGVkKDIpfSxcclxuXHRcdFx0ZGlyOiBidWxsLmRpclxyXG5cdFx0fTtcclxuXHJcblx0XHRzZW5kQWxsR2FtZXJzKG5ld19tZXNzKTtcclxuXHR9XHJcblx0XHJcblx0ZnVuY3Rpb24gTW92ZUJ1bGxldChidWxsKXtcclxuXHJcblx0XHR2YXIgYXhpcyA9ICd4JztcclxuXHRcdHZhciBkaXIgPSAxO1xyXG5cdFx0c3dpdGNoKGJ1bGwuZGlyKXtcclxuXHRcdFx0Y2FzZSAtMC41OiBkaXIgPSAtMTtcclxuXHRcdFx0Y2FzZSAwLjU6IGF4aXMgPSBcInlcIjsgYnJlYWs7XHJcblx0XHRcdGNhc2UgMTpcclxuXHRcdFx0Y2FzZSAtMTogZGlyID0gLTE7IGJyZWFrO1xyXG5cdFx0fVxyXG5cdFx0XHJcblxyXG5cdFx0YnVsbC5wb3NbYXhpc10gKz0gZGlyICogYnVsbC5zcGVlZCAqIChEYXRlLm5vdygpIC0gYnVsbC5kYXRlKSAqIDAuMDAwNTtcclxuXHJcblx0XHRpZighY29sbGlzQnVsbGV0KGJ1bGwsIGJ1bGwucG9zKSlcclxuXHRcdFx0c2VuZEFsbEdhbWVycyh7XHJcblx0XHRcdFx0YWN0aW9uOiBcIlVwZGF0ZVwiLFxyXG5cdFx0XHRcdHR5cGU6IFwiQWN0b3JcIixcclxuXHRcdFx0XHRhY3Rvcl90eXBlOiBcIkJ1bGxldFwiLFxyXG5cdFx0XHRcdGlkOiBidWxsLmlkLFxyXG5cdFx0XHRcdGJveDoge3c6IGJ1bGwuYm94LncsIGg6IGJ1bGwuYm94Lmh9LFxyXG5cdFx0XHRcdHBvczoge3g6ICtidWxsLnBvcy54LnRvRml4ZWQoMiksIHk6ICtidWxsLnBvcy55LnRvRml4ZWQoMil9LFxyXG5cdFx0XHRcdGRpcjogYnVsbC5kaXJcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0YnVsbC5kYXRlID0gRGF0ZS5ub3coKTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGNvbGxpc0J1bGxldChidWxsLCBuZXdfcG9zKXtcclxuXHRcdFxyXG5cdFx0aWYoaXNJbnRvTWFwKGJ1bGwsIG5ld19wb3MpKXtcclxuXHRcdFx0XHJcblx0XHRcdHZhciBvYmpzID0gY29sbGlzQnVsbGV0T2JzdChidWxsLCBcIkdhbWVyXCIpO1xyXG5cdFx0XHR2YXIgYnVsbHMgPSBjb2xsaXNCdWxsZXRPYnN0KGJ1bGwsIFwiQnVsbGV0XCIpO1xyXG5cdFx0XHRpZihvYmpzLmxlbmd0aCB8fCBidWxscy5sZW5ndGgpe1xyXG5cclxuXHRcdFx0XHR2YXIgbGlzdCA9IG9ianM7XHJcblx0XHRcdFx0aWYoIW9ianMubGVuZ3RoKVxyXG5cdFx0XHRcdFx0bGlzdCA9IGJ1bGxzO1xyXG5cclxuXHRcdFx0XHRPdXRwdXQoe1xyXG5cdFx0XHRcdFx0YWN0aW9uOiBcIkNvbGxpc2lvblwiLFxyXG5cdFx0XHRcdFx0aWQ6IGJ1bGwuaWQsXHJcblx0XHRcdFx0XHRsaXN0OiBsaXN0LFxyXG5cdFx0XHRcdFx0YWRyOiBidWxsLnNvdXJjZVxyXG5cdFx0XHRcdH0pO1xyXG5cclxuXHRcdFx0XHRMaXN0W1wiQnVsbGV0XCJdLmRlbGwoYnVsbC5pZCk7XHJcblx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fWVsc2V7XHJcblx0XHRcdE91dHB1dCh7XHJcblx0XHRcdFx0YWN0aW9uOiBcIk92ZXJNYXBcIixcclxuXHRcdFx0XHRpZDogYnVsbC5pZCxcclxuXHRcdFx0XHRhZHI6IGJ1bGwuc291cmNlXHJcblx0XHRcdH0pO1xyXG5cdFx0XHRMaXN0W1wiQnVsbGV0XCJdLmRlbGwoYnVsbC5pZCk7XHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRcclxuXHRmdW5jdGlvbiBjb2xsaXNCdWxsZXRPYnN0KGJ1bGxldCwgb2JzdF90eXBlKXtcclxuXHRcdHJldHVybiBMaXN0W29ic3RfdHlwZV0uZmlsdGVyKGZ1bmN0aW9uKG9ic3Qpe1xyXG5cdFx0XHQgaWYob2JzdCAmJiAhKG9ic3QuaWQgPT0gYnVsbGV0LmlkICYmIG9ic3RfdHlwZSA9PSBcIkJ1bGxldFwiKSkgXHJcblx0XHRcdCBcdHJldHVybiBpc0NvbGxpcyhidWxsZXQsIGJ1bGxldC5wb3MsIG9ic3QpO1xyXG5cdFx0fSkubWFwKGZ1bmN0aW9uKG9iail7XHJcblx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0aWQ6IG9iai5pZCwgXHJcblx0XHRcdFx0dHlwZTogb2JzdF90eXBlLCBcclxuXHRcdFx0XHRzb3VyY2U6IG9iai5zb3VyY2UsIFxyXG5cdFx0XHRcdHBvczogT2JqZWN0LmFzc2lnbih7fSwgb2JqLnBvcylcclxuXHRcdFx0fTtcclxuXHRcdH0pO1xyXG5cdH1cclxuXHJcbi8vPT09PT09PT09PT09PT09QmxvY2tzPT09PT09PT09PT09PT09PT09XHJcblxyXG5cdGZ1bmN0aW9uIENyQmxvY2sobWVzcyl7XHJcblx0XHR2YXIgYmxvY2sgPSBtZXNzLmJsb2NrO1xyXG5cdFx0dmFyIG9iaiA9IHtcclxuXHRcdFx0dHlwZTogbWVzcy50eXBlLFxyXG5cdFx0XHRwb3M6IHt4OiBibG9jay5jb29yZHMueCwgeTogYmxvY2suY29vcmRzLnl9LFxyXG5cdFx0XHRib3g6IHt3OiBibG9jay5jb29yZHMueCArIGJsb2NrLnNpemUsIGg6IGJsb2NrLmNvb3Jkcy54ICsgYmxvY2suc2l6ZX0sXHJcblx0XHRcdGRpcjogYmxvY2sucm90YXRlLFxyXG5cdFx0XHRzcHJpdGU6IGJsb2NrLmltYWdlc1swXSxcclxuXHRcdH07XHJcblxyXG5cdFx0b2JqLmlkID0gTGlzdC5CbG9jay5hZGQob2JqKTtcclxuXHJcblx0fVxyXG5cdFxyXG4vLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblx0XHJcblx0ZnVuY3Rpb24gaXNJbnRvTWFwKG9iaiwgbmV3X3Bvcyl7XHJcblx0XHR2YXIgdyA9ICd3JztcclxuXHRcdHZhciBoID0gJ2gnO1xyXG5cdFx0XHJcblx0XHRpZihvYmouZGlyICUgMil7XHJcblx0XHRcdHcgPSAnaCc7XHJcblx0XHRcdGggPSAndyc7XHJcblx0XHR9XHJcblx0XHRcclxuXHRcdHJldHVybiAobmV3X3Bvcy54IC0gb2JqLmJveFt3XSkgPiAwIFxyXG5cdFx0JiYgKG5ld19wb3MueCArIG9iai5ib3hbd10pIDwgbWFwLnNpemVcclxuXHRcdCYmIChuZXdfcG9zLnkgLSBvYmouYm94W2hdKSA+IDAgXHJcblx0XHQmJiAobmV3X3Bvcy55ICsgb2JqLmJveFtoXSkgPCBtYXAuc2l6ZTtcclxuXHR9XHJcblx0XHJcblx0ZnVuY3Rpb24gaXNDb2xsaXMob2JqLCBuZXdfcG9zLCB3YWxsKXtcclxuXHRcdHZhciBvX3cgPSAndyc7XHJcblx0XHR2YXIgb19oID0gJ2gnO1xyXG5cdFx0dmFyIHdfdyA9ICd3JztcclxuXHRcdHZhciB3X2ggPSAnaCc7XHJcblx0XHRcclxuXHRcdGlmKG9iai5kaXIgJSAyKXtcclxuXHRcdFx0b193ID0gJ2gnO1xyXG5cdFx0XHRvX2ggPSAndyc7XHJcblx0XHR9XHJcblx0XHRcclxuXHRcdGlmKHdhbGwuZGlyICUgMil7XHJcblx0XHRcdHdfdyA9ICdoJztcclxuXHRcdFx0d19oID0gJ3cnO1xyXG5cdFx0fVxyXG5cdFx0XHJcblx0XHRpZigobmV3X3Bvcy54IC0gb2JqLmJveFtvX3ddKSA+ICh3YWxsLnBvcy54ICsgd2FsbC5ib3hbd193XSkpIHJldHVybiBmYWxzZTtcclxuXHRcdGlmKChuZXdfcG9zLnggKyBvYmouYm94W29fd10pIDwgKHdhbGwucG9zLnggLSB3YWxsLmJveFt3X3ddKSkgcmV0dXJuIGZhbHNlO1xyXG5cdFx0XHJcblx0XHRpZigobmV3X3Bvcy55IC0gb2JqLmJveFtvX2hdKSA+ICh3YWxsLnBvcy55ICsgd2FsbC5ib3hbd19oXSkpIHJldHVybiBmYWxzZTtcclxuXHRcdGlmKChuZXdfcG9zLnkgKyBvYmouYm94W29faF0pIDwgKHdhbGwucG9zLnkgLSB3YWxsLmJveFt3X2hdKSkgcmV0dXJuIGZhbHNlO1xyXG5cdFx0XHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ3JNYXA7XHJcblxyXG5mdW5jdGlvbiBDck1vdmluZ0xvb3AoT2JqZWN0cywgTW92ZSl7XHJcblx0c2V0SW50ZXJ2YWwoT2JqZWN0cy5mb3JFYWNoLmJpbmQoT2JqZWN0cywgZnVuY3Rpb24ob2JqKXtcclxuXHRcdGlmKG9iaikgTW92ZShvYmopO1xyXG5cdH0pLCA0MCk7XHJcbn1cclxuIiwiXHJcbnZhciBUID0gcmVxdWlyZShcInR5cGVzanNcIik7XHJcblxyXG52YXIgbWFwX3NpemUgPSAyNTtcclxuZXhwb3J0cy5tYXBfc2l6ZSA9IG1hcF9zaXplO1xyXG5leHBvcnRzLm9ial9pZCA9IFQuSW5kZXguRGVmKG1hcF9zaXplKm1hcF9zaXplKjIpO1xyXG5cclxuZXhwb3J0cy5ib3ggPSBULk9iamVjdC5EZWYoe1xyXG5cdHc6IFQuTnVtYmVyLkRlZihtYXBfc2l6ZSwgMCwgMiksIFxyXG5cdGg6IFQuTnVtYmVyLkRlZihtYXBfc2l6ZSwgMCwgMilcclxufSk7XHJcblxyXG5leHBvcnRzLnBvc2l0aW9uID0gVC5PYmplY3QuRGVmKHtcclxuXHR4OiBULk51bWJlci5EZWYobWFwX3NpemUsIDAsIDIpLCBcclxuXHR5OiBULk51bWJlci5EZWYobWFwX3NpemUsIDAsIDIpXHJcbn0pO1xyXG5cclxuZXhwb3J0cy5kaXJlY3Rpb24gPSBULk51bWJlci5EZWYoMSwgLTEsIDEpO1xyXG5cclxuZXhwb3J0cy5wYXRoID0gVC5BcnJheS5EZWYoVC5TdHJpbmcuRGVmKCdcXFxcd1xcXFxkXy4nLCAyNTYpLCAyNTYpO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbnJlcXVpcmUoXCIuLi9saWIvbW9mLmpzXCIpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDckNsaWVudDtcclxuXHJcbmZ1bmN0aW9uIENyQ2xpZW50KENvbW11bil7XHJcblx0dmFyIGJ1bF9hZHIgPSBcIkJ1bGxldHNcIjtcclxuXHR2YXIgZ2FtZV9tb2RfYWRyID0gXCJHYW1lTW9kZVwiO1xyXG5cdHZhciBtYW5hZ2VyX2FkciA9IFwiUGxheWVyc01hbmFnZXJcIjtcclxuXHJcblx0dmFyIEdhbWVyRGF0YSA9IG51bGw7XHJcblxyXG5cdHZhciBJc1JlYWR5VGlsZXMgPSBmYWxzZTtcclxuXHR2YXIgSXNNYXAgPSBmYWxzZTtcclxuXHR2YXIgSXNQbGF5ID0gZmFsc2U7IFxyXG5cdFxyXG5cdFxyXG5cdHZhciBTZW5kID0ge1xyXG5cdFx0Y2xpZW50OiBudWxsLFxyXG5cdFx0ZGVmOiBDb21tdW4uY29ubmVjdChJbnB1dCksXHJcblx0XHRtYXA6IGZ1bmN0aW9uKG1lc3Mpe1xyXG5cdFx0XHR0aGlzLmRlZihtZXNzKTtcclxuXHRcdH0sXHJcblx0XHRidWxsZXQ6IGZ1bmN0aW9uKG1lc3Mpe1xyXG5cdFx0XHRtZXNzLmFkciA9IGJ1bF9hZHI7XHJcblx0XHRcdHRoaXMuZGVmKG1lc3MpO1xyXG5cdFx0fSxcclxuXHRcdG1vZGU6IGZ1bmN0aW9uKG1lc3Mpe1xyXG5cdFx0XHRtZXNzLmFkciA9IGdhbWVfbW9kX2FkcjtcclxuXHRcdFx0dGhpcy5kZWYobWVzcyk7XHJcblx0XHR9LFxyXG5cdFx0bWFuYWdlcjogZnVuY3Rpb24obWVzcyl7XHJcblx0XHRcdG1lc3MuYWRyID0gbWFuYWdlcl9hZHI7XHJcblx0XHRcdHRoaXMuZGVmKG1lc3MpO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cclxuXHR2YXIgR2FtZXIgPSBuZXcgQ3JHYW1lcihTZW5kLCBEZWF0aCk7XHJcblx0XHJcblx0dGhpcy5JbnB1dCA9IElucHV0O1xyXG5cdHRoaXMuQ29ubmVjdCA9IGZ1bmN0aW9uKENsaWVudCl7XHJcblx0XHRTZW5kLmNsaWVudCA9IENsaWVudC5jb25uZWN0KElucHV0Q2xpZW50KTtcclxuXHRcdFxyXG5cdFx0R2FtZXJEYXRhID0gQ2xpZW50LmRhdGE7XHJcblxyXG5cdFx0R2FtZXIubG9naW4gPSBDbGllbnQubG9naW47XHJcblx0XHRTZW5kLmNsaWVudCh7XHJcblx0XHRcdGFjdGlvbjogXCJVcGRhdGVcIiwgXHJcblx0XHRcdHR5cGU6IFwiR1VJXCIsIFxyXG5cdFx0XHRkYXRhOiB7XHJcblx0XHRcdFx0U3RhdHVzOiBcIldhdGNoIG90aGVyIGdhbWVyc1wiLCBcclxuXHRcdFx0XHRsb2dpbjogR2FtZXIubG9naW5cclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0U2VuZC5tYXAoe1xyXG5cdFx0XHRhY3Rpb246IFwiUmVnXCIsIFxyXG5cdFx0XHRsb2dpbjogR2FtZXIubG9naW4sIFxyXG5cdFx0XHRzb3VyY2U6IEdhbWVyLmFkcmVzcywgXHJcblx0XHRcdGFkcjogZ2FtZV9tb2RfYWRyXHJcblx0XHR9KTtcclxuXHJcblx0XHRTZW5kLm1hcCh7XHJcblx0XHRcdGFjdGlvbjogXCJDcmVhdGVcIiwgXHJcblx0XHRcdHR5cGU6IFwiVGlsZXNcIiwgXHJcblx0XHRcdHNvdXJjZTogR2FtZXIuYWRyZXNzXHJcblx0XHR9KTtcclxuXHJcblx0XHRTZW5kLm1hcCh7XHJcblx0XHRcdGFjdGlvbjogXCJBZGRcIiwgXHJcblx0XHRcdHR5cGU6IFwiVGlsZXNcIixcclxuXHRcdFx0dGlsZV90eXBlOiBcIkdhbWVyXCIsXHJcblx0XHRcdHRpbGU6IEdhbWVyRGF0YS50aWxlLFxyXG5cdFx0XHRzb3VyY2U6IEdhbWVyLmFkcmVzcyxcclxuXHRcdH0pOyAgXHJcblx0XHRcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH07XHJcblxyXG5cdHRoaXMuUmVhZHkgPSBmdW5jdGlvbigpe1xyXG5cdFx0UmVzcCgpO1xyXG5cdFx0Y29uc29sZS5pbmZvKFwiR2FtZXIgTlwiICsgR2FtZXIuYWRyZXNzICsgXCIgaXMgcGxheWluZy5cIik7XHJcblx0fVxyXG5cclxuXHR0aGlzLkRlc3Ryb3kgPSBmdW5jdGlvbigpe1xyXG5cdFx0T2ZmKCk7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gdGhpcztcclxuXHJcblxyXG5cdFxyXG5cclxuXHRmdW5jdGlvbiBSZXNwKCl7XHJcblxyXG5cdFx0U2VuZC5tYXAoe1xyXG5cdFx0XHRhY3Rpb246IFwiQ3JlYXRlXCIsXHJcblx0XHRcdHR5cGU6IFwiR2FtZXJcIixcclxuXHRcdFx0c291cmNlOiBHYW1lci5hZHJlc3MsXHJcblx0XHRcdGJveDoge3c6IEdhbWVyLmJveC53LCBoOiBHYW1lci5ib3guaH0sXHJcblx0XHRcdHNwcml0ZTogR2FtZXJEYXRhLnRpbGUuaWRcclxuXHRcdH0pO1xyXG5cclxuXHRcdElzUGxheSA9IHRydWU7XHJcblx0fVxyXG5cdFxyXG5cdGZ1bmN0aW9uIE9mZigpe1xyXG5cdFx0R2FtZXIuZGVzdHJveSgpO1xyXG5cdFx0IFxyXG5cdFx0U2VuZC5tYXAoe1xyXG5cdFx0XHRhY3Rpb246IFwiRGVsbFwiLFxyXG5cdFx0XHR0eXBlOiBcIkdhbWVyXCIsXHJcblx0XHRcdGlkOiBHYW1lci5pZCxcclxuXHRcdFx0c291cmNlOiBHYW1lci5hZHJlc3MsXHJcblx0XHR9KTtcclxuXHJcblx0XHRJc1BsYXkgPSBmYWxzZTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIERlYXRoKGtpbGxlcil7XHJcblx0XHRPZmYoKTtcclxuXHRcdEdhbWVyLmRlYXRocysrO1xyXG5cdFx0UmVzcCgpO1xyXG5cclxuXHRcdFNlbmQubW9kZSh7XHJcblx0XHRcdGFjdGlvbjogXCJLaWxsXCIsXHJcblx0XHRcdGtpbGxlcjoga2lsbGVyLFxyXG5cdFx0XHRjYXN1YWx0eTogR2FtZXIuYWRyZXNzXHJcblx0XHR9KTtcclxuXHR9XHJcblx0XHJcblx0XHJcblx0ZnVuY3Rpb24gSW5wdXRDbGllbnQobWVzcyl7XHJcblx0XHRzd2l0Y2gobWVzcy5hY3Rpb24pe1xyXG5cdFx0XHRjYXNlIFwiUmVhZHlMb2FkXCI6IFJlYWR5TG9hZChtZXNzKTsgYnJlYWs7XHJcblx0XHRcdGNhc2UgXCJNb3ZlXCI6IGlmKElzUGxheSkgR2FtZXIubmV3X2RpciA9IG1lc3MuZGlyOyBicmVhaztcclxuXHRcdFx0Y2FzZSBcIkZpcmVcIjogaWYoSXNQbGF5KSBHYW1lci5wcmVzc19maXJlID0gdHJ1ZTsgYnJlYWs7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBSZWFkeUxvYWQobWVzcyl7XHJcblx0XHRzd2l0Y2gobWVzcy50eXBlKXtcclxuXHRcdFx0Y2FzZSBcIlRpbGVzXCI6IFJlYWR5VGlsZXMobWVzcyk7IGJyZWFrO1xyXG5cdFx0XHRjYXNlIFwiTWFwXCI6IFJlYWR5TWFwKG1lc3MpOyBicmVhaztcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIFJlYWR5VGlsZXMobWVzcyl7XHJcblx0XHRTZW5kLm1hcCh7XHJcblx0XHRcdGFjdGlvbjogXCJDcmVhdGVcIiwgXHJcblx0XHRcdHR5cGU6IFwiTWFwXCIsIFxyXG5cdFx0XHRzb3VyY2U6IEdhbWVyLmFkcmVzc1xyXG5cdFx0fSk7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBSZWFkeU1hcChtZXNzKXtcclxuXHRcdFJlYWR5R2FtZXIoKTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIFJlYWR5R2FtZXIoKXtcclxuXHRcdFNlbmQubWFuYWdlcih7XHJcblx0XHRcdGFjdGlvbjogXCJSZWFkeVwiLFxyXG5cdFx0XHR0eXBlOiBcIkdhbWVyXCIsXHJcblx0XHRcdGlkOiBHYW1lci5hZHJlc3MsXHJcblx0XHR9KTtcclxuXHR9XHJcblx0XHJcblx0XHJcblx0ZnVuY3Rpb24gSW5wdXQobWVzcyl7XHJcblxyXG5cdFx0aWYobWVzcy5hY3Rpb24gPT0gJ0Nvbm5lY3QnKXtcclxuXHRcdFx0R2FtZXIuYWRyZXNzID0gbWVzcy5hZHJlc3M7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRzd2l0Y2gobWVzcy50eXBlKXtcclxuXHRcdFx0Y2FzZSBcIlRpbGVzXCI6IFRpbGVzSW5wdXQobWVzcyk7IGJyZWFrO1xyXG5cdFx0XHRjYXNlIFwiTWFwXCI6IE1hcElucHV0KG1lc3MpOyBicmVhaztcclxuXHRcdFx0Y2FzZSBcIkdhbWVyXCI6IEdhbWVySW5wdXQobWVzcyk7IGJyZWFrO1xyXG5cdFx0XHRjYXNlIFwiQWN0b3JcIjogQWN0b3JJbnB1dChtZXNzKTsgYnJlYWs7XHJcblx0XHRcdGRlZmF1bHQ6IGNvbnNvbGUuZXJyb3IoXCJVbmtub3duIG1lc3NhZ2U6IFwiLCBtZXNzKTtcclxuXHRcdH1cclxuXHRcdFxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gVGlsZXNJbnB1dChtZXNzKXtcclxuXHRcdHN3aXRjaChtZXNzLmFjdGlvbil7XHJcblx0XHRcdGNhc2UgXCJDcmVhdGVcIjogXHJcblx0XHRcdFx0U2VuZC5jbGllbnQoe1xyXG5cdFx0XHRcdFx0YWN0aW9uOiBtZXNzLmFjdGlvbixcclxuXHRcdFx0XHRcdHR5cGU6IG1lc3MudHlwZSxcclxuXHRcdFx0XHRcdHRpbGVzOiBtZXNzLnRpbGVzXHJcblx0XHRcdFx0fSk7XHJcblxyXG5cdFx0XHRcdElzUmVhZHlUaWxlcyA9IHRydWU7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdGNhc2UgXCJBZGRcIjogQWRkVGlsZShtZXNzKTsgYnJlYWs7XHJcblx0XHRcdGRlZmF1bHQ6IGNvbnNvbGUuZXJyb3IoXCJVbmtub3duIG1lc3NhZ2U6IFwiLCBtZXNzKTtcclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBNYXBJbnB1dChtZXNzKXtcclxuXHRcdHN3aXRjaChtZXNzLmFjdGlvbil7XHJcblx0XHRcdGNhc2UgXCJDcmVhdGVcIjogSXNNYXAgPSB0cnVlOyBicmVhaztcclxuXHRcdFx0Y2FzZSBcIkRlbGxcIjogSXNNYXAgPSBmYWxzZTsgYnJlYWs7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYoSXNSZWFkeVRpbGVzKSBcclxuXHRcdFx0U2VuZC5jbGllbnQobWVzcyk7XHJcblx0XHRlbHNlIHRocm93IG5ldyBFcnJvcigpO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gR2FtZXJJbnB1dChtZXNzKXtcclxuXHRcdFxyXG5cdFx0c3dpdGNoKG1lc3MuYWN0aW9uKXtcclxuXHRcdFx0Y2FzZSBcIkNyZWF0ZVwiOiBHYW1lci5pbml0KG1lc3MpOyBicmVhaztcclxuXHRcdFx0Y2FzZSBcIlVwZGF0ZVwiOiBHYW1lci51cGRhdGUobWVzcyk7IGJyZWFrO1xyXG5cdFx0XHRjYXNlIFwiRGFtYWdlXCI6IEdhbWVyLmRhbWFnZShtZXNzKTsgYnJlYWs7XHJcblx0XHRcdGNhc2UgXCJLaWxsXCI6IEdhbWVyLmtpbGxzKys7IGJyZWFrO1xyXG5cdFx0XHRjYXNlIFwiV2luXCI6XHJcblx0XHRcdGNhc2UgXCJMb3NlXCI6IEVuZEdhbWUobWVzcyk7IGJyZWFrO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gRW5kR2FtZShtZXNzKXtcclxuXHRcdFNlbmQuY2xpZW50KHtcclxuXHRcdFx0YWN0aW9uOiBcIlVwZGF0ZVwiLFxyXG5cdFx0XHR0eXBlOiBcIkdVSVwiLCBcclxuXHRcdFx0ZGF0YToge1xyXG5cdFx0XHRcdFN0YXR1czogbWVzcy5hY3Rpb24sXHJcblx0XHRcdFx0V2lubmVyOiBtZXNzLndpbm5lcixcclxuXHRcdFx0XHRsaWZlOiBHYW1lci5saWZlLFxyXG5cdFx0XHRcdGRlYXRoczogR2FtZXIuZGVhdGhzLFxyXG5cdFx0XHRcdGtpbGxzOiBHYW1lci5raWxsc1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdFxyXG5cdFx0R2FtZXIuZGVzdHJveSgpO1xyXG5cdFx0SXNQbGF5ID0gZmFsc2U7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBBY3RvcklucHV0KG1lc3Mpe1xyXG5cdFx0XHJcblx0XHRpZihJc01hcCl7XHJcblx0XHRcdHZhciBuZXdfbWVzcyA9IE9iamVjdC5hc3NpZ24oe30sIG1lc3MpO1xyXG5cdFx0XHRkZWxldGUgbmV3X21lc3Muc291cmNlO1xyXG5cdFx0XHRTZW5kLmNsaWVudChuZXdfbWVzcyk7XHJcblx0XHR9XHJcblx0fVxyXG5cdFxyXG5cdGZ1bmN0aW9uIEFkZFRpbGUobWVzcyl7XHJcblx0XHRpZihtZXNzLnRpbGVfdHlwZSA9PSBcIkdhbWVyXCIpe1xyXG5cdFx0XHRHYW1lckRhdGEudGlsZS5pZCA9IG1lc3MudGlsZV9pZDtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmKElzUmVhZHlUaWxlcyl7XHJcblx0XHRcdHZhciBuZXdfbWVzcyA9IE9iamVjdC5hc3NpZ24oe30sIG1lc3MpO1xyXG5cdFx0XHRkZWxldGUgbmV3X21lc3Muc291cmNlO1xyXG5cdFx0XHRTZW5kLmNsaWVudChuZXdfbWVzcyk7XHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiBDckdhbWVyKFNlbmQsIERlYXRoKXtcclxuXHR2YXIgR2FtZXIgPSB7XHJcblx0XHRkaXI6IDAsXHJcblx0XHRzcGVlZDogNyxcclxuXHRcdGJveDoge3c6IDAuOSwgaDogMC45fSxcclxuXHRcdGJlZ19saWZlOiAzLFxyXG5cdFx0a2lsbHM6IDAsXHJcblx0XHRkZWF0aHM6IDBcclxuXHR9O1xyXG5cclxuXHR2YXIgR3VuID0gbmV3IENyR3VuKFwiQnVsbGV0XCIsIDcpO1xyXG5cclxuXHRDckRpcihHYW1lcik7XHJcblxyXG5cdEdhbWVyLmluaXQgPSBmdW5jdGlvbihtZXNzKXtcclxuXHJcblx0XHR0aGlzLnBvcyA9IHt4OiBtZXNzLnBvcy54LCB5OiBtZXNzLnBvcy55fTtcclxuXHRcdHRoaXMuaWQgPSBtZXNzLmlkO1xyXG5cdFx0dGhpcy5kaXIgPSBtZXNzLmRpcjtcclxuXHRcdHRoaXMubGlmZSA9IHRoaXMuYmVnX2xpZmU7XHJcblx0XHRcclxuXHRcdHRoaXMuc2Nhbl90aW1lciA9IHNldEludGVydmFsKEdhbWVyLnNjYW4uYmluZChHYW1lciksIDQwKTtcclxuXHRcdHRoaXMuc3RhdF90aW1lciA9IHNldEludGVydmFsKEdhbWVyLnVwU3RhdC5iaW5kKEdhbWVyKSwgMTQwKTtcclxuXHR9XHJcblxyXG5cdEdhbWVyLmRlc3Ryb3kgPSBmdW5jdGlvbigpe1xyXG5cdFx0Y2xlYXJJbnRlcnZhbCh0aGlzLnNjYW5fdGltZXIpO1xyXG5cdFx0Y2xlYXJJbnRlcnZhbCh0aGlzLnN0YXRfdGltZXIpO1xyXG5cdH1cclxuXHJcblx0R2FtZXIudXBkYXRlID0gZnVuY3Rpb24obWVzcyl7XHJcblx0XHR0aGlzLnBvcyA9IHt4OiBtZXNzLnBvcy54LCB5OiBtZXNzLnBvcy55fTtcclxuXHRcdHRoaXMuZGlyID0gbWVzcy5kaXI7XHJcblx0fVxyXG5cclxuXHRHYW1lci51cFN0YXQgPSBmdW5jdGlvbigpe1xyXG5cdFx0U2VuZC5jbGllbnQoe1xyXG5cdFx0XHRhY3Rpb246IFwiVXBkYXRlXCIsXHJcblx0XHRcdHR5cGU6IFwiR1VJXCIsIFxyXG5cdFx0XHRkYXRhOiB7XHJcblx0XHRcdFx0U3RhdHVzOiBcIlBsYXlcIixcclxuXHRcdFx0XHRsaWZlOiB0aGlzLmxpZmUsXHJcblx0XHRcdFx0ZGVhdGhzOiB0aGlzLmRlYXRocyxcclxuXHRcdFx0XHRraWxsczogdGhpcy5raWxsc1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHR9XHRcclxuXHRcclxuXHRcclxuXHRHYW1lci5zY2FuID0gZnVuY3Rpb24oKXtcclxuXHRcdGlmKHRoaXMuaXNfY2hhbmdlZCB8fCB0aGlzLm1vdmUpe1xyXG5cdFx0XHR0aGlzLnVwZGF0ZURpcigpO1xyXG5cclxuXHRcdFx0dmFyIHNwZWVkID0gMDtcclxuXHRcdFx0aWYodGhpcy5tb3ZlKVxyXG5cdFx0XHRcdHNwZWVkID0gdGhpcy5zcGVlZDtcclxuXHRcdFx0XHJcblx0XHRcdHZhciBtZXNzID0ge1xyXG5cdFx0XHRcdGFjdGlvbjogXCJNb3ZlXCIsXHJcblx0XHRcdFx0dHlwZTogXCJHYW1lclwiLFxyXG5cdFx0XHRcdGlkOiB0aGlzLmlkLFxyXG5cdFx0XHRcdGRpcjogdGhpcy5kaXIsXHJcblx0XHRcdFx0c3BlZWQ6IHNwZWVkXHJcblx0XHRcdH07XHJcblx0XHRcdFxyXG5cdFx0XHRTZW5kLm1hcChtZXNzKTtcclxuXHRcdH1cclxuXHRcdFxyXG5cdFx0aWYodGhpcy5wcmVzc19maXJlKSBHYW1lci5maXJlKCk7XHJcblx0fVxyXG5cclxuXHRHYW1lci5maXJlID0gZnVuY3Rpb24oKXtcclxuXHRcdHRoaXMucHJlc3NfZmlyZSA9IGZhbHNlO1xyXG5cclxuXHRcdGlmKEd1bi5pc19yZWNoYXJnZSlcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0XHJcblx0XHR2YXIgYXhpcyA9ICd4JztcclxuXHRcdHZhciBkaXIgPSAxO1xyXG5cdFx0c3dpdGNoKHRoaXMuZGlyKXtcclxuXHRcdFx0Y2FzZSAtMC41OiBkaXIgPSAtMTtcclxuXHRcdFx0Y2FzZSAwLjU6IGF4aXMgPSBcInlcIjsgYnJlYWs7XHJcblx0XHRcdGNhc2UgMTpcclxuXHRcdFx0Y2FzZSAtMTogZGlyID0gLTE7IGJyZWFrO1xyXG5cdFx0fVxyXG5cdFx0XHJcblx0XHR2YXIgYl9wb3MgPSB7eDogdGhpcy5wb3MueCwgeTogdGhpcy5wb3MueX07XHJcblx0XHRiX3Bvc1theGlzXSArPSBkaXIgKiAodGhpcy5ib3guaCArIDAuMDUpO1xyXG5cdFx0XHJcblx0XHR2YXIgbWVzcyA9IHtcclxuXHRcdFx0YWN0aW9uOiBcIkZpcmVcIixcclxuXHRcdFx0c291cmNlOiB0aGlzLmFkcmVzcyxcclxuXHRcdFx0cG9zOiB7eDogK2JfcG9zLngudG9GaXhlZCgyKSwgeTogK2JfcG9zLnkudG9GaXhlZCgyKX0sXHJcblx0XHRcdGRpcjogdGhpcy5kaXJcclxuXHRcdH07XHJcblx0XHRcclxuXHRcdFNlbmQuYnVsbGV0KG1lc3MpO1xyXG5cclxuXHRcdEd1bi5pc19yZWNoYXJnZSA9IHRydWU7XHJcblx0fVxyXG5cclxuXHRHYW1lci5kYW1hZ2UgPSBmdW5jdGlvbihtZXNzKXtcclxuXHRcdEdhbWVyLmxpZmUtLTtcclxuXHRcdFxyXG5cdFx0aWYoR2FtZXIubGlmZSA8PSAwKXtcclxuXHRcdFx0RGVhdGgobWVzcy5raWxsZXIpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cmV0dXJuIEdhbWVyO1xyXG59XHJcblxyXG5mdW5jdGlvbiBDckd1bihidWxsX3R5cGUsIHJlY2hhcmdlKXtcclxuXHR2YXIgaXNfcmVjaGFyZ2UgPSBmYWxzZTtcclxuXHJcblx0dGhpcy5hZGRHZXRTZXQoXCJpc19yZWNoYXJnZVwiLCBcclxuXHRcdGZ1bmN0aW9uKCl7XHJcblx0XHRcdHJldHVybiBpc19yZWNoYXJnZTtcclxuXHRcdH0sIFxyXG5cdFx0ZnVuY3Rpb24odmFsKXtcclxuXHRcdFx0aXNfcmVjaGFyZ2UgPSB2YWw7XHJcblx0XHRcdGlmKGlzX3JlY2hhcmdlKVxyXG5cdFx0XHRcdHNldFRpbWVvdXQoKFxyXG5cdFx0XHRcdFx0KCkgPT4gaXNfcmVjaGFyZ2UgPSBmYWxzZVxyXG5cdFx0XHRcdCksIDEwMCpyZWNoYXJnZSk7XHJcblx0XHR9XHJcblx0KTtcclxufVxyXG5cclxuZnVuY3Rpb24gQ3JEaXIob2JqKXtcclxuXHR2YXIgZGlyID0gbnVsbDtcclxuXHRvYmouaXNfbW92ZSA9IGZhbHNlO1xyXG5cclxuXHRvYmouYWRkR2V0U2V0KCduZXdfZGlyJywgXHJcblx0XHRmdW5jdGlvbigpe3JldHVybiBkaXJ9LFxyXG5cdFx0ZnVuY3Rpb24obmV3X2Rpcil7XHJcblx0XHRcdGlmKGRpciA9PT0gbnVsbCl7XHJcblx0XHRcdFx0ZGlyID0gbmV3X2RpcjtcclxuXHRcdFx0XHRvYmouaXNfY2hhbmdlZCA9IHRydWU7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHQpO1xyXG5cdG9iai51cGRhdGVEaXIgPSBmdW5jdGlvbigpe1xyXG5cdFx0b2JqLm1vdmUgPSBmYWxzZTtcclxuXHJcblx0XHRpZihvYmouZGlyID09IGRpcilcclxuXHRcdFx0b2JqLm1vdmUgPSB0cnVlO1xyXG5cclxuXHRcdGlmKGRpciAhPSBudWxsKXtcclxuXHRcdFx0b2JqLmRpciA9IGRpcjsgXHJcblx0XHR9XHJcblxyXG5cdFx0b2JqLmlzX2NoYW5nZWQgPSBmYWxzZTtcclxuXHRcdGRpciA9IG51bGw7XHJcblx0fTtcclxufVxyXG4iLCJtb2R1bGUuZXhwb3J0cz17XHJcblx0XCJCdWxsZXRcIjogXHJcblx0e1xyXG5cdFx0XCJ0aWxlXCI6IFxyXG5cdFx0e1xyXG4gICAgICBcdFx0XCJpbWFnZXNcIjogXHJcbiAgICAgIFx0XHRbXHJcbiAgICAgIFx0XHRcdFwiPHN2ZyB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHZpZXdCb3g9XFxcIjAgMCAxMzUuNDY3IDEzNS40NjdcXFwiIGhlaWdodD1cXFwiNTEyXFxcIiB3aWR0aD1cXFwiNTEyXFxcIj48cGF0aCBkPVxcXCJNMTM1LjY5NyA3MC40NDlhMzIuNzg4IDQzLjM3NCAwIDAgMS0zMi43ODggNDMuMzc0IDMyLjc4OCA0My4zNzQgMCAwIDEtNi43ODgtLjk5MkguMzc1VjI2LjA5SDEwMy42MXYxLjAyYTMyLjc4OCA0My4zNzQgMCAwIDEgMzIuMDg3IDQzLjM0elxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIi4zOTlcXFwiIGZpbGw9XFxcInJlZFxcXCIvPjwvc3ZnPlwiXHJcblx0XHRcdF0sXHJcblx0XHRcdFwidHlwZVwiOiBcInN0ZWVsXCIsXHJcbiAgICAgIFx0XHRcInNpemVcIjogMlxyXG5cdFx0fVxyXG5cdH1cclxufSIsIm1vZHVsZS5leHBvcnRzPXtcclxuICBcIm5hbWVcIjogXCJwZXJla3Jlc3Rva1wiLFxyXG4gIFwidGlsZXNcIjogW1xyXG4gICAge1xyXG4gICAgICBcImltYWdlc1wiOiBbXHJcbiAgICAgICAgXCI8P3htbCB2ZXJzaW9uPVxcXCIxLjBcXFwiIGVuY29kaW5nPVxcXCJVVEYtOFxcXCIgc3RhbmRhbG9uZT1cXFwibm9cXFwiPz5cXG48c3ZnXFxuICAgeG1sbnM6ZGM9XFxcImh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvXFxcIlxcbiAgIHhtbG5zOmNjPVxcXCJodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9ucyNcXFwiXFxuICAgeG1sbnM6cmRmPVxcXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjXFxcIlxcbiAgIHhtbG5zOnN2Zz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiXFxuICAgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIlxcbiAgIGlkPVxcXCJzdmc4XFxcIlxcbiAgIHZlcnNpb249XFxcIjEuMVxcXCJcXG4gICB2aWV3Qm94PVxcXCIwIDAgNDAwIDQwMFxcXCJcXG4gICBoZWlnaHQ9XFxcIjQwMG1tXFxcIlxcbiAgIHdpZHRoPVxcXCI0MDBtbVxcXCI+XFxuICA8ZGVmc1xcbiAgICAgaWQ9XFxcImRlZnMyXFxcIiAvPlxcbiAgPG1ldGFkYXRhXFxuICAgICBpZD1cXFwibWV0YWRhdGE1XFxcIj5cXG4gICAgPHJkZjpSREY+XFxuICAgICAgPGNjOldvcmtcXG4gICAgICAgICByZGY6YWJvdXQ9XFxcIlxcXCI+XFxuICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3N2Zyt4bWw8L2RjOmZvcm1hdD5cXG4gICAgICAgIDxkYzp0eXBlXFxuICAgICAgICAgICByZGY6cmVzb3VyY2U9XFxcImh0dHA6Ly9wdXJsLm9yZy9kYy9kY21pdHlwZS9TdGlsbEltYWdlXFxcIiAvPlxcbiAgICAgICAgPGRjOnRpdGxlPjwvZGM6dGl0bGU+XFxuICAgICAgPC9jYzpXb3JrPlxcbiAgICA8L3JkZjpSREY+XFxuICA8L21ldGFkYXRhPlxcbiAgPGdcXG4gICAgIHRyYW5zZm9ybT1cXFwidHJhbnNsYXRlKC0zLjI2Nzg4MDFlLTYsMTAzKVxcXCJcXG4gICAgIGlkPVxcXCJsYXllcjFcXFwiPlxcbiAgICA8Z1xcbiAgICAgICB0cmFuc2Zvcm09XFxcIm1hdHJpeCgtMC4yNjQzMjg1OSwwLDAsMC4yNjQ1ODI3MSw0MDAsNzQuMjUwNTI2KVxcXCJcXG4gICAgICAgaWQ9XFxcImcyNzExXFxcIj5cXG4gICAgICA8cGF0aFxcbiAgICAgICAgIGlkPVxcXCJwYXRoMTA5NFxcXCJcXG4gICAgICAgICBzdHlsZT1cXFwiZmlsbDojOGVjOTUzO2ZpbGwtcnVsZTpldmVub2RkO3N0cm9rZS13aWR0aDoxLjMzMzU0OTg2XFxcIlxcbiAgICAgICAgIGQ9XFxcIm0gMCwtNjY5LjkyMDg0IGggMTUxMS43NDQgbCAwLjA3LDE1MTEuODEwNiBIIDAuMDY5IFpcXFwiIC8+XFxuICAgICAgPHBhdGhcXG4gICAgICAgICBpZD1cXFwicGF0aDEwOTZcXFwiXFxuICAgICAgICAgc3R5bGU9XFxcImZpbGw6I2EyYTJhMjtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2Utd2lkdGg6MS4zMjI2MjgyNlxcXCJcXG4gICAgICAgICBkPVxcXCJtIDExNjYuMDMsLTY2OS45MjQ4NCB2IDE1MTEuODExMiBoIDM0MC4xNTcgdiAtMTUxMS44MTEyIHpcXFwiIC8+XFxuICAgICAgPHBhdGhcXG4gICAgICAgICBpZD1cXFwicGF0aDExMDBcXFwiXFxuICAgICAgICAgc3R5bGU9XFxcImZpbGw6IzcxNzI3MTtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2Utd2lkdGg6MS4xOTIzODQzNlxcXCJcXG4gICAgICAgICBkPVxcXCJtIDEyMzIuMTcsLTY2OS45MjE4NCBoIC03NC41MSB2IDE1MTEuODExNSBoIDc1LjU5MSB6XFxcIiAvPlxcbiAgICAgIDxwYXRoXFxuICAgICAgICAgaWQ9XFxcInBhdGgxMTAwLTJcXFwiXFxuICAgICAgICAgc3R5bGU9XFxcImZpbGw6IzcxNzI3MTtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2Utd2lkdGg6MS4xOTIzODQzNlxcXCJcXG4gICAgICAgICBkPVxcXCJtIDE1MTIuMTg3LC02NjkuOTI0ODQgaCAtNzQuNTEgViA4NDEuODg2NjEgaCA3NS41OTEgelxcXCIgLz5cXG4gICAgPC9nPlxcbiAgPC9nPlxcbjwvc3ZnPlxcblwiXHJcbiAgICAgIF0sXHJcbiAgICAgIFwidHlwZVwiOiBcIndvb2RcIixcclxuICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgIFwiaWRcIjogMFxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgXCJpbWFnZXNcIjogW1xyXG4gICAgICAgIFwiPD94bWwgdmVyc2lvbj1cXFwiMS4wXFxcIiBlbmNvZGluZz1cXFwiVVRGLThcXFwiIHN0YW5kYWxvbmU9XFxcIm5vXFxcIj8+XFxuPHN2Z1xcbiAgIHhtbG5zOmRjPVxcXCJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xL1xcXCJcXG4gICB4bWxuczpjYz1cXFwiaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbnMjXFxcIlxcbiAgIHhtbG5zOnJkZj1cXFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zI1xcXCJcXG4gICB4bWxuczpzdmc9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIlxcbiAgIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCJcXG4gICBpZD1cXFwic3ZnMjc3N1xcXCJcXG4gICB2ZXJzaW9uPVxcXCIxLjFcXFwiXFxuICAgdmlld0JveD1cXFwiMCAwIDQwMCA0MDBcXFwiXFxuICAgaGVpZ2h0PVxcXCI0MDBtbVxcXCJcXG4gICB3aWR0aD1cXFwiNDAwbW1cXFwiPlxcbiAgPGRlZnNcXG4gICAgIGlkPVxcXCJkZWZzMjc3MVxcXCIgLz5cXG4gIDxtZXRhZGF0YVxcbiAgICAgaWQ9XFxcIm1ldGFkYXRhMjc3NFxcXCI+XFxuICAgIDxyZGY6UkRGPlxcbiAgICAgIDxjYzpXb3JrXFxuICAgICAgICAgcmRmOmFib3V0PVxcXCJcXFwiPlxcbiAgICAgICAgPGRjOmZvcm1hdD5pbWFnZS9zdmcreG1sPC9kYzpmb3JtYXQ+XFxuICAgICAgICA8ZGM6dHlwZVxcbiAgICAgICAgICAgcmRmOnJlc291cmNlPVxcXCJodHRwOi8vcHVybC5vcmcvZGMvZGNtaXR5cGUvU3RpbGxJbWFnZVxcXCIgLz5cXG4gICAgICAgIDxkYzp0aXRsZT48L2RjOnRpdGxlPlxcbiAgICAgIDwvY2M6V29yaz5cXG4gICAgPC9yZGY6UkRGPlxcbiAgPC9tZXRhZGF0YT5cXG4gIDxnXFxuICAgICB0cmFuc2Zvcm09XFxcInRyYW5zbGF0ZSg0Ny4yOTc2NjgsNjAuMjM4MTI5KVxcXCJcXG4gICAgIGlkPVxcXCJsYXllcjFcXFwiPlxcbiAgICA8Z1xcbiAgICAgICB0cmFuc2Zvcm09XFxcIm1hdHJpeCgwLjM1Mjc3NzU2LDAsMCwwLjM1Mjc3NzgsLTUxMTYuNzQ4NiwyMTMyLjU3NjUpXFxcIlxcbiAgICAgICBpZD1cXFwiTGF5ZXIxMDYzXFxcIj5cXG4gICAgICA8cGF0aFxcbiAgICAgICAgIGlkPVxcXCJwYXRoMTIzNVxcXCJcXG4gICAgICAgICBzdHlsZT1cXFwiZmlsbDojNTI1MjUyO2ZpbGwtcnVsZTpldmVub2RkXFxcIlxcbiAgICAgICAgIGQ9XFxcIm0gMTQzNzAuMTA2LC02MjE1Ljg1MjEgdiAxMTMzLjg1ODIgaCAxMTMzLjg1OSB2IC0xMTMzLjg1ODIgelxcXCIgLz5cXG4gICAgICA8cGF0aFxcbiAgICAgICAgIGlkPVxcXCJwYXRoMTIzN1xcXCJcXG4gICAgICAgICBzdHlsZT1cXFwiZmlsbDojZDJkMWQyO2ZpbGwtcnVsZTpldmVub2RkXFxcIlxcbiAgICAgICAgIGQ9XFxcIm0gMTQ1NjcuNjk5LC01MDgxLjk5MzkgdiAtMTEzMy44NTgyIGggLTE5Ny41OTMgdiAxMTMzLjg1ODIgelxcXCIgLz5cXG4gICAgICA8cGF0aFxcbiAgICAgICAgIGlkPVxcXCJwYXRoMTIzOVxcXCJcXG4gICAgICAgICBzdHlsZT1cXFwiZmlsbDojNTI1MjUyO2ZpbGwtcnVsZTpldmVub2RkXFxcIlxcbiAgICAgICAgIGQ9XFxcIm0gMTQ2MTguNzM0LC01ODE5LjkxMzkgaCAtMjQ4LjYyOCB2IDM5Ni44NTA5IGggMjQ4LjYyOCB6XFxcIiAvPlxcbiAgICA8L2c+XFxuICA8L2c+XFxuPC9zdmc+XFxuXCJcclxuICAgICAgXSxcclxuICAgICAgXCJ0eXBlXCI6IFwid29vZFwiLFxyXG4gICAgICBcInNpemVcIjogMSxcclxuICAgICAgXCJpZFwiOiAxXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICBcImltYWdlc1wiOiBbXHJcbiAgICAgICAgXCI8P3htbCB2ZXJzaW9uPVxcXCIxLjBcXFwiIGVuY29kaW5nPVxcXCJVVEYtOFxcXCIgc3RhbmRhbG9uZT1cXFwibm9cXFwiPz5cXG48c3ZnXFxuICAgeG1sbnM6ZGM9XFxcImh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvXFxcIlxcbiAgIHhtbG5zOmNjPVxcXCJodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9ucyNcXFwiXFxuICAgeG1sbnM6cmRmPVxcXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjXFxcIlxcbiAgIHhtbG5zOnN2Zz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiXFxuICAgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIlxcbiAgIGlkPVxcXCJzdmc4MjFcXFwiXFxuICAgdmVyc2lvbj1cXFwiMS4xXFxcIlxcbiAgIHZpZXdCb3g9XFxcIjAgMCA0MDAgMzk5LjU5OTk4XFxcIlxcbiAgIGhlaWdodD1cXFwiMzk5LjU5OTk4bW1cXFwiXFxuICAgd2lkdGg9XFxcIjQwMG1tXFxcIj5cXG4gIDxkZWZzXFxuICAgICBpZD1cXFwiZGVmczgxNVxcXCIgLz5cXG4gIDxtZXRhZGF0YVxcbiAgICAgaWQ9XFxcIm1ldGFkYXRhODE4XFxcIj5cXG4gICAgPHJkZjpSREY+XFxuICAgICAgPGNjOldvcmtcXG4gICAgICAgICByZGY6YWJvdXQ9XFxcIlxcXCI+XFxuICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3N2Zyt4bWw8L2RjOmZvcm1hdD5cXG4gICAgICAgIDxkYzp0eXBlXFxuICAgICAgICAgICByZGY6cmVzb3VyY2U9XFxcImh0dHA6Ly9wdXJsLm9yZy9kYy9kY21pdHlwZS9TdGlsbEltYWdlXFxcIiAvPlxcbiAgICAgICAgPGRjOnRpdGxlPjwvZGM6dGl0bGU+XFxuICAgICAgPC9jYzpXb3JrPlxcbiAgICA8L3JkZjpSREY+XFxuICA8L21ldGFkYXRhPlxcbiAgPGdcXG4gICAgIHRyYW5zZm9ybT1cXFwidHJhbnNsYXRlKDAsMTAyLjU5OTk5KVxcXCJcXG4gICAgIGlkPVxcXCJsYXllcjFcXFwiPlxcbiAgICA8cGF0aFxcbiAgICAgICBpZD1cXFwicGF0aDEzOTBcXFwiXFxuICAgICAgIHN0eWxlPVxcXCJmaWxsOiM5MTViMjY7ZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlLXdpZHRoOjAuMzUyNzc3ODRcXFwiXFxuICAgICAgIGQ9XFxcIk0gMCwtMTAyLjk5OTk5IFYgMjk3IGggMzk5Ljk5OTk5IHYgLTM5OS45OTk5OSB6XFxcIiAvPlxcbiAgPC9nPlxcbjwvc3ZnPlxcblwiXHJcbiAgICAgIF0sXHJcbiAgICAgIFwidHlwZVwiOiBcIndvb2RcIixcclxuICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgIFwiaWRcIjogMlxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgXCJpbWFnZXNcIjogW1xyXG4gICAgICAgIFwiPD94bWwgdmVyc2lvbj1cXFwiMS4wXFxcIiBlbmNvZGluZz1cXFwiVVRGLThcXFwiIHN0YW5kYWxvbmU9XFxcIm5vXFxcIj8+XFxuPHN2Z1xcbiAgIHhtbG5zOmRjPVxcXCJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xL1xcXCJcXG4gICB4bWxuczpjYz1cXFwiaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbnMjXFxcIlxcbiAgIHhtbG5zOnJkZj1cXFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zI1xcXCJcXG4gICB4bWxuczpzdmc9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIlxcbiAgIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCJcXG4gICBpZD1cXFwic3ZnNDAzN1xcXCJcXG4gICB2ZXJzaW9uPVxcXCIxLjFcXFwiXFxuICAgdmlld0JveD1cXFwiMCAwIDQwMCA0MDBcXFwiXFxuICAgaGVpZ2h0PVxcXCI0MDBtbVxcXCJcXG4gICB3aWR0aD1cXFwiNDAwbW1cXFwiPlxcbiAgPGRlZnNcXG4gICAgIGlkPVxcXCJkZWZzNDAzMVxcXCIgLz5cXG4gIDxtZXRhZGF0YVxcbiAgICAgaWQ9XFxcIm1ldGFkYXRhNDAzNFxcXCI+XFxuICAgIDxyZGY6UkRGPlxcbiAgICAgIDxjYzpXb3JrXFxuICAgICAgICAgcmRmOmFib3V0PVxcXCJcXFwiPlxcbiAgICAgICAgPGRjOmZvcm1hdD5pbWFnZS9zdmcreG1sPC9kYzpmb3JtYXQ+XFxuICAgICAgICA8ZGM6dHlwZVxcbiAgICAgICAgICAgcmRmOnJlc291cmNlPVxcXCJodHRwOi8vcHVybC5vcmcvZGMvZGNtaXR5cGUvU3RpbGxJbWFnZVxcXCIgLz5cXG4gICAgICAgIDxkYzp0aXRsZT48L2RjOnRpdGxlPlxcbiAgICAgIDwvY2M6V29yaz5cXG4gICAgPC9yZGY6UkRGPlxcbiAgPC9tZXRhZGF0YT5cXG4gIDxnXFxuICAgICB0cmFuc2Zvcm09XFxcInRyYW5zbGF0ZSgxLjQ3NTI3NDZlLTYsMTAzKVxcXCJcXG4gICAgIGlkPVxcXCJsYXllcjFcXFwiPlxcbiAgICA8Z1xcbiAgICAgICB0cmFuc2Zvcm09XFxcInJvdGF0ZSgtOTAsMTE2LjAzODY5LDk1Ljg2NjA3KVxcXCJcXG4gICAgICAgaWQ9XFxcImc1MjQzXFxcIj5cXG4gICAgICA8Z1xcbiAgICAgICAgIGlkPVxcXCJnNTA1OFxcXCJcXG4gICAgICAgICB0cmFuc2Zvcm09XFxcIm1hdHJpeCgwLjk5OTgxNzcxLDAsMCwwLjk5OTYzNTgxLC0zMy45NTQyNTQsNDMzLjcwNjY4KVxcXCI+XFxuICAgICAgICA8cGF0aFxcbiAgICAgICAgICAgaWQ9XFxcInBhdGgxMzgwLTRcXFwiXFxuICAgICAgICAgICBzdHlsZT1cXFwiZmlsbDojODA4MDgwO2ZpbGwtcnVsZTpldmVub2RkO3N0cm9rZS13aWR0aDowLjM1Mjc3NzY2XFxcIlxcbiAgICAgICAgICAgZD1cXFwiTSAtNTEuMDc3MzgyLC00NTQuMDQ0NjYgViAtNTQuMDQ0NjY4IEggMzQ4LjkyMjYyIFYgLTQ1NC4wNDQ2NiBaXFxcIiAvPlxcbiAgICAgICAgPHJlY3RcXG4gICAgICAgICAgIHk9XFxcIi00NTMuODk4NjhcXFwiXFxuICAgICAgICAgICB4PVxcXCItMTEuMDkxODc3XFxcIlxcbiAgICAgICAgICAgaGVpZ2h0PVxcXCIzOTkuODUzOTFcXFwiXFxuICAgICAgICAgICB3aWR0aD1cXFwiMzkuOTg1MzlcXFwiXFxuICAgICAgICAgICBpZD1cXFwicmVjdDM5MDktMi00NVxcXCJcXG4gICAgICAgICAgIHN0eWxlPVxcXCJvcGFjaXR5OjE7ZmlsbDojNGQ0ZDRkO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTojMWExYTFhO3N0cm9rZS13aWR0aDowLjE0NjExNDI2O3N0cm9rZS1taXRlcmxpbWl0OjQ7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjFcXFwiIC8+XFxuICAgICAgICA8cmVjdFxcbiAgICAgICAgICAgeT1cXFwiLTQ1My44OTg3NFxcXCJcXG4gICAgICAgICAgIHg9XFxcIjY4Ljg3ODg4M1xcXCJcXG4gICAgICAgICAgIGhlaWdodD1cXFwiMzk5Ljg1MzkxXFxcIlxcbiAgICAgICAgICAgd2lkdGg9XFxcIjM5Ljk4NTM5XFxcIlxcbiAgICAgICAgICAgaWQ9XFxcInJlY3QzOTA5LTItMC03XFxcIlxcbiAgICAgICAgICAgc3R5bGU9XFxcIm9wYWNpdHk6MTtmaWxsOiM0ZDRkNGQ7ZmlsbC1vcGFjaXR5OjE7c3Ryb2tlOiMxYTFhMWE7c3Ryb2tlLXdpZHRoOjAuMTQ2MTE0MjY7c3Ryb2tlLW1pdGVybGltaXQ6NDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MVxcXCIgLz5cXG4gICAgICAgIDxyZWN0XFxuICAgICAgICAgICB5PVxcXCItNDUzLjg5ODhcXFwiXFxuICAgICAgICAgICB4PVxcXCIxNDguODQ5NjdcXFwiXFxuICAgICAgICAgICBoZWlnaHQ9XFxcIjM5OS44NTM5MVxcXCJcXG4gICAgICAgICAgIHdpZHRoPVxcXCIzOS45ODUzOVxcXCJcXG4gICAgICAgICAgIGlkPVxcXCJyZWN0MzkwOS0yLTQtNFxcXCJcXG4gICAgICAgICAgIHN0eWxlPVxcXCJvcGFjaXR5OjE7ZmlsbDojNGQ0ZDRkO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTojMWExYTFhO3N0cm9rZS13aWR0aDowLjE0NjExNDI2O3N0cm9rZS1taXRlcmxpbWl0OjQ7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjFcXFwiIC8+XFxuICAgICAgICA8cmVjdFxcbiAgICAgICAgICAgeT1cXFwiLTQ1My44OTg4NlxcXCJcXG4gICAgICAgICAgIHg9XFxcIjIyOC44MjA0NVxcXCJcXG4gICAgICAgICAgIGhlaWdodD1cXFwiMzk5Ljg1MzkxXFxcIlxcbiAgICAgICAgICAgd2lkdGg9XFxcIjM5Ljk4NTM5XFxcIlxcbiAgICAgICAgICAgaWQ9XFxcInJlY3QzOTA5LTItMC01LTZcXFwiXFxuICAgICAgICAgICBzdHlsZT1cXFwib3BhY2l0eToxO2ZpbGw6IzRkNGQ0ZDtmaWxsLW9wYWNpdHk6MTtzdHJva2U6IzFhMWExYTtzdHJva2Utd2lkdGg6MC4xNDYxMTQyNjtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxXFxcIiAvPlxcbiAgICAgICAgPHJlY3RcXG4gICAgICAgICAgIHk9XFxcIi00NTMuODk4OTNcXFwiXFxuICAgICAgICAgICB4PVxcXCIzMDguNzkxMjNcXFwiXFxuICAgICAgICAgICBoZWlnaHQ9XFxcIjM5OS44NTM5MVxcXCJcXG4gICAgICAgICAgIHdpZHRoPVxcXCIzOS45ODUzOVxcXCJcXG4gICAgICAgICAgIGlkPVxcXCJyZWN0MzkwOS0yLTAtNS01LTdcXFwiXFxuICAgICAgICAgICBzdHlsZT1cXFwib3BhY2l0eToxO2ZpbGw6IzRkNGQ0ZDtmaWxsLW9wYWNpdHk6MTtzdHJva2U6IzFhMWExYTtzdHJva2Utd2lkdGg6MC4xNDYxMTQyNjtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxXFxcIiAvPlxcbiAgICAgIDwvZz5cXG4gICAgICA8Z1xcbiAgICAgICAgIGlkPVxcXCJnNTA1MFxcXCJcXG4gICAgICAgICB0cmFuc2Zvcm09XFxcIm1hdHJpeCgwLC0wLjk5OTYzNTgxLC0wLjk5OTgxNzcxLDAsLTEzOC4xMTk2MSw3OTYuODU0MjkpXFxcIj5cXG4gICAgICAgIDxwYXRoXFxuICAgICAgICAgICBpZD1cXFwicGF0aDEzODAtNlxcXCJcXG4gICAgICAgICAgIHN0eWxlPVxcXCJmaWxsOiNiM2IzYjM7ZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlLXdpZHRoOjAuMjQ5NDUxNDdcXFwiXFxuICAgICAgICAgICBkPVxcXCJtIDQxNy4xNzg4NCwtMjUyLjk3NTU4IGggMzk5Ljk5OTk5IHYgLTIwMCBIIDQxNy4xNzg4NCBaXFxcIiAvPlxcbiAgICAgICAgPHBhdGhcXG4gICAgICAgICAgIGlkPVxcXCJwYXRoMTM4MC0wXFxcIlxcbiAgICAgICAgICAgc3R5bGU9XFxcImZpbGw6IzgwODA4MDtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2Utd2lkdGg6MC4xMTE1NTgwOVxcXCJcXG4gICAgICAgICAgIGQ9XFxcIm0gNDE3LjE3ODg0LC0yNTIuOTc1NTggaCAzOTkuOTk5OTkgdiAtNDAgSCA0MTcuMTc4ODQgWlxcXCIgLz5cXG4gICAgICAgIDxwYXRoXFxuICAgICAgICAgICBpZD1cXFwicGF0aDEzODAtMC03XFxcIlxcbiAgICAgICAgICAgc3R5bGU9XFxcImZpbGw6IzgwODA4MDtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2Utd2lkdGg6MC4wNTU3NzkwNFxcXCJcXG4gICAgICAgICAgIGQ9XFxcIm0gNDM3LjE3ODg0LC0yNTIuOTc1NTggdiAtMjAwIGggLTIwIHYgMjAwIHpcXFwiIC8+XFxuICAgICAgICA8cGF0aFxcbiAgICAgICAgICAgaWQ9XFxcInBhdGgxMzgwLTAtNy02XFxcIlxcbiAgICAgICAgICAgc3R5bGU9XFxcImZpbGw6IzgwODA4MDtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2Utd2lkdGg6MC4wNTU3NzkwNFxcXCJcXG4gICAgICAgICAgIGQ9XFxcIm0gODE3LjE3ODgzLC0yNTIuOTc1NTggdiAtMjAwIGggLTIwIHYgMjAwIHpcXFwiIC8+XFxuICAgICAgICA8cGF0aFxcbiAgICAgICAgICAgaWQ9XFxcInBhdGgxMzgwLTAtNlxcXCJcXG4gICAgICAgICAgIHN0eWxlPVxcXCJmaWxsOiM0ZDRkNGQ7ZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlLXdpZHRoOjAuMDc4ODgzNDhcXFwiXFxuICAgICAgICAgICBkPVxcXCJtIDQxNy4xNzg4NCwtMjUyLjk3NTU4IGggMzk5Ljk5OTk5IHYgLTIwIEggNDE3LjE3ODg0IFpcXFwiIC8+XFxuICAgICAgICA8Z1xcbiAgICAgICAgICAgc3R5bGU9XFxcImZpbGw6IzRkNGQ0ZDtmaWxsLW9wYWNpdHk6MVxcXCJcXG4gICAgICAgICAgIGlkPVxcXCJnNDczMS01LTFcXFwiXFxuICAgICAgICAgICB0cmFuc2Zvcm09XFxcInRyYW5zbGF0ZSgtNDcuMTE4NzEyLDc3Ljg2MjAzKVxcXCI+XFxuICAgICAgICAgIDxjaXJjbGVcXG4gICAgICAgICAgICAgc3R5bGU9XFxcIm9wYWNpdHk6MTtmaWxsOiM0ZDRkNGQ7ZmlsbC1vcGFjaXR5OjE7c3Ryb2tlOiMxYTFhMWE7c3Ryb2tlLXdpZHRoOjAuMTU4NzU7c3Ryb2tlLW1pdGVybGltaXQ6NDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MVxcXCJcXG4gICAgICAgICAgICAgaWQ9XFxcInBhdGg0NzAyLTQtNlxcXCJcXG4gICAgICAgICAgICAgY3g9XFxcIjQ5Ny4xMjEzNFxcXCJcXG4gICAgICAgICAgICAgY3k9XFxcIi00OTUuMTg2ODlcXFwiXFxuICAgICAgICAgICAgIHI9XFxcIjExLjIyNTMyXFxcIiAvPlxcbiAgICAgICAgICA8Y2lyY2xlXFxuICAgICAgICAgICAgIHN0eWxlPVxcXCJvcGFjaXR5OjE7ZmlsbDojNGQ0ZDRkO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTojMWExYTFhO3N0cm9rZS13aWR0aDowLjExMDMxNTg7c3Ryb2tlLW1pdGVybGltaXQ6NDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MVxcXCJcXG4gICAgICAgICAgICAgaWQ9XFxcInBhdGg0NzAyLTgtNi0wXFxcIlxcbiAgICAgICAgICAgICBjeD1cXFwiNDk3LjA2MzkzXFxcIlxcbiAgICAgICAgICAgICBjeT1cXFwiLTQ5NS4xMzQwNlxcXCJcXG4gICAgICAgICAgICAgcj1cXFwiNy44MDA1MDM3XFxcIiAvPlxcbiAgICAgICAgPC9nPlxcbiAgICAgICAgPGdcXG4gICAgICAgICAgIHN0eWxlPVxcXCJmaWxsOiM0ZDRkNGQ7ZmlsbC1vcGFjaXR5OjFcXFwiXFxuICAgICAgICAgICBpZD1cXFwiZzQ3MzEtNS0xLTJcXFwiXFxuICAgICAgICAgICB0cmFuc2Zvcm09XFxcInRyYW5zbGF0ZSgtNDcuMDA0Nzg4LDExNC40MjA3MylcXFwiPlxcbiAgICAgICAgICA8Y2lyY2xlXFxuICAgICAgICAgICAgIHN0eWxlPVxcXCJvcGFjaXR5OjE7ZmlsbDojNGQ0ZDRkO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTojMWExYTFhO3N0cm9rZS13aWR0aDowLjE1ODc1O3N0cm9rZS1taXRlcmxpbWl0OjQ7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjFcXFwiXFxuICAgICAgICAgICAgIGlkPVxcXCJwYXRoNDcwMi00LTYtM1xcXCJcXG4gICAgICAgICAgICAgY3g9XFxcIjQ5Ny4xMjEzNFxcXCJcXG4gICAgICAgICAgICAgY3k9XFxcIi00OTUuMTg2ODlcXFwiXFxuICAgICAgICAgICAgIHI9XFxcIjExLjIyNTMyXFxcIiAvPlxcbiAgICAgICAgICA8Y2lyY2xlXFxuICAgICAgICAgICAgIHN0eWxlPVxcXCJvcGFjaXR5OjE7ZmlsbDojNGQ0ZDRkO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTojMWExYTFhO3N0cm9rZS13aWR0aDowLjExMDMxNTg7c3Ryb2tlLW1pdGVybGltaXQ6NDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MVxcXCJcXG4gICAgICAgICAgICAgaWQ9XFxcInBhdGg0NzAyLTgtNi0wLTJcXFwiXFxuICAgICAgICAgICAgIGN4PVxcXCI0OTcuMDYzOTNcXFwiXFxuICAgICAgICAgICAgIGN5PVxcXCItNDk1LjEzNDA2XFxcIlxcbiAgICAgICAgICAgICByPVxcXCI3LjgwMDUwMzdcXFwiIC8+XFxuICAgICAgICA8L2c+XFxuICAgICAgICA8Z1xcbiAgICAgICAgICAgc3R5bGU9XFxcImZpbGw6IzRkNGQ0ZDtmaWxsLW9wYWNpdHk6MVxcXCJcXG4gICAgICAgICAgIGlkPVxcXCJnNDczMS01LThcXFwiXFxuICAgICAgICAgICB0cmFuc2Zvcm09XFxcInRyYW5zbGF0ZSgtNDcuMTk3Njg0LDE1Mi41NjAzMSlcXFwiPlxcbiAgICAgICAgICA8Y2lyY2xlXFxuICAgICAgICAgICAgIHN0eWxlPVxcXCJvcGFjaXR5OjE7ZmlsbDojNGQ0ZDRkO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTojMWExYTFhO3N0cm9rZS13aWR0aDowLjE1ODc1O3N0cm9rZS1taXRlcmxpbWl0OjQ7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjFcXFwiXFxuICAgICAgICAgICAgIGlkPVxcXCJwYXRoNDcwMi00LThcXFwiXFxuICAgICAgICAgICAgIGN4PVxcXCI0OTcuMTIxMzRcXFwiXFxuICAgICAgICAgICAgIGN5PVxcXCItNDk1LjE4Njg5XFxcIlxcbiAgICAgICAgICAgICByPVxcXCIxMS4yMjUzMlxcXCIgLz5cXG4gICAgICAgICAgPGNpcmNsZVxcbiAgICAgICAgICAgICBzdHlsZT1cXFwib3BhY2l0eToxO2ZpbGw6IzRkNGQ0ZDtmaWxsLW9wYWNpdHk6MTtzdHJva2U6IzFhMWExYTtzdHJva2Utd2lkdGg6MC4xMTAzMTU4O3N0cm9rZS1taXRlcmxpbWl0OjQ7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjFcXFwiXFxuICAgICAgICAgICAgIGlkPVxcXCJwYXRoNDcwMi04LTYtNTZcXFwiXFxuICAgICAgICAgICAgIGN4PVxcXCI0OTcuMDYzOTNcXFwiXFxuICAgICAgICAgICAgIGN5PVxcXCItNDk1LjEzNDA2XFxcIlxcbiAgICAgICAgICAgICByPVxcXCI3LjgwMDUwMzdcXFwiIC8+XFxuICAgICAgICA8L2c+XFxuICAgICAgICA8Z1xcbiAgICAgICAgICAgc3R5bGU9XFxcImZpbGw6IzRkNGQ0ZDtmaWxsLW9wYWNpdHk6MVxcXCJcXG4gICAgICAgICAgIGlkPVxcXCJnNDczMS01LTctOFxcXCJcXG4gICAgICAgICAgIHRyYW5zZm9ybT1cXFwidHJhbnNsYXRlKC00Ny4zODYxNTgsMTg2LjkyNjcpXFxcIj5cXG4gICAgICAgICAgPGNpcmNsZVxcbiAgICAgICAgICAgICBzdHlsZT1cXFwib3BhY2l0eToxO2ZpbGw6IzRkNGQ0ZDtmaWxsLW9wYWNpdHk6MTtzdHJva2U6IzFhMWExYTtzdHJva2Utd2lkdGg6MC4xNTg3NTtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxXFxcIlxcbiAgICAgICAgICAgICBpZD1cXFwicGF0aDQ3MDItNC00LTVcXFwiXFxuICAgICAgICAgICAgIGN4PVxcXCI0OTcuMTIxMzRcXFwiXFxuICAgICAgICAgICAgIGN5PVxcXCItNDk1LjE4Njg5XFxcIlxcbiAgICAgICAgICAgICByPVxcXCIxMS4yMjUzMlxcXCIgLz5cXG4gICAgICAgICAgPGNpcmNsZVxcbiAgICAgICAgICAgICBzdHlsZT1cXFwib3BhY2l0eToxO2ZpbGw6IzRkNGQ0ZDtmaWxsLW9wYWNpdHk6MTtzdHJva2U6IzFhMWExYTtzdHJva2Utd2lkdGg6MC4xMTAzMTU4O3N0cm9rZS1taXRlcmxpbWl0OjQ7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjFcXFwiXFxuICAgICAgICAgICAgIGlkPVxcXCJwYXRoNDcwMi04LTYtNS05XFxcIlxcbiAgICAgICAgICAgICBjeD1cXFwiNDk3LjA2MzkzXFxcIlxcbiAgICAgICAgICAgICBjeT1cXFwiLTQ5NS4xMzQwNlxcXCJcXG4gICAgICAgICAgICAgcj1cXFwiNy44MDA1MDM3XFxcIiAvPlxcbiAgICAgICAgPC9nPlxcbiAgICAgICAgPHBhdGhcXG4gICAgICAgICAgIGlkPVxcXCJwYXRoMTM4MC0wLTlcXFwiXFxuICAgICAgICAgICBzdHlsZT1cXFwiZmlsbDojODA4MDgwO2ZpbGwtcnVsZTpldmVub2RkO3N0cm9rZS13aWR0aDowLjA3ODg4MzQ4XFxcIlxcbiAgICAgICAgICAgZD1cXFwibSA0MTcuMTc4ODQsLTQzMi45NzU1OCBoIDM5OS45OTk5OSB2IC0yMCBIIDQxNy4xNzg4NCBaXFxcIiAvPlxcbiAgICAgICAgPGdcXG4gICAgICAgICAgIHN0eWxlPVxcXCJmaWxsOiM0ZDRkNGQ7ZmlsbC1vcGFjaXR5OjFcXFwiXFxuICAgICAgICAgICBpZD1cXFwiZzQ3MzEtNS0xLThcXFwiXFxuICAgICAgICAgICB0cmFuc2Zvcm09XFxcInRyYW5zbGF0ZSgyODcuMTAyNzQsNzcuNDk4ODIyKVxcXCI+XFxuICAgICAgICAgIDxjaXJjbGVcXG4gICAgICAgICAgICAgc3R5bGU9XFxcIm9wYWNpdHk6MTtmaWxsOiM0ZDRkNGQ7ZmlsbC1vcGFjaXR5OjE7c3Ryb2tlOiMxYTFhMWE7c3Ryb2tlLXdpZHRoOjAuMTU4NzU7c3Ryb2tlLW1pdGVybGltaXQ6NDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MVxcXCJcXG4gICAgICAgICAgICAgaWQ9XFxcInBhdGg0NzAyLTQtNi03XFxcIlxcbiAgICAgICAgICAgICBjeD1cXFwiNDk3LjEyMTM0XFxcIlxcbiAgICAgICAgICAgICBjeT1cXFwiLTQ5NS4xODY4OVxcXCJcXG4gICAgICAgICAgICAgcj1cXFwiMTEuMjI1MzJcXFwiIC8+XFxuICAgICAgICAgIDxjaXJjbGVcXG4gICAgICAgICAgICAgc3R5bGU9XFxcIm9wYWNpdHk6MTtmaWxsOiM0ZDRkNGQ7ZmlsbC1vcGFjaXR5OjE7c3Ryb2tlOiMxYTFhMWE7c3Ryb2tlLXdpZHRoOjAuMTEwMzE1ODtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxXFxcIlxcbiAgICAgICAgICAgICBpZD1cXFwicGF0aDQ3MDItOC02LTAtM1xcXCJcXG4gICAgICAgICAgICAgY3g9XFxcIjQ5Ny4wNjM5M1xcXCJcXG4gICAgICAgICAgICAgY3k9XFxcIi00OTUuMTM0MDZcXFwiXFxuICAgICAgICAgICAgIHI9XFxcIjcuODAwNTAzN1xcXCIgLz5cXG4gICAgICAgIDwvZz5cXG4gICAgICAgIDxnXFxuICAgICAgICAgICBzdHlsZT1cXFwiZmlsbDojNGQ0ZDRkO2ZpbGwtb3BhY2l0eToxXFxcIlxcbiAgICAgICAgICAgaWQ9XFxcImc0NzMxLTUtMS0yLTVcXFwiXFxuICAgICAgICAgICB0cmFuc2Zvcm09XFxcInRyYW5zbGF0ZSgyODcuMjE2NjcsMTE0LjA1NzUyKVxcXCI+XFxuICAgICAgICAgIDxjaXJjbGVcXG4gICAgICAgICAgICAgc3R5bGU9XFxcIm9wYWNpdHk6MTtmaWxsOiM0ZDRkNGQ7ZmlsbC1vcGFjaXR5OjE7c3Ryb2tlOiMxYTFhMWE7c3Ryb2tlLXdpZHRoOjAuMTU4NzU7c3Ryb2tlLW1pdGVybGltaXQ6NDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MVxcXCJcXG4gICAgICAgICAgICAgaWQ9XFxcInBhdGg0NzAyLTQtNi0zLThcXFwiXFxuICAgICAgICAgICAgIGN4PVxcXCI0OTcuMTIxMzRcXFwiXFxuICAgICAgICAgICAgIGN5PVxcXCItNDk1LjE4Njg5XFxcIlxcbiAgICAgICAgICAgICByPVxcXCIxMS4yMjUzMlxcXCIgLz5cXG4gICAgICAgICAgPGNpcmNsZVxcbiAgICAgICAgICAgICBzdHlsZT1cXFwib3BhY2l0eToxO2ZpbGw6IzRkNGQ0ZDtmaWxsLW9wYWNpdHk6MTtzdHJva2U6IzFhMWExYTtzdHJva2Utd2lkdGg6MC4xMTAzMTU4O3N0cm9rZS1taXRlcmxpbWl0OjQ7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjFcXFwiXFxuICAgICAgICAgICAgIGlkPVxcXCJwYXRoNDcwMi04LTYtMC0yLTJcXFwiXFxuICAgICAgICAgICAgIGN4PVxcXCI0OTcuMDYzOTNcXFwiXFxuICAgICAgICAgICAgIGN5PVxcXCItNDk1LjEzNDA2XFxcIlxcbiAgICAgICAgICAgICByPVxcXCI3LjgwMDUwMzdcXFwiIC8+XFxuICAgICAgICA8L2c+XFxuICAgICAgICA8Z1xcbiAgICAgICAgICAgc3R5bGU9XFxcImZpbGw6IzRkNGQ0ZDtmaWxsLW9wYWNpdHk6MVxcXCJcXG4gICAgICAgICAgIGlkPVxcXCJnNDczMS01LTgtMVxcXCJcXG4gICAgICAgICAgIHRyYW5zZm9ybT1cXFwidHJhbnNsYXRlKDI4Ny4wMjM3NiwxNTIuMTk3MSlcXFwiPlxcbiAgICAgICAgICA8Y2lyY2xlXFxuICAgICAgICAgICAgIHN0eWxlPVxcXCJvcGFjaXR5OjE7ZmlsbDojNGQ0ZDRkO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTojMWExYTFhO3N0cm9rZS13aWR0aDowLjE1ODc1O3N0cm9rZS1taXRlcmxpbWl0OjQ7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjFcXFwiXFxuICAgICAgICAgICAgIGlkPVxcXCJwYXRoNDcwMi00LTgtOVxcXCJcXG4gICAgICAgICAgICAgY3g9XFxcIjQ5Ny4xMjEzNFxcXCJcXG4gICAgICAgICAgICAgY3k9XFxcIi00OTUuMTg2ODlcXFwiXFxuICAgICAgICAgICAgIHI9XFxcIjExLjIyNTMyXFxcIiAvPlxcbiAgICAgICAgICA8Y2lyY2xlXFxuICAgICAgICAgICAgIHN0eWxlPVxcXCJvcGFjaXR5OjE7ZmlsbDojNGQ0ZDRkO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTojMWExYTFhO3N0cm9rZS13aWR0aDowLjExMDMxNTg7c3Ryb2tlLW1pdGVybGltaXQ6NDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MVxcXCJcXG4gICAgICAgICAgICAgaWQ9XFxcInBhdGg0NzAyLTgtNi01Ni00XFxcIlxcbiAgICAgICAgICAgICBjeD1cXFwiNDk3LjA2MzkzXFxcIlxcbiAgICAgICAgICAgICBjeT1cXFwiLTQ5NS4xMzQwNlxcXCJcXG4gICAgICAgICAgICAgcj1cXFwiNy44MDA1MDM3XFxcIiAvPlxcbiAgICAgICAgPC9nPlxcbiAgICAgICAgPGdcXG4gICAgICAgICAgIHN0eWxlPVxcXCJmaWxsOiM0ZDRkNGQ7ZmlsbC1vcGFjaXR5OjFcXFwiXFxuICAgICAgICAgICBpZD1cXFwiZzQ3MzEtNS03LTgtNlxcXCJcXG4gICAgICAgICAgIHRyYW5zZm9ybT1cXFwidHJhbnNsYXRlKDI4Ni44MzUyOSwxODYuNTYzNDkpXFxcIj5cXG4gICAgICAgICAgPGNpcmNsZVxcbiAgICAgICAgICAgICBzdHlsZT1cXFwib3BhY2l0eToxO2ZpbGw6IzRkNGQ0ZDtmaWxsLW9wYWNpdHk6MTtzdHJva2U6IzFhMWExYTtzdHJva2Utd2lkdGg6MC4xNTg3NTtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxXFxcIlxcbiAgICAgICAgICAgICBpZD1cXFwicGF0aDQ3MDItNC00LTUtOVxcXCJcXG4gICAgICAgICAgICAgY3g9XFxcIjQ5Ny4xMjEzNFxcXCJcXG4gICAgICAgICAgICAgY3k9XFxcIi00OTUuMTg2ODlcXFwiXFxuICAgICAgICAgICAgIHI9XFxcIjExLjIyNTMyXFxcIiAvPlxcbiAgICAgICAgICA8Y2lyY2xlXFxuICAgICAgICAgICAgIHN0eWxlPVxcXCJvcGFjaXR5OjE7ZmlsbDojNGQ0ZDRkO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTojMWExYTFhO3N0cm9rZS13aWR0aDowLjExMDMxNTg7c3Ryb2tlLW1pdGVybGltaXQ6NDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MVxcXCJcXG4gICAgICAgICAgICAgaWQ9XFxcInBhdGg0NzAyLTgtNi01LTktN1xcXCJcXG4gICAgICAgICAgICAgY3g9XFxcIjQ5Ny4wNjM5M1xcXCJcXG4gICAgICAgICAgICAgY3k9XFxcIi00OTUuMTM0MDZcXFwiXFxuICAgICAgICAgICAgIHI9XFxcIjcuODAwNTAzN1xcXCIgLz5cXG4gICAgICAgIDwvZz5cXG4gICAgICA8L2c+XFxuICAgICAgPHJlY3RcXG4gICAgICAgICBzdHlsZT1cXFwib3BhY2l0eToxO2ZpbGw6IzRkNGQ0ZDtmaWxsLW9wYWNpdHk6MTtzdHJva2U6IzFhMWExYTtzdHJva2Utd2lkdGg6MC4xMDMwNDg7c3Ryb2tlLW1pdGVybGltaXQ6NDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MVxcXCJcXG4gICAgICAgICBpZD1cXFwicmVjdDM5MDktMlxcXCJcXG4gICAgICAgICB3aWR0aD1cXFwiMTkuODkzMjk1XFxcIlxcbiAgICAgICAgIGhlaWdodD1cXFwiMzk5Ljc1MTI4XFxcIlxcbiAgICAgICAgIHg9XFxcIi04NS4wNDM3MTZcXFwiXFxuICAgICAgICAgeT1cXFwiLTIwLjA0Nzg1MlxcXCIgLz5cXG4gICAgPC9nPlxcbiAgPC9nPlxcbjwvc3ZnPlxcblwiXHJcbiAgICAgIF0sXHJcbiAgICAgIFwidHlwZVwiOiBcIndvb2RcIixcclxuICAgICAgXCJzaXplXCI6IDIsXHJcbiAgICAgIFwiaWRcIjogM1xyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgXCJpbWFnZXNcIjogW1xyXG4gICAgICAgIFwiPD94bWwgdmVyc2lvbj1cXFwiMS4wXFxcIiBlbmNvZGluZz1cXFwiVVRGLThcXFwiIHN0YW5kYWxvbmU9XFxcIm5vXFxcIj8+XFxuPHN2Z1xcbiAgIHhtbG5zOmRjPVxcXCJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xL1xcXCJcXG4gICB4bWxuczpjYz1cXFwiaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbnMjXFxcIlxcbiAgIHhtbG5zOnJkZj1cXFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zI1xcXCJcXG4gICB4bWxuczpzdmc9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIlxcbiAgIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCJcXG4gICB3aWR0aD1cXFwiNDQ0LjQ0NTMxbW1cXFwiXFxuICAgaGVpZ2h0PVxcXCI0NDQuNDQ0NDNtbVxcXCJcXG4gICB2aWV3Qm94PVxcXCIwIDAgNDAwLjAwMDc5IDM5OS45OTk5N1xcXCJcXG4gICB2ZXJzaW9uPVxcXCIxLjFcXFwiXFxuICAgaWQ9XFxcInN2ZzEzNzJcXFwiPlxcbiAgPGRlZnNcXG4gICAgIGlkPVxcXCJkZWZzMTM2NlxcXCIgLz5cXG4gIDxtZXRhZGF0YVxcbiAgICAgaWQ9XFxcIm1ldGFkYXRhMTM2OVxcXCI+XFxuICAgIDxyZGY6UkRGPlxcbiAgICAgIDxjYzpXb3JrXFxuICAgICAgICAgcmRmOmFib3V0PVxcXCJcXFwiPlxcbiAgICAgICAgPGRjOmZvcm1hdD5pbWFnZS9zdmcreG1sPC9kYzpmb3JtYXQ+XFxuICAgICAgICA8ZGM6dHlwZVxcbiAgICAgICAgICAgcmRmOnJlc291cmNlPVxcXCJodHRwOi8vcHVybC5vcmcvZGMvZGNtaXR5cGUvU3RpbGxJbWFnZVxcXCIgLz5cXG4gICAgICAgIDxkYzp0aXRsZT48L2RjOnRpdGxlPlxcbiAgICAgIDwvY2M6V29yaz5cXG4gICAgPC9yZGY6UkRGPlxcbiAgPC9tZXRhZGF0YT5cXG4gIDxnXFxuICAgICBpZD1cXFwibGF5ZXIxXFxcIlxcbiAgICAgdHJhbnNmb3JtPVxcXCJ0cmFuc2xhdGUoMCwxMDIuOTk5OTkpXFxcIj5cXG4gICAgPHBhdGhcXG4gICAgICAgZD1cXFwibSAwLDI5NyBoIDM5OS45ODIyNyBsIDAuMDE4NSwtMzk5Ljk5OTk5IEggMC4wMTc5OTEgWlxcXCJcXG4gICAgICAgc3R5bGU9XFxcImZpbGw6IzhlYzk1MztmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2Utd2lkdGg6MC4zNTI3Nzc0MlxcXCJcXG4gICAgICAgaWQ9XFxcInBhdGgxMDUxXFxcIiAvPlxcbiAgPC9nPlxcbjwvc3ZnPlxcblwiXHJcbiAgICAgIF0sXHJcbiAgICAgIFwidHlwZVwiOiBcIndvb2RcIixcclxuICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgIFwiaWRcIjogNFxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgXCJpbWFnZXNcIjogW1xyXG4gICAgICAgIFwiPD94bWwgdmVyc2lvbj1cXFwiMS4wXFxcIiBlbmNvZGluZz1cXFwiVVRGLThcXFwiIHN0YW5kYWxvbmU9XFxcIm5vXFxcIj8+XFxuPHN2Z1xcbiAgIHhtbG5zOmRjPVxcXCJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xL1xcXCJcXG4gICB4bWxuczpjYz1cXFwiaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbnMjXFxcIlxcbiAgIHhtbG5zOnJkZj1cXFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zI1xcXCJcXG4gICB4bWxuczpzdmc9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIlxcbiAgIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCJcXG4gICBpZD1cXFwic3ZnOFxcXCJcXG4gICB2ZXJzaW9uPVxcXCIxLjFcXFwiXFxuICAgdmlld0JveD1cXFwiMCAwIDQwMCAzOTkuOTk5OTdcXFwiXFxuICAgaGVpZ2h0PVxcXCIzOTkuOTk5OTdtbVxcXCJcXG4gICB3aWR0aD1cXFwiNDAwbW1cXFwiPlxcbiAgPGRlZnNcXG4gICAgIGlkPVxcXCJkZWZzMlxcXCIgLz5cXG4gIDxtZXRhZGF0YVxcbiAgICAgaWQ9XFxcIm1ldGFkYXRhNVxcXCI+XFxuICAgIDxyZGY6UkRGPlxcbiAgICAgIDxjYzpXb3JrXFxuICAgICAgICAgcmRmOmFib3V0PVxcXCJcXFwiPlxcbiAgICAgICAgPGRjOmZvcm1hdD5pbWFnZS9zdmcreG1sPC9kYzpmb3JtYXQ+XFxuICAgICAgICA8ZGM6dHlwZVxcbiAgICAgICAgICAgcmRmOnJlc291cmNlPVxcXCJodHRwOi8vcHVybC5vcmcvZGMvZGNtaXR5cGUvU3RpbGxJbWFnZVxcXCIgLz5cXG4gICAgICAgIDxkYzp0aXRsZT48L2RjOnRpdGxlPlxcbiAgICAgIDwvY2M6V29yaz5cXG4gICAgPC9yZGY6UkRGPlxcbiAgPC9tZXRhZGF0YT5cXG4gIDxnXFxuICAgICB0cmFuc2Zvcm09XFxcInRyYW5zbGF0ZSgxMTMuODIxMzgsNTUuNzAyMzk0KVxcXCJcXG4gICAgIGlkPVxcXCJsYXllcjFcXFwiPlxcbiAgICA8Z1xcbiAgICAgICB0cmFuc2Zvcm09XFxcIm1hdHJpeCgwLjM0Mzk2Nzg4LDAsMCwwLjM0NDIyMDg4LC00Mzc3LjUwNjgsNDI5OC4wNDQpXFxcIlxcbiAgICAgICBpZD1cXFwiTGF5ZXIxMDAyXFxcIj5cXG4gICAgICA8cGF0aFxcbiAgICAgICAgIGlkPVxcXCJwYXRoMTQ0XFxcIlxcbiAgICAgICAgIHN0eWxlPVxcXCJmaWxsOiNjYjMyMDA7ZmlsbC1ydWxlOmV2ZW5vZGRcXFwiXFxuICAgICAgICAgZD1cXFwibSAxMjM5NS43MjQsLTEyMDY3LjQ3OCB2IDI4My40NjUgaCAyOTcuNDIxIHYgLTI4My40NjUgelxcXCIgLz5cXG4gICAgICA8cGF0aFxcbiAgICAgICAgIGlkPVxcXCJwYXRoMTQ2XFxcIlxcbiAgICAgICAgIHN0eWxlPVxcXCJmaWxsOiNjYjMyMDA7ZmlsbC1ydWxlOmV2ZW5vZGRcXFwiXFxuICAgICAgICAgZD1cXFwibSAxMzI2MS4wNDcsLTEyMDY3LjQ3OCB2IDI4My40NjUgaCAyOTcuNDQ0IHYgLTI4My40NjUgelxcXCIgLz5cXG4gICAgICA8cGF0aFxcbiAgICAgICAgIGlkPVxcXCJwYXRoMTQ4XFxcIlxcbiAgICAgICAgIHN0eWxlPVxcXCJmaWxsOiNjYjMyMDA7ZmlsbC1ydWxlOmV2ZW5vZGRcXFwiXFxuICAgICAgICAgZD1cXFwibSAxMjM5NS43MjYsLTEyNjQ3Ljk0MSB2IDI5Ny41MjggaCAyOTcuNDE5IHYgLTI5Ny41MjggelxcXCIgLz5cXG4gICAgICA8cGF0aFxcbiAgICAgICAgIGlkPVxcXCJwYXRoMTUwXFxcIlxcbiAgICAgICAgIHN0eWxlPVxcXCJmaWxsOiNjYjMyMDA7ZmlsbC1ydWxlOmV2ZW5vZGRcXFwiXFxuICAgICAgICAgZD1cXFwibSAxMzI2MS4zMzEsLTEyNjQ3LjkwNyB2IDI5Ni45MjcgaCAyOTcgdiAtMjk2LjkyNyB6XFxcIiAvPlxcbiAgICAgIDxwYXRoXFxuICAgICAgICAgaWQ9XFxcInBhdGgxNTJcXFwiXFxuICAgICAgICAgc3R5bGU9XFxcImZpbGw6I2NiMzIwMDtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2U6IzFiMTkxODtzdHJva2Utd2lkdGg6MjguMzQ2NTAwNDtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2UtZGFzaGFycmF5Om5vbmVcXFwiXFxuICAgICAgICAgZD1cXFwibSAxMjQwOS43NjUsLTExNzgzLjcxMSB2IDI4My40NjQgaCA1NjYuOTI5IHYgLTI4My40NjQgelxcXCIgLz5cXG4gICAgICA8cGF0aFxcbiAgICAgICAgIGlkPVxcXCJwYXRoMTU0XFxcIlxcbiAgICAgICAgIHN0eWxlPVxcXCJmaWxsOiNjYjMyMDA7ZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlOiMxYjE5MTg7c3Ryb2tlLXdpZHRoOjI4LjM0NjUwMDQ7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLWRhc2hhcnJheTpub25lXFxcIlxcbiAgICAgICAgIGQ9XFxcIm0gMTI5NzcuMjk5LC0xMTc4My43MTEgdiAyODMuNDY0IGggNTY2LjkyOSB2IC0yODMuNDY0IHpcXFwiIC8+XFxuICAgICAgPHBhdGhcXG4gICAgICAgICBpZD1cXFwicGF0aDE1NlxcXCJcXG4gICAgICAgICBzdHlsZT1cXFwiZmlsbDojY2IzMjAwO2ZpbGwtcnVsZTpldmVub2RkO3N0cm9rZTojMWIxOTE4O3N0cm9rZS13aWR0aDoyOC4zNDY1MDA0O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1kYXNoYXJyYXk6bm9uZVxcXCJcXG4gICAgICAgICBkPVxcXCJtIDEyNjkzLjQ2NiwtMTIwNjcuNTQ0IHYgMjgzLjQ2NCBoIDU2Ni45MjkgdiAtMjgzLjQ2NCB6XFxcIiAvPlxcbiAgICAgIDxwYXRoXFxuICAgICAgICAgaWQ9XFxcInBhdGgxNThcXFwiXFxuICAgICAgICAgc3R5bGU9XFxcImZpbGw6I2NiMzIwMDtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2U6IzFiMTkxODtzdHJva2Utd2lkdGg6MjguMzQ2NTAwNDtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2UtZGFzaGFycmF5Om5vbmVcXFwiXFxuICAgICAgICAgZD1cXFwibSAxMjQwOS43NjUsLTEyMzUwLjExMiB2IDI4My40NjUgaCA1NjYuOTI5IHYgLTI4My40NjUgelxcXCIgLz5cXG4gICAgICA8cGF0aFxcbiAgICAgICAgIGlkPVxcXCJwYXRoMTYwXFxcIlxcbiAgICAgICAgIHN0eWxlPVxcXCJmaWxsOiNjYjMyMDA7ZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlOiMxYjE5MTg7c3Ryb2tlLXdpZHRoOjI4LjM0NjUwMDQ7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLWRhc2hhcnJheTpub25lXFxcIlxcbiAgICAgICAgIGQ9XFxcIm0gMTI5NzcuMjk5LC0xMjM1MC4xMTIgdiAyODMuNDY1IGggNTY2LjkyOSB2IC0yODMuNDY1IHpcXFwiIC8+XFxuICAgICAgPHBhdGhcXG4gICAgICAgICBpZD1cXFwicGF0aDE2MlxcXCJcXG4gICAgICAgICBzdHlsZT1cXFwiZmlsbDojY2IzMjAwO2ZpbGwtcnVsZTpldmVub2RkO3N0cm9rZTojMWIxOTE4O3N0cm9rZS13aWR0aDoyOC4zNDY1MDA0O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1kYXNoYXJyYXk6bm9uZVxcXCJcXG4gICAgICAgICBkPVxcXCJtIDEyNjkzLjQ2NiwtMTI2MzMuOTQ1IHYgMjgzLjQ2NSBoIDU2Ni45MjkgdiAtMjgzLjQ2NSB6XFxcIiAvPlxcbiAgICA8L2c+XFxuICA8L2c+XFxuPC9zdmc+XFxuXCJcclxuICAgICAgXSxcclxuICAgICAgXCJ0eXBlXCI6IFwic3RvbmVcIixcclxuICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgIFwiaWRcIjogNVxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgXCJpbWFnZXNcIjogW1xyXG4gICAgICAgIFwiPD94bWwgdmVyc2lvbj1cXFwiMS4wXFxcIiBlbmNvZGluZz1cXFwiVVRGLThcXFwiIHN0YW5kYWxvbmU9XFxcIm5vXFxcIj8+XFxuPHN2Z1xcbiAgIHhtbG5zOmRjPVxcXCJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xL1xcXCJcXG4gICB4bWxuczpjYz1cXFwiaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbnMjXFxcIlxcbiAgIHhtbG5zOnJkZj1cXFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zI1xcXCJcXG4gICB4bWxuczpzdmc9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIlxcbiAgIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCJcXG4gICBpZD1cXFwic3ZnNDAzN1xcXCJcXG4gICB2ZXJzaW9uPVxcXCIxLjFcXFwiXFxuICAgdmlld0JveD1cXFwiMCAwIDQwMCA0MDBcXFwiXFxuICAgaGVpZ2h0PVxcXCI0MDBtbVxcXCJcXG4gICB3aWR0aD1cXFwiNDAwbW1cXFwiPlxcbiAgPGRlZnNcXG4gICAgIGlkPVxcXCJkZWZzNDAzMVxcXCIgLz5cXG4gIDxtZXRhZGF0YVxcbiAgICAgaWQ9XFxcIm1ldGFkYXRhNDAzNFxcXCI+XFxuICAgIDxyZGY6UkRGPlxcbiAgICAgIDxjYzpXb3JrXFxuICAgICAgICAgcmRmOmFib3V0PVxcXCJcXFwiPlxcbiAgICAgICAgPGRjOmZvcm1hdD5pbWFnZS9zdmcreG1sPC9kYzpmb3JtYXQ+XFxuICAgICAgICA8ZGM6dHlwZVxcbiAgICAgICAgICAgcmRmOnJlc291cmNlPVxcXCJodHRwOi8vcHVybC5vcmcvZGMvZGNtaXR5cGUvU3RpbGxJbWFnZVxcXCIgLz5cXG4gICAgICAgIDxkYzp0aXRsZT48L2RjOnRpdGxlPlxcbiAgICAgIDwvY2M6V29yaz5cXG4gICAgPC9yZGY6UkRGPlxcbiAgPC9tZXRhZGF0YT5cXG4gIDxnXFxuICAgICB0cmFuc2Zvcm09XFxcInRyYW5zbGF0ZSgxLjQ3NTI3NDZlLTYsMTAzKVxcXCJcXG4gICAgIGlkPVxcXCJsYXllcjFcXFwiPlxcbiAgICA8Z1xcbiAgICAgICB0cmFuc2Zvcm09XFxcInJvdGF0ZSgtOTAsMTE2LjAzODY5LDk1Ljg2NjA3KVxcXCJcXG4gICAgICAgaWQ9XFxcImc1MjQzXFxcIj5cXG4gICAgICA8Z1xcbiAgICAgICAgIGlkPVxcXCJnNTA1OFxcXCJcXG4gICAgICAgICB0cmFuc2Zvcm09XFxcIm1hdHJpeCgwLjk5OTgxNzcxLDAsMCwwLjk5OTYzNTgxLC0zMy45NTQyNTQsNDMzLjcwNjY4KVxcXCI+XFxuICAgICAgICA8cGF0aFxcbiAgICAgICAgICAgaWQ9XFxcInBhdGgxMzgwLTRcXFwiXFxuICAgICAgICAgICBzdHlsZT1cXFwiZmlsbDojODA4MDgwO2ZpbGwtcnVsZTpldmVub2RkO3N0cm9rZS13aWR0aDowLjM1Mjc3NzY2XFxcIlxcbiAgICAgICAgICAgZD1cXFwiTSAtNTEuMDc3MzgyLC00NTQuMDQ0NjYgViAtNTQuMDQ0NjY4IEggMzQ4LjkyMjYyIFYgLTQ1NC4wNDQ2NiBaXFxcIiAvPlxcbiAgICAgICAgPHJlY3RcXG4gICAgICAgICAgIHk9XFxcIi00NTMuODk4NjhcXFwiXFxuICAgICAgICAgICB4PVxcXCItMTEuMDkxODc3XFxcIlxcbiAgICAgICAgICAgaGVpZ2h0PVxcXCIzOTkuODUzOTFcXFwiXFxuICAgICAgICAgICB3aWR0aD1cXFwiMzkuOTg1MzlcXFwiXFxuICAgICAgICAgICBpZD1cXFwicmVjdDM5MDktMi00NVxcXCJcXG4gICAgICAgICAgIHN0eWxlPVxcXCJvcGFjaXR5OjE7ZmlsbDojNGQ0ZDRkO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTojMWExYTFhO3N0cm9rZS13aWR0aDowLjE0NjExNDI2O3N0cm9rZS1taXRlcmxpbWl0OjQ7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjFcXFwiIC8+XFxuICAgICAgICA8cmVjdFxcbiAgICAgICAgICAgeT1cXFwiLTQ1My44OTg3NFxcXCJcXG4gICAgICAgICAgIHg9XFxcIjY4Ljg3ODg4M1xcXCJcXG4gICAgICAgICAgIGhlaWdodD1cXFwiMzk5Ljg1MzkxXFxcIlxcbiAgICAgICAgICAgd2lkdGg9XFxcIjM5Ljk4NTM5XFxcIlxcbiAgICAgICAgICAgaWQ9XFxcInJlY3QzOTA5LTItMC03XFxcIlxcbiAgICAgICAgICAgc3R5bGU9XFxcIm9wYWNpdHk6MTtmaWxsOiM0ZDRkNGQ7ZmlsbC1vcGFjaXR5OjE7c3Ryb2tlOiMxYTFhMWE7c3Ryb2tlLXdpZHRoOjAuMTQ2MTE0MjY7c3Ryb2tlLW1pdGVybGltaXQ6NDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MVxcXCIgLz5cXG4gICAgICAgIDxyZWN0XFxuICAgICAgICAgICB5PVxcXCItNDUzLjg5ODhcXFwiXFxuICAgICAgICAgICB4PVxcXCIxNDguODQ5NjdcXFwiXFxuICAgICAgICAgICBoZWlnaHQ9XFxcIjM5OS44NTM5MVxcXCJcXG4gICAgICAgICAgIHdpZHRoPVxcXCIzOS45ODUzOVxcXCJcXG4gICAgICAgICAgIGlkPVxcXCJyZWN0MzkwOS0yLTQtNFxcXCJcXG4gICAgICAgICAgIHN0eWxlPVxcXCJvcGFjaXR5OjE7ZmlsbDojNGQ0ZDRkO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTojMWExYTFhO3N0cm9rZS13aWR0aDowLjE0NjExNDI2O3N0cm9rZS1taXRlcmxpbWl0OjQ7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjFcXFwiIC8+XFxuICAgICAgICA8cmVjdFxcbiAgICAgICAgICAgeT1cXFwiLTQ1My44OTg4NlxcXCJcXG4gICAgICAgICAgIHg9XFxcIjIyOC44MjA0NVxcXCJcXG4gICAgICAgICAgIGhlaWdodD1cXFwiMzk5Ljg1MzkxXFxcIlxcbiAgICAgICAgICAgd2lkdGg9XFxcIjM5Ljk4NTM5XFxcIlxcbiAgICAgICAgICAgaWQ9XFxcInJlY3QzOTA5LTItMC01LTZcXFwiXFxuICAgICAgICAgICBzdHlsZT1cXFwib3BhY2l0eToxO2ZpbGw6IzRkNGQ0ZDtmaWxsLW9wYWNpdHk6MTtzdHJva2U6IzFhMWExYTtzdHJva2Utd2lkdGg6MC4xNDYxMTQyNjtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxXFxcIiAvPlxcbiAgICAgICAgPHJlY3RcXG4gICAgICAgICAgIHk9XFxcIi00NTMuODk4OTNcXFwiXFxuICAgICAgICAgICB4PVxcXCIzMDguNzkxMjNcXFwiXFxuICAgICAgICAgICBoZWlnaHQ9XFxcIjM5OS44NTM5MVxcXCJcXG4gICAgICAgICAgIHdpZHRoPVxcXCIzOS45ODUzOVxcXCJcXG4gICAgICAgICAgIGlkPVxcXCJyZWN0MzkwOS0yLTAtNS01LTdcXFwiXFxuICAgICAgICAgICBzdHlsZT1cXFwib3BhY2l0eToxO2ZpbGw6IzRkNGQ0ZDtmaWxsLW9wYWNpdHk6MTtzdHJva2U6IzFhMWExYTtzdHJva2Utd2lkdGg6MC4xNDYxMTQyNjtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxXFxcIiAvPlxcbiAgICAgIDwvZz5cXG4gICAgICA8Z1xcbiAgICAgICAgIGlkPVxcXCJnNTA1MFxcXCJcXG4gICAgICAgICB0cmFuc2Zvcm09XFxcIm1hdHJpeCgwLC0wLjk5OTYzNTgxLC0wLjk5OTgxNzcxLDAsLTEzOC4xMTk2MSw3OTYuODU0MjkpXFxcIj5cXG4gICAgICAgIDxwYXRoXFxuICAgICAgICAgICBpZD1cXFwicGF0aDEzODAtNlxcXCJcXG4gICAgICAgICAgIHN0eWxlPVxcXCJmaWxsOiNiM2IzYjM7ZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlLXdpZHRoOjAuMjQ5NDUxNDdcXFwiXFxuICAgICAgICAgICBkPVxcXCJtIDQxNy4xNzg4NCwtMjUyLjk3NTU4IGggMzk5Ljk5OTk5IHYgLTIwMCBIIDQxNy4xNzg4NCBaXFxcIiAvPlxcbiAgICAgICAgPHBhdGhcXG4gICAgICAgICAgIGlkPVxcXCJwYXRoMTM4MC0wXFxcIlxcbiAgICAgICAgICAgc3R5bGU9XFxcImZpbGw6IzgwODA4MDtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2Utd2lkdGg6MC4xMTE1NTgwOVxcXCJcXG4gICAgICAgICAgIGQ9XFxcIm0gNDE3LjE3ODg0LC0yNTIuOTc1NTggaCAzOTkuOTk5OTkgdiAtNDAgSCA0MTcuMTc4ODQgWlxcXCIgLz5cXG4gICAgICAgIDxwYXRoXFxuICAgICAgICAgICBpZD1cXFwicGF0aDEzODAtMC03XFxcIlxcbiAgICAgICAgICAgc3R5bGU9XFxcImZpbGw6IzgwODA4MDtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2Utd2lkdGg6MC4wNTU3NzkwNFxcXCJcXG4gICAgICAgICAgIGQ9XFxcIm0gNDM3LjE3ODg0LC0yNTIuOTc1NTggdiAtMjAwIGggLTIwIHYgMjAwIHpcXFwiIC8+XFxuICAgICAgICA8cGF0aFxcbiAgICAgICAgICAgaWQ9XFxcInBhdGgxMzgwLTAtNy02XFxcIlxcbiAgICAgICAgICAgc3R5bGU9XFxcImZpbGw6IzgwODA4MDtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2Utd2lkdGg6MC4wNTU3NzkwNFxcXCJcXG4gICAgICAgICAgIGQ9XFxcIm0gODE3LjE3ODgzLC0yNTIuOTc1NTggdiAtMjAwIGggLTIwIHYgMjAwIHpcXFwiIC8+XFxuICAgICAgICA8cGF0aFxcbiAgICAgICAgICAgaWQ9XFxcInBhdGgxMzgwLTAtNlxcXCJcXG4gICAgICAgICAgIHN0eWxlPVxcXCJmaWxsOiM0ZDRkNGQ7ZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlLXdpZHRoOjAuMDc4ODgzNDhcXFwiXFxuICAgICAgICAgICBkPVxcXCJtIDQxNy4xNzg4NCwtMjUyLjk3NTU4IGggMzk5Ljk5OTk5IHYgLTIwIEggNDE3LjE3ODg0IFpcXFwiIC8+XFxuICAgICAgICA8Z1xcbiAgICAgICAgICAgc3R5bGU9XFxcImZpbGw6IzRkNGQ0ZDtmaWxsLW9wYWNpdHk6MVxcXCJcXG4gICAgICAgICAgIGlkPVxcXCJnNDczMS01LTFcXFwiXFxuICAgICAgICAgICB0cmFuc2Zvcm09XFxcInRyYW5zbGF0ZSgtNDcuMTE4NzEyLDc3Ljg2MjAzKVxcXCI+XFxuICAgICAgICAgIDxjaXJjbGVcXG4gICAgICAgICAgICAgc3R5bGU9XFxcIm9wYWNpdHk6MTtmaWxsOiM0ZDRkNGQ7ZmlsbC1vcGFjaXR5OjE7c3Ryb2tlOiMxYTFhMWE7c3Ryb2tlLXdpZHRoOjAuMTU4NzU7c3Ryb2tlLW1pdGVybGltaXQ6NDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MVxcXCJcXG4gICAgICAgICAgICAgaWQ9XFxcInBhdGg0NzAyLTQtNlxcXCJcXG4gICAgICAgICAgICAgY3g9XFxcIjQ5Ny4xMjEzNFxcXCJcXG4gICAgICAgICAgICAgY3k9XFxcIi00OTUuMTg2ODlcXFwiXFxuICAgICAgICAgICAgIHI9XFxcIjExLjIyNTMyXFxcIiAvPlxcbiAgICAgICAgICA8Y2lyY2xlXFxuICAgICAgICAgICAgIHN0eWxlPVxcXCJvcGFjaXR5OjE7ZmlsbDojNGQ0ZDRkO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTojMWExYTFhO3N0cm9rZS13aWR0aDowLjExMDMxNTg7c3Ryb2tlLW1pdGVybGltaXQ6NDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MVxcXCJcXG4gICAgICAgICAgICAgaWQ9XFxcInBhdGg0NzAyLTgtNi0wXFxcIlxcbiAgICAgICAgICAgICBjeD1cXFwiNDk3LjA2MzkzXFxcIlxcbiAgICAgICAgICAgICBjeT1cXFwiLTQ5NS4xMzQwNlxcXCJcXG4gICAgICAgICAgICAgcj1cXFwiNy44MDA1MDM3XFxcIiAvPlxcbiAgICAgICAgPC9nPlxcbiAgICAgICAgPGdcXG4gICAgICAgICAgIHN0eWxlPVxcXCJmaWxsOiM0ZDRkNGQ7ZmlsbC1vcGFjaXR5OjFcXFwiXFxuICAgICAgICAgICBpZD1cXFwiZzQ3MzEtNS0xLTJcXFwiXFxuICAgICAgICAgICB0cmFuc2Zvcm09XFxcInRyYW5zbGF0ZSgtNDcuMDA0Nzg4LDExNC40MjA3MylcXFwiPlxcbiAgICAgICAgICA8Y2lyY2xlXFxuICAgICAgICAgICAgIHN0eWxlPVxcXCJvcGFjaXR5OjE7ZmlsbDojNGQ0ZDRkO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTojMWExYTFhO3N0cm9rZS13aWR0aDowLjE1ODc1O3N0cm9rZS1taXRlcmxpbWl0OjQ7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjFcXFwiXFxuICAgICAgICAgICAgIGlkPVxcXCJwYXRoNDcwMi00LTYtM1xcXCJcXG4gICAgICAgICAgICAgY3g9XFxcIjQ5Ny4xMjEzNFxcXCJcXG4gICAgICAgICAgICAgY3k9XFxcIi00OTUuMTg2ODlcXFwiXFxuICAgICAgICAgICAgIHI9XFxcIjExLjIyNTMyXFxcIiAvPlxcbiAgICAgICAgICA8Y2lyY2xlXFxuICAgICAgICAgICAgIHN0eWxlPVxcXCJvcGFjaXR5OjE7ZmlsbDojNGQ0ZDRkO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTojMWExYTFhO3N0cm9rZS13aWR0aDowLjExMDMxNTg7c3Ryb2tlLW1pdGVybGltaXQ6NDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MVxcXCJcXG4gICAgICAgICAgICAgaWQ9XFxcInBhdGg0NzAyLTgtNi0wLTJcXFwiXFxuICAgICAgICAgICAgIGN4PVxcXCI0OTcuMDYzOTNcXFwiXFxuICAgICAgICAgICAgIGN5PVxcXCItNDk1LjEzNDA2XFxcIlxcbiAgICAgICAgICAgICByPVxcXCI3LjgwMDUwMzdcXFwiIC8+XFxuICAgICAgICA8L2c+XFxuICAgICAgICA8Z1xcbiAgICAgICAgICAgc3R5bGU9XFxcImZpbGw6IzRkNGQ0ZDtmaWxsLW9wYWNpdHk6MVxcXCJcXG4gICAgICAgICAgIGlkPVxcXCJnNDczMS01LThcXFwiXFxuICAgICAgICAgICB0cmFuc2Zvcm09XFxcInRyYW5zbGF0ZSgtNDcuMTk3Njg0LDE1Mi41NjAzMSlcXFwiPlxcbiAgICAgICAgICA8Y2lyY2xlXFxuICAgICAgICAgICAgIHN0eWxlPVxcXCJvcGFjaXR5OjE7ZmlsbDojNGQ0ZDRkO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTojMWExYTFhO3N0cm9rZS13aWR0aDowLjE1ODc1O3N0cm9rZS1taXRlcmxpbWl0OjQ7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjFcXFwiXFxuICAgICAgICAgICAgIGlkPVxcXCJwYXRoNDcwMi00LThcXFwiXFxuICAgICAgICAgICAgIGN4PVxcXCI0OTcuMTIxMzRcXFwiXFxuICAgICAgICAgICAgIGN5PVxcXCItNDk1LjE4Njg5XFxcIlxcbiAgICAgICAgICAgICByPVxcXCIxMS4yMjUzMlxcXCIgLz5cXG4gICAgICAgICAgPGNpcmNsZVxcbiAgICAgICAgICAgICBzdHlsZT1cXFwib3BhY2l0eToxO2ZpbGw6IzRkNGQ0ZDtmaWxsLW9wYWNpdHk6MTtzdHJva2U6IzFhMWExYTtzdHJva2Utd2lkdGg6MC4xMTAzMTU4O3N0cm9rZS1taXRlcmxpbWl0OjQ7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjFcXFwiXFxuICAgICAgICAgICAgIGlkPVxcXCJwYXRoNDcwMi04LTYtNTZcXFwiXFxuICAgICAgICAgICAgIGN4PVxcXCI0OTcuMDYzOTNcXFwiXFxuICAgICAgICAgICAgIGN5PVxcXCItNDk1LjEzNDA2XFxcIlxcbiAgICAgICAgICAgICByPVxcXCI3LjgwMDUwMzdcXFwiIC8+XFxuICAgICAgICA8L2c+XFxuICAgICAgICA8Z1xcbiAgICAgICAgICAgc3R5bGU9XFxcImZpbGw6IzRkNGQ0ZDtmaWxsLW9wYWNpdHk6MVxcXCJcXG4gICAgICAgICAgIGlkPVxcXCJnNDczMS01LTctOFxcXCJcXG4gICAgICAgICAgIHRyYW5zZm9ybT1cXFwidHJhbnNsYXRlKC00Ny4zODYxNTgsMTg2LjkyNjcpXFxcIj5cXG4gICAgICAgICAgPGNpcmNsZVxcbiAgICAgICAgICAgICBzdHlsZT1cXFwib3BhY2l0eToxO2ZpbGw6IzRkNGQ0ZDtmaWxsLW9wYWNpdHk6MTtzdHJva2U6IzFhMWExYTtzdHJva2Utd2lkdGg6MC4xNTg3NTtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxXFxcIlxcbiAgICAgICAgICAgICBpZD1cXFwicGF0aDQ3MDItNC00LTVcXFwiXFxuICAgICAgICAgICAgIGN4PVxcXCI0OTcuMTIxMzRcXFwiXFxuICAgICAgICAgICAgIGN5PVxcXCItNDk1LjE4Njg5XFxcIlxcbiAgICAgICAgICAgICByPVxcXCIxMS4yMjUzMlxcXCIgLz5cXG4gICAgICAgICAgPGNpcmNsZVxcbiAgICAgICAgICAgICBzdHlsZT1cXFwib3BhY2l0eToxO2ZpbGw6IzRkNGQ0ZDtmaWxsLW9wYWNpdHk6MTtzdHJva2U6IzFhMWExYTtzdHJva2Utd2lkdGg6MC4xMTAzMTU4O3N0cm9rZS1taXRlcmxpbWl0OjQ7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjFcXFwiXFxuICAgICAgICAgICAgIGlkPVxcXCJwYXRoNDcwMi04LTYtNS05XFxcIlxcbiAgICAgICAgICAgICBjeD1cXFwiNDk3LjA2MzkzXFxcIlxcbiAgICAgICAgICAgICBjeT1cXFwiLTQ5NS4xMzQwNlxcXCJcXG4gICAgICAgICAgICAgcj1cXFwiNy44MDA1MDM3XFxcIiAvPlxcbiAgICAgICAgPC9nPlxcbiAgICAgICAgPHBhdGhcXG4gICAgICAgICAgIGlkPVxcXCJwYXRoMTM4MC0wLTlcXFwiXFxuICAgICAgICAgICBzdHlsZT1cXFwiZmlsbDojODA4MDgwO2ZpbGwtcnVsZTpldmVub2RkO3N0cm9rZS13aWR0aDowLjA3ODg4MzQ4XFxcIlxcbiAgICAgICAgICAgZD1cXFwibSA0MTcuMTc4ODQsLTQzMi45NzU1OCBoIDM5OS45OTk5OSB2IC0yMCBIIDQxNy4xNzg4NCBaXFxcIiAvPlxcbiAgICAgICAgPGdcXG4gICAgICAgICAgIHN0eWxlPVxcXCJmaWxsOiM0ZDRkNGQ7ZmlsbC1vcGFjaXR5OjFcXFwiXFxuICAgICAgICAgICBpZD1cXFwiZzQ3MzEtNS0xLThcXFwiXFxuICAgICAgICAgICB0cmFuc2Zvcm09XFxcInRyYW5zbGF0ZSgyODcuMTAyNzQsNzcuNDk4ODIyKVxcXCI+XFxuICAgICAgICAgIDxjaXJjbGVcXG4gICAgICAgICAgICAgc3R5bGU9XFxcIm9wYWNpdHk6MTtmaWxsOiM0ZDRkNGQ7ZmlsbC1vcGFjaXR5OjE7c3Ryb2tlOiMxYTFhMWE7c3Ryb2tlLXdpZHRoOjAuMTU4NzU7c3Ryb2tlLW1pdGVybGltaXQ6NDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MVxcXCJcXG4gICAgICAgICAgICAgaWQ9XFxcInBhdGg0NzAyLTQtNi03XFxcIlxcbiAgICAgICAgICAgICBjeD1cXFwiNDk3LjEyMTM0XFxcIlxcbiAgICAgICAgICAgICBjeT1cXFwiLTQ5NS4xODY4OVxcXCJcXG4gICAgICAgICAgICAgcj1cXFwiMTEuMjI1MzJcXFwiIC8+XFxuICAgICAgICAgIDxjaXJjbGVcXG4gICAgICAgICAgICAgc3R5bGU9XFxcIm9wYWNpdHk6MTtmaWxsOiM0ZDRkNGQ7ZmlsbC1vcGFjaXR5OjE7c3Ryb2tlOiMxYTFhMWE7c3Ryb2tlLXdpZHRoOjAuMTEwMzE1ODtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxXFxcIlxcbiAgICAgICAgICAgICBpZD1cXFwicGF0aDQ3MDItOC02LTAtM1xcXCJcXG4gICAgICAgICAgICAgY3g9XFxcIjQ5Ny4wNjM5M1xcXCJcXG4gICAgICAgICAgICAgY3k9XFxcIi00OTUuMTM0MDZcXFwiXFxuICAgICAgICAgICAgIHI9XFxcIjcuODAwNTAzN1xcXCIgLz5cXG4gICAgICAgIDwvZz5cXG4gICAgICAgIDxnXFxuICAgICAgICAgICBzdHlsZT1cXFwiZmlsbDojNGQ0ZDRkO2ZpbGwtb3BhY2l0eToxXFxcIlxcbiAgICAgICAgICAgaWQ9XFxcImc0NzMxLTUtMS0yLTVcXFwiXFxuICAgICAgICAgICB0cmFuc2Zvcm09XFxcInRyYW5zbGF0ZSgyODcuMjE2NjcsMTE0LjA1NzUyKVxcXCI+XFxuICAgICAgICAgIDxjaXJjbGVcXG4gICAgICAgICAgICAgc3R5bGU9XFxcIm9wYWNpdHk6MTtmaWxsOiM0ZDRkNGQ7ZmlsbC1vcGFjaXR5OjE7c3Ryb2tlOiMxYTFhMWE7c3Ryb2tlLXdpZHRoOjAuMTU4NzU7c3Ryb2tlLW1pdGVybGltaXQ6NDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MVxcXCJcXG4gICAgICAgICAgICAgaWQ9XFxcInBhdGg0NzAyLTQtNi0zLThcXFwiXFxuICAgICAgICAgICAgIGN4PVxcXCI0OTcuMTIxMzRcXFwiXFxuICAgICAgICAgICAgIGN5PVxcXCItNDk1LjE4Njg5XFxcIlxcbiAgICAgICAgICAgICByPVxcXCIxMS4yMjUzMlxcXCIgLz5cXG4gICAgICAgICAgPGNpcmNsZVxcbiAgICAgICAgICAgICBzdHlsZT1cXFwib3BhY2l0eToxO2ZpbGw6IzRkNGQ0ZDtmaWxsLW9wYWNpdHk6MTtzdHJva2U6IzFhMWExYTtzdHJva2Utd2lkdGg6MC4xMTAzMTU4O3N0cm9rZS1taXRlcmxpbWl0OjQ7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjFcXFwiXFxuICAgICAgICAgICAgIGlkPVxcXCJwYXRoNDcwMi04LTYtMC0yLTJcXFwiXFxuICAgICAgICAgICAgIGN4PVxcXCI0OTcuMDYzOTNcXFwiXFxuICAgICAgICAgICAgIGN5PVxcXCItNDk1LjEzNDA2XFxcIlxcbiAgICAgICAgICAgICByPVxcXCI3LjgwMDUwMzdcXFwiIC8+XFxuICAgICAgICA8L2c+XFxuICAgICAgICA8Z1xcbiAgICAgICAgICAgc3R5bGU9XFxcImZpbGw6IzRkNGQ0ZDtmaWxsLW9wYWNpdHk6MVxcXCJcXG4gICAgICAgICAgIGlkPVxcXCJnNDczMS01LTgtMVxcXCJcXG4gICAgICAgICAgIHRyYW5zZm9ybT1cXFwidHJhbnNsYXRlKDI4Ny4wMjM3NiwxNTIuMTk3MSlcXFwiPlxcbiAgICAgICAgICA8Y2lyY2xlXFxuICAgICAgICAgICAgIHN0eWxlPVxcXCJvcGFjaXR5OjE7ZmlsbDojNGQ0ZDRkO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTojMWExYTFhO3N0cm9rZS13aWR0aDowLjE1ODc1O3N0cm9rZS1taXRlcmxpbWl0OjQ7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjFcXFwiXFxuICAgICAgICAgICAgIGlkPVxcXCJwYXRoNDcwMi00LTgtOVxcXCJcXG4gICAgICAgICAgICAgY3g9XFxcIjQ5Ny4xMjEzNFxcXCJcXG4gICAgICAgICAgICAgY3k9XFxcIi00OTUuMTg2ODlcXFwiXFxuICAgICAgICAgICAgIHI9XFxcIjExLjIyNTMyXFxcIiAvPlxcbiAgICAgICAgICA8Y2lyY2xlXFxuICAgICAgICAgICAgIHN0eWxlPVxcXCJvcGFjaXR5OjE7ZmlsbDojNGQ0ZDRkO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTojMWExYTFhO3N0cm9rZS13aWR0aDowLjExMDMxNTg7c3Ryb2tlLW1pdGVybGltaXQ6NDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MVxcXCJcXG4gICAgICAgICAgICAgaWQ9XFxcInBhdGg0NzAyLTgtNi01Ni00XFxcIlxcbiAgICAgICAgICAgICBjeD1cXFwiNDk3LjA2MzkzXFxcIlxcbiAgICAgICAgICAgICBjeT1cXFwiLTQ5NS4xMzQwNlxcXCJcXG4gICAgICAgICAgICAgcj1cXFwiNy44MDA1MDM3XFxcIiAvPlxcbiAgICAgICAgPC9nPlxcbiAgICAgICAgPGdcXG4gICAgICAgICAgIHN0eWxlPVxcXCJmaWxsOiM0ZDRkNGQ7ZmlsbC1vcGFjaXR5OjFcXFwiXFxuICAgICAgICAgICBpZD1cXFwiZzQ3MzEtNS03LTgtNlxcXCJcXG4gICAgICAgICAgIHRyYW5zZm9ybT1cXFwidHJhbnNsYXRlKDI4Ni44MzUyOSwxODYuNTYzNDkpXFxcIj5cXG4gICAgICAgICAgPGNpcmNsZVxcbiAgICAgICAgICAgICBzdHlsZT1cXFwib3BhY2l0eToxO2ZpbGw6IzRkNGQ0ZDtmaWxsLW9wYWNpdHk6MTtzdHJva2U6IzFhMWExYTtzdHJva2Utd2lkdGg6MC4xNTg3NTtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxXFxcIlxcbiAgICAgICAgICAgICBpZD1cXFwicGF0aDQ3MDItNC00LTUtOVxcXCJcXG4gICAgICAgICAgICAgY3g9XFxcIjQ5Ny4xMjEzNFxcXCJcXG4gICAgICAgICAgICAgY3k9XFxcIi00OTUuMTg2ODlcXFwiXFxuICAgICAgICAgICAgIHI9XFxcIjExLjIyNTMyXFxcIiAvPlxcbiAgICAgICAgICA8Y2lyY2xlXFxuICAgICAgICAgICAgIHN0eWxlPVxcXCJvcGFjaXR5OjE7ZmlsbDojNGQ0ZDRkO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTojMWExYTFhO3N0cm9rZS13aWR0aDowLjExMDMxNTg7c3Ryb2tlLW1pdGVybGltaXQ6NDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MVxcXCJcXG4gICAgICAgICAgICAgaWQ9XFxcInBhdGg0NzAyLTgtNi01LTktN1xcXCJcXG4gICAgICAgICAgICAgY3g9XFxcIjQ5Ny4wNjM5M1xcXCJcXG4gICAgICAgICAgICAgY3k9XFxcIi00OTUuMTM0MDZcXFwiXFxuICAgICAgICAgICAgIHI9XFxcIjcuODAwNTAzN1xcXCIgLz5cXG4gICAgICAgIDwvZz5cXG4gICAgICA8L2c+XFxuICAgICAgPHJlY3RcXG4gICAgICAgICBzdHlsZT1cXFwib3BhY2l0eToxO2ZpbGw6IzRkNGQ0ZDtmaWxsLW9wYWNpdHk6MTtzdHJva2U6IzFhMWExYTtzdHJva2Utd2lkdGg6MC4xMDMwNDg7c3Ryb2tlLW1pdGVybGltaXQ6NDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MVxcXCJcXG4gICAgICAgICBpZD1cXFwicmVjdDM5MDktMlxcXCJcXG4gICAgICAgICB3aWR0aD1cXFwiMTkuODkzMjk1XFxcIlxcbiAgICAgICAgIGhlaWdodD1cXFwiMzk5Ljc1MTI4XFxcIlxcbiAgICAgICAgIHg9XFxcIi04NS4wNDM3MTZcXFwiXFxuICAgICAgICAgeT1cXFwiLTIwLjA0Nzg1MlxcXCIgLz5cXG4gICAgPC9nPlxcbiAgPC9nPlxcbjwvc3ZnPlxcblwiXHJcbiAgICAgIF0sXHJcbiAgICAgIFwidHlwZVwiOiBcInNwYXduZXJcIixcclxuICAgICAgXCJzaXplXCI6IDIsXHJcbiAgICAgIFwiaWRcIjogNlxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgXCJpbWFnZXNcIjogW1xyXG4gICAgICAgIFwiPD94bWwgdmVyc2lvbj1cXFwiMS4wXFxcIiBlbmNvZGluZz1cXFwiVVRGLThcXFwiIHN0YW5kYWxvbmU9XFxcIm5vXFxcIj8+XFxuPHN2Z1xcbiAgIHhtbG5zOmRjPVxcXCJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xL1xcXCJcXG4gICB4bWxuczpjYz1cXFwiaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbnMjXFxcIlxcbiAgIHhtbG5zOnJkZj1cXFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zI1xcXCJcXG4gICB4bWxuczpzdmc9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIlxcbiAgIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCJcXG4gICBpZD1cXFwic3ZnMTkyM1xcXCJcXG4gICB2ZXJzaW9uPVxcXCIxLjFcXFwiXFxuICAgdmlld0JveD1cXFwiMCAwIDQwMC4wMDA4OCAzOTkuOTk4OVxcXCJcXG4gICBoZWlnaHQ9XFxcIjM5OS45OTg5bW1cXFwiXFxuICAgd2lkdGg9XFxcIjQwMC4wMDA4OW1tXFxcIj5cXG4gIDxkZWZzXFxuICAgICBpZD1cXFwiZGVmczE5MTdcXFwiIC8+XFxuICA8bWV0YWRhdGFcXG4gICAgIGlkPVxcXCJtZXRhZGF0YTE5MjBcXFwiPlxcbiAgICA8cmRmOlJERj5cXG4gICAgICA8Y2M6V29ya1xcbiAgICAgICAgIHJkZjphYm91dD1cXFwiXFxcIj5cXG4gICAgICAgIDxkYzpmb3JtYXQ+aW1hZ2Uvc3ZnK3htbDwvZGM6Zm9ybWF0PlxcbiAgICAgICAgPGRjOnR5cGVcXG4gICAgICAgICAgIHJkZjpyZXNvdXJjZT1cXFwiaHR0cDovL3B1cmwub3JnL2RjL2RjbWl0eXBlL1N0aWxsSW1hZ2VcXFwiIC8+XFxuICAgICAgICA8ZGM6dGl0bGU+PC9kYzp0aXRsZT5cXG4gICAgICA8L2NjOldvcms+XFxuICAgIDwvcmRmOlJERj5cXG4gIDwvbWV0YWRhdGE+XFxuICA8Z1xcbiAgICAgdHJhbnNmb3JtPVxcXCJ0cmFuc2xhdGUoMTAzLjA4NTI0LDM4LjYwODc3KVxcXCJcXG4gICAgIGlkPVxcXCJsYXllcjFcXFwiPlxcbiAgICA8Z1xcbiAgICAgICBpZD1cXFwiXzE4MDYyNzkzOTYzMDRcXFwiXFxuICAgICAgIHN0eWxlPVxcXCJjbGlwLXJ1bGU6ZXZlbm9kZDtmaWxsLXJ1bGU6ZXZlbm9kZDtpbWFnZS1yZW5kZXJpbmc6b3B0aW1pemVRdWFsaXR5O3NoYXBlLXJlbmRlcmluZzpnZW9tZXRyaWNQcmVjaXNpb247dGV4dC1yZW5kZXJpbmc6Z2VvbWV0cmljUHJlY2lzaW9uXFxcIlxcbiAgICAgICB0cmFuc2Zvcm09XFxcIm1hdHJpeCgwLjAwOTc4NTkyLDAsMCwwLjAwOTc1NTgxLC01NDguNzM3NzYsMzg1LjEwODYpXFxcIj5cXG4gICAgICA8cmVjdFxcbiAgICAgICAgIGNsYXNzPVxcXCJmaWwyIHN0cjFcXFwiXFxuICAgICAgICAgdHJhbnNmb3JtPVxcXCJtYXRyaXgoMCwtMS4wMDA5MywxLjA5NDU2LDAsNzc3MDcsLTM2MzcuOTkpXFxcIlxcbiAgICAgICAgIHdpZHRoPVxcXCIzODQzOVxcXCJcXG4gICAgICAgICBoZWlnaHQ9XFxcIjc1NTZcXFwiXFxuICAgICAgICAgcng9XFxcIjE0ODJcXFwiXFxuICAgICAgICAgcnk9XFxcIjE0ODJcXFwiXFxuICAgICAgICAgaWQ9XFxcInJlY3Q0MTM5XFxcIlxcbiAgICAgICAgIHg9XFxcIjBcXFwiXFxuICAgICAgICAgeT1cXFwiMFxcXCJcXG4gICAgICAgICBzdHlsZT1cXFwiZmlsbDojN2Q4ZWE1O3N0cm9rZTojMmMyYTI5O3N0cm9rZS13aWR0aDo4MDBcXFwiIC8+XFxuICAgICAgPHJlY3RcXG4gICAgICAgICBjbGFzcz1cXFwiZmlsMyBzdHIxXFxcIlxcbiAgICAgICAgIHRyYW5zZm9ybT1cXFwibWF0cml4KDAsLTAuODE4NTQsMC45NjAxMTQsMCw3NzczNy44LC00ODY2LjgpXFxcIlxcbiAgICAgICAgIHdpZHRoPVxcXCIxMjI4XFxcIlxcbiAgICAgICAgIGhlaWdodD1cXFwiODU1MVxcXCJcXG4gICAgICAgICByeD1cXFwiNTUzXFxcIlxcbiAgICAgICAgIHJ5PVxcXCI1NTNcXFwiXFxuICAgICAgICAgaWQ9XFxcInJlY3Q0MTQxXFxcIlxcbiAgICAgICAgIHg9XFxcIjBcXFwiXFxuICAgICAgICAgeT1cXFwiMFxcXCJcXG4gICAgICAgICBzdHlsZT1cXFwiZmlsbDojNDk0ODQ4O3N0cm9rZTojMmMyYTI5O3N0cm9rZS13aWR0aDo4MDBcXFwiIC8+XFxuICAgICAgPHJlY3RcXG4gICAgICAgICBjbGFzcz1cXFwiZmlsMyBzdHIxXFxcIlxcbiAgICAgICAgIHRyYW5zZm9ybT1cXFwibWF0cml4KDAsLTAuODE4NTQsMC45NjAxMTQsMCw3NzczNy44LC04NzE2LjcxKVxcXCJcXG4gICAgICAgICB3aWR0aD1cXFwiMTIyOFxcXCJcXG4gICAgICAgICBoZWlnaHQ9XFxcIjg1NTFcXFwiXFxuICAgICAgICAgaWQ9XFxcInJlY3Q0MTQzXFxcIlxcbiAgICAgICAgIHg9XFxcIjBcXFwiXFxuICAgICAgICAgeT1cXFwiMFxcXCJcXG4gICAgICAgICBzdHlsZT1cXFwiZmlsbDojNDk0ODQ4O3N0cm9rZTojMmMyYTI5O3N0cm9rZS13aWR0aDo4MDBcXFwiIC8+XFxuICAgICAgPHJlY3RcXG4gICAgICAgICBjbGFzcz1cXFwiZmlsMyBzdHIxXFxcIlxcbiAgICAgICAgIHRyYW5zZm9ybT1cXFwibWF0cml4KDAsLTAuODE4NTQsMC45NjAxMTQsMCw3NzczNy44LC0xMjU5My44KVxcXCJcXG4gICAgICAgICB3aWR0aD1cXFwiMTIyOFxcXCJcXG4gICAgICAgICBoZWlnaHQ9XFxcIjg1NTFcXFwiXFxuICAgICAgICAgaWQ9XFxcInJlY3Q0MTQ1XFxcIlxcbiAgICAgICAgIHg9XFxcIjBcXFwiXFxuICAgICAgICAgeT1cXFwiMFxcXCJcXG4gICAgICAgICBzdHlsZT1cXFwiZmlsbDojNDk0ODQ4O3N0cm9rZTojMmMyYTI5O3N0cm9rZS13aWR0aDo4MDBcXFwiIC8+XFxuICAgICAgPHJlY3RcXG4gICAgICAgICBjbGFzcz1cXFwiZmlsMyBzdHIxXFxcIlxcbiAgICAgICAgIHRyYW5zZm9ybT1cXFwibWF0cml4KDAsLTAuODE4NTQsMC45NjAxMTQsMCw3NzczNy44LC0xNjUxOS40KVxcXCJcXG4gICAgICAgICB3aWR0aD1cXFwiMTIyOFxcXCJcXG4gICAgICAgICBoZWlnaHQ9XFxcIjg1NTFcXFwiXFxuICAgICAgICAgaWQ9XFxcInJlY3Q0MTQ3XFxcIlxcbiAgICAgICAgIHg9XFxcIjBcXFwiXFxuICAgICAgICAgeT1cXFwiMFxcXCJcXG4gICAgICAgICBzdHlsZT1cXFwiZmlsbDojNDk0ODQ4O3N0cm9rZTojMmMyYTI5O3N0cm9rZS13aWR0aDo4MDBcXFwiIC8+XFxuICAgICAgPHJlY3RcXG4gICAgICAgICBjbGFzcz1cXFwiZmlsMyBzdHIxXFxcIlxcbiAgICAgICAgIHRyYW5zZm9ybT1cXFwibWF0cml4KDAsLTAuODE4NTQsMC45NjAxMTQsMCw3NzczNy44LC0yMDM2OS4zKVxcXCJcXG4gICAgICAgICB3aWR0aD1cXFwiMTIyOFxcXCJcXG4gICAgICAgICBoZWlnaHQ9XFxcIjg1NTFcXFwiXFxuICAgICAgICAgaWQ9XFxcInJlY3Q0MTQ5XFxcIlxcbiAgICAgICAgIHg9XFxcIjBcXFwiXFxuICAgICAgICAgeT1cXFwiMFxcXCJcXG4gICAgICAgICBzdHlsZT1cXFwiZmlsbDojNDk0ODQ4O3N0cm9rZTojMmMyYTI5O3N0cm9rZS13aWR0aDo4MDBcXFwiIC8+XFxuICAgICAgPHJlY3RcXG4gICAgICAgICBjbGFzcz1cXFwiZmlsMyBzdHIxXFxcIlxcbiAgICAgICAgIHRyYW5zZm9ybT1cXFwibWF0cml4KDAsLTAuODE4NTQsMC45NjAxMTQsMCw3NzczNy44LC0yNDI0Ni40KVxcXCJcXG4gICAgICAgICB3aWR0aD1cXFwiMTIyOFxcXCJcXG4gICAgICAgICBoZWlnaHQ9XFxcIjg1NTFcXFwiXFxuICAgICAgICAgaWQ9XFxcInJlY3Q0MTUxXFxcIlxcbiAgICAgICAgIHg9XFxcIjBcXFwiXFxuICAgICAgICAgeT1cXFwiMFxcXCJcXG4gICAgICAgICBzdHlsZT1cXFwiZmlsbDojNDk0ODQ4O3N0cm9rZTojMmMyYTI5O3N0cm9rZS13aWR0aDo4MDBcXFwiIC8+XFxuICAgICAgPHJlY3RcXG4gICAgICAgICBjbGFzcz1cXFwiZmlsMyBzdHIxXFxcIlxcbiAgICAgICAgIHRyYW5zZm9ybT1cXFwibWF0cml4KDAsLTAuODE4NTQsMC45NjAxMTQsMCw3NzczNy44LC0yODIzNS41KVxcXCJcXG4gICAgICAgICB3aWR0aD1cXFwiMTIyOFxcXCJcXG4gICAgICAgICBoZWlnaHQ9XFxcIjg1NTFcXFwiXFxuICAgICAgICAgaWQ9XFxcInJlY3Q0MTUzXFxcIlxcbiAgICAgICAgIHg9XFxcIjBcXFwiXFxuICAgICAgICAgeT1cXFwiMFxcXCJcXG4gICAgICAgICBzdHlsZT1cXFwiZmlsbDojNDk0ODQ4O3N0cm9rZTojMmMyYTI5O3N0cm9rZS13aWR0aDo4MDBcXFwiIC8+XFxuICAgICAgPHJlY3RcXG4gICAgICAgICBjbGFzcz1cXFwiZmlsMyBzdHIxXFxcIlxcbiAgICAgICAgIHRyYW5zZm9ybT1cXFwibWF0cml4KDAsLTAuODE4NTQsMC45NjAxMTQsMCw3NzczNy44LC0zMjA4NS40KVxcXCJcXG4gICAgICAgICB3aWR0aD1cXFwiMTIyOFxcXCJcXG4gICAgICAgICBoZWlnaHQ9XFxcIjg1NTFcXFwiXFxuICAgICAgICAgaWQ9XFxcInJlY3Q0MTU1XFxcIlxcbiAgICAgICAgIHg9XFxcIjBcXFwiXFxuICAgICAgICAgeT1cXFwiMFxcXCJcXG4gICAgICAgICBzdHlsZT1cXFwiZmlsbDojNDk0ODQ4O3N0cm9rZTojMmMyYTI5O3N0cm9rZS13aWR0aDo4MDBcXFwiIC8+XFxuICAgICAgPHJlY3RcXG4gICAgICAgICBjbGFzcz1cXFwiZmlsMyBzdHIxXFxcIlxcbiAgICAgICAgIHRyYW5zZm9ybT1cXFwibWF0cml4KDAsLTAuODE4NTQsMC45NjAxMTQsMCw3NzczNy44LC0zNTk2Mi41KVxcXCJcXG4gICAgICAgICB3aWR0aD1cXFwiMTIyOFxcXCJcXG4gICAgICAgICBoZWlnaHQ9XFxcIjg1NTFcXFwiXFxuICAgICAgICAgaWQ9XFxcInJlY3Q0MTU3XFxcIlxcbiAgICAgICAgIHg9XFxcIjBcXFwiXFxuICAgICAgICAgeT1cXFwiMFxcXCJcXG4gICAgICAgICBzdHlsZT1cXFwiZmlsbDojNDk0ODQ4O3N0cm9rZTojMmMyYTI5O3N0cm9rZS13aWR0aDo4MDBcXFwiIC8+XFxuICAgICAgPHJlY3RcXG4gICAgICAgICBjbGFzcz1cXFwiZmlsMyBzdHIxXFxcIlxcbiAgICAgICAgIHRyYW5zZm9ybT1cXFwibWF0cml4KDAsLTAuODE4NTQsMC45NjAxMTQsMCw3NzczNy44LC0zOTkwMy4xKVxcXCJcXG4gICAgICAgICB3aWR0aD1cXFwiMTIyOFxcXCJcXG4gICAgICAgICBoZWlnaHQ9XFxcIjg1NTFcXFwiXFxuICAgICAgICAgcng9XFxcIjUwOVxcXCJcXG4gICAgICAgICByeT1cXFwiNTA5XFxcIlxcbiAgICAgICAgIGlkPVxcXCJyZWN0NDE1OVxcXCJcXG4gICAgICAgICB4PVxcXCIwXFxcIlxcbiAgICAgICAgIHk9XFxcIjBcXFwiXFxuICAgICAgICAgc3R5bGU9XFxcImZpbGw6IzQ5NDg0ODtzdHJva2U6IzJjMmEyOTtzdHJva2Utd2lkdGg6ODAwXFxcIiAvPlxcbiAgICAgIDxyZWN0XFxuICAgICAgICAgY2xhc3M9XFxcImZpbDIgc3RyMVxcXCJcXG4gICAgICAgICB0cmFuc2Zvcm09XFxcIm1hdHJpeCgwLC0xLjAwMDkzLDEuMDk0NTYsMCw0NTk3OCwtMzYzNy45OSlcXFwiXFxuICAgICAgICAgd2lkdGg9XFxcIjM4NDM5XFxcIlxcbiAgICAgICAgIGhlaWdodD1cXFwiNzU1NlxcXCJcXG4gICAgICAgICByeD1cXFwiMTQ4MlxcXCJcXG4gICAgICAgICByeT1cXFwiMTQ4MlxcXCJcXG4gICAgICAgICBpZD1cXFwicmVjdDQxNjFcXFwiXFxuICAgICAgICAgeD1cXFwiMFxcXCJcXG4gICAgICAgICB5PVxcXCIwXFxcIlxcbiAgICAgICAgIHN0eWxlPVxcXCJmaWxsOiM3ZDhlYTU7c3Ryb2tlOiMyYzJhMjk7c3Ryb2tlLXdpZHRoOjgwMFxcXCIgLz5cXG4gICAgICA8cmVjdFxcbiAgICAgICAgIGNsYXNzPVxcXCJmaWwzIHN0cjFcXFwiXFxuICAgICAgICAgdHJhbnNmb3JtPVxcXCJtYXRyaXgoMCwtMC44MTg1NCwwLjk2MDExNCwwLDQ2MDA4LjgsLTQ4NjYuOClcXFwiXFxuICAgICAgICAgd2lkdGg9XFxcIjEyMjhcXFwiXFxuICAgICAgICAgaGVpZ2h0PVxcXCI4NTUxXFxcIlxcbiAgICAgICAgIHJ4PVxcXCI1NTNcXFwiXFxuICAgICAgICAgcnk9XFxcIjU1M1xcXCJcXG4gICAgICAgICBpZD1cXFwicmVjdDQxNjNcXFwiXFxuICAgICAgICAgeD1cXFwiMFxcXCJcXG4gICAgICAgICB5PVxcXCIwXFxcIlxcbiAgICAgICAgIHN0eWxlPVxcXCJmaWxsOiM0OTQ4NDg7c3Ryb2tlOiMyYzJhMjk7c3Ryb2tlLXdpZHRoOjgwMFxcXCIgLz5cXG4gICAgICA8cmVjdFxcbiAgICAgICAgIGNsYXNzPVxcXCJmaWwzIHN0cjFcXFwiXFxuICAgICAgICAgdHJhbnNmb3JtPVxcXCJtYXRyaXgoMCwtMC44MTg1NCwwLjk2MDExNCwwLDQ2MDA4LjgsLTg3MTYuNzEpXFxcIlxcbiAgICAgICAgIHdpZHRoPVxcXCIxMjI4XFxcIlxcbiAgICAgICAgIGhlaWdodD1cXFwiODU1MVxcXCJcXG4gICAgICAgICBpZD1cXFwicmVjdDQxNjVcXFwiXFxuICAgICAgICAgeD1cXFwiMFxcXCJcXG4gICAgICAgICB5PVxcXCIwXFxcIlxcbiAgICAgICAgIHN0eWxlPVxcXCJmaWxsOiM0OTQ4NDg7c3Ryb2tlOiMyYzJhMjk7c3Ryb2tlLXdpZHRoOjgwMFxcXCIgLz5cXG4gICAgICA8cmVjdFxcbiAgICAgICAgIGNsYXNzPVxcXCJmaWwzIHN0cjFcXFwiXFxuICAgICAgICAgdHJhbnNmb3JtPVxcXCJtYXRyaXgoMCwtMC44MTg1NCwwLjk2MDExNCwwLDQ2MDA4LjgsLTEyNTkzLjgpXFxcIlxcbiAgICAgICAgIHdpZHRoPVxcXCIxMjI4XFxcIlxcbiAgICAgICAgIGhlaWdodD1cXFwiODU1MVxcXCJcXG4gICAgICAgICBpZD1cXFwicmVjdDQxNjdcXFwiXFxuICAgICAgICAgeD1cXFwiMFxcXCJcXG4gICAgICAgICB5PVxcXCIwXFxcIlxcbiAgICAgICAgIHN0eWxlPVxcXCJmaWxsOiM0OTQ4NDg7c3Ryb2tlOiMyYzJhMjk7c3Ryb2tlLXdpZHRoOjgwMFxcXCIgLz5cXG4gICAgICA8cmVjdFxcbiAgICAgICAgIGNsYXNzPVxcXCJmaWwzIHN0cjFcXFwiXFxuICAgICAgICAgdHJhbnNmb3JtPVxcXCJtYXRyaXgoMCwtMC44MTg1NCwwLjk2MDExNCwwLDQ2MDA4LjgsLTE2NTE5LjQpXFxcIlxcbiAgICAgICAgIHdpZHRoPVxcXCIxMjI4XFxcIlxcbiAgICAgICAgIGhlaWdodD1cXFwiODU1MVxcXCJcXG4gICAgICAgICBpZD1cXFwicmVjdDQxNjlcXFwiXFxuICAgICAgICAgeD1cXFwiMFxcXCJcXG4gICAgICAgICB5PVxcXCIwXFxcIlxcbiAgICAgICAgIHN0eWxlPVxcXCJmaWxsOiM0OTQ4NDg7c3Ryb2tlOiMyYzJhMjk7c3Ryb2tlLXdpZHRoOjgwMFxcXCIgLz5cXG4gICAgICA8cmVjdFxcbiAgICAgICAgIGNsYXNzPVxcXCJmaWwzIHN0cjFcXFwiXFxuICAgICAgICAgdHJhbnNmb3JtPVxcXCJtYXRyaXgoMCwtMC44MTg1NCwwLjk2MDExNCwwLDQ2MDA4LjgsLTIwMzY5LjMpXFxcIlxcbiAgICAgICAgIHdpZHRoPVxcXCIxMjI4XFxcIlxcbiAgICAgICAgIGhlaWdodD1cXFwiODU1MVxcXCJcXG4gICAgICAgICBpZD1cXFwicmVjdDQxNzFcXFwiXFxuICAgICAgICAgeD1cXFwiMFxcXCJcXG4gICAgICAgICB5PVxcXCIwXFxcIlxcbiAgICAgICAgIHN0eWxlPVxcXCJmaWxsOiM0OTQ4NDg7c3Ryb2tlOiMyYzJhMjk7c3Ryb2tlLXdpZHRoOjgwMFxcXCIgLz5cXG4gICAgICA8cmVjdFxcbiAgICAgICAgIGNsYXNzPVxcXCJmaWwzIHN0cjFcXFwiXFxuICAgICAgICAgdHJhbnNmb3JtPVxcXCJtYXRyaXgoMCwtMC44MTg1NCwwLjk2MDExNCwwLDQ2MDA4LjgsLTI0MjQ2LjQpXFxcIlxcbiAgICAgICAgIHdpZHRoPVxcXCIxMjI4XFxcIlxcbiAgICAgICAgIGhlaWdodD1cXFwiODU1MVxcXCJcXG4gICAgICAgICBpZD1cXFwicmVjdDQxNzNcXFwiXFxuICAgICAgICAgeD1cXFwiMFxcXCJcXG4gICAgICAgICB5PVxcXCIwXFxcIlxcbiAgICAgICAgIHN0eWxlPVxcXCJmaWxsOiM0OTQ4NDg7c3Ryb2tlOiMyYzJhMjk7c3Ryb2tlLXdpZHRoOjgwMFxcXCIgLz5cXG4gICAgICA8cmVjdFxcbiAgICAgICAgIGNsYXNzPVxcXCJmaWwzIHN0cjFcXFwiXFxuICAgICAgICAgdHJhbnNmb3JtPVxcXCJtYXRyaXgoMCwtMC44MTg1NCwwLjk2MDExNCwwLDQ2MDA4LjgsLTI4MjM1LjUpXFxcIlxcbiAgICAgICAgIHdpZHRoPVxcXCIxMjI4XFxcIlxcbiAgICAgICAgIGhlaWdodD1cXFwiODU1MVxcXCJcXG4gICAgICAgICBpZD1cXFwicmVjdDQxNzVcXFwiXFxuICAgICAgICAgeD1cXFwiMFxcXCJcXG4gICAgICAgICB5PVxcXCIwXFxcIlxcbiAgICAgICAgIHN0eWxlPVxcXCJmaWxsOiM0OTQ4NDg7c3Ryb2tlOiMyYzJhMjk7c3Ryb2tlLXdpZHRoOjgwMFxcXCIgLz5cXG4gICAgICA8cmVjdFxcbiAgICAgICAgIGNsYXNzPVxcXCJmaWwzIHN0cjFcXFwiXFxuICAgICAgICAgdHJhbnNmb3JtPVxcXCJtYXRyaXgoMCwtMC44MTg1NCwwLjk2MDExNCwwLDQ2MDA4LjgsLTMyMDg1LjQpXFxcIlxcbiAgICAgICAgIHdpZHRoPVxcXCIxMjI4XFxcIlxcbiAgICAgICAgIGhlaWdodD1cXFwiODU1MVxcXCJcXG4gICAgICAgICBpZD1cXFwicmVjdDQxNzdcXFwiXFxuICAgICAgICAgeD1cXFwiMFxcXCJcXG4gICAgICAgICB5PVxcXCIwXFxcIlxcbiAgICAgICAgIHN0eWxlPVxcXCJmaWxsOiM0OTQ4NDg7c3Ryb2tlOiMyYzJhMjk7c3Ryb2tlLXdpZHRoOjgwMFxcXCIgLz5cXG4gICAgICA8cmVjdFxcbiAgICAgICAgIGNsYXNzPVxcXCJmaWwzIHN0cjFcXFwiXFxuICAgICAgICAgdHJhbnNmb3JtPVxcXCJtYXRyaXgoMCwtMC44MTg1NCwwLjk2MDExNCwwLDQ2MDA4LjgsLTM1OTYyLjUpXFxcIlxcbiAgICAgICAgIHdpZHRoPVxcXCIxMjI4XFxcIlxcbiAgICAgICAgIGhlaWdodD1cXFwiODU1MVxcXCJcXG4gICAgICAgICBpZD1cXFwicmVjdDQxNzlcXFwiXFxuICAgICAgICAgeD1cXFwiMFxcXCJcXG4gICAgICAgICB5PVxcXCIwXFxcIlxcbiAgICAgICAgIHN0eWxlPVxcXCJmaWxsOiM0OTQ4NDg7c3Ryb2tlOiMyYzJhMjk7c3Ryb2tlLXdpZHRoOjgwMFxcXCIgLz5cXG4gICAgICA8cmVjdFxcbiAgICAgICAgIGNsYXNzPVxcXCJmaWwzIHN0cjFcXFwiXFxuICAgICAgICAgdHJhbnNmb3JtPVxcXCJtYXRyaXgoMCwtMC44MTg1NCwwLjk2MDExNCwwLDQ2MDA4LjgsLTM5OTAzLjEpXFxcIlxcbiAgICAgICAgIHdpZHRoPVxcXCIxMjI4XFxcIlxcbiAgICAgICAgIGhlaWdodD1cXFwiODU1MVxcXCJcXG4gICAgICAgICByeD1cXFwiNTA5XFxcIlxcbiAgICAgICAgIHJ5PVxcXCI1MDlcXFwiXFxuICAgICAgICAgaWQ9XFxcInJlY3Q0MTgxXFxcIlxcbiAgICAgICAgIHg9XFxcIjBcXFwiXFxuICAgICAgICAgeT1cXFwiMFxcXCJcXG4gICAgICAgICBzdHlsZT1cXFwiZmlsbDojNDk0ODQ4O3N0cm9rZTojMmMyYTI5O3N0cm9rZS13aWR0aDo4MDBcXFwiIC8+XFxuICAgICAgPHBvbHlnb25cXG4gICAgICAgICBjbGFzcz1cXFwiZmlsMTAgc3RyOFxcXCJcXG4gICAgICAgICBwb2ludHM9XFxcIjU5NzE2LC00MjkzMiA1OTcxNiwtMjkzMiA1MDI1MywtMjkzMiA1MDI1MywtNDI5MzIgXFxcIlxcbiAgICAgICAgIGlkPVxcXCJwb2x5Z29uNDE4M1xcXCJcXG4gICAgICAgICBzdHlsZT1cXFwiZmlsbDojYzk5ODA2O3N0cm9rZTojMmIyYTI5O3N0cm9rZS13aWR0aDoxMDAwXFxcIiAvPlxcbiAgICAgIDxyZWN0XFxuICAgICAgICAgY2xhc3M9XFxcImZpbDEwIHN0cjhcXFwiXFxuICAgICAgICAgdHJhbnNmb3JtPVxcXCJtYXRyaXgoMCwtMS4wMDA5MywxLjQ2MSwwLDcyMzc5LjUsLTI5MzEuNjgpXFxcIlxcbiAgICAgICAgIHdpZHRoPVxcXCIzOTk2M1xcXCJcXG4gICAgICAgICBoZWlnaHQ9XFxcIjY0NzdcXFwiXFxuICAgICAgICAgaWQ9XFxcInJlY3Q0MTg1XFxcIlxcbiAgICAgICAgIHg9XFxcIjBcXFwiXFxuICAgICAgICAgeT1cXFwiMFxcXCJcXG4gICAgICAgICBzdHlsZT1cXFwiZmlsbDojYzk5ODA2O3N0cm9rZTojMmIyYTI5O3N0cm9rZS13aWR0aDoxMDAwXFxcIiAvPlxcbiAgICAgIDxwb2x5Z29uXFxuICAgICAgICAgY2xhc3M9XFxcImZpbDExIHN0cjhcXFwiXFxuICAgICAgICAgcG9pbnRzPVxcXCI3ODQwOSwtNDE2MDQgNzg0MDksLTg4MDQgNTM0OTksLTg4MDQgNTM0OTksLTQxNjA0IFxcXCJcXG4gICAgICAgICBpZD1cXFwicG9seWdvbjQxODdcXFwiXFxuICAgICAgICAgc3R5bGU9XFxcImZpbGw6I2NjOWEwMDtzdHJva2U6IzJiMmEyOTtzdHJva2Utd2lkdGg6MTAwMFxcXCIgLz5cXG4gICAgICA8cmVjdFxcbiAgICAgICAgIGNsYXNzPVxcXCJmaWw3XFxcIlxcbiAgICAgICAgIHg9XFxcIjU4MTY0XFxcIlxcbiAgICAgICAgIHk9XFxcIi00MDY1M1xcXCJcXG4gICAgICAgICB3aWR0aD1cXFwiMTEyMFxcXCJcXG4gICAgICAgICBoZWlnaHQ9XFxcIjQ4OTJcXFwiXFxuICAgICAgICAgcng9XFxcIjQzOFxcXCJcXG4gICAgICAgICByeT1cXFwiMjc1XFxcIlxcbiAgICAgICAgIGlkPVxcXCJyZWN0NDE4OVxcXCJcXG4gICAgICAgICBzdHlsZT1cXFwiZmlsbDojMmIyYTI5XFxcIiAvPlxcbiAgICAgIDxyZWN0XFxuICAgICAgICAgY2xhc3M9XFxcImZpbDdcXFwiXFxuICAgICAgICAgeD1cXFwiNTk5MDVcXFwiXFxuICAgICAgICAgeT1cXFwiLTQwNjUzXFxcIlxcbiAgICAgICAgIHdpZHRoPVxcXCIxMTIwXFxcIlxcbiAgICAgICAgIGhlaWdodD1cXFwiNDg5MlxcXCJcXG4gICAgICAgICByeD1cXFwiNDM4XFxcIlxcbiAgICAgICAgIHJ5PVxcXCIyNzVcXFwiXFxuICAgICAgICAgaWQ9XFxcInJlY3Q0MTkxXFxcIlxcbiAgICAgICAgIHN0eWxlPVxcXCJmaWxsOiMyYjJhMjlcXFwiIC8+XFxuICAgICAgPHJlY3RcXG4gICAgICAgICBjbGFzcz1cXFwiZmlsN1xcXCJcXG4gICAgICAgICB4PVxcXCI2MTU4N1xcXCJcXG4gICAgICAgICB5PVxcXCItNDA2NTNcXFwiXFxuICAgICAgICAgd2lkdGg9XFxcIjExMjBcXFwiXFxuICAgICAgICAgaGVpZ2h0PVxcXCI0ODkyXFxcIlxcbiAgICAgICAgIHJ4PVxcXCI0MzhcXFwiXFxuICAgICAgICAgcnk9XFxcIjI3NVxcXCJcXG4gICAgICAgICBpZD1cXFwicmVjdDQxOTNcXFwiXFxuICAgICAgICAgc3R5bGU9XFxcImZpbGw6IzJiMmEyOVxcXCIgLz5cXG4gICAgICA8cmVjdFxcbiAgICAgICAgIGNsYXNzPVxcXCJmaWw3XFxcIlxcbiAgICAgICAgIHg9XFxcIjYzMDkyXFxcIlxcbiAgICAgICAgIHk9XFxcIi00MDY1M1xcXCJcXG4gICAgICAgICB3aWR0aD1cXFwiMTEyMFxcXCJcXG4gICAgICAgICBoZWlnaHQ9XFxcIjQ4OTJcXFwiXFxuICAgICAgICAgcng9XFxcIjQzOFxcXCJcXG4gICAgICAgICByeT1cXFwiMjc1XFxcIlxcbiAgICAgICAgIGlkPVxcXCJyZWN0NDE5NVxcXCJcXG4gICAgICAgICBzdHlsZT1cXFwiZmlsbDojMmIyYTI5XFxcIiAvPlxcbiAgICAgIDxyZWN0XFxuICAgICAgICAgY2xhc3M9XFxcImZpbDdcXFwiXFxuICAgICAgICAgeD1cXFwiNjQ3NDRcXFwiXFxuICAgICAgICAgeT1cXFwiLTQwNjUzXFxcIlxcbiAgICAgICAgIHdpZHRoPVxcXCIxMTIwXFxcIlxcbiAgICAgICAgIGhlaWdodD1cXFwiNDg5MlxcXCJcXG4gICAgICAgICByeD1cXFwiNDM4XFxcIlxcbiAgICAgICAgIHJ5PVxcXCIyNzVcXFwiXFxuICAgICAgICAgaWQ9XFxcInJlY3Q0MTk3XFxcIlxcbiAgICAgICAgIHN0eWxlPVxcXCJmaWxsOiMyYjJhMjlcXFwiIC8+XFxuICAgICAgPHJlY3RcXG4gICAgICAgICBjbGFzcz1cXFwiZmlsN1xcXCJcXG4gICAgICAgICB4PVxcXCI2NjMzMVxcXCJcXG4gICAgICAgICB5PVxcXCItNDA2NTNcXFwiXFxuICAgICAgICAgd2lkdGg9XFxcIjExMjBcXFwiXFxuICAgICAgICAgaGVpZ2h0PVxcXCI0ODkyXFxcIlxcbiAgICAgICAgIHJ4PVxcXCI0MzhcXFwiXFxuICAgICAgICAgcnk9XFxcIjI3NVxcXCJcXG4gICAgICAgICBpZD1cXFwicmVjdDQxOTlcXFwiXFxuICAgICAgICAgc3R5bGU9XFxcImZpbGw6IzJiMmEyOVxcXCIgLz5cXG4gICAgICA8cmVjdFxcbiAgICAgICAgIGNsYXNzPVxcXCJmaWw3XFxcIlxcbiAgICAgICAgIHg9XFxcIjY4MDcyXFxcIlxcbiAgICAgICAgIHk9XFxcIi00MDY1M1xcXCJcXG4gICAgICAgICB3aWR0aD1cXFwiMTEyMFxcXCJcXG4gICAgICAgICBoZWlnaHQ9XFxcIjQ4OTJcXFwiXFxuICAgICAgICAgcng9XFxcIjQzOFxcXCJcXG4gICAgICAgICByeT1cXFwiMjc1XFxcIlxcbiAgICAgICAgIGlkPVxcXCJyZWN0NDIwMVxcXCJcXG4gICAgICAgICBzdHlsZT1cXFwiZmlsbDojMmIyYTI5XFxcIiAvPlxcbiAgICAgIDxyZWN0XFxuICAgICAgICAgY2xhc3M9XFxcImZpbDdcXFwiXFxuICAgICAgICAgeD1cXFwiNjk3NTRcXFwiXFxuICAgICAgICAgeT1cXFwiLTQwNjUzXFxcIlxcbiAgICAgICAgIHdpZHRoPVxcXCIxMTIwXFxcIlxcbiAgICAgICAgIGhlaWdodD1cXFwiNDg5MlxcXCJcXG4gICAgICAgICByeD1cXFwiNDM4XFxcIlxcbiAgICAgICAgIHJ5PVxcXCIyNzVcXFwiXFxuICAgICAgICAgaWQ9XFxcInJlY3Q0MjAzXFxcIlxcbiAgICAgICAgIHN0eWxlPVxcXCJmaWxsOiMyYjJhMjlcXFwiIC8+XFxuICAgICAgPHJlY3RcXG4gICAgICAgICBjbGFzcz1cXFwiZmlsN1xcXCJcXG4gICAgICAgICB4PVxcXCI3MTI1OVxcXCJcXG4gICAgICAgICB5PVxcXCItNDA2NTNcXFwiXFxuICAgICAgICAgd2lkdGg9XFxcIjExMjBcXFwiXFxuICAgICAgICAgaGVpZ2h0PVxcXCI0ODkyXFxcIlxcbiAgICAgICAgIHJ4PVxcXCI0MzhcXFwiXFxuICAgICAgICAgcnk9XFxcIjI3NVxcXCJcXG4gICAgICAgICBpZD1cXFwicmVjdDQyMDVcXFwiXFxuICAgICAgICAgc3R5bGU9XFxcImZpbGw6IzJiMmEyOVxcXCIgLz5cXG4gICAgICA8cmVjdFxcbiAgICAgICAgIGNsYXNzPVxcXCJmaWw3XFxcIlxcbiAgICAgICAgIHg9XFxcIjcyOTExXFxcIlxcbiAgICAgICAgIHk9XFxcIi00MDY1M1xcXCJcXG4gICAgICAgICB3aWR0aD1cXFwiMTEyMFxcXCJcXG4gICAgICAgICBoZWlnaHQ9XFxcIjQ4OTJcXFwiXFxuICAgICAgICAgcng9XFxcIjQzOFxcXCJcXG4gICAgICAgICByeT1cXFwiMjc1XFxcIlxcbiAgICAgICAgIGlkPVxcXCJyZWN0NDIwN1xcXCJcXG4gICAgICAgICBzdHlsZT1cXFwiZmlsbDojMmIyYTI5XFxcIiAvPlxcbiAgICAgIDxwb2x5Z29uXFxuICAgICAgICAgY2xhc3M9XFxcImZpbDEyXFxcIlxcbiAgICAgICAgIHBvaW50cz1cXFwiNzc4NjUsLTkyODQgNzUzNTEsLTE0MTE5IDU2NTI3LC0xNDExOSA1NDAxMywtOTI4NCBcXFwiXFxuICAgICAgICAgaWQ9XFxcInBvbHlnb240MjA5XFxcIlxcbiAgICAgICAgIHN0eWxlPVxcXCJmaWxsOiNmZWMwMDA7ZmlsbC1vcGFjaXR5OjAuMTg4MjM0OTlcXFwiIC8+XFxuICAgICAgPHBvbHlnb25cXG4gICAgICAgICBjbGFzcz1cXFwiZmlsMTNcXFwiXFxuICAgICAgICAgcG9pbnRzPVxcXCI1NjUyMSwtNDExMzIgNTY1MjEsLTE0MDkyIDU0MDQ4LC05MzQ4IDU0MDQ4LC00MTEzNCBcXFwiXFxuICAgICAgICAgaWQ9XFxcInBvbHlnb240MjExXFxcIlxcbiAgICAgICAgIHN0eWxlPVxcXCJmaWxsOiNhMTc5MDBcXFwiIC8+XFxuICAgICAgPHBvbHlnb25cXG4gICAgICAgICBjbGFzcz1cXFwiZmlsMTNcXFwiXFxuICAgICAgICAgcG9pbnRzPVxcXCI3NTM0MCwtNDExMzIgNzUzNDAsLTE0MDkyIDc3ODEzLC05MzQ4IDc3ODEzLC00MTEzNCBcXFwiXFxuICAgICAgICAgaWQ9XFxcInBvbHlnb240MjEzXFxcIlxcbiAgICAgICAgIHN0eWxlPVxcXCJmaWxsOiNhMTc5MDBcXFwiIC8+XFxuICAgICAgPHJlY3RcXG4gICAgICAgICBjbGFzcz1cXFwiZmlsMTEgc3RyOFxcXCJcXG4gICAgICAgICB0cmFuc2Zvcm09XFxcIm1hdHJpeCgwLC0xLjAwMDkzLDEuMDk0NTYsMCw1NjE1OSwtMTQzNjAuNClcXFwiXFxuICAgICAgICAgd2lkdGg9XFxcIjIwNjU5XFxcIlxcbiAgICAgICAgIGhlaWdodD1cXFwiMTc2NTNcXFwiXFxuICAgICAgICAgcng9XFxcIjMxNzVcXFwiXFxuICAgICAgICAgcnk9XFxcIjMxNzVcXFwiXFxuICAgICAgICAgaWQ9XFxcInJlY3Q0MjE1XFxcIlxcbiAgICAgICAgIHg9XFxcIjBcXFwiXFxuICAgICAgICAgeT1cXFwiMFxcXCJcXG4gICAgICAgICBzdHlsZT1cXFwiZmlsbDojY2M5YTAwO3N0cm9rZTojMmIyYTI5O3N0cm9rZS13aWR0aDoxMDAwXFxcIiAvPlxcbiAgICAgIDxlbGxpcHNlXFxuICAgICAgICAgY2xhc3M9XFxcImZpbDExIHN0cjhcXFwiXFxuICAgICAgICAgdHJhbnNmb3JtPVxcXCJtYXRyaXgoMCwtMS4yMDI5NiwxLjMxNTQ5LDAsNjU4MjAuMSwtMjQ2OTkuMylcXFwiXFxuICAgICAgICAgcng9XFxcIjQ2NTdcXFwiXFxuICAgICAgICAgcnk9XFxcIjQ0NDVcXFwiXFxuICAgICAgICAgaWQ9XFxcImVsbGlwc2U0MjE3XFxcIlxcbiAgICAgICAgIGN4PVxcXCIwXFxcIlxcbiAgICAgICAgIGN5PVxcXCIwXFxcIlxcbiAgICAgICAgIHN0eWxlPVxcXCJmaWxsOiNjYzlhMDA7c3Ryb2tlOiMyYjJhMjk7c3Ryb2tlLXdpZHRoOjEwMDBcXFwiIC8+XFxuICAgICAgPGVsbGlwc2VcXG4gICAgICAgICBjbGFzcz1cXFwiZmlsMTEgc3RyOFxcXCJcXG4gICAgICAgICB0cmFuc2Zvcm09XFxcIm1hdHJpeCgwLC0wLjc3MzMzMywwLjg0NTY2OSwwLDY1ODIwLjEsLTI0Njk5LjMpXFxcIlxcbiAgICAgICAgIHJ4PVxcXCI0NjU3XFxcIlxcbiAgICAgICAgIHJ5PVxcXCI0NDQ1XFxcIlxcbiAgICAgICAgIGlkPVxcXCJlbGxpcHNlNDIxOVxcXCJcXG4gICAgICAgICBjeD1cXFwiMFxcXCJcXG4gICAgICAgICBjeT1cXFwiMFxcXCJcXG4gICAgICAgICBzdHlsZT1cXFwiZmlsbDojY2M5YTAwO3N0cm9rZTojMmIyYTI5O3N0cm9rZS13aWR0aDoxMDAwXFxcIiAvPlxcbiAgICAgIDxyZWN0XFxuICAgICAgICAgY2xhc3M9XFxcImZpbDExIHN0cjhcXFwiXFxuICAgICAgICAgdHJhbnNmb3JtPVxcXCJtYXRyaXgoMCwtMS4wMDA5MywxLjA5NDU2LDAsNjQzMDMuMywtNTQzMi4wMilcXFwiXFxuICAgICAgICAgd2lkdGg9XFxcIjEwNzQyXFxcIlxcbiAgICAgICAgIGhlaWdodD1cXFwiMzAxNlxcXCJcXG4gICAgICAgICByeD1cXFwiMTExMVxcXCJcXG4gICAgICAgICByeT1cXFwiMTExMVxcXCJcXG4gICAgICAgICBpZD1cXFwicmVjdDQyMjFcXFwiXFxuICAgICAgICAgeD1cXFwiMFxcXCJcXG4gICAgICAgICB5PVxcXCIwXFxcIlxcbiAgICAgICAgIHN0eWxlPVxcXCJmaWxsOiNjYzlhMDA7c3Ryb2tlOiMyYjJhMjk7c3Ryb2tlLXdpZHRoOjEwMDBcXFwiIC8+XFxuICAgICAgPHJlY3RcXG4gICAgICAgICBjbGFzcz1cXFwiZmlsMTEgc3RyOFxcXCJcXG4gICAgICAgICB0cmFuc2Zvcm09XFxcIm1hdHJpeCgwLC0wLjU1NzcxOSwxLjY3MDY0LDAsNjM0MzQuNSwtMzI1NC40NilcXFwiXFxuICAgICAgICAgd2lkdGg9XFxcIjEwNzQyXFxcIlxcbiAgICAgICAgIGhlaWdodD1cXFwiMzAxNlxcXCJcXG4gICAgICAgICByeD1cXFwiMTExMVxcXCJcXG4gICAgICAgICByeT1cXFwiMTExMVxcXCJcXG4gICAgICAgICBpZD1cXFwicmVjdDQyMjNcXFwiXFxuICAgICAgICAgeD1cXFwiMFxcXCJcXG4gICAgICAgICB5PVxcXCIwXFxcIlxcbiAgICAgICAgIHN0eWxlPVxcXCJmaWxsOiNjYzlhMDA7c3Ryb2tlOiMyYjJhMjk7c3Ryb2tlLXdpZHRoOjEwMDBcXFwiIC8+XFxuICAgICAgPHJlY3RcXG4gICAgICAgICBjbGFzcz1cXFwiZmlsN1xcXCJcXG4gICAgICAgICB0cmFuc2Zvcm09XFxcIm1hdHJpeCgwLC0xLjAwMjk3LDAuOTcwOTU5LDAsNjkxMjguMSwtMTE3MTQuNClcXFwiXFxuICAgICAgICAgd2lkdGg9XFxcIjUyOVxcXCJcXG4gICAgICAgICBoZWlnaHQ9XFxcIjUyOTJcXFwiXFxuICAgICAgICAgaWQ9XFxcInJlY3Q0MjI1XFxcIlxcbiAgICAgICAgIHg9XFxcIjBcXFwiXFxuICAgICAgICAgeT1cXFwiMFxcXCJcXG4gICAgICAgICBzdHlsZT1cXFwiZmlsbDojMmIyYTI5XFxcIiAvPlxcbiAgICAgIDxyZWN0XFxuICAgICAgICAgY2xhc3M9XFxcImZpbDdcXFwiXFxuICAgICAgICAgdHJhbnNmb3JtPVxcXCJtYXRyaXgoMCwtMS4wMDI5NywwLjk3MDk1OSwwLDU3NjE5LC0xMTcxNC40KVxcXCJcXG4gICAgICAgICB3aWR0aD1cXFwiNTI5XFxcIlxcbiAgICAgICAgIGhlaWdodD1cXFwiNTI5MlxcXCJcXG4gICAgICAgICBpZD1cXFwicmVjdDQyMjdcXFwiXFxuICAgICAgICAgeD1cXFwiMFxcXCJcXG4gICAgICAgICB5PVxcXCIwXFxcIlxcbiAgICAgICAgIHN0eWxlPVxcXCJmaWxsOiMyYjJhMjlcXFwiIC8+XFxuICAgIDwvZz5cXG4gIDwvZz5cXG48L3N2Zz5cXG5cIlxyXG4gICAgICBdLFxyXG4gICAgICBcInR5cGVcIjogXCJzcGF3bmVyXCIsXHJcbiAgICAgIFwic2l6ZVwiOiAyLFxyXG4gICAgICBcImlkXCI6IDdcclxuICAgIH1cclxuICBdLFxyXG4gIFwibWFwXCI6IHtcclxuICAgIFwibmFtZVwiOiBcInBlcmVrcmVzdG9rXCIsXHJcbiAgICBcInNpemVzXCI6IHtcclxuICAgICAgXCJsYXllcnNcIjogMixcclxuICAgICAgXCJoZWlnaHRcIjogMjAsXHJcbiAgICAgIFwid2lkdGhcIjogMjBcclxuICAgIH0sXHJcbiAgICBcImxheWVyc1wiOiBbXHJcbiAgICAgIFtcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAwLFxyXG4gICAgICAgICAgICBcInlcIjogMCxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiAyLFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMSxcclxuICAgICAgICAgICAgXCJ5XCI6IDAsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogMixcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDIsXHJcbiAgICAgICAgICAgIFwieVwiOiAwLFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDIsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAzLFxyXG4gICAgICAgICAgICBcInlcIjogMCxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiAyLFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogNCxcclxuICAgICAgICAgICAgXCJ5XCI6IDAsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogMixcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDUsXHJcbiAgICAgICAgICAgIFwieVwiOiAwLFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDIsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiA2LFxyXG4gICAgICAgICAgICBcInlcIjogMCxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiAyLFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogNyxcclxuICAgICAgICAgICAgXCJ5XCI6IDAsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogMixcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDgsXHJcbiAgICAgICAgICAgIFwieVwiOiAwLFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDIsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiA5LFxyXG4gICAgICAgICAgICBcInlcIjogMCxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiAxLFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMlxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMTAsXHJcbiAgICAgICAgICAgIFwieVwiOiAwLFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDEsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAxMSxcclxuICAgICAgICAgICAgXCJ5XCI6IDAsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogMixcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDEyLFxyXG4gICAgICAgICAgICBcInlcIjogMCxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiAyLFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMTMsXHJcbiAgICAgICAgICAgIFwieVwiOiAwLFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDIsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAxNCxcclxuICAgICAgICAgICAgXCJ5XCI6IDAsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogMixcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDE1LFxyXG4gICAgICAgICAgICBcInlcIjogMCxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiAyLFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMTYsXHJcbiAgICAgICAgICAgIFwieVwiOiAwLFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDIsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAxNyxcclxuICAgICAgICAgICAgXCJ5XCI6IDAsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogMixcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDE4LFxyXG4gICAgICAgICAgICBcInlcIjogMCxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiAyLFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMTksXHJcbiAgICAgICAgICAgIFwieVwiOiAwLFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDIsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAwLFxyXG4gICAgICAgICAgICBcInlcIjogMSxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiAyLFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMSxcclxuICAgICAgICAgICAgXCJ5XCI6IDEsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNCxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDIsXHJcbiAgICAgICAgICAgIFwieVwiOiAxLFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDQsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAzLFxyXG4gICAgICAgICAgICBcInlcIjogMSxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA0LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogNCxcclxuICAgICAgICAgICAgXCJ5XCI6IDEsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNCxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDUsXHJcbiAgICAgICAgICAgIFwieVwiOiAxLFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDQsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiA2LFxyXG4gICAgICAgICAgICBcInlcIjogMSxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA0LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogNyxcclxuICAgICAgICAgICAgXCJ5XCI6IDEsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNCxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDgsXHJcbiAgICAgICAgICAgIFwieVwiOiAxLFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDQsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiA5LFxyXG4gICAgICAgICAgICBcInlcIjogMSxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiAxLFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMlxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMTAsXHJcbiAgICAgICAgICAgIFwieVwiOiAxLFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDEsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAxMSxcclxuICAgICAgICAgICAgXCJ5XCI6IDEsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNCxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDEyLFxyXG4gICAgICAgICAgICBcInlcIjogMSxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA0LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMTMsXHJcbiAgICAgICAgICAgIFwieVwiOiAxLFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDQsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAxNCxcclxuICAgICAgICAgICAgXCJ5XCI6IDEsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNCxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDE1LFxyXG4gICAgICAgICAgICBcInlcIjogMSxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA0LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMTYsXHJcbiAgICAgICAgICAgIFwieVwiOiAxLFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDQsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAxNyxcclxuICAgICAgICAgICAgXCJ5XCI6IDEsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNCxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDE4LFxyXG4gICAgICAgICAgICBcInlcIjogMSxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA0LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMTksXHJcbiAgICAgICAgICAgIFwieVwiOiAxLFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDIsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAwLFxyXG4gICAgICAgICAgICBcInlcIjogMixcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiAyLFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMSxcclxuICAgICAgICAgICAgXCJ5XCI6IDIsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNCxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDIsXHJcbiAgICAgICAgICAgIFwieVwiOiAyLFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDQsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAzLFxyXG4gICAgICAgICAgICBcInlcIjogMixcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA0LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogNCxcclxuICAgICAgICAgICAgXCJ5XCI6IDIsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNCxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDUsXHJcbiAgICAgICAgICAgIFwieVwiOiAyLFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDQsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiA2LFxyXG4gICAgICAgICAgICBcInlcIjogMixcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA0LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogNyxcclxuICAgICAgICAgICAgXCJ5XCI6IDIsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNCxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDgsXHJcbiAgICAgICAgICAgIFwieVwiOiAyLFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDQsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiA5LFxyXG4gICAgICAgICAgICBcInlcIjogMixcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiAxLFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMlxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMTAsXHJcbiAgICAgICAgICAgIFwieVwiOiAyLFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDEsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAxMSxcclxuICAgICAgICAgICAgXCJ5XCI6IDIsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNCxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDEyLFxyXG4gICAgICAgICAgICBcInlcIjogMixcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA0LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMTMsXHJcbiAgICAgICAgICAgIFwieVwiOiAyLFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDQsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAxNCxcclxuICAgICAgICAgICAgXCJ5XCI6IDIsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNCxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDE1LFxyXG4gICAgICAgICAgICBcInlcIjogMixcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA0LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMTYsXHJcbiAgICAgICAgICAgIFwieVwiOiAyLFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDQsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAxNyxcclxuICAgICAgICAgICAgXCJ5XCI6IDIsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNCxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDE4LFxyXG4gICAgICAgICAgICBcInlcIjogMixcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA0LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMTksXHJcbiAgICAgICAgICAgIFwieVwiOiAyLFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDIsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAwLFxyXG4gICAgICAgICAgICBcInlcIjogMyxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiAyLFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMSxcclxuICAgICAgICAgICAgXCJ5XCI6IDMsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNCxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDIsXHJcbiAgICAgICAgICAgIFwieVwiOiAzLFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDQsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAzLFxyXG4gICAgICAgICAgICBcInlcIjogMyxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiAyLFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogNCxcclxuICAgICAgICAgICAgXCJ5XCI6IDMsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogMixcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDUsXHJcbiAgICAgICAgICAgIFwieVwiOiAzLFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDIsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiA2LFxyXG4gICAgICAgICAgICBcInlcIjogMyxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiAyLFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogNyxcclxuICAgICAgICAgICAgXCJ5XCI6IDMsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNCxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDgsXHJcbiAgICAgICAgICAgIFwieVwiOiAzLFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDQsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiA5LFxyXG4gICAgICAgICAgICBcInlcIjogMyxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiAxLFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMlxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMTAsXHJcbiAgICAgICAgICAgIFwieVwiOiAzLFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDEsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAxMSxcclxuICAgICAgICAgICAgXCJ5XCI6IDMsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNCxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDEyLFxyXG4gICAgICAgICAgICBcInlcIjogMyxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA0LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMTMsXHJcbiAgICAgICAgICAgIFwieVwiOiAzLFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDIsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAxNCxcclxuICAgICAgICAgICAgXCJ5XCI6IDMsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogMixcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDE1LFxyXG4gICAgICAgICAgICBcInlcIjogMyxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiAyLFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMTYsXHJcbiAgICAgICAgICAgIFwieVwiOiAzLFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDIsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAxNyxcclxuICAgICAgICAgICAgXCJ5XCI6IDMsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNCxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDE4LFxyXG4gICAgICAgICAgICBcInlcIjogMyxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA0LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMTksXHJcbiAgICAgICAgICAgIFwieVwiOiAzLFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDIsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAwLFxyXG4gICAgICAgICAgICBcInlcIjogNCxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiAyLFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMSxcclxuICAgICAgICAgICAgXCJ5XCI6IDQsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNCxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDIsXHJcbiAgICAgICAgICAgIFwieVwiOiA0LFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDQsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAzLFxyXG4gICAgICAgICAgICBcInlcIjogNCxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiAyLFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogNCxcclxuICAgICAgICAgICAgXCJ5XCI6IDQsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogMixcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDUsXHJcbiAgICAgICAgICAgIFwieVwiOiA0LFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDIsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiA2LFxyXG4gICAgICAgICAgICBcInlcIjogNCxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiAyLFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogNyxcclxuICAgICAgICAgICAgXCJ5XCI6IDQsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNCxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDgsXHJcbiAgICAgICAgICAgIFwieVwiOiA0LFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDQsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiA5LFxyXG4gICAgICAgICAgICBcInlcIjogNCxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiAxLFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMlxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMTAsXHJcbiAgICAgICAgICAgIFwieVwiOiA0LFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDEsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAxMSxcclxuICAgICAgICAgICAgXCJ5XCI6IDQsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNCxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDEyLFxyXG4gICAgICAgICAgICBcInlcIjogNCxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA0LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMTMsXHJcbiAgICAgICAgICAgIFwieVwiOiA0LFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDIsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAxNCxcclxuICAgICAgICAgICAgXCJ5XCI6IDQsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDIsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogMyxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDJcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDE2LFxyXG4gICAgICAgICAgICBcInlcIjogNCxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiAyLFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMTcsXHJcbiAgICAgICAgICAgIFwieVwiOiA0LFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDQsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAxOCxcclxuICAgICAgICAgICAgXCJ5XCI6IDQsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNCxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDE5LFxyXG4gICAgICAgICAgICBcInlcIjogNCxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiAyLFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMCxcclxuICAgICAgICAgICAgXCJ5XCI6IDUsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogMixcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDEsXHJcbiAgICAgICAgICAgIFwieVwiOiA1LFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDQsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAyLFxyXG4gICAgICAgICAgICBcInlcIjogNSxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA0LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMyxcclxuICAgICAgICAgICAgXCJ5XCI6IDUsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogMixcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDQsXHJcbiAgICAgICAgICAgIFwieVwiOiA1LFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDIsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiA1LFxyXG4gICAgICAgICAgICBcInlcIjogNSxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiAyLFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogNixcclxuICAgICAgICAgICAgXCJ5XCI6IDUsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogMixcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDcsXHJcbiAgICAgICAgICAgIFwieVwiOiA1LFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDQsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiA4LFxyXG4gICAgICAgICAgICBcInlcIjogNSxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA0LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogOSxcclxuICAgICAgICAgICAgXCJ5XCI6IDUsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogMSxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDJcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDEwLFxyXG4gICAgICAgICAgICBcInlcIjogNSxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiAxLFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMTEsXHJcbiAgICAgICAgICAgIFwieVwiOiA1LFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDQsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAxMixcclxuICAgICAgICAgICAgXCJ5XCI6IDUsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNCxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDEzLFxyXG4gICAgICAgICAgICBcInlcIjogNSxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiAyLFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMTYsXHJcbiAgICAgICAgICAgIFwieVwiOiA1LFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDIsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAxNyxcclxuICAgICAgICAgICAgXCJ5XCI6IDUsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNCxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDE4LFxyXG4gICAgICAgICAgICBcInlcIjogNSxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA0LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMTksXHJcbiAgICAgICAgICAgIFwieVwiOiA1LFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDIsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAwLFxyXG4gICAgICAgICAgICBcInlcIjogNixcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiAyLFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMSxcclxuICAgICAgICAgICAgXCJ5XCI6IDYsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNCxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDIsXHJcbiAgICAgICAgICAgIFwieVwiOiA2LFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDQsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAzLFxyXG4gICAgICAgICAgICBcInlcIjogNixcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiAyLFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogNCxcclxuICAgICAgICAgICAgXCJ5XCI6IDYsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogMixcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDUsXHJcbiAgICAgICAgICAgIFwieVwiOiA2LFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDIsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiA2LFxyXG4gICAgICAgICAgICBcInlcIjogNixcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiAyLFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogNyxcclxuICAgICAgICAgICAgXCJ5XCI6IDYsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNCxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDgsXHJcbiAgICAgICAgICAgIFwieVwiOiA2LFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDQsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiA5LFxyXG4gICAgICAgICAgICBcInlcIjogNixcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiAxLFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMlxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMTAsXHJcbiAgICAgICAgICAgIFwieVwiOiA2LFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDEsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAxMSxcclxuICAgICAgICAgICAgXCJ5XCI6IDYsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNCxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDEyLFxyXG4gICAgICAgICAgICBcInlcIjogNixcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA0LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMTMsXHJcbiAgICAgICAgICAgIFwieVwiOiA2LFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDIsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAxNCxcclxuICAgICAgICAgICAgXCJ5XCI6IDYsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogMixcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDE1LFxyXG4gICAgICAgICAgICBcInlcIjogNixcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiAyLFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMTYsXHJcbiAgICAgICAgICAgIFwieVwiOiA2LFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDIsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAxNyxcclxuICAgICAgICAgICAgXCJ5XCI6IDYsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNCxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDE4LFxyXG4gICAgICAgICAgICBcInlcIjogNixcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA0LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMTksXHJcbiAgICAgICAgICAgIFwieVwiOiA2LFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDIsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAwLFxyXG4gICAgICAgICAgICBcInlcIjogNyxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiAyLFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMSxcclxuICAgICAgICAgICAgXCJ5XCI6IDcsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNCxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDIsXHJcbiAgICAgICAgICAgIFwieVwiOiA3LFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDQsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAzLFxyXG4gICAgICAgICAgICBcInlcIjogNyxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA0LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogNCxcclxuICAgICAgICAgICAgXCJ5XCI6IDcsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNCxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDUsXHJcbiAgICAgICAgICAgIFwieVwiOiA3LFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDQsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiA2LFxyXG4gICAgICAgICAgICBcInlcIjogNyxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA0LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogNyxcclxuICAgICAgICAgICAgXCJ5XCI6IDcsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNCxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDgsXHJcbiAgICAgICAgICAgIFwieVwiOiA3LFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDQsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiA5LFxyXG4gICAgICAgICAgICBcInlcIjogNyxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiAxLFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMlxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMTAsXHJcbiAgICAgICAgICAgIFwieVwiOiA3LFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDEsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAxMSxcclxuICAgICAgICAgICAgXCJ5XCI6IDcsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNCxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDEyLFxyXG4gICAgICAgICAgICBcInlcIjogNyxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA0LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMTMsXHJcbiAgICAgICAgICAgIFwieVwiOiA3LFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDQsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAxNCxcclxuICAgICAgICAgICAgXCJ5XCI6IDcsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNCxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDE1LFxyXG4gICAgICAgICAgICBcInlcIjogNyxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA0LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMTYsXHJcbiAgICAgICAgICAgIFwieVwiOiA3LFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDQsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAxNyxcclxuICAgICAgICAgICAgXCJ5XCI6IDcsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNCxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDE4LFxyXG4gICAgICAgICAgICBcInlcIjogNyxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA0LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMTksXHJcbiAgICAgICAgICAgIFwieVwiOiA3LFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDIsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAwLFxyXG4gICAgICAgICAgICBcInlcIjogOCxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiAyLFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMSxcclxuICAgICAgICAgICAgXCJ5XCI6IDgsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNCxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDIsXHJcbiAgICAgICAgICAgIFwieVwiOiA4LFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDQsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAzLFxyXG4gICAgICAgICAgICBcInlcIjogOCxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA0LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogNCxcclxuICAgICAgICAgICAgXCJ5XCI6IDgsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNCxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDUsXHJcbiAgICAgICAgICAgIFwieVwiOiA4LFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDQsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiA2LFxyXG4gICAgICAgICAgICBcInlcIjogOCxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA0LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogNyxcclxuICAgICAgICAgICAgXCJ5XCI6IDgsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogMixcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDgsXHJcbiAgICAgICAgICAgIFwieVwiOiA4LFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDIsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiA5LFxyXG4gICAgICAgICAgICBcInlcIjogOCxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiAxLFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMlxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMTAsXHJcbiAgICAgICAgICAgIFwieVwiOiA4LFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDEsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAxMSxcclxuICAgICAgICAgICAgXCJ5XCI6IDgsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogMixcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDEyLFxyXG4gICAgICAgICAgICBcInlcIjogOCxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiAyLFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMTMsXHJcbiAgICAgICAgICAgIFwieVwiOiA4LFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDQsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAxNCxcclxuICAgICAgICAgICAgXCJ5XCI6IDgsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNCxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDE1LFxyXG4gICAgICAgICAgICBcInlcIjogOCxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA0LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMTYsXHJcbiAgICAgICAgICAgIFwieVwiOiA4LFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDQsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAxNyxcclxuICAgICAgICAgICAgXCJ5XCI6IDgsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNCxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDE4LFxyXG4gICAgICAgICAgICBcInlcIjogOCxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA0LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMTksXHJcbiAgICAgICAgICAgIFwieVwiOiA4LFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDIsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAwLFxyXG4gICAgICAgICAgICBcInlcIjogOSxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiAyLFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMSxcclxuICAgICAgICAgICAgXCJ5XCI6IDksXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogMixcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDIsXHJcbiAgICAgICAgICAgIFwieVwiOiA5LFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDIsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAzLFxyXG4gICAgICAgICAgICBcInlcIjogOSxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiAyLFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogNCxcclxuICAgICAgICAgICAgXCJ5XCI6IDksXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogMixcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDUsXHJcbiAgICAgICAgICAgIFwieVwiOiA5LFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDQsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiA2LFxyXG4gICAgICAgICAgICBcInlcIjogOSxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA0LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogNyxcclxuICAgICAgICAgICAgXCJ5XCI6IDksXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogMixcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDgsXHJcbiAgICAgICAgICAgIFwieVwiOiA5LFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDIsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiA5LFxyXG4gICAgICAgICAgICBcInlcIjogOSxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiAxLFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMlxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMTAsXHJcbiAgICAgICAgICAgIFwieVwiOiA5LFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDEsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAxMSxcclxuICAgICAgICAgICAgXCJ5XCI6IDksXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogMixcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDEyLFxyXG4gICAgICAgICAgICBcInlcIjogOSxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiAyLFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMTMsXHJcbiAgICAgICAgICAgIFwieVwiOiA5LFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDQsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAxNCxcclxuICAgICAgICAgICAgXCJ5XCI6IDksXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNCxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDE1LFxyXG4gICAgICAgICAgICBcInlcIjogOSxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiAyLFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMTYsXHJcbiAgICAgICAgICAgIFwieVwiOiA5LFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDIsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAxNyxcclxuICAgICAgICAgICAgXCJ5XCI6IDksXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogMixcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDE4LFxyXG4gICAgICAgICAgICBcInlcIjogOSxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiAyLFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMTksXHJcbiAgICAgICAgICAgIFwieVwiOiA5LFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDIsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAwLFxyXG4gICAgICAgICAgICBcInlcIjogMTAsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogMixcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDEsXHJcbiAgICAgICAgICAgIFwieVwiOiAxMCxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiAyLFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMixcclxuICAgICAgICAgICAgXCJ5XCI6IDEwLFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDIsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAzLFxyXG4gICAgICAgICAgICBcInlcIjogMTAsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogMixcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDQsXHJcbiAgICAgICAgICAgIFwieVwiOiAxMCxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiAyLFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogNSxcclxuICAgICAgICAgICAgXCJ5XCI6IDEwLFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDQsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiA2LFxyXG4gICAgICAgICAgICBcInlcIjogMTAsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNCxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDcsXHJcbiAgICAgICAgICAgIFwieVwiOiAxMCxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiAyLFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogOCxcclxuICAgICAgICAgICAgXCJ5XCI6IDEwLFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDIsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiA5LFxyXG4gICAgICAgICAgICBcInlcIjogMTAsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogMSxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDJcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDEwLFxyXG4gICAgICAgICAgICBcInlcIjogMTAsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogMSxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDExLFxyXG4gICAgICAgICAgICBcInlcIjogMTAsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogMixcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDEyLFxyXG4gICAgICAgICAgICBcInlcIjogMTAsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogMixcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDEzLFxyXG4gICAgICAgICAgICBcInlcIjogMTAsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNCxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDE0LFxyXG4gICAgICAgICAgICBcInlcIjogMTAsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNCxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDE1LFxyXG4gICAgICAgICAgICBcInlcIjogMTAsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogMixcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDE2LFxyXG4gICAgICAgICAgICBcInlcIjogMTAsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogMixcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDE3LFxyXG4gICAgICAgICAgICBcInlcIjogMTAsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogMixcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDE4LFxyXG4gICAgICAgICAgICBcInlcIjogMTAsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogMixcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDE5LFxyXG4gICAgICAgICAgICBcInlcIjogMTAsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogMixcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDAsXHJcbiAgICAgICAgICAgIFwieVwiOiAxMSxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiAyLFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMSxcclxuICAgICAgICAgICAgXCJ5XCI6IDExLFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDQsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAyLFxyXG4gICAgICAgICAgICBcInlcIjogMTEsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNCxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDMsXHJcbiAgICAgICAgICAgIFwieVwiOiAxMSxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA0LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogNCxcclxuICAgICAgICAgICAgXCJ5XCI6IDExLFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDQsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiA1LFxyXG4gICAgICAgICAgICBcInlcIjogMTEsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNCxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDYsXHJcbiAgICAgICAgICAgIFwieVwiOiAxMSxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA0LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogNyxcclxuICAgICAgICAgICAgXCJ5XCI6IDExLFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDIsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiA4LFxyXG4gICAgICAgICAgICBcInlcIjogMTEsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogMixcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDksXHJcbiAgICAgICAgICAgIFwieVwiOiAxMSxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiAxLFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMlxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMTAsXHJcbiAgICAgICAgICAgIFwieVwiOiAxMSxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiAxLFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMTEsXHJcbiAgICAgICAgICAgIFwieVwiOiAxMSxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiAyLFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMTIsXHJcbiAgICAgICAgICAgIFwieVwiOiAxMSxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiAyLFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMTMsXHJcbiAgICAgICAgICAgIFwieVwiOiAxMSxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA0LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMTQsXHJcbiAgICAgICAgICAgIFwieVwiOiAxMSxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA0LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMTUsXHJcbiAgICAgICAgICAgIFwieVwiOiAxMSxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA0LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMTYsXHJcbiAgICAgICAgICAgIFwieVwiOiAxMSxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA0LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMTcsXHJcbiAgICAgICAgICAgIFwieVwiOiAxMSxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA0LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMTgsXHJcbiAgICAgICAgICAgIFwieVwiOiAxMSxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA0LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMTksXHJcbiAgICAgICAgICAgIFwieVwiOiAxMSxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiAyLFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMCxcclxuICAgICAgICAgICAgXCJ5XCI6IDEyLFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDIsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAxLFxyXG4gICAgICAgICAgICBcInlcIjogMTIsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNCxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDIsXHJcbiAgICAgICAgICAgIFwieVwiOiAxMixcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA0LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMyxcclxuICAgICAgICAgICAgXCJ5XCI6IDEyLFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDQsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiA0LFxyXG4gICAgICAgICAgICBcInlcIjogMTIsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNCxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDUsXHJcbiAgICAgICAgICAgIFwieVwiOiAxMixcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA0LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogNixcclxuICAgICAgICAgICAgXCJ5XCI6IDEyLFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDQsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiA3LFxyXG4gICAgICAgICAgICBcInlcIjogMTIsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNCxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDgsXHJcbiAgICAgICAgICAgIFwieVwiOiAxMixcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA0LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogOSxcclxuICAgICAgICAgICAgXCJ5XCI6IDEyLFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDEsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAyXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAxMCxcclxuICAgICAgICAgICAgXCJ5XCI6IDEyLFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDEsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAxMSxcclxuICAgICAgICAgICAgXCJ5XCI6IDEyLFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDQsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAxMixcclxuICAgICAgICAgICAgXCJ5XCI6IDEyLFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDQsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAxMyxcclxuICAgICAgICAgICAgXCJ5XCI6IDEyLFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDQsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAxNCxcclxuICAgICAgICAgICAgXCJ5XCI6IDEyLFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDQsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAxNSxcclxuICAgICAgICAgICAgXCJ5XCI6IDEyLFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDQsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAxNixcclxuICAgICAgICAgICAgXCJ5XCI6IDEyLFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDQsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAxNyxcclxuICAgICAgICAgICAgXCJ5XCI6IDEyLFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDQsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAxOCxcclxuICAgICAgICAgICAgXCJ5XCI6IDEyLFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDQsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAxOSxcclxuICAgICAgICAgICAgXCJ5XCI6IDEyLFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDIsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAwLFxyXG4gICAgICAgICAgICBcInlcIjogMTMsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogMixcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDEsXHJcbiAgICAgICAgICAgIFwieVwiOiAxMyxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA0LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMixcclxuICAgICAgICAgICAgXCJ5XCI6IDEzLFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDQsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAzLFxyXG4gICAgICAgICAgICBcInlcIjogMTMsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogMixcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDQsXHJcbiAgICAgICAgICAgIFwieVwiOiAxMyxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiAyLFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogNSxcclxuICAgICAgICAgICAgXCJ5XCI6IDEzLFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDIsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiA2LFxyXG4gICAgICAgICAgICBcInlcIjogMTMsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogMixcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDcsXHJcbiAgICAgICAgICAgIFwieVwiOiAxMyxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA0LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogOCxcclxuICAgICAgICAgICAgXCJ5XCI6IDEzLFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDQsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiA5LFxyXG4gICAgICAgICAgICBcInlcIjogMTMsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogMSxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDJcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDEwLFxyXG4gICAgICAgICAgICBcInlcIjogMTMsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogMSxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDExLFxyXG4gICAgICAgICAgICBcInlcIjogMTMsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNCxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDEyLFxyXG4gICAgICAgICAgICBcInlcIjogMTMsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNCxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDEzLFxyXG4gICAgICAgICAgICBcInlcIjogMTMsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogMixcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDE0LFxyXG4gICAgICAgICAgICBcInlcIjogMTMsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogMixcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDE1LFxyXG4gICAgICAgICAgICBcInlcIjogMTMsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogMixcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDE2LFxyXG4gICAgICAgICAgICBcInlcIjogMTMsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogMixcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDE3LFxyXG4gICAgICAgICAgICBcInlcIjogMTMsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNCxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDE4LFxyXG4gICAgICAgICAgICBcInlcIjogMTMsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNCxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDE5LFxyXG4gICAgICAgICAgICBcInlcIjogMTMsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogMixcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDAsXHJcbiAgICAgICAgICAgIFwieVwiOiAxNCxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiAyLFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMSxcclxuICAgICAgICAgICAgXCJ5XCI6IDE0LFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDQsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAyLFxyXG4gICAgICAgICAgICBcInlcIjogMTQsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNCxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDMsXHJcbiAgICAgICAgICAgIFwieVwiOiAxNCxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiAyLFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogNCxcclxuICAgICAgICAgICAgXCJ5XCI6IDE0LFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAyLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDMsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiA2LFxyXG4gICAgICAgICAgICBcInlcIjogMTQsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogMixcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDcsXHJcbiAgICAgICAgICAgIFwieVwiOiAxNCxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA0LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogOCxcclxuICAgICAgICAgICAgXCJ5XCI6IDE0LFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDQsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiA5LFxyXG4gICAgICAgICAgICBcInlcIjogMTQsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogMSxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDJcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDEwLFxyXG4gICAgICAgICAgICBcInlcIjogMTQsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogMSxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDExLFxyXG4gICAgICAgICAgICBcInlcIjogMTQsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNCxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDEyLFxyXG4gICAgICAgICAgICBcInlcIjogMTQsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNCxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDEzLFxyXG4gICAgICAgICAgICBcInlcIjogMTQsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogMixcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDE0LFxyXG4gICAgICAgICAgICBcInlcIjogMTQsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogMixcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDE1LFxyXG4gICAgICAgICAgICBcInlcIjogMTQsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogMixcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDE2LFxyXG4gICAgICAgICAgICBcInlcIjogMTQsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogMixcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDE3LFxyXG4gICAgICAgICAgICBcInlcIjogMTQsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNCxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDE4LFxyXG4gICAgICAgICAgICBcInlcIjogMTQsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNCxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDE5LFxyXG4gICAgICAgICAgICBcInlcIjogMTQsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogMixcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDAsXHJcbiAgICAgICAgICAgIFwieVwiOiAxNSxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiAyLFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMSxcclxuICAgICAgICAgICAgXCJ5XCI6IDE1LFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDQsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAyLFxyXG4gICAgICAgICAgICBcInlcIjogMTUsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNCxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDMsXHJcbiAgICAgICAgICAgIFwieVwiOiAxNSxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiAyLFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogNixcclxuICAgICAgICAgICAgXCJ5XCI6IDE1LFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDIsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiA3LFxyXG4gICAgICAgICAgICBcInlcIjogMTUsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNCxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDgsXHJcbiAgICAgICAgICAgIFwieVwiOiAxNSxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA0LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogOSxcclxuICAgICAgICAgICAgXCJ5XCI6IDE1LFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDEsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAyXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAxMCxcclxuICAgICAgICAgICAgXCJ5XCI6IDE1LFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDEsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAxMSxcclxuICAgICAgICAgICAgXCJ5XCI6IDE1LFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDQsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAxMixcclxuICAgICAgICAgICAgXCJ5XCI6IDE1LFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDQsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAxMyxcclxuICAgICAgICAgICAgXCJ5XCI6IDE1LFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDIsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAxNCxcclxuICAgICAgICAgICAgXCJ5XCI6IDE1LFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDIsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAxNSxcclxuICAgICAgICAgICAgXCJ5XCI6IDE1LFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDIsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAxNixcclxuICAgICAgICAgICAgXCJ5XCI6IDE1LFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDIsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAxNyxcclxuICAgICAgICAgICAgXCJ5XCI6IDE1LFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDQsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAxOCxcclxuICAgICAgICAgICAgXCJ5XCI6IDE1LFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDQsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAxOSxcclxuICAgICAgICAgICAgXCJ5XCI6IDE1LFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDIsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAwLFxyXG4gICAgICAgICAgICBcInlcIjogMTYsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogMixcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDEsXHJcbiAgICAgICAgICAgIFwieVwiOiAxNixcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA0LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMixcclxuICAgICAgICAgICAgXCJ5XCI6IDE2LFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDQsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAzLFxyXG4gICAgICAgICAgICBcInlcIjogMTYsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogMixcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDQsXHJcbiAgICAgICAgICAgIFwieVwiOiAxNixcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiAyLFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogNSxcclxuICAgICAgICAgICAgXCJ5XCI6IDE2LFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDIsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiA2LFxyXG4gICAgICAgICAgICBcInlcIjogMTYsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogMixcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDcsXHJcbiAgICAgICAgICAgIFwieVwiOiAxNixcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA0LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogOCxcclxuICAgICAgICAgICAgXCJ5XCI6IDE2LFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDQsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiA5LFxyXG4gICAgICAgICAgICBcInlcIjogMTYsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogMSxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDJcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDEwLFxyXG4gICAgICAgICAgICBcInlcIjogMTYsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogMSxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDExLFxyXG4gICAgICAgICAgICBcInlcIjogMTYsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNCxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDEyLFxyXG4gICAgICAgICAgICBcInlcIjogMTYsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNCxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDEzLFxyXG4gICAgICAgICAgICBcInlcIjogMTYsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogMixcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDE0LFxyXG4gICAgICAgICAgICBcInlcIjogMTYsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogMixcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDE1LFxyXG4gICAgICAgICAgICBcInlcIjogMTYsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogMixcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDE2LFxyXG4gICAgICAgICAgICBcInlcIjogMTYsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogMixcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDE3LFxyXG4gICAgICAgICAgICBcInlcIjogMTYsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNCxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDE4LFxyXG4gICAgICAgICAgICBcInlcIjogMTYsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNCxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDE5LFxyXG4gICAgICAgICAgICBcInlcIjogMTYsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogMixcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDAsXHJcbiAgICAgICAgICAgIFwieVwiOiAxNyxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiAyLFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMSxcclxuICAgICAgICAgICAgXCJ5XCI6IDE3LFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDQsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAyLFxyXG4gICAgICAgICAgICBcInlcIjogMTcsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNCxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDMsXHJcbiAgICAgICAgICAgIFwieVwiOiAxNyxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA0LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogNCxcclxuICAgICAgICAgICAgXCJ5XCI6IDE3LFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDQsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiA1LFxyXG4gICAgICAgICAgICBcInlcIjogMTcsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNCxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDYsXHJcbiAgICAgICAgICAgIFwieVwiOiAxNyxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA0LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogNyxcclxuICAgICAgICAgICAgXCJ5XCI6IDE3LFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDQsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiA4LFxyXG4gICAgICAgICAgICBcInlcIjogMTcsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNCxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDksXHJcbiAgICAgICAgICAgIFwieVwiOiAxNyxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiAxLFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMlxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMTAsXHJcbiAgICAgICAgICAgIFwieVwiOiAxNyxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiAxLFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMTEsXHJcbiAgICAgICAgICAgIFwieVwiOiAxNyxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA0LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMTIsXHJcbiAgICAgICAgICAgIFwieVwiOiAxNyxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA0LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMTMsXHJcbiAgICAgICAgICAgIFwieVwiOiAxNyxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA0LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMTQsXHJcbiAgICAgICAgICAgIFwieVwiOiAxNyxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA0LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMTUsXHJcbiAgICAgICAgICAgIFwieVwiOiAxNyxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA0LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMTYsXHJcbiAgICAgICAgICAgIFwieVwiOiAxNyxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA0LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMTcsXHJcbiAgICAgICAgICAgIFwieVwiOiAxNyxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA0LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMTgsXHJcbiAgICAgICAgICAgIFwieVwiOiAxNyxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA0LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMTksXHJcbiAgICAgICAgICAgIFwieVwiOiAxNyxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiAyLFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMCxcclxuICAgICAgICAgICAgXCJ5XCI6IDE4LFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDIsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAxLFxyXG4gICAgICAgICAgICBcInlcIjogMTgsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNCxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDIsXHJcbiAgICAgICAgICAgIFwieVwiOiAxOCxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA0LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMyxcclxuICAgICAgICAgICAgXCJ5XCI6IDE4LFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDQsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiA0LFxyXG4gICAgICAgICAgICBcInlcIjogMTgsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNCxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDUsXHJcbiAgICAgICAgICAgIFwieVwiOiAxOCxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA0LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogNixcclxuICAgICAgICAgICAgXCJ5XCI6IDE4LFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDQsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiA3LFxyXG4gICAgICAgICAgICBcInlcIjogMTgsXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNCxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDgsXHJcbiAgICAgICAgICAgIFwieVwiOiAxOCxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA0LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogOSxcclxuICAgICAgICAgICAgXCJ5XCI6IDE4LFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDEsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAyXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAxMCxcclxuICAgICAgICAgICAgXCJ5XCI6IDE4LFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDEsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAxMSxcclxuICAgICAgICAgICAgXCJ5XCI6IDE4LFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDQsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAxMixcclxuICAgICAgICAgICAgXCJ5XCI6IDE4LFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDQsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAxMyxcclxuICAgICAgICAgICAgXCJ5XCI6IDE4LFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDQsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAxNCxcclxuICAgICAgICAgICAgXCJ5XCI6IDE4LFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDQsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAxNSxcclxuICAgICAgICAgICAgXCJ5XCI6IDE4LFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDQsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAxNixcclxuICAgICAgICAgICAgXCJ5XCI6IDE4LFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDQsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAxNyxcclxuICAgICAgICAgICAgXCJ5XCI6IDE4LFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDQsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAxOCxcclxuICAgICAgICAgICAgXCJ5XCI6IDE4LFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDQsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAxOSxcclxuICAgICAgICAgICAgXCJ5XCI6IDE4LFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDIsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAwLFxyXG4gICAgICAgICAgICBcInlcIjogMTksXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogMixcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDEsXHJcbiAgICAgICAgICAgIFwieVwiOiAxOSxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiAyLFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMixcclxuICAgICAgICAgICAgXCJ5XCI6IDE5LFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDIsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAzLFxyXG4gICAgICAgICAgICBcInlcIjogMTksXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogMixcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDQsXHJcbiAgICAgICAgICAgIFwieVwiOiAxOSxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiAyLFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogNSxcclxuICAgICAgICAgICAgXCJ5XCI6IDE5LFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDIsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiA2LFxyXG4gICAgICAgICAgICBcInlcIjogMTksXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogMixcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDcsXHJcbiAgICAgICAgICAgIFwieVwiOiAxOSxcclxuICAgICAgICAgICAgXCJ6XCI6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiAyLFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogOCxcclxuICAgICAgICAgICAgXCJ5XCI6IDE5LFxyXG4gICAgICAgICAgICBcInpcIjogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDIsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiA5LFxyXG4gICAgICAgICAgICBcInlcIjogMTksXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogMSxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDJcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDEwLFxyXG4gICAgICAgICAgICBcInlcIjogMTksXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogMSxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDExLFxyXG4gICAgICAgICAgICBcInlcIjogMTksXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogMixcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDEyLFxyXG4gICAgICAgICAgICBcInlcIjogMTksXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogMixcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDEzLFxyXG4gICAgICAgICAgICBcInlcIjogMTksXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogMixcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDE0LFxyXG4gICAgICAgICAgICBcInlcIjogMTksXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogMixcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDE1LFxyXG4gICAgICAgICAgICBcInlcIjogMTksXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogMixcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDE2LFxyXG4gICAgICAgICAgICBcInlcIjogMTksXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogMixcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDE3LFxyXG4gICAgICAgICAgICBcInlcIjogMTksXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogMixcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDE4LFxyXG4gICAgICAgICAgICBcInlcIjogMTksXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogMixcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDE5LFxyXG4gICAgICAgICAgICBcInlcIjogMTksXHJcbiAgICAgICAgICAgIFwielwiOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogMixcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9XHJcbiAgICAgIF0sXHJcbiAgICAgIFtcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAwLFxyXG4gICAgICAgICAgICBcInlcIjogMCxcclxuICAgICAgICAgICAgXCJ6XCI6IDFcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA1LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMSxcclxuICAgICAgICAgICAgXCJ5XCI6IDAsXHJcbiAgICAgICAgICAgIFwielwiOiAxXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNSxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDIsXHJcbiAgICAgICAgICAgIFwieVwiOiAwLFxyXG4gICAgICAgICAgICBcInpcIjogMVxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDUsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAzLFxyXG4gICAgICAgICAgICBcInlcIjogMCxcclxuICAgICAgICAgICAgXCJ6XCI6IDFcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA1LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogNCxcclxuICAgICAgICAgICAgXCJ5XCI6IDAsXHJcbiAgICAgICAgICAgIFwielwiOiAxXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNSxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDUsXHJcbiAgICAgICAgICAgIFwieVwiOiAwLFxyXG4gICAgICAgICAgICBcInpcIjogMVxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDUsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiA2LFxyXG4gICAgICAgICAgICBcInlcIjogMCxcclxuICAgICAgICAgICAgXCJ6XCI6IDFcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA1LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogNyxcclxuICAgICAgICAgICAgXCJ5XCI6IDAsXHJcbiAgICAgICAgICAgIFwielwiOiAxXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNSxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDgsXHJcbiAgICAgICAgICAgIFwieVwiOiAwLFxyXG4gICAgICAgICAgICBcInpcIjogMVxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDUsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAxMSxcclxuICAgICAgICAgICAgXCJ5XCI6IDAsXHJcbiAgICAgICAgICAgIFwielwiOiAxXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNSxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDEyLFxyXG4gICAgICAgICAgICBcInlcIjogMCxcclxuICAgICAgICAgICAgXCJ6XCI6IDFcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA1LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMTMsXHJcbiAgICAgICAgICAgIFwieVwiOiAwLFxyXG4gICAgICAgICAgICBcInpcIjogMVxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDUsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAxNCxcclxuICAgICAgICAgICAgXCJ5XCI6IDAsXHJcbiAgICAgICAgICAgIFwielwiOiAxXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNSxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDE1LFxyXG4gICAgICAgICAgICBcInlcIjogMCxcclxuICAgICAgICAgICAgXCJ6XCI6IDFcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA1LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMTYsXHJcbiAgICAgICAgICAgIFwieVwiOiAwLFxyXG4gICAgICAgICAgICBcInpcIjogMVxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDUsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAxNyxcclxuICAgICAgICAgICAgXCJ5XCI6IDAsXHJcbiAgICAgICAgICAgIFwielwiOiAxXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNSxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDE4LFxyXG4gICAgICAgICAgICBcInlcIjogMCxcclxuICAgICAgICAgICAgXCJ6XCI6IDFcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA1LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMTksXHJcbiAgICAgICAgICAgIFwieVwiOiAwLFxyXG4gICAgICAgICAgICBcInpcIjogMVxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDUsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAwLFxyXG4gICAgICAgICAgICBcInlcIjogMSxcclxuICAgICAgICAgICAgXCJ6XCI6IDFcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA1LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMTksXHJcbiAgICAgICAgICAgIFwieVwiOiAxLFxyXG4gICAgICAgICAgICBcInpcIjogMVxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDUsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAwLFxyXG4gICAgICAgICAgICBcInlcIjogMixcclxuICAgICAgICAgICAgXCJ6XCI6IDFcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA1LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMTksXHJcbiAgICAgICAgICAgIFwieVwiOiAyLFxyXG4gICAgICAgICAgICBcInpcIjogMVxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDUsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAwLFxyXG4gICAgICAgICAgICBcInlcIjogMyxcclxuICAgICAgICAgICAgXCJ6XCI6IDFcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA1LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMyxcclxuICAgICAgICAgICAgXCJ5XCI6IDMsXHJcbiAgICAgICAgICAgIFwielwiOiAxXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNSxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDQsXHJcbiAgICAgICAgICAgIFwieVwiOiAzLFxyXG4gICAgICAgICAgICBcInpcIjogMVxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDUsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiA1LFxyXG4gICAgICAgICAgICBcInlcIjogMyxcclxuICAgICAgICAgICAgXCJ6XCI6IDFcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA1LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogNixcclxuICAgICAgICAgICAgXCJ5XCI6IDMsXHJcbiAgICAgICAgICAgIFwielwiOiAxXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNSxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDEzLFxyXG4gICAgICAgICAgICBcInlcIjogMyxcclxuICAgICAgICAgICAgXCJ6XCI6IDFcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA1LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMTQsXHJcbiAgICAgICAgICAgIFwieVwiOiAzLFxyXG4gICAgICAgICAgICBcInpcIjogMVxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDUsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAxNSxcclxuICAgICAgICAgICAgXCJ5XCI6IDMsXHJcbiAgICAgICAgICAgIFwielwiOiAxXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNSxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDE2LFxyXG4gICAgICAgICAgICBcInlcIjogMyxcclxuICAgICAgICAgICAgXCJ6XCI6IDFcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA1LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMTksXHJcbiAgICAgICAgICAgIFwieVwiOiAzLFxyXG4gICAgICAgICAgICBcInpcIjogMVxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDUsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAwLFxyXG4gICAgICAgICAgICBcInlcIjogNCxcclxuICAgICAgICAgICAgXCJ6XCI6IDFcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA1LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMyxcclxuICAgICAgICAgICAgXCJ5XCI6IDQsXHJcbiAgICAgICAgICAgIFwielwiOiAxXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNSxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDQsXHJcbiAgICAgICAgICAgIFwieVwiOiA0LFxyXG4gICAgICAgICAgICBcInpcIjogMVxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDUsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiA1LFxyXG4gICAgICAgICAgICBcInlcIjogNCxcclxuICAgICAgICAgICAgXCJ6XCI6IDFcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA1LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogNixcclxuICAgICAgICAgICAgXCJ5XCI6IDQsXHJcbiAgICAgICAgICAgIFwielwiOiAxXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNSxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDEzLFxyXG4gICAgICAgICAgICBcInlcIjogNCxcclxuICAgICAgICAgICAgXCJ6XCI6IDFcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA1LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMTQsXHJcbiAgICAgICAgICAgIFwieVwiOiA0LFxyXG4gICAgICAgICAgICBcInpcIjogMVxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAyLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDYsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAxNixcclxuICAgICAgICAgICAgXCJ5XCI6IDQsXHJcbiAgICAgICAgICAgIFwielwiOiAxXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNSxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDE5LFxyXG4gICAgICAgICAgICBcInlcIjogNCxcclxuICAgICAgICAgICAgXCJ6XCI6IDFcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA1LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMCxcclxuICAgICAgICAgICAgXCJ5XCI6IDUsXHJcbiAgICAgICAgICAgIFwielwiOiAxXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNSxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDMsXHJcbiAgICAgICAgICAgIFwieVwiOiA1LFxyXG4gICAgICAgICAgICBcInpcIjogMVxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDUsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiA0LFxyXG4gICAgICAgICAgICBcInlcIjogNSxcclxuICAgICAgICAgICAgXCJ6XCI6IDFcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA1LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogNSxcclxuICAgICAgICAgICAgXCJ5XCI6IDUsXHJcbiAgICAgICAgICAgIFwielwiOiAxXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNSxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDYsXHJcbiAgICAgICAgICAgIFwieVwiOiA1LFxyXG4gICAgICAgICAgICBcInpcIjogMVxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDUsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAxMyxcclxuICAgICAgICAgICAgXCJ5XCI6IDUsXHJcbiAgICAgICAgICAgIFwielwiOiAxXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNSxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDE2LFxyXG4gICAgICAgICAgICBcInlcIjogNSxcclxuICAgICAgICAgICAgXCJ6XCI6IDFcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA1LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMTksXHJcbiAgICAgICAgICAgIFwieVwiOiA1LFxyXG4gICAgICAgICAgICBcInpcIjogMVxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDUsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAwLFxyXG4gICAgICAgICAgICBcInlcIjogNixcclxuICAgICAgICAgICAgXCJ6XCI6IDFcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA1LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMyxcclxuICAgICAgICAgICAgXCJ5XCI6IDYsXHJcbiAgICAgICAgICAgIFwielwiOiAxXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNSxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDQsXHJcbiAgICAgICAgICAgIFwieVwiOiA2LFxyXG4gICAgICAgICAgICBcInpcIjogMVxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDUsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiA1LFxyXG4gICAgICAgICAgICBcInlcIjogNixcclxuICAgICAgICAgICAgXCJ6XCI6IDFcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA1LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogNixcclxuICAgICAgICAgICAgXCJ5XCI6IDYsXHJcbiAgICAgICAgICAgIFwielwiOiAxXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNSxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDEzLFxyXG4gICAgICAgICAgICBcInlcIjogNixcclxuICAgICAgICAgICAgXCJ6XCI6IDFcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA1LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMTQsXHJcbiAgICAgICAgICAgIFwieVwiOiA2LFxyXG4gICAgICAgICAgICBcInpcIjogMVxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDUsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAxNSxcclxuICAgICAgICAgICAgXCJ5XCI6IDYsXHJcbiAgICAgICAgICAgIFwielwiOiAxXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNSxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDE2LFxyXG4gICAgICAgICAgICBcInlcIjogNixcclxuICAgICAgICAgICAgXCJ6XCI6IDFcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA1LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMTksXHJcbiAgICAgICAgICAgIFwieVwiOiA2LFxyXG4gICAgICAgICAgICBcInpcIjogMVxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDUsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAwLFxyXG4gICAgICAgICAgICBcInlcIjogNyxcclxuICAgICAgICAgICAgXCJ6XCI6IDFcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA1LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMTksXHJcbiAgICAgICAgICAgIFwieVwiOiA3LFxyXG4gICAgICAgICAgICBcInpcIjogMVxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDUsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAwLFxyXG4gICAgICAgICAgICBcInlcIjogOCxcclxuICAgICAgICAgICAgXCJ6XCI6IDFcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA1LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogNyxcclxuICAgICAgICAgICAgXCJ5XCI6IDgsXHJcbiAgICAgICAgICAgIFwielwiOiAxXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNSxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDgsXHJcbiAgICAgICAgICAgIFwieVwiOiA4LFxyXG4gICAgICAgICAgICBcInpcIjogMVxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDUsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAxMSxcclxuICAgICAgICAgICAgXCJ5XCI6IDgsXHJcbiAgICAgICAgICAgIFwielwiOiAxXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNSxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDEyLFxyXG4gICAgICAgICAgICBcInlcIjogOCxcclxuICAgICAgICAgICAgXCJ6XCI6IDFcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA1LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMTksXHJcbiAgICAgICAgICAgIFwieVwiOiA4LFxyXG4gICAgICAgICAgICBcInpcIjogMVxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDUsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAwLFxyXG4gICAgICAgICAgICBcInlcIjogOSxcclxuICAgICAgICAgICAgXCJ6XCI6IDFcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA1LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMSxcclxuICAgICAgICAgICAgXCJ5XCI6IDksXHJcbiAgICAgICAgICAgIFwielwiOiAxXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNSxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDIsXHJcbiAgICAgICAgICAgIFwieVwiOiA5LFxyXG4gICAgICAgICAgICBcInpcIjogMVxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDUsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAzLFxyXG4gICAgICAgICAgICBcInlcIjogOSxcclxuICAgICAgICAgICAgXCJ6XCI6IDFcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA1LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogNCxcclxuICAgICAgICAgICAgXCJ5XCI6IDksXHJcbiAgICAgICAgICAgIFwielwiOiAxXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNSxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDcsXHJcbiAgICAgICAgICAgIFwieVwiOiA5LFxyXG4gICAgICAgICAgICBcInpcIjogMVxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDUsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiA4LFxyXG4gICAgICAgICAgICBcInlcIjogOSxcclxuICAgICAgICAgICAgXCJ6XCI6IDFcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA1LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMTEsXHJcbiAgICAgICAgICAgIFwieVwiOiA5LFxyXG4gICAgICAgICAgICBcInpcIjogMVxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDUsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAxMixcclxuICAgICAgICAgICAgXCJ5XCI6IDksXHJcbiAgICAgICAgICAgIFwielwiOiAxXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNSxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDE1LFxyXG4gICAgICAgICAgICBcInlcIjogOSxcclxuICAgICAgICAgICAgXCJ6XCI6IDFcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA1LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMTYsXHJcbiAgICAgICAgICAgIFwieVwiOiA5LFxyXG4gICAgICAgICAgICBcInpcIjogMVxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDUsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAxNyxcclxuICAgICAgICAgICAgXCJ5XCI6IDksXHJcbiAgICAgICAgICAgIFwielwiOiAxXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNSxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDE4LFxyXG4gICAgICAgICAgICBcInlcIjogOSxcclxuICAgICAgICAgICAgXCJ6XCI6IDFcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA1LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMTksXHJcbiAgICAgICAgICAgIFwieVwiOiA5LFxyXG4gICAgICAgICAgICBcInpcIjogMVxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDUsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAwLFxyXG4gICAgICAgICAgICBcInlcIjogMTAsXHJcbiAgICAgICAgICAgIFwielwiOiAxXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNSxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDEsXHJcbiAgICAgICAgICAgIFwieVwiOiAxMCxcclxuICAgICAgICAgICAgXCJ6XCI6IDFcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA1LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMixcclxuICAgICAgICAgICAgXCJ5XCI6IDEwLFxyXG4gICAgICAgICAgICBcInpcIjogMVxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDUsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAzLFxyXG4gICAgICAgICAgICBcInlcIjogMTAsXHJcbiAgICAgICAgICAgIFwielwiOiAxXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNSxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDQsXHJcbiAgICAgICAgICAgIFwieVwiOiAxMCxcclxuICAgICAgICAgICAgXCJ6XCI6IDFcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA1LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogNyxcclxuICAgICAgICAgICAgXCJ5XCI6IDEwLFxyXG4gICAgICAgICAgICBcInpcIjogMVxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDUsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiA4LFxyXG4gICAgICAgICAgICBcInlcIjogMTAsXHJcbiAgICAgICAgICAgIFwielwiOiAxXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNSxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDExLFxyXG4gICAgICAgICAgICBcInlcIjogMTAsXHJcbiAgICAgICAgICAgIFwielwiOiAxXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNSxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDEyLFxyXG4gICAgICAgICAgICBcInlcIjogMTAsXHJcbiAgICAgICAgICAgIFwielwiOiAxXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNSxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDE1LFxyXG4gICAgICAgICAgICBcInlcIjogMTAsXHJcbiAgICAgICAgICAgIFwielwiOiAxXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNSxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDE2LFxyXG4gICAgICAgICAgICBcInlcIjogMTAsXHJcbiAgICAgICAgICAgIFwielwiOiAxXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNSxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDE3LFxyXG4gICAgICAgICAgICBcInlcIjogMTAsXHJcbiAgICAgICAgICAgIFwielwiOiAxXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNSxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDE4LFxyXG4gICAgICAgICAgICBcInlcIjogMTAsXHJcbiAgICAgICAgICAgIFwielwiOiAxXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNSxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDE5LFxyXG4gICAgICAgICAgICBcInlcIjogMTAsXHJcbiAgICAgICAgICAgIFwielwiOiAxXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNSxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDAsXHJcbiAgICAgICAgICAgIFwieVwiOiAxMSxcclxuICAgICAgICAgICAgXCJ6XCI6IDFcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA1LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogNyxcclxuICAgICAgICAgICAgXCJ5XCI6IDExLFxyXG4gICAgICAgICAgICBcInpcIjogMVxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDUsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiA4LFxyXG4gICAgICAgICAgICBcInlcIjogMTEsXHJcbiAgICAgICAgICAgIFwielwiOiAxXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNSxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDExLFxyXG4gICAgICAgICAgICBcInlcIjogMTEsXHJcbiAgICAgICAgICAgIFwielwiOiAxXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNSxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDEyLFxyXG4gICAgICAgICAgICBcInlcIjogMTEsXHJcbiAgICAgICAgICAgIFwielwiOiAxXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNSxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDE5LFxyXG4gICAgICAgICAgICBcInlcIjogMTEsXHJcbiAgICAgICAgICAgIFwielwiOiAxXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNSxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDAsXHJcbiAgICAgICAgICAgIFwieVwiOiAxMixcclxuICAgICAgICAgICAgXCJ6XCI6IDFcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA1LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMTksXHJcbiAgICAgICAgICAgIFwieVwiOiAxMixcclxuICAgICAgICAgICAgXCJ6XCI6IDFcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA1LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMCxcclxuICAgICAgICAgICAgXCJ5XCI6IDEzLFxyXG4gICAgICAgICAgICBcInpcIjogMVxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDUsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAzLFxyXG4gICAgICAgICAgICBcInlcIjogMTMsXHJcbiAgICAgICAgICAgIFwielwiOiAxXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNSxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDQsXHJcbiAgICAgICAgICAgIFwieVwiOiAxMyxcclxuICAgICAgICAgICAgXCJ6XCI6IDFcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA1LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogNSxcclxuICAgICAgICAgICAgXCJ5XCI6IDEzLFxyXG4gICAgICAgICAgICBcInpcIjogMVxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDUsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiA2LFxyXG4gICAgICAgICAgICBcInlcIjogMTMsXHJcbiAgICAgICAgICAgIFwielwiOiAxXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNSxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDEzLFxyXG4gICAgICAgICAgICBcInlcIjogMTMsXHJcbiAgICAgICAgICAgIFwielwiOiAxXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNSxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDE0LFxyXG4gICAgICAgICAgICBcInlcIjogMTMsXHJcbiAgICAgICAgICAgIFwielwiOiAxXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNSxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDE1LFxyXG4gICAgICAgICAgICBcInlcIjogMTMsXHJcbiAgICAgICAgICAgIFwielwiOiAxXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNSxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDE2LFxyXG4gICAgICAgICAgICBcInlcIjogMTMsXHJcbiAgICAgICAgICAgIFwielwiOiAxXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNSxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDE5LFxyXG4gICAgICAgICAgICBcInlcIjogMTMsXHJcbiAgICAgICAgICAgIFwielwiOiAxXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNSxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDAsXHJcbiAgICAgICAgICAgIFwieVwiOiAxNCxcclxuICAgICAgICAgICAgXCJ6XCI6IDFcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA1LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMyxcclxuICAgICAgICAgICAgXCJ5XCI6IDE0LFxyXG4gICAgICAgICAgICBcInpcIjogMVxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDUsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiA0LFxyXG4gICAgICAgICAgICBcInlcIjogMTQsXHJcbiAgICAgICAgICAgIFwielwiOiAxXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDIsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNyxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDJcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDYsXHJcbiAgICAgICAgICAgIFwieVwiOiAxNCxcclxuICAgICAgICAgICAgXCJ6XCI6IDFcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA1LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMTMsXHJcbiAgICAgICAgICAgIFwieVwiOiAxNCxcclxuICAgICAgICAgICAgXCJ6XCI6IDFcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA1LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMTQsXHJcbiAgICAgICAgICAgIFwieVwiOiAxNCxcclxuICAgICAgICAgICAgXCJ6XCI6IDFcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA1LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMTUsXHJcbiAgICAgICAgICAgIFwieVwiOiAxNCxcclxuICAgICAgICAgICAgXCJ6XCI6IDFcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA1LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMTYsXHJcbiAgICAgICAgICAgIFwieVwiOiAxNCxcclxuICAgICAgICAgICAgXCJ6XCI6IDFcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA1LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMTksXHJcbiAgICAgICAgICAgIFwieVwiOiAxNCxcclxuICAgICAgICAgICAgXCJ6XCI6IDFcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA1LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMCxcclxuICAgICAgICAgICAgXCJ5XCI6IDE1LFxyXG4gICAgICAgICAgICBcInpcIjogMVxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDUsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAzLFxyXG4gICAgICAgICAgICBcInlcIjogMTUsXHJcbiAgICAgICAgICAgIFwielwiOiAxXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNSxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDYsXHJcbiAgICAgICAgICAgIFwieVwiOiAxNSxcclxuICAgICAgICAgICAgXCJ6XCI6IDFcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA1LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMTMsXHJcbiAgICAgICAgICAgIFwieVwiOiAxNSxcclxuICAgICAgICAgICAgXCJ6XCI6IDFcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA1LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMTQsXHJcbiAgICAgICAgICAgIFwieVwiOiAxNSxcclxuICAgICAgICAgICAgXCJ6XCI6IDFcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA1LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMTUsXHJcbiAgICAgICAgICAgIFwieVwiOiAxNSxcclxuICAgICAgICAgICAgXCJ6XCI6IDFcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA1LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMTYsXHJcbiAgICAgICAgICAgIFwieVwiOiAxNSxcclxuICAgICAgICAgICAgXCJ6XCI6IDFcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA1LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMTksXHJcbiAgICAgICAgICAgIFwieVwiOiAxNSxcclxuICAgICAgICAgICAgXCJ6XCI6IDFcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA1LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMCxcclxuICAgICAgICAgICAgXCJ5XCI6IDE2LFxyXG4gICAgICAgICAgICBcInpcIjogMVxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDUsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAzLFxyXG4gICAgICAgICAgICBcInlcIjogMTYsXHJcbiAgICAgICAgICAgIFwielwiOiAxXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNSxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDQsXHJcbiAgICAgICAgICAgIFwieVwiOiAxNixcclxuICAgICAgICAgICAgXCJ6XCI6IDFcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA1LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogNSxcclxuICAgICAgICAgICAgXCJ5XCI6IDE2LFxyXG4gICAgICAgICAgICBcInpcIjogMVxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDUsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiA2LFxyXG4gICAgICAgICAgICBcInlcIjogMTYsXHJcbiAgICAgICAgICAgIFwielwiOiAxXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNSxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDEzLFxyXG4gICAgICAgICAgICBcInlcIjogMTYsXHJcbiAgICAgICAgICAgIFwielwiOiAxXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNSxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDE0LFxyXG4gICAgICAgICAgICBcInlcIjogMTYsXHJcbiAgICAgICAgICAgIFwielwiOiAxXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNSxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDE1LFxyXG4gICAgICAgICAgICBcInlcIjogMTYsXHJcbiAgICAgICAgICAgIFwielwiOiAxXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNSxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDE2LFxyXG4gICAgICAgICAgICBcInlcIjogMTYsXHJcbiAgICAgICAgICAgIFwielwiOiAxXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNSxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDE5LFxyXG4gICAgICAgICAgICBcInlcIjogMTYsXHJcbiAgICAgICAgICAgIFwielwiOiAxXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNSxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDAsXHJcbiAgICAgICAgICAgIFwieVwiOiAxNyxcclxuICAgICAgICAgICAgXCJ6XCI6IDFcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA1LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMTksXHJcbiAgICAgICAgICAgIFwieVwiOiAxNyxcclxuICAgICAgICAgICAgXCJ6XCI6IDFcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA1LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMCxcclxuICAgICAgICAgICAgXCJ5XCI6IDE4LFxyXG4gICAgICAgICAgICBcInpcIjogMVxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDUsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAxOSxcclxuICAgICAgICAgICAgXCJ5XCI6IDE4LFxyXG4gICAgICAgICAgICBcInpcIjogMVxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDUsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAwLFxyXG4gICAgICAgICAgICBcInlcIjogMTksXHJcbiAgICAgICAgICAgIFwielwiOiAxXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNSxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDEsXHJcbiAgICAgICAgICAgIFwieVwiOiAxOSxcclxuICAgICAgICAgICAgXCJ6XCI6IDFcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA1LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogMixcclxuICAgICAgICAgICAgXCJ5XCI6IDE5LFxyXG4gICAgICAgICAgICBcInpcIjogMVxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDUsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAzLFxyXG4gICAgICAgICAgICBcInlcIjogMTksXHJcbiAgICAgICAgICAgIFwielwiOiAxXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNSxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDQsXHJcbiAgICAgICAgICAgIFwieVwiOiAxOSxcclxuICAgICAgICAgICAgXCJ6XCI6IDFcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA1LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogNSxcclxuICAgICAgICAgICAgXCJ5XCI6IDE5LFxyXG4gICAgICAgICAgICBcInpcIjogMVxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDUsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiA2LFxyXG4gICAgICAgICAgICBcInlcIjogMTksXHJcbiAgICAgICAgICAgIFwielwiOiAxXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzaXplXCI6IDEsXHJcbiAgICAgICAgICBcInRpbGVfaWRcIjogNSxcclxuICAgICAgICAgIFwicm90YXRlXCI6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiY29vcmRzXCI6IHtcclxuICAgICAgICAgICAgXCJ4XCI6IDcsXHJcbiAgICAgICAgICAgIFwieVwiOiAxOSxcclxuICAgICAgICAgICAgXCJ6XCI6IDFcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcInNpemVcIjogMSxcclxuICAgICAgICAgIFwidGlsZV9pZFwiOiA1LFxyXG4gICAgICAgICAgXCJyb3RhdGVcIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJjb29yZHNcIjoge1xyXG4gICAgICAgICAgICBcInhcIjogOCxcclxuICAgICAgICAgICAgXCJ5XCI6IDE5LFxyXG4gICAgICAgICAgICBcInpcIjogMVxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDUsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAxMSxcclxuICAgICAgICAgICAgXCJ5XCI6IDE5LFxyXG4gICAgICAgICAgICBcInpcIjogMVxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDUsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAxMixcclxuICAgICAgICAgICAgXCJ5XCI6IDE5LFxyXG4gICAgICAgICAgICBcInpcIjogMVxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDUsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAxMyxcclxuICAgICAgICAgICAgXCJ5XCI6IDE5LFxyXG4gICAgICAgICAgICBcInpcIjogMVxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDUsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAxNCxcclxuICAgICAgICAgICAgXCJ5XCI6IDE5LFxyXG4gICAgICAgICAgICBcInpcIjogMVxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDUsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAxNSxcclxuICAgICAgICAgICAgXCJ5XCI6IDE5LFxyXG4gICAgICAgICAgICBcInpcIjogMVxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDUsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAxNixcclxuICAgICAgICAgICAgXCJ5XCI6IDE5LFxyXG4gICAgICAgICAgICBcInpcIjogMVxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDUsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAxNyxcclxuICAgICAgICAgICAgXCJ5XCI6IDE5LFxyXG4gICAgICAgICAgICBcInpcIjogMVxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDUsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAxOCxcclxuICAgICAgICAgICAgXCJ5XCI6IDE5LFxyXG4gICAgICAgICAgICBcInpcIjogMVxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDUsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImNvb3Jkc1wiOiB7XHJcbiAgICAgICAgICAgIFwieFwiOiAxOSxcclxuICAgICAgICAgICAgXCJ5XCI6IDE5LFxyXG4gICAgICAgICAgICBcInpcIjogMVxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwic2l6ZVwiOiAxLFxyXG4gICAgICAgICAgXCJ0aWxlX2lkXCI6IDUsXHJcbiAgICAgICAgICBcInJvdGF0ZVwiOiAwXHJcbiAgICAgICAgfVxyXG4gICAgICBdXHJcbiAgICBdXHJcbiAgfVxyXG59IiwiY29uc3QgQ3JSb3V0aW5nID0gcmVxdWlyZShcIkFzeW5Db21tdW5cIikuQ3JSb3V0ZXI7XHJcbmNvbnN0IENyQ29tbXVuID0gcmVxdWlyZShcIkFzeW5Db21tdW5cIikuQ3JDb21tdW5pY2F0b3I7XHJcblxyXG5jb25zdCBDclJlc291cmNlcyA9IHJlcXVpcmUoXCJSZXNDYXQuanNcIik7XHJcbmNvbnN0IENyTWFwID0gcmVxdWlyZShcIi4vTWFwLmpzXCIpO1xyXG5jb25zdCBDckJ1bGxldHMgPSByZXF1aXJlKFwiLi9CdWxsZXRzLmpzXCIpO1xyXG5jb25zdCBDckJsb2NrcyA9IHJlcXVpcmUoXCIuL0Jsb2Nrcy5qc1wiKTtcclxuY29uc3QgQ3JHYW1lciA9IHJlcXVpcmUoXCIuL2FjdG9yX2dhbWVyLmpzXCIpO1xyXG5jb25zdCBDckdhbWVNb2RlID0gcmVxdWlyZShcIi4vR2FtZU1vZGUuanNcIik7XHJcblxyXG5mdW5jdGlvbiBDclNlc3Npb24oR2FtZXJzRGF0YSwgTWFwX2RhdGEsIERlc3Ryb3kpe1xyXG5cdHZhciBQYXJhbSA9IHtcclxuXHRcdG1heF9raWxsczogNVxyXG5cdH1cclxuXHJcbi8vPT09PT09PT09PT09PT09PT09PT1Jbml0U2Vzc2lvbj09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuXHRNYXBfZGF0YS5yZXNwID0gUmVzcE1hcChNYXBfZGF0YSk7XHJcblx0TWFwX2RhdGEuc2l6ZSA9IE1hcF9kYXRhLm1hcC5zaXplcy53aWR0aDtcclxuXHJcblx0dmFyIHJlYWR5ID0gZmFsc2U7XHJcblx0XHJcblx0dmFyIFJvdXRlciA9IG5ldyBDclJvdXRpbmcoKTtcclxuXHR2YXIgTWFwQ29tbXVuID0gbmV3IENyQ29tbXVuKCk7XHJcblx0dmFyIEdhbWVNb2RlQ29tbXVuID0gbmV3IENyQ29tbXVuKCk7XHJcblx0dmFyIEJ1bGxldHNDb21tdW4gPSBuZXcgQ3JDb21tdW4oKTtcclxuXHR2YXIgQmxvY2tzQ29tbXVuID0gbmV3IENyQ29tbXVuKCk7XHJcblx0dmFyIFJlc291cmNlc0NvbW11biA9IG5ldyBDckNvbW11bigpO1xyXG5cdHZhciBQbGF5ZXJzTWFuYWdlckNvbW11biA9IG5ldyBDckNvbW11bigpO1xyXG5cclxuXHRSb3V0ZXIoTWFwQ29tbXVuLCBcIkRlZmF1bHRcIik7XHJcblx0Um91dGVyKEdhbWVNb2RlQ29tbXVuLCBcIkdhbWVNb2RlXCIpO1xyXG5cdFJvdXRlcihCdWxsZXRzQ29tbXVuLCBcIkJ1bGxldHNcIik7XHJcblx0Um91dGVyKEJsb2Nrc0NvbW11biwgXCJCbG9ja3NcIik7XHJcblx0Um91dGVyKFJlc291cmNlc0NvbW11biwgXCJSZXNvdXJjZXNcIik7XHJcblx0Um91dGVyKFBsYXllcnNNYW5hZ2VyQ29tbXVuLCBcIlBsYXllcnNNYW5hZ2VyXCIpO1xyXG5cclxuXHRjb25zdCByZXNvdXJjZXMgPSBuZXcgQ3JSZXNvdXJjZXMoKTtcclxuXHJcblx0Q3JNYXAoTWFwQ29tbXVuLCBNYXBfZGF0YSk7XHJcblx0Q3JHYW1lTW9kZShHYW1lTW9kZUNvbW11biwgUGFyYW0pO1xyXG5cdENyQnVsbGV0cyhCdWxsZXRzQ29tbXVuKTtcclxuXHRDckJsb2NrcyhCbG9ja3NDb21tdW4sIEpTT04uc3RyaW5naWZ5KE1hcF9kYXRhKSk7XHJcblx0cmVzb3VyY2VzLmNvbm5lY3QoUmVzb3VyY2VzQ29tbXVuKTtcclxuXHRcclxuLy89PT09PT09PT09PT09PT09PT09PVBsYXllcnNNYW5hZ2VyPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuXHR2YXIgU2VuZCA9IFBsYXllcnNNYW5hZ2VyQ29tbXVuLmNvbm5lY3QoSW5wdXQpO1xyXG5cclxuXHR2YXIgR2FtZXJzID0gTWFwX2RhdGEucmVzcC5tYXAoZnVuY3Rpb24ocmVzcCwgaSl7XHJcblx0XHR2YXIgR2FtZXJDb21tdW4gPSBuZXcgQ3JDb21tdW4oKTtcclxuXHRcdFJvdXRlcihHYW1lckNvbW11biwgaSk7XHJcblx0XHRyZXR1cm4gbmV3IENyR2FtZXIoR2FtZXJDb21tdW4pO1xyXG5cdH0pO1xyXG5cdFxyXG5cdHZhciBMZW5fR2FtZXJzID0gR2FtZXJzLmxlbmd0aDtcclxuXHR2YXIgUmVhZHlfR2FtZXJzID0gMDtcclxuXHR2YXIgUGxheV9HYW1lcnMgPSAwO1xyXG5cclxuXHR0aGlzLkNvbm5lY3QgPSBmdW5jdGlvbihDbGllbnQpe1xyXG5cdFx0Y29uc29sZS5pbmZvKFwiQ29ubmVjdGluZyBnYW1lci4uLlwiKTtcclxuXHJcblx0XHRDbGllbnQuZGF0YSA9IEdhbWVyc0RhdGFbQ2xpZW50LmxvZ2luXTtcclxuXHRcdFxyXG5cdFx0aWYoTGVuX0dhbWVycyAhPT0gUmVhZHlfR2FtZXJzKXtcclxuXHRcdFx0R2FtZXJzW1JlYWR5X0dhbWVyc10uQ29ubmVjdChDbGllbnQpO1xyXG5cdFx0XHRSZWFkeV9HYW1lcnMrKztcclxuXHJcblx0XHRcdGNvbnNvbGUuaW5mbyhcIkNvbm5lY3RlZCBcIiArIENsaWVudC5sb2dpbik7XHJcblx0XHR9XHJcblx0XHRlbHNlIFxyXG5cdFx0XHRDbGllbnQuZGlzY29ubmVjdCh7YWN0aW9uOiBcIlN0YXRcIiwgZGF0YToge1N0YXR1czogXCJNYXggZ2FtZXJzIG9uIG1hcCFcIn19KTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIElucHV0KG1lc3Mpe1xyXG5cdFx0aWYobWVzcy5hY3Rpb24gPT0gXCJDb25uZWN0XCIpXHJcblx0XHRcdHJldHVybjtcclxuXHJcblx0XHRzd2l0Y2gobWVzcy50eXBlKXtcclxuXHRcdFx0Y2FzZSBcIlRpbGVzXCI6ICBUaWxlc0lucHV0KG1lc3MpOyBicmVhaztcclxuXHRcdFx0Y2FzZSBcIkdhbWVyXCI6IEdhbWVyc0lucHV0KG1lc3MpOyBicmVhaztcclxuXHRcdFx0Y2FzZSBcIkFjdG9yXCI6IFNlbmRQbGF5ZXJzKG1lc3MpOyBicmVhaztcclxuXHRcdFx0ZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKEpTT04uc3RyaW5naWZ5KG1lc3MpLCBcIlwiLCA0KTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIEdhbWVyc0lucHV0KG1lc3Mpe1xyXG5cdFx0c3dpdGNoKG1lc3MuYWN0aW9uKXtcclxuXHRcdFx0Y2FzZSBcIlJlYWR5XCI6ICBSZWFkeShtZXNzKTsgYnJlYWs7XHJcblx0XHRcdGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcihKU09OLnN0cmluZ2lmeShtZXNzKSwgXCJcIiwgNCk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBUaWxlc0lucHV0KG1lc3Mpe1xyXG5cdFx0U2VuZFBsYXllcnMobWVzcyk7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBSZWFkeShtZXNzKXtcclxuXHRcdFBsYXlfR2FtZXJzKys7XHJcblx0XHRjb25zb2xlLmluZm8oXCJHYW1lciBOXCIgKyBtZXNzLmlkICsgXCIgaXMgcmVhZHkuXCIpO1xyXG5cclxuXHRcdGlmKFBsYXlfR2FtZXJzID09PSBMZW5fR2FtZXJzKVxyXG5cdFx0XHRHYW1lcnMuZm9yRWFjaChmdW5jdGlvbihHYW1lcil7R2FtZXIuUmVhZHkoKX0pO1xyXG5cdH1cclxuXHRcclxuXHRmdW5jdGlvbiBEZXN0cm95R2FtZXIoaW5kZXgpe1xyXG5cdFx0UmVhZHlfR2FtZXJzW2luZGV4XS5EZXN0cm95KCk7XHJcblx0XHRkZWxldGUgUmVhZHlfR2FtZXJzW2luZGV4XTtcclxuXHRcdGlmKHJlYWR5ICYmIFJlYWR5X0dhbWVycy5ldmVyeShmdW5jdGlvbihnYW1lcil7cmV0dXJuICFnYW1lcjt9KSkgRGVzdHJveSgpO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gU2VuZFBsYXllcnMobWVzcyl7XHJcblx0XHRPYmplY3QuZnJlZXplKG1lc3MpO1xyXG5cdFx0R2FtZXJzLmZvckVhY2goU2VuZFBsYXllci5iaW5kKG51bGwsIG1lc3MpKTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIFNlbmRQbGF5ZXIobWVzcywgcGxheWVyLCBpKXtcclxuXHRcdHBsYXllci5JbnB1dChtZXNzKTtcclxuXHR9XHJcblx0XHJcbn1cclxuXHJcbmZ1bmN0aW9uIFJlc3BNYXAobWFwX2RhdGEpe1xyXG5cdHJldHVybiBtYXBfZGF0YS50aWxlcy5maWx0ZXIoXHJcblx0XHQodGlsZSk9PiAodGlsZS50eXBlID09IFwic3Bhd25lclwiKVxyXG5cdCkubWFwKEdldFRpbGVDb29yZHMpLmZpbHRlcigocmVzcCk9PiByZXNwLmxlbmd0aClcclxuXHJcblxyXG5cdGZ1bmN0aW9uIEdldFRpbGVDb29yZHModGlsZSl7XHJcblx0XHR2YXIgbGF5ZXJzID0gbWFwX2RhdGEubWFwLmxheWVycztcclxuXHRcdHZhciBibG9ja3MgPSBbXTtcclxuXHJcblx0XHRsYXllcnMuZm9yRWFjaCgobGF5ZXIpPT5cclxuXHRcdFx0bGF5ZXIuZm9yRWFjaChmdW5jdGlvbihibG9jayl7XHJcblx0XHRcdFx0aWYodGlsZS5pZCA9PSBibG9jay50aWxlX2lkKVxyXG5cdFx0XHRcdFx0YmxvY2tzLnB1c2goYmxvY2suY29vcmRzKVxyXG5cdFx0XHR9KVxyXG5cdFx0KTtcclxuXHJcblx0XHRyZXR1cm4gYmxvY2tzO1xyXG5cdH1cclxufVxyXG5cclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENyU2Vzc2lvbjtcclxuIl19
